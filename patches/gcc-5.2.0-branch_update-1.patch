Submitted By: Jim Gifford (jim at cross-lfs dot org)
Date: 10-31-2015
Initial Package Version: 5.2.0
Origin: Upstream
Upstream Status: Applied
Description: This is a branch update for gcc-5.2.0, and should be
             rechecked periodically.

This patch was made from Revision #229636.

diff -Naur gcc-5.2.0.orig/boehm-gc/os_dep.c gcc-5.2.0/boehm-gc/os_dep.c
--- gcc-5.2.0.orig/boehm-gc/os_dep.c	2013-03-06 09:08:58.000000000 -0600
+++ gcc-5.2.0/boehm-gc/os_dep.c	2015-09-10 09:11:16.970564000 -0500
@@ -3184,13 +3184,11 @@
 	    	      		(GC_words_allocd + GC_words_allocd_before_gc));
 #	endif       
     }
-    sprintf(buf, "/proc/%d", getpid());
-    fd = open(buf, O_RDONLY);
-    if (fd < 0) {
+    sprintf(buf, "/proc/%d/pagedata", getpid());
+    GC_proc_fd = open(buf, O_RDONLY);
+    if (GC_proc_fd < 0) {
     	ABORT("/proc open failed");
     }
-    GC_proc_fd = syscall(SYS_ioctl, fd, PIOCOPENPD, 0);
-    close(fd);
     syscall(SYS_fcntl, GC_proc_fd, F_SETFD, FD_CLOEXEC);
     if (GC_proc_fd < 0) {
     	ABORT("/proc ioctl failed");
diff -Naur gcc-5.2.0.orig/contrib/download_prerequisites gcc-5.2.0/contrib/download_prerequisites
--- gcc-5.2.0.orig/contrib/download_prerequisites	2014-12-11 21:23:16.000000000 -0600
+++ gcc-5.2.0/contrib/download_prerequisites	2015-09-11 01:12:40.145086000 -0500
@@ -24,6 +24,11 @@
 # be downloaded.
 GRAPHITE_LOOP_OPT=yes
 
+if [ ! -e gcc/BASE-VER ] ; then
+	echo "You must run this script in the top level GCC source directory."
+	exit 1
+fi
+
 # Necessary to build GCC.
 MPFR=mpfr-2.4.2
 GMP=gmp-4.3.2
diff -Naur gcc-5.2.0.orig/fixincludes/fixincl.x gcc-5.2.0/fixincludes/fixincl.x
--- gcc-5.2.0.orig/fixincludes/fixincl.x	2015-05-22 08:13:11.000000000 -0500
+++ gcc-5.2.0/fixincludes/fixincl.x	2015-08-14 06:34:26.037693000 -0500
@@ -1,12 +1,12 @@
 /*  -*- buffer-read-only: t -*- vi: set ro:
- * 
- * DO NOT EDIT THIS FILE   (fixincl.x)
- * 
- * It has been AutoGen-ed  May 21, 2015 at 02:48:12 AM by AutoGen 5.18.3
- * From the definitions    inclhack.def
- * and the template file   fixincl
+ *
+ *DO NOT EDIT THIS FILE   (fixincl.x)
+ *
+ *It has been AutoGen-ed  August 13, 2015 at 05:25:50 PM by AutoGen 5.18.3
+ *From the definitions    inclhack.def
+ *and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Thu May 21 02:48:12 UTC 2015
+/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Aug 13 17:25:50 UTC 2015
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 229 fixup descriptions.
+ * This file contains 230 fixup descriptions.
  *
  * See README for more information.
  *
@@ -1503,6 +1503,50 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Aix_Stdio_Inline fix
+ */
+tSCC zAix_Stdio_InlineName[] =
+     "aix_stdio_inline";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zAix_Stdio_InlineList[] =
+  "stdio.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzAix_Stdio_InlineMachs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zAix_Stdio_InlineSelect0[] =
+       "#ifdef __cplusplus\\\n\
+}\\\n\
+\\\n\
+#ifdef ferror\\\n";
+
+#define    AIX_STDIO_INLINE_TEST_CT  1
+static tTestDesc aAix_Stdio_InlineTests[] = {
+  { TT_EGREP,    zAix_Stdio_InlineSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Aix_Stdio_Inline
+ */
+static const char* apzAix_Stdio_InlinePatch[] = {
+    "format",
+    "#ifdef __cplusplus\n\
+}\n\
+#endif\n\n\
+#if (defined(__cplusplus) && defined(__IBMCPP__))\n\
+#ifdef ferror\n",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Aix_Strtof_Const fix
  */
 tSCC zAix_Strtof_ConstName[] =
@@ -1516,7 +1560,9 @@
 /*
  *  Machine/OS name selection pattern
  */
-#define apzAix_Strtof_ConstMachs (const char**)NULL
+tSCC* apzAix_Strtof_ConstMachs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
 
 /*
  *  content selection pattern - do fix if pattern found
@@ -1551,7 +1597,9 @@
 /*
  *  Machine/OS name selection pattern
  */
-#define apzAix_SysmachineMachs (const char**)NULL
+tSCC* apzAix_SysmachineMachs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
 
 /*
  *  content selection pattern - do fix if pattern found
@@ -1586,7 +1634,9 @@
 /*
  *  Machine/OS name selection pattern
  */
-#define apzAix_Syswait_2Machs (const char**)NULL
+tSCC* apzAix_Syswait_2Machs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
 
 /*
  *  content selection pattern - do fix if pattern found
@@ -1621,7 +1671,9 @@
 /*
  *  Machine/OS name selection pattern
  */
-#define apzAix_VolatileMachs (const char**)NULL
+tSCC* apzAix_VolatileMachs[] = {
+        "*-*-aix*",
+        (const char*)NULL };
 
 /*
  *  content selection pattern - do fix if pattern found
@@ -9396,9 +9448,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          266
+#define REGEX_COUNT          267
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            229
+#define FIX_COUNT            230
 
 /*
  *  Enumerate the fixes
@@ -9435,6 +9487,7 @@
     AIX_STDINT_3_FIXIDX,
     AIX_STDINT_4_FIXIDX,
     AIX_STDINT_5_FIXIDX,
+    AIX_STDIO_INLINE_FIXIDX,
     AIX_STRTOF_CONST_FIXIDX,
     AIX_SYSMACHINE_FIXIDX,
     AIX_SYSWAIT_2_FIXIDX,
@@ -9791,6 +9844,11 @@
      AIX_STDINT_5_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aAix_Stdint_5Tests,   apzAix_Stdint_5Patch, 0 },
 
+  {  zAix_Stdio_InlineName,    zAix_Stdio_InlineList,
+     apzAix_Stdio_InlineMachs,
+     AIX_STDIO_INLINE_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aAix_Stdio_InlineTests,   apzAix_Stdio_InlinePatch, 0 },
+
   {  zAix_Strtof_ConstName,    zAix_Strtof_ConstList,
      apzAix_Strtof_ConstMachs,
      AIX_STRTOF_CONST_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
diff -Naur gcc-5.2.0.orig/fixincludes/inclhack.def gcc-5.2.0/fixincludes/inclhack.def
--- gcc-5.2.0.orig/fixincludes/inclhack.def	2015-05-22 08:13:11.000000000 -0500
+++ gcc-5.2.0/fixincludes/inclhack.def	2015-08-14 06:34:26.037693000 -0500
@@ -892,10 +892,32 @@
 };
 
 /*
+ * stdio.h on AIX defines ferror, clearerr and feof as C++ inline, which
+   produces wrong code with G++.
+ */
+fix = {
+    hackname  = aix_stdio_inline;
+    mach      = "*-*-aix*";
+    files     = stdio.h;
+    select    = "#ifdef __cplusplus\\\n"
+                "}\\\n\\\n"
+                "#ifdef ferror\\\n";
+    c_fix     = format;
+    c_fix_arg = "#ifdef __cplusplus\n"
+                "}\n"
+                "#endif\n\n"
+                "#if (defined(__cplusplus) && defined(__IBMCPP__))\n"
+                "#ifdef ferror\n";
+    test_text = "#ifdef __cplusplus\n}\n\n#ifdef ferror";
+};
+
+
+/*
  * stdlib.h on AIX 4.3 declares strtof() with a non-const first argument.
  */
 fix = {
     hackname  = aix_strtof_const;
+    mach      = "*-*-aix*";
     files     = stdlib.h;
     select    = "((extern[ \t]+)?float[ \t]+strtof)\\(char \\*, char \\*\\*\\);";
     c_fix     = format;
@@ -909,6 +931,7 @@
  */
 fix = {
     hackname  = aix_sysmachine;
+    mach      = "*-*-aix*";
     files     = sys/machine.h;
     select    = "\\\\ +\n";
     c_fix     = format;
@@ -923,6 +946,7 @@
  */
 fix = {
     hackname  = aix_syswait_2;
+    mach      = "*-*-aix*";
     files     = sys/wait.h;
     select    = '\? (\(\(\(\(unsigned[^)]*\)[^)]*\) >> [^)]*\) \& 0xff\) : -1)';
     c_fix     = format;
@@ -939,6 +963,7 @@
  */
 fix = {
     hackname  = aix_volatile;
+    mach      = "*-*-aix*";
     files     = sys/signal.h;
     select    = "typedef volatile int sig_atomic_t";
     c_fix     = format;
diff -Naur gcc-5.2.0.orig/fixincludes/tests/base/stdio.h gcc-5.2.0/fixincludes/tests/base/stdio.h
--- gcc-5.2.0.orig/fixincludes/tests/base/stdio.h	2011-08-10 03:43:38.000000000 -0500
+++ gcc-5.2.0/fixincludes/tests/base/stdio.h	2015-08-14 06:34:26.037693000 -0500
@@ -19,6 +19,16 @@
 #endif  /* AAB_AIX_STDIO_CHECK */
 
 
+#if defined( AIX_STDIO_INLINE_CHECK )
+#ifdef __cplusplus
+}
+#endif
+
+#if (defined(__cplusplus) && defined(__IBMCPP__))
+#ifdef ferror
+#endif  /* AIX_STDIO_INLINE_CHECK */
+
+
 #if defined( ALPHA_GETOPT_CHECK )
 extern int getopt(int, char *const[], const char *);
 #endif  /* ALPHA_GETOPT_CHECK */
diff -Naur gcc-5.2.0.orig/gcc/ada/gcc-interface/Make-lang.in gcc-5.2.0/gcc/ada/gcc-interface/Make-lang.in
--- gcc-5.2.0.orig/gcc/ada/gcc-interface/Make-lang.in	2015-03-02 05:03:29.000000000 -0600
+++ gcc-5.2.0/gcc/ada/gcc-interface/Make-lang.in	2015-10-09 03:14:21.872164000 -0500
@@ -1025,7 +1025,7 @@
 
 # When building from scratch we don't have dependency files, the only thing
 # we need to ensure is that the generated files are created first.
-$(GNAT1_ADA_OBJS) $(GNATBIND_OBJS): | $(ada_generated_files)
+$(GNAT1_OBJS) $(GNATBIND_OBJS): | $(ada_generated_files)
 
 # Manually include the auto-generated dependencies for the Ada host objects.
 ADA_DEPFILES = $(foreach obj,$(GNAT1_ADA_OBJS) $(GNATBIND_OBJS),\
diff -Naur gcc-5.2.0.orig/gcc/builtins.c gcc-5.2.0/gcc/builtins.c
--- gcc-5.2.0.orig/gcc/builtins.c	2015-07-15 06:55:00.000000000 -0500
+++ gcc-5.2.0/gcc/builtins.c	2015-10-08 11:54:23.551701000 -0500
@@ -5271,7 +5271,7 @@
   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);
   val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);
 
-  return expand_atomic_fetch_op (target, mem, val, code, MEMMODEL_SEQ_CST,
+  return expand_atomic_fetch_op (target, mem, val, code, MEMMODEL_SYNC_SEQ_CST,
 				 after);
 }
 
@@ -5301,8 +5301,8 @@
 	poval = &target;
     }
   if (!expand_atomic_compare_and_swap (pbool, poval, mem, old_val, new_val,
-				       false, MEMMODEL_SEQ_CST,
-				       MEMMODEL_SEQ_CST))
+				       false, MEMMODEL_SYNC_SEQ_CST,
+				       MEMMODEL_SYNC_SEQ_CST))
     return NULL_RTX;
 
   return target;
@@ -5337,7 +5337,7 @@
   /* Expand the operands.  */
   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);
 
-  expand_atomic_store (mem, const0_rtx, MEMMODEL_RELEASE, true);
+  expand_atomic_store (mem, const0_rtx, MEMMODEL_SYNC_RELEASE, true);
 }
 
 /* Given an integer representing an ``enum memmodel'', verify its
@@ -5366,7 +5366,8 @@
       return MEMMODEL_SEQ_CST;
     }
 
-  if ((INTVAL (op) & MEMMODEL_MASK) >= MEMMODEL_LAST)
+  /* Should never see a user explicit SYNC memodel model, so >= LAST works. */
+  if (memmodel_base (val) >= MEMMODEL_LAST)
     {
       warning (OPT_Winvalid_memory_model,
 	       "invalid memory model argument to builtin");
@@ -5433,8 +5434,7 @@
       success = MEMMODEL_SEQ_CST;
     }
  
-  if ((failure & MEMMODEL_MASK) == MEMMODEL_RELEASE
-      || (failure & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)
+  if (is_mm_release (failure) || is_mm_acq_rel (failure))
     {
       warning (OPT_Winvalid_memory_model,
 	       "invalid failure memory model for "
@@ -5496,8 +5496,7 @@
   enum memmodel model;
 
   model = get_memmodel (CALL_EXPR_ARG (exp, 1));
-  if ((model & MEMMODEL_MASK) == MEMMODEL_RELEASE
-      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)
+  if (is_mm_release (model) || is_mm_acq_rel (model))
     {
       warning (OPT_Winvalid_memory_model,
 	       "invalid memory model for %<__atomic_load%>");
@@ -5526,9 +5525,8 @@
   enum memmodel model;
 
   model = get_memmodel (CALL_EXPR_ARG (exp, 2));
-  if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED
-      && (model & MEMMODEL_MASK) != MEMMODEL_SEQ_CST
-      && (model & MEMMODEL_MASK) != MEMMODEL_RELEASE)
+  if (!(is_mm_relaxed (model) || is_mm_seq_cst (model)
+	|| is_mm_release (model)))
     {
       warning (OPT_Winvalid_memory_model,
 	       "invalid memory model for %<__atomic_store%>");
@@ -5635,9 +5633,7 @@
   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);
   model = get_memmodel (CALL_EXPR_ARG (exp, 1));
 
-  if ((model & MEMMODEL_MASK) == MEMMODEL_CONSUME
-      || (model & MEMMODEL_MASK) == MEMMODEL_ACQUIRE
-      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)
+  if (is_mm_consume (model) || is_mm_acquire (model) || is_mm_acq_rel (model))
     {
       warning (OPT_Winvalid_memory_model,
 	       "invalid memory model for %<__atomic_store%>");
@@ -5697,8 +5693,20 @@
   mode = mode_for_size (size, MODE_INT, 0);
   mode_align = GET_MODE_ALIGNMENT (mode);
 
-  if (TREE_CODE (arg1) == INTEGER_CST && INTVAL (expand_normal (arg1)) == 0)
-    type_align = mode_align;
+  if (TREE_CODE (arg1) == INTEGER_CST)
+    {
+      unsigned HOST_WIDE_INT val = UINTVAL (expand_normal (arg1));
+
+      /* Either this argument is null, or it's a fake pointer encoding
+         the alignment of the object.  */
+      val = val & -val;
+      val *= BITS_PER_UNIT;
+
+      if (val == 0 || mode_align < val)
+        type_align = mode_align;
+      else
+        type_align = val;
+    }
   else
     {
       tree ttype = TREE_TYPE (arg1);
@@ -5833,7 +5841,7 @@
 static void
 expand_builtin_sync_synchronize (void)
 {
-  expand_mem_thread_fence (MEMMODEL_SEQ_CST);
+  expand_mem_thread_fence (MEMMODEL_SYNC_SEQ_CST);
 }
 
 static rtx
diff -Naur gcc-5.2.0.orig/gcc/c/c-decl.c gcc-5.2.0/gcc/c/c-decl.c
--- gcc-5.2.0.orig/gcc/c/c-decl.c	2015-06-11 07:51:04.000000000 -0500
+++ gcc-5.2.0/gcc/c/c-decl.c	2015-09-09 02:30:42.229662000 -0500
@@ -8883,7 +8883,8 @@
   current_scope->bindings = NULL;
   for (; b; b = free_binding_and_advance (b))
     {
-      gcc_assert (TREE_CODE (b->decl) == PARM_DECL);
+      gcc_assert (TREE_CODE (b->decl) == PARM_DECL
+		  || b->decl == error_mark_node);
       gcc_assert (I_SYMBOL_BINDING (b->id) == b);
       I_SYMBOL_BINDING (b->id) = b->shadowed;
       if (b->shadowed && b->shadowed->u.type)
diff -Naur gcc-5.2.0.orig/gcc/c/c-parser.c gcc-5.2.0/gcc/c/c-parser.c
--- gcc-5.2.0.orig/gcc/c/c-parser.c	2015-05-22 03:10:32.000000000 -0500
+++ gcc-5.2.0/gcc/c/c-parser.c	2015-09-10 02:37:00.176754000 -0500
@@ -11185,9 +11185,9 @@
       tree alignment = c_parser_expr_no_commas (parser, NULL).value;
       mark_exp_read (alignment);
       alignment = c_fully_fold (alignment, false, NULL);
-      if (!INTEGRAL_TYPE_P (TREE_TYPE (alignment))
-	  && TREE_CODE (alignment) != INTEGER_CST
-	  && tree_int_cst_sgn (alignment) != 1)
+      if (TREE_CODE (alignment) != INTEGER_CST
+	  || !INTEGRAL_TYPE_P (TREE_TYPE (alignment))
+	  || tree_int_cst_sgn (alignment) != 1)
 	{
 	  error_at (clause_loc, "%<aligned%> clause alignment expression must "
 				"be positive constant integer expression");
@@ -11264,9 +11264,9 @@
   t = c_parser_expr_no_commas (parser, NULL).value;
   mark_exp_read (t);
   t = c_fully_fold (t, false, NULL);
-  if (!INTEGRAL_TYPE_P (TREE_TYPE (t))
-      && TREE_CODE (t) != INTEGER_CST
-      && tree_int_cst_sgn (t) != 1)
+  if (TREE_CODE (t) != INTEGER_CST
+      || !INTEGRAL_TYPE_P (TREE_TYPE (t))
+      || tree_int_cst_sgn (t) != 1)
     {
       error_at (clause_loc, "%<safelen%> clause expression must "
 			    "be positive constant integer expression");
@@ -11300,9 +11300,9 @@
   t = c_parser_expr_no_commas (parser, NULL).value;
   mark_exp_read (t);
   t = c_fully_fold (t, false, NULL);
-  if (!INTEGRAL_TYPE_P (TREE_TYPE (t))
-      && TREE_CODE (t) != INTEGER_CST
-      && tree_int_cst_sgn (t) != 1)
+  if (TREE_CODE (t) != INTEGER_CST
+      || !INTEGRAL_TYPE_P (TREE_TYPE (t))
+      || tree_int_cst_sgn (t) != 1)
     {
       error_at (clause_loc, "%<simdlen%> clause expression must "
 			    "be positive constant integer expression");
@@ -11706,7 +11706,7 @@
 
       first = false;
 
-      if (((mask >> c_kind) & 1) == 0 && !parser->error)
+      if (((mask >> c_kind) & 1) == 0)
 	{
 	  /* Remove the invalid clause(s) from the list to avoid
 	     confusing the rest of the compiler.  */
@@ -11935,7 +11935,7 @@
 
       first = false;
 
-      if (((mask >> c_kind) & 1) == 0 && !parser->error)
+      if (((mask >> c_kind) & 1) == 0)
 	{
 	  /* Remove the invalid clause(s) from the list to avoid
 	     confusing the rest of the compiler.  */
@@ -12379,6 +12379,7 @@
   bool structured_block = false;
   bool swapped = false;
   bool seq_cst = false;
+  bool non_lvalue_p;
 
   if (c_parser_next_token_is (parser, CPP_NAME))
     {
@@ -12432,20 +12433,33 @@
     {
     case OMP_ATOMIC_READ:
     case NOP_EXPR: /* atomic write */
-      v = c_parser_unary_expression (parser).value;
+      v = c_parser_cast_expression (parser, NULL).value;
+      non_lvalue_p = !lvalue_p (v);
       v = c_fully_fold (v, false, NULL);
       if (v == error_mark_node)
 	goto saw_error;
+      if (non_lvalue_p)
+	v = non_lvalue (v);
       loc = c_parser_peek_token (parser)->location;
       if (!c_parser_require (parser, CPP_EQ, "expected %<=%>"))
 	goto saw_error;
       if (code == NOP_EXPR)
-	lhs = c_parser_expression (parser).value;
+	{
+	  lhs = c_parser_expression (parser).value;
+	  lhs = c_fully_fold (lhs, false, NULL);
+	  if (lhs == error_mark_node)
+	    goto saw_error;
+	}
       else
-	lhs = c_parser_unary_expression (parser).value;
-      lhs = c_fully_fold (lhs, false, NULL);
-      if (lhs == error_mark_node)
-	goto saw_error;
+	{
+	  lhs = c_parser_cast_expression (parser, NULL).value;
+	  non_lvalue_p = !lvalue_p (lhs);
+	  lhs = c_fully_fold (lhs, false, NULL);
+	  if (lhs == error_mark_node)
+	    goto saw_error;
+	  if (non_lvalue_p)
+	    lhs = non_lvalue (lhs);
+	}
       if (code == NOP_EXPR)
 	{
 	  /* atomic write is represented by OMP_ATOMIC with NOP_EXPR
@@ -12464,10 +12478,13 @@
 	}
       else
 	{
-	  v = c_parser_unary_expression (parser).value;
+	  v = c_parser_cast_expression (parser, NULL).value;
+	  non_lvalue_p = !lvalue_p (v);
 	  v = c_fully_fold (v, false, NULL);
 	  if (v == error_mark_node)
 	    goto saw_error;
+	  if (non_lvalue_p)
+	    v = non_lvalue (v);
 	  if (!c_parser_require (parser, CPP_EQ, "expected %<=%>"))
 	    goto saw_error;
 	}
@@ -12480,7 +12497,7 @@
      old or new x should be captured.  */
 restart:
   eloc = c_parser_peek_token (parser)->location;
-  expr = c_parser_unary_expression (parser);
+  expr = c_parser_cast_expression (parser, NULL);
   lhs = expr.value;
   expr = default_function_array_conversion (eloc, expr);
   unfolded_lhs = expr.value;
@@ -12573,6 +12590,8 @@
 	}
       /* FALLTHRU */
     default:
+      if (!lvalue_p (unfolded_lhs))
+	lhs = non_lvalue (lhs);
       switch (c_parser_peek_token (parser)->type)
 	{
 	case CPP_MULT_EQ:
@@ -12687,20 +12706,25 @@
     {
       if (!c_parser_require (parser, CPP_SEMICOLON, "expected %<;%>"))
 	goto saw_error;
-      v = c_parser_unary_expression (parser).value;
+      v = c_parser_cast_expression (parser, NULL).value;
+      non_lvalue_p = !lvalue_p (v);
       v = c_fully_fold (v, false, NULL);
       if (v == error_mark_node)
 	goto saw_error;
+      if (non_lvalue_p)
+	v = non_lvalue (v);
       if (!c_parser_require (parser, CPP_EQ, "expected %<=%>"))
 	goto saw_error;
       eloc = c_parser_peek_token (parser)->location;
-      expr = c_parser_unary_expression (parser);
+      expr = c_parser_cast_expression (parser, NULL);
       lhs1 = expr.value;
       expr = default_function_array_read_conversion (eloc, expr);
       unfolded_lhs1 = expr.value;
       lhs1 = c_fully_fold (lhs1, false, NULL);
       if (lhs1 == error_mark_node)
 	goto saw_error;
+      if (!lvalue_p (unfolded_lhs1))
+	lhs1 = non_lvalue (lhs1);
     }
   if (structured_block)
     {
@@ -12802,7 +12826,8 @@
 		       tree clauses, tree *cclauses)
 {
   tree decl, cond, incr, save_break, save_cont, body, init, stmt, cl;
-  tree declv, condv, incrv, initv, ret = NULL;
+  tree declv, condv, incrv, initv, ret = NULL_TREE;
+  tree pre_body = NULL_TREE, this_pre_body;
   bool fail = false, open_brace_parsed = false;
   int i, collapse = 1, nbraces = 0;
   location_t for_loc;
@@ -12846,8 +12871,23 @@
 	{
 	  if (i > 0)
 	    vec_safe_push (for_block, c_begin_compound_stmt (true));
+	  this_pre_body = push_stmt_list ();
 	  c_parser_declaration_or_fndef (parser, true, true, true, true, true,
 					 NULL, vNULL);
+	  if (this_pre_body)
+	    {
+	      this_pre_body = pop_stmt_list (this_pre_body);
+	      if (pre_body)
+		{
+		  tree t = pre_body;   
+		  pre_body = push_stmt_list ();
+		  add_stmt (t);
+		  add_stmt (this_pre_body);
+		  pre_body = pop_stmt_list (pre_body);
+		}
+	      else
+		pre_body = this_pre_body;
+	    }
 	  decl = check_for_loop_decls (for_loc, flag_isoc99);
 	  if (decl == NULL)
 	    goto error_init;
@@ -13042,7 +13082,7 @@
   if (!fail)
     {
       stmt = c_finish_omp_for (loc, code, declv, initv, condv,
-			       incrv, body, NULL);
+			       incrv, body, pre_body);
       if (stmt)
 	{
 	  if (cclauses != NULL
diff -Naur gcc-5.2.0.orig/gcc/c/c-typeck.c gcc-5.2.0/gcc/c/c-typeck.c
--- gcc-5.2.0.orig/gcc/c/c-typeck.c	2015-03-10 01:38:57.000000000 -0500
+++ gcc-5.2.0/gcc/c/c-typeck.c	2015-10-05 07:35:20.216307000 -0500
@@ -5707,6 +5707,10 @@
   tree rname = NULL_TREE;
   bool objc_ok = false;
 
+  /* Use the expansion point location to handle cases such as user's
+     function returning a wrong-type macro defined in a system header.  */
+  location = expansion_point_location_if_in_system_header (location);
+
   if (errtype == ic_argpass)
     {
       tree selector;
@@ -9368,8 +9372,12 @@
   bool npc = false;
   size_t rank = 0;
 
+  /* Use the expansion point to handle cases such as returning NULL
+     in a function returning void.  */
+  source_location xloc = expansion_point_location_if_in_system_header (loc);
+
   if (TREE_THIS_VOLATILE (current_function_decl))
-    warning_at (loc, 0,
+    warning_at (xloc, 0,
 		"function declared %<noreturn%> has a %<return%> statement");
 
   if (flag_cilkplus && contains_array_notation_expr (retval))
@@ -9424,10 +9432,10 @@
     {
       current_function_returns_null = 1;
       if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)
-	pedwarn (loc, 0,
+	pedwarn (xloc, 0,
 		 "%<return%> with a value, in function returning void");
       else
-	pedwarn (loc, OPT_Wpedantic, "ISO C forbids "
+	pedwarn (xloc, OPT_Wpedantic, "ISO C forbids "
 		 "%<return%> with expression, in function returning void");
     }
   else
diff -Naur gcc-5.2.0.orig/gcc/calls.c gcc-5.2.0/gcc/calls.c
--- gcc-5.2.0.orig/gcc/calls.c	2015-04-30 06:11:34.000000000 -0500
+++ gcc-5.2.0/gcc/calls.c	2015-07-23 13:51:56.363755000 -0500
@@ -3115,6 +3115,19 @@
 
       compute_argument_addresses (args, argblock, num_actuals);
 
+      /* Stack is properly aligned, pops can't safely be deferred during
+	 the evaluation of the arguments.  */
+      NO_DEFER_POP;
+
+      /* Precompute all register parameters.  It isn't safe to compute
+	 anything once we have started filling any specific hard regs.
+	 TLS symbols sometimes need a call to resolve.  Precompute
+	 register parameters before any stack pointer manipulation
+	 to avoid unaligned stack in the called function.  */
+      precompute_register_parameters (num_actuals, args, &reg_parm_seen);
+
+      OK_DEFER_POP;
+
       /* Perform stack alignment before the first push (the last arg).  */
       if (argblock == 0
           && adjusted_args_size.constant > reg_parm_stack_space
@@ -3155,10 +3168,6 @@
 
       funexp = rtx_for_function_call (fndecl, addr);
 
-      /* Precompute all register parameters.  It isn't safe to compute anything
-	 once we have started filling any specific hard regs.  */
-      precompute_register_parameters (num_actuals, args, &reg_parm_seen);
-
       if (CALL_EXPR_STATIC_CHAIN (exp))
 	static_chain_value = expand_normal (CALL_EXPR_STATIC_CHAIN (exp));
       else
diff -Naur gcc-5.2.0.orig/gcc/c-family/c-common.c gcc-5.2.0/gcc/c-family/c-common.c
--- gcc-5.2.0.orig/gcc/c-family/c-common.c	2015-04-10 02:54:46.000000000 -0500
+++ gcc-5.2.0/gcc/c-family/c-common.c	2015-08-05 06:20:59.983324000 -0500
@@ -10741,7 +10741,7 @@
       if (TREE_CODE (p) == INTEGER_CST)
         {
 	  int i = tree_to_uhwi (p);
-	  if (i < 0 || (i & MEMMODEL_MASK) >= MEMMODEL_LAST)
+	  if (i < 0 || (memmodel_base (i) >= MEMMODEL_LAST))
 	    {
 	      warning_at (loc, OPT_Winvalid_memory_model,
 			  "invalid memory model argument %d of %qE", x + 1,
diff -Naur gcc-5.2.0.orig/gcc/c-family/c.opt gcc-5.2.0/gcc/c-family/c.opt
--- gcc-5.2.0.orig/gcc/c-family/c.opt	2015-03-27 05:29:04.000000000 -0500
+++ gcc-5.2.0/gcc/c-family/c.opt	2015-10-02 10:19:52.819852000 -0500
@@ -1592,7 +1592,7 @@
 
 std=c11
 C ObjC
-Conform to the ISO 2011 C standard (experimental and incomplete support)
+Conform to the ISO 2011 C standard
 
 std=c1x
 C ObjC Alias(std=c11)
@@ -1648,7 +1648,7 @@
 
 std=gnu11
 C ObjC
-Conform to the ISO 2011 C standard with GNU extensions (experimental and incomplete support)
+Conform to the ISO 2011 C standard with GNU extensions
 
 std=gnu1x
 C ObjC Alias(std=gnu11)
@@ -1688,7 +1688,7 @@
 
 std=iso9899:2011
 C ObjC Alias(std=c11)
-Conform to the ISO 2011 C standard (experimental and incomplete support)
+Conform to the ISO 2011 C standard
 
 traditional
 Driver
diff -Naur gcc-5.2.0.orig/gcc/c-family/c-ubsan.c gcc-5.2.0/gcc/c-family/c-ubsan.c
--- gcc-5.2.0.orig/gcc/c-family/c-ubsan.c	2015-03-06 17:44:56.000000000 -0600
+++ gcc-5.2.0/gcc/c-family/c-ubsan.c	2015-09-25 05:46:03.665534000 -0500
@@ -55,6 +55,7 @@
 #include "internal-fn.h"
 #include "stor-layout.h"
 #include "builtins.h"
+#include "gimplify.h"
 
 /* Instrument division by zero and INT_MIN / -1.  If not instrumenting,
    return NULL_TREE.  */
@@ -71,6 +72,9 @@
   gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (op0))
 	      == TYPE_MAIN_VARIANT (TREE_TYPE (op1)));
 
+  op0 = unshare_expr (op0);
+  op1 = unshare_expr (op1);
+
   if (TREE_CODE (type) == INTEGER_TYPE
       && (flag_sanitize & SANITIZE_DIVIDE))
     t = fold_build2 (EQ_EXPR, boolean_type_node,
@@ -117,6 +121,7 @@
 	}
     }
   t = fold_build2 (COMPOUND_EXPR, TREE_TYPE (t), op0, t);
+  t = fold_build2 (COMPOUND_EXPR, TREE_TYPE (t), op1, t);
   if (flag_sanitize_undefined_trap_on_error)
     tt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);
   else
@@ -151,6 +156,9 @@
   HOST_WIDE_INT op0_prec = TYPE_PRECISION (type0);
   tree uprecm1 = build_int_cst (op1_utype, op0_prec - 1);
 
+  op0 = unshare_expr (op0);
+  op1 = unshare_expr (op1);
+
   t = fold_convert_loc (loc, op1_utype, op1);
   t = fold_build2 (GT_EXPR, boolean_type_node, t, uprecm1);
 
diff -Naur gcc-5.2.0.orig/gcc/cfgexpand.c gcc-5.2.0/gcc/cfgexpand.c
--- gcc-5.2.0.orig/gcc/cfgexpand.c	2015-03-16 06:17:32.000000000 -0500
+++ gcc-5.2.0/gcc/cfgexpand.c	2015-07-23 05:39:26.086189000 -0500
@@ -3219,18 +3219,25 @@
   bounds_rtl = DECL_BOUNDS_RTL (DECL_RESULT (current_function_decl));
   if (bounds_rtl)
     {
-      rtx addr, bnd;
+      rtx addr = NULL;
+      rtx bnd = NULL;
 
-      if (bounds)
+      if (bounds && bounds != error_mark_node)
 	{
 	  bnd = expand_normal (bounds);
 	  targetm.calls.store_returned_bounds (bounds_rtl, bnd);
 	}
       else if (REG_P (bounds_rtl))
 	{
-	  addr = expand_normal (build_fold_addr_expr (retval_rhs));
-	  addr = gen_rtx_MEM (Pmode, addr);
-	  bnd = targetm.calls.load_bounds_for_arg (addr, NULL, NULL);
+	  if (bounds)
+	    bnd = chkp_expand_zero_bounds ();
+	  else
+	    {
+	      addr = expand_normal (build_fold_addr_expr (retval_rhs));
+	      addr = gen_rtx_MEM (Pmode, addr);
+	      bnd = targetm.calls.load_bounds_for_arg (addr, NULL, NULL);
+	    }
+
 	  targetm.calls.store_returned_bounds (bounds_rtl, bnd);
 	}
       else
@@ -3239,15 +3246,23 @@
 
 	  gcc_assert (GET_CODE (bounds_rtl) == PARALLEL);
 
-	  addr = expand_normal (build_fold_addr_expr (retval_rhs));
-	  addr = gen_rtx_MEM (Pmode, addr);
+	  if (bounds)
+	    bnd = chkp_expand_zero_bounds ();
+	  else
+	    {
+	      addr = expand_normal (build_fold_addr_expr (retval_rhs));
+	      addr = gen_rtx_MEM (Pmode, addr);
+	    }
 
 	  for (n = 0; n < XVECLEN (bounds_rtl, 0); n++)
 	    {
-	      rtx offs = XEXP (XVECEXP (bounds_rtl, 0, n), 1);
 	      rtx slot = XEXP (XVECEXP (bounds_rtl, 0, n), 0);
-	      rtx from = adjust_address (addr, Pmode, INTVAL (offs));
-	      rtx bnd = targetm.calls.load_bounds_for_arg (from, NULL, NULL);
+	      if (!bounds)
+		{
+		  rtx offs = XEXP (XVECEXP (bounds_rtl, 0, n), 1);
+		  rtx from = adjust_address (addr, Pmode, INTVAL (offs));
+		  bnd = targetm.calls.load_bounds_for_arg (from, NULL, NULL);
+		}
 	      targetm.calls.store_returned_bounds (slot, bnd);
 	    }
 	}
@@ -3344,33 +3359,40 @@
       break;
 
     case GIMPLE_RETURN:
-      op0 = gimple_return_retval (as_a <greturn *> (stmt));
-
-      if (op0 && op0 != error_mark_node)
-	{
-	  tree result = DECL_RESULT (current_function_decl);
-
-	  /* If we are not returning the current function's RESULT_DECL,
-	     build an assignment to it.  */
-	  if (op0 != result)
-	    {
-	      /* I believe that a function's RESULT_DECL is unique.  */
-	      gcc_assert (TREE_CODE (op0) != RESULT_DECL);
-
-	      /* ??? We'd like to use simply expand_assignment here,
-	         but this fails if the value is of BLKmode but the return
-		 decl is a register.  expand_return has special handling
-		 for this combination, which eventually should move
-		 to common code.  See comments there.  Until then, let's
-		 build a modify expression :-/  */
-	      op0 = build2 (MODIFY_EXPR, TREE_TYPE (result),
-			    result, op0);
-	    }
-	}
-      if (!op0)
-	expand_null_return ();
-      else
-	expand_return (op0, gimple_return_retbnd (stmt));
+      {
+	tree bnd = gimple_return_retbnd (as_a <greturn *> (stmt));
+	op0 = gimple_return_retval (as_a <greturn *> (stmt));
+
+	if (op0 && op0 != error_mark_node)
+	  {
+	    tree result = DECL_RESULT (current_function_decl);
+
+	    /* If we are not returning the current function's RESULT_DECL,
+	       build an assignment to it.  */
+	    if (op0 != result)
+	      {
+		/* I believe that a function's RESULT_DECL is unique.  */
+		gcc_assert (TREE_CODE (op0) != RESULT_DECL);
+
+		/* ??? We'd like to use simply expand_assignment here,
+		   but this fails if the value is of BLKmode but the return
+		   decl is a register.  expand_return has special handling
+		   for this combination, which eventually should move
+		   to common code.  See comments there.  Until then, let's
+		   build a modify expression :-/  */
+		op0 = build2 (MODIFY_EXPR, TREE_TYPE (result),
+			      result, op0);
+	      }
+	    /* Mark we have return statement with missing bounds.  */
+	    if (!bnd && chkp_function_instrumented_p (cfun->decl))
+	      bnd = error_mark_node;
+	  }
+
+	if (!op0)
+	  expand_null_return ();
+	else
+	  expand_return (op0, bnd);
+      }
       break;
 
     case GIMPLE_ASSIGN:
diff -Naur gcc-5.2.0.orig/gcc/combine.c gcc-5.2.0/gcc/combine.c
--- gcc-5.2.0.orig/gcc/combine.c	2015-04-09 09:37:14.000000000 -0500
+++ gcc-5.2.0/gcc/combine.c	2015-08-18 07:21:41.551020000 -0500
@@ -11960,14 +11960,15 @@
 	      continue;
 	    }
 
-	  /* If this is (and:M1 (subreg:M2 X 0) (const_int C1)) where C1
+	  /* If this is (and:M1 (subreg:M1 X:M2 0) (const_int C1)) where C1
 	     fits in both M1 and M2 and the SUBREG is either paradoxical
 	     or represents the low part, permute the SUBREG and the AND
 	     and try again.  */
-	  if (GET_CODE (XEXP (op0, 0)) == SUBREG)
+	  if (GET_CODE (XEXP (op0, 0)) == SUBREG
+	      && CONST_INT_P (XEXP (op0, 1)))
 	    {
-	      unsigned HOST_WIDE_INT c1;
 	      tmode = GET_MODE (SUBREG_REG (XEXP (op0, 0)));
+	      unsigned HOST_WIDE_INT c1 = INTVAL (XEXP (op0, 1));
 	      /* Require an integral mode, to avoid creating something like
 		 (AND:SF ...).  */
 	      if (SCALAR_INT_MODE_P (tmode)
@@ -11977,18 +11978,22 @@
 		     have a defined value due to the AND operation.
 		     However, if we commute the AND inside the SUBREG then
 		     they no longer have defined values and the meaning of
-		     the code has been changed.  */
+		     the code has been changed.
+		     Also C1 should not change value in the smaller mode,
+		     see PR67028 (a positive C1 can become negative in the
+		     smaller mode, so that the AND does no longer mask the
+		     upper bits).  */
 		  && (0
 #ifdef WORD_REGISTER_OPERATIONS
 		      || (mode_width > GET_MODE_PRECISION (tmode)
-			  && mode_width <= BITS_PER_WORD)
+			  && mode_width <= BITS_PER_WORD
+			  && trunc_int_for_mode (c1, tmode) == (HOST_WIDE_INT) c1)
 #endif
 		      || (mode_width <= GET_MODE_PRECISION (tmode)
 			  && subreg_lowpart_p (XEXP (op0, 0))))
-		  && CONST_INT_P (XEXP (op0, 1))
 		  && mode_width <= HOST_BITS_PER_WIDE_INT
 		  && HWI_COMPUTABLE_MODE_P (tmode)
-		  && ((c1 = INTVAL (XEXP (op0, 1))) & ~mask) == 0
+		  && (c1 & ~mask) == 0
 		  && (c1 & ~GET_MODE_MASK (tmode)) == 0
 		  && c1 != mask
 		  && c1 != GET_MODE_MASK (tmode))
diff -Naur gcc-5.2.0.orig/gcc/config/aarch64/aarch64.c gcc-5.2.0/gcc/config/aarch64/aarch64.c
--- gcc-5.2.0.orig/gcc/config/aarch64/aarch64.c	2015-06-24 04:59:28.000000000 -0500
+++ gcc-5.2.0/gcc/config/aarch64/aarch64.c	2015-08-05 06:40:25.689425000 -0500
@@ -5246,11 +5246,17 @@
       if (speed)
 	{
 	  /* Floating-point FMA/FMUL can also support negations of the
-	     operands.  */
-	  if (GET_CODE (op0) == NEG)
-	    op0 = XEXP (op0, 0);
-	  if (GET_CODE (op1) == NEG)
-	    op1 = XEXP (op1, 0);
+	     operands, unless the rounding mode is upward or downward in
+	     which case FNMUL is different than FMUL with operand negation.  */
+	  bool neg0 = GET_CODE (op0) == NEG;
+	  bool neg1 = GET_CODE (op1) == NEG;
+	  if (maybe_fma || !flag_rounding_math || (neg0 && neg1))
+	    {
+	      if (neg0)
+		op0 = XEXP (op0, 0);
+	      if (neg1)
+		op1 = XEXP (op1, 0);
+	    }
 
 	  if (maybe_fma)
 	    /* FMADD/FNMADD/FNMSUB/FMSUB.  */
@@ -5694,6 +5700,12 @@
               *cost = rtx_cost (op0, NEG, 0, speed);
               return true;
             }
+	  if (GET_CODE (op0) == MULT)
+	    {
+	      /* FNMUL.  */
+	      *cost = rtx_cost (op0, NEG, 0, speed);
+	      return true;
+	    }
 	  if (speed)
 	    /* FNEG.  */
 	    *cost += extra_cost->fp[mode == DFmode].neg;
@@ -9020,8 +9032,8 @@
      unlikely event of fail being ACQUIRE and succ being RELEASE we need to
      promote succ to ACQ_REL so that we don't lose the acquire semantics.  */
 
-  if (INTVAL (mod_f) == MEMMODEL_ACQUIRE
-      && INTVAL (mod_s) == MEMMODEL_RELEASE)
+  if (is_mm_acquire (memmodel_from_int (INTVAL (mod_f)))
+      && is_mm_release (memmodel_from_int (INTVAL (mod_s))))
     mod_s = GEN_INT (MEMMODEL_ACQ_REL);
 
   switch (mode)
@@ -9066,6 +9078,23 @@
   emit_insn (gen_rtx_SET (VOIDmode, bval, x));
 }
 
+/* Emit a barrier, that is appropriate for memory model MODEL, at the end of a
+   sequence implementing an atomic operation.  */
+
+static void
+aarch64_emit_post_barrier (enum memmodel model)
+{
+  const enum memmodel base_model = memmodel_base (model);
+
+  if (is_mm_sync (model)
+      && (base_model == MEMMODEL_ACQUIRE
+	  || base_model == MEMMODEL_ACQ_REL
+	  || base_model == MEMMODEL_SEQ_CST))
+    {
+      emit_insn (gen_mem_thread_fence (GEN_INT (MEMMODEL_SEQ_CST)));
+    }
+}
+
 /* Split a compare and swap pattern.  */
 
 void
@@ -9076,14 +9105,18 @@
   bool is_weak;
   rtx_code_label *label1, *label2;
   rtx x, cond;
+  enum memmodel model;
+  rtx model_rtx;
 
   rval = operands[0];
   mem = operands[1];
   oldval = operands[2];
   newval = operands[3];
   is_weak = (operands[4] != const0_rtx);
+  model_rtx = operands[5];
   scratch = operands[7];
   mode = GET_MODE (mem);
+  model = memmodel_from_int (INTVAL (model_rtx));
 
   label1 = NULL;
   if (!is_weak)
@@ -9093,7 +9126,13 @@
     }
   label2 = gen_label_rtx ();
 
-  aarch64_emit_load_exclusive (mode, rval, mem, operands[5]);
+  /* The initial load can be relaxed for a __sync operation since a final
+     barrier will be emitted to stop code hoisting.  */
+  if (is_mm_sync (model))
+    aarch64_emit_load_exclusive (mode, rval, mem,
+				 GEN_INT (MEMMODEL_RELAXED));
+  else
+    aarch64_emit_load_exclusive (mode, rval, mem, model_rtx);
 
   cond = aarch64_gen_compare_reg (NE, rval, oldval);
   x = gen_rtx_NE (VOIDmode, cond, const0_rtx);
@@ -9101,7 +9140,7 @@
 			    gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);
   aarch64_emit_unlikely_jump (gen_rtx_SET (VOIDmode, pc_rtx, x));
 
-  aarch64_emit_store_exclusive (mode, scratch, mem, newval, operands[5]);
+  aarch64_emit_store_exclusive (mode, scratch, mem, newval, model_rtx);
 
   if (!is_weak)
     {
@@ -9118,6 +9157,10 @@
     }
 
   emit_label (label2);
+
+  /* Emit any final barrier needed for a __sync operation.  */
+  if (is_mm_sync (model))
+    aarch64_emit_post_barrier (model);
 }
 
 /* Split an atomic operation.  */
@@ -9128,6 +9171,8 @@
 {
   machine_mode mode = GET_MODE (mem);
   machine_mode wmode = (mode == DImode ? DImode : SImode);
+  const enum memmodel model = memmodel_from_int (INTVAL (model_rtx));
+  const bool is_sync = is_mm_sync (model);
   rtx_code_label *label;
   rtx x;
 
@@ -9142,7 +9187,13 @@
     old_out = new_out;
   value = simplify_gen_subreg (wmode, value, mode, 0);
 
-  aarch64_emit_load_exclusive (mode, old_out, mem, model_rtx);
+  /* The initial load can be relaxed for a __sync operation since a final
+     barrier will be emitted to stop code hoisting.  */
+ if (is_sync)
+    aarch64_emit_load_exclusive (mode, old_out, mem,
+				 GEN_INT (MEMMODEL_RELAXED));
+  else
+    aarch64_emit_load_exclusive (mode, old_out, mem, model_rtx);
 
   switch (code)
     {
@@ -9178,6 +9229,10 @@
   x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,
 			    gen_rtx_LABEL_REF (Pmode, label), pc_rtx);
   aarch64_emit_unlikely_jump (gen_rtx_SET (VOIDmode, pc_rtx, x));
+
+  /* Emit any final barrier needed for a __sync operation.  */
+  if (is_sync)
+    aarch64_emit_post_barrier (model);
 }
 
 static void
diff -Naur gcc-5.2.0.orig/gcc/config/aarch64/aarch64-elf-raw.h gcc-5.2.0/gcc/config/aarch64/aarch64-elf-raw.h
--- gcc-5.2.0.orig/gcc/config/aarch64/aarch64-elf-raw.h	2015-05-12 03:49:59.000000000 -0500
+++ gcc-5.2.0/gcc/config/aarch64/aarch64-elf-raw.h	2015-07-24 11:02:46.263397000 -0500
@@ -44,7 +44,12 @@
 #endif
 
 #ifndef LINK_SPEC
-#define LINK_SPEC "%{mbig-endian:-EB} %{mlittle-endian:-EL} -X \
+#define LINK_SPEC "%{h*}			\
+   %{static:-Bstatic}				\
+   %{shared:-shared}				\
+   %{symbolic:-Bsymbolic}			\
+   %{!static:%{rdynamic:-export-dynamic}}	\
+   %{mbig-endian:-EB} %{mlittle-endian:-EL} -X	\
   -maarch64elf%{mabi=ilp32*:32}%{mbig-endian:b}" \
   CA53_ERR_835769_SPEC \
   CA53_ERR_843419_SPEC
diff -Naur gcc-5.2.0.orig/gcc/config/aarch64/aarch64-linux.h gcc-5.2.0/gcc/config/aarch64/aarch64-linux.h
--- gcc-5.2.0.orig/gcc/config/aarch64/aarch64-linux.h	2015-05-12 03:49:59.000000000 -0500
+++ gcc-5.2.0/gcc/config/aarch64/aarch64-linux.h	2015-07-24 11:00:26.564818000 -0500
@@ -35,8 +35,9 @@
    %{static:-Bstatic}				\
    %{shared:-shared}				\
    %{symbolic:-Bsymbolic}			\
-   %{rdynamic:-export-dynamic}			\
-   -dynamic-linker " GNU_USER_DYNAMIC_LINKER "	\
+   %{!static:					\
+     %{rdynamic:-export-dynamic}		\
+     %{!shared:-dynamic-linker " GNU_USER_DYNAMIC_LINKER "}} \
    -X						\
    %{mbig-endian:-EB} %{mlittle-endian:-EL}     \
    -maarch64linux%{mabi=ilp32:32}%{mbig-endian:b}"
diff -Naur gcc-5.2.0.orig/gcc/config/aarch64/aarch64.md gcc-5.2.0/gcc/config/aarch64/aarch64.md
--- gcc-5.2.0.orig/gcc/config/aarch64/aarch64.md	2015-02-28 02:37:48.000000000 -0600
+++ gcc-5.2.0/gcc/config/aarch64/aarch64.md	2015-10-28 08:32:17.454275000 -0500
@@ -382,7 +382,7 @@
 )
 
 (define_insn "prefetch"
-  [(prefetch (match_operand:DI 0 "address_operand" "r")
+  [(prefetch (match_operand:DI 0 "register_operand" "r")
             (match_operand:QI 1 "const_int_operand" "")
             (match_operand:QI 2 "const_int_operand" ""))]
   ""
@@ -872,7 +872,7 @@
    fmov\\t%w0, %s1
    fmov\\t%s0, %s1"
    "CONST_INT_P (operands[1]) && !aarch64_move_imm (INTVAL (operands[1]), SImode)
-    && GP_REGNUM_P (REGNO (operands[0]))"
+    && REG_P (operands[0]) && GP_REGNUM_P (REGNO (operands[0]))"
    [(const_int 0)]
    "{
        aarch64_expand_mov_immediate (operands[0], operands[1]);
@@ -905,7 +905,7 @@
    fmov\\t%d0, %d1
    movi\\t%d0, %1"
    "(CONST_INT_P (operands[1]) && !aarch64_move_imm (INTVAL (operands[1]), DImode))
-    && GP_REGNUM_P (REGNO (operands[0]))"
+    && REG_P (operands[0]) && GP_REGNUM_P (REGNO (operands[0]))"
    [(const_int 0)]
    "{
        aarch64_expand_mov_immediate (operands[0], operands[1]);
@@ -3971,6 +3971,16 @@
         (mult:GPF
 		 (neg:GPF (match_operand:GPF 1 "register_operand" "w"))
 		 (match_operand:GPF 2 "register_operand" "w")))]
+  "TARGET_FLOAT && !flag_rounding_math"
+  "fnmul\\t%<s>0, %<s>1, %<s>2"
+  [(set_attr "type" "fmul<s>")]
+)
+
+(define_insn "*fnmul<mode>3"
+  [(set (match_operand:GPF 0 "register_operand" "=w")
+        (neg:GPF (mult:GPF
+		 (match_operand:GPF 1 "register_operand" "w")
+		 (match_operand:GPF 2 "register_operand" "w"))))]
   "TARGET_FLOAT"
   "fnmul\\t%<s>0, %<s>1, %<s>2"
   [(set_attr "type" "fmul<s>")]
diff -Naur gcc-5.2.0.orig/gcc/config/aarch64/atomics.md gcc-5.2.0/gcc/config/aarch64/atomics.md
--- gcc-5.2.0.orig/gcc/config/aarch64/atomics.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/aarch64/atomics.md	2015-09-23 04:48:16.591988000 -0500
@@ -119,7 +119,7 @@
   [(set (match_operand:ALLI 0 "aarch64_sync_memory_operand" "+Q")
     (unspec_volatile:ALLI
       [(atomic_op:ALLI (match_dup 0)
-	(match_operand:ALLI 1 "<atomic_op_operand>" "r<lconst_atomic>"))
+	(match_operand:ALLI 1 "<atomic_op_operand>" "r<const_atomic>"))
        (match_operand:SI 2 "const_int_operand")]		;; model
       UNSPECV_ATOMIC_OP))
        (clobber (reg:CC CC_REGNUM))
@@ -164,7 +164,7 @@
    (set (match_dup 1)
     (unspec_volatile:ALLI
       [(atomic_op:ALLI (match_dup 1)
-	(match_operand:ALLI 2 "<atomic_op_operand>" "r<lconst_atomic>"))
+	(match_operand:ALLI 2 "<atomic_op_operand>" "r<const_atomic>"))
        (match_operand:SI 3 "const_int_operand")]		;; model
       UNSPECV_ATOMIC_OP))
    (clobber (reg:CC CC_REGNUM))
@@ -209,7 +209,7 @@
   [(set (match_operand:ALLI 0 "register_operand" "=&r")
     (atomic_op:ALLI
       (match_operand:ALLI 1 "aarch64_sync_memory_operand" "+Q")
-      (match_operand:ALLI 2 "<atomic_op_operand>" "r<lconst_atomic>")))
+      (match_operand:ALLI 2 "<atomic_op_operand>" "r<const_atomic>")))
    (set (match_dup 1)
     (unspec_volatile:ALLI
       [(match_dup 1) (match_dup 2)
@@ -260,10 +260,8 @@
       UNSPECV_LDA))]
   ""
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-    if (model == MEMMODEL_RELAXED
-	|| model == MEMMODEL_CONSUME
-	|| model == MEMMODEL_RELEASE)
+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))
       return "ldr<atomic_sfx>\t%<w>0, %1";
     else
       return "ldar<atomic_sfx>\t%<w>0, %1";
@@ -278,10 +276,8 @@
       UNSPECV_STL))]
   ""
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-    if (model == MEMMODEL_RELAXED
-	|| model == MEMMODEL_CONSUME
-	|| model == MEMMODEL_ACQUIRE)
+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_acquire (model))
       return "str<atomic_sfx>\t%<w>1, %0";
     else
       return "stlr<atomic_sfx>\t%<w>1, %0";
@@ -297,10 +293,8 @@
 	UNSPECV_LX)))]
   ""
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-    if (model == MEMMODEL_RELAXED
-	|| model == MEMMODEL_CONSUME
-	|| model == MEMMODEL_RELEASE)
+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))
       return "ldxr<atomic_sfx>\t%w0, %1";
     else
       return "ldaxr<atomic_sfx>\t%w0, %1";
@@ -315,10 +309,8 @@
       UNSPECV_LX))]
   ""
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-    if (model == MEMMODEL_RELAXED
-	|| model == MEMMODEL_CONSUME
-	|| model == MEMMODEL_RELEASE)
+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))
       return "ldxr\t%<w>0, %1";
     else
       return "ldaxr\t%<w>0, %1";
@@ -335,10 +327,8 @@
       UNSPECV_SX))]
   ""
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[3]);
-    if (model == MEMMODEL_RELAXED
-	|| model == MEMMODEL_CONSUME
-	|| model == MEMMODEL_ACQUIRE)
+    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_acquire (model))
       return "stxr<atomic_sfx>\t%w0, %<w>2, %1";
     else
       return "stlxr<atomic_sfx>\t%w0, %<w>2, %1";
@@ -349,8 +339,8 @@
   [(match_operand:SI 0 "const_int_operand" "")]
   ""
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[0]);
-    if (model != MEMMODEL_RELAXED && model != MEMMODEL_CONSUME)
+    enum memmodel model = memmodel_from_int (INTVAL (operands[0]));
+    if (!(is_mm_relaxed (model) || is_mm_consume (model)))
       emit_insn (gen_dmb (operands[0]));
     DONE;
   }
@@ -373,8 +363,8 @@
      UNSPEC_MB))]
   ""
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[1]);
-    if (model == MEMMODEL_ACQUIRE)
+    enum memmodel model = memmodel_from_int (INTVAL (operands[1]));
+    if (is_mm_acquire (model))
       return "dmb\\tishld";
     else
       return "dmb\\tish";
diff -Naur gcc-5.2.0.orig/gcc/config/aarch64/iterators.md gcc-5.2.0/gcc/config/aarch64/iterators.md
--- gcc-5.2.0.orig/gcc/config/aarch64/iterators.md	2015-06-02 06:14:16.000000000 -0500
+++ gcc-5.2.0/gcc/config/aarch64/iterators.md	2015-09-23 04:48:16.591988000 -0500
@@ -342,9 +342,6 @@
 ;; Attribute to describe constants acceptable in logical operations
 (define_mode_attr lconst [(SI "K") (DI "L")])
 
-;; Attribute to describe constants acceptable in atomic logical operations
-(define_mode_attr lconst_atomic [(QI "K") (HI "K") (SI "K") (DI "L")])
-
 ;; Map a mode to a specific constraint character.
 (define_mode_attr cmode [(QI "q") (HI "h") (SI "s") (DI "d")])
 
@@ -845,6 +842,16 @@
    (plus "aarch64_plus_operand")
    (minus "aarch64_plus_operand")])
 
+;; Constants acceptable for atomic operations.
+;; This definition must appear in this file before the iterators it refers to.
+(define_code_attr const_atomic
+ [(plus "IJ") (minus "IJ")
+  (xor "<lconst_atomic>") (ior "<lconst_atomic>")
+  (and "<lconst_atomic>")])
+
+;; Attribute to describe constants acceptable in atomic logical operations
+(define_mode_attr lconst_atomic [(QI "K") (HI "K") (SI "K") (DI "L")])
+
 ;; -------------------------------------------------------------------
 ;; Int Iterators.
 ;; -------------------------------------------------------------------
diff -Naur gcc-5.2.0.orig/gcc/config/alpha/alpha.c gcc-5.2.0/gcc/config/alpha/alpha.c
--- gcc-5.2.0.orig/gcc/config/alpha/alpha.c	2015-05-16 02:42:20.000000000 -0500
+++ gcc-5.2.0/gcc/config/alpha/alpha.c	2015-08-05 06:20:59.983324000 -0500
@@ -4548,8 +4548,8 @@
   oldval = operands[3];
   newval = operands[4];
   is_weak = (operands[5] != const0_rtx);
-  mod_s = (enum memmodel) INTVAL (operands[6]);
-  mod_f = (enum memmodel) INTVAL (operands[7]);
+  mod_s = memmodel_from_int (INTVAL (operands[6]));
+  mod_f = memmodel_from_int (INTVAL (operands[7]));
   mode = GET_MODE (mem);
 
   alpha_pre_atomic_barrier (mod_s);
@@ -4587,12 +4587,12 @@
       emit_unlikely_jump (x, label1);
     }
 
-  if (mod_f != MEMMODEL_RELAXED)
+  if (!is_mm_relaxed (mod_f))
     emit_label (XEXP (label2, 0));
 
   alpha_post_atomic_barrier (mod_s);
 
-  if (mod_f == MEMMODEL_RELAXED)
+  if (is_mm_relaxed (mod_f))
     emit_label (XEXP (label2, 0));
 }
 
@@ -4653,8 +4653,8 @@
   newval = operands[4];
   align = operands[5];
   is_weak = (operands[6] != const0_rtx);
-  mod_s = (enum memmodel) INTVAL (operands[7]);
-  mod_f = (enum memmodel) INTVAL (operands[8]);
+  mod_s = memmodel_from_int (INTVAL (operands[7]));
+  mod_f = memmodel_from_int (INTVAL (operands[8]));
   scratch = operands[9];
   mode = GET_MODE (orig_mem);
   addr = XEXP (orig_mem, 0);
@@ -4706,12 +4706,12 @@
       emit_unlikely_jump (x, label1);
     }
 
-  if (mod_f != MEMMODEL_RELAXED)
+  if (!is_mm_relaxed (mod_f))
     emit_label (XEXP (label2, 0));
 
   alpha_post_atomic_barrier (mod_s);
 
-  if (mod_f == MEMMODEL_RELAXED)
+  if (is_mm_relaxed (mod_f))
     emit_label (XEXP (label2, 0));
 }
 
diff -Naur gcc-5.2.0.orig/gcc/config/arm/arm.c gcc-5.2.0/gcc/config/arm/arm.c
--- gcc-5.2.0.orig/gcc/config/arm/arm.c	2015-07-06 12:32:07.000000000 -0500
+++ gcc-5.2.0/gcc/config/arm/arm.c	2015-10-27 08:46:15.949493000 -0500
@@ -10269,7 +10269,7 @@
 
 	  *cost = COSTS_N_INSNS (1);
 
-	  if (GET_CODE (op0) == NEG)
+	  if (GET_CODE (op0) == NEG && !flag_rounding_math)
 	    op0 = XEXP (op0, 0);
 
 	  if (speed_p)
@@ -10345,6 +10345,13 @@
       if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
 	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	{
+	  if (GET_CODE (XEXP (x, 0)) == MULT)
+	    {
+	      /* VNMUL.  */
+	      *cost = rtx_cost (XEXP (x, 0), NEG, 0, speed_p);
+	      return true;
+	    }
+
 	  *cost = COSTS_N_INSNS (1);
 	  if (speed_p)
 	    *cost += extra_cost->fp[mode != SFmode].neg;
@@ -27537,25 +27544,36 @@
   return 0;
 }
 
+/* If X is a CONST_DOUBLE with a value that is a power of 2 whose
+   log2 is in [1, 32], return that log2.  Otherwise return -1.
+   This is used in the patterns for vcvt.s32.f32 floating-point to
+   fixed-point conversions.  */
+
 int
-vfp3_const_double_for_bits (rtx operand)
+vfp3_const_double_for_bits (rtx x)
 {
-  REAL_VALUE_TYPE r0;
+  if (!CONST_DOUBLE_P (x))
+    return -1;
 
-  if (!CONST_DOUBLE_P (operand))
-    return 0;
+  REAL_VALUE_TYPE r;
 
-  REAL_VALUE_FROM_CONST_DOUBLE (r0, operand);
-  if (exact_real_truncate (DFmode, &r0))
-    {
-      HOST_WIDE_INT value = real_to_integer (&r0);
-      value = value & 0xffffffff;
-      if ((value != 0) && ( (value & (value - 1)) == 0))
-	return int_log2 (value);
-    }
+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+  if (REAL_VALUE_NEGATIVE (r)
+      || REAL_VALUE_ISNAN (r)
+      || REAL_VALUE_ISINF (r)
+      || !real_isinteger (&r, SFmode))
+    return -1;
 
-  return 0;
+  HOST_WIDE_INT hwint = exact_log2 (real_to_integer (&r));
+
+  /* The exact_log2 above will have returned -1 if this is
+     not an exact log2.  */
+  if (!IN_RANGE (hwint, 1, 32))
+    return -1;
+
+  return hwint;
 }
+
 
 /* Emit a memory barrier around an atomic sequence according to MODEL.  */
 
@@ -27678,8 +27696,8 @@
      promote succ to ACQ_REL so that we don't lose the acquire semantics.  */
 
   if (TARGET_HAVE_LDACQ
-      && INTVAL (mod_f) == MEMMODEL_ACQUIRE
-      && INTVAL (mod_s) == MEMMODEL_RELEASE)
+      && is_mm_acquire (memmodel_from_int (INTVAL (mod_f)))
+      && is_mm_release (memmodel_from_int (INTVAL (mod_s))))
     mod_s = GEN_INT (MEMMODEL_ACQ_REL);
 
   switch (mode)
@@ -27752,20 +27770,25 @@
   oldval = operands[2];
   newval = operands[3];
   is_weak = (operands[4] != const0_rtx);
-  mod_s = (enum memmodel) INTVAL (operands[5]);
-  mod_f = (enum memmodel) INTVAL (operands[6]);
+  mod_s = memmodel_from_int (INTVAL (operands[5]));
+  mod_f = memmodel_from_int (INTVAL (operands[6]));
   scratch = operands[7];
   mode = GET_MODE (mem);
 
-  bool use_acquire = TARGET_HAVE_LDACQ
-                     && !(mod_s == MEMMODEL_RELAXED
-                          || mod_s == MEMMODEL_CONSUME
-                          || mod_s == MEMMODEL_RELEASE);
+  bool is_armv8_sync = arm_arch8 && is_mm_sync (mod_s);
 
+  bool use_acquire = TARGET_HAVE_LDACQ
+                     && !(is_mm_relaxed (mod_s) || is_mm_consume (mod_s)
+			  || is_mm_release (mod_s));
+		
   bool use_release = TARGET_HAVE_LDACQ
-                     && !(mod_s == MEMMODEL_RELAXED
-                          || mod_s == MEMMODEL_CONSUME
-                          || mod_s == MEMMODEL_ACQUIRE);
+                     && !(is_mm_relaxed (mod_s) || is_mm_consume (mod_s)
+			  || is_mm_acquire (mod_s));
+
+  /* For ARMv8, the load-acquire is too weak for __sync memory orders.  Instead,
+     a full barrier is emitted after the store-release.  */
+  if (is_armv8_sync)
+    use_acquire = false;
 
   /* Checks whether a barrier is needed and emits one accordingly.  */
   if (!(use_acquire || use_release))
@@ -27803,14 +27826,15 @@
       emit_unlikely_jump (gen_rtx_SET (VOIDmode, pc_rtx, x));
     }
 
-  if (mod_f != MEMMODEL_RELAXED)
+  if (!is_mm_relaxed (mod_f))
     emit_label (label2);
 
   /* Checks whether a barrier is needed and emits one accordingly.  */
-  if (!(use_acquire || use_release))
+  if (is_armv8_sync
+      || !(use_acquire || use_release))
     arm_post_atomic_barrier (mod_s);
 
-  if (mod_f == MEMMODEL_RELAXED)
+  if (is_mm_relaxed (mod_f))
     emit_label (label2);
 }
 
@@ -27818,21 +27842,26 @@
 arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,
 		     rtx value, rtx model_rtx, rtx cond)
 {
-  enum memmodel model = (enum memmodel) INTVAL (model_rtx);
+  enum memmodel model = memmodel_from_int (INTVAL (model_rtx));
   machine_mode mode = GET_MODE (mem);
   machine_mode wmode = (mode == DImode ? DImode : SImode);
   rtx_code_label *label;
   rtx x;
 
+  bool is_armv8_sync = arm_arch8 && is_mm_sync (model);
+
   bool use_acquire = TARGET_HAVE_LDACQ
-                     && !(model == MEMMODEL_RELAXED
-                          || model == MEMMODEL_CONSUME
-                          || model == MEMMODEL_RELEASE);
+                     && !(is_mm_relaxed (model) || is_mm_consume (model)
+			  || is_mm_release (model));
 
   bool use_release = TARGET_HAVE_LDACQ
-                     && !(model == MEMMODEL_RELAXED
-                          || model == MEMMODEL_CONSUME
-                          || model == MEMMODEL_ACQUIRE);
+                     && !(is_mm_relaxed (model) || is_mm_consume (model)
+			  || is_mm_acquire (model));
+
+  /* For ARMv8, a load-acquire is too weak for __sync memory orders.  Instead,
+     a full barrier is emitted after the store-release.  */
+  if (is_armv8_sync)
+    use_acquire = false;
 
   /* Checks whether a barrier is needed and emits one accordingly.  */
   if (!(use_acquire || use_release))
@@ -27904,7 +27933,8 @@
   emit_unlikely_jump (gen_cbranchsi4 (x, cond, const0_rtx, label));
 
   /* Checks whether a barrier is needed and emits one accordingly.  */
-  if (!(use_acquire || use_release))
+  if (is_armv8_sync
+      || !(use_acquire || use_release))
     arm_post_atomic_barrier (model);
 }
 
@@ -28792,6 +28822,38 @@
   #undef BRANCH
 }
 
+/* Returns true if the pattern is a valid symbolic address, which is either a
+   symbol_ref or (symbol_ref + addend).
+
+   According to the ARM ELF ABI, the initial addend of REL-type relocations
+   processing MOVW and MOVT instructions is formed by interpreting the 16-bit
+   literal field of the instruction as a 16-bit signed value in the range
+   -32768 <= A < 32768.  */
+
+bool
+arm_valid_symbolic_address_p (rtx addr)
+{
+  rtx xop0, xop1 = NULL_RTX;
+  rtx tmp = addr;
+
+  if (GET_CODE (tmp) == SYMBOL_REF || GET_CODE (tmp) == LABEL_REF)
+    return true;
+
+  /* (const (plus: symbol_ref const_int))  */
+  if (GET_CODE (addr) == CONST)
+    tmp = XEXP (addr, 0);
+
+  if (GET_CODE (tmp) == PLUS)
+    {
+      xop0 = XEXP (tmp, 0);
+      xop1 = XEXP (tmp, 1);
+
+      if (GET_CODE (xop0) == SYMBOL_REF && CONST_INT_P (xop1))
+	  return IN_RANGE (INTVAL (xop1), -0x8000, 0x7fff);
+    }
+
+  return false;
+}
 
 /* Returns true if a valid comparison operation and makes
    the operands in a form that is valid.  */
diff -Naur gcc-5.2.0.orig/gcc/config/arm/arm.md gcc-5.2.0/gcc/config/arm/arm.md
--- gcc-5.2.0.orig/gcc/config/arm/arm.md	2015-07-06 12:18:40.000000000 -0500
+++ gcc-5.2.0/gcc/config/arm/arm.md	2015-09-23 05:36:48.364214000 -0500
@@ -5415,7 +5415,7 @@
       if (!REG_P (operands[0]))
 	operands[1] = force_reg (DImode, operands[1]);
     }
-  if (REG_P (operands[0]) && REGNO (operands[0]) < FIRST_VIRTUAL_REGISTER
+  if (REG_P (operands[0]) && REGNO (operands[0]) <= LAST_ARM_REGNUM
       && !HARD_REGNO_MODE_OK (REGNO (operands[0]), DImode))
     {
       /* Avoid LDRD's into an odd-numbered register pair in ARM state
@@ -5434,7 +5434,7 @@
 		      gen_highpart (SImode, operands[1]));
       DONE;
     }
-  else if (REG_P (operands[1]) && REGNO (operands[1]) < FIRST_VIRTUAL_REGISTER
+  else if (REG_P (operands[1]) && REGNO (operands[1]) <= LAST_ARM_REGNUM
 	   && !HARD_REGNO_MODE_OK (REGNO (operands[1]), DImode))
     {
       /* Avoid STRD's from an odd-numbered register pair in ARM state
@@ -5662,7 +5662,7 @@
   [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
 	(lo_sum:SI (match_operand:SI 1 "nonimmediate_operand" "0")
 		   (match_operand:SI 2 "general_operand"      "i")))]
-  "arm_arch_thumb2"
+  "arm_arch_thumb2 && arm_valid_symbolic_address_p (operands[2])"
   "movt%?\t%0, #:upper16:%c2"
   [(set_attr "predicable" "yes")
    (set_attr "predicable_short_it" "no")
@@ -6508,7 +6508,7 @@
 (define_insn "*arm32_movhf"
   [(set (match_operand:HF 0 "nonimmediate_operand" "=r,m,r,r")
 	(match_operand:HF 1 "general_operand"	   " m,r,r,F"))]
-  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_FP16) && !arm_restrict_it
+  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_FP16)
    && (	  s_register_operand (operands[0], HFmode)
        || s_register_operand (operands[1], HFmode))"
   "*
@@ -6546,7 +6546,8 @@
   [(set_attr "conds" "unconditional")
    (set_attr "type" "load1,store1,mov_reg,multiple")
    (set_attr "length" "4,4,4,8")
-   (set_attr "predicable" "yes")]
+   (set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")]
 )
 
 (define_expand "movsf"
diff -Naur gcc-5.2.0.orig/gcc/config/arm/arm-protos.h gcc-5.2.0/gcc/config/arm/arm-protos.h
--- gcc-5.2.0.orig/gcc/config/arm/arm-protos.h	2015-03-25 00:53:55.000000000 -0500
+++ gcc-5.2.0/gcc/config/arm/arm-protos.h	2015-08-26 08:49:00.639074000 -0500
@@ -312,6 +312,7 @@
 
 extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,
 					   rtx);
+extern bool arm_valid_symbolic_address_p (rtx);
 extern bool arm_validize_comparison (rtx *, rtx *, rtx *);
 #endif /* RTX_CODE */
 
diff -Naur gcc-5.2.0.orig/gcc/config/arm/constraints.md gcc-5.2.0/gcc/config/arm/constraints.md
--- gcc-5.2.0.orig/gcc/config/arm/constraints.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/arm/constraints.md	2015-10-27 08:46:15.949493000 -0500
@@ -67,7 +67,8 @@
 (define_constraint "j"
  "A constant suitable for a MOVW instruction. (ARM/Thumb-2)"
  (and (match_test "TARGET_32BIT && arm_arch_thumb2")
-      (ior (match_code "high")
+      (ior (and (match_code "high")
+		(match_test "arm_valid_symbolic_address_p (XEXP (op, 0))"))
 	   (and (match_code "const_int")
                 (match_test "(ival & 0xffff0000) == 0")))))
 
@@ -338,7 +339,8 @@
  "@internal
   In ARM/ Thumb2 a const_double which can be used with a vcvt.s32.f32 with bits operation"
   (and (match_code "const_double")
-       (match_test "TARGET_32BIT && TARGET_VFP && vfp3_const_double_for_bits (op)")))
+       (match_test "TARGET_32BIT && TARGET_VFP
+		    && vfp3_const_double_for_bits (op) > 0")))
 
 (define_register_constraint "Ts" "(arm_restrict_it) ? LO_REGS : GENERAL_REGS"
  "For arm_restrict_it the core registers @code{r0}-@code{r7}.  GENERAL_REGS otherwise.")
diff -Naur gcc-5.2.0.orig/gcc/config/arm/predicates.md gcc-5.2.0/gcc/config/arm/predicates.md
--- gcc-5.2.0.orig/gcc/config/arm/predicates.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/arm/predicates.md	2015-10-27 08:46:15.949493000 -0500
@@ -668,7 +668,7 @@
 (define_predicate "const_double_vcvt_power_of_two"
   (and (match_code "const_double")
        (match_test "TARGET_32BIT && TARGET_VFP
-                   && vfp3_const_double_for_bits (op)")))
+		    && vfp3_const_double_for_bits (op) > 0")))
 
 (define_predicate "neon_struct_operand"
   (and (match_code "mem")
diff -Naur gcc-5.2.0.orig/gcc/config/arm/sync.md gcc-5.2.0/gcc/config/arm/sync.md
--- gcc-5.2.0.orig/gcc/config/arm/sync.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/arm/sync.md	2015-10-01 04:05:45.272698000 -0500
@@ -73,15 +73,14 @@
       VUNSPEC_LDA))]
   "TARGET_HAVE_LDACQ"
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-    if (model == MEMMODEL_RELAXED
-        || model == MEMMODEL_CONSUME
-        || model == MEMMODEL_RELEASE)
-      return \"ldr<sync_sfx>\\t%0, %1\";
+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))
+      return \"ldr%(<sync_sfx>%)\\t%0, %1\";
     else
-      return \"lda<sync_sfx>\\t%0, %1\";
+      return \"lda<sync_sfx>%?\\t%0, %1\";
   }
-)
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")])
 
 (define_insn "atomic_store<mode>"
   [(set (match_operand:QHSI 0 "memory_operand" "=Q")
@@ -91,15 +90,14 @@
       VUNSPEC_STL))]
   "TARGET_HAVE_LDACQ"
   {
-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);
-    if (model == MEMMODEL_RELAXED
-        || model == MEMMODEL_CONSUME
-        || model == MEMMODEL_ACQUIRE)
-      return \"str<sync_sfx>\t%1, %0\";
+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_acquire (model))
+      return \"str%(<sync_sfx>%)\t%1, %0\";
     else
-      return \"stl<sync_sfx>\t%1, %0\";
+      return \"stl<sync_sfx>%?\t%1, %0\";
   }
-)
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")])
 
 ;; Note that ldrd and vldr are *not* guaranteed to be single-copy atomic,
 ;; even for a 64-bit aligned address.  Instead we use a ldrexd unparied
@@ -110,10 +108,10 @@
    (match_operand:SI 2 "const_int_operand")]		;; model
   "TARGET_HAVE_LDREXD && ARM_DOUBLEWORD_ALIGN"
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
   expand_mem_thread_fence (model);
   emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
-  if (model == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (model))
     expand_mem_thread_fence (model);
   DONE;
 })
diff -Naur gcc-5.2.0.orig/gcc/config/arm/vfp.md gcc-5.2.0/gcc/config/arm/vfp.md
--- gcc-5.2.0.orig/gcc/config/arm/vfp.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/arm/vfp.md	2015-08-03 09:27:43.641873000 -0500
@@ -770,6 +770,17 @@
   [(set (match_operand:SF		   0 "s_register_operand" "=t")
 	(mult:SF (neg:SF (match_operand:SF 1 "s_register_operand" "t"))
 		 (match_operand:SF	   2 "s_register_operand" "t")))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && !flag_rounding_math"
+  "vnmul%?.f32\\t%0, %1, %2"
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")
+   (set_attr "type" "fmuls")]
+)
+
+(define_insn "*negmulsf3_vfp"
+  [(set (match_operand:SF		   0 "s_register_operand" "=t")
+	(neg:SF (mult:SF (match_operand:SF 1 "s_register_operand" "t")
+		 (match_operand:SF	   2 "s_register_operand" "t"))))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
   "vnmul%?.f32\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
@@ -781,6 +792,18 @@
   [(set (match_operand:DF		   0 "s_register_operand" "=w")
 	(mult:DF (neg:DF (match_operand:DF 1 "s_register_operand" "w"))
 		 (match_operand:DF	   2 "s_register_operand" "w")))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+  && !flag_rounding_math"
+  "vnmul%?.f64\\t%P0, %P1, %P2"
+  [(set_attr "predicable" "yes")
+   (set_attr "predicable_short_it" "no")
+   (set_attr "type" "fmuld")]
+)
+
+(define_insn "*negmuldf3_vfp"
+  [(set (match_operand:DF		   0 "s_register_operand" "=w")
+	(neg:DF (mult:DF (match_operand:DF 1 "s_register_operand" "w")
+		 (match_operand:DF	   2 "s_register_operand" "w"))))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "vnmul%?.f64\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
diff -Naur gcc-5.2.0.orig/gcc/config/avr/avr.c gcc-5.2.0/gcc/config/avr/avr.c
--- gcc-5.2.0.orig/gcc/config/avr/avr.c	2015-03-10 04:50:41.000000000 -0500
+++ gcc-5.2.0/gcc/config/avr/avr.c	2015-08-20 09:15:30.212999000 -0500
@@ -9272,10 +9272,10 @@
         {
           if (TYPE_P (node))
             error ("%qT uses address space %qs beyond flash of %d KiB",
-                   node, avr_addrspace[as].name, avr_n_flash);
+                   node, avr_addrspace[as].name, 64 * avr_n_flash);
           else
             error ("%s %q+D uses address space %qs beyond flash of %d KiB",
-                   reason, node, avr_addrspace[as].name, avr_n_flash);
+                   reason, node, avr_addrspace[as].name, 64 * avr_n_flash);
         }
       else
         {
@@ -9322,7 +9322,7 @@
       if (avr_addrspace[as].segment >= avr_n_flash)
         {
           error ("variable %q+D located in address space %qs beyond flash "
-                 "of %d KiB", node, avr_addrspace[as].name, avr_n_flash);
+                 "of %d KiB", node, avr_addrspace[as].name, 64 * avr_n_flash);
         }
       else if (!AVR_HAVE_LPM && avr_addrspace[as].pointer_size > 2)
 	{
diff -Naur gcc-5.2.0.orig/gcc/config/avr/avr-dimode.md gcc-5.2.0/gcc/config/avr/avr-dimode.md
--- gcc-5.2.0.orig/gcc/config/avr/avr-dimode.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/avr/avr-dimode.md	2015-07-21 12:29:47.408167000 -0500
@@ -461,7 +461,8 @@
               (match_operand:SI 2 "general_operand" "")
               ;; Just to mention the iterator 
               (clobber (any_extend:SI (match_dup 1)))])]
-  "avr_have_dimode"
+  "avr_have_dimode
+   && AVR_HAVE_MUL"
   {
     avr_fix_inputs (operands, 1 << 2, regmask (SImode, 22));
     emit_move_insn (gen_rtx_REG (SImode, 22), operands[1]);
@@ -480,7 +481,8 @@
                  (any_extend:DI (reg:SI 22))))
    (clobber (reg:HI REG_X))
    (clobber (reg:HI REG_Z))]
-  "avr_have_dimode"
+  "avr_have_dimode
+   && AVR_HAVE_MUL"
   "%~call __<extend_u>mulsidi3"
   [(set_attr "adjust_len" "call")
    (set_attr "cc" "clobber")])
diff -Naur gcc-5.2.0.orig/gcc/config/i386/i386.c gcc-5.2.0/gcc/config/i386/i386.c
--- gcc-5.2.0.orig/gcc/config/i386/i386.c	2015-06-18 05:56:43.000000000 -0500
+++ gcc-5.2.0/gcc/config/i386/i386.c	2015-10-22 01:52:00.764034000 -0500
@@ -4055,11 +4055,11 @@
   if (opts_set->x_ix86_incoming_stack_boundary_arg)
     {
       if (opts->x_ix86_incoming_stack_boundary_arg
-	  < (TARGET_64BIT_P (opts->x_ix86_isa_flags) ? 4 : 2)
+	  < (TARGET_64BIT_P (opts->x_ix86_isa_flags) ? 3 : 2)
 	  || opts->x_ix86_incoming_stack_boundary_arg > 12)
 	error ("-mincoming-stack-boundary=%d is not between %d and 12",
 	       opts->x_ix86_incoming_stack_boundary_arg,
-	       TARGET_64BIT_P (opts->x_ix86_isa_flags) ? 4 : 2);
+	       TARGET_64BIT_P (opts->x_ix86_isa_flags) ? 3 : 2);
       else
 	{
 	  ix86_user_incoming_stack_boundary
@@ -5201,6 +5201,14 @@
 	TREE_TARGET_GLOBALS (new_tree) = save_target_globals_default_opts ();
     }
   ix86_previous_fndecl = fndecl;
+
+  /* 64-bit MS and SYSV ABI have different set of call used registers.
+     Avoid expensive re-initialization of init_regs each time we switch
+     function context.  */
+  if (TARGET_64BIT
+      && (call_used_regs[SI_REG]
+	  == (cfun->machine->call_abi == MS_ABI)))
+    reinit_regs ();
 }
 
 
@@ -6344,17 +6352,6 @@
     cfun->machine->call_abi = ix86_function_type_abi (TREE_TYPE (fndecl));
 }
 
-/* 64-bit MS and SYSV ABI have different set of call used registers.  Avoid
-   expensive re-initialization of init_regs each time we switch function context
-   since this is needed only during RTL expansion.  */
-static void
-ix86_maybe_switch_abi (void)
-{
-  if (TARGET_64BIT &&
-      call_used_regs[SI_REG] == (cfun->machine->call_abi == MS_ABI))
-    reinit_regs ();
-}
-
 /* Return 1 if pseudo register should be created and used to hold
    GOT address for PIC code.  */
 bool
@@ -8211,7 +8208,8 @@
     case SI_REG:
       return TARGET_64BIT && ix86_cfun_abi () != MS_ABI;
 
-    case FIRST_BND_REG:
+    case BND0_REG:
+    case BND1_REG:
       return chkp_function_instrumented_p (current_function_decl);
 
       /* Complex values are returned in %st(0)/%st(1) pair.  */
@@ -10104,11 +10102,14 @@
   frame->nregs = ix86_nsaved_regs ();
   frame->nsseregs = ix86_nsaved_sseregs ();
 
-  /* 64-bit MS ABI seem to require stack alignment to be always 16 except for
-     function prologues and leaf.  */
+  /* 64-bit MS ABI seem to require stack alignment to be always 16,
+     except for function prologues, leaf functions and when the defult
+     incoming stack boundary is overriden at command line or via
+     force_align_arg_pointer attribute.  */
   if ((TARGET_64BIT_MS_ABI && crtl->preferred_stack_boundary < 128)
       && (!crtl->is_leaf || cfun->calls_alloca != 0
-          || ix86_current_function_calls_tls_descriptor))
+	  || ix86_current_function_calls_tls_descriptor
+	  || ix86_incoming_stack_boundary < 128))
     {
       crtl->preferred_stack_boundary = 128;
       crtl->stack_alignment_needed = 128;
@@ -10207,10 +10208,14 @@
   if (frame->nsseregs)
     {
       /* The only ABI that has saved SSE registers (Win64) also has a
-         16-byte aligned default stack, and thus we don't need to be
-	 within the re-aligned local stack frame to save them.  */
-      gcc_assert (INCOMING_STACK_BOUNDARY >= 128);
-      offset = (offset + 16 - 1) & -16;
+	 16-byte aligned default stack, and thus we don't need to be
+	 within the re-aligned local stack frame to save them.  In case
+	 incoming stack boundary is aligned to less than 16 bytes,
+	 unaligned move of SSE register will be emitted, so there is
+	 no point to round up the SSE register save area outside the
+	 re-aligned local stack frame to 16 bytes.  */
+      if (ix86_incoming_stack_boundary >= 128)
+	offset = (offset + 16 - 1) & -16;
       offset += frame->nsseregs * 16;
     }
   frame->sse_reg_save_offset = offset;
@@ -10220,7 +10225,7 @@
      sure that no value happens to be the same before and after, force
      the alignment computation below to add a non-zero value.  */
   if (stack_realign_fp)
-    offset = (offset + stack_alignment_needed) & -stack_alignment_needed;
+    offset = (offset + stack_alignment_needed - 1) & -stack_alignment_needed;
 
   /* Va-arg area */
   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;
@@ -10433,15 +10438,24 @@
 {
   struct machine_function *m = cfun->machine;
   rtx reg = gen_rtx_REG (mode, regno);
+  rtx unspec = NULL_RTX;
   rtx mem, addr, base, insn;
+  unsigned int align;
 
   addr = choose_baseaddr (cfa_offset);
   mem = gen_frame_mem (mode, addr);
 
-  /* For SSE saves, we need to indicate the 128-bit alignment.  */
-  set_mem_align (mem, GET_MODE_ALIGNMENT (mode));
+  /* The location is aligned up to INCOMING_STACK_BOUNDARY.  */
+  align = MIN (GET_MODE_ALIGNMENT (mode), INCOMING_STACK_BOUNDARY);
+  set_mem_align (mem, align);
+
+  /* SSE saves are not within re-aligned local stack frame.
+     In case INCOMING_STACK_BOUNDARY is misaligned, we have
+     to emit unaligned store.  */
+  if (mode == V4SFmode && align < 128)
+    unspec = gen_rtx_UNSPEC (mode, gen_rtvec (1, reg), UNSPEC_STOREU);
 
-  insn = emit_move_insn (mem, reg);
+  insn = emit_insn (gen_rtx_SET (VOIDmode, mem, unspec ? unspec : reg));
   RTX_FRAME_RELATED_P (insn) = 1;
 
   base = addr;
@@ -10489,6 +10503,9 @@
       mem = gen_rtx_MEM (mode, addr);
       add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (VOIDmode, mem, reg));
     }
+  else if (unspec)
+    add_reg_note (insn, REG_CFA_EXPRESSION,
+		  gen_rtx_SET (VOIDmode, mem, reg));
 }
 
 /* Emit code to save registers using MOV insns.
@@ -10705,6 +10722,25 @@
     }
 }
 
+/* Handle a "force_align_arg_pointer" attribute.  */
+
+static tree
+ix86_handle_force_align_arg_pointer_attribute (tree *node, tree name,
+					       tree, int, bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) != FUNCTION_TYPE
+      && TREE_CODE (*node) != METHOD_TYPE
+      && TREE_CODE (*node) != FIELD_DECL
+      && TREE_CODE (*node) != TYPE_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute only applies to functions",
+	       name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 /* Return minimum incoming stack alignment.  */
 
 static unsigned int
@@ -10719,7 +10755,6 @@
      if -mstackrealign is used, it isn't used for sibcall check and
      estimated stack alignment is 128bit.  */
   else if (!sibcall
-	   && !TARGET_64BIT
 	   && ix86_force_align_arg_pointer
 	   && crtl->stack_alignment_estimated == 128)
     incoming_stack_boundary = MIN_STACK_BOUNDARY;
@@ -11578,7 +11613,7 @@
          pointer is no longer valid.  As for the value of sp_offset,
 	 see ix86_compute_frame_layout, which we need to match in order
 	 to pass verification of stack_pointer_offset at the end.  */
-      m->fs.sp_offset = (m->fs.sp_offset + align_bytes) & -align_bytes;
+      m->fs.sp_offset = (m->fs.sp_offset + align_bytes - 1) & -align_bytes;
       m->fs.sp_valid = false;
     }
 
@@ -11991,11 +12026,26 @@
       {
 	rtx reg = gen_rtx_REG (V4SFmode, regno);
 	rtx mem;
+ 	unsigned int align;
 
 	mem = choose_baseaddr (cfa_offset);
 	mem = gen_rtx_MEM (V4SFmode, mem);
-	set_mem_align (mem, 128);
-	emit_move_insn (reg, mem);
+
+ 	/* The location is aligned up to INCOMING_STACK_BOUNDARY.  */
+	align = MIN (GET_MODE_ALIGNMENT (V4SFmode), INCOMING_STACK_BOUNDARY);
+ 	set_mem_align (mem, align);
+
+ 	/* SSE saves are not within re-aligned local stack frame.
+ 	   In case INCOMING_STACK_BOUNDARY is misaligned, we have
+ 	   to emit unaligned load.  */
+ 	if (align < 128)
+ 	  {
+ 	    rtx unspec = gen_rtx_UNSPEC (V4SFmode, gen_rtvec (1, mem),
+ 					 UNSPEC_LOADU);
+ 	    emit_insn (gen_rtx_SET (VOIDmode, reg, unspec));
+ 	  }
+ 	else
+ 	  emit_insn (gen_rtx_SET (VOIDmode, reg, mem));
 
 	ix86_add_cfa_restore_note (NULL_RTX, reg, cfa_offset);
 
@@ -25140,7 +25190,8 @@
       dst = change_address (dst, BLKmode, destreg);
       set_mem_align (dst, desired_align * BITS_PER_UNIT);
       epilogue_size_needed = 0;
-      if (need_zero_guard && !min_size)
+      if (need_zero_guard
+	  && min_size < (unsigned HOST_WIDE_INT) size_needed)
 	{
 	  /* It is possible that we copied enough so the main loop will not
 	     execute.  */
@@ -25272,7 +25323,7 @@
 	  max_size -= align_bytes;
 	}
       if (need_zero_guard
-	  && !min_size
+	  && min_size < (unsigned HOST_WIDE_INT) size_needed
 	  && (count < (unsigned HOST_WIDE_INT) size_needed
 	      || (align_bytes == 0
 		  && count < ((unsigned HOST_WIDE_INT) size_needed
@@ -25557,7 +25608,7 @@
 
   /* Avoid branch in fixing the byte.  */
   tmpreg = gen_lowpart (QImode, tmpreg);
-  emit_insn (gen_addqi3_cc (tmpreg, tmpreg, tmpreg));
+  emit_insn (gen_addqi3_cconly_overflow (tmpreg, tmpreg));
   tmp = gen_rtx_REG (CCmode, FLAGS_REG);
   cmp = gen_rtx_LTU (VOIDmode, tmp, const0_rtx);
   emit_insn (ix86_gen_sub3_carry (out, out, GEN_INT (3), tmp, cmp));
@@ -39522,60 +39573,57 @@
       return target;
 
     case IX86_BUILTIN_SBB32:
-      icode = CODE_FOR_subsi3_carry;
+      icode = CODE_FOR_subborrowsi;
       mode0 = SImode;
-      goto addcarryx;
+      goto handlecarry;
 
     case IX86_BUILTIN_SBB64:
-      icode = CODE_FOR_subdi3_carry;
+      icode = CODE_FOR_subborrowdi;
       mode0 = DImode;
-      goto addcarryx;
+      goto handlecarry;
 
     case IX86_BUILTIN_ADDCARRYX32:
-      icode = TARGET_ADX ? CODE_FOR_adcxsi3 : CODE_FOR_addsi3_carry;
+      icode = CODE_FOR_addcarrysi;
       mode0 = SImode;
-      goto addcarryx;
+      goto handlecarry;
 
     case IX86_BUILTIN_ADDCARRYX64:
-      icode = TARGET_ADX ? CODE_FOR_adcxdi3 : CODE_FOR_adddi3_carry;
+      icode = CODE_FOR_addcarrydi;
       mode0 = DImode;
 
-addcarryx:
+    handlecarry:
       arg0 = CALL_EXPR_ARG (exp, 0); /* unsigned char c_in.  */
       arg1 = CALL_EXPR_ARG (exp, 1); /* unsigned int src1.  */
       arg2 = CALL_EXPR_ARG (exp, 2); /* unsigned int src2.  */
       arg3 = CALL_EXPR_ARG (exp, 3); /* unsigned int *sum_out.  */
 
-      op0 = gen_reg_rtx (QImode);
-
-      /* Generate CF from input operand.  */
       op1 = expand_normal (arg0);
       op1 = copy_to_mode_reg (QImode, convert_to_mode (QImode, op1, 1));
-      emit_insn (gen_addqi3_cc (op0, op1, constm1_rtx));
 
-      /* Gen ADCX instruction to compute X+Y+CF.  */
       op2 = expand_normal (arg1);
-      op3 = expand_normal (arg2);
-
-      if (!REG_P (op2))
+      if (!register_operand (op2, mode0))
 	op2 = copy_to_mode_reg (mode0, op2);
-      if (!REG_P (op3))
-	op3 = copy_to_mode_reg (mode0, op3);
-
-      op0 = gen_reg_rtx (mode0);
 
-      op4 = gen_rtx_REG (CCCmode, FLAGS_REG);
-      pat = gen_rtx_LTU (VOIDmode, op4, const0_rtx);
-      emit_insn (GEN_FCN (icode) (op0, op2, op3, op4, pat));
+      op3 = expand_normal (arg2);
+      if (!register_operand (op3, mode0))
+	op3 = copy_to_mode_reg (mode0, op3);
 
-      /* Store the result.  */
       op4 = expand_normal (arg3);
       if (!address_operand (op4, VOIDmode))
 	{
 	  op4 = convert_memory_address (Pmode, op4);
 	  op4 = copy_addr_to_reg (op4);
 	}
-      emit_move_insn (gen_rtx_MEM (mode0, op4), op0);
+
+      /* Generate CF from input operand.  */
+      emit_insn (gen_addqi3_cconly_overflow (op1, constm1_rtx));
+
+      /* Generate instruction that consumes CF.  */
+      op0 = gen_reg_rtx (mode0);
+
+      op1 = gen_rtx_REG (CCCmode, FLAGS_REG);
+      pat = gen_rtx_LTU (mode0, op1, const0_rtx);
+      emit_insn (GEN_FCN (icode) (op0, op2, op3, op1, pat));
 
       /* Return current CF value.  */
       if (target == 0)
@@ -39583,6 +39631,10 @@
 
       PUT_MODE (pat, QImode);
       emit_insn (gen_rtx_SET (VOIDmode, target, pat));
+
+      /* Store the result.  */
+      emit_move_insn (gen_rtx_MEM (mode0, op4), op0);
+
       return target;
 
     case IX86_BUILTIN_READ_FLAGS:
@@ -46836,7 +46888,7 @@
     true },
   /* force_align_arg_pointer says this function realigns the stack at entry.  */
   { (const char *)&ix86_force_align_arg_pointer_string, 0, 0,
-    false, true,  true, ix86_handle_cconv_attribute, false },
+    false, true,  true, ix86_handle_force_align_arg_pointer_attribute, false },
 #if TARGET_DLLIMPORT_DECL_ATTRIBUTES
   { "dllimport", 0, 0, false, false, false, handle_dll_attribute, false },
   { "dllexport", 0, 0, false, false, false, handle_dll_attribute, false },
@@ -48957,6 +49009,62 @@
   return true;
 }
 
+/* A subroutine of expand_vec_perm_even_odd_1.  Implement extract-even
+   and extract-odd permutations of two V64QI operands
+   with two "shifts", two "truncs" and one "concat" insns for "odd"
+   and two "truncs" and one concat insn for "even."
+   Have already failed all two instruction sequences.  */
+
+static bool
+expand_vec_perm_even_odd_trunc (struct expand_vec_perm_d *d)
+{
+  rtx t1, t2, t3, t4;
+  unsigned i, odd, nelt = d->nelt;
+
+  if (!TARGET_AVX512BW
+      || d->one_operand_p
+      || d->vmode != V64QImode)
+    return false;
+
+  /* Check that permutation is even or odd.  */
+  odd = d->perm[0];
+  if (odd > 1)
+    return false;
+
+  for (i = 1; i < nelt; ++i)
+    if (d->perm[i] != 2 * i + odd)
+      return false;
+
+  if (d->testing_p)
+    return true;
+
+
+  if (odd)
+    {
+      t1 = gen_reg_rtx (V32HImode);
+      t2 = gen_reg_rtx (V32HImode);
+      emit_insn (gen_lshrv32hi3 (t1,
+				 gen_lowpart (V32HImode, d->op0),
+				 GEN_INT (8)));
+      emit_insn (gen_lshrv32hi3 (t2,
+				 gen_lowpart (V32HImode, d->op1),
+				 GEN_INT (8)));
+    }
+  else
+    {
+      t1 = gen_lowpart (V32HImode, d->op0);
+      t2 = gen_lowpart (V32HImode, d->op1);
+    }
+
+  t3 = gen_reg_rtx (V32QImode);
+  t4 = gen_reg_rtx (V32QImode);
+  emit_insn (gen_avx512bw_truncatev32hiv32qi2 (t3, t1));
+  emit_insn (gen_avx512bw_truncatev32hiv32qi2 (t4, t2));
+  emit_insn (gen_avx_vec_concatv64qi (d->target, t3, t4));
+
+  return true;
+}
+
 /* A subroutine of ix86_expand_vec_perm_builtin_1.  Implement extract-even
    and extract-odd permutations.  */
 
@@ -49059,6 +49167,9 @@
     case V32QImode:
       return expand_vec_perm_even_odd_pack (d);
 
+    case V64QImode:
+      return expand_vec_perm_even_odd_trunc (d);
+
     case V4DImode:
       if (!TARGET_AVX2)
 	{
@@ -49520,6 +49631,8 @@
 
   /* Try sequences of four instructions.  */
 
+  if (expand_vec_perm_even_odd_trunc (d))
+    return true;
   if (expand_vec_perm_vpshufb2_vpermq (d))
     return true;
 
@@ -50335,15 +50448,20 @@
   unsigned int size = INTVAL (operands[1]);
   unsigned int pos = INTVAL (operands[2]);
 
+  if (GET_CODE (src) == SUBREG)
+    {
+      /* Reject non-lowpart subregs.  */
+      if (SUBREG_BYTE (src) != 0)
+       return false;
+      src = SUBREG_REG (src);
+    }
+
   if (GET_CODE (dst) == SUBREG)
     {
       pos += SUBREG_BYTE (dst) * BITS_PER_UNIT;
       dst = SUBREG_REG (dst);
     }
 
-  if (GET_CODE (src) == SUBREG)
-    src = SUBREG_REG (src);
-
   switch (GET_MODE (dst))
     {
     case V16QImode:
@@ -50391,6 +50509,10 @@
 	    return false;
 	  }
 
+	/* Reject insertions to misaligned positions.  */
+	if (pos & (size-1))
+	  return false;
+
 	rtx d = dst;
 	if (GET_MODE (dst) != dstmode)
 	  d = gen_reg_rtx (dstmode);
@@ -51516,7 +51638,7 @@
 static unsigned HOST_WIDE_INT
 ix86_memmodel_check (unsigned HOST_WIDE_INT val)
 {
-  unsigned HOST_WIDE_INT model = val & MEMMODEL_MASK;
+  enum memmodel model = memmodel_from_int (val);
   bool strong;
 
   if (val & ~(unsigned HOST_WIDE_INT)(IX86_HLE_ACQUIRE|IX86_HLE_RELEASE
@@ -51527,14 +51649,14 @@
 	       "Unknown architecture specific memory model");
       return MEMMODEL_SEQ_CST;
     }
-  strong = (model == MEMMODEL_ACQ_REL || model == MEMMODEL_SEQ_CST);
-  if (val & IX86_HLE_ACQUIRE && !(model == MEMMODEL_ACQUIRE || strong))
+  strong = (is_mm_acq_rel (model) || is_mm_seq_cst (model));
+  if (val & IX86_HLE_ACQUIRE && !(is_mm_acquire (model) || strong))
     {
       warning (OPT_Winvalid_memory_model,
               "HLE_ACQUIRE not used with ACQUIRE or stronger memory model");
       return MEMMODEL_SEQ_CST | IX86_HLE_ACQUIRE;
     }
-   if (val & IX86_HLE_RELEASE && !(model == MEMMODEL_RELEASE || strong))
+  if (val & IX86_HLE_RELEASE && !(is_mm_release (model) || strong))
     {
       warning (OPT_Winvalid_memory_model,
               "HLE_RELEASE not used with RELEASE or stronger memory model");
@@ -52307,9 +52429,6 @@
 #undef TARGET_CAN_INLINE_P
 #define TARGET_CAN_INLINE_P ix86_can_inline_p
 
-#undef TARGET_EXPAND_TO_RTL_HOOK
-#define TARGET_EXPAND_TO_RTL_HOOK ix86_maybe_switch_abi
-
 #undef TARGET_LEGITIMATE_ADDRESS_P
 #define TARGET_LEGITIMATE_ADDRESS_P ix86_legitimate_address_p
 
diff -Naur gcc-5.2.0.orig/gcc/config/i386/i386.h gcc-5.2.0/gcc/config/i386/i386.h
--- gcc-5.2.0.orig/gcc/config/i386/i386.h	2015-06-18 05:56:43.000000000 -0500
+++ gcc-5.2.0/gcc/config/i386/i386.h	2015-10-12 11:29:37.933151000 -0500
@@ -747,7 +747,7 @@
 #define MAIN_STACK_BOUNDARY (TARGET_64BIT ? 128 : 32)
 
 /* Minimum stack boundary.  */
-#define MIN_STACK_BOUNDARY (TARGET_64BIT ? (TARGET_SSE ? 128 : 64) : 32)
+#define MIN_STACK_BOUNDARY BITS_PER_WORD
 
 /* Boundary (in *bits*) on which the stack pointer prefers to be
    aligned; the compiler cannot rely on having this alignment.  */
diff -Naur gcc-5.2.0.orig/gcc/config/i386/i386.md gcc-5.2.0/gcc/config/i386/i386.md
--- gcc-5.2.0.orig/gcc/config/i386/i386.md	2015-06-26 05:30:37.000000000 -0500
+++ gcc-5.2.0/gcc/config/i386/i386.md	2015-09-22 04:49:20.487735000 -0500
@@ -102,7 +102,6 @@
   UNSPEC_SAHF
   UNSPEC_PARITY
   UNSPEC_FSTCW
-  UNSPEC_ADD_CARRY
   UNSPEC_FLDCW
   UNSPEC_REP
   UNSPEC_LD_MPIC	; load_macho_picbase
@@ -783,7 +782,8 @@
 (define_attr "isa" "base,x64,x64_sse4,x64_sse4_noavx,x64_avx,nox64,
 		    sse2,sse2_noavx,sse3,sse4,sse4_noavx,avx,noavx,
 		    avx2,noavx2,bmi,bmi2,fma4,fma,avx512f,noavx512f,
-		    fma_avx512f,avx512bw,noavx512bw,avx512dq,noavx512dq"
+		    fma_avx512f,avx512bw,noavx512bw,avx512dq,noavx512dq,
+		    avx512vl,noavx512vl"
   (const_string "base"))
 
 (define_attr "enabled" ""
@@ -818,6 +818,8 @@
 	 (eq_attr "isa" "noavx512bw") (symbol_ref "!TARGET_AVX512BW")
 	 (eq_attr "isa" "avx512dq") (symbol_ref "TARGET_AVX512DQ")
 	 (eq_attr "isa" "noavx512dq") (symbol_ref "!TARGET_AVX512DQ")
+	 (eq_attr "isa" "avx512vl") (symbol_ref "TARGET_AVX512VL")
+	 (eq_attr "isa" "noavx512vl") (symbol_ref "!TARGET_AVX512VL")
 	]
 	(const_int 1)))
 
@@ -844,8 +846,6 @@
 (define_code_attr plusminus_mnemonic
   [(plus "add") (ss_plus "adds") (us_plus "addus")
    (minus "sub") (ss_minus "subs") (us_minus "subus")])
-(define_code_attr plusminus_carry_mnemonic
-  [(plus "adc") (minus "sbb")])
 (define_code_attr multdiv_mnemonic
   [(mult "mul") (div "div")])
 
@@ -5051,11 +5051,11 @@
   /* The DImode arrived in a pair of integral registers (e.g. %edx:%eax).
      Assemble the 64-bit DImode value in an xmm register.  */
   emit_insn (gen_sse2_loadld (operands[3], CONST0_RTX (V4SImode),
-			      gen_rtx_SUBREG (SImode, operands[1], 0)));
+			      gen_lowpart (SImode, operands[1])));
   emit_insn (gen_sse2_loadld (operands[4], CONST0_RTX (V4SImode),
-			      gen_rtx_SUBREG (SImode, operands[1], 4)));
+			      gen_highpart (SImode, operands[1])));
   emit_insn (gen_vec_interleave_lowv4si (operands[3], operands[3],
-  	    				 operands[4]));
+					 operands[4]));
 
   operands[3] = gen_rtx_REG (DImode, REGNO (operands[3]));
 })
@@ -5213,46 +5213,21 @@
   "ix86_binary_operator_ok (PLUS, <DWI>mode, operands)"
   "#"
   "reload_completed"
-  [(parallel [(set (reg:CC FLAGS_REG)
-		   (unspec:CC [(match_dup 1) (match_dup 2)]
-			      UNSPEC_ADD_CARRY))
+  [(parallel [(set (reg:CCC FLAGS_REG)
+		   (compare:CCC
+		     (plus:DWIH (match_dup 1) (match_dup 2))
+		     (match_dup 1)))
 	      (set (match_dup 0)
 		   (plus:DWIH (match_dup 1) (match_dup 2)))])
    (parallel [(set (match_dup 3)
 		   (plus:DWIH
-		     (match_dup 4)
 		     (plus:DWIH
 		       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))
-		       (match_dup 5))))
+		       (match_dup 4))
+		     (match_dup 5)))
 	      (clobber (reg:CC FLAGS_REG))])]
   "split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);")
 
-(define_insn "*add<mode>3_cc"
-  [(set (reg:CC FLAGS_REG)
-	(unspec:CC
-	  [(match_operand:SWI48 1 "nonimmediate_operand" "%0,0")
-	   (match_operand:SWI48 2 "<general_operand>" "r<i>,rm")]
-	  UNSPEC_ADD_CARRY))
-   (set (match_operand:SWI48 0 "nonimmediate_operand" "=rm,r")
-	(plus:SWI48 (match_dup 1) (match_dup 2)))]
-  "ix86_binary_operator_ok (PLUS, <MODE>mode, operands)"
-  "add{<imodesuffix>}\t{%2, %0|%0, %2}"
-  [(set_attr "type" "alu")
-   (set_attr "mode" "<MODE>")])
-
-(define_insn "addqi3_cc"
-  [(set (reg:CC FLAGS_REG)
-	(unspec:CC
-	  [(match_operand:QI 1 "nonimmediate_operand" "%0,0")
-	   (match_operand:QI 2 "general_operand" "qn,qm")]
-	  UNSPEC_ADD_CARRY))
-   (set (match_operand:QI 0 "nonimmediate_operand" "=qm,q")
-	(plus:QI (match_dup 1) (match_dup 2)))]
-  "ix86_binary_operator_ok (PLUS, QImode, operands)"
-  "add{b}\t{%2, %0|%0, %2}"
-  [(set_attr "type" "alu")
-   (set_attr "mode" "QI")])
-
 (define_insn "*add<mode>_1"
   [(set (match_operand:SWI48 0 "nonimmediate_operand" "=r,rm,r,r")
 	(plus:SWI48
@@ -6160,10 +6135,10 @@
 		   (minus:DWIH (match_dup 1) (match_dup 2)))])
    (parallel [(set (match_dup 3)
 		   (minus:DWIH
-		     (match_dup 4)
-		     (plus:DWIH
-		       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))
-		       (match_dup 5))))
+		     (minus:DWIH
+		       (match_dup 4)
+		       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0)))
+		     (match_dup 5)))
 	      (clobber (reg:CC FLAGS_REG))])]
   "split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);")
 
@@ -6327,29 +6302,17 @@
 
 ;; Add with carry and subtract with borrow
 
-(define_expand "<plusminus_insn><mode>3_carry"
-  [(parallel
-    [(set (match_operand:SWI 0 "nonimmediate_operand")
-	  (plusminus:SWI
-	    (match_operand:SWI 1 "nonimmediate_operand")
-	    (plus:SWI (match_operator:SWI 4 "ix86_carry_flag_operator"
-		       [(match_operand 3 "flags_reg_operand")
-			(const_int 0)])
-		      (match_operand:SWI 2 "<general_operand>"))))
-     (clobber (reg:CC FLAGS_REG))])]
-  "ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)")
-
-(define_insn "*<plusminus_insn><mode>3_carry"
+(define_insn "add<mode>3_carry"
   [(set (match_operand:SWI 0 "nonimmediate_operand" "=<r>m,<r>")
-	(plusminus:SWI
-	  (match_operand:SWI 1 "nonimmediate_operand" "<comm>0,0")
+	(plus:SWI
 	  (plus:SWI
-	    (match_operator 3 "ix86_carry_flag_operator"
-	     [(reg FLAGS_REG) (const_int 0)])
-	    (match_operand:SWI 2 "<general_operand>" "<r><i>,<r>m"))))
+	    (match_operator:SWI 4 "ix86_carry_flag_operator"
+	     [(match_operand 3 "flags_reg_operand") (const_int 0)])
+	    (match_operand:SWI 1 "nonimmediate_operand" "%0,0"))
+	  (match_operand:SWI 2 "<general_operand>" "<r><i>,<r>m")))
    (clobber (reg:CC FLAGS_REG))]
   "ix86_binary_operator_ok (PLUS, <MODE>mode, operands)"
-  "<plusminus_carry_mnemonic>{<imodesuffix>}\t{%2, %0|%0, %2}"
+  "adc{<imodesuffix>}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
    (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
@@ -6358,10 +6321,11 @@
 (define_insn "*addsi3_carry_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (plus:SI (match_operand:SI 1 "nonimmediate_operand" "%0")
-		   (plus:SI (match_operator 3 "ix86_carry_flag_operator"
-			     [(reg FLAGS_REG) (const_int 0)])
-			    (match_operand:SI 2 "x86_64_general_operand" "rme")))))
+	  (plus:SI
+	    (plus:SI (match_operator:SI 3 "ix86_carry_flag_operator"
+		      [(reg FLAGS_REG) (const_int 0)])
+		     (match_operand:SI 1 "register_operand" "%0"))
+	    (match_operand:SI 2 "x86_64_general_operand" "rme"))))
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)"
   "adc{l}\t{%2, %k0|%k0, %2}"
@@ -6370,45 +6334,96 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
+;; There is no point to generate ADCX instruction. ADC is shorter and faster.
+
+(define_insn "addcarry<mode>"
+  [(set (reg:CCC FLAGS_REG)
+	(compare:CCC
+	  (plus:SWI48
+	    (plus:SWI48
+	      (match_operator:SWI48 4 "ix86_carry_flag_operator"
+	       [(match_operand 3 "flags_reg_operand") (const_int 0)])
+	      (match_operand:SWI48 1 "nonimmediate_operand" "%0"))
+	    (match_operand:SWI48 2 "nonimmediate_operand" "rm"))
+	  (match_dup 1)))
+   (set (match_operand:SWI48 0 "register_operand" "=r")
+	(plus:SWI48 (plus:SWI48 (match_op_dup 4
+				 [(match_dup 3) (const_int 0)])
+				(match_dup 1))
+		    (match_dup 2)))]
+  "ix86_binary_operator_ok (PLUS, <MODE>mode, operands)"
+  "adc{<imodesuffix>}\t{%2, %0|%0, %2}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "sub<mode>3_carry"
+  [(set (match_operand:SWI 0 "nonimmediate_operand" "=<r>m,<r>")
+	(minus:SWI
+	  (minus:SWI
+	    (match_operand:SWI 1 "nonimmediate_operand" "0,0")
+	    (match_operator:SWI 4 "ix86_carry_flag_operator"
+	     [(match_operand 3 "flags_reg_operand") (const_int 0)]))
+	  (match_operand:SWI 2 "<general_operand>" "<r><i>,<r>m")))
+   (clobber (reg:CC FLAGS_REG))]
+  "ix86_binary_operator_ok (MINUS, <MODE>mode, operands)"
+  "sbb{<imodesuffix>}\t{%2, %0|%0, %2}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*subsi3_carry_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (minus:SI (match_operand:SI 1 "register_operand" "0")
-		    (plus:SI (match_operator 3 "ix86_carry_flag_operator"
-			      [(reg FLAGS_REG) (const_int 0)])
-			     (match_operand:SI 2 "x86_64_general_operand" "rme")))))
+	  (minus:SI
+	    (minus:SI
+	      (match_operand:SI 1 "register_operand" "0")
+	      (match_operator:SI 3 "ix86_carry_flag_operator"
+	       [(reg FLAGS_REG) (const_int 0)]))
+	    (match_operand:SI 2 "x86_64_general_operand" "rme"))))
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && ix86_binary_operator_ok (MINUS, SImode, operands)"
   "sbb{l}\t{%2, %k0|%k0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
-
-;; ADCX instruction
 
-(define_insn "adcx<mode>3"
+(define_insn "subborrow<mode>"
   [(set (reg:CCC FLAGS_REG)
 	(compare:CCC
+	  (match_operand:SWI48 1 "nonimmediate_operand" "0")
 	  (plus:SWI48
-	    (match_operand:SWI48 1 "nonimmediate_operand" "%0")
-	    (plus:SWI48
-	      (match_operator 4 "ix86_carry_flag_operator"
-	       [(match_operand 3 "flags_reg_operand") (const_int 0)])
-	      (match_operand:SWI48 2 "nonimmediate_operand" "rm")))
-	  (const_int 0)))
+	    (match_operator:SWI48 4 "ix86_carry_flag_operator"
+	     [(match_operand 3 "flags_reg_operand") (const_int 0)])
+	    (match_operand:SWI48 2 "nonimmediate_operand" "rm"))))
    (set (match_operand:SWI48 0 "register_operand" "=r")
-	(plus:SWI48 (match_dup 1)
-		    (plus:SWI48 (match_op_dup 4
-				 [(match_dup 3) (const_int 0)])
-				(match_dup 2))))]
-  "TARGET_ADX && ix86_binary_operator_ok (PLUS, <MODE>mode, operands)"
-  "adcx\t{%2, %0|%0, %2}"
+	(minus:SWI48 (minus:SWI48 (match_dup 1)
+				  (match_op_dup 4
+				   [(match_dup 3) (const_int 0)]))
+		     (match_dup 2)))]
+  "ix86_binary_operator_ok (MINUS, <MODE>mode, operands)"
+  "sbb{<imodesuffix>}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
    (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
    (set_attr "mode" "<MODE>")])
 
 ;; Overflow setting add instructions
 
+(define_expand "addqi3_cconly_overflow"
+  [(parallel
+     [(set (reg:CCC FLAGS_REG)
+	   (compare:CCC
+	     (plus:QI
+	       (match_operand:QI 0 "nonimmediate_operand")
+	       (match_operand:QI 1 "general_operand"))
+	     (match_dup 0)))
+      (clobber (match_scratch:QI 2))])]
+  "!(MEM_P (operands[0]) && MEM_P (operands[1]))")
+
 (define_insn "*add<mode>3_cconly_overflow"
   [(set (reg:CCC FLAGS_REG)
 	(compare:CCC
@@ -8462,11 +8477,11 @@
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_AVX512F && reload_completed"
    [(parallel [(set (match_dup 0)
-		    (xor:HI (match_dup 0)
-			    (match_dup 1)))
+		    (xor:SWI1248x (match_dup 0)
+				  (match_dup 1)))
 	       (clobber (reg:CC FLAGS_REG))])
     (set (match_dup 0)
-	 (not:HI (match_dup 0)))])
+	 (not:SWI1248x (match_dup 0)))])
 
 ;;There are kortrest[bdq] but no intrinsics for them.
 ;;We probably don't need to implement them.
@@ -8500,7 +8515,7 @@
   [(set (match_operand:HI 0 "register_operand" "=k")
 	(ior:HI
 	  (ashift:HI
-	    (match_operand:HI 1 "register_operand" "k")
+	    (zero_extend:HI (match_operand:QI 1 "register_operand" "k"))
 	    (const_int 8))
 	  (zero_extend:HI (match_operand:QI 2 "register_operand" "k"))))]
   "TARGET_AVX512F"
@@ -8513,9 +8528,9 @@
   [(set (match_operand:SI 0 "register_operand" "=k")
 	(ior:SI
 	  (ashift:SI
-	    (match_operand:SI 1 "register_operand" "k")
+	    (zero_extend:SI (match_operand:HI 1 "register_operand" "k"))
 	    (const_int 16))
-	  (zero_extend:SI (subreg:HI (match_operand:SI 2 "register_operand" "k") 0))))]
+	  (zero_extend:SI (match_operand:HI 2 "register_operand" "k"))))]
   "TARGET_AVX512BW"
   "kunpckwd\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "mode" "SI")])
@@ -8524,9 +8539,9 @@
   [(set (match_operand:DI 0 "register_operand" "=k")
 	(ior:DI
 	  (ashift:DI
-	    (match_operand:DI 1 "register_operand" "k")
+	    (zero_extend:DI (match_operand:SI 1 "register_operand" "k"))
 	    (const_int 32))
-	  (zero_extend:DI (subreg:SI (match_operand:DI 2 "register_operand" "k") 0))))]
+	  (zero_extend:DI (match_operand:SI 2 "register_operand" "k"))))]
   "TARGET_AVX512BW"
   "kunpckdq\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "mode" "DI")])
@@ -8754,9 +8769,9 @@
      (set (match_dup 0) (neg:DWIH (match_dup 1)))])
    (parallel
     [(set (match_dup 2)
-	  (plus:DWIH (match_dup 3)
-		     (plus:DWIH (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))
-				(const_int 0))))
+	  (plus:DWIH (plus:DWIH (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))
+				(match_dup 3))
+		     (const_int 0)))
      (clobber (reg:CC FLAGS_REG))])
    (parallel
     [(set (match_dup 2)
@@ -13237,7 +13252,8 @@
 	(call:P
 	 (mem:QI (match_operand 2 "constant_call_address_operand" "Bz"))
 	 (match_operand 3)))
-   (unspec:P [(match_operand 1 "tls_symbolic_operand")]
+   (unspec:P [(match_operand 1 "tls_symbolic_operand")
+	      (reg:P SP_REG)]
 	     UNSPEC_TLS_GD)]
   "TARGET_64BIT"
 {
@@ -13261,8 +13277,9 @@
 	 (mem:QI (plus:DI (match_operand:DI 2 "register_operand" "b")
 			  (match_operand:DI 3 "immediate_operand" "i")))
 	 (match_operand 4)))
-   (unspec:DI [(match_operand 1 "tls_symbolic_operand")]
-	     UNSPEC_TLS_GD)]
+   (unspec:DI [(match_operand 1 "tls_symbolic_operand")
+	       (reg:DI SP_REG)]
+	      UNSPEC_TLS_GD)]
   "TARGET_64BIT && ix86_cmodel == CM_LARGE_PIC && !TARGET_PECOFF
    && GET_CODE (operands[3]) == CONST
    && GET_CODE (XEXP (operands[3], 0)) == UNSPEC
@@ -13283,7 +13300,8 @@
 	  (call:P
 	   (mem:QI (match_operand 2))
 	   (const_int 0)))
-     (unspec:P [(match_operand 1 "tls_symbolic_operand")]
+     (unspec:P [(match_operand 1 "tls_symbolic_operand")
+		(reg:P SP_REG)]
 	       UNSPEC_TLS_GD)])]
   "TARGET_64BIT"
   "ix86_tls_descriptor_calls_expanded_in_cfun = true;")
@@ -13333,7 +13351,7 @@
 	(call:P
 	 (mem:QI (match_operand 1 "constant_call_address_operand" "Bz"))
 	 (match_operand 2)))
-   (unspec:P [(const_int 0)] UNSPEC_TLS_LD_BASE)]
+   (unspec:P [(reg:P SP_REG)] UNSPEC_TLS_LD_BASE)]
   "TARGET_64BIT"
 {
   output_asm_insn
@@ -13351,7 +13369,7 @@
 	 (mem:QI (plus:DI (match_operand:DI 1 "register_operand" "b")
 			  (match_operand:DI 2 "immediate_operand" "i")))
 	 (match_operand 3)))
-   (unspec:DI [(const_int 0)] UNSPEC_TLS_LD_BASE)]
+   (unspec:DI [(reg:DI SP_REG)] UNSPEC_TLS_LD_BASE)]
   "TARGET_64BIT && ix86_cmodel == CM_LARGE_PIC && !TARGET_PECOFF
    && GET_CODE (operands[2]) == CONST
    && GET_CODE (XEXP (operands[2], 0)) == UNSPEC
@@ -13372,7 +13390,7 @@
 	   (call:P
 	    (mem:QI (match_operand 1))
 	    (const_int 0)))
-      (unspec:P [(const_int 0)] UNSPEC_TLS_LD_BASE)])]
+      (unspec:P [(reg:P SP_REG)] UNSPEC_TLS_LD_BASE)])]
   "TARGET_64BIT"
   "ix86_tls_descriptor_calls_expanded_in_cfun = true;")
 
@@ -17431,8 +17449,8 @@
 ;; lifetime information then.
 
 (define_peephole2
-  [(set (match_operand:SWI124 0 "nonimmediate_operand")
-	(not:SWI124 (match_operand:SWI124 1 "nonimmediate_operand")))]
+  [(set (match_operand:SWI124 0 "nonimmediate_gr_operand")
+	(not:SWI124 (match_operand:SWI124 1 "nonimmediate_gr_operand")))]
   "optimize_insn_for_speed_p ()
    && ((TARGET_NOT_UNPAIRABLE
 	&& (!MEM_P (operands[0])
@@ -17576,8 +17594,10 @@
                      [(match_dup 0)
                       (match_operand 2 "memory_operand")]))]
   "REGNO (operands[0]) != REGNO (operands[1])
-   && ((MMX_REG_P (operands[0]) && MMX_REG_P (operands[1])) 
-       || (SSE_REG_P (operands[0]) && SSE_REG_P (operands[1])))"
+   && ((MMX_REGNO_P (REGNO (operands[0]))
+        && MMX_REGNO_P (REGNO (operands[1]))) 
+       || (SSE_REGNO_P (REGNO (operands[0]))
+           && SSE_REGNO_P (REGNO (operands[1]))))"
   [(set (match_dup 0) (match_dup 2))
    (set (match_dup 0)
         (match_op_dup 3 [(match_dup 0) (match_dup 1)]))])
@@ -17725,7 +17745,7 @@
 	(match_operand 1 "const0_operand"))]
   "GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD
    && (! TARGET_USE_MOV0 || optimize_insn_for_size_p ())
-   && GENERAL_REG_P (operands[0])
+   && GENERAL_REGNO_P (REGNO (operands[0]))
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 0) (const_int 0))
 	      (clobber (reg:CC FLAGS_REG))])]
@@ -17746,6 +17766,7 @@
   [(set (match_operand:SWI248 0 "register_operand")
 	(const_int -1))]
   "(optimize_insn_for_size_p () || TARGET_MOVE_M1_VIA_OR)
+   && GENERAL_REGNO_P (REGNO (operands[0]))
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 0) (const_int -1))
 	      (clobber (reg:CC FLAGS_REG))])]
@@ -18113,11 +18134,13 @@
 
   operands[1] = gen_rtx_PLUS (word_mode, base,
 			      gen_rtx_MULT (word_mode, index, GEN_INT (scale)));
-  operands[5] = base;
   if (mode != word_mode)
     operands[1] = gen_rtx_SUBREG (mode, operands[1], 0);
+
+  operands[5] = base;
   if (op1mode != word_mode)
-    operands[5] = gen_rtx_SUBREG (op1mode, operands[5], 0);
+    operands[5] = gen_lowpart (op1mode, operands[5]);
+
   operands[0] = dest;
 })
 
diff -Naur gcc-5.2.0.orig/gcc/config/i386/intelmic-mkoffload.c gcc-5.2.0/gcc/config/i386/intelmic-mkoffload.c
--- gcc-5.2.0.orig/gcc/config/i386/intelmic-mkoffload.c	2015-04-06 07:40:28.000000000 -0500
+++ gcc-5.2.0/gcc/config/i386/intelmic-mkoffload.c	2015-09-07 10:32:23.683954000 -0500
@@ -453,17 +453,18 @@
   fork_execute (objcopy_argv[0], CONST_CAST (char **, objcopy_argv), false);
 
   /* Objcopy has created symbols, containing the input file name with
-     special characters replaced with '_'.  We are going to rename these
-     new symbols.  */
+     non-alphanumeric characters replaced by underscores.
+     We are going to rename these new symbols.  */
   size_t symbol_name_len = strlen (target_so_filename);
   char *symbol_name = XALLOCAVEC (char, symbol_name_len + 1);
-  for (size_t i = 0; i <= symbol_name_len; i++)
+  for (size_t i = 0; i < symbol_name_len; i++)
     {
       char c = target_so_filename[i];
-      if ((c == '/') || (c == '.'))
+      if (!ISALNUM (c))
 	c = '_';
       symbol_name[i] = c;
     }
+  symbol_name[symbol_name_len] = '\0';
 
   char *opt_for_objcopy[3];
   opt_for_objcopy[0] = XALLOCAVEC (char, sizeof ("_binary__start=")
diff -Naur gcc-5.2.0.orig/gcc/config/i386/predicates.md gcc-5.2.0/gcc/config/i386/predicates.md
--- gcc-5.2.0.orig/gcc/config/i386/predicates.md	2015-01-31 09:30:30.000000000 -0600
+++ gcc-5.2.0/gcc/config/i386/predicates.md	2015-07-17 11:27:58.471071000 -0500
@@ -37,6 +37,12 @@
   (and (match_code "reg")
        (match_test "GENERAL_REG_P (op)")))
 
+;; True if the operand is a nonimmediate operand with GENERAL class register.
+(define_predicate "nonimmediate_gr_operand"
+  (if_then_else (match_code "reg")
+    (match_test "GENERAL_REGNO_P (REGNO (op))")
+    (match_operand 0 "nonimmediate_operand")))
+
 ;; Return true if OP is a register operand other than an i387 fp register.
 (define_predicate "register_and_not_fp_reg_operand"
   (and (match_code "reg")
diff -Naur gcc-5.2.0.orig/gcc/config/i386/sol2.h gcc-5.2.0/gcc/config/i386/sol2.h
--- gcc-5.2.0.orig/gcc/config/i386/sol2.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/i386/sol2.h	2015-10-01 07:01:18.897040000 -0500
@@ -86,13 +86,10 @@
 #endif
 #endif
 
-#undef  ENDFILE_SPEC
-#define ENDFILE_SPEC \
-  "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
-   %{mpc32:crtprec32.o%s} \
+#define ENDFILE_ARCH_SPEC \
+  "%{mpc32:crtprec32.o%s} \
    %{mpc64:crtprec64.o%s} \
-   %{mpc80:crtprec80.o%s} \
-   crtend.o%s crtn.o%s"
+   %{mpc80:crtprec80.o%s}"
 
 #define SUBTARGET_CPU_EXTRA_SPECS \
   { "cpp_subtarget",	 CPP_SUBTARGET_SPEC },		\
diff -Naur gcc-5.2.0.orig/gcc/config/i386/sse.md gcc-5.2.0/gcc/config/i386/sse.md
--- gcc-5.2.0.orig/gcc/config/i386/sse.md	2015-06-08 05:28:40.000000000 -0500
+++ gcc-5.2.0/gcc/config/i386/sse.md	2015-10-12 06:03:56.562174000 -0500
@@ -375,8 +375,8 @@
   [(V16HI "TARGET_AVX2") V8HI
    (V8SI "TARGET_AVX2") V4SI])
 
-(define_mode_iterator VI124_AVX512F
-  [(V32QI "TARGET_AVX2") V16QI
+(define_mode_iterator VI124_AVX2_24_AVX512F_1_AVX512BW
+  [(V64QI "TARGET_AVX512BW") (V32QI "TARGET_AVX2") V16QI
    (V32HI "TARGET_AVX512F") (V16HI "TARGET_AVX2") V8HI
    (V16SI "TARGET_AVX512F") (V8SI "TARGET_AVX2") V4SI])
 
@@ -392,9 +392,9 @@
   [(V8SI "TARGET_AVX2") V4SI
    (V4DI "TARGET_AVX2") V2DI])
 
-(define_mode_iterator VI248_AVX2_8_AVX512F
-  [(V16HI "TARGET_AVX2") V8HI
-   (V8SI "TARGET_AVX2") V4SI
+(define_mode_iterator VI248_AVX2_8_AVX512F_24_AVX512BW
+  [(V32HI "TARGET_AVX512BW") (V16HI "TARGET_AVX2") V8HI
+   (V16SI "TARGET_AVX512BW") (V8SI "TARGET_AVX2") V4SI
    (V8DI "TARGET_AVX512F") (V4DI "TARGET_AVX2") V2DI])
 
 (define_mode_iterator VI248_AVX512BW_AVX512VL
@@ -410,6 +410,14 @@
   [(V16SI "TARGET_AVX512F") V8SI V4SI
    (V8DI "TARGET_AVX512F") V4DI V2DI])
 
+(define_mode_iterator VI48_AVX_AVX512F
+  [(V16SI "TARGET_AVX512F") (V8SI "TARGET_AVX") V4SI
+   (V8DI "TARGET_AVX512F") (V4DI "TARGET_AVX") V2DI])
+
+(define_mode_iterator VI12_AVX_AVX512F
+  [ (V64QI "TARGET_AVX512F") (V32QI "TARGET_AVX") V16QI
+    (V32HI "TARGET_AVX512F") (V16HI "TARGET_AVX") V8HI])
+
 (define_mode_iterator V48_AVX2
   [V4SF V2DF
    V8SF V4DF
@@ -1078,9 +1086,9 @@
       /* The DImode arrived in a pair of integral registers (e.g. %edx:%eax).
 	 Assemble the 64-bit DImode value in an xmm register.  */
       emit_insn (gen_sse2_loadld (operands[0], CONST0_RTX (V4SImode),
-				  gen_rtx_SUBREG (SImode, operands[1], 0)));
+				  gen_lowpart (SImode, operands[1])));
       emit_insn (gen_sse2_loadld (operands[2], CONST0_RTX (V4SImode),
-				  gen_rtx_SUBREG (SImode, operands[1], 4)));
+				  gen_highpart (SImode, operands[1])));
       emit_insn (gen_vec_interleave_lowv4si (operands[0], operands[0],
 					     operands[2]));
    }
@@ -8490,42 +8498,48 @@
    (set_attr "mode" "DF,DF,V1DF,V1DF,V1DF,V2DF,V1DF,V1DF,V1DF")])
 
 (define_insn "vec_dupv2df<mask_name>"
-  [(set (match_operand:V2DF 0 "register_operand"     "=x,v")
+  [(set (match_operand:V2DF 0 "register_operand"     "=x,x,v")
 	(vec_duplicate:V2DF
-	  (match_operand:DF 1 "nonimmediate_operand" " 0,vm")))]
+	  (match_operand:DF 1 "nonimmediate_operand" " 0,xm,vm")))]
   "TARGET_SSE2 && <mask_avx512vl_condition>"
   "@
    unpcklpd\t%0, %0
-   %vmovddup\t{%1, %0<mask_operand2>|%0<mask_operand2>, %1}"
-  [(set_attr "isa" "noavx,sse3")
+   %vmovddup\t{%1, %0<mask_operand2>|%0<mask_operand2>, %1}
+   vmovddup\t{%1, %0<mask_operand2>|%0<mask_operand2>, %1}"
+  [(set_attr "isa" "noavx,sse3,avx512vl")
    (set_attr "type" "sselog1")
-   (set_attr "prefix" "orig,maybe_vex")
-   (set_attr "mode" "V2DF,DF")])
+   (set_attr "prefix" "orig,maybe_vex,evex")
+   (set_attr "mode" "V2DF,DF,DF")])
 
 (define_insn "*vec_concatv2df"
-  [(set (match_operand:V2DF 0 "register_operand"     "=x,v,v,x,x,v,x,x")
+  [(set (match_operand:V2DF 0 "register_operand"     "=x,x,v,x,v,x,x,v,x,x")
 	(vec_concat:V2DF
-	  (match_operand:DF 1 "nonimmediate_operand" " 0,v,m,0,x,m,0,0")
-	  (match_operand:DF 2 "vector_move_operand"  " x,v,1,m,m,C,x,m")))]
+	  (match_operand:DF 1 "nonimmediate_operand" " 0,x,v,m,m,0,x,m,0,0")
+	  (match_operand:DF 2 "vector_move_operand"  " x,x,v,1,1,m,m,C,x,m")))]
   "TARGET_SSE"
   "@
    unpcklpd\t{%2, %0|%0, %2}
    vunpcklpd\t{%2, %1, %0|%0, %1, %2}
+   vunpcklpd\t{%2, %1, %0|%0, %1, %2}
    %vmovddup\t{%1, %0|%0, %1}
+   vmovddup\t{%1, %0|%0, %1}
    movhpd\t{%2, %0|%0, %2}
    vmovhpd\t{%2, %1, %0|%0, %1, %2}
    %vmovsd\t{%1, %0|%0, %1}
    movlhps\t{%2, %0|%0, %2}
    movhps\t{%2, %0|%0, %2}"
-  [(set_attr "isa" "sse2_noavx,avx,sse3,sse2_noavx,avx,sse2,noavx,noavx")
+  [(set_attr "isa" "sse2_noavx,avx,avx512vl,sse3,avx512vl,sse2_noavx,avx,sse2,noavx,noavx")
    (set (attr "type")
      (if_then_else
-       (eq_attr "alternative" "0,1,2")
+       (eq_attr "alternative" "0,1,2,3,4")
        (const_string "sselog")
        (const_string "ssemov")))
-   (set_attr "prefix_data16" "*,*,*,1,*,*,*,*")
-   (set_attr "prefix" "orig,vex,maybe_vex,orig,vex,maybe_vex,orig,orig")
-   (set_attr "mode" "V2DF,V2DF,DF,V1DF,V1DF,DF,V4SF,V2SF")])
+   (set (attr "prefix_data16")
+	(if_then_else (eq_attr "alternative" "5")
+		      (const_string "1")
+		      (const_string "*")))
+   (set_attr "prefix" "orig,vex,evex,maybe_vex,evex,orig,vex,maybe_vex,orig,orig")
+   (set_attr "mode" "V2DF,V2DF,V2DF, DF, DF, V1DF,V1DF,DF,V4SF,V2SF")])
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
@@ -8575,7 +8589,7 @@
       (match_operand:<avx512fmaskmode> 2 "register_operand")))]
   "TARGET_AVX512F")
 
-(define_insn "*avx512bw_<code>v32hiv32qi2"
+(define_insn "avx512bw_<code>v32hiv32qi2"
   [(set (match_operand:V32QI 0 "nonimmediate_operand" "=v,m")
 	(any_truncate:V32QI
 	    (match_operand:V32HI 1 "register_operand" "v,v")))]
@@ -10911,10 +10925,10 @@
 })
 
 (define_insn "<mask_codefor><code><mode>3<mask_name>"
-  [(set (match_operand:VI 0 "register_operand" "=x,v")
-	(any_logic:VI
-	  (match_operand:VI 1 "nonimmediate_operand" "%0,v")
-	  (match_operand:VI 2 "nonimmediate_operand" "xm,vm")))]
+  [(set (match_operand:VI48_AVX_AVX512F 0 "register_operand" "=x,v")
+	(any_logic:VI48_AVX_AVX512F
+	  (match_operand:VI48_AVX_AVX512F 1 "nonimmediate_operand" "%0,v")
+	  (match_operand:VI48_AVX_AVX512F 2 "nonimmediate_operand" "xm,vm")))]
   "TARGET_SSE && <mask_mode512bit_condition>
    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)"
 {
@@ -10943,24 +10957,120 @@
         case V4DImode:
         case V4SImode:
         case V2DImode:
-          if (TARGET_AVX512VL)
+          tmp = TARGET_AVX512VL ? "p<logic><ssemodesuffix>" : "p<logic>";
+          break;
+        default:
+          gcc_unreachable ();
+      }
+      break;
+
+   case MODE_V8SF:
+      gcc_assert (TARGET_AVX);
+   case MODE_V4SF:
+      gcc_assert (TARGET_SSE);
+      gcc_assert (!<mask_applied>);
+      tmp = "<logic>ps";
+      break;
+
+   default:
+      gcc_unreachable ();
+   }
+
+  switch (which_alternative)
+    {
+    case 0:
+      if (<mask_applied>)
+        ops = "v%s\t{%%2, %%0, %%0<mask_operand3_1>|%%0<mask_operand3_1>, %%0, %%2}";
+      else
+        ops = "%s\t{%%2, %%0|%%0, %%2}";
+      break;
+    case 1:
+      ops = "v%s\t{%%2, %%1, %%0<mask_operand3_1>|%%0<mask_operand3_1>, %%1, %%2}";
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  snprintf (buf, sizeof (buf), ops, tmp);
+  return buf;
+}
+  [(set_attr "isa" "noavx,avx")
+   (set_attr "type" "sselog")
+   (set (attr "prefix_data16")
+     (if_then_else
+       (and (eq_attr "alternative" "0")
+	    (eq_attr "mode" "TI"))
+       (const_string "1")
+       (const_string "*")))
+   (set_attr "prefix" "<mask_prefix3>")
+   (set (attr "mode")
+	(cond [(and (match_test "<MODE_SIZE> == 16")
+		    (match_test "TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL"))
+		 (const_string "<ssePSmode>")
+	       (match_test "TARGET_AVX2")
+		 (const_string "<sseinsnmode>")
+	       (match_test "TARGET_AVX")
+		 (if_then_else
+		   (match_test "<MODE_SIZE> > 16")
+		   (const_string "V8SF")
+		   (const_string "<sseinsnmode>"))
+	       (ior (not (match_test "TARGET_SSE2"))
+		    (match_test "optimize_function_for_size_p (cfun)"))
+		 (const_string "V4SF")
+	      ]
+	      (const_string "<sseinsnmode>")))])
+
+(define_insn "*<code><mode>3"
+  [(set (match_operand:VI12_AVX_AVX512F 0 "register_operand" "=x,v")
+	(any_logic: VI12_AVX_AVX512F
+	  (match_operand:VI12_AVX_AVX512F 1 "nonimmediate_operand" "%0,v")
+	  (match_operand:VI12_AVX_AVX512F 2 "nonimmediate_operand" "xm,vm")))]
+  "TARGET_SSE && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)"
+{
+  static char buf[64];
+  const char *ops;
+  const char *tmp;
+  const char *ssesuffix;
+
+  switch (get_attr_mode (insn))
+    {
+    case MODE_XI:
+      gcc_assert (TARGET_AVX512F);
+    case MODE_OI:
+      gcc_assert (TARGET_AVX2 || TARGET_AVX512VL);
+    case MODE_TI:
+      gcc_assert (TARGET_SSE2 || TARGET_AVX512VL);
+      switch (<MODE>mode)
+        {
+        case V64QImode:
+        case V32HImode:
+          if (TARGET_AVX512F)
           {
-            tmp = "p<logic><ssemodesuffix>";
+            tmp = "p<logic>";
+            ssesuffix = "q";
+            break;
+          }
+        case V32QImode:
+        case V16HImode:
+        case V16QImode:
+        case V8HImode:
+          if (TARGET_AVX512VL || TARGET_AVX2 || TARGET_SSE2)
+          {
+            tmp = "p<logic>";
+            ssesuffix = TARGET_AVX512VL ? "q" : "";
             break;
           }
         default:
-          tmp = TARGET_AVX512VL ? "p<logic>q" : "p<logic>";
+          gcc_unreachable ();
       }
       break;
 
-   case MODE_V16SF:
-      gcc_assert (TARGET_AVX512F);
    case MODE_V8SF:
       gcc_assert (TARGET_AVX);
    case MODE_V4SF:
       gcc_assert (TARGET_SSE);
-
       tmp = "<logic>ps";
+      ssesuffix = "";
       break;
 
    default:
@@ -10971,15 +11081,16 @@
     {
     case 0:
       ops = "%s\t{%%2, %%0|%%0, %%2}";
+      snprintf (buf, sizeof (buf), ops, tmp);
       break;
     case 1:
-      ops = "v%s\t{%%2, %%1, %%0<mask_operand3_1>|%%0<mask_operand3_1>, %%1, %%2}";
+      ops = "v%s%s\t{%%2, %%1, %%0|%%0, %%1, %%2}";
+      snprintf (buf, sizeof (buf), ops, tmp, ssesuffix);
       break;
     default:
       gcc_unreachable ();
     }
 
-  snprintf (buf, sizeof (buf), ops, tmp);
   return buf;
 }
   [(set_attr "isa" "noavx,avx")
@@ -11060,8 +11171,8 @@
 
 (define_expand "vec_pack_trunc_<mode>"
   [(match_operand:<ssepackmode> 0 "register_operand")
-   (match_operand:VI248_AVX2_8_AVX512F 1 "register_operand")
-   (match_operand:VI248_AVX2_8_AVX512F 2 "register_operand")]
+   (match_operand:VI248_AVX2_8_AVX512F_24_AVX512BW 1 "register_operand")
+   (match_operand:VI248_AVX2_8_AVX512F_24_AVX512BW 2 "register_operand")]
   "TARGET_SSE2"
 {
   rtx op1 = gen_lowpart (<ssepackmode>mode, operands[1]);
@@ -12971,25 +13082,25 @@
 
 (define_expand "vec_unpacks_lo_<mode>"
   [(match_operand:<sseunpackmode> 0 "register_operand")
-   (match_operand:VI124_AVX512F 1 "register_operand")]
+   (match_operand:VI124_AVX2_24_AVX512F_1_AVX512BW 1 "register_operand")]
   "TARGET_SSE2"
   "ix86_expand_sse_unpack (operands[0], operands[1], false, false); DONE;")
 
 (define_expand "vec_unpacks_hi_<mode>"
   [(match_operand:<sseunpackmode> 0 "register_operand")
-   (match_operand:VI124_AVX512F 1 "register_operand")]
+   (match_operand:VI124_AVX2_24_AVX512F_1_AVX512BW 1 "register_operand")]
   "TARGET_SSE2"
   "ix86_expand_sse_unpack (operands[0], operands[1], false, true); DONE;")
 
 (define_expand "vec_unpacku_lo_<mode>"
   [(match_operand:<sseunpackmode> 0 "register_operand")
-   (match_operand:VI124_AVX512F 1 "register_operand")]
+   (match_operand:VI124_AVX2_24_AVX512F_1_AVX512BW 1 "register_operand")]
   "TARGET_SSE2"
   "ix86_expand_sse_unpack (operands[0], operands[1], true, false); DONE;")
 
 (define_expand "vec_unpacku_hi_<mode>"
   [(match_operand:<sseunpackmode> 0 "register_operand")
-   (match_operand:VI124_AVX512F 1 "register_operand")]
+   (match_operand:VI124_AVX2_24_AVX512F_1_AVX512BW 1 "register_operand")]
   "TARGET_SSE2"
   "ix86_expand_sse_unpack (operands[0], operands[1], true, true); DONE;")
 
diff -Naur gcc-5.2.0.orig/gcc/config/i386/sync.md gcc-5.2.0/gcc/config/i386/sync.md
--- gcc-5.2.0.orig/gcc/config/i386/sync.md	2015-04-02 02:56:05.000000000 -0500
+++ gcc-5.2.0/gcc/config/i386/sync.md	2015-08-05 06:20:59.983324000 -0500
@@ -105,11 +105,11 @@
   [(match_operand:SI 0 "const_int_operand")]		;; model
   ""
 {
-  enum memmodel model = (enum memmodel) (INTVAL (operands[0]) & MEMMODEL_MASK);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[0]));
 
   /* Unless this is a SEQ_CST fence, the i386 memory model is strong
      enough not to require barriers of any kind.  */
-  if (model == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (model))
     {
       rtx (*mfence_insn)(rtx);
       rtx mem;
@@ -217,7 +217,7 @@
 		       UNSPEC_STA))]
   ""
 {
-  enum memmodel model = (enum memmodel) (INTVAL (operands[2]) & MEMMODEL_MASK);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
 
   if (<MODE>mode == DImode && !TARGET_64BIT)
     {
@@ -233,7 +233,7 @@
       operands[1] = force_reg (<MODE>mode, operands[1]);
 
       /* For seq-cst stores, when we lack MFENCE, use XCHG.  */
-      if (model == MEMMODEL_SEQ_CST && !(TARGET_64BIT || TARGET_SSE2))
+      if (is_mm_seq_cst (model) && !(TARGET_64BIT || TARGET_SSE2))
 	{
 	  emit_insn (gen_atomic_exchange<mode> (gen_reg_rtx (<MODE>mode),
 						operands[0], operands[1],
@@ -246,7 +246,7 @@
 					   operands[2]));
     }
   /* ... followed by an MFENCE, if required.  */
-  if (model == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (model))
     emit_insn (gen_mem_thread_fence (operands[2]));
   DONE;
 })
diff -Naur gcc-5.2.0.orig/gcc/config/ia64/ia64.c gcc-5.2.0/gcc/config/ia64/ia64.c
--- gcc-5.2.0.orig/gcc/config/ia64/ia64.c	2015-03-03 04:41:00.000000000 -0600
+++ gcc-5.2.0/gcc/config/ia64/ia64.c	2015-08-05 06:20:59.983324000 -0500
@@ -2389,10 +2389,12 @@
 	{
 	case MEMMODEL_ACQ_REL:
 	case MEMMODEL_SEQ_CST:
+	case MEMMODEL_SYNC_SEQ_CST:
 	  emit_insn (gen_memory_barrier ());
 	  /* FALLTHRU */
 	case MEMMODEL_RELAXED:
 	case MEMMODEL_ACQUIRE:
+	case MEMMODEL_SYNC_ACQUIRE:
 	case MEMMODEL_CONSUME:
 	  if (mode == SImode)
 	    icode = CODE_FOR_fetchadd_acq_si;
@@ -2400,6 +2402,7 @@
 	    icode = CODE_FOR_fetchadd_acq_di;
 	  break;
 	case MEMMODEL_RELEASE:
+	case MEMMODEL_SYNC_RELEASE:
 	  if (mode == SImode)
 	    icode = CODE_FOR_fetchadd_rel_si;
 	  else
@@ -2426,8 +2429,7 @@
      front half of the full barrier.  The end half is the cmpxchg.rel.
      For relaxed and release memory models, we don't need this.  But we
      also don't bother trying to prevent it either.  */
-  gcc_assert (model == MEMMODEL_RELAXED
-	      || model == MEMMODEL_RELEASE
+  gcc_assert (is_mm_relaxed (model) || is_mm_release (model)
 	      || MEM_VOLATILE_P (mem));
 
   old_reg = gen_reg_rtx (DImode);
@@ -2471,6 +2473,7 @@
     {
     case MEMMODEL_RELAXED:
     case MEMMODEL_ACQUIRE:
+    case MEMMODEL_SYNC_ACQUIRE:
     case MEMMODEL_CONSUME:
       switch (mode)
 	{
@@ -2484,8 +2487,10 @@
       break;
 
     case MEMMODEL_RELEASE:
+    case MEMMODEL_SYNC_RELEASE:
     case MEMMODEL_ACQ_REL:
     case MEMMODEL_SEQ_CST:
+    case MEMMODEL_SYNC_SEQ_CST:
       switch (mode)
 	{
 	case QImode: icode = CODE_FOR_cmpxchg_rel_qi;  break;
diff -Naur gcc-5.2.0.orig/gcc/config/ia64/sync.md gcc-5.2.0/gcc/config/ia64/sync.md
--- gcc-5.2.0.orig/gcc/config/ia64/sync.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/ia64/sync.md	2015-08-05 06:20:59.983324000 -0500
@@ -33,7 +33,7 @@
   [(match_operand:SI 0 "const_int_operand" "")]		;; model
   ""
 {
-  if (INTVAL (operands[0]) == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (memmodel_from_int (INTVAL (operands[0]))))
     emit_insn (gen_memory_barrier ());
   DONE;
 })
@@ -60,11 +60,11 @@
    (match_operand:SI 2 "const_int_operand" "")]			;; model
   ""
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
 
   /* Unless the memory model is relaxed, we want to emit ld.acq, which
      will happen automatically for volatile memories.  */
-  gcc_assert (model == MEMMODEL_RELAXED || MEM_VOLATILE_P (operands[1]));
+  gcc_assert (is_mm_relaxed (model) || MEM_VOLATILE_P (operands[1]));
   emit_move_insn (operands[0], operands[1]);
   DONE;
 })
@@ -75,17 +75,17 @@
    (match_operand:SI 2 "const_int_operand" "")]			;; model
   ""
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
 
   /* Unless the memory model is relaxed, we want to emit st.rel, which
      will happen automatically for volatile memories.  */
-  gcc_assert (model == MEMMODEL_RELAXED || MEM_VOLATILE_P (operands[0]));
+  gcc_assert (is_mm_relaxed (model) || MEM_VOLATILE_P (operands[0]));
   emit_move_insn (operands[0], operands[1]);
 
   /* Sequentially consistent stores need a subsequent MF.  See
      http://www.decadent.org.uk/pipermail/cpp-threads/2008-December/001952.html
      for a discussion of why a MF is needed here, but not for atomic_load.  */
-  if (model == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (model))
     emit_insn (gen_memory_barrier ());
   DONE;
 })
@@ -101,7 +101,8 @@
    (match_operand:SI 7 "const_int_operand" "")]			;; fail model
   ""
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[6]);
+  /* No need to distinquish __sync from __atomic, so get base value.  */
+  enum memmodel model = memmodel_base (INTVAL (operands[6]));
   rtx ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);
   rtx dval, eval;
 
@@ -200,7 +201,8 @@
    (match_operand:SI 3 "const_int_operand" "")]			;; succ model
   ""
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[3]);
+  /* No need to distinquish __sync from __atomic, so get base value.  */
+  enum memmodel model = memmodel_base (INTVAL (operands[3]));
 
   switch (model)
     {
diff -Naur gcc-5.2.0.orig/gcc/config/mips/mips.c gcc-5.2.0/gcc/config/mips/mips.c
--- gcc-5.2.0.orig/gcc/config/mips/mips.c	2015-01-28 03:44:39.000000000 -0600
+++ gcc-5.2.0/gcc/config/mips/mips.c	2015-08-05 06:20:59.983324000 -0500
@@ -13111,7 +13111,7 @@
       model = MEMMODEL_ACQUIRE;
       break;
     default:
-      model = (enum memmodel) INTVAL (operands[memmodel_attr]);
+      model = memmodel_from_int (INTVAL (operands[memmodel_attr]));
     }
 
   mips_multi_start ();
diff -Naur gcc-5.2.0.orig/gcc/config/nios2/nios2.c gcc-5.2.0/gcc/config/nios2/nios2.c
--- gcc-5.2.0.orig/gcc/config/nios2/nios2.c	2015-03-21 21:39:24.000000000 -0500
+++ gcc-5.2.0/gcc/config/nios2/nios2.c	2015-09-22 07:23:20.768742000 -0500
@@ -1894,15 +1894,15 @@
 
      Which will be output as '%tls_le(var+48)(r23)' in assembly.  */
   if (GET_CODE (x) == PLUS
-      && GET_CODE (XEXP (x, 0)) == REG
       && GET_CODE (XEXP (x, 1)) == CONST)
     {
-      rtx unspec, offset, reg = XEXP (x, 0);
+      rtx unspec, offset;
       split_const (XEXP (x, 1), &unspec, &offset);
       if (GET_CODE (unspec) == UNSPEC
 	  && !nios2_large_offset_p (XINT (unspec, 1))
 	  && offset != const0_rtx)
 	{
+	  rtx reg = force_reg (Pmode, XEXP (x, 0));
 	  unspec = copy_rtx (unspec);
 	  XVECEXP (unspec, 0, 0)
 	    = plus_constant (Pmode, XVECEXP (unspec, 0, 0), INTVAL (offset));
diff -Naur gcc-5.2.0.orig/gcc/config/pa/pa.c gcc-5.2.0/gcc/config/pa/pa.c
--- gcc-5.2.0.orig/gcc/config/pa/pa.c	2015-06-11 18:22:32.000000000 -0500
+++ gcc-5.2.0/gcc/config/pa/pa.c	2015-09-24 19:04:26.380077000 -0500
@@ -2443,6 +2443,7 @@
   enum { REGOP, OFFSOP, MEMOP, CNSTOP, RNDOP } optype0, optype1;
   rtx latehalf[2];
   rtx addreg0 = 0, addreg1 = 0;
+  int highonly = 0;
 
   /* First classify both operands.  */
 
@@ -2653,7 +2654,14 @@
   else if (optype1 == OFFSOP)
     latehalf[1] = adjust_address_nv (operands[1], SImode, 4);
   else if (optype1 == CNSTOP)
-    split_double (operands[1], &operands[1], &latehalf[1]);
+    {
+      if (GET_CODE (operands[1]) == HIGH)
+	{
+	  operands[1] = XEXP (operands[1], 0);
+	  highonly = 1;
+	}
+      split_double (operands[1], &operands[1], &latehalf[1]);
+    }
   else
     latehalf[1] = operands[1];
 
@@ -2706,8 +2714,11 @@
   if (addreg1)
     output_asm_insn ("ldo 4(%0),%0", &addreg1);
 
-  /* Do that word.  */
-  output_asm_insn (pa_singlemove_string (latehalf), latehalf);
+  /* Do high-numbered word.  */
+  if (highonly)
+    output_asm_insn ("ldil L'%1,%0", latehalf);
+  else
+    output_asm_insn (pa_singlemove_string (latehalf), latehalf);
 
   /* Undo the adds we just did.  */
   if (addreg0)
@@ -5712,7 +5723,7 @@
     }
 
   if (TARGET_SYNC_LIBCALL)
-    init_sync_libfuncs (UNITS_PER_WORD);
+    init_sync_libfuncs (8);
 }
 
 /* HP's millicode routines mean something special to the assembler.
@@ -8473,14 +8484,6 @@
   if (TARGET_PORTABLE_RUNTIME)
     return false;
 
-  /* Sibcalls are ok for TARGET_ELF32 as along as the linker is used in
-     single subspace mode and the call is not indirect.  As far as I know,
-     there is no operating system support for the multiple subspace mode.
-     It might be possible to support indirect calls if we didn't use
-     $$dyncall (see the indirect sequence generated in pa_output_call).  */
-  if (TARGET_ELF32)
-    return (decl != NULL_TREE);
-
   /* Sibcalls are not ok because the arg pointer register is not a fixed
      register.  This prevents the sibcall optimization from occurring.  In
      addition, there are problems with stub placement using GNU ld.  This
@@ -10515,4 +10518,79 @@
     fputs ("\t.end_brtab\n", asm_out_file);
 }
 
+/* This is a helper function for the other atomic operations.  This function
+   emits a loop that contains SEQ that iterates until a compare-and-swap
+   operation at the end succeeds.  MEM is the memory to be modified.  SEQ is
+   a set of instructions that takes a value from OLD_REG as an input and
+   produces a value in NEW_REG as an output.  Before SEQ, OLD_REG will be
+   set to the current contents of MEM.  After SEQ, a compare-and-swap will
+   attempt to update MEM with NEW_REG.  The function returns true when the
+   loop was generated successfully.  */
+
+static bool
+pa_expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)
+{
+  machine_mode mode = GET_MODE (mem);
+  rtx_code_label *label;
+  rtx cmp_reg, success, oldval;
+
+  /* The loop we want to generate looks like
+
+        cmp_reg = mem;
+      label:
+        old_reg = cmp_reg;
+        seq;
+        (success, cmp_reg) = compare-and-swap(mem, old_reg, new_reg)
+        if (success)
+          goto label;
+
+     Note that we only do the plain load from memory once.  Subsequent
+     iterations use the value loaded by the compare-and-swap pattern.  */
+
+  label = gen_label_rtx ();
+  cmp_reg = gen_reg_rtx (mode);
+
+  emit_move_insn (cmp_reg, mem);
+  emit_label (label);
+  emit_move_insn (old_reg, cmp_reg);
+  if (seq)
+    emit_insn (seq);
+
+  success = NULL_RTX;
+  oldval = cmp_reg;
+  if (!expand_atomic_compare_and_swap (&success, &oldval, mem, old_reg,
+                                       new_reg, false, MEMMODEL_SYNC_SEQ_CST,
+                                       MEMMODEL_RELAXED))
+    return false;
+
+  if (oldval != cmp_reg)
+    emit_move_insn (cmp_reg, oldval);
+
+  /* Mark this jump predicted not taken.  */
+  emit_cmp_and_jump_insns (success, const0_rtx, EQ, const0_rtx,
+                           GET_MODE (success), 1, label, 0);
+  return true;
+}
+
+/* This function tries to implement an atomic exchange operation using a 
+   compare_and_swap loop. VAL is written to *MEM.  The previous contents of
+   *MEM are returned, using TARGET if possible.  No memory model is required
+   since a compare_and_swap loop is seq-cst.  */
+
+rtx
+pa_maybe_emit_compare_and_swap_exchange_loop (rtx target, rtx mem, rtx val)
+{
+  machine_mode mode = GET_MODE (mem);
+
+  if (can_compare_and_swap_p (mode, true))
+    {
+      if (!target || !register_operand (target, mode))
+        target = gen_reg_rtx (mode);
+      if (pa_expand_compare_and_swap_loop (mem, target, val, NULL_RTX))
+        return target;
+    }
+
+  return NULL_RTX;
+}
+
 #include "gt-pa.h"
diff -Naur gcc-5.2.0.orig/gcc/config/pa/pa-linux.h gcc-5.2.0/gcc/config/pa/pa-linux.h
--- gcc-5.2.0.orig/gcc/config/pa/pa-linux.h	2015-05-28 09:07:55.000000000 -0500
+++ gcc-5.2.0/gcc/config/pa/pa-linux.h	2015-09-24 19:04:26.380077000 -0500
@@ -140,3 +140,4 @@
 #define HAVE_sync_compare_and_swapqi 1
 #define HAVE_sync_compare_and_swaphi 1
 #define HAVE_sync_compare_and_swapsi 1
+#define HAVE_sync_compare_and_swapdi 1
diff -Naur gcc-5.2.0.orig/gcc/config/pa/pa.md gcc-5.2.0/gcc/config/pa/pa.md
--- gcc-5.2.0.orig/gcc/config/pa/pa.md	2015-07-04 08:44:39.000000000 -0500
+++ gcc-5.2.0/gcc/config/pa/pa.md	2015-09-24 19:04:26.380077000 -0500
@@ -699,59 +699,229 @@
 ;; doubleword loads and stores are not guaranteed to be atomic
 ;; when referencing the I/O address space.
 
-;; Implement atomic DImode load using 64-bit floating point load and copy.
+;; The kernel cmpxchg operation on linux is not atomic with respect to
+;; memory stores on SMP machines, so we must do stores using a cmpxchg
+;; operation.
+
+;; Implement atomic QImode store using exchange.
+
+(define_expand "atomic_storeqi"
+  [(match_operand:QI 0 "memory_operand")                ;; memory
+   (match_operand:QI 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+  FAIL;
+})
+
+;; Implement atomic HImode stores using exchange.
+
+(define_expand "atomic_storehi"
+  [(match_operand:HI 0 "memory_operand")                ;; memory
+   (match_operand:HI 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+  FAIL;
+})
+
+;; Implement atomic SImode store using exchange.
+
+(define_expand "atomic_storesi"
+  [(match_operand:SI 0 "memory_operand")                ;; memory
+   (match_operand:SI 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+  FAIL;
+})
+
+;; Implement atomic SFmode store using exchange.
+
+(define_expand "atomic_storesf"
+  [(match_operand:SF 0 "memory_operand")                ;; memory
+   (match_operand:SF 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+  FAIL;
+})
+
+;; Implement atomic DImode load using 64-bit floating point load.
 
 (define_expand "atomic_loaddi"
   [(match_operand:DI 0 "register_operand")              ;; val out
    (match_operand:DI 1 "memory_operand")                ;; memory
    (match_operand:SI 2 "const_int_operand")]            ;; model
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
+  ""
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+  enum memmodel model;
+
+  if (TARGET_64BIT || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  model = memmodel_from_int (INTVAL (operands[2]));
   operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  operands[2] = gen_reg_rtx (DImode);
   expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1], operands[2]));
-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
+  if (is_mm_seq_cst (model))
     expand_mem_thread_fence (model);
   DONE;
 })
 
 (define_insn "atomic_loaddi_1"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (mem:DI (match_operand:SI 1 "register_operand" "r")))
-   (clobber (match_operand:DI 2 "register_operand" "=&f"))]
+  [(set (match_operand:DI 0 "register_operand" "=f,r")
+        (mem:DI (match_operand:SI 1 "register_operand" "r,r")))
+   (clobber (match_scratch:DI 2 "=X,f"))]
   "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-  "{fldds|fldd} 0(%1),%2\;{fstds|fstd} %2,-16(%%sp)\;{ldws|ldw} -16(%%sp),%0\;{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move")
-   (set_attr "length" "16")])
+  "@
+   {fldds|fldd} 0(%1),%0
+   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
+  [(set_attr "type" "move,move")
+   (set_attr "length" "4,16")])
 
-;; Implement atomic DImode store using copy and 64-bit floating point store.
+;; Implement atomic DImode store.
 
 (define_expand "atomic_storedi"
   [(match_operand:DI 0 "memory_operand")                ;; memory
    (match_operand:DI 1 "register_operand")              ;; val out
    (match_operand:SI 2 "const_int_operand")]            ;; model
-  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
+  ""
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+  enum memmodel model;
+
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+
+  if (TARGET_64BIT || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  model = memmodel_from_int (INTVAL (operands[2]));
   operands[0] = force_reg (SImode, XEXP (operands[0], 0));
-  operands[2] = gen_reg_rtx (DImode);
   expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1], operands[2]));
-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
+  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));
+  if (is_mm_seq_cst (model))
     expand_mem_thread_fence (model);
   DONE;
 })
 
 (define_insn "atomic_storedi_1"
-  [(set (mem:DI (match_operand:SI 0 "register_operand" "r"))
-        (match_operand:DI 1 "register_operand" "r"))
-   (clobber (match_operand:DI 2 "register_operand" "=&f"))]
+  [(set (mem:DI (match_operand:SI 0 "register_operand" "r,r"))
+        (match_operand:DI 1 "register_operand" "f,r"))
+   (clobber (match_scratch:DI 2 "=X,f"))]
+  "!TARGET_64BIT && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
+  "@
+   {fstds|fstd} %1,0(%0)
+   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
+  [(set_attr "type" "move,move")
+   (set_attr "length" "4,16")])
+
+;; Implement atomic DFmode load using 64-bit floating point load.
+
+(define_expand "atomic_loaddf"
+  [(match_operand:DF 0 "register_operand")              ;; val out
+   (match_operand:DF 1 "memory_operand")                ;; memory
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  enum memmodel model;
+
+  if (TARGET_64BIT || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  model = memmodel_from_int (INTVAL (operands[2]));
+  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
+  expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_loaddf_1 (operands[0], operands[1]));
+  if (is_mm_seq_cst (model))
+    expand_mem_thread_fence (model);
+  DONE;
+})
+
+(define_insn "atomic_loaddf_1"
+  [(set (match_operand:DF 0 "register_operand" "=f,r")
+        (mem:DF (match_operand:SI 1 "register_operand" "r,r")))
+   (clobber (match_scratch:DF 2 "=X,f"))]
   "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
-  "{stws|stw} %1,-16(%%sp)\;{stws|stw} %R1,-12(%%sp)\;{fldds|fldd} -16(%%sp),%2\;{fstds|fstd} %2,0(%0)"
-  [(set_attr "type" "move")
-   (set_attr "length" "16")])
+  "@
+   {fldds|fldd} 0(%1),%0
+   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
+  [(set_attr "type" "move,move")
+   (set_attr "length" "4,16")])
+
+;; Implement atomic DFmode store using 64-bit floating point store.
+
+(define_expand "atomic_storedf"
+  [(match_operand:DF 0 "memory_operand")                ;; memory
+   (match_operand:DF 1 "register_operand")              ;; val out
+   (match_operand:SI 2 "const_int_operand")]            ;; model
+  ""
+{
+  enum memmodel model;
+
+  if (TARGET_SYNC_LIBCALL)
+    {
+      rtx mem = operands[0];
+      rtx val = operands[1];
+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
+	DONE;
+    }
+
+  if (TARGET_64BIT || TARGET_SOFT_FLOAT)
+    FAIL;
+
+  model = memmodel_from_int (INTVAL (operands[2]));
+  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
+  expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_storedf_1 (operands[0], operands[1]));
+  if (is_mm_seq_cst (model))
+    expand_mem_thread_fence (model);
+  DONE;
+})
+
+(define_insn "atomic_storedf_1"
+  [(set (mem:DF (match_operand:SI 0 "register_operand" "r,r"))
+        (match_operand:DF 1 "register_operand" "f,r"))
+   (clobber (match_scratch:DF 2 "=X,f"))]
+  "!TARGET_64BIT && !TARGET_SOFT_FLOAT"
+  "@
+   {fstds|fstd} %1,0(%0)
+   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
+  [(set_attr "type" "move,move")
+   (set_attr "length" "4,16")])
 
 ;; Compare instructions.
 ;; This controls RTL generation and register allocation.
@@ -7516,7 +7686,6 @@
 (define_insn "call_reg_64bit"
   [(call (mem:SI (match_operand:DI 0 "register_operand" "r"))
 	 (match_operand 1 "" "i"))
-   (clobber (reg:DI 1))
    (clobber (reg:DI 2))
    (clobber (match_operand 2))
    (use (reg:DI 27))
@@ -7537,7 +7706,6 @@
 (define_split
   [(parallel [(call (mem:SI (match_operand 0 "register_operand" ""))
 		    (match_operand 1 "" ""))
-	      (clobber (reg:DI 1))
 	      (clobber (reg:DI 2))
 	      (clobber (match_operand 2))
 	      (use (reg:DI 27))
@@ -7548,7 +7716,6 @@
   [(set (match_dup 2) (reg:DI 27))
    (parallel [(call (mem:SI (match_dup 0))
 		    (match_dup 1))
-	      (clobber (reg:DI 1))
 	      (clobber (reg:DI 2))
 	      (use (reg:DI 27))
 	      (use (reg:DI 29))
@@ -7558,7 +7725,6 @@
 (define_split
   [(parallel [(call (mem:SI (match_operand 0 "register_operand" ""))
 		    (match_operand 1 "" ""))
-	      (clobber (reg:DI 1))
 	      (clobber (reg:DI 2))
 	      (clobber (match_operand 2))
 	      (use (reg:DI 27))
@@ -7568,7 +7734,6 @@
   [(set (match_dup 2) (reg:DI 27))
    (parallel [(call (mem:SI (match_dup 0))
 		    (match_dup 1))
-	      (clobber (reg:DI 1))
 	      (clobber (reg:DI 2))
 	      (use (reg:DI 27))
 	      (use (reg:DI 29))
@@ -7579,7 +7744,6 @@
 (define_insn "*call_reg_64bit_post_reload"
   [(call (mem:SI (match_operand:DI 0 "register_operand" "r"))
 	 (match_operand 1 "" "i"))
-   (clobber (reg:DI 1))
    (clobber (reg:DI 2))
    (use (reg:DI 27))
    (use (reg:DI 29))
diff -Naur gcc-5.2.0.orig/gcc/config/pa/pa-protos.h gcc-5.2.0/gcc/config/pa/pa-protos.h
--- gcc-5.2.0.orig/gcc/config/pa/pa-protos.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/pa/pa-protos.h	2015-09-24 19:04:26.380077000 -0500
@@ -79,6 +79,7 @@
 #endif /* ARGS_SIZE_RTX */
 extern int pa_insn_refs_are_delayed (rtx_insn *);
 extern rtx pa_get_deferred_plabel (rtx);
+extern rtx pa_maybe_emit_compare_and_swap_exchange_loop (rtx, rtx, rtx);
 #endif /* RTX_CODE */
 
 extern int pa_and_mask_p (unsigned HOST_WIDE_INT);
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/htm.md gcc-5.2.0/gcc/config/rs6000/htm.md
--- gcc-5.2.0.orig/gcc/config/rs6000/htm.md	2015-05-05 09:22:33.000000000 -0500
+++ gcc-5.2.0/gcc/config/rs6000/htm.md	2015-10-15 11:38:47.269450000 -0500
@@ -27,6 +27,14 @@
   ])
 
 ;;
+;; UNSPEC usage
+;;
+
+(define_c_enum "unspec"
+  [UNSPEC_HTM_FENCE
+  ])
+
+;;
 ;; UNSPEC_VOLATILE usage
 ;;
 
@@ -45,96 +53,223 @@
    UNSPECV_HTM_MTSPR
   ])
 
+(define_expand "tabort"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand:SI 0 "base_reg_operand" "b")]
+			       UNSPECV_HTM_TABORT))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
 
-(define_insn "tabort"
+(define_insn "*tabort"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
-	(unspec_volatile:CC [(match_operand:SI 0 "gpc_reg_operand" "r")]
-			    UNSPECV_HTM_TABORT))]
+	(unspec_volatile:CC [(match_operand:SI 0 "base_reg_operand" "b")]
+			    UNSPECV_HTM_TABORT))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tabort<wd>c"
+(define_expand "tabort<wd>c"
+  [(parallel
+     [(set (match_operand:CC 3 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
+				(match_operand:GPR 1 "gpc_reg_operand" "r")
+				(match_operand:GPR 2 "gpc_reg_operand" "r")]
+			       UNSPECV_HTM_TABORTXC))
+      (set (match_dup 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[4] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[4]) = 1;
+})
+
+(define_insn "*tabort<wd>c"
   [(set (match_operand:CC 3 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
 			     (match_operand:GPR 1 "gpc_reg_operand" "r")
 			     (match_operand:GPR 2 "gpc_reg_operand" "r")]
-			    UNSPECV_HTM_TABORTXC))]
+			    UNSPECV_HTM_TABORTXC))
+   (set (match_operand:BLK 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort<wd>c. %0,%1,%2"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tabort<wd>ci"
+(define_expand "tabort<wd>ci"
+  [(parallel
+     [(set (match_operand:CC 3 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
+				(match_operand:GPR 1 "gpc_reg_operand" "r")
+				(match_operand 2 "s5bit_cint_operand" "n")]
+			       UNSPECV_HTM_TABORTXCI))
+      (set (match_dup 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[4] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[4]) = 1;
+})
+
+(define_insn "*tabort<wd>ci"
   [(set (match_operand:CC 3 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "u5bit_cint_operand" "n")
 			     (match_operand:GPR 1 "gpc_reg_operand" "r")
 			     (match_operand 2 "s5bit_cint_operand" "n")]
-			    UNSPECV_HTM_TABORTXCI))]
+			    UNSPECV_HTM_TABORTXCI))
+   (set (match_operand:BLK 4) (unspec:BLK [(match_dup 4)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabort<wd>ci. %0,%1,%2"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tbegin"
+(define_expand "tbegin"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
+			       UNSPECV_HTM_TBEGIN))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
+
+(define_insn "*tbegin"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
-			    UNSPECV_HTM_TBEGIN))]
+			    UNSPECV_HTM_TBEGIN))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tbegin. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tcheck"
+(define_expand "tcheck"
+  [(parallel
+     [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	   (unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TCHECK))
+      (set (match_dup 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[1] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[1]) = 1;
+})
+
+(define_insn "*tcheck"
   [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec_volatile:CC [(const_int 0)]
-			    UNSPECV_HTM_TCHECK))]
+	(unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TCHECK))
+   (set (match_operand:BLK 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tcheck %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tend"
+(define_expand "tend"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
+			       UNSPECV_HTM_TEND))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
+
+(define_insn "*tend"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
-			    UNSPECV_HTM_TEND))]
+			    UNSPECV_HTM_TEND))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tend. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "trechkpt"
+(define_expand "trechkpt"
+  [(parallel
+     [(set (match_operand:CC 0 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TRECHKPT))
+      (set (match_dup 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[1] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[1]) = 1;
+})
+
+(define_insn "*trechkpt"
   [(set (match_operand:CC 0 "cc_reg_operand" "=x")
-	(unspec_volatile:CC [(const_int 0)]
-			    UNSPECV_HTM_TRECHKPT))]
+	(unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TRECHKPT))
+   (set (match_operand:BLK 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "trechkpt."
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "treclaim"
+(define_expand "treclaim"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand:SI 0 "gpc_reg_operand" "r")]
+			       UNSPECV_HTM_TRECLAIM))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
+
+(define_insn "*treclaim"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand:SI 0 "gpc_reg_operand" "r")]
-			    UNSPECV_HTM_TRECLAIM))]
+			    UNSPECV_HTM_TRECLAIM))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "treclaim. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "tsr"
+(define_expand "tsr"
+  [(parallel
+     [(set (match_operand:CC 1 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
+			       UNSPECV_HTM_TSR))
+      (set (match_dup 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[2]) = 1;
+})
+
+(define_insn "*tsr"
   [(set (match_operand:CC 1 "cc_reg_operand" "=x")
 	(unspec_volatile:CC [(match_operand 0 "const_0_to_1_operand" "n")]
-			    UNSPECV_HTM_TSR))]
+			    UNSPECV_HTM_TSR))
+   (set (match_operand:BLK 2) (unspec:BLK [(match_dup 2)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tsr. %0"
   [(set_attr "type" "htm")
    (set_attr "length" "4")])
 
-(define_insn "ttest"
+(define_expand "ttest"
+  [(parallel
+     [(set (match_operand:CC 0 "cc_reg_operand" "=x")
+	   (unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TTEST))
+      (set (match_dup 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))])]
+  "TARGET_HTM"
+{
+  operands[1] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[1]) = 1;
+})
+
+(define_insn "*ttest"
   [(set (match_operand:CC 0 "cc_reg_operand" "=x")
-	(unspec_volatile:CC [(const_int 0)]
-			    UNSPECV_HTM_TTEST))]
+	(unspec_volatile:CC [(const_int 0)] UNSPECV_HTM_TTEST))
+   (set (match_operand:BLK 1) (unspec:BLK [(match_dup 1)] UNSPEC_HTM_FENCE))]
   "TARGET_HTM"
   "tabortwci. 0,1,0"
   [(set_attr "type" "htm")
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/predicates.md gcc-5.2.0/gcc/config/rs6000/predicates.md
--- gcc-5.2.0.orig/gcc/config/rs6000/predicates.md	2015-07-05 21:07:49.000000000 -0500
+++ gcc-5.2.0/gcc/config/rs6000/predicates.md	2015-09-01 18:04:58.809944000 -0500
@@ -1048,12 +1048,12 @@
 (define_predicate "current_file_function_operand"
   (and (match_code "symbol_ref")
        (match_test "(DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))
-		    && ((SYMBOL_REF_LOCAL_P (op)
-			 && ((DEFAULT_ABI != ABI_AIX
-			      && DEFAULT_ABI != ABI_ELFv2)
-			     || !SYMBOL_REF_EXTERNAL_P (op)))
-		        || (op == XEXP (DECL_RTL (current_function_decl),
-						  0)))")))
+		    && (SYMBOL_REF_LOCAL_P (op)
+			|| op == XEXP (DECL_RTL (current_function_decl), 0))
+		    && !((DEFAULT_ABI == ABI_AIX
+			  || DEFAULT_ABI == ABI_ELFv2)
+			 && (SYMBOL_REF_EXTERNAL_P (op)
+			     || SYMBOL_REF_WEAK (op)))")))
 
 ;; Return 1 if this operand is a valid input for a move insn.
 (define_predicate "input_operand"
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/rs6000.c gcc-5.2.0/gcc/config/rs6000/rs6000.c
--- gcc-5.2.0.orig/gcc/config/rs6000/rs6000.c	2015-05-16 12:56:55.000000000 -0500
+++ gcc-5.2.0/gcc/config/rs6000/rs6000.c	2015-09-09 00:59:16.039307000 -0500
@@ -3692,6 +3692,45 @@
       && optimize >= 3)
     rs6000_isa_flags |= OPTION_MASK_P8_FUSION_SIGN;
 
+  /* Set -mallow-movmisalign to explicitly on if we have full ISA 2.07
+     support. If we only have ISA 2.06 support, and the user did not specify
+     the switch, leave it set to -1 so the movmisalign patterns are enabled,
+     but we don't enable the full vectorization support  */
+  if (TARGET_ALLOW_MOVMISALIGN == -1 && TARGET_P8_VECTOR && TARGET_DIRECT_MOVE)
+    TARGET_ALLOW_MOVMISALIGN = 1;
+
+  else if (TARGET_ALLOW_MOVMISALIGN && !TARGET_VSX)
+    {
+      if (TARGET_ALLOW_MOVMISALIGN > 0)
+	error ("-mallow-movmisalign requires -mvsx");
+
+      TARGET_ALLOW_MOVMISALIGN = 0;
+    }
+
+  /* Determine when unaligned vector accesses are permitted, and when
+     they are preferred over masked Altivec loads.  Note that if
+     TARGET_ALLOW_MOVMISALIGN has been disabled by the user, then
+     TARGET_EFFICIENT_UNALIGNED_VSX must be as well.  The converse is
+     not true.  */
+  if (TARGET_EFFICIENT_UNALIGNED_VSX)
+    {
+      if (!TARGET_VSX)
+	{
+	  if (rs6000_isa_flags_explicit & OPTION_MASK_EFFICIENT_UNALIGNED_VSX)
+	    error ("-mefficient-unaligned-vsx requires -mvsx");
+
+	  rs6000_isa_flags &= ~OPTION_MASK_EFFICIENT_UNALIGNED_VSX;
+	}
+
+      else if (!TARGET_ALLOW_MOVMISALIGN)
+	{
+	  if (rs6000_isa_flags_explicit & OPTION_MASK_EFFICIENT_UNALIGNED_VSX)
+	    error ("-mefficient-unaligned-vsx requires -mallow-movmisalign");
+
+	  rs6000_isa_flags &= ~OPTION_MASK_EFFICIENT_UNALIGNED_VSX;
+	}
+    }
+
   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)
     rs6000_print_isa_options (stderr, 0, "after defaults", rs6000_isa_flags);
 
@@ -4251,22 +4290,6 @@
 	}
     }
 
-  /* Determine when unaligned vector accesses are permitted, and when
-     they are preferred over masked Altivec loads.  Note that if
-     TARGET_ALLOW_MOVMISALIGN has been disabled by the user, then
-     TARGET_EFFICIENT_UNALIGNED_VSX must be as well.  The converse is
-     not true.  */
-  if (TARGET_EFFICIENT_UNALIGNED_VSX == -1) {
-    if (TARGET_VSX && rs6000_cpu == PROCESSOR_POWER8
-	&& TARGET_ALLOW_MOVMISALIGN != 0)
-      TARGET_EFFICIENT_UNALIGNED_VSX = 1;
-    else
-      TARGET_EFFICIENT_UNALIGNED_VSX = 0;
-  }
-
-  if (TARGET_ALLOW_MOVMISALIGN == -1 && rs6000_cpu == PROCESSOR_POWER8)
-    TARGET_ALLOW_MOVMISALIGN = 1;
-
   /* Set the builtin mask of the various options used that could affect which
      builtins were used.  In the past we used target_flags, but we've run out
      of bits, and some options like SPE and PAIRED are no longer in
@@ -17678,8 +17701,21 @@
 
   if (GET_CODE (addr) == PRE_MODIFY)
     {
+      gcc_assert (REG_P (XEXP (addr, 0))
+		  && GET_CODE (XEXP (addr, 1)) == PLUS
+		  && XEXP (XEXP (addr, 1), 0) == XEXP (addr, 0));
       scratch_or_premodify = XEXP (addr, 0);
-      gcc_assert (REG_P (scratch_or_premodify));
+      if (!HARD_REGISTER_P (scratch_or_premodify))
+	/* If we have a pseudo here then reload will have arranged
+	   to have it replaced, but only in the original insn.
+	   Use the replacement here too.  */
+	scratch_or_premodify = find_replacement (&XEXP (addr, 0));
+
+      /* RTL emitted by rs6000_secondary_reload_gpr uses RTL
+	 expressions from the original insn, without unsharing them.
+	 Any RTL that points into the original insn will of course
+	 have register replacements applied.  That is why we don't
+	 need to look for replacements under the PLUS.  */
       addr = XEXP (addr, 1);
     }
   gcc_assert (GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM);
@@ -20537,12 +20573,15 @@
     case MEMMODEL_RELAXED:
     case MEMMODEL_CONSUME:
     case MEMMODEL_ACQUIRE:
+    case MEMMODEL_SYNC_ACQUIRE:
       break;
     case MEMMODEL_RELEASE:
+    case MEMMODEL_SYNC_RELEASE:
     case MEMMODEL_ACQ_REL:
       emit_insn (gen_lwsync ());
       break;
     case MEMMODEL_SEQ_CST:
+    case MEMMODEL_SYNC_SEQ_CST:
       emit_insn (gen_hwsync ());
       break;
     default:
@@ -20559,10 +20598,13 @@
     case MEMMODEL_RELAXED:
     case MEMMODEL_CONSUME:
     case MEMMODEL_RELEASE:
+    case MEMMODEL_SYNC_RELEASE:
       break;
     case MEMMODEL_ACQUIRE:
+    case MEMMODEL_SYNC_ACQUIRE:
     case MEMMODEL_ACQ_REL:
     case MEMMODEL_SEQ_CST:
+    case MEMMODEL_SYNC_SEQ_CST:
       emit_insn (gen_isync ());
       break;
     default:
@@ -20662,8 +20704,8 @@
   oldval = operands[3];
   newval = operands[4];
   is_weak = (INTVAL (operands[5]) != 0);
-  mod_s = (enum memmodel) INTVAL (operands[6]);
-  mod_f = (enum memmodel) INTVAL (operands[7]);
+  mod_s = memmodel_from_int (INTVAL (operands[6]));
+  mod_f = memmodel_from_int (INTVAL (operands[7]));
   orig_mode = mode = GET_MODE (mem);
 
   mask = shift = NULL_RTX;
@@ -20751,12 +20793,12 @@
       emit_unlikely_jump (x, label1);
     }
 
-  if (mod_f != MEMMODEL_RELAXED)
+  if (!is_mm_relaxed (mod_f))
     emit_label (XEXP (label2, 0));
 
   rs6000_post_atomic_barrier (mod_s);
 
-  if (mod_f == MEMMODEL_RELAXED)
+  if (is_mm_relaxed (mod_f))
     emit_label (XEXP (label2, 0));
 
   if (shift)
@@ -22311,6 +22353,7 @@
       || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)
 	  && decl
 	  && !DECL_EXTERNAL (decl)
+	  && !DECL_WEAK (decl)
 	  && (*targetm.binds_local_p) (decl))
       || (DEFAULT_ABI == ABI_V4
 	  && (!TARGET_SECURE_PLT
@@ -32274,6 +32317,8 @@
   { "crypto",			OPTION_MASK_CRYPTO,		false, true  },
   { "direct-move",		OPTION_MASK_DIRECT_MOVE,	false, true  },
   { "dlmzb",			OPTION_MASK_DLMZB,		false, true  },
+  { "efficient-unaligned-vsx",	OPTION_MASK_EFFICIENT_UNALIGNED_VSX,
+								false, true  },
   { "fprnd",			OPTION_MASK_FPRND,		false, true  },
   { "hard-dfp",			OPTION_MASK_DFP,		false, true  },
   { "htm",			OPTION_MASK_HTM,		false, true  },
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/rs6000-c.c gcc-5.2.0/gcc/config/rs6000/rs6000-c.c
--- gcc-5.2.0.orig/gcc/config/rs6000/rs6000-c.c	2015-04-02 06:54:58.000000000 -0500
+++ gcc-5.2.0/gcc/config/rs6000/rs6000-c.c	2015-10-15 11:38:47.269450000 -0500
@@ -381,7 +381,11 @@
   if ((flags & OPTION_MASK_VSX) != 0)
     rs6000_define_or_undefine_macro (define_p, "__VSX__");
   if ((flags & OPTION_MASK_HTM) != 0)
-    rs6000_define_or_undefine_macro (define_p, "__HTM__");
+    {
+      rs6000_define_or_undefine_macro (define_p, "__HTM__");
+      /* Tell the user that our HTM insn patterns act as memory barriers.  */
+      rs6000_define_or_undefine_macro (define_p, "__TM_FENCE__");
+    }
   if ((flags & OPTION_MASK_P8_VECTOR) != 0)
     rs6000_define_or_undefine_macro (define_p, "__POWER8_VECTOR__");
   if ((flags & OPTION_MASK_QUAD_MEMORY) != 0)
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/rs6000-cpus.def gcc-5.2.0/gcc/config/rs6000/rs6000-cpus.def
--- gcc-5.2.0.orig/gcc/config/rs6000/rs6000-cpus.def	2015-03-02 18:59:56.000000000 -0600
+++ gcc-5.2.0/gcc/config/rs6000/rs6000-cpus.def	2015-08-24 14:11:02.078717000 -0500
@@ -53,6 +53,7 @@
 				 | OPTION_MASK_P8_VECTOR		\
 				 | OPTION_MASK_CRYPTO			\
 				 | OPTION_MASK_DIRECT_MOVE		\
+				 | OPTION_MASK_EFFICIENT_UNALIGNED_VSX	\
 				 | OPTION_MASK_HTM			\
 				 | OPTION_MASK_QUAD_MEMORY		\
   				 | OPTION_MASK_QUAD_MEMORY_ATOMIC	\
@@ -78,6 +79,7 @@
 				 | OPTION_MASK_DFP			\
 				 | OPTION_MASK_DIRECT_MOVE		\
 				 | OPTION_MASK_DLMZB			\
+				 | OPTION_MASK_EFFICIENT_UNALIGNED_VSX	\
 				 | OPTION_MASK_FPRND			\
 				 | OPTION_MASK_HTM			\
 				 | OPTION_MASK_ISEL			\
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/rs6000.opt gcc-5.2.0/gcc/config/rs6000/rs6000.opt
--- gcc-5.2.0.orig/gcc/config/rs6000/rs6000.opt	2015-04-24 15:03:13.000000000 -0500
+++ gcc-5.2.0/gcc/config/rs6000/rs6000.opt	2015-08-24 14:11:02.078717000 -0500
@@ -212,7 +212,7 @@
 ; Allow/disallow the movmisalign in DF/DI vectors
 
 mefficient-unaligned-vector
-Target Undocumented Report Var(TARGET_EFFICIENT_UNALIGNED_VSX) Init(-1) Save
+Target Undocumented Report Mask(EFFICIENT_UNALIGNED_VSX) Var(rs6000_isa_flags)
 ; Consider unaligned VSX accesses to be efficient/inefficient
 
 mallow-df-permute
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/sync.md gcc-5.2.0/gcc/config/rs6000/sync.md
--- gcc-5.2.0.orig/gcc/config/rs6000/sync.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/rs6000/sync.md	2015-08-05 06:20:59.983324000 -0500
@@ -41,18 +41,21 @@
   [(match_operand:SI 0 "const_int_operand" "")]		;; model
   ""
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[0]);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[0]));
   switch (model)
     {
     case MEMMODEL_RELAXED:
       break;
     case MEMMODEL_CONSUME:
     case MEMMODEL_ACQUIRE:
+    case MEMMODEL_SYNC_ACQUIRE:
     case MEMMODEL_RELEASE:
+    case MEMMODEL_SYNC_RELEASE:
     case MEMMODEL_ACQ_REL:
       emit_insn (gen_lwsync ());
       break;
     case MEMMODEL_SEQ_CST:
+    case MEMMODEL_SYNC_SEQ_CST:
       emit_insn (gen_hwsync ());
       break;
     default:
@@ -144,9 +147,9 @@
   if (<MODE>mode == TImode && !TARGET_SYNC_TI)
     FAIL;
 
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
 
-  if (model == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (model))
     emit_insn (gen_hwsync ());
 
   if (<MODE>mode != TImode)
@@ -182,7 +185,9 @@
       break;
     case MEMMODEL_CONSUME:
     case MEMMODEL_ACQUIRE:
+    case MEMMODEL_SYNC_ACQUIRE:
     case MEMMODEL_SEQ_CST:
+    case MEMMODEL_SYNC_SEQ_CST:
       emit_insn (gen_loadsync_<mode> (operands[0]));
       break;
     default:
@@ -209,15 +214,17 @@
   if (<MODE>mode == TImode && !TARGET_SYNC_TI)
     FAIL;
 
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
   switch (model)
     {
     case MEMMODEL_RELAXED:
       break;
     case MEMMODEL_RELEASE:
+    case MEMMODEL_SYNC_RELEASE:
       emit_insn (gen_lwsync ());
       break;
     case MEMMODEL_SEQ_CST:
+    case MEMMODEL_SYNC_SEQ_CST:
       emit_insn (gen_hwsync ());
       break;
     default:
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/sysv4.h gcc-5.2.0/gcc/config/rs6000/sysv4.h
--- gcc-5.2.0.orig/gcc/config/rs6000/sysv4.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/rs6000/sysv4.h	2015-09-24 08:46:45.240734000 -0500
@@ -574,7 +574,6 @@
 %{R*} \
 %(link_shlib) \
 %{!T*: %(link_start) } \
-%(link_target) \
 %(link_os)"
 
 /* Shared libraries are not default.  */
@@ -584,10 +583,6 @@
 %{shared:-G -dy -z text } \
 %{symbolic:-Bsymbolic -G -dy -z text }"
 
-/* Override the default target of the linker.  */
-#define	LINK_TARGET_SPEC \
-  ENDIAN_SELECT("", " --oformat elf32-powerpcle", "")
-
 /* Any specific OS flags.  */
 #define LINK_OS_SPEC "\
 %{mads         : %(link_os_ads)         ; \
@@ -873,7 +868,6 @@
   { "endfile_openbsd",		ENDFILE_OPENBSD_SPEC },			\
   { "endfile_default",		ENDFILE_DEFAULT_SPEC },			\
   { "link_shlib",		LINK_SHLIB_SPEC },			\
-  { "link_target",		LINK_TARGET_SPEC },			\
   { "link_start",		LINK_START_SPEC },			\
   { "link_start_ads",		LINK_START_ADS_SPEC },			\
   { "link_start_yellowknife",	LINK_START_YELLOWKNIFE_SPEC },		\
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/sysv4le.h gcc-5.2.0/gcc/config/rs6000/sysv4le.h
--- gcc-5.2.0.orig/gcc/config/rs6000/sysv4le.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/rs6000/sysv4le.h	2015-09-24 08:46:45.240734000 -0500
@@ -25,10 +25,6 @@
 #undef	DEFAULT_ASM_ENDIAN
 #define	DEFAULT_ASM_ENDIAN " -mlittle"
 
-#undef	LINK_TARGET_SPEC
-#define	LINK_TARGET_SPEC \
-  ENDIAN_SELECT(" --oformat elf32-powerpc", "", "")
-
 #undef	MULTILIB_DEFAULTS
 #define	MULTILIB_DEFAULTS { "mlittle", "mcall-sysv" }
 
diff -Naur gcc-5.2.0.orig/gcc/config/rs6000/vector.md gcc-5.2.0/gcc/config/rs6000/vector.md
--- gcc-5.2.0.orig/gcc/config/rs6000/vector.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/rs6000/vector.md	2015-08-27 13:34:54.229009000 -0500
@@ -918,6 +918,8 @@
 ;; General shift amounts can be supported using vsro + vsr. We're
 ;; not expecting to see these yet (the vectorizer currently
 ;; generates only shifts by a whole number of vector elements).
+;; Note that the vec_shr operation is actually defined as 
+;; 'shift toward element 0' so is a shr for LE and shl for BE.
 (define_expand "vec_shr_<mode>"
   [(match_operand:VEC_L 0 "vlogical_operand" "")
    (match_operand:VEC_L 1 "vlogical_operand" "")
@@ -928,6 +930,7 @@
   rtx bitshift = operands[2];
   rtx shift;
   rtx insn;
+  rtx zero_reg, op1, op2;
   HOST_WIDE_INT bitshift_val;
   HOST_WIDE_INT byteshift_val;
 
@@ -937,19 +940,29 @@
   if (bitshift_val & 0x7)
     FAIL;
   byteshift_val = (bitshift_val >> 3);
+  zero_reg = gen_reg_rtx (<MODE>mode);
+  emit_move_insn (zero_reg, CONST0_RTX (<MODE>mode));
   if (!BYTES_BIG_ENDIAN)
-    byteshift_val = 16 - byteshift_val;
+    {
+      byteshift_val = 16 - byteshift_val;
+      op1 = zero_reg;
+      op2 = operands[1];
+    }
+  else
+    {
+      op1 = operands[1];
+      op2 = zero_reg;
+    }
+
   if (TARGET_VSX && (byteshift_val & 0x3) == 0)
     {
       shift = gen_rtx_CONST_INT (QImode, byteshift_val >> 2);
-      insn = gen_vsx_xxsldwi_<mode> (operands[0], operands[1], operands[1],
-				     shift);
+      insn = gen_vsx_xxsldwi_<mode> (operands[0], op1, op2, shift);
     }
   else
     {
       shift = gen_rtx_CONST_INT (QImode, byteshift_val);
-      insn = gen_altivec_vsldoi_<mode> (operands[0], operands[1], operands[1],
-					shift);
+      insn = gen_altivec_vsldoi_<mode> (operands[0], op1, op2, shift);
     }
 
   emit_insn (insn);
diff -Naur gcc-5.2.0.orig/gcc/config/s390/s390-builtins.def gcc-5.2.0/gcc/config/s390/s390-builtins.def
--- gcc-5.2.0.orig/gcc/config/s390/s390-builtins.def	2015-07-02 11:28:08.000000000 -0500
+++ gcc-5.2.0/gcc/config/s390/s390-builtins.def	2015-08-25 06:37:49.817958000 -0500
@@ -438,15 +438,15 @@
 B_DEF      (s390_vllezg,                vec_insert_and_zerov2di,0,              B_VX,               0,                  BT_FN_UV2DI_ULONGLONGCONSTPTR)
 
 OB_DEF     (s390_vec_load_bndry,        s390_vec_load_bndry_s8,s390_vec_load_bndry_dbl,B_VX,        BT_FN_OV4SI_INTCONSTPTR_INT)
-OB_DEF_VAR (s390_vec_load_bndry_s8,     s390_vlbb,          O2_U3,              BT_OV_V16QI_SCHARCONSTPTR_USHORT)
-OB_DEF_VAR (s390_vec_load_bndry_u8,     s390_vlbb,          O2_U3,              BT_OV_UV16QI_UCHARCONSTPTR_USHORT)
-OB_DEF_VAR (s390_vec_load_bndry_s16,    s390_vlbb,          O2_U3,              BT_OV_V8HI_SHORTCONSTPTR_USHORT)
-OB_DEF_VAR (s390_vec_load_bndry_u16,    s390_vlbb,          O2_U3,              BT_OV_UV8HI_USHORTCONSTPTR_USHORT)
-OB_DEF_VAR (s390_vec_load_bndry_s32,    s390_vlbb,          O2_U3,              BT_OV_V4SI_INTCONSTPTR_USHORT)
-OB_DEF_VAR (s390_vec_load_bndry_u32,    s390_vlbb,          O2_U3,              BT_OV_UV4SI_UINTCONSTPTR_USHORT)
-OB_DEF_VAR (s390_vec_load_bndry_s64,    s390_vlbb,          O2_U3,              BT_OV_V2DI_LONGLONGCONSTPTR_USHORT)
-OB_DEF_VAR (s390_vec_load_bndry_u64,    s390_vlbb,          O2_U3,              BT_OV_UV2DI_ULONGLONGCONSTPTR_USHORT)
-OB_DEF_VAR (s390_vec_load_bndry_dbl,    s390_vlbb,          O2_U3,              BT_OV_V2DF_DBLCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_s8,     s390_vlbb,          O2_U16,              BT_OV_V16QI_SCHARCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_u8,     s390_vlbb,          O2_U16,              BT_OV_UV16QI_UCHARCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_s16,    s390_vlbb,          O2_U16,              BT_OV_V8HI_SHORTCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_u16,    s390_vlbb,          O2_U16,              BT_OV_UV8HI_USHORTCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_s32,    s390_vlbb,          O2_U16,              BT_OV_V4SI_INTCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_u32,    s390_vlbb,          O2_U16,              BT_OV_UV4SI_UINTCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_s64,    s390_vlbb,          O2_U16,              BT_OV_V2DI_LONGLONGCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_u64,    s390_vlbb,          O2_U16,              BT_OV_UV2DI_ULONGLONGCONSTPTR_USHORT)
+OB_DEF_VAR (s390_vec_load_bndry_dbl,    s390_vlbb,          O2_U16,              BT_OV_V2DF_DBLCONSTPTR_USHORT)
 
 B_DEF      (s390_vlbb,                  vlbb,               0,                  B_VX,               O2_U3,              BT_FN_UV16QI_UCHARCONSTPTR_USHORT)
 
diff -Naur gcc-5.2.0.orig/gcc/config/s390/s390.c gcc-5.2.0/gcc/config/s390/s390.c
--- gcc-5.2.0.orig/gcc/config/s390/s390.c	2015-07-02 11:26:51.000000000 -0500
+++ gcc-5.2.0/gcc/config/s390/s390.c	2015-10-02 03:09:09.582503000 -0500
@@ -750,7 +750,7 @@
 		HOST_WIDE_INT_PRINT_DEC ".."
 		HOST_WIDE_INT_PRINT_DEC ")",
 		argnum, decl,
-		-(HOST_WIDE_INT)1 << (bitwidth - 1),
+		-((HOST_WIDE_INT)1 << (bitwidth - 1)),
 		((HOST_WIDE_INT)1 << (bitwidth - 1)) - 1);
 	  return false;
 	}
@@ -7705,11 +7705,12 @@
 /* We keep a list of constants which we have to add to internal
    constant tables in the middle of large functions.  */
 
-#define NR_C_MODES 31
+#define NR_C_MODES 32
 machine_mode constant_modes[NR_C_MODES] =
 {
   TFmode, TImode, TDmode,
-  V16QImode, V8HImode, V4SImode, V2DImode, V4SFmode, V2DFmode, V1TFmode,
+  V16QImode, V8HImode, V4SImode, V2DImode, V1TImode,
+  V4SFmode, V2DFmode, V1TFmode,
   DFmode, DImode, DDmode,
   V8QImode, V4HImode, V2SImode, V1DImode, V2SFmode, V1DFmode,
   SFmode, SImode, SDmode,
diff -Naur gcc-5.2.0.orig/gcc/config/s390/s390.md gcc-5.2.0/gcc/config/s390/s390.md
--- gcc-5.2.0.orig/gcc/config/s390/s390.md	2015-07-02 10:53:33.000000000 -0500
+++ gcc-5.2.0/gcc/config/s390/s390.md	2015-10-22 03:28:57.203960000 -0500
@@ -6044,8 +6044,13 @@
 			  (match_operand:GPR 2 "nonimmediate_operand" "")
 			  (match_operand:GPR 3 "nonimmediate_operand" "")))]
   "TARGET_Z196"
-  "operands[1] = s390_emit_compare (GET_CODE (operands[1]),
-                                    XEXP (operands[1], 0), XEXP (operands[1], 1));")
+{
+  /* Emit the comparison insn in case we do not already have a comparison result.  */
+  if (!s390_comparison (operands[1], VOIDmode))
+    operands[1] = s390_emit_compare (GET_CODE (operands[1]),
+				     XEXP (operands[1], 0),
+				     XEXP (operands[1], 1));
+})
 
 ; locr, loc, stoc, locgr, locg, stocg
 (define_insn_and_split "*mov<mode>cc"
@@ -9594,7 +9599,7 @@
 {
   /* Unless this is a SEQ_CST fence, the s390 memory model is strong
      enough not to require barriers of any kind.  */
-  if (INTVAL (operands[0]) == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (memmodel_from_int (INTVAL (operands[0]))))
     {
       rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
       MEM_VOLATILE_P (mem) = 1;
@@ -9675,7 +9680,7 @@
    (match_operand:SI 2 "const_int_operand")]	;; model
   ""
 {
-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);
+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));
 
   if (MEM_ALIGN (operands[0]) < GET_MODE_BITSIZE (GET_MODE (operands[0])))
     FAIL;
@@ -9686,7 +9691,7 @@
     emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));
   else
     emit_move_insn (operands[0], operands[1]);
-  if (model == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (model))
     emit_insn (gen_mem_thread_fence (operands[2]));
   DONE;
 })
diff -Naur gcc-5.2.0.orig/gcc/config/s390/vx-builtins.md gcc-5.2.0/gcc/config/s390/vx-builtins.md
--- gcc-5.2.0.orig/gcc/config/s390/vx-builtins.md	2015-07-02 10:53:33.000000000 -0500
+++ gcc-5.2.0/gcc/config/s390/vx-builtins.md	2015-09-29 05:28:00.829455000 -0500
@@ -414,7 +414,7 @@
 	(unspec:<non_vec> [(match_operand:V_HW_64                0 "register_operand"  "v")
 			   (match_dup 3)] UNSPEC_VEC_EXTRACT))]
   "TARGET_VX && !TARGET_64BIT"
-  "vsce<V_HW_64:gf>\t%v0,%O2(%v1,%R2),%3"
+  "vsce<V_HW_64:bhfgq>\t%v0,%O2(%v1,%R2),%3"
   [(set_attr "op_type" "VRV")])
 
 ; Element size and target adress size is the same
@@ -428,7 +428,7 @@
 	(unspec:<non_vec> [(match_operand:V_HW_32_64     0 "register_operand"  "v")
 			   (match_dup 3)] UNSPEC_VEC_EXTRACT))]
   "TARGET_VX"
-  "vsce<gf>\t%v0,%O2(%v1,%R2),%3"
+  "vsce<bhfgq>\t%v0,%O2(%v1,%R2),%3"
   [(set_attr "op_type" "VRV")])
 
 ; Depending on the address size we have to expand a different pattern.
@@ -870,11 +870,11 @@
 ; vec_mladd -> vec_vmal
 ; vmalb, vmalh, vmalf, vmalg
 (define_insn "vec_vmal<mode>"
-  [(set (match_operand:VI_HW 0 "register_operand" "=v")
-	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand" "v")
-		       (match_operand:VI_HW 2 "register_operand" "v")
-		       (match_operand:VI_HW 3 "register_operand" "v")]
-		      UNSPEC_VEC_VMAL))]
+  [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
+			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
+			   (match_operand:VI_HW_QHS 3 "register_operand" "v")]
+			  UNSPEC_VEC_VMAL))]
   "TARGET_VX"
   "vmal<bhfgq><w>\t%v0,%v1,%v2,%v3"
   [(set_attr "op_type" "VRR")])
@@ -883,22 +883,22 @@
 
 ; vmahb; vmahh, vmahf, vmahg
 (define_insn "vec_vmah<mode>"
-  [(set (match_operand:VI_HW 0 "register_operand" "=v")
-	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand" "v")
-		       (match_operand:VI_HW 2 "register_operand" "v")
-		       (match_operand:VI_HW 3 "register_operand" "v")]
-		      UNSPEC_VEC_VMAH))]
+  [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
+			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
+			   (match_operand:VI_HW_QHS 3 "register_operand" "v")]
+			  UNSPEC_VEC_VMAH))]
   "TARGET_VX"
   "vmah<bhfgq>\t%v0,%v1,%v2,%v3"
   [(set_attr "op_type" "VRR")])
 
 ; vmalhb; vmalhh, vmalhf, vmalhg
 (define_insn "vec_vmalh<mode>"
-  [(set (match_operand:VI_HW 0 "register_operand" "=v")
-	(unspec:VI_HW [(match_operand:VI_HW 1 "register_operand" "v")
-		       (match_operand:VI_HW 2 "register_operand" "v")
-		       (match_operand:VI_HW 3 "register_operand" "v")]
-		      UNSPEC_VEC_VMALH))]
+  [(set (match_operand:VI_HW_QHS 0 "register_operand" "=v")
+	(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 "register_operand" "v")
+			   (match_operand:VI_HW_QHS 2 "register_operand" "v")
+			   (match_operand:VI_HW_QHS 3 "register_operand" "v")]
+			  UNSPEC_VEC_VMALH))]
   "TARGET_VX"
   "vmalh<bhfgq>\t%v0,%v1,%v2,%v3"
   [(set_attr "op_type" "VRR")])
diff -Naur gcc-5.2.0.orig/gcc/config/sh/sh.c gcc-5.2.0/gcc/config/sh/sh.c
--- gcc-5.2.0.orig/gcc/config/sh/sh.c	2015-06-25 05:15:18.000000000 -0500
+++ gcc-5.2.0/gcc/config/sh/sh.c	2015-10-03 10:20:58.905754000 -0500
@@ -222,6 +222,7 @@
 static rtx_insn *gen_block_redirect (rtx_insn *, int, int);
 static void sh_reorg (void);
 static void sh_option_override (void);
+static void sh_override_options_after_change (void);
 static void output_stack_adjust (int, rtx, int, HARD_REG_SET *, bool);
 static rtx_insn *frame_insn (rtx);
 static rtx push (int);
@@ -236,7 +237,6 @@
 static int sh_mode_entry (int);
 static int sh_mode_exit (int);
 static int sh_mode_priority (int entity, int n);
-static bool sh_lra_p (void);
 
 static rtx mark_constant_pool_use (rtx);
 static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree,
@@ -413,6 +413,10 @@
 #undef TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE sh_option_override
 
+#undef TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE
+#define TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE \
+  sh_override_options_after_change
+
 #undef TARGET_PRINT_OPERAND
 #define TARGET_PRINT_OPERAND sh_print_operand
 #undef TARGET_PRINT_OPERAND_ADDRESS
@@ -1065,42 +1069,6 @@
       TARGET_ACCUMULATE_OUTGOING_ARGS = 1;
     }
 
-  /*  Adjust loop, jump and function alignment values (in bytes), if those
-      were not specified by the user using -falign-loops, -falign-jumps
-      and -falign-functions options.
-      32 bit alignment is better for speed, because instructions can be
-      fetched as a pair from a longword boundary.  For size use 16 bit
-      alignment to get more compact code.
-      Aligning all jumps increases the code size, even if it might
-      result in slightly faster code.  Thus, it is set to the smallest 
-      alignment possible if not specified by the user.  */
-  if (align_loops == 0)
-    {
-      if (TARGET_SH5)
-	align_loops = 8;
-      else
-	align_loops = optimize_size ? 2 : 4;
-    }
-
-  if (align_jumps == 0)
-    {
-      if (TARGET_SHMEDIA)
-	align_jumps = 1 << CACHE_LOG;
-      else
-	align_jumps = 2;
-    }
-  else if (align_jumps < (TARGET_SHMEDIA ? 4 : 2))
-    align_jumps = TARGET_SHMEDIA ? 4 : 2;
-
-  if (align_functions == 0)
-    {
-      if (TARGET_SHMEDIA)
-	align_functions = optimize_size
-			  ? FUNCTION_BOUNDARY/8 : (1 << CACHE_LOG);
-      else
-	align_functions = optimize_size ? 2 : 4;
-    }
-
   /* The linker relaxation code breaks when a function contains
      alignments that are larger than that at the start of a
      compilation unit.  */
@@ -1144,6 +1112,8 @@
   if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
+  sh_override_options_after_change ();
+
   /* Parse atomic model option and make sure it is valid for the current
      target CPU.  */
   selected_atomic_model_
@@ -1151,6 +1121,62 @@
 
   register_sh_passes ();
 }
+
+/* Implement targetm.override_options_after_change.  */
+
+static void
+sh_override_options_after_change (void)
+{
+  /*  Adjust loop, jump and function alignment values (in bytes), if those
+      were not specified by the user using -falign-loops, -falign-jumps
+      and -falign-functions options.
+      32 bit alignment is better for speed, because instructions can be
+      fetched as a pair from a longword boundary.  For size use 16 bit
+      alignment to get more compact code.
+      Aligning all jumps increases the code size, even if it might
+      result in slightly faster code.  Thus, it is set to the smallest 
+      alignment possible if not specified by the user.  */
+  if (align_loops == 0)
+    {
+      if (TARGET_SH5)
+	align_loops = 8;
+      else
+	align_loops = optimize_size ? 2 : 4;
+    }
+
+  if (align_jumps == 0)
+    {
+      if (TARGET_SHMEDIA)
+	align_jumps = 1 << CACHE_LOG;
+      else
+	align_jumps = 2;
+    }
+  else if (align_jumps < (TARGET_SHMEDIA ? 4 : 2))
+    align_jumps = TARGET_SHMEDIA ? 4 : 2;
+
+  if (align_functions == 0)
+    {
+      if (TARGET_SHMEDIA)
+	align_functions = optimize_size
+			  ? FUNCTION_BOUNDARY/8 : (1 << CACHE_LOG);
+      else
+	align_functions = optimize_size ? 2 : 4;
+    }
+
+  /* The linker relaxation code breaks when a function contains
+     alignments that are larger than that at the start of a
+     compilation unit.  */
+  if (TARGET_RELAX)
+    {
+      int min_align = align_loops > align_jumps ? align_loops : align_jumps;
+
+      /* Also take possible .long constants / mova tables into account.	*/
+      if (min_align < 4)
+	min_align = 4;
+      if (align_functions < min_align)
+	align_functions = min_align;
+    }
+}
 
 /* Print the operand address in x to the stream.  */
 static void
@@ -13787,6 +13813,34 @@
   return i;
 }
 
+/* Given a move insn destiation and a source, make sure that the move source
+   operand is not a post-inc mem load with the same address reg as the
+   destination.  Returns the modified source operand with the post-inc removed
+   if necessary.  */
+rtx
+sh_remove_overlapping_post_inc (rtx dst, rtx src)
+{
+  if (!MEM_P (src))
+    return src;
+
+  rtx addr = XEXP (src, 0);
+
+  if (GET_CODE (addr) == POST_INC
+      && reg_overlap_mentioned_p (XEXP (addr, 0), dst))
+    return replace_equiv_address (src, XEXP (addr, 0));
+
+  gcc_assert (GET_CODE (addr) != POST_MODIFY);
+  return src;
+}
+
+/* Emit a move insn that is safe to be used in peephole patterns.  */
+rtx_insn*
+sh_peephole_emit_move_insn (rtx dst, rtx src)
+{
+  return sh_check_add_incdec_notes (
+	emit_move_insn (dst, sh_remove_overlapping_post_inc (dst, src)));
+}
+
 /* Given an op rtx and an insn, try to find out whether the result of the
    specified op consists only of logical operations on T bit stores.  */
 bool
@@ -13886,6 +13940,7 @@
       && !sh_insn_operands_modified_between_p (t_before_negc.insn,
 					       t_before_negc.insn,
 					       t_after_negc.insn)
+      && !modified_between_p (get_t_reg_rtx (), curr_insn, t_after_negc.insn)
       && !sh_unspec_insn_p (t_after_negc.insn)
       && !volatile_insn_p (PATTERN (t_after_negc.insn))
       && !side_effects_p (PATTERN (t_after_negc.insn))
@@ -13992,6 +14047,9 @@
   else
     {
       rtx extension_dst = XEXP (set_rtx, 0);
+      if (GET_MODE (extension_dst) != SImode)
+	extension_dst = simplify_gen_subreg (SImode, extension_dst,
+					     GET_MODE (extension_dst), 0);
       if (modified_between_p (extension_dst, insn, use_at_insn))
 	{
 	  if (dump_file)
@@ -14162,6 +14220,12 @@
   if (!can_create_pseudo_p ())
     return false;
 
+  /* expand_debug_locations may call this to compute rtx costs at
+     very early stage.  In that case, don't make new insns here to
+     avoid codegen differences with -g. */
+  if (currently_expanding_to_rtl)
+    return false;
+
   /* We are going to invoke recog in a re-entrant way and thus
      have to capture its current state and restore it afterwards.  */
   recog_data_d prev_recog_data = recog_data;
@@ -14446,7 +14510,7 @@
 */
 
 /* Return true if we use LRA instead of reload pass.  */
-static bool
+bool
 sh_lra_p (void)
 {
   return sh_lra_flag;
diff -Naur gcc-5.2.0.orig/gcc/config/sh/sh.md gcc-5.2.0/gcc/config/sh/sh.md
--- gcc-5.2.0.orig/gcc/config/sh/sh.md	2015-07-10 04:50:18.000000000 -0500
+++ gcc-5.2.0/gcc/config/sh/sh.md	2015-09-28 08:44:32.077610000 -0500
@@ -2082,17 +2082,18 @@
 })
 
 (define_expand "addsi3"
-  [(set (match_operand:SI 0 "arith_reg_operand" "")
-	(plus:SI (match_operand:SI 1 "arith_operand" "")
-		 (match_operand:SI 2 "arith_or_int_operand" "")))]
+  [(set (match_operand:SI 0 "arith_reg_dest")
+	(plus:SI (match_operand:SI 1 "arith_reg_operand")
+		 (match_operand:SI 2 "arith_or_int_operand")))]
   ""
 {
-  if (TARGET_SHMEDIA)
-    operands[1] = force_reg (SImode, operands[1]);
-  else if (! arith_operand (operands[2], SImode))
+  if (TARGET_SH1 && !arith_operand (operands[2], SImode))
     {
-      if (reg_overlap_mentioned_p (operands[0], operands[1]))
-	FAIL;
+      if (!sh_lra_p () || reg_overlap_mentioned_p (operands[0], operands[1]))
+	{
+	  emit_insn (gen_addsi3_scr (operands[0], operands[1], operands[2]));
+	  DONE;
+	}
     }
 })
 
@@ -2128,18 +2129,22 @@
 ;; copy or constant load before the actual add insn.
 ;; Use u constraint for that case to avoid the invalid value in the stack
 ;; pointer.
-(define_insn_and_split "*addsi3_compact"
+;; This also results in better code when LRA is not used.  However, we have
+;; to use different sets of patterns and the order of these patterns is
+;; important.
+;; In some cases the constant zero might end up in operands[2] of the
+;; patterns.  We have to accept that and convert it into a reg-reg move.
+(define_insn_and_split "*addsi3_compact_lra"
   [(set (match_operand:SI 0 "arith_reg_dest" "=r,&u")
-	(plus:SI (match_operand:SI 1 "arith_operand" "%0,r")
+	(plus:SI (match_operand:SI 1 "arith_reg_operand" "%0,r")
 		 (match_operand:SI 2 "arith_or_int_operand" "rI08,rn")))]
-  "TARGET_SH1
-   && ((rtx_equal_p (operands[0], operands[1])
-        && arith_operand (operands[2], SImode))
-       || ! reg_overlap_mentioned_p (operands[0], operands[1]))"
+  "TARGET_SH1 && sh_lra_p ()
+   && (! reg_overlap_mentioned_p (operands[0], operands[1])
+       || arith_operand (operands[2], SImode))"
   "@
 	add	%2,%0
 	#"
-  "reload_completed
+  "&& reload_completed
    && ! reg_overlap_mentioned_p (operands[0], operands[1])"
   [(set (match_dup 0) (match_dup 2))
    (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))]
@@ -2150,6 +2155,58 @@
 }
   [(set_attr "type" "arith")])
 
+(define_insn_and_split "addsi3_scr"
+  [(set (match_operand:SI 0 "arith_reg_dest" "=r,&u,&u")
+	(plus:SI (match_operand:SI 1 "arith_reg_operand" "%0,r,r")
+		 (match_operand:SI 2 "arith_or_int_operand" "rI08,r,n")))
+   (clobber (match_scratch:SI 3 "=X,X,&u"))]
+  "TARGET_SH1"
+  "@
+	add	%2,%0
+	#
+	#"
+  "&& reload_completed"
+  [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))]
+{
+  if (operands[2] == const0_rtx)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      DONE;
+    }
+
+  if (CONST_INT_P (operands[2]) && !satisfies_constraint_I08 (operands[2]))
+    {
+      if (reg_overlap_mentioned_p (operands[0], operands[1]))
+	{
+	  emit_move_insn (operands[3], operands[2]);
+	  emit_move_insn (operands[0], operands[1]);
+	  operands[2] = operands[3];
+	}
+      else
+	{
+	  emit_move_insn (operands[0], operands[2]);
+	  operands[2] = operands[1];
+	}
+    }
+  else if (!reg_overlap_mentioned_p (operands[0], operands[1]))
+    emit_move_insn (operands[0], operands[1]);
+}
+  [(set_attr "type" "arith")])
+
+(define_insn_and_split "*addsi3"
+  [(set (match_operand:SI 0 "arith_reg_dest" "=r,r")
+	(plus:SI (match_operand:SI 1 "arith_reg_operand" "%0,r")
+		 (match_operand:SI 2 "arith_operand" "rI08,Z")))]
+  "TARGET_SH1 && !sh_lra_p ()"
+  "@
+	add	%2,%0
+	#"
+  "&& operands[2] == const0_rtx"
+  [(set (match_dup 0) (match_dup 1))]
+{
+}
+  [(set_attr "type" "arith")])
+
 ;; -------------------------------------------------------------------------
 ;; Subtraction instructions
 ;; -------------------------------------------------------------------------
@@ -7851,6 +7908,24 @@
   ""
 {
   prepare_move_operands (operands, DImode);
+  if (TARGET_SH1)
+    {
+      /* When the dest operand is (R0, R1) register pair, split it to
+	 two movsi of which dest is R1 and R0 so as to lower R0-register
+	 pressure on the first movsi.  Apply only for simple source not
+	 to make complex rtl here.  */
+      if (REG_P (operands[0])
+	  && REGNO (operands[0]) == R0_REG
+	  && REG_P (operands[1])
+	  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)
+	{
+	  emit_insn (gen_movsi (gen_rtx_REG (SImode, R1_REG),
+			        gen_rtx_SUBREG (SImode, operands[1], 4)));
+	  emit_insn (gen_movsi (gen_rtx_REG (SImode, R0_REG),
+			        gen_rtx_SUBREG (SImode, operands[1], 0)));
+	  DONE;
+	}
+    }
 })
 
 (define_insn "movdf_media"
@@ -9404,7 +9479,7 @@
    (use (reg:SI FPSCR_MODES_REG))
    (use (reg:SI PIC_REG))
    (clobber (reg:SI PR_REG))
-   (clobber (match_scratch:SI 2 "=r"))]
+   (clobber (match_scratch:SI 2 "=&r"))]
   "TARGET_SH2"
   "#"
   "reload_completed"
@@ -9538,7 +9613,7 @@
    (use (reg:SI FPSCR_MODES_REG))
    (use (reg:SI PIC_REG))
    (clobber (reg:SI PR_REG))
-   (clobber (match_scratch:SI 3 "=r"))]
+   (clobber (match_scratch:SI 3 "=&r"))]
   "TARGET_SH2"
   "#"
   "reload_completed"
@@ -9939,7 +10014,7 @@
   [(call (mem:SI (match_operand:SI 0 "symbol_ref_operand" ""))
 	 (match_operand 1 "" ""))
    (use (reg:SI FPSCR_MODES_REG))
-   (clobber (match_scratch:SI 2 "=k"))
+   (clobber (match_scratch:SI 2 "=&k"))
    (return)]
   "TARGET_SH2"
   "#"
@@ -10131,7 +10206,7 @@
 	(call (mem:SI (match_operand:SI 1 "symbol_ref_operand" ""))
 	      (match_operand 2 "" "")))
    (use (reg:SI FPSCR_MODES_REG))
-   (clobber (match_scratch:SI 3 "=k"))
+   (clobber (match_scratch:SI 3 "=&k"))
    (return)]
   "TARGET_SH2"
   "#"
@@ -10579,7 +10654,7 @@
   if (TARGET_SHMEDIA)
     {
       rtx tr = gen_rtx_REG (Pmode, TR0_REG);
-      rtx pic = operands[0];
+      rtx pic = operands[1];
       rtx lab = PATTERN (gen_call_site ());
       rtx insn, equiv;
 
@@ -14626,7 +14701,7 @@
   [(const_int 0)]
 {
   emit_insn (gen_addsi3 (operands[1], operands[1], operands[2]));
-  sh_check_add_incdec_notes (emit_move_insn (operands[3], operands[1]));
+  sh_peephole_emit_move_insn (operands[3], operands[1]);
 })
 
 ;;	mov.l	@(r0,r9),r1
@@ -14639,7 +14714,7 @@
   "TARGET_SH1 && peep2_reg_dead_p (2, operands[0])"
   [(const_int 0)]
 {
-  sh_check_add_incdec_notes (emit_move_insn (operands[2], operands[1]));
+  sh_peephole_emit_move_insn (operands[2], operands[1]);
 })
 
 (define_peephole2
@@ -14650,7 +14725,7 @@
   "TARGET_SH1 && peep2_reg_dead_p (2, operands[0])"
   [(const_int 0)]
 {
-  sh_check_add_incdec_notes (emit_move_insn (operands[2], operands[1]));
+  sh_peephole_emit_move_insn (operands[2], operands[1]);
 })
 
 (define_peephole2
@@ -14662,7 +14737,7 @@
   [(const_int 0)]
 {
   sh_check_add_incdec_notes (emit_insn (gen_extend<mode>si2 (operands[2],
-							     operands[1])));
+		   sh_remove_overlapping_post_inc (operands[2], operands[1]))));
 })
 
 ;;	mov.w	@(18,r1),r0 (r0 = HImode)
@@ -14692,8 +14767,9 @@
 
   // We don't know what the new set insn will be in detail.  Just make sure
   // that it still can be recognized and the constraints are satisfied.
-  rtx_insn* i = emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[3]));
-						     
+  rtx_insn* i = emit_insn (gen_rtx_SET (VOIDmode, operands[2],
+		    sh_remove_overlapping_post_inc (operands[2], operands[3])));
+
   recog_data_d prev_recog_data = recog_data;
   bool i_invalid = insn_invalid_p (i, false); 
   recog_data = prev_recog_data;
@@ -14731,7 +14807,8 @@
 {
   // We don't know what the new set insn will be in detail.  Just make sure
   // that it still can be recognized and the constraints are satisfied.
-  rtx_insn* i = emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[3]));
+  rtx_insn* i = emit_insn (gen_rtx_SET (VOIDmode, operands[2],
+		    sh_remove_overlapping_post_inc (operands[2], operands[3])));
 
   recog_data_d prev_recog_data = recog_data;
   bool i_invalid = insn_invalid_p (i, false); 
diff -Naur gcc-5.2.0.orig/gcc/config/sh/sh-protos.h gcc-5.2.0/gcc/config/sh/sh-protos.h
--- gcc-5.2.0.orig/gcc/config/sh/sh-protos.h	2015-02-26 13:14:23.000000000 -0600
+++ gcc-5.2.0/gcc/config/sh/sh-protos.h	2015-09-28 08:44:32.077610000 -0500
@@ -93,6 +93,7 @@
 extern rtx sh_fsca_int2sf (void);
 
 /* Declare functions defined in sh.c and used in templates.  */
+extern bool sh_lra_p (void);
 
 extern const char *output_branch (int, rtx_insn *, rtx *);
 extern const char *output_ieee_ccmpeq (rtx_insn *, rtx *);
@@ -191,18 +192,19 @@
   if (!REG_P (reg) || insn == NULL_RTX)
     return result;
 
-  rtx_insn* previnsn = insn;
-
-  for (result.insn = stepfunc (insn); result.insn != NULL_RTX;
-       previnsn = result.insn, result.insn = stepfunc (result.insn))
+  for (rtx_insn* i = stepfunc (insn); i != NULL_RTX; i = stepfunc (i))
     {
-      if (BARRIER_P (result.insn))
+      if (BARRIER_P (i))
 	break;
-      if (!NONJUMP_INSN_P (result.insn))
-	continue;
-      if (reg_set_p (reg, result.insn))
+      if (!INSN_P (i) || DEBUG_INSN_P (i))
+	  continue;
+      if (reg_set_p (reg, i))
 	{
-	  result.set_rtx = set_of (reg, result.insn);
+	  if (CALL_P (i))
+	    break;
+
+	  result.insn = i;
+	  result.set_rtx = set_of (reg, i);
 
 	  if (result.set_rtx == NULL_RTX || GET_CODE (result.set_rtx) != SET)
 	    break;
@@ -225,12 +227,6 @@
 	}
     }
 
-  /* If the loop above stopped at the first insn in the list,
-     result.insn will be null.  Use the insn from the previous iteration
-     in this case.  */
-  if (result.insn == NULL)
-    result.insn = previnsn;
-
   if (result.set_src != NULL)
     gcc_assert (result.insn != NULL && result.set_rtx != NULL);
 
@@ -310,6 +306,8 @@
 extern bool sh_reg_dead_or_unused_after_insn (const rtx_insn* i, int regno);
 extern void sh_remove_reg_dead_or_unused_notes (rtx_insn* i, int regno);
 extern rtx_insn* sh_check_add_incdec_notes (rtx_insn* i);
+extern rtx sh_remove_overlapping_post_inc (rtx dst, rtx src);
+extern rtx_insn* sh_peephole_emit_move_insn (rtx dst, rtx src);
 
 extern bool sh_in_recog_treg_set_expr (void);
 extern bool sh_recog_treg_set_expr (rtx op, machine_mode mode);
diff -Naur gcc-5.2.0.orig/gcc/config/sol2.h gcc-5.2.0/gcc/config/sol2.h
--- gcc-5.2.0.orig/gcc/config/sol2.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/sol2.h	2015-10-01 07:01:18.897040000 -0500
@@ -154,21 +154,41 @@
 #define STARTFILE_ARCH_SPEC "%{ansi:values-Xc.o%s} \
 			    %{!ansi:values-Xa.o%s}"
 
+#if defined(HAVE_LD_PIE) && defined(HAVE_SOLARIS_CRTS)
+#define STARTFILE_CRTBEGIN_SPEC "%{shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+#else
+#define STARTFILE_CRTBEGIN_SPEC	"crtbegin.o%s"
+#endif
+
 /* We don't use the standard svr4 STARTFILE_SPEC because it's wrong for us.  */
 #undef STARTFILE_SPEC
-#define STARTFILE_SPEC "%{!shared: \
-			 %{!symbolic: \
-			  %{p:mcrt1.o%s} \
-                          %{!p: \
-	                    %{pg:gcrt1.o%s gmon.o%s} \
-                            %{!pg:crt1.o%s}}}} \
-			crti.o%s %(startfile_arch) \
-			crtbegin.o%s"
+#ifdef HAVE_SOLARIS_CRTS
+/* Since Solaris 11.x and Solaris 12, the OS delivers crt1.o, crti.o, and
+   crtn.o, with a hook for compiler-dependent stuff like profile handling.  */
+#define STARTFILE_SPEC "%{!shared:%{!symbolic: \
+			  crt1.o%s \
+			  %{p:%e-p is not supported; \
+			    pg:crtpg.o%s gmon.o%s; \
+			      :crtp.o%s}}} \
+			crti.o%s %(startfile_arch) %(startfile_crtbegin)"
+#else
+#define STARTFILE_SPEC "%{!shared:%{!symbolic: \
+			  %{p:mcrt1.o%s; \
+                            pg:gcrt1.o%s gmon.o%s; \
+                              :crt1.o%s}}} \
+			crti.o%s %(startfile_arch) %(startfile_crtbegin)"
+#endif
+
+#if defined(HAVE_LD_PIE) && defined(HAVE_SOLARIS_CRTS)
+#define ENDFILE_CRTEND_SPEC "%{shared|pie:crtendS.o%s;:crtend.o%s}"
+#else
+#define ENDFILE_CRTEND_SPEC "crtend.o%s"
+#endif
 
 #undef  ENDFILE_SPEC
 #define ENDFILE_SPEC \
   "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
-   crtend.o%s crtn.o%s"
+   %(endfile_arch) %(endfile_crtend) crtn.o%s"
 
 #undef LINK_ARCH32_SPEC_BASE
 #define LINK_ARCH32_SPEC_BASE \
@@ -241,11 +261,14 @@
 
 #undef SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS \
-  { "startfile_arch",	 STARTFILE_ARCH_SPEC },		\
-  { "link_arch32",       LINK_ARCH32_SPEC },            \
-  { "link_arch64",       LINK_ARCH64_SPEC },            \
-  { "link_arch_default", LINK_ARCH_DEFAULT_SPEC },	\
-  { "link_arch",	 LINK_ARCH_SPEC },		\
+  { "startfile_arch",	 	STARTFILE_ARCH_SPEC },		\
+  { "startfile_crtbegin",	STARTFILE_CRTBEGIN_SPEC },	\
+  { "link_arch32",       	LINK_ARCH32_SPEC },		\
+  { "link_arch64",       	LINK_ARCH64_SPEC },		\
+  { "link_arch_default", 	LINK_ARCH_DEFAULT_SPEC },	\
+  { "link_arch",	 	LINK_ARCH_SPEC },		\
+  { "endfile_arch",	 	ENDFILE_ARCH_SPEC },		\
+  { "endfile_crtend",		ENDFILE_CRTEND_SPEC },	\
   SUBTARGET_CPU_EXTRA_SPECS
 
 /* C++11 programs need -lrt for nanosleep.  */
@@ -300,6 +323,20 @@
 #endif /* HAVE_LD_EH_FRAME && TARGET_DL_ITERATE_PHDR */
 #endif
 
+#if defined(HAVE_LD_PIE) && defined(HAVE_SOLARIS_CRTS)
+#ifdef USE_GLD
+/* Assert -z text by default to match Solaris ld.  */
+#define LINK_PIE_SPEC "%{pie:-pie %{!mimpure-text:-z text}} "
+#else
+/* Solaris ld needs -z type=pie instead of -pie.  */
+#define LINK_PIE_SPEC "%{pie:-z type=pie %{mimpure-text:-z textoff}} "
+#endif
+#else
+/* Error out if some part of PIE support is missing.  */
+#define LINK_PIE_SPEC \
+  "%{no-pie:} %{pie:%e-pie is not supported in this configuration} "
+#endif
+
 /* collect2.c can only parse GNU nm -n output.  Solaris nm needs -png to
    produce the same format.  */
 #define NM_FLAGS "-png"
diff -Naur gcc-5.2.0.orig/gcc/config/sparc/driver-sparc.c gcc-5.2.0/gcc/config/sparc/driver-sparc.c
--- gcc-5.2.0.orig/gcc/config/sparc/driver-sparc.c	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/sparc/driver-sparc.c	2015-09-28 01:24:21.352655000 -0500
@@ -73,6 +73,7 @@
   { "UltraSparc T2",	"niagara2" },
   { "UltraSparc T3",	"niagara3" },
   { "UltraSparc T4",	"niagara4" },
+  { "LEON",		"leon3" },
 #endif
   { NULL,	NULL }
   };
diff -Naur gcc-5.2.0.orig/gcc/config/sparc/sol2.h gcc-5.2.0/gcc/config/sparc/sol2.h
--- gcc-5.2.0.orig/gcc/config/sparc/sol2.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/sparc/sol2.h	2015-10-01 07:01:18.897040000 -0500
@@ -280,6 +280,8 @@
 
 #define SUBTARGET_CPU_EXTRA_SPECS
 
+#define ENDFILE_ARCH_SPEC ""
+
 
 
 /* Register the Solaris-specific #pragma directives.  */
diff -Naur gcc-5.2.0.orig/gcc/config/sparc/sparc.c gcc-5.2.0/gcc/config/sparc/sparc.c
--- gcc-5.2.0.orig/gcc/config/sparc/sparc.c	2015-06-11 10:58:32.000000000 -0500
+++ gcc-5.2.0/gcc/config/sparc/sparc.c	2015-09-28 01:21:05.639984000 -0500
@@ -7455,7 +7455,7 @@
 static bool
 sparc_function_value_regno_p (const unsigned int regno)
 {
-  return (regno == 8 || regno == 32);
+  return (regno == 8 || (TARGET_FPU && regno == 32));
 }
 
 /* Do what is necessary for `va_start'.  We look at the current function
@@ -11678,9 +11678,8 @@
 
   if (before_after & 1)
     {
-      if (model == MEMMODEL_RELEASE
-	  || model == MEMMODEL_ACQ_REL
-	  || model == MEMMODEL_SEQ_CST)
+      if (is_mm_release (model) || is_mm_acq_rel (model)
+	  || is_mm_seq_cst (model))
 	{
 	  if (load_store & 1)
 	    mm |= LoadLoad | StoreLoad;
@@ -11690,9 +11689,8 @@
     }
   if (before_after & 2)
     {
-      if (model == MEMMODEL_ACQUIRE
-	  || model == MEMMODEL_ACQ_REL
-	  || model == MEMMODEL_SEQ_CST)
+      if (is_mm_acquire (model) || is_mm_acq_rel (model)
+	  || is_mm_seq_cst (model))
 	{
 	  if (load_store & 1)
 	    mm |= LoadLoad | LoadStore;
diff -Naur gcc-5.2.0.orig/gcc/config/sparc/sparc.md gcc-5.2.0/gcc/config/sparc/sparc.md
--- gcc-5.2.0.orig/gcc/config/sparc/sparc.md	2015-06-11 10:58:32.000000000 -0500
+++ gcc-5.2.0/gcc/config/sparc/sparc.md	2015-09-28 01:21:05.639984000 -0500
@@ -6398,7 +6398,6 @@
   ""
 {
   rtx valreg1 = gen_rtx_REG (DImode, 8);
-  rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);
   rtx result = operands[1];
 
   /* Pass constm1 to indicate that it may expect a structure value, but
@@ -6407,8 +6406,12 @@
 
   /* Save the function value registers.  */
   emit_move_insn (adjust_address (result, DImode, 0), valreg1);
-  emit_move_insn (adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8),
-				  valreg2);
+  if (TARGET_FPU)
+    {
+      rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);
+      emit_move_insn (adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8),
+		      valreg2);
+    }
 
   /* The optimizer does not know that the call sets the function value
      registers we stored in the result block.  We avoid problems by
@@ -6620,7 +6623,6 @@
   ""
 {
   rtx valreg1 = gen_rtx_REG (DImode, 24);
-  rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);
   rtx result = operands[0];
 
   if (! TARGET_ARCH64)
@@ -6637,14 +6639,18 @@
       emit_insn (gen_update_return (rtnreg, value));
     }
 
-  /* Reload the function value registers.  */
+  /* Reload the function value registers.
+     Put USE insns before the return.  */
   emit_move_insn (valreg1, adjust_address (result, DImode, 0));
-  emit_move_insn (valreg2,
-		  adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8));
-
-  /* Put USE insns before the return.  */
   emit_use (valreg1);
-  emit_use (valreg2);
+
+  if (TARGET_FPU)
+    {
+      rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);
+      emit_move_insn (valreg2,
+		      adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8));
+      emit_use (valreg2);
+    }
 
   /* Construct the return.  */
   expand_naked_return ();
diff -Naur gcc-5.2.0.orig/gcc/config/sparc/sparc.opt gcc-5.2.0/gcc/config/sparc/sparc.opt
--- gcc-5.2.0.orig/gcc/config/sparc/sparc.opt	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/sparc/sparc.opt	2015-09-28 01:22:41.955493000 -0500
@@ -114,8 +114,8 @@
 Optimize tail call instructions in assembler and linker
 
 muser-mode
-Target Report Mask(USER_MODE)
-Do not generate code that can only run in supervisor mode
+Target Report InverseMask(SV_MODE)
+Do not generate code that can only run in supervisor mode (default)
 
 mcpu=
 Target RejectNegative Joined Var(sparc_cpu_and_features) Enum(sparc_processor_type) Init(PROCESSOR_V7)
diff -Naur gcc-5.2.0.orig/gcc/config/sparc/sync.md gcc-5.2.0/gcc/config/sparc/sync.md
--- gcc-5.2.0.orig/gcc/config/sparc/sync.md	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/sparc/sync.md	2015-09-28 01:22:41.955493000 -0500
@@ -222,10 +222,10 @@
 	  UNSPECV_CAS))]
   "TARGET_LEON3"
 {
-  if (TARGET_USER_MODE)
-    return "casa\t%1 0xa, %2, %0"; /* ASI for user data space.  */
-  else
+  if (TARGET_SV_MODE)
     return "casa\t%1 0xb, %2, %0"; /* ASI for supervisor data space.  */
+  else
+    return "casa\t%1 0xa, %2, %0"; /* ASI for user data space.  */
 }
   [(set_attr "type" "multi")])
 
diff -Naur gcc-5.2.0.orig/gcc/config/sparc/t-rtems gcc-5.2.0/gcc/config/sparc/t-rtems
--- gcc-5.2.0.orig/gcc/config/sparc/t-rtems	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/config/sparc/t-rtems	2015-09-28 10:05:38.974299000 -0500
@@ -17,15 +17,20 @@
 # <http://www.gnu.org/licenses/>.
 #
 
-MULTILIB_OPTIONS = msoft-float mcpu=v8/mcpu=leon3/mcpu=leon3v7 muser-mode
-MULTILIB_DIRNAMES = soft v8 leon3 leon3v7 user-mode
+MULTILIB_OPTIONS = msoft-float mcpu=v8/mcpu=leon3/mcpu=leon3v7/mcpu=leon \
+		   mfix-ut699/mfix-at697f
+MULTILIB_DIRNAMES = soft v8 leon3 leon3v7 leon ut699 at697f
 MULTILIB_MATCHES = msoft-float=mno-fpu
 
-MULTILIB_EXCEPTIONS = muser-mode
-MULTILIB_EXCEPTIONS += mcpu=leon3
-MULTILIB_EXCEPTIONS += mcpu=leon3v7
-MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3
-MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3v7
-MULTILIB_EXCEPTIONS += msoft-float/muser-mode
-MULTILIB_EXCEPTIONS += msoft-float/mcpu=v8/muser-mode
-MULTILIB_EXCEPTIONS += mcpu=v8/muser-mode
+MULTILIB_EXCEPTIONS = mfix-ut699
+MULTILIB_EXCEPTIONS += msoft-float/mfix-ut699
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=v8/mfix-ut699
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3*/mfix-ut699
+MULTILIB_EXCEPTIONS += mcpu=v8/mfix-ut699
+MULTILIB_EXCEPTIONS += mcpu=leon3*/mfix-ut699
+MULTILIB_EXCEPTIONS += mfix-at697f
+MULTILIB_EXCEPTIONS += msoft-float/mfix-at697f
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=v8/mfix-at697f
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3*/mfix-at697f
+MULTILIB_EXCEPTIONS += mcpu=v8/mfix-at697f
+MULTILIB_EXCEPTIONS += mcpu=leon3*/mfix-at697f
diff -Naur gcc-5.2.0.orig/gcc/config.gcc gcc-5.2.0/gcc/config.gcc
--- gcc-5.2.0.orig/gcc/config.gcc	2015-07-02 10:53:33.000000000 -0500
+++ gcc-5.2.0/gcc/config.gcc	2015-09-10 09:17:53.714149000 -0500
@@ -819,6 +819,12 @@
   sol2_tm_file_head="dbxelf.h elfos.h ${cpu_type}/sysv4.h"
   sol2_tm_file_tail="${cpu_type}/sol2.h sol2.h"
   sol2_tm_file="${sol2_tm_file_head} ${sol2_tm_file_tail}"
+  case ${target} in
+    *-*-solaris2.1[2-9]*)
+      # __cxa_atexit was introduced in Solaris 12.
+      default_use_cxa_atexit=yes
+      ;;
+  esac
   use_gcc_stdint=wrap
   if test x$gnu_ld = xyes; then
     tm_file="usegld.h ${tm_file}"
diff -Naur gcc-5.2.0.orig/gcc/config.in gcc-5.2.0/gcc/config.in
--- gcc-5.2.0.orig/gcc/config.in	2015-07-16 04:16:25.000000000 -0500
+++ gcc-5.2.0/gcc/config.in	2015-10-12 05:59:21.185205000 -0500
@@ -1313,6 +1313,12 @@
 #endif
 
 
+/* Define if isl_options_set_schedule_serialize_sccs exists. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
+#endif
+
+
 /* Define if isl_schedule_constraints_compute_schedule exists. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
@@ -1423,7 +1429,7 @@
 #endif
 
 
-/* Define if your linker supports -pie option. */
+/* Define if your linker supports PIE option. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_LD_PIE
 #endif
@@ -1580,6 +1586,12 @@
 #endif
 
 
+/* Define if the system-provided CRTs are present on Solaris. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_SOLARIS_CRTS
+#endif
+
+
 /* Define to 1 if you have the <stddef.h> header file. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_STDDEF_H
diff -Naur gcc-5.2.0.orig/gcc/configure gcc-5.2.0/gcc/configure
--- gcc-5.2.0.orig/gcc/configure	2015-07-03 12:00:49.000000000 -0500
+++ gcc-5.2.0/gcc/configure	2015-10-12 05:59:21.185205000 -0500
@@ -27141,15 +27141,37 @@
 $as_echo_n "checking linker position independent executable support... " >&6; }
 gcc_cv_ld_pie=no
 if test $in_tree_ld = yes ; then
-  if test "$gcc_cv_gld_major_version" -eq 2 -a "$gcc_cv_gld_minor_version" -ge 15 -o "$gcc_cv_gld_major_version" -gt 2 \
+  case "$target" in
+    # Full PIE support on Solaris was only introduced in gld 2.26.
+    *-*-solaris2*)  gcc_gld_pie_min_version=26 ;;
+    *) 		    gcc_gld_pie_min_version=15 ;;
+  esac
+  if test "$gcc_cv_gld_major_version" -eq 2 -a "$gcc_cv_gld_minor_version" -ge "$gcc_gld_pie_min_version" -o "$gcc_cv_gld_major_version" -gt 2 \
      && test $in_tree_ld_is_elf = yes; then
     gcc_cv_ld_pie=yes
   fi
 elif test x$gcc_cv_ld != x; then
-	# Check if linker supports -pie option
-	if $gcc_cv_ld --help 2>/dev/null | grep -- -pie > /dev/null; then
-		gcc_cv_ld_pie=yes
+  # Check if linker supports -pie option
+  if $gcc_cv_ld --help 2>/dev/null | grep -- -pie > /dev/null; then
+    gcc_cv_ld_pie=yes
+    case "$target" in
+      *-*-solaris2*)
+	if echo "$ld_ver" | grep GNU > /dev/null \
+	  && test "$ld_vers_major" -eq 2 -a "$ld_vers_minor" -lt 26; then
+	  gcc_cv_ld_pie=no
 	fi
+	;;
+    esac
+  else
+    case "$target" in
+      *-*-solaris2.1[1-9]*)
+	# Solaris 11.x and Solaris 12 added PIE support.
+	if $gcc_cv_ld -z help 2>&1 | grep -- type.*pie > /dev/null; then
+	  gcc_cv_ld_pie=yes
+	fi
+	;;
+    esac
+  fi
 fi
 if test x"$gcc_cv_ld_pie" = xyes; then
 
@@ -27734,6 +27756,44 @@
 
 fi
 
+case $target in
+*-*-solaris2*)
+  # Check for system-provided CRTs on Solaris 11.x and Solaris 12.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking system-provided CRTs on Solaris" >&5
+$as_echo_n "checking system-provided CRTs on Solaris... " >&6; }
+if test "${gcc_cv_solaris_crts+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_solaris_crts=no
+     if test x$host != x$target; then
+       if test "x$with_sysroot" = xyes; then
+         target_sysroot="${test_exec_prefix}/${target_noncanonical}/sys-root"
+       else
+         target_sysroot="${with_sysroot}"
+       fi
+     fi
+     target_libdir="$target_sysroot/usr/lib"
+     # At the time they were added, gcrt1.o became a symlink for backwards
+     # compatibility on x86, while crt1.o was added on sparc, so check for that.
+     case $target in
+       i?86-*-solaris2* | x86_64-*-solaris2*)
+         if test -h "$target_libdir/gcrt1.o"; then gcc_cv_solaris_crts=yes; fi
+	 ;;
+       sparc*-*-solaris2*)
+         if test -f "$target_libdir/crt1.o"; then gcc_cv_solaris_crts=yes; fi
+	 ;;
+     esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_solaris_crts" >&5
+$as_echo "$gcc_cv_solaris_crts" >&6; }
+  ;;
+esac
+if test x$gcc_cv_solaris_crts = xyes; then
+
+$as_echo "#define HAVE_SOLARIS_CRTS 1" >>confdefs.h
+
+fi
+
 # Test for stack protector support in target C library.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking __stack_chk_fail in target C library" >&5
 $as_echo_n "checking __stack_chk_fail in target C library... " >&6; }
@@ -28245,6 +28305,8 @@
 
 # Check whether isl_schedule_constraints_compute_schedule is available;
 # it's new in ISL-0.13.
+# Check whether isl_options_set_schedule_serialize_sccs is available;
+# it's new in ISL-0.15.
 if test "x${ISLLIBS}" != "x" ; then
   saved_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS $ISLINC"
@@ -28274,6 +28336,29 @@
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_schedule_constraints_compute_schedule" >&5
 $as_echo "$ac_has_isl_schedule_constraints_compute_schedule" >&6; }
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking Checking for isl_options_set_schedule_serialize_sccs" >&5
+$as_echo_n "checking Checking for isl_options_set_schedule_serialize_sccs... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <isl/schedule.h>
+int
+main ()
+{
+isl_options_set_schedule_serialize_sccs (NULL, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_has_isl_options_set_schedule_serialize_sccs=yes
+else
+  ac_has_isl_options_set_schedule_serialize_sccs=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_options_set_schedule_serialize_sccs" >&5
+$as_echo "$ac_has_isl_options_set_schedule_serialize_sccs" >&6; }
+
   LIBS="$saved_LIBS"
   CFLAGS="$saved_CFLAGS"
 
@@ -28282,6 +28367,12 @@
 $as_echo "#define HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE 1" >>confdefs.h
 
   fi
+
+  if test x"$ac_has_isl_options_set_schedule_serialize_sccs" = x"yes"; then
+
+$as_echo "#define HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS 1" >>confdefs.h
+
+  fi
 fi
 
 # Check for plugin support
diff -Naur gcc-5.2.0.orig/gcc/configure.ac gcc-5.2.0/gcc/configure.ac
--- gcc-5.2.0.orig/gcc/configure.ac	2015-07-03 12:00:49.000000000 -0500
+++ gcc-5.2.0/gcc/configure.ac	2015-10-12 05:59:21.185205000 -0500
@@ -4719,19 +4719,41 @@
 AC_MSG_CHECKING(linker position independent executable support)
 gcc_cv_ld_pie=no
 if test $in_tree_ld = yes ; then
-  if test "$gcc_cv_gld_major_version" -eq 2 -a "$gcc_cv_gld_minor_version" -ge 15 -o "$gcc_cv_gld_major_version" -gt 2 \
+  case "$target" in
+    # Full PIE support on Solaris was only introduced in gld 2.26.
+    *-*-solaris2*)  gcc_gld_pie_min_version=26 ;;
+    *) 		    gcc_gld_pie_min_version=15 ;;
+  esac
+  if test "$gcc_cv_gld_major_version" -eq 2 -a "$gcc_cv_gld_minor_version" -ge "$gcc_gld_pie_min_version" -o "$gcc_cv_gld_major_version" -gt 2 \
      && test $in_tree_ld_is_elf = yes; then
     gcc_cv_ld_pie=yes
   fi
 elif test x$gcc_cv_ld != x; then
-	# Check if linker supports -pie option
-	if $gcc_cv_ld --help 2>/dev/null | grep -- -pie > /dev/null; then
-		gcc_cv_ld_pie=yes
+  # Check if linker supports -pie option
+  if $gcc_cv_ld --help 2>/dev/null | grep -- -pie > /dev/null; then
+    gcc_cv_ld_pie=yes
+    case "$target" in
+      *-*-solaris2*)
+	if echo "$ld_ver" | grep GNU > /dev/null \
+	  && test "$ld_vers_major" -eq 2 -a "$ld_vers_minor" -lt 26; then
+	  gcc_cv_ld_pie=no
+	fi
+	;;
+    esac
+  else
+    case "$target" in
+      *-*-solaris2.1[[1-9]]*)
+	# Solaris 11.x and Solaris 12 added PIE support.
+	if $gcc_cv_ld -z help 2>&1 | grep -- type.*pie > /dev/null; then
+	  gcc_cv_ld_pie=yes
 	fi
+	;;
+    esac
+  fi
 fi
 if test x"$gcc_cv_ld_pie" = xyes; then
 	AC_DEFINE(HAVE_LD_PIE, 1,
-[Define if your linker supports -pie option.])
+[Define if your linker supports PIE option.])
 fi
 AC_MSG_RESULT($gcc_cv_ld_pie)
 
@@ -5224,6 +5246,37 @@
   [Define if your linker supports --sysroot.])
 fi	  
 
+case $target in
+*-*-solaris2*)
+  # Check for system-provided CRTs on Solaris 11.x and Solaris 12.
+  AC_CACHE_CHECK([system-provided CRTs on Solaris],
+    gcc_cv_solaris_crts,
+    [gcc_cv_solaris_crts=no
+     if test x$host != x$target; then
+       if test "x$with_sysroot" = xyes; then
+         target_sysroot="${test_exec_prefix}/${target_noncanonical}/sys-root"
+       else
+         target_sysroot="${with_sysroot}"
+       fi
+     fi
+     target_libdir="$target_sysroot/usr/lib"
+     # At the time they were added, gcrt1.o became a symlink for backwards
+     # compatibility on x86, while crt1.o was added on sparc, so check for that.
+     case $target in
+       i?86-*-solaris2* | x86_64-*-solaris2*)
+         if test -h "$target_libdir/gcrt1.o"; then gcc_cv_solaris_crts=yes; fi
+	 ;;
+       sparc*-*-solaris2*)
+         if test -f "$target_libdir/crt1.o"; then gcc_cv_solaris_crts=yes; fi
+	 ;;
+     esac])
+  ;;
+esac
+if test x$gcc_cv_solaris_crts = xyes; then
+  AC_DEFINE(HAVE_SOLARIS_CRTS, 1,
+  	    [Define if the system-provided CRTs are present on Solaris.])
+fi
+
 # Test for stack protector support in target C library.
 AC_CACHE_CHECK(__stack_chk_fail in target C library,
       gcc_cv_libc_provides_ssp,
@@ -5693,6 +5746,8 @@
 
 # Check whether isl_schedule_constraints_compute_schedule is available;
 # it's new in ISL-0.13.
+# Check whether isl_options_set_schedule_serialize_sccs is available;
+# it's new in ISL-0.15.
 if test "x${ISLLIBS}" != "x" ; then
   saved_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS $ISLINC"
@@ -5706,6 +5761,13 @@
               [ac_has_isl_schedule_constraints_compute_schedule=no])
   AC_MSG_RESULT($ac_has_isl_schedule_constraints_compute_schedule)
 
+  AC_MSG_CHECKING([Checking for isl_options_set_schedule_serialize_sccs])
+  AC_TRY_LINK([#include <isl/schedule.h>],
+              [isl_options_set_schedule_serialize_sccs (NULL, 0);],
+              [ac_has_isl_options_set_schedule_serialize_sccs=yes],
+              [ac_has_isl_options_set_schedule_serialize_sccs=no])
+  AC_MSG_RESULT($ac_has_isl_options_set_schedule_serialize_sccs)
+
   LIBS="$saved_LIBS"
   CFLAGS="$saved_CFLAGS"
 
@@ -5713,6 +5775,11 @@
      AC_DEFINE(HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE, 1,
                [Define if isl_schedule_constraints_compute_schedule exists.])
   fi
+
+  if test x"$ac_has_isl_options_set_schedule_serialize_sccs" = x"yes"; then
+     AC_DEFINE(HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS, 1,
+               [Define if isl_options_set_schedule_serialize_sccs exists.])
+  fi
 fi
 
 GCC_ENABLE_PLUGINS
diff -Naur gcc-5.2.0.orig/gcc/coretypes.h gcc-5.2.0/gcc/coretypes.h
--- gcc-5.2.0.orig/gcc/coretypes.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/coretypes.h	2015-08-05 06:20:59.983324000 -0500
@@ -263,6 +263,18 @@
   function_c11_misc
 };
 
+/* Suppose that higher bits are target dependent. */
+#define MEMMODEL_MASK ((1<<16)-1)
+
+/* Legacy sync operations set this upper flag in the memory model.  This allows
+   targets that need to do something stronger for sync operations to
+   differentiate with their target patterns and issue a more appropriate insn
+   sequence.  See bugzilla 65697 for background.  */
+#define MEMMODEL_SYNC (1<<15)
+
+/* Memory model without SYNC bit for targets/operations that do not care.  */
+#define MEMMODEL_BASE_MASK (MEMMODEL_SYNC-1)
+
 /* Memory model types for the __atomic* builtins. 
    This must match the order in libstdc++-v3/include/bits/atomic_base.h.  */
 enum memmodel
@@ -273,12 +285,12 @@
   MEMMODEL_RELEASE = 3,
   MEMMODEL_ACQ_REL = 4,
   MEMMODEL_SEQ_CST = 5,
-  MEMMODEL_LAST = 6
+  MEMMODEL_LAST = 6,
+  MEMMODEL_SYNC_ACQUIRE = MEMMODEL_ACQUIRE | MEMMODEL_SYNC,
+  MEMMODEL_SYNC_RELEASE = MEMMODEL_RELEASE | MEMMODEL_SYNC,
+  MEMMODEL_SYNC_SEQ_CST = MEMMODEL_SEQ_CST | MEMMODEL_SYNC
 };
 
-/* Suppose that higher bits are target dependent. */
-#define MEMMODEL_MASK ((1<<16)-1)
-
 /* Support for user-provided GGC and PCH markers.  The first parameter
    is a pointer to a pointer, the second a cookie.  */
 typedef void (*gt_pointer_operator) (void *, void *);
diff -Naur gcc-5.2.0.orig/gcc/cp/call.c gcc-5.2.0/gcc/cp/call.c
--- gcc-5.2.0.orig/gcc/cp/call.c	2015-06-23 19:53:02.000000000 -0500
+++ gcc-5.2.0/gcc/cp/call.c	2015-10-21 04:27:12.283863000 -0500
@@ -7002,6 +7002,39 @@
   return r;
 }
 
+/* Return true iff T refers to a base field.  */
+
+static bool
+is_base_field_ref (tree t)
+{
+  STRIP_NOPS (t);
+  if (TREE_CODE (t) == ADDR_EXPR)
+    t = TREE_OPERAND (t, 0);
+  if (TREE_CODE (t) == COMPONENT_REF)
+    t = TREE_OPERAND (t, 1);
+  if (TREE_CODE (t) == FIELD_DECL)
+    return DECL_FIELD_IS_BASE (t);
+  return false;
+}
+
+/* We can't elide a copy from a function returning by value to a base
+   subobject, as the callee might clobber tail padding.  Return true iff this
+   could be that case.  */
+
+static bool
+unsafe_copy_elision_p (tree target, tree exp)
+{
+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));
+  if (type == CLASSTYPE_AS_BASE (type))
+    return false;
+  if (!is_base_field_ref (target)
+      && resolves_to_fixed_type_p (target, NULL))
+    return false;
+  tree init = TARGET_EXPR_INITIAL (exp);
+  return (TREE_CODE (init) == AGGR_INIT_EXPR
+	  && !AGGR_INIT_VIA_CTOR_P (init));
+}
+
 /* Subroutine of the various build_*_call functions.  Overload resolution
    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.
    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a
@@ -7419,7 +7452,9 @@
 	  else if (trivial)
 	    return force_target_expr (DECL_CONTEXT (fn), arg, complain);
 	}
-      else if (TREE_CODE (arg) == TARGET_EXPR || trivial)
+      else if (trivial
+	       || (TREE_CODE (arg) == TARGET_EXPR
+		   && !unsafe_copy_elision_p (fa, arg)))
 	{
 	  tree to = stabilize_reference (cp_build_indirect_ref (fa, RO_NULL,
 								complain));
diff -Naur gcc-5.2.0.orig/gcc/cp/class.c gcc-5.2.0/gcc/cp/class.c
--- gcc-5.2.0.orig/gcc/cp/class.c	2015-07-01 12:06:52.000000000 -0500
+++ gcc-5.2.0/gcc/cp/class.c	2015-08-17 10:44:35.750755000 -0500
@@ -1989,14 +1989,23 @@
   if (!t)
     return;
 
+  tree attrs = TYPE_ATTRIBUTES (t);
+  unsigned align = TYPE_ALIGN (t);
+  bool user_align = TYPE_USER_ALIGN (t);
+
   for (variants = TYPE_NEXT_VARIANT (t);
        variants;
        variants = TYPE_NEXT_VARIANT (variants))
     {
       /* These are the two fields that check_qualified_type looks at and
 	 are affected by attributes.  */
-      TYPE_ATTRIBUTES (variants) = TYPE_ATTRIBUTES (t);
-      TYPE_ALIGN (variants) = TYPE_ALIGN (t);
+      TYPE_ATTRIBUTES (variants) = attrs;
+      unsigned valign = align;
+      if (TYPE_USER_ALIGN (variants))
+	valign = MAX (valign, TYPE_ALIGN (variants));
+      else
+	TYPE_USER_ALIGN (variants) = user_align;
+      TYPE_ALIGN (variants) = valign;
     }
 }
 
diff -Naur gcc-5.2.0.orig/gcc/cp/constexpr.c gcc-5.2.0/gcc/cp/constexpr.c
--- gcc-5.2.0.orig/gcc/cp/constexpr.c	2015-06-19 13:24:24.000000000 -0500
+++ gcc-5.2.0/gcc/cp/constexpr.c	2015-08-17 10:44:29.687207000 -0500
@@ -1750,7 +1750,38 @@
       VERIFY_CONSTANT (ary);
       gcc_unreachable ();
     }
-  if (compare_tree_int (index, len) >= 0)
+
+  i = tree_to_shwi (index);
+  bool found = true;
+  if (TREE_CODE (ary) == CONSTRUCTOR && len
+      && (TREE_CODE (CONSTRUCTOR_ELT (ary, len-1)->index) == RANGE_EXPR
+	  || compare_tree_int (CONSTRUCTOR_ELT (ary, len-1)->index, len-1)))
+    {
+      /* The last element doesn't match its position in the array; this must be
+	 a sparse array from cxx_eval_store_expression.  So iterate.  */
+      found = false;
+      vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (ary);
+      constructor_elt *e;
+      for (unsigned ix = 0; vec_safe_iterate (v, ix, &e); ++ix)
+	{
+	  if (TREE_CODE (e->index) == RANGE_EXPR)
+	    {
+	      tree lo = TREE_OPERAND (e->index, 0);
+	      tree hi = TREE_OPERAND (e->index, 1);
+	      if (tree_int_cst_le (lo, index) && tree_int_cst_le (index, hi))
+		found = true;
+	    }
+	  else if (tree_int_cst_equal (e->index, index))
+	    found = true;
+	  if (found)
+	    {
+	      i = ix;
+	      break;
+	    }
+	}
+    }
+
+  if (i >= len || !found)
     {
       if (tree_int_cst_lt (index, array_type_nelts_top (TREE_TYPE (ary))))
 	{
@@ -1767,14 +1798,14 @@
       *non_constant_p = true;
       return t;
     }
-  else if (tree_int_cst_lt (index, integer_zero_node))
+  else if (i < 0)
     {
       if (!ctx->quiet)
 	error ("negative array subscript");
       *non_constant_p = true;
       return t;
     }
-  i = tree_to_shwi (index);
+
   if (TREE_CODE (ary) == CONSTRUCTOR)
     return (*CONSTRUCTOR_ELTS (ary))[i].value;
   else if (elem_nchars == 1)
diff -Naur gcc-5.2.0.orig/gcc/cp/cp-tree.h gcc-5.2.0/gcc/cp/cp-tree.h
--- gcc-5.2.0.orig/gcc/cp/cp-tree.h	2015-06-24 15:24:01.000000000 -0500
+++ gcc-5.2.0/gcc/cp/cp-tree.h	2015-08-05 23:10:01.554759000 -0500
@@ -5762,6 +5762,7 @@
 extern tree instantiate_non_dependent_expr	(tree);
 extern tree instantiate_non_dependent_expr_sfinae (tree, tsubst_flags_t);
 extern tree instantiate_non_dependent_expr_internal (tree, tsubst_flags_t);
+extern bool variable_template_specialization_p  (tree);
 extern bool alias_type_or_template_p            (tree);
 extern bool alias_template_specialization_p     (const_tree);
 extern bool dependent_alias_template_spec_p     (const_tree);
@@ -5944,7 +5945,7 @@
 						 tsubst_flags_t);
 extern tree finish_call_expr			(tree, vec<tree, va_gc> **, bool,
 						 bool, tsubst_flags_t);
-extern tree finish_template_variable	(tree);
+extern tree finish_template_variable		(tree, tsubst_flags_t = tf_warning_or_error);
 extern tree finish_increment_expr		(tree, enum tree_code);
 extern tree finish_this_expr			(void);
 extern tree finish_pseudo_destructor_expr       (tree, tree, tree, location_t);
diff -Naur gcc-5.2.0.orig/gcc/cp/cvt.c gcc-5.2.0/gcc/cp/cvt.c
--- gcc-5.2.0.orig/gcc/cp/cvt.c	2015-04-22 15:53:02.000000000 -0500
+++ gcc-5.2.0/gcc/cp/cvt.c	2015-08-14 11:33:10.424885000 -0500
@@ -695,7 +695,8 @@
     }
 
   /* FIXME remove when moving to c_fully_fold model.  */
-  e = scalar_constant_value (e);
+  if (!CLASS_TYPE_P (type))
+    e = scalar_constant_value (e);
   if (error_operand_p (e))
     return error_mark_node;
 
diff -Naur gcc-5.2.0.orig/gcc/cp/decl2.c gcc-5.2.0/gcc/cp/decl2.c
--- gcc-5.2.0.orig/gcc/cp/decl2.c	2015-06-05 11:25:26.000000000 -0500
+++ gcc-5.2.0/gcc/cp/decl2.c	2015-10-12 08:15:30.542303000 -0500
@@ -1742,6 +1742,9 @@
   tree fnaddr;
   unsigned HOST_WIDE_INT idx;
 
+  /* It's OK for the vtable to refer to deprecated virtual functions.  */
+  warning_sentinel w(warn_deprecated_decl);
+
   FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (DECL_INITIAL (decl)),
 			      idx, fnaddr)
     {
@@ -4232,8 +4235,12 @@
 		TYPE_NAME (t));
     }
   else if (cxx_dialect >= cxx11)
-    permerror (DECL_SOURCE_LOCATION (decl), "%q#D, declared using local type "
-	       "%qT, is used but never defined", decl, t);
+    {
+      if (TREE_CODE (decl) == VAR_DECL || !DECL_PURE_VIRTUAL_P (decl))
+	permerror (DECL_SOURCE_LOCATION (decl),
+		   "%q#D, declared using local type "
+		   "%qT, is used but never defined", decl, t);
+    }
   else if (TREE_CODE (decl) == VAR_DECL)
     warning_at (DECL_SOURCE_LOCATION (decl), 0, "type %qT with no linkage "
 		"used to declare variable %q#D with linkage", t, decl);
diff -Naur gcc-5.2.0.orig/gcc/cp/error.c gcc-5.2.0/gcc/cp/error.c
--- gcc-5.2.0.orig/gcc/cp/error.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/cp/error.c	2015-08-12 13:05:49.608889000 -0500
@@ -1230,7 +1230,8 @@
 	if (args == error_mark_node)
 	  pp_string (pp, M_("<template arguments error>"));
 	else if (args)
-	  dump_template_argument_list (pp, args, flags);
+	  dump_template_argument_list
+	    (pp, args, flags|TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS);
       	pp_cxx_end_template_argument_list (pp);
       }
       break;
diff -Naur gcc-5.2.0.orig/gcc/cp/init.c gcc-5.2.0/gcc/cp/init.c
--- gcc-5.2.0.orig/gcc/cp/init.c	2015-06-24 10:41:10.000000000 -0500
+++ gcc-5.2.0/gcc/cp/init.c	2015-10-21 04:27:18.455628000 -0500
@@ -851,6 +851,18 @@
   return list;
 }
 
+/* Return the innermost aggregate scope for FIELD, whether that is
+   the enclosing class or an anonymous aggregate within it.  */
+
+static tree
+innermost_aggr_scope (tree field)
+{
+  if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))
+    return TREE_TYPE (field);
+  else
+    return DECL_CONTEXT (field);
+}
+
 /* The MEM_INITS are a TREE_LIST.  The TREE_PURPOSE of each list gives
    a FIELD_DECL or BINFO in T that needs initialization.  The
    TREE_VALUE gives the initializer, or list of initializer arguments.
@@ -994,7 +1006,7 @@
 
 	  /* See if this field is a member of a union, or a member of a
 	     structure contained in a union, etc.  */
-	  for (ctx = DECL_CONTEXT (field);
+	  for (ctx = innermost_aggr_scope (field);
 	       !same_type_p (ctx, t);
 	       ctx = TYPE_CONTEXT (ctx))
 	    if (TREE_CODE (ctx) == UNION_TYPE
@@ -1027,8 +1039,9 @@
 	       union { struct { int i; int j; }; };
 
 	     initializing both `i' and `j' makes sense.  */
-	  ctx = common_enclosing_class (DECL_CONTEXT (field),
-					DECL_CONTEXT (TREE_PURPOSE (*last_p)));
+	  ctx = common_enclosing_class
+	    (innermost_aggr_scope (field),
+	     innermost_aggr_scope (TREE_PURPOSE (*last_p)));
 
 	  if (ctx && TREE_CODE (ctx) == UNION_TYPE)
 	    {
diff -Naur gcc-5.2.0.orig/gcc/cp/mangle.c gcc-5.2.0/gcc/cp/mangle.c
--- gcc-5.2.0.orig/gcc/cp/mangle.c	2015-06-26 15:35:06.000000000 -0500
+++ gcc-5.2.0/gcc/cp/mangle.c	2015-08-06 09:28:26.630372000 -0500
@@ -2771,7 +2771,9 @@
     {
       tree fn = TREE_OPERAND (expr, 0);
       if (is_overloaded_fn (fn))
-	fn = DECL_NAME (get_first_fn (fn));
+	fn = get_first_fn (fn);
+      if (DECL_P (fn))
+	fn = DECL_NAME (fn);
       if (IDENTIFIER_OPNAME_P (fn))
 	write_string ("on");
       write_unqualified_id (fn);
diff -Naur gcc-5.2.0.orig/gcc/cp/parser.c gcc-5.2.0/gcc/cp/parser.c
--- gcc-5.2.0.orig/gcc/cp/parser.c	2015-06-29 04:34:58.000000000 -0500
+++ gcc-5.2.0/gcc/cp/parser.c	2015-09-09 02:32:28.892592000 -0500
@@ -4432,7 +4432,8 @@
 	parser->greater_than_is_operator_p
 	  = saved_greater_than_is_operator_p;
 	/* Consume the `)'.  */
-	if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))
+	if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN)
+	    && !cp_parser_uncommitted_to_tentative_parse_p (parser))
 	  cp_parser_skip_to_end_of_statement (parser);
 
 	return expr;
@@ -28181,8 +28182,8 @@
   if (num == error_mark_node)
     return list;
   num = fold_non_dependent_expr (num);
-  if (!INTEGRAL_TYPE_P (TREE_TYPE (num))
-      || !tree_fits_shwi_p (num)
+  if (!tree_fits_shwi_p (num)
+      || !INTEGRAL_TYPE_P (TREE_TYPE (num))
       || (n = tree_to_shwi (num)) <= 0
       || (int) n != n)
     {
diff -Naur gcc-5.2.0.orig/gcc/cp/pt.c gcc-5.2.0/gcc/cp/pt.c
--- gcc-5.2.0.orig/gcc/cp/pt.c	2015-07-10 09:12:20.000000000 -0500
+++ gcc-5.2.0/gcc/cp/pt.c	2015-09-08 10:02:27.890508000 -0500
@@ -3222,6 +3222,13 @@
 			ppd, ppd->visited);
 	  *walk_subtrees = 0;
 	}
+      else if (variable_template_specialization_p (t))
+	{
+	  cp_walk_tree (&DECL_TI_ARGS (t),
+			find_parameter_packs_r,
+			ppd, ppd->visited);
+	  *walk_subtrees = 0;
+	}
       break;
 
     case BASES:
@@ -5323,6 +5330,17 @@
   return instantiate_non_dependent_expr_sfinae (expr, tf_error);
 }
 
+/* True iff T is a specialization of a variable template.  */
+
+bool
+variable_template_specialization_p (tree t)
+{
+  if (!VAR_P (t) || !DECL_LANG_SPECIFIC (t) || !DECL_TEMPLATE_INFO (t))
+    return false;
+  tree tmpl = DECL_TI_TEMPLATE (t);
+  return variable_template_p (tmpl);
+}
+
 /* Return TRUE iff T is a type alias, a TEMPLATE_DECL for an alias
    template declaration, or a TYPE_DECL for an alias declaration.  */
 
@@ -8161,14 +8179,14 @@
 tree
 lookup_template_variable (tree templ, tree arglist)
 {
-  tree type = unknown_type_node;
+  tree type = NULL_TREE;
   return build2 (TEMPLATE_ID_EXPR, type, templ, arglist);
 }
 
 /* Instantiate a variable declaration from a TEMPLATE_ID_EXPR for use. */
 
 tree
-finish_template_variable (tree var)
+finish_template_variable (tree var, tsubst_flags_t complain)
 {
   tree templ = TREE_OPERAND (var, 0);
 
@@ -8177,7 +8195,6 @@
   arglist = add_outermost_template_args (tmpl_args, arglist);
 
   tree parms = DECL_TEMPLATE_PARMS (templ);
-  tsubst_flags_t complain = tf_warning_or_error;
   arglist = coerce_innermost_template_parms (parms, arglist, templ, complain,
 					     /*req_all*/true,
 					     /*use_default*/true);
@@ -11547,6 +11564,10 @@
 	  {
 	    DECL_ORIGINAL_TYPE (r) = NULL_TREE;
 	    set_underlying_type (r);
+	    if (TYPE_DECL_ALIAS_P (r) && type != error_mark_node)
+	      /* An alias template specialization can be dependent
+		 even if its underlying type is not.  */
+	      TYPE_DEPENDENT_P_VALID (TREE_TYPE (r)) = false;
 	  }
 
 	layout_decl (r, 0);
@@ -13089,8 +13110,9 @@
 	      if (r)
 		{
 		  /* Make sure that the one we found is the one we want.  */
-		  tree ctx = tsubst (DECL_CONTEXT (t), args,
-				     complain, in_decl);
+		  tree ctx = DECL_CONTEXT (t);
+		  if (DECL_LANG_SPECIFIC (ctx) && DECL_TEMPLATE_INFO (ctx))
+		    ctx = tsubst (ctx, args, complain, in_decl);
 		  if (ctx != DECL_CONTEXT (r))
 		    r = NULL_TREE;
 		}
@@ -13138,7 +13160,8 @@
 	}
       else
 	r = t;
-      mark_used (r);
+      if (!mark_used (r, complain) && !(complain & tf_error))
+	return error_mark_node;
       return r;
 
     case NAMESPACE_DECL:
@@ -14714,6 +14737,19 @@
 
 	if (targs)
 	  targs = tsubst_template_args (targs, args, complain, in_decl);
+	if (targs == error_mark_node)
+	  return error_mark_node;
+
+	if (variable_template_p (templ))
+	  {
+	    templ = lookup_template_variable (templ, targs);
+	    if (!any_dependent_template_arguments_p (targs))
+	      {
+		templ = finish_template_variable (templ, complain);
+		mark_used (templ);
+	      }
+	    RETURN (convert_from_reference (templ));
+	  }
 
 	if (TREE_CODE (templ) == COMPONENT_REF)
 	  {
@@ -15826,6 +15862,8 @@
 
 	LAMBDA_EXPR_THIS_CAPTURE (r) = NULL_TREE;
 
+	insert_pending_capture_proxies ();
+
 	RETURN (build_lambda_object (r));
       }
 
@@ -16112,6 +16150,8 @@
   /* The DECL_TI_TEMPLATE should always be the immediate parent
      template, not the most general template.  */
   DECL_TI_TEMPLATE (fndecl) = tmpl;
+  if (VAR_P (fndecl))
+    DECL_TI_ARGS (fndecl) = targ_ptr;
 
   /* Now we know the specialization, compute access previously
      deferred.  */
diff -Naur gcc-5.2.0.orig/gcc/cp/search.c gcc-5.2.0/gcc/cp/search.c
--- gcc-5.2.0.orig/gcc/cp/search.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/cp/search.c	2015-08-18 09:44:06.561968000 -0500
@@ -736,7 +736,7 @@
     Here DERIVED is a possible P, DECL is m and BINFO_TYPE (binfo) is N.  */
 
   /* If DERIVED isn't derived from N, then it can't be a P.  */
-  if (!DERIVED_FROM_P (BINFO_TYPE (binfo), derived))
+  if (!DERIVED_FROM_P (context_for_name_lookup (decl), derived))
     return 0;
 
   access = access_in_type (derived, decl);
diff -Naur gcc-5.2.0.orig/gcc/cp/semantics.c gcc-5.2.0/gcc/cp/semantics.c
--- gcc-5.2.0.orig/gcc/cp/semantics.c	2015-06-17 09:33:08.000000000 -0500
+++ gcc-5.2.0/gcc/cp/semantics.c	2015-09-10 02:40:59.531058000 -0500
@@ -3580,6 +3580,7 @@
 	{
 	  decl = finish_template_variable (decl);
 	  mark_used (decl);
+	  decl = convert_from_reference (decl);
 	}
       else if (scope)
 	{
@@ -4294,8 +4295,6 @@
     {
       if (error_operand_p (t))
 	return error_mark_node;
-      if (type_dependent_expression_p (t))
-	return NULL_TREE;
       if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)
 	{
 	  if (processing_template_decl)
@@ -4318,6 +4317,8 @@
 		    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);
 	  return error_mark_node;
 	}
+      if (type_dependent_expression_p (t))
+	return NULL_TREE;
       t = convert_from_reference (t);
       return t;
     }
@@ -5332,7 +5333,8 @@
 	  goto check_dup_generic;
 	case OMP_CLAUSE_LINEAR:
 	  t = OMP_CLAUSE_DECL (c);
-	  if (!type_dependent_expression_p (t)
+	  if ((VAR_P (t) || TREE_CODE (t) == PARM_DECL)
+	      && !type_dependent_expression_p (t)
 	      && !INTEGRAL_TYPE_P (TREE_TYPE (t))
 	      && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)
 	    {
@@ -5359,7 +5361,9 @@
 	  else
 	    {
 	      t = mark_rvalue_use (t);
-	      if (!processing_template_decl)
+	      if (!processing_template_decl
+		  && (VAR_P (OMP_CLAUSE_DECL (c))
+		      || TREE_CODE (OMP_CLAUSE_DECL (c)) == PARM_DECL))
 		{
 		  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == PARM_DECL)
 		    t = maybe_constant_value (t);
@@ -6452,7 +6456,8 @@
   iter_init = build_x_modify_expr (elocus,
 				   iter, PLUS_EXPR, iter_init,
 				   tf_warning_or_error);
-  iter_init = build1 (NOP_EXPR, void_type_node, iter_init);
+  if (iter_init != error_mark_node)
+    iter_init = build1 (NOP_EXPR, void_type_node, iter_init);
   finish_expr_stmt (iter_init);
   finish_expr_stmt (build_x_modify_expr (elocus,
 					 last, NOP_EXPR, decl,
diff -Naur gcc-5.2.0.orig/gcc/cp/tree.c gcc-5.2.0/gcc/cp/tree.c
--- gcc-5.2.0.orig/gcc/cp/tree.c	2015-06-23 09:28:55.000000000 -0500
+++ gcc-5.2.0/gcc/cp/tree.c	2015-07-16 08:25:25.804895000 -0500
@@ -3602,13 +3602,15 @@
 		 name, *node);
 	  goto fail;
 	}
-      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (*node))
+      else if (CLASS_TYPE_P (*node)
+	       && CLASSTYPE_TEMPLATE_INSTANTIATION (*node))
 	{
 	  warning (OPT_Wattributes, "ignoring %qE attribute applied to "
 		   "template instantiation %qT", name, *node);
 	  goto fail;
 	}
-      else if (CLASSTYPE_TEMPLATE_SPECIALIZATION (*node))
+      else if (CLASS_TYPE_P (*node)
+	       && CLASSTYPE_TEMPLATE_SPECIALIZATION (*node))
 	{
 	  warning (OPT_Wattributes, "ignoring %qE attribute applied to "
 		   "template specialization %qT", name, *node);
diff -Naur gcc-5.2.0.orig/gcc/DATESTAMP gcc-5.2.0/gcc/DATESTAMP
--- gcc-5.2.0.orig/gcc/DATESTAMP	2015-07-15 19:16:08.000000000 -0500
+++ gcc-5.2.0/gcc/DATESTAMP	2015-10-30 19:16:13.174605000 -0500
@@ -1 +1 @@
-20150716
+20151031
diff -Naur gcc-5.2.0.orig/gcc/df-problems.c gcc-5.2.0/gcc/df-problems.c
--- gcc-5.2.0.orig/gcc/df-problems.c	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/df-problems.c	2015-09-17 10:35:43.219378000 -0500
@@ -1323,22 +1323,23 @@
 
 
 /*----------------------------------------------------------------------------
-   LIVE AND MUST-INITIALIZED REGISTERS.
+   LIVE AND MAY-INITIALIZED REGISTERS.
 
    This problem first computes the IN and OUT bitvectors for the
-   must-initialized registers problems, which is a forward problem.
-   It gives the set of registers for which we MUST have an available
-   definition on any path from the entry block to the entry/exit of
-   a basic block.  Sets generate a definition, while clobbers kill
+   may-initialized registers problems, which is a forward problem.
+   It gives the set of registers for which we MAY have an available
+   definition, i.e. for which there is an available definition on
+   at least one path from the entry block to the entry/exit of a
+   basic block.  Sets generate a definition, while clobbers kill
    a definition.
 
    In and out bitvectors are built for each basic block and are indexed by
    regnum (see df.h for details).  In and out bitvectors in struct
-   df_live_bb_info actually refers to the must-initialized problem;
+   df_live_bb_info actually refers to the may-initialized problem;
 
    Then, the in and out sets for the LIVE problem itself are computed.
    These are the logical AND of the IN and OUT sets from the LR problem
-   and the must-initialized problem.
+   and the may-initialized problem.
 ----------------------------------------------------------------------------*/
 
 /* Private data used to verify the solution for this problem.  */
@@ -1545,7 +1546,7 @@
 }
 
 
-/* Transfer function for the forwards must-initialized problem.  */
+/* Transfer function for the forwards may-initialized problem.  */
 
 static bool
 df_live_transfer_function (int bb_index)
@@ -1569,7 +1570,7 @@
 }
 
 
-/* And the LR info with the must-initialized registers, to produce the LIVE info.  */
+/* And the LR info with the may-initialized registers to produce the LIVE info.  */
 
 static void
 df_live_finalize (bitmap all_blocks)
diff -Naur gcc-5.2.0.orig/gcc/doc/extend.texi gcc-5.2.0/gcc/doc/extend.texi
--- gcc-5.2.0.orig/gcc/doc/extend.texi	2015-06-18 05:56:43.000000000 -0500
+++ gcc-5.2.0/gcc/doc/extend.texi	2015-10-15 11:38:47.269450000 -0500
@@ -8423,9 +8423,9 @@
 than invoke a runtime library call or inline a switch statement.  This is
 standard compliant, safe, and the simplest approach for now.
 
-The memory model parameter is a signed int, but only the lower 8 bits are
+The memory model parameter is a signed int, but only the lower 16 bits are
 reserved for the memory model.  The remainder of the signed int is reserved
-for future use and should be 0.  Use of the predefined atomic values
+for target use and should be 0.  Use of the predefined atomic values
 ensures proper usage.
 
 @deftypefn {Built-in Function} @var{type} __atomic_load_n (@var{type} *ptr, int memmodel)
@@ -15153,6 +15153,28 @@
 unsigned int __builtin_tsuspend (void)
 @end smallexample
 
+Note that the semantics of the above HTM builtins are required to mimic
+the locking semantics used for critical sections.  Builtins that are used
+to create a new transaction or restart a suspended transaction must have
+lock acquisition like semantics while those builtins that end or suspend a
+transaction must have lock release like semantics.  Specifically, this must
+mimic lock semantics as specified by C++11, for example: Lock acquisition is
+as-if an execution of __atomic_exchange_n(&globallock,1,__ATOMIC_ACQUIRE)
+that returns 0, and lock release is as-if an execution of
+__atomic_store(&globallock,0,__ATOMIC_RELEASE), with globallock being an
+implicit implementation-defined lock used for all transactions.  The HTM
+instructions associated with with the builtins inherently provide the
+correct acquisition and release hardware barriers required.  However,
+the compiler must also be prohibited from moving loads and stores across
+the builtins in a way that would violate their semantics.  This has been
+accomplished by adding memory barriers to the associated HTM instructions
+(which is a conservative approach to provide acquire and release semantics).
+Earlier versions of the compiler did not treat the HTM instructions as
+memory barriers.  A @code{__TM_FENCE__} macro has been added, which can
+be used to determine whether the current compiler treats HTM instructions
+as memory barriers or not.  This allows the user to explicitly add memory
+barriers to their code when using an older version of the compiler.
+
 The following set of built-in functions are available to gain access
 to the HTM specific special purpose registers.
 
diff -Naur gcc-5.2.0.orig/gcc/doc/invoke.texi gcc-5.2.0/gcc/doc/invoke.texi
--- gcc-5.2.0.orig/gcc/doc/invoke.texi	2015-07-03 04:33:17.000000000 -0500
+++ gcc-5.2.0/gcc/doc/invoke.texi	2015-09-28 01:22:41.955493000 -0500
@@ -5628,25 +5628,26 @@
 Enable AddressSanitizer, a fast memory error detector.
 Memory access instructions are instrumented to detect
 out-of-bounds and use-after-free bugs.
-See @uref{http://code.google.com/p/address-sanitizer/} for
+See @uref{https://github.com/google/sanitizers/wiki/AddressSanitizer} for
 more details.  The run-time behavior can be influenced using the
-@env{ASAN_OPTIONS} environment variable; see
-@url{https://code.google.com/p/address-sanitizer/wiki/Flags#Run-time_flags} for
-a list of supported options.
+@env{ASAN_OPTIONS} environment variable.  When set to @code{help=1},
+the available options are shown at startup of the instrumended program.  See
+@url{https://github.com/google/sanitizers/wiki/AddressSanitizerFlags#run-time-flags}
+for a list of supported options.
 
 @item -fsanitize=kernel-address
 @opindex fsanitize=kernel-address
 Enable AddressSanitizer for Linux kernel.
-See @uref{http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel} for more details.
+See @uref{https://github.com/google/kasan/wiki} for more details.
 
 @item -fsanitize=thread
 @opindex fsanitize=thread
 Enable ThreadSanitizer, a fast data race detector.
 Memory access instructions are instrumented to detect
-data race bugs.  See @uref{http://code.google.com/p/thread-sanitizer/} for more
+data race bugs.  See @uref{https://github.com/google/sanitizers/wiki#threadsanitizer} for more
 details. The run-time behavior can be influenced using the @env{TSAN_OPTIONS}
 environment variable; see
-@url{https://code.google.com/p/thread-sanitizer/wiki/Flags} for a list of
+@url{https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags} for a list of
 supported options.
 
 @item -fsanitize=leak
@@ -5656,7 +5657,7 @@
 @option{-fsanitize=address} nor @option{-fsanitize=thread} is used.  In that
 case the executable is linked against a library that overrides @code{malloc}
 and other allocator functions.  See
-@uref{https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer} for more
+@uref{https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer} for more
 details.  The run-time behavior can be influenced using the
 @env{LSAN_OPTIONS} environment variable.
 
@@ -21056,8 +21057,8 @@
 @opindex muser-mode
 @opindex mno-user-mode
 Do not generate code that can only run in supervisor mode.  This is relevant
-only for the @code{casa} instruction emitted for the LEON3 processor.  The
-default is @option{-mno-user-mode}.
+only for the @code{casa} instruction emitted for the LEON3 processor.  This
+is the default.
 
 @item -mno-faster-structs
 @itemx -mfaster-structs
diff -Naur gcc-5.2.0.orig/gcc/dojump.c gcc-5.2.0/gcc/dojump.c
--- gcc-5.2.0.orig/gcc/dojump.c	2015-01-15 07:28:42.000000000 -0600
+++ gcc-5.2.0/gcc/dojump.c	2015-10-25 10:42:19.114693000 -0500
@@ -1217,12 +1217,12 @@
      If one side isn't, we want a noncanonicalized comparison.  See PR
      middle-end/17564.  */
   if (HAVE_canonicalize_funcptr_for_compare
-      && TREE_CODE (TREE_TYPE (treeop0)) == POINTER_TYPE
-      && TREE_CODE (TREE_TYPE (TREE_TYPE (treeop0)))
-          == FUNCTION_TYPE
-      && TREE_CODE (TREE_TYPE (treeop1)) == POINTER_TYPE
-      && TREE_CODE (TREE_TYPE (TREE_TYPE (treeop1)))
-          == FUNCTION_TYPE)
+      && POINTER_TYPE_P (TREE_TYPE (treeop0))
+      && POINTER_TYPE_P (TREE_TYPE (treeop1))
+      && (TREE_CODE (TREE_TYPE (TREE_TYPE (treeop0))) == FUNCTION_TYPE
+	  || TREE_CODE (TREE_TYPE (TREE_TYPE (treeop0))) == METHOD_TYPE)
+      && (TREE_CODE (TREE_TYPE (TREE_TYPE (treeop1))) == FUNCTION_TYPE
+	  || TREE_CODE (TREE_TYPE (TREE_TYPE (treeop1))) == METHOD_TYPE))
     {
       rtx new_op0 = gen_reg_rtx (mode);
       rtx new_op1 = gen_reg_rtx (mode);
diff -Naur gcc-5.2.0.orig/gcc/emit-rtl.c gcc-5.2.0/gcc/emit-rtl.c
--- gcc-5.2.0.orig/gcc/emit-rtl.c	2015-01-23 09:57:42.000000000 -0600
+++ gcc-5.2.0/gcc/emit-rtl.c	2015-08-05 06:20:59.983324000 -0500
@@ -6323,11 +6323,14 @@
     case MEMMODEL_CONSUME:
       return false;
     case MEMMODEL_RELEASE:
+    case MEMMODEL_SYNC_RELEASE:
       return pre;
     case MEMMODEL_ACQUIRE:
+    case MEMMODEL_SYNC_ACQUIRE:
       return !pre;
     case MEMMODEL_ACQ_REL:
     case MEMMODEL_SEQ_CST:
+    case MEMMODEL_SYNC_SEQ_CST:
       return true;
     default:
       gcc_unreachable ();
diff -Naur gcc-5.2.0.orig/gcc/except.c gcc-5.2.0/gcc/except.c
--- gcc-5.2.0.orig/gcc/except.c	2015-01-15 07:28:42.000000000 -0600
+++ gcc-5.2.0/gcc/except.c	2015-09-21 10:23:52.542487000 -0500
@@ -2235,7 +2235,7 @@
 		     VOIDmode, EXPAND_NORMAL);
   tmp = convert_memory_address (Pmode, tmp);
   if (!crtl->eh.ehr_stackadj)
-    crtl->eh.ehr_stackadj = copy_to_reg (tmp);
+    crtl->eh.ehr_stackadj = copy_addr_to_reg (tmp);
   else if (tmp != crtl->eh.ehr_stackadj)
     emit_move_insn (crtl->eh.ehr_stackadj, tmp);
 #endif
@@ -2244,7 +2244,7 @@
 		     VOIDmode, EXPAND_NORMAL);
   tmp = convert_memory_address (Pmode, tmp);
   if (!crtl->eh.ehr_handler)
-    crtl->eh.ehr_handler = copy_to_reg (tmp);
+    crtl->eh.ehr_handler = copy_addr_to_reg (tmp);
   else if (tmp != crtl->eh.ehr_handler)
     emit_move_insn (crtl->eh.ehr_handler, tmp);
 
diff -Naur gcc-5.2.0.orig/gcc/fold-const.c gcc-5.2.0/gcc/fold-const.c
--- gcc-5.2.0.orig/gcc/fold-const.c	2015-03-12 08:02:42.000000000 -0500
+++ gcc-5.2.0/gcc/fold-const.c	2015-09-28 05:45:55.478232000 -0500
@@ -6236,8 +6236,12 @@
 	      && ((sign == UNSIGNED && tcode != MULT_EXPR) || sign == SIGNED))
 	    overflow_p = true;
 	  if (!overflow_p)
-	    return fold_build2 (tcode, ctype, fold_convert (ctype, op0),
-				wide_int_to_tree (ctype, mul));
+	    {
+	      mul = wide_int::from (mul, TYPE_PRECISION (ctype),
+				    TYPE_SIGN (TREE_TYPE (op1)));
+	      return fold_build2 (tcode, ctype, fold_convert (ctype, op0),
+				  wide_int_to_tree (ctype, mul));
+	    }
 	}
 
       /* If these operations "cancel" each other, we have the main
@@ -7519,6 +7523,10 @@
 int
 native_encode_expr (const_tree expr, unsigned char *ptr, int len, int off)
 {
+  /* We don't support starting at negative offset and -1 is special.  */
+  if (off < -1)
+    return 0;
+
   switch (TREE_CODE (expr))
     {
     case INTEGER_CST:
diff -Naur gcc-5.2.0.orig/gcc/fortran/array.c gcc-5.2.0/gcc/fortran/array.c
--- gcc-5.2.0.orig/gcc/fortran/array.c	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/fortran/array.c	2015-10-29 14:37:59.442021000 -0500
@@ -1074,7 +1074,8 @@
   /* Try to match an optional "type-spec ::"  */
   gfc_clear_ts (&ts);
   gfc_new_undo_checkpoint (changed_syms);
-  if (gfc_match_type_spec (&ts) == MATCH_YES)
+  m = gfc_match_type_spec (&ts);
+  if (m == MATCH_YES)
     {
       seen_ts = (gfc_match (" ::") == MATCH_YES);
 
@@ -1096,6 +1097,11 @@
 	    }
 	}
     }
+  else if (m == MATCH_ERROR)
+    {
+      gfc_restore_last_undo_checkpoint ();
+      goto cleanup;
+    }
 
   if (seen_ts)
     gfc_drop_last_undo_checkpoint ();
diff -Naur gcc-5.2.0.orig/gcc/fortran/class.c gcc-5.2.0/gcc/fortran/class.c
--- gcc-5.2.0.orig/gcc/fortran/class.c	2015-03-24 05:28:48.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/class.c	2015-08-05 11:15:40.067149000 -0500
@@ -1599,6 +1599,7 @@
   final->ts.type = BT_INTEGER;
   final->ts.kind = 4;
   final->attr.artificial = 1;
+  final->attr.always_explicit = 1;
   final->attr.if_source = expr_null_wrapper ? IFSRC_IFBODY : IFSRC_DECL;
   if (ns->proc_name->attr.flavor == FL_MODULE)
     final->module = ns->proc_name->name;
diff -Naur gcc-5.2.0.orig/gcc/fortran/data.c gcc-5.2.0/gcc/fortran/data.c
--- gcc-5.2.0.orig/gcc/fortran/data.c	2015-01-31 18:29:54.000000000 -0600
+++ gcc-5.2.0/gcc/fortran/data.c	2015-10-29 15:07:13.209515000 -0500
@@ -104,7 +104,7 @@
 create_character_initializer (gfc_expr *init, gfc_typespec *ts,
 			      gfc_ref *ref, gfc_expr *rvalue)
 {
-  int len, start, end;
+  int len, start, end, tlen;
   gfc_char_t *dest;
   bool alloced_init = false;
 	    
@@ -162,12 +162,22 @@
   else
     len = rvalue->value.character.length;
 
-  if (len > end - start)
+  tlen = end - start;
+  if (len > tlen)
     {
-      gfc_warning_now (0, "Initialization string starting at %L was "
-		       "truncated to fit the variable (%d/%d)",
-		       &rvalue->where, end - start, len);
-      len = end - start;
+      if (tlen < 0)
+	{
+	  gfc_warning_now (0, "Unused initialization string at %L because "
+			   "variable has zero length", &rvalue->where);
+	  len = 0;
+	}
+      else
+	{
+	  gfc_warning_now (0, "Initialization string at %L was truncated to "
+			   "fit the variable (%d/%d)", &rvalue->where,
+			   tlen, len);
+	  len = tlen;
+	}
     }
 
   if (rvalue->ts.type == BT_HOLLERITH)
@@ -181,7 +191,7 @@
 	    len * sizeof (gfc_char_t));
 
   /* Pad with spaces.  Substrings will already be blanked.  */
-  if (len < end - start && ref == NULL)
+  if (len < tlen && ref == NULL)
     gfc_wide_memset (&dest[start + len], ' ', end - (start + len));
 
   if (rvalue->ts.type == BT_HOLLERITH)
diff -Naur gcc-5.2.0.orig/gcc/fortran/decl.c gcc-5.2.0/gcc/fortran/decl.c
--- gcc-5.2.0.orig/gcc/fortran/decl.c	2015-05-19 13:20:12.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/decl.c	2015-10-30 13:27:14.464395000 -0500
@@ -705,8 +705,7 @@
 
   if (gfc_match_char (':') == MATCH_YES)
     {
-      if (!gfc_notify_std (GFC_STD_F2003, "deferred type "
-			   "parameter at %C"))
+      if (!gfc_notify_std (GFC_STD_F2003, "deferred type parameter at %C"))
 	return MATCH_ERROR;
 
       *deferred = true;
@@ -716,33 +715,69 @@
 
   m = gfc_match_expr (expr);
 
-  if (m == MATCH_YES
-      && !gfc_expr_check_typed (*expr, gfc_current_ns, false))
+  if (m == MATCH_NO || m == MATCH_ERROR)
+    return m;
+
+  if (!gfc_expr_check_typed (*expr, gfc_current_ns, false))
     return MATCH_ERROR;
 
-  if (m == MATCH_YES && (*expr)->expr_type == EXPR_FUNCTION)
+  if ((*expr)->expr_type == EXPR_FUNCTION)
     {
-      if ((*expr)->value.function.actual
-	  && (*expr)->value.function.actual->expr->symtree)
+      if ((*expr)->ts.type == BT_INTEGER
+	  || ((*expr)->ts.type == BT_UNKNOWN
+	      && strcmp((*expr)->symtree->name, "null") != 0))
+	return MATCH_YES;
+
+      goto syntax;
+    }
+  else if ((*expr)->expr_type == EXPR_CONSTANT)
+    {
+      /* F2008, 4.4.3.1:  The length is a type parameter; its kind is
+	 processor dependent and its value is greater than or equal to zero.
+	 F2008, 4.4.3.2:  If the character length parameter value evaluates
+	 to a negative value, the length of character entities declared
+	 is zero.  */
+
+      if ((*expr)->ts.type == BT_INTEGER)
 	{
-	  gfc_expr *e;
-	  e = (*expr)->value.function.actual->expr;
-	  if (e->symtree->n.sym->attr.flavor == FL_PROCEDURE
-	      && e->expr_type == EXPR_VARIABLE)
-	    {
-	      if (e->symtree->n.sym->ts.type == BT_UNKNOWN)
-		goto syntax;
-	      if (e->symtree->n.sym->ts.type == BT_CHARACTER
-		  && e->symtree->n.sym->ts.u.cl
-		  && e->symtree->n.sym->ts.u.cl->length->ts.type == BT_UNKNOWN)
-	        goto syntax;
-	    }
+	  if (mpz_cmp_si ((*expr)->value.integer, 0) < 0)
+	    mpz_set_si ((*expr)->value.integer, 0);
+	}
+      else
+	goto syntax;
+    }
+  else if ((*expr)->expr_type == EXPR_ARRAY)
+    goto syntax;
+  else if ((*expr)->expr_type == EXPR_VARIABLE)
+    {
+      gfc_expr *e;
+
+      e = gfc_copy_expr (*expr);
+
+      /* This catches the invalid code "[character(m(2:3)) :: 'x', 'y']",
+	 which causes an ICE if gfc_reduce_init_expr() is called.  */
+      if (e->ref && e->ref->type == REF_ARRAY
+	  && e->ref->u.ar.type == AR_UNKNOWN
+	  && e->ref->u.ar.dimen_type[0] == DIMEN_RANGE)
+	goto syntax;
+
+      gfc_reduce_init_expr (e);
+
+      if ((e->ref && e->ref->type == REF_ARRAY
+	   && e->ref->u.ar.type != AR_ELEMENT) 
+	  || (!e->ref && e->expr_type == EXPR_ARRAY))
+	{
+	  gfc_free_expr (e);
+	  goto syntax;
 	}
+
+      gfc_free_expr (e);
     }
+
   return m;
 
 syntax:
-  gfc_error ("Conflict in attributes of function argument at %C");
+  gfc_error ("Scalar INTEGER expression expected at %L", &(*expr)->where);
   return MATCH_ERROR;
 }
 
@@ -1236,7 +1271,9 @@
   int slen;
 
   gcc_assert (expr->expr_type == EXPR_CONSTANT);
-  gcc_assert (expr->ts.type == BT_CHARACTER);
+
+  if (expr->ts.type != BT_CHARACTER)
+    return;
 
   slen = expr->value.character.length;
   if (len != slen)
@@ -1404,7 +1441,16 @@
 		    }
 		  else if (init->expr_type == EXPR_ARRAY)
 		    {
-		      clen = mpz_get_si (init->ts.u.cl->length->value.integer);
+		      if (init->ts.u.cl)
+			clen = mpz_get_si (init->ts.u.cl->length->value.integer);
+		      else if (init->value.constructor)
+			{
+			  gfc_constructor *c;
+	                  c = gfc_constructor_first (init->value.constructor); 	 
+	                  clen = c->expr->value.character.length;
+			}
+		      else
+			  gcc_unreachable ();
 		      sym->ts.u.cl->length
 				= gfc_get_int_expr (gfc_default_integer_kind,
 						    NULL, clen);
@@ -1417,7 +1463,12 @@
 	  /* Update initializer character length according symbol.  */
 	  else if (sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
 	    {
-	      int len = mpz_get_si (sym->ts.u.cl->length->value.integer);
+	      int len;
+
+	      if (!gfc_specification_expr (sym->ts.u.cl->length))
+		return false;
+
+	      len = mpz_get_si (sym->ts.u.cl->length->value.integer);
 
 	      if (init->expr_type == EXPR_CONSTANT)
 		gfc_set_constant_character_len (len, init, -1);
@@ -1449,7 +1500,6 @@
 			 " with scalar", &sym->declared_at);
 	      return false;
 	    }
-	  gcc_assert (sym->as->rank == init->rank);
 
 	  /* Shape should be present, we get an initialization expression.  */
 	  gcc_assert (init->shape);
@@ -2945,7 +2995,11 @@
 
   m = gfc_match_kind_spec (ts, false);
   if (m == MATCH_NO && ts->type != BT_CHARACTER)
-    m = gfc_match_old_kind_spec (ts);
+    {
+      m = gfc_match_old_kind_spec (ts);
+      if (gfc_validate_kind (ts->type, ts->kind, true) == -1)
+         return MATCH_ERROR;
+    }
 
   if (matched_type && gfc_match_char (')') != MATCH_YES)
     return MATCH_ERROR;
@@ -3870,7 +3924,9 @@
 	  break;
 
 	case DECL_PROTECTED:
-	  if (gfc_current_ns->proc_name->attr.flavor != FL_MODULE)
+	  if (gfc_current_state () != COMP_MODULE
+	      || (gfc_current_ns->proc_name
+		  && gfc_current_ns->proc_name->attr.flavor != FL_MODULE))
 	    {
 	       gfc_error ("PROTECTED at %C only allowed in specification "
 			  "part of a module");
diff -Naur gcc-5.2.0.orig/gcc/fortran/error.c gcc-5.2.0/gcc/fortran/error.c
--- gcc-5.2.0.orig/gcc/fortran/error.c	2015-01-31 18:29:54.000000000 -0600
+++ gcc-5.2.0/gcc/fortran/error.c	2015-09-04 13:41:08.087653000 -0500
@@ -804,6 +804,9 @@
   pp->buffer = this_buffer;
   pp_clear_output_area (pp);
   pp->buffer = tmp_buffer;
+  /* We need to reset last_location, otherwise we may skip caret lines
+     when we actually give a diagnostic.  */
+  global_dc->last_location = UNKNOWN_LOCATION;
 }
 
 
diff -Naur gcc-5.2.0.orig/gcc/fortran/expr.c gcc-5.2.0/gcc/fortran/expr.c
--- gcc-5.2.0.orig/gcc/fortran/expr.c	2015-05-19 12:59:58.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/expr.c	2015-09-10 13:07:07.099692000 -0500
@@ -2599,14 +2599,18 @@
       break;
 
     case EXPR_SUBSTRING:
-      t = gfc_check_init_expr (e->ref->u.ss.start);
-      if (!t)
-	break;
-
-      t = gfc_check_init_expr (e->ref->u.ss.end);
-      if (t)
-	t = gfc_simplify_expr (e, 0);
+      if (e->ref)
+	{
+	  t = gfc_check_init_expr (e->ref->u.ss.start);
+	  if (!t)
+	    break;
 
+	  t = gfc_check_init_expr (e->ref->u.ss.end);
+	  if (t)
+	    t = gfc_simplify_expr (e, 0);
+	}
+      else
+	t = false;
       break;
 
     case EXPR_STRUCTURE:
diff -Naur gcc-5.2.0.orig/gcc/fortran/interface.c gcc-5.2.0/gcc/fortran/interface.c
--- gcc-5.2.0.orig/gcc/fortran/interface.c	2015-05-19 13:31:39.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/interface.c	2015-10-30 11:58:20.838643000 -0500
@@ -2442,7 +2442,9 @@
 	  {
 	    if (ref->u.ar.as->lower[i] && ref->u.ar.as->upper[i]
 		&& ref->u.ar.as->lower[i]->expr_type == EXPR_CONSTANT
-		&& ref->u.ar.as->upper[i]->expr_type == EXPR_CONSTANT)
+		&& ref->u.ar.as->lower[i]->ts.type == BT_INTEGER
+		&& ref->u.ar.as->upper[i]->expr_type == EXPR_CONSTANT
+		&& ref->u.ar.as->upper[i]->ts.type == BT_INTEGER)
 	      elements *= mpz_get_si (ref->u.ar.as->upper[i]->value.integer)
 			  - mpz_get_si (ref->u.ar.as->lower[i]->value.integer)
 			  + 1L;
diff -Naur gcc-5.2.0.orig/gcc/fortran/io.c gcc-5.2.0/gcc/fortran/io.c
--- gcc-5.2.0.orig/gcc/fortran/io.c	2015-05-19 20:50:34.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/io.c	2015-10-02 15:19:32.809047000 -0500
@@ -1181,7 +1181,7 @@
 }
 
 
-/************ Fortran 95 I/O statement matchers *************/
+/************ Fortran I/O statement matchers *************/
 
 /* Match a FORMAT statement.  This amounts to actually parsing the
    format descriptors in order to correctly locate the end of the
@@ -1242,6 +1242,36 @@
 }
 
 
+/* Check for a CHARACTER variable.  The check for scalar is done in
+   resolve_tag.  */
+
+static bool
+check_char_variable (gfc_expr *e)
+{
+  if (e->expr_type != EXPR_VARIABLE || e->ts.type != BT_CHARACTER)
+    {
+      gfc_error("IOMSG must be a scalar-default-char-variable at %L", &e->where);
+      return false;
+    }
+  return true;
+}
+
+
+static bool
+is_char_type (const char *name, gfc_expr *e)
+{
+  gfc_resolve_expr (e);
+
+  if (e->ts.type != BT_CHARACTER)
+    {
+      gfc_error ("%s requires a scalar-default-char-expr at %L",
+		   name, &e->where);
+      return false;
+    }
+  return true;
+}
+
+
 /* Match an expression I/O tag of some sort.  */
 
 static match
@@ -1552,12 +1582,16 @@
   match m;
 
   m = match_etag (&tag_e_async, &open->asynchronous);
+  if (m == MATCH_YES && !is_char_type ("ASYNCHRONOUS", open->asynchronous))
+    return MATCH_ERROR;
   if (m != MATCH_NO)
     return m;
   m = match_etag (&tag_unit, &open->unit);
   if (m != MATCH_NO)
     return m;
-  m = match_out_tag (&tag_iomsg, &open->iomsg);
+  m = match_etag (&tag_iomsg, &open->iomsg);
+  if (m == MATCH_YES && !check_char_variable (open->iomsg))
+    return MATCH_ERROR;
   if (m != MATCH_NO)
     return m;
   m = match_out_tag (&tag_iostat, &open->iostat);
@@ -1870,6 +1904,9 @@
       static const char *access_f2003[] = { "STREAM", NULL };
       static const char *access_gnu[] = { "APPEND", NULL };
 
+      if (!is_char_type ("ACCESS", open->access))
+	goto cleanup;
+
       if (!compare_to_allowed_values ("ACCESS", access_f95, access_f2003,
 				      access_gnu,
 				      open->access->value.character.string,
@@ -1882,6 +1919,9 @@
     {
       static const char *action[] = { "READ", "WRITE", "READWRITE", NULL };
 
+      if (!is_char_type ("ACTION", open->action))
+	goto cleanup;
+
       if (!compare_to_allowed_values ("ACTION", action, NULL, NULL,
 				      open->action->value.character.string,
 				      "OPEN", warn))
@@ -1895,6 +1935,9 @@
 			   "not allowed in Fortran 95"))
 	goto cleanup;
 
+      if (!is_char_type ("ASYNCHRONOUS", open->asynchronous))
+	goto cleanup;
+
       if (open->asynchronous->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * asynchronous[] = { "YES", "NO", NULL };
@@ -1913,6 +1956,9 @@
 			   "not allowed in Fortran 95"))
 	goto cleanup;
 
+      if (!is_char_type ("BLANK", open->blank))
+	goto cleanup;
+
       if (open->blank->expr_type == EXPR_CONSTANT)
 	{
 	  static const char *blank[] = { "ZERO", "NULL", NULL };
@@ -1931,6 +1977,9 @@
 			   "not allowed in Fortran 95"))
 	goto cleanup;
 
+      if (!is_char_type ("DECIMAL", open->decimal))
+	goto cleanup;
+
       if (open->decimal->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * decimal[] = { "COMMA", "POINT", NULL };
@@ -1949,6 +1998,9 @@
 	{
 	  static const char *delim[] = { "APOSTROPHE", "QUOTE", "NONE", NULL };
 
+	if (!is_char_type ("DELIM", open->delim))
+	  goto cleanup;
+
 	  if (!compare_to_allowed_values ("DELIM", delim, NULL, NULL,
 					  open->delim->value.character.string,
 					  "OPEN", warn))
@@ -1962,7 +2014,10 @@
       if (!gfc_notify_std (GFC_STD_F2003, "ENCODING= at %C "
 			   "not allowed in Fortran 95"))
 	goto cleanup;
-    
+
+      if (!is_char_type ("ENCODING", open->encoding))
+	goto cleanup;
+
       if (open->encoding->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * encoding[] = { "DEFAULT", "UTF-8", NULL };
@@ -1979,6 +2034,9 @@
     {
       static const char *form[] = { "FORMATTED", "UNFORMATTED", NULL };
 
+      if (!is_char_type ("FORM", open->form))
+	goto cleanup;
+
       if (!compare_to_allowed_values ("FORM", form, NULL, NULL,
 				      open->form->value.character.string,
 				      "OPEN", warn))
@@ -1990,6 +2048,9 @@
     {
       static const char *pad[] = { "YES", "NO", NULL };
 
+      if (!is_char_type ("PAD", open->pad))
+	goto cleanup;
+
       if (!compare_to_allowed_values ("PAD", pad, NULL, NULL,
 				      open->pad->value.character.string,
 				      "OPEN", warn))
@@ -2001,6 +2062,9 @@
     {
       static const char *position[] = { "ASIS", "REWIND", "APPEND", NULL };
 
+      if (!is_char_type ("POSITION", open->position))
+	goto cleanup;
+
       if (!compare_to_allowed_values ("POSITION", position, NULL, NULL,
 				      open->position->value.character.string,
 				      "OPEN", warn))
@@ -2014,6 +2078,9 @@
 			   "not allowed in Fortran 95"))
       goto cleanup;
 
+      if (!is_char_type ("ROUND", open->round))
+	goto cleanup;
+
       if (open->round->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * round[] = { "UP", "DOWN", "ZERO", "NEAREST",
@@ -2034,6 +2101,9 @@
 			   "not allowed in Fortran 95"))
 	goto cleanup;
 
+      if (!is_char_type ("SIGN", open->sign))
+	goto cleanup;
+
       if (open->sign->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * sign[] = { "PLUS", "SUPPRESS", "PROCESSOR_DEFINED",
@@ -2071,6 +2141,9 @@
       static const char *status[] = { "OLD", "NEW", "SCRATCH",
 	"REPLACE", "UNKNOWN", NULL };
 
+      if (!is_char_type ("STATUS", open->status))
+	goto cleanup;
+
       if (!compare_to_allowed_values ("STATUS", status, NULL, NULL,
 				      open->status->value.character.string,
 				      "OPEN", warn))
@@ -2182,7 +2255,9 @@
   m = match_etag (&tag_status, &close->status);
   if (m != MATCH_NO)
     return m;
-  m = match_out_tag (&tag_iomsg, &close->iomsg);
+  m = match_etag (&tag_iomsg, &close->iomsg);
+  if (m == MATCH_YES && !check_char_variable (close->iomsg))
+    return MATCH_ERROR;
   if (m != MATCH_NO)
     return m;
   m = match_out_tag (&tag_iostat, &close->iostat);
@@ -2256,6 +2331,9 @@
     {
       static const char *status[] = { "KEEP", "DELETE", NULL };
 
+      if (!is_char_type ("STATUS", close->status))
+	goto cleanup;
+
       if (!compare_to_allowed_values ("STATUS", status, NULL, NULL,
 				      close->status->value.character.string,
 				      "CLOSE", warn))
@@ -2340,7 +2418,9 @@
   m = match_etag (&tag_unit, &fp->unit);
   if (m != MATCH_NO)
     return m;
-  m = match_out_tag (&tag_iomsg, &fp->iomsg);
+  m = match_etag (&tag_iomsg, &fp->iomsg);
+  if (m == MATCH_YES && !check_char_variable (fp->iomsg))
+    return MATCH_ERROR;
   if (m != MATCH_NO)
     return m;
   m = match_out_tag (&tag_iostat, &fp->iostat);
@@ -2436,12 +2516,21 @@
   if (!gfc_reference_st_label (fp->err, ST_LABEL_TARGET))
     return false;
 
+  if (!fp->unit && (fp->iostat || fp->iomsg))
+    {
+      locus where;
+      where = fp->iostat ? fp->iostat->where : fp->iomsg->where;
+      gfc_error ("UNIT number missing in statement at %L", &where);
+      return false;
+    }
+
   if (fp->unit->expr_type == EXPR_CONSTANT
       && fp->unit->ts.type == BT_INTEGER
       && mpz_sgn (fp->unit->value.integer) < 0)
     {
       gfc_error ("UNIT number in statement at %L must be non-negative",
 		 &fp->unit->where);
+      return false;
     }
 
   return true;
@@ -2676,6 +2765,8 @@
     }
 
   m = match_etag (&tag_e_async, &dt->asynchronous);
+  if (m == MATCH_YES && !is_char_type ("ASYNCHRONOUS", dt->asynchronous))
+    return MATCH_ERROR;
   if (m != MATCH_NO)
     return m;
   m = match_etag (&tag_e_blank, &dt->blank);
@@ -2705,9 +2796,12 @@
   m = match_etag (&tag_spos, &dt->pos);
   if (m != MATCH_NO)
     return m;
-  m = match_out_tag (&tag_iomsg, &dt->iomsg);
+  m = match_etag (&tag_iomsg, &dt->iomsg);
+  if (m == MATCH_YES && !check_char_variable (dt->iomsg))
+    return MATCH_ERROR;
   if (m != MATCH_NO)
     return m;
+
   m = match_out_tag (&tag_iostat, &dt->iostat);
   if (m != MATCH_NO)
     return m;
@@ -3305,6 +3399,9 @@
 	  return MATCH_ERROR;
 	}
 
+      if (!is_char_type ("ASYNCHRONOUS", dt->asynchronous))
+	return MATCH_ERROR;
+
       if (!compare_to_allowed_values
 		("ASYNCHRONOUS", asynchronous, NULL, NULL,
 		 dt->asynchronous->value.character.string,
@@ -3334,6 +3431,9 @@
 	{
 	  static const char * decimal[] = { "COMMA", "POINT", NULL };
 
+      if (!is_char_type ("DECIMAL", dt->decimal))
+	return MATCH_ERROR;
+
 	  if (!compare_to_allowed_values ("DECIMAL", decimal, NULL, NULL,
 					  dt->decimal->value.character.string,
 					  io_kind_name (k), warn))
@@ -3351,10 +3451,14 @@
 			   "not allowed in Fortran 95"))
 	return MATCH_ERROR;
 
+      if (!is_char_type ("BLANK", dt->blank))
+	return MATCH_ERROR;
+
       if (dt->blank->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * blank[] = { "NULL", "ZERO", NULL };
 
+
 	  if (!compare_to_allowed_values ("BLANK", blank, NULL, NULL,
 					  dt->blank->value.character.string,
 					  io_kind_name (k), warn))
@@ -3372,6 +3476,9 @@
 			   "not allowed in Fortran 95"))
 	return MATCH_ERROR;
 
+      if (!is_char_type ("PAD", dt->pad))
+	return MATCH_ERROR;
+
       if (dt->pad->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * pad[] = { "YES", "NO", NULL };
@@ -3393,6 +3500,9 @@
 			   "not allowed in Fortran 95"))
 	return MATCH_ERROR;
 
+      if (!is_char_type ("ROUND", dt->round))
+	return MATCH_ERROR;
+
       if (dt->round->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * round[] = { "UP", "DOWN", "ZERO", "NEAREST",
@@ -3412,6 +3522,10 @@
       if (gfc_notify_std (GFC_STD_F2003, "SIGN= at %C "
 	  "not allowed in Fortran 95") == false)
 	return MATCH_ERROR;  */
+
+      if (!is_char_type ("SIGN", dt->sign))
+	return MATCH_ERROR;
+
       if (dt->sign->expr_type == EXPR_CONSTANT)
 	{
 	  static const char * sign[] = { "PLUS", "SUPPRESS", "PROCESSOR_DEFINED",
@@ -3438,6 +3552,9 @@
 			   "not allowed in Fortran 95"))
 	return MATCH_ERROR;
 
+      if (!is_char_type ("DELIM", dt->delim))
+	return MATCH_ERROR;
+
       if (dt->delim->expr_type == EXPR_CONSTANT)
 	{
 	  static const char *delim[] = { "APOSTROPHE", "QUOTE", "NONE", NULL };
@@ -3860,7 +3977,9 @@
   m = match_etag (&tag_unit, &inquire->unit);
   RETM m = match_etag (&tag_file, &inquire->file);
   RETM m = match_ltag (&tag_err, &inquire->err);
-  RETM m = match_out_tag (&tag_iomsg, &inquire->iomsg);
+  RETM m = match_etag (&tag_iomsg, &inquire->iomsg);
+  if (m == MATCH_YES && !check_char_variable (inquire->iomsg))
+    return MATCH_ERROR;
   RETM m = match_out_tag (&tag_iostat, &inquire->iostat);
   RETM m = match_vtag (&tag_exist, &inquire->exist);
   RETM m = match_vtag (&tag_opened, &inquire->opened);
@@ -3882,6 +4001,8 @@
   RETM m = match_vtag (&tag_write, &inquire->write);
   RETM m = match_vtag (&tag_readwrite, &inquire->readwrite);
   RETM m = match_vtag (&tag_s_async, &inquire->asynchronous);
+  if (m == MATCH_YES && !is_char_type ("ASYNCHRONOUS", inquire->asynchronous))
+    return MATCH_ERROR;
   RETM m = match_vtag (&tag_s_delim, &inquire->delim);
   RETM m = match_vtag (&tag_s_decimal, &inquire->decimal);
   RETM m = match_out_tag (&tag_size, &inquire->size);
@@ -4143,7 +4264,9 @@
   RETM m = match_ltag (&tag_err, &wait->err);
   RETM m = match_ltag (&tag_end, &wait->eor);
   RETM m = match_ltag (&tag_eor, &wait->end);
-  RETM m = match_out_tag (&tag_iomsg, &wait->iomsg);
+  RETM m = match_etag (&tag_iomsg, &wait->iomsg);
+  if (m == MATCH_YES && !check_char_variable (wait->iomsg))
+    return MATCH_ERROR;
   RETM m = match_out_tag (&tag_iostat, &wait->iostat);
   RETM m = match_etag (&tag_id, &wait->id);
   RETM return MATCH_NO;
diff -Naur gcc-5.2.0.orig/gcc/fortran/match.c gcc-5.2.0/gcc/fortran/match.c
--- gcc-5.2.0.orig/gcc/fortran/match.c	2015-06-08 11:45:56.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/match.c	2015-10-29 14:37:59.442021000 -0500
@@ -544,7 +544,10 @@
   c = gfc_next_ascii_char ();
   if (!(ISALPHA (c) || (c == '_' && flag_allow_leading_underscore)))
     {
-      if (!gfc_error_flag_test () && c != '(')
+      /* Special cases for unary minus and plus, which allows for a sensible
+	 error message for code of the form 'c = exp(-a*b) )' where an
+	 extra ')' appears at the end of statement.  */
+      if (!gfc_error_flag_test () && c != '(' && c != '-' && c != '+')
 	gfc_error ("Invalid character in name at %C");
       gfc_current_locus = old_loc;
       return MATCH_NO;
@@ -1943,6 +1946,11 @@
   if (m == MATCH_NO)
     m = MATCH_YES;		/* No kind specifier found.  */
 
+  /* gfortran may have matched REAL(a=1), which is the keyword form of the
+     intrinsic procedure.  */
+  if (ts->type == BT_REAL && m == MATCH_ERROR)
+    m = MATCH_NO;
+
   return m;
 }
 
diff -Naur gcc-5.2.0.orig/gcc/fortran/parse.c gcc-5.2.0/gcc/fortran/parse.c
--- gcc-5.2.0.orig/gcc/fortran/parse.c	2015-05-19 12:25:09.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/parse.c	2015-09-25 17:45:27.788689000 -0500
@@ -3092,15 +3092,18 @@
 static void
 check_function_result_typed (void)
 {
-  gfc_typespec* ts = &gfc_current_ns->proc_name->result->ts;
+  gfc_typespec ts;
 
   gcc_assert (gfc_current_state () == COMP_FUNCTION);
-  gcc_assert (ts->type != BT_UNKNOWN);
+
+  if (!gfc_current_ns->proc_name->result) return;
+
+  ts = gfc_current_ns->proc_name->result->ts;
 
   /* Check type-parameters, at the moment only CHARACTER lengths possible.  */
   /* TODO:  Extend when KIND type parameters are implemented.  */
-  if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length)
-    gfc_expr_check_typed (ts->u.cl->length, gfc_current_ns, true);
+  if (ts.type == BT_CHARACTER && ts.u.cl && ts.u.cl->length)
+    gfc_expr_check_typed (ts.u.cl->length, gfc_current_ns, true);
 }
 
 
diff -Naur gcc-5.2.0.orig/gcc/fortran/primary.c gcc-5.2.0/gcc/fortran/primary.c
--- gcc-5.2.0.orig/gcc/fortran/primary.c	2015-04-09 14:37:57.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/primary.c	2015-10-26 12:25:03.496685000 -0500
@@ -748,7 +748,7 @@
 /* Match a substring reference.  */
 
 static match
-match_substring (gfc_charlen *cl, int init, gfc_ref **result)
+match_substring (gfc_charlen *cl, int init, gfc_ref **result, bool deferred)
 {
   gfc_expr *start, *end;
   locus old_loc;
@@ -800,7 +800,7 @@
     }
 
   /* Optimize away the (:) reference.  */
-  if (start == NULL && end == NULL)
+  if (start == NULL && end == NULL && !deferred)
     ref = NULL;
   else
     {
@@ -1098,7 +1098,7 @@
   if (ret != -1)
     gfc_internal_error ("match_string_constant(): Delimiter not found");
 
-  if (match_substring (NULL, 0, &e->ref) != MATCH_NO)
+  if (match_substring (NULL, 0, &e->ref, false) != MATCH_NO)
     e->expr_type = EXPR_SUBSTRING;
 
   *result = e;
@@ -1202,6 +1202,9 @@
       return MATCH_ERROR;
     }
 
+  if (!sym->value)
+    goto error;
+
   if (!gfc_numeric_ts (&sym->value->ts))
     {
       gfc_error ("Numeric PARAMETER required in complex constant at %C");
@@ -2078,7 +2081,8 @@
 
   if (primary->ts.type == BT_CHARACTER)
     {
-      switch (match_substring (primary->ts.u.cl, equiv_flag, &substring))
+      bool def = primary->ts.deferred == 1;
+      switch (match_substring (primary->ts.u.cl, equiv_flag, &substring, def))
 	{
 	case MATCH_YES:
 	  if (tail == NULL)
@@ -2642,7 +2646,7 @@
   gfc_expr *e;
   gfc_symtree *symtree;
 
-  gfc_get_sym_tree (sym->name, NULL, &symtree, false);   /* Can't fail */
+  gfc_get_ha_sym_tree (sym->name, &symtree);
 
   e = gfc_get_expr ();
   e->symtree = symtree;
@@ -3091,7 +3095,7 @@
 	     that we're not sure is a variable yet.  */
 
 	  if ((implicit_char || sym->ts.type == BT_CHARACTER)
-	      && match_substring (sym->ts.u.cl, 0, &e->ref) == MATCH_YES)
+	      && match_substring (sym->ts.u.cl, 0, &e->ref, false) == MATCH_YES)
 	    {
 
 	      e->expr_type = EXPR_VARIABLE;
diff -Naur gcc-5.2.0.orig/gcc/fortran/resolve.c gcc-5.2.0/gcc/fortran/resolve.c
--- gcc-5.2.0.orig/gcc/fortran/resolve.c	2015-06-24 04:16:13.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/resolve.c	2015-10-19 19:45:48.201991000 -0500
@@ -4554,8 +4554,7 @@
     {
       if (e->ts.u.cl->length)
 	gfc_free_expr (e->ts.u.cl->length);
-      else if (e->expr_type == EXPR_VARIABLE
-		 && e->symtree->n.sym->attr.dummy)
+      else if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym->attr.dummy)
 	return;
     }
 
@@ -4584,12 +4583,19 @@
       return;
     }
 
-  /* Length = (end - start +1).  */
+  /* Length = (end - start + 1).  */
   e->ts.u.cl->length = gfc_subtract (end, start);
   e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,
 				gfc_get_int_expr (gfc_default_integer_kind,
 						  NULL, 1));
 
+  /* F2008, 6.4.1:  Both the starting point and the ending point shall
+     be within the range 1, 2, ..., n unless the starting point exceeds
+     the ending point, in which case the substring has length zero.  */
+
+  if (mpz_cmp_si (e->ts.u.cl->length->value.integer, 0) < 0)
+    mpz_set_si (e->ts.u.cl->length->value.integer, 0);
+
   e->ts.u.cl->length->ts.type = BT_INTEGER;
   e->ts.u.cl->length->ts.kind = gfc_charlen_int_kind;
 
@@ -10230,15 +10236,22 @@
 	  }
 
 	case EXEC_ARITHMETIC_IF:
-	  if (t
-	      && code->expr1->ts.type != BT_INTEGER
-	      && code->expr1->ts.type != BT_REAL)
-	    gfc_error ("Arithmetic IF statement at %L requires a numeric "
-		       "expression", &code->expr1->where);
+	  {
+	    gfc_expr *e = code->expr1;
+
+	    gfc_resolve_expr (e);
+	    if (e->expr_type == EXPR_NULL)
+	      gfc_error ("Invalid NULL at %L", &e->where);
+
+	    if (t && (e->rank > 0
+		      || !(e->ts.type == BT_REAL || e->ts.type == BT_INTEGER)))
+	      gfc_error ("Arithmetic IF statement at %L requires a scalar "
+			 "REAL or INTEGER expression", &e->where);
 
-	  resolve_branch (code->label1, code);
-	  resolve_branch (code->label2, code);
-	  resolve_branch (code->label3, code);
+	    resolve_branch (code->label1, code);
+	    resolve_branch (code->label2, code);
+	    resolve_branch (code->label3, code);
+	  }
 	  break;
 
 	case EXEC_IF:
@@ -10548,7 +10561,7 @@
       sym->binding_label = NULL;
 
     }
-  else if (sym->attr.flavor == FL_VARIABLE
+  else if (sym->attr.flavor == FL_VARIABLE && module 
 	   && (strcmp (module, gsym->mod_name) != 0
 	       || strcmp (sym->name, gsym->sym_name) != 0))
     {
@@ -10636,18 +10649,11 @@
 	}
     }
 
-  /* "If the character length parameter value evaluates to a negative
-     value, the length of character entities declared is zero."  */
+  /* F2008, 4.4.3.2:  If the character length parameter value evaluates to
+     a negative value, the length of character entities declared is zero.  */
   if (cl->length && !gfc_extract_int (cl->length, &i) && i < 0)
-    {
-      if (warn_surprising)
-	gfc_warning_now (OPT_Wsurprising,
-			 "CHARACTER variable at %L has negative length %d,"
-			 " the length has been set to zero",
-			 &cl->length->where, i);
-      gfc_replace_expr (cl->length,
-			gfc_get_int_expr (gfc_default_integer_kind, NULL, 0));
-    }
+    gfc_replace_expr (cl->length,
+		      gfc_get_int_expr (gfc_default_integer_kind, NULL, 0));
 
   /* Check that the character length is not too large.  */
   k = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);
diff -Naur gcc-5.2.0.orig/gcc/fortran/simplify.c gcc-5.2.0/gcc/fortran/simplify.c
--- gcc-5.2.0.orig/gcc/fortran/simplify.c	2015-06-02 18:02:05.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/simplify.c	2015-07-16 14:22:38.836603000 -0500
@@ -2352,9 +2352,7 @@
   if (e->expr_type != EXPR_CONSTANT)
     return NULL;
 
-  gfc_set_model_kind (kind);
-
-  mpfr_init (floor);
+  mpfr_init2 (floor, mpfr_get_prec (e->value.real));
   mpfr_floor (floor, e->value.real);
 
   result = gfc_get_constant_expr (BT_INTEGER, kind, &e->where);
diff -Naur gcc-5.2.0.orig/gcc/fortran/trans-array.c gcc-5.2.0/gcc/fortran/trans-array.c
--- gcc-5.2.0.orig/gcc/fortran/trans-array.c	2015-03-24 05:28:48.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/trans-array.c	2015-10-18 10:01:03.189982000 -0500
@@ -7468,7 +7468,8 @@
 
 static tree
 duplicate_allocatable (tree dest, tree src, tree type, int rank,
-		       bool no_malloc, bool no_memcpy, tree str_sz)
+		       bool no_malloc, bool no_memcpy, tree str_sz,
+		       tree add_when_allocated)
 {
   tree tmp;
   tree size;
@@ -7548,6 +7549,7 @@
 	}
     }
 
+  gfc_add_expr_to_block (&block, add_when_allocated);
   tmp = gfc_finish_block (&block);
 
   /* Null the destination if the source is null; otherwise do
@@ -7567,10 +7569,11 @@
 /* Allocate dest to the same size as src, and copy data src -> dest.  */
 
 tree
-gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank)
+gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank,
+			   tree add_when_allocated)
 {
   return duplicate_allocatable (dest, src, type, rank, false, false,
-				NULL_TREE);
+				NULL_TREE, add_when_allocated);
 }
 
 
@@ -7580,7 +7583,7 @@
 gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank)
 {
   return duplicate_allocatable (dest, src, type, rank, true, false,
-				NULL_TREE);
+				NULL_TREE, NULL_TREE);
 }
 
 /* Allocate dest to the same size as src, but don't copy anything.  */
@@ -7588,7 +7591,8 @@
 tree
 gfc_duplicate_allocatable_nocopy (tree dest, tree src, tree type, int rank)
 {
-  return duplicate_allocatable (dest, src, type, rank, false, true, NULL_TREE);
+  return duplicate_allocatable (dest, src, type, rank, false, true,
+				NULL_TREE, NULL_TREE);
 }
 
 
@@ -7620,27 +7624,32 @@
   tree ctype;
   tree vref, dref;
   tree null_cond = NULL_TREE;
+  tree add_when_allocated;
   bool called_dealloc_with_status;
 
   gfc_init_block (&fnblock);
 
   decl_type = TREE_TYPE (decl);
 
-  if ((POINTER_TYPE_P (decl_type) && rank != 0)
+  if ((POINTER_TYPE_P (decl_type))
 	|| (TREE_CODE (decl_type) == REFERENCE_TYPE && rank == 0))
-    decl = build_fold_indirect_ref_loc (input_location, decl);
+    {
+      decl = build_fold_indirect_ref_loc (input_location, decl);
+      /* Deref dest in sync with decl, but only when it is not NULL.  */
+      if (dest)
+	dest = build_fold_indirect_ref_loc (input_location, dest);
+    }
 
-  /* Just in case in gets dereferenced.  */
+  /* Just in case it gets dereferenced.  */
   decl_type = TREE_TYPE (decl);
 
-  /* If this an array of derived types with allocatable components
+  /* If this is an array of derived types with allocatable components
      build a loop and recursively call this function.  */
   if (TREE_CODE (decl_type) == ARRAY_TYPE
       || (GFC_DESCRIPTOR_TYPE_P (decl_type) && rank != 0))
     {
       tmp = gfc_conv_array_data (decl);
-      var = build_fold_indirect_ref_loc (input_location,
-				     tmp);
+      var = build_fold_indirect_ref_loc (input_location, tmp);
 
       /* Get the number of elements - 1 and set the counter.  */
       if (GFC_DESCRIPTOR_TYPE_P (decl_type))
@@ -7661,7 +7670,7 @@
       else
 	{
 	  /*  Otherwise use the TYPE_DOMAIN information.  */
-	  tmp =  array_type_nelts (decl_type);
+	  tmp = array_type_nelts (decl_type);
 	  tmp = fold_convert (gfc_array_index_type, tmp);
 	}
 
@@ -7674,19 +7683,7 @@
 
       vref = gfc_build_array_ref (var, index, NULL);
 
-      if (purpose == COPY_ALLOC_COMP)
-        {
-	  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (dest)))
-	    {
-	      tmp = gfc_duplicate_allocatable (dest, decl, decl_type, rank);
-	      gfc_add_expr_to_block (&fnblock, tmp);
-	    }
-	  tmp = build_fold_indirect_ref_loc (input_location,
-					 gfc_conv_array_data (dest));
-	  dref = gfc_build_array_ref (tmp, index, NULL);
-	  tmp = structure_alloc_comps (der_type, vref, dref, rank, purpose);
-	}
-      else if (purpose == COPY_ONLY_ALLOC_COMP)
+      if (purpose == COPY_ALLOC_COMP || purpose == COPY_ONLY_ALLOC_COMP)
         {
 	  tmp = build_fold_indirect_ref_loc (input_location,
 					 gfc_conv_array_data (dest));
@@ -7709,7 +7706,17 @@
       gfc_add_block_to_block (&fnblock, &loop.pre);
 
       tmp = gfc_finish_block (&fnblock);
-      if (null_cond != NULL_TREE)
+      /* When copying allocateable components, the above implements the
+	 deep copy.  Nevertheless is a deep copy only allowed, when the current
+	 component is allocated, for which code will be generated in
+	 gfc_duplicate_allocatable (), where the deep copy code is just added
+	 into the if's body, by adding tmp (the deep copy code) as last
+	 argument to gfc_duplicate_allocatable ().  */
+      if (purpose == COPY_ALLOC_COMP
+	  && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (dest)))
+	tmp = gfc_duplicate_allocatable (dest, decl, decl_type, rank,
+					 tmp);
+      else if (null_cond != NULL_TREE)
 	tmp = build3_v (COND_EXPR, null_cond, tmp,
 			build_empty_stmt (input_location));
 
@@ -7994,6 +8001,22 @@
 	      continue;
 	    }
 
+	  /* To implement guarded deep copy, i.e., deep copy only allocatable
+	     components that are really allocated, the deep copy code has to
+	     be generated first and then added to the if-block in
+	     gfc_duplicate_allocatable ().  */
+	  if (cmp_has_alloc_comps)
+	    {
+	      rank = c->as ? c->as->rank : 0;
+	      tmp = fold_convert (TREE_TYPE (dcmp), comp);
+	      gfc_add_modify (&fnblock, dcmp, tmp);
+	      add_when_allocated = structure_alloc_comps (c->ts.u.derived,
+							  comp, dcmp,
+							  rank, purpose);
+	    }
+	  else
+	    add_when_allocated = NULL_TREE;
+
 	  if (gfc_deferred_strlen (c, &tmp))
 	    {
 	      tree len, size;
@@ -8008,30 +8031,29 @@
 				     TREE_TYPE (len), len, tmp);
 	      gfc_add_expr_to_block (&fnblock, tmp);
 	      size = size_of_string_in_bytes (c->ts.kind, len);
+	      /* This component can not have allocatable components,
+		 therefore add_when_allocated of duplicate_allocatable ()
+		 is always NULL.  */
 	      tmp = duplicate_allocatable (dcmp, comp, ctype, rank,
-					   false, false, size);
+					   false, false, size, NULL_TREE);
 	      gfc_add_expr_to_block (&fnblock, tmp);
 	    }
 	  else if (c->attr.allocatable && !c->attr.proc_pointer
-		   && !cmp_has_alloc_comps)
+		   && (!(cmp_has_alloc_comps && c->as)
+		       || c->attr.codimension))
 	    {
 	      rank = c->as ? c->as->rank : 0;
 	      if (c->attr.codimension)
 		tmp = gfc_copy_allocatable_data (dcmp, comp, ctype, rank);
 	      else
-		tmp = gfc_duplicate_allocatable (dcmp, comp, ctype, rank);
+		tmp = gfc_duplicate_allocatable (dcmp, comp, ctype, rank,
+						 add_when_allocated);
 	      gfc_add_expr_to_block (&fnblock, tmp);
 	    }
+	  else
+	    if (cmp_has_alloc_comps)
+	      gfc_add_expr_to_block (&fnblock, add_when_allocated);
 
-          if (cmp_has_alloc_comps)
-	    {
-	      rank = c->as ? c->as->rank : 0;
-	      tmp = fold_convert (TREE_TYPE (dcmp), comp);
-	      gfc_add_modify (&fnblock, dcmp, tmp);
-	      tmp = structure_alloc_comps (c->ts.u.derived, comp, dcmp,
-					   rank, purpose);
-	      gfc_add_expr_to_block (&fnblock, tmp);
-	    }
 	  break;
 
 	default:
@@ -8972,7 +8994,11 @@
     return NULL;
 
   /* Normal procedure case.  */
-  sym = procedure_ref->symtree->n.sym;
+  if (procedure_ref->expr_type == EXPR_FUNCTION
+      && procedure_ref->value.function.esym)
+    sym = procedure_ref->value.function.esym;
+  else
+    sym = procedure_ref->symtree->n.sym;
 
   /* Typebound procedure case.  */
   for (ref = procedure_ref->ref; ref; ref = ref->next)
diff -Naur gcc-5.2.0.orig/gcc/fortran/trans-array.h gcc-5.2.0/gcc/fortran/trans-array.h
--- gcc-5.2.0.orig/gcc/fortran/trans-array.h	2015-03-24 05:28:48.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/trans-array.h	2015-10-18 10:01:03.189982000 -0500
@@ -46,7 +46,7 @@
 
 tree gfc_full_array_size (stmtblock_t *, tree, int);
 
-tree gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank);
+tree gfc_duplicate_allocatable (tree, tree, tree, int, tree);
 
 tree gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank);
 
diff -Naur gcc-5.2.0.orig/gcc/fortran/trans-decl.c gcc-5.2.0/gcc/fortran/trans-decl.c
--- gcc-5.2.0.orig/gcc/fortran/trans-decl.c	2015-03-10 12:58:01.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/trans-decl.c	2015-10-29 14:52:56.305599000 -0500
@@ -5158,6 +5158,16 @@
 			  "Unused parameter %qs which has been explicitly "
 			  "imported at %L", sym->name, &sym->declared_at);
 	}
+
+      if (sym->ns
+	  && sym->ns->parent
+	  && sym->ns->parent->code
+	  && sym->ns->parent->code->op == EXEC_BLOCK)
+	{
+	  if (sym->attr.referenced)
+	    gfc_get_symbol_decl (sym);
+	  sym->mark = 1;
+	}
     }
   else if (sym->attr.flavor == FL_PROCEDURE)
     {
diff -Naur gcc-5.2.0.orig/gcc/fortran/trans-expr.c gcc-5.2.0/gcc/fortran/trans-expr.c
--- gcc-5.2.0.orig/gcc/fortran/trans-expr.c	2015-03-24 06:47:45.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/trans-expr.c	2015-10-26 12:25:03.496685000 -0500
@@ -5698,18 +5698,18 @@
   vec_safe_reserve (retargs, arglen);
 
   /* Add the return arguments.  */
-  retargs->splice (arglist);
+  vec_safe_splice (retargs, arglist);
 
   /* Add the hidden present status for optional+value to the arguments.  */
-  retargs->splice (optionalargs);
+  vec_safe_splice (retargs, optionalargs);
 
   /* Add the hidden string length parameters to the arguments.  */
-  retargs->splice (stringargs);
+  vec_safe_splice (retargs, stringargs);
 
   /* We may want to append extra arguments here.  This is used e.g. for
      calls to libgfortran_matmul_??, which need extra information.  */
-  if (!vec_safe_is_empty (append_args))
-    retargs->splice (append_args);
+  vec_safe_splice (retargs, append_args);
+
   arglist = retargs;
 
   /* Generate the actual call.  */
@@ -5739,6 +5739,20 @@
   fntype = TREE_TYPE (TREE_TYPE (se->expr));
   se->expr = build_call_vec (TREE_TYPE (fntype), se->expr, arglist);
 
+  /* Allocatable scalar function results must be freed and nullified
+     after use. This necessitates the creation of a temporary to
+     hold the result to prevent duplicate calls.  */
+  if (!byref && sym->ts.type != BT_CHARACTER
+      && sym->attr.allocatable && !sym->attr.dimension)
+    {
+      tmp = gfc_create_var (TREE_TYPE (se->expr), NULL);
+      gfc_add_modify (&se->pre, tmp, se->expr);
+      se->expr = tmp;
+      tmp = gfc_call_free (tmp);
+      gfc_add_expr_to_block (&post, tmp);
+      gfc_add_modify (&post, se->expr, build_int_cst (TREE_TYPE (se->expr), 0));
+    }
+
   /* If we have a pointer function, but we don't want a pointer, e.g.
      something like
         x = f()
@@ -6563,13 +6577,13 @@
 	{
 	  tmp = TREE_TYPE (dest);
 	  tmp = gfc_duplicate_allocatable (dest, se.expr,
-					   tmp, expr->rank);
+					   tmp, expr->rank, NULL_TREE);
 	}
     }
   else
     tmp = gfc_duplicate_allocatable (dest, se.expr,
 				     TREE_TYPE(cm->backend_decl),
-				     cm->as->rank);
+				     cm->as->rank, NULL_TREE);
 
   gfc_add_expr_to_block (&block, tmp);
   gfc_add_block_to_block (&block, &se.post);
@@ -6732,6 +6746,29 @@
 				       TREE_TYPE (tmp), tmp,
 				       fold_convert (TREE_TYPE (tmp), size));
     }
+  else if (cm->ts.type == BT_CLASS)
+    {
+      gcc_assert (expr2->ts.type == BT_CLASS || expr2->ts.type == BT_DERIVED);
+      if (expr2->ts.type == BT_DERIVED)
+	{
+	  tmp = gfc_get_symbol_decl (expr2->ts.u.derived);
+	  size = TYPE_SIZE_UNIT (tmp);
+	}
+      else
+	{
+	  gfc_expr *e2vtab;
+	  gfc_se se;
+	  e2vtab = gfc_find_and_cut_at_last_class_ref (expr2);
+	  gfc_add_vptr_component (e2vtab);
+	  gfc_add_size_component (e2vtab);
+	  gfc_init_se (&se, NULL);
+	  gfc_conv_expr (&se, e2vtab);
+	  gfc_add_block_to_block (block, &se.pre);
+	  size = fold_convert (size_type_node, se.expr);
+	  gfc_free_expr (e2vtab);
+	}
+      size_in_bytes = size;
+    }
   else
     {
       /* Otherwise use the length in bytes of the rhs.  */
@@ -6859,7 +6896,8 @@
       gfc_add_expr_to_block (&block, tmp);
     }
   else if (init && (cm->attr.allocatable
-	   || (cm->ts.type == BT_CLASS && CLASS_DATA (cm)->attr.allocatable)))
+	   || (cm->ts.type == BT_CLASS && CLASS_DATA (cm)->attr.allocatable
+	       && expr->ts.type != BT_CLASS)))
     {
       /* Take care about non-array allocatable components here.  The alloc_*
 	 routine below is motivated by the alloc_scalar_allocatable_for_
@@ -8634,6 +8672,7 @@
   tree jump_label1;
   tree jump_label2;
   gfc_se lse;
+  gfc_ref *ref;
 
   if (!expr1 || expr1->rank)
     return;
@@ -8641,6 +8680,10 @@
   if (!expr2 || expr2->rank)
     return;
 
+  for (ref = expr1->ref; ref; ref = ref->next)
+    if (ref->type == REF_SUBSTRING)
+      return;
+
   realloc_lhs_warning (expr2->ts.type, false, &expr2->where);
 
   /* Since this is a scalar lhs, we can afford to do this.  That is,
@@ -8975,7 +9018,6 @@
   scalar_to_array = (expr2->ts.type == BT_DERIVED
 		       && expr2->ts.u.derived->attr.alloc_comp
 		       && !expr_is_variable (expr2)
-		       && !gfc_is_constant_expr (expr2)
 		       && expr1->rank && !expr2->rank);
   scalar_to_array |= (expr1->ts.type == BT_DERIVED
 				    && expr1->rank
@@ -8984,7 +9026,7 @@
   if (scalar_to_array && dealloc)
     {
       tmp = gfc_deallocate_alloc_comp_no_caf (expr2->ts.u.derived, rse.expr, 0);
-      gfc_add_expr_to_block (&loop.post, tmp);
+      gfc_prepend_expr_to_block (&loop.post, tmp);
     }
 
   /* When assigning a character function result to a deferred-length variable,
diff -Naur gcc-5.2.0.orig/gcc/fortran/trans-intrinsic.c gcc-5.2.0/gcc/fortran/trans-intrinsic.c
--- gcc-5.2.0.orig/gcc/fortran/trans-intrinsic.c	2015-03-24 05:28:48.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/trans-intrinsic.c	2015-10-26 12:25:03.496685000 -0500
@@ -8801,7 +8801,7 @@
 	}
       opr_flags = build_int_cst (integer_type_node, opr_flag_int);
       gfc_conv_expr (&argse, opr_expr);
-      opr = gfc_build_addr_expr (NULL_TREE, argse.expr);
+      opr = argse.expr;
       fndecl = build_call_expr_loc (input_location, fndecl, 8, array, opr, opr_flags,
 				    image_index, stat, errmsg, strlen, errmsg_len);
     }
@@ -9360,6 +9360,16 @@
 	    }
 	}
 
+      if (to_expr->ts.type == BT_CHARACTER && to_expr->ts.deferred)
+	{
+	  gfc_add_modify_loc (input_location, &block, to_se.string_length,
+			      fold_convert (TREE_TYPE (to_se.string_length),
+					    from_se.string_length));
+	  if (from_expr->ts.deferred)
+	    gfc_add_modify_loc (input_location, &block, from_se.string_length,
+			build_int_cst (TREE_TYPE (from_se.string_length), 0));
+	}
+
       return gfc_finish_block (&block);
     }
 
@@ -9459,6 +9469,14 @@
     }
   else
     {
+      if (to_expr->ts.type == BT_DERIVED
+	  && to_expr->ts.u.derived->attr.alloc_comp)
+	{
+	  tmp = gfc_deallocate_alloc_comp (to_expr->ts.u.derived,
+					   to_se.expr, to_expr->rank);
+	  gfc_add_expr_to_block (&block, tmp);
+	}
+
       tmp = gfc_conv_descriptor_data_get (to_se.expr);
       tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE, NULL_TREE,
 					NULL_TREE, true, to_expr, false);
@@ -9473,6 +9491,17 @@
   gfc_add_modify_loc (input_location, &block, tmp,
 		      fold_convert (TREE_TYPE (tmp), null_pointer_node));
 
+
+  if (to_expr->ts.type == BT_CHARACTER && to_expr->ts.deferred)
+    {
+      gfc_add_modify_loc (input_location, &block, to_se.string_length,
+			  fold_convert (TREE_TYPE (to_se.string_length),
+					from_se.string_length));
+      if (from_expr->ts.deferred)
+        gfc_add_modify_loc (input_location, &block, from_se.string_length,
+			build_int_cst (TREE_TYPE (from_se.string_length), 0));
+    }
+
   return gfc_finish_block (&block);
 }
 
diff -Naur gcc-5.2.0.orig/gcc/fortran/trans-openmp.c gcc-5.2.0/gcc/fortran/trans-openmp.c
--- gcc-5.2.0.orig/gcc/fortran/trans-openmp.c	2015-05-22 03:10:32.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/trans-openmp.c	2015-10-18 10:01:03.189982000 -0500
@@ -391,9 +391,11 @@
 	  if (GFC_DESCRIPTOR_TYPE_P (ftype)
 	      && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)
 	    tem = gfc_duplicate_allocatable (destf, declf, ftype,
-					     GFC_TYPE_ARRAY_RANK (ftype));
+					     GFC_TYPE_ARRAY_RANK (ftype),
+					     NULL_TREE);
 	  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))
-	    tem = gfc_duplicate_allocatable (destf, declf, ftype, 0);
+	    tem = gfc_duplicate_allocatable (destf, declf, ftype, 0,
+					     NULL_TREE);
 	  break;
 	}
       if (tem)
diff -Naur gcc-5.2.0.orig/gcc/fortran/trans-stmt.c gcc-5.2.0/gcc/fortran/trans-stmt.c
--- gcc-5.2.0.orig/gcc/fortran/trans-stmt.c	2015-04-10 07:03:35.000000000 -0500
+++ gcc-5.2.0/gcc/fortran/trans-stmt.c	2015-10-22 13:05:21.540564000 -0500
@@ -5210,6 +5210,17 @@
 		 here, fix it for future use.  */
 	      if (se.string_length)
 		expr3_len = gfc_evaluate_now (se.string_length, &block);
+
+	      /* Deallocate any allocatable components after all the allocations
+		 and assignments of expr3 have been completed.  */
+	      if (expr3 && code->expr3->ts.type == BT_DERIVED
+		  && code->expr3->rank == 0
+		  && code->expr3->ts.u.derived->attr.alloc_comp)
+		{
+		  tmp = gfc_deallocate_alloc_comp (code->expr3->ts.u.derived,
+						   expr3, 0);
+		  gfc_add_expr_to_block (&post, tmp);
+		}
 	    }
 	}
 
@@ -5618,7 +5629,8 @@
 	      tmp = gfc_copy_class_to_class (expr3, to,
 					     nelems, upoly_expr);
 	    }
-	  else if (code->expr3->ts.type == BT_CHARACTER)
+	  else if (code->expr3->ts.type == BT_CHARACTER
+		   && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)))
 	    {
 	      tmp = INDIRECT_REF_P (se.expr) ?
 			se.expr :
diff -Naur gcc-5.2.0.orig/gcc/function.c gcc-5.2.0/gcc/function.c
--- gcc-5.2.0.orig/gcc/function.c	2015-01-15 07:28:42.000000000 -0600
+++ gcc-5.2.0/gcc/function.c	2015-07-23 05:44:19.212145000 -0500
@@ -3500,9 +3500,11 @@
 
 static void
 assign_bounds (vec<bounds_parm_data> &bndargs,
-	       struct assign_parm_data_all &all)
+	       struct assign_parm_data_all &all,
+	       bool assign_regs, bool assign_special,
+	       bool assign_bt)
 {
-  unsigned i, pass, handled = 0;
+  unsigned i, pass;
   bounds_parm_data *pbdata;
 
   if (!bndargs.exists ())
@@ -3516,17 +3518,20 @@
       {
 	/* Pass 0 => regs only.  */
 	if (pass == 0
-	    && (!pbdata->parm_data.entry_parm
-		|| GET_CODE (pbdata->parm_data.entry_parm) != REG))
+	    && (!assign_regs
+		||(!pbdata->parm_data.entry_parm
+		   || GET_CODE (pbdata->parm_data.entry_parm) != REG)))
 	  continue;
 	/* Pass 1 => slots only.  */
 	else if (pass == 1
-		 && (!pbdata->parm_data.entry_parm
-		     || GET_CODE (pbdata->parm_data.entry_parm) == REG))
+		 && (!assign_special
+		     || (!pbdata->parm_data.entry_parm
+			 || GET_CODE (pbdata->parm_data.entry_parm) == REG)))
 	  continue;
 	/* Pass 2 => BT only.  */
 	else if (pass == 2
-		 && pbdata->parm_data.entry_parm)
+		 && (!assign_bt
+		     || pbdata->parm_data.entry_parm))
 	  continue;
 
 	if (!pbdata->parm_data.entry_parm
@@ -3547,14 +3552,7 @@
 	else
 	  assign_parm_setup_stack (&all, pbdata->bounds_parm,
 				   &pbdata->parm_data);
-
-	/* Count handled bounds to make sure we miss nothing.  */
-	handled++;
       }
-
-  gcc_assert (handled == bndargs.length ());
-
-  bndargs.release ();
 }
 
 /* Assign RTL expressions to the function's parameters.  This may involve
@@ -3679,12 +3677,14 @@
 	      /* We expect this is the last parm.  Otherwise it is wrong
 		 to assign bounds right now.  */
 	      gcc_assert (i == (fnargs.length () - 1));
-	      assign_bounds (bndargs, all);
+	      assign_bounds (bndargs, all, true, false, false);
 	      targetm.calls.setup_incoming_vararg_bounds (all.args_so_far,
 							  data.promoted_mode,
 							  data.passed_type,
 							  &pretend_bytes,
 							  false);
+	      assign_bounds (bndargs, all, false, true, true);
+	      bndargs.release ();
 	    }
 	}
 
@@ -3696,7 +3696,8 @@
 	bound_no++;
     }
 
-  assign_bounds (bndargs, all);
+  assign_bounds (bndargs, all, true, true, true);
+  bndargs.release ();
 
   if (targetm.calls.split_complex_arg)
     assign_parms_unsplit_complex (&all, fnargs);
@@ -5193,8 +5194,8 @@
 void
 diddle_return_value (void (*doit) (rtx, void *), void *arg)
 {
-  diddle_return_value_1 (doit, arg, crtl->return_rtx);
   diddle_return_value_1 (doit, arg, crtl->return_bnd);
+  diddle_return_value_1 (doit, arg, crtl->return_rtx);
 }
 
 static void
diff -Naur gcc-5.2.0.orig/gcc/genmatch.c gcc-5.2.0/gcc/genmatch.c
--- gcc-5.2.0.orig/gcc/genmatch.c	2015-03-25 03:46:20.000000000 -0500
+++ gcc-5.2.0/gcc/genmatch.c	2015-07-21 09:04:12.057212000 -0500
@@ -1515,16 +1515,25 @@
 {
   if (capture *c = dyn_cast <capture *> (o))
     {
-      info[c->where].toplevel_msk |= 1 << toplevel_arg;
-      info[c->where].force_no_side_effects_p |= conditional_p;
-      info[c->where].cond_expr_cond_p |= cond_expr_cond_p;
-      /* Mark expr (non-leaf) captures and recurse.  */
+      unsigned where = c->where;
+      info[where].toplevel_msk |= 1 << toplevel_arg;
+      info[where].force_no_side_effects_p |= conditional_p;
+      info[where].cond_expr_cond_p |= cond_expr_cond_p;
+      if (!c->what)
+	return;
+      /* Recurse to exprs and captures.  */
+      if (is_a <capture *> (c->what)
+	  || is_a <expr *> (c->what))
+	walk_match (c->what, toplevel_arg, conditional_p, false);
+      /* We need to look past multiple captures to find a captured
+	 expression as with conditional converts two captures
+	 can be collapsed onto the same expression.  */
+      while (c->what && is_a <capture *> (c->what))
+	c = as_a <capture *> (c->what);
+      /* Mark expr (non-leaf) captures.  */
       if (c->what
 	  && is_a <expr *> (c->what))
-	{
-	  info[c->where].expr_p = true;
-	  walk_match (c->what, toplevel_arg, conditional_p, false);
-	}
+	info[where].expr_p = true;
     }
   else if (expr *e = dyn_cast <expr *> (o))
     {
diff -Naur gcc-5.2.0.orig/gcc/gimple-fold.c gcc-5.2.0/gcc/gimple-fold.c
--- gcc-5.2.0.orig/gcc/gimple-fold.c	2015-06-02 04:17:49.000000000 -0500
+++ gcc-5.2.0/gcc/gimple-fold.c	2015-10-06 05:19:54.537907000 -0500
@@ -693,7 +693,7 @@
 	      unlink_stmt_vdef (stmt);
 	      release_defs (stmt);
 	    }
-	  gsi_replace (si_p, gimple_build_nop (), true);
+	  gsi_replace (si_p, gimple_build_nop (), false);
 	  return;
 	}
     }
@@ -734,7 +734,7 @@
       unlink_stmt_vdef (stmt);
       release_ssa_name (vdef);
     }
-  gsi_replace (gsi, repl, true);
+  gsi_replace (gsi, repl, false);
 }
 
 /* Replace the call at *GSI with the new call REPL and fold that
@@ -753,7 +753,7 @@
       gimple_set_vuse (repl, gimple_vuse (stmt));
       SSA_NAME_DEF_STMT (gimple_vdef (repl)) = repl;
     }
-  gsi_replace (gsi, repl, true);
+  gsi_replace (gsi, repl, false);
   fold_stmt (gsi);
 }
 
@@ -800,7 +800,7 @@
 	  unlink_stmt_vdef (stmt);
 	  release_ssa_name (vdef);
 	}
-      gsi_replace (gsi, repl, true);
+      gsi_replace (gsi, repl, false);
       return true;
     }
 
@@ -813,7 +813,7 @@
 	release_ssa_name (gimple_vdef (stmt));
       if (!lhs)
 	{
-	  gsi_replace (gsi, gimple_build_nop (), true);
+	  gsi_replace (gsi, gimple_build_nop (), false);
 	  return true;
 	}
       goto done;
@@ -895,7 +895,7 @@
 			SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;
 		      if (!lhs)
 			{
-			  gsi_replace (gsi, new_stmt, true);
+			  gsi_replace (gsi, new_stmt, false);
 			  return true;
 			}
 		      gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);
@@ -1175,7 +1175,7 @@
 	SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;
       if (!lhs)
 	{
-	  gsi_replace (gsi, new_stmt, true);
+	  gsi_replace (gsi, new_stmt, false);
 	  return true;
 	}
       gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);
@@ -1193,7 +1193,7 @@
   dest = force_gimple_operand_gsi (gsi, dest, false, NULL_TREE, true,
 				   GSI_SAME_STMT);
   gimple repl = gimple_build_assign (lhs, dest);
-  gsi_replace (gsi, repl, true);
+  gsi_replace (gsi, repl, false);
   return true;
 }
 
@@ -1275,7 +1275,7 @@
   if (gimple_call_lhs (stmt))
     {
       gimple asgn = gimple_build_assign (gimple_call_lhs (stmt), dest);
-      gsi_replace (gsi, asgn, true);
+      gsi_replace (gsi, asgn, false);
     }
   else
     {
@@ -2125,7 +2125,7 @@
   gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);
   gassign *ret = gimple_build_assign (gimple_call_lhs (stmt),
 				      POINTER_PLUS_EXPR, dest, tem);
-  gsi_replace (gsi, ret, true);
+  gsi_replace (gsi, ret, false);
   /* Finally fold the memcpy call.  */
   gimple_stmt_iterator gsi2 = *gsi;
   gsi_prev (&gsi2);
@@ -3207,7 +3207,7 @@
 		  && tree_int_cst_le (gimple_call_arg (stmt, 1),
 				      gimple_call_arg (stmt, 2))))
 	    {
-	      gsi_replace (gsi, gimple_build_nop (), true);
+	      gsi_replace (gsi, gimple_build_nop (), false);
 	      unlink_stmt_vdef (stmt);
 	      release_defs (stmt);
 	      return true;
diff -Naur gcc-5.2.0.orig/gcc/gimple-low.c gcc-5.2.0/gcc/gimple-low.c
--- gcc-5.2.0.orig/gcc/gimple-low.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/gimple-low.c	2015-09-17 07:50:54.117834000 -0500
@@ -361,7 +361,8 @@
 		return;
 	      }
 	    else if (DECL_FUNCTION_CODE (decl) == BUILT_IN_POSIX_MEMALIGN
-		     && flag_tree_bit_ccp)
+		     && flag_tree_bit_ccp
+		     && gimple_builtin_call_types_compatible_p (stmt, decl))
 	      {
 		lower_builtin_posix_memalign (gsi);
 		return;
diff -Naur gcc-5.2.0.orig/gcc/gimple-ssa-isolate-paths.c gcc-5.2.0/gcc/gimple-ssa-isolate-paths.c
--- gcc-5.2.0.orig/gcc/gimple-ssa-isolate-paths.c	2015-07-10 07:33:28.000000000 -0500
+++ gcc-5.2.0/gcc/gimple-ssa-isolate-paths.c	2015-09-21 04:55:57.657387000 -0500
@@ -125,7 +125,14 @@
   if (walk_stmt_load_store_ops (stmt, (void *)op,
 			        check_loadstore,
 				check_loadstore))
-    gsi_insert_after (si_p, seq, GSI_NEW_STMT);
+    {
+      gsi_insert_after (si_p, seq, GSI_NEW_STMT);
+      if (stmt_ends_bb_p (stmt))
+	{
+	  split_block (gimple_bb (stmt), stmt);
+	  return;
+	}
+    }
   else
     gsi_insert_before (si_p, seq, GSI_NEW_STMT);
 
diff -Naur gcc-5.2.0.orig/gcc/gimplify.c gcc-5.2.0/gcc/gimplify.c
--- gcc-5.2.0.orig/gcc/gimplify.c	2015-07-10 09:14:18.000000000 -0500
+++ gcc-5.2.0/gcc/gimplify.c	2015-09-10 02:41:34.430878000 -0500
@@ -6195,9 +6195,12 @@
 		    }
 		  else
 		    break;
-		  gcc_checking_assert (splay_tree_lookup (octx->variables,
-							  (splay_tree_key)
-							  decl) == NULL);
+		  if (splay_tree_lookup (octx->variables,
+					 (splay_tree_key) decl) != NULL)
+		    {
+		      octx = NULL;
+		      break;
+		    }
 		  flags = GOVD_SEEN;
 		  if (!OMP_CLAUSE_LINEAR_NO_COPYIN (c))
 		    flags |= GOVD_FIRSTPRIVATE;
@@ -6979,7 +6982,7 @@
 static enum gimplify_status
 gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 {
-  tree for_stmt, orig_for_stmt, decl, var, t;
+  tree for_stmt, orig_for_stmt, inner_for_stmt = NULL_TREE, decl, var, t;
   enum gimplify_status ret = GS_ALL_DONE;
   enum gimplify_status tret;
   gomp_for *gfor;
@@ -7022,6 +7025,19 @@
 	  }
     }
 
+  if (OMP_FOR_INIT (for_stmt) == NULL_TREE)
+    {
+      gcc_assert (TREE_CODE (for_stmt) != OACC_LOOP);
+      inner_for_stmt = walk_tree (&OMP_FOR_BODY (for_stmt),
+				  find_combined_omp_for, NULL, NULL);
+      if (inner_for_stmt == NULL_TREE)
+	{
+	  gcc_assert (seen_error ());
+	  *expr_p = NULL_TREE;
+	  return GS_ERROR;
+	}
+    }
+
   gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p,
 			     simd ? ORT_SIMD : ORT_WORKSHARE);
   if (TREE_CODE (for_stmt) == OMP_DISTRIBUTE)
@@ -7057,10 +7073,7 @@
 
   if (OMP_FOR_INIT (for_stmt) == NULL_TREE)
     {
-      gcc_assert (TREE_CODE (for_stmt) != OACC_LOOP);
-      for_stmt = walk_tree (&OMP_FOR_BODY (for_stmt), find_combined_omp_for,
-			    NULL, NULL);
-      gcc_assert (for_stmt != NULL_TREE);
+      for_stmt = inner_for_stmt;
       gimplify_omp_ctxp->combined_loop = true;
     }
 
@@ -7104,13 +7117,27 @@
 		  OMP_CLAUSE_LINEAR_NO_COPYOUT (c) = 1;
 		  flags |= GOVD_LINEAR_LASTPRIVATE_NO_OUTER;
 		}
+	      struct gimplify_omp_ctx *outer
+		= gimplify_omp_ctxp->outer_context;
+	      if (outer && !OMP_CLAUSE_LINEAR_NO_COPYOUT (c))
+		{
+		  if (outer->region_type == ORT_WORKSHARE
+		      && outer->combined_loop)
+		    {
+		      n = splay_tree_lookup (outer->variables,
+					     (splay_tree_key)decl);
+		      if (n != NULL && (n->value & GOVD_LOCAL) != 0)
+			{
+			  OMP_CLAUSE_LINEAR_NO_COPYOUT (c) = 1;
+			  flags |= GOVD_LINEAR_LASTPRIVATE_NO_OUTER;
+			}
+		    }
+		}
+
 	      OMP_CLAUSE_DECL (c) = decl;
 	      OMP_CLAUSE_CHAIN (c) = OMP_FOR_CLAUSES (for_stmt);
 	      OMP_FOR_CLAUSES (for_stmt) = c;
-	      
 	      omp_add_variable (gimplify_omp_ctxp, decl, flags);
-	      struct gimplify_omp_ctx *outer
-		= gimplify_omp_ctxp->outer_context;
 	      if (outer && !OMP_CLAUSE_LINEAR_NO_COPYOUT (c))
 		{
 		  if (outer->region_type == ORT_WORKSHARE
@@ -7127,10 +7154,16 @@
 		    outer = NULL;
 		  if (outer)
 		    {
-		      omp_add_variable (outer, decl,
-					GOVD_LASTPRIVATE | GOVD_SEEN);
-		      if (outer->outer_context)
-			omp_notice_variable (outer->outer_context, decl, true);
+		      n = splay_tree_lookup (outer->variables,
+					     (splay_tree_key)decl);
+		      if (n == NULL || (n->value & GOVD_DATA_SHARE_CLASS) == 0)
+			{
+			  omp_add_variable (outer, decl,
+					    GOVD_LASTPRIVATE | GOVD_SEEN);
+			  if (outer->outer_context)
+			    omp_notice_variable (outer->outer_context, decl,
+						 true);
+			}
 		    }
 		}
 	    }
@@ -7147,9 +7180,16 @@
 		  if (outer->region_type == ORT_WORKSHARE
 		      && outer->combined_loop)
 		    {
-		      if (outer->outer_context
-			  && (outer->outer_context->region_type
-			      == ORT_COMBINED_PARALLEL))
+		      n = splay_tree_lookup (outer->variables,
+					     (splay_tree_key)decl);
+		      if (n != NULL && (n->value & GOVD_LOCAL) != 0)
+			{
+			  lastprivate = false;
+			  outer = NULL;
+			}
+		      else if (outer->outer_context
+			       && (outer->outer_context->region_type
+				   == ORT_COMBINED_PARALLEL))
 			outer = outer->outer_context;
 		      else if (omp_check_private (outer, decl, false))
 			outer = NULL;
@@ -7158,10 +7198,16 @@
 		    outer = NULL;
 		  if (outer)
 		    {
-		      omp_add_variable (outer, decl,
-					GOVD_LASTPRIVATE | GOVD_SEEN);
-		      if (outer->outer_context)
-			omp_notice_variable (outer->outer_context, decl, true);
+		      n = splay_tree_lookup (outer->variables,
+					     (splay_tree_key)decl);
+		      if (n == NULL || (n->value & GOVD_DATA_SHARE_CLASS) == 0)
+			{
+			  omp_add_variable (outer, decl,
+					    GOVD_LASTPRIVATE | GOVD_SEEN);
+			  if (outer->outer_context)
+			    omp_notice_variable (outer->outer_context, decl,
+						 true);
+			}
 		    }
 		}
 
diff -Naur gcc-5.2.0.orig/gcc/graphite-blocking.c gcc-5.2.0/gcc/graphite-blocking.c
--- gcc-5.2.0.orig/gcc/graphite-blocking.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-blocking.c	2015-10-12 05:59:21.185205000 -0500
@@ -24,6 +24,7 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
diff -Naur gcc-5.2.0.orig/gcc/graphite.c gcc-5.2.0/gcc/graphite.c
--- gcc-5.2.0.orig/gcc/graphite.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite.c	2015-10-12 05:59:21.185205000 -0500
@@ -35,6 +35,7 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/options.h>
diff -Naur gcc-5.2.0.orig/gcc/graphite-dependences.c gcc-5.2.0/gcc/graphite-dependences.c
--- gcc-5.2.0.orig/gcc/graphite-dependences.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-dependences.c	2015-10-12 05:59:21.185205000 -0500
@@ -22,6 +22,7 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
@@ -227,7 +228,7 @@
 /* Helper function used on each MAP of a isl_union_map.  Computes the
    maximal output dimension.  */
 
-static int
+static isl_stat
 max_number_of_out_dimensions (__isl_take isl_map *map, void *user)
 {
   int global_max = *((int *) user);
@@ -239,7 +240,7 @@
 
   isl_map_free (map);
   isl_space_free (space);
-  return 0;
+  return isl_stat_ok;
 }
 
 /* Extends the output dimension of MAP to MAX dimensions.  */
@@ -263,12 +264,12 @@
 
 /* Helper function for extend_schedule.  */
 
-static int
+static isl_stat
 extend_schedule_1 (__isl_take isl_map *map, void *user)
 {
   struct extend_schedule_str *str = (struct extend_schedule_str *) user;
   str->umap = isl_union_map_add_map (str->umap, extend_map (map, str->max));
-  return 0;
+  return isl_stat_ok;
 }
 
 /* Return a relation that has uniform output dimensions.  */
@@ -277,16 +278,16 @@
 extend_schedule (__isl_take isl_union_map *x)
 {
   int max = 0;
-  int res;
+  isl_stat res;
   struct extend_schedule_str str;
 
   res = isl_union_map_foreach_map (x, max_number_of_out_dimensions, (void *) &max);
-  gcc_assert (res == 0);
+  gcc_assert (res == isl_stat_ok);
 
   str.max = max;
   str.umap = isl_union_map_empty (isl_union_map_get_space (x));
   res = isl_union_map_foreach_map (x, extend_schedule_1, (void *) &str);
-  gcc_assert (res == 0);
+  gcc_assert (res == isl_stat_ok);
 
   isl_union_map_free (x);
   return str.umap;
diff -Naur gcc-5.2.0.orig/gcc/graphite-interchange.c gcc-5.2.0/gcc/graphite-interchange.c
--- gcc-5.2.0.orig/gcc/graphite-interchange.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-interchange.c	2015-10-12 05:59:21.185205000 -0500
@@ -24,6 +24,7 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/aff.h>
 #include <isl/set.h>
 #include <isl/map.h>
diff -Naur gcc-5.2.0.orig/gcc/graphite-isl-ast-to-gimple.c gcc-5.2.0/gcc/graphite-isl-ast-to-gimple.c
--- gcc-5.2.0.orig/gcc/graphite-isl-ast-to-gimple.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-isl-ast-to-gimple.c	2015-10-12 05:59:21.185205000 -0500
@@ -21,7 +21,9 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/set.h>
+#include <isl/union_set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
 #include <isl/ast_build.h>
diff -Naur gcc-5.2.0.orig/gcc/graphite-optimize-isl.c gcc-5.2.0/gcc/graphite-optimize-isl.c
--- gcc-5.2.0.orig/gcc/graphite-optimize-isl.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-optimize-isl.c	2015-10-12 05:59:21.185205000 -0500
@@ -21,7 +21,9 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/set.h>
+#include <isl/union_set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
 #include <isl/schedule.h>
@@ -530,13 +532,13 @@
   return ScheduleMap;
 }
 
-static int
+static isl_stat
 getSingleMap (__isl_take isl_map *map, void *user)
 {
   isl_map **singleMap = (isl_map **) user;
   *singleMap = map;
 
-  return 0;
+  return isl_stat_ok;
 }
 
 static void
@@ -608,7 +610,11 @@
 
   isl_options_set_schedule_max_constant_term (scop->ctx, CONSTANT_BOUND);
   isl_options_set_schedule_maximize_band_depth (scop->ctx, 1);
+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
+  isl_options_set_schedule_serialize_sccs (scop->ctx, 1);
+#else
   isl_options_set_schedule_fuse (scop->ctx, ISL_SCHEDULE_FUSE_MIN);
+#endif
   isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_CONTINUE);
 
 #ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
diff -Naur gcc-5.2.0.orig/gcc/graphite-poly.c gcc-5.2.0/gcc/graphite-poly.c
--- gcc-5.2.0.orig/gcc/graphite-poly.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-poly.c	2015-10-12 05:59:21.185205000 -0500
@@ -22,6 +22,7 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
diff -Naur gcc-5.2.0.orig/gcc/graphite-poly.h gcc-5.2.0/gcc/graphite-poly.h
--- gcc-5.2.0.orig/gcc/graphite-poly.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-poly.h	2015-10-12 05:59:21.185205000 -0500
@@ -22,6 +22,11 @@
 #ifndef GCC_GRAPHITE_POLY_H
 #define GCC_GRAPHITE_POLY_H
 
+#ifndef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
+# define isl_stat int
+# define isl_stat_ok 0
+#endif
+
 typedef struct poly_dr *poly_dr_p;
 
 typedef struct poly_bb *poly_bb_p;
diff -Naur gcc-5.2.0.orig/gcc/graphite-scop-detection.c gcc-5.2.0/gcc/graphite-scop-detection.c
--- gcc-5.2.0.orig/gcc/graphite-scop-detection.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-scop-detection.c	2015-10-12 05:59:21.185205000 -0500
@@ -22,6 +22,7 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
diff -Naur gcc-5.2.0.orig/gcc/graphite-sese-to-poly.c gcc-5.2.0/gcc/graphite-sese-to-poly.c
--- gcc-5.2.0.orig/gcc/graphite-sese-to-poly.c	2015-01-15 07:28:42.000000000 -0600
+++ gcc-5.2.0/gcc/graphite-sese-to-poly.c	2015-10-12 05:59:21.185205000 -0500
@@ -21,6 +21,7 @@
 #include "config.h"
 
 #ifdef HAVE_isl
+#include <isl/constraint.h>
 #include <isl/set.h>
 #include <isl/map.h>
 #include <isl/union_map.h>
@@ -2634,9 +2635,17 @@
   gcc_assert (is_gimple_assign (stmt));
   code = gimple_assign_rhs_code (stmt);
 
-  return flag_associative_math
-    && commutative_tree_code (code)
-    && associative_tree_code (code);
+  if (!commutative_tree_code (code)
+      || !associative_tree_code (code))
+    return false;
+
+  tree type = TREE_TYPE (gimple_assign_lhs (stmt));
+
+  if (FLOAT_TYPE_P (type))
+    return flag_associative_math;
+
+  return (INTEGRAL_TYPE_P (type)
+	  && TYPE_OVERFLOW_WRAPS (type));
 }
 
 /* Returns true when PHI contains an argument ARG.  */
diff -Naur gcc-5.2.0.orig/gcc/ipa-chkp.c gcc-5.2.0/gcc/ipa-chkp.c
--- gcc-5.2.0.orig/gcc/ipa-chkp.c	2015-05-21 04:47:32.000000000 -0500
+++ gcc-5.2.0/gcc/ipa-chkp.c	2015-07-23 05:34:48.781735000 -0500
@@ -104,7 +104,7 @@
 
 /* Return 1 calls to FNDECL should be replaced with
    a call to wrapper function.  */
-static bool
+bool
 chkp_wrap_function (tree fndecl)
 {
   if (!flag_chkp_use_wrappers)
@@ -139,6 +139,51 @@
   return false;
 }
 
+static const char *
+chkp_wrap_function_name (tree fndecl)
+{
+  gcc_assert (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL);
+
+  switch (DECL_FUNCTION_CODE (fndecl))
+    {
+    case BUILT_IN_STRLEN:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "strlen";
+    case BUILT_IN_STRCPY:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "strcpy";
+    case BUILT_IN_STRNCPY:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "strncpy";
+    case BUILT_IN_STPCPY:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "stpcpy";
+    case BUILT_IN_STPNCPY:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "stpncpy";
+    case BUILT_IN_STRCAT:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "strcat";
+    case BUILT_IN_STRNCAT:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "strncat";
+    case BUILT_IN_MEMCPY:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "memcpy";
+    case BUILT_IN_MEMPCPY:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "mempcpy";
+    case BUILT_IN_MEMSET:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "memset";
+    case BUILT_IN_MEMMOVE:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "memmove";
+    case BUILT_IN_BZERO:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "bzero";
+    case BUILT_IN_MALLOC:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "malloc";
+    case BUILT_IN_CALLOC:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "calloc";
+    case BUILT_IN_REALLOC:
+      return CHKP_WRAPPER_SYMBOL_PREFIX "realloc";
+
+    default:
+      gcc_unreachable ();
+    }
+
+  return "";
+}
+
 /* Build a clone of FNDECL with a modified name.  */
 
 static tree
@@ -164,9 +209,8 @@
      instrumented version.  */
   if (chkp_wrap_function(fndecl))
     {
-      s = CHKP_WRAPPER_SYMBOL_PREFIX;
-      s += IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));
-      new_name = get_identifier (s.c_str ());
+      new_name = get_identifier (chkp_wrap_function_name (fndecl));
+      DECL_VISIBILITY (new_decl) = VISIBILITY_DEFAULT;
     }
   else
     {
@@ -541,25 +585,10 @@
 
       if (gimple_has_body_p (fndecl))
 	{
-	  /* If function will not be instrumented, then it's instrumented
-	     version is a thunk for the original.  */
-	  if (!chkp_instrumentable_p (fndecl))
-	    {
-	      clone->remove_callees ();
-	      clone->remove_all_references ();
-	      clone->thunk.thunk_p = true;
-	      clone->thunk.add_pointer_bounds_args = true;
-	      clone->create_edge (node, NULL, 0, CGRAPH_FREQ_BASE);
-	      /* Thunk shouldn't be a cdtor.  */
-	      DECL_STATIC_CONSTRUCTOR (clone->decl) = 0;
-	      DECL_STATIC_DESTRUCTOR (clone->decl) = 0;
-	    }
-	  else
-	    {
-	      tree_function_versioning (fndecl, new_decl, NULL, false,
-					NULL, false, NULL, NULL);
-	      clone->lowered = true;
-	    }
+	  gcc_assert (chkp_instrumentable_p (fndecl));
+	  tree_function_versioning (fndecl, new_decl, NULL, false,
+				    NULL, false, NULL, NULL);
+	  clone->lowered = true;
 	}
 
       /* New params are inserted after versioning because it
@@ -586,12 +615,7 @@
 
       /* Clone all aliases.  */
       for (i = 0; node->iterate_direct_aliases (i, ref); i++)
-	{
-	  struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);
-	  struct cgraph_node *chkp_alias
-	    = chkp_maybe_create_clone (alias->decl);
-	  chkp_alias->create_reference (clone, IPA_REF_ALIAS, NULL);
-	}
+	chkp_maybe_create_clone (ref->referring->decl);
 
       /* Clone all thunks.  */
       for (e = node->callers; e; e = e->next_caller)
@@ -615,7 +639,10 @@
 
 	  ref = node->ref_list.first_reference ();
 	  if (ref)
-	    chkp_maybe_create_clone (ref->referred->decl);
+	    {
+	      target = chkp_maybe_create_clone (ref->referred->decl);
+	      clone->create_reference (target, IPA_REF_ALIAS);
+	    }
 
 	  if (node->alias_target)
 	    {
diff -Naur gcc-5.2.0.orig/gcc/ipa-chkp.h gcc-5.2.0/gcc/ipa-chkp.h
--- gcc-5.2.0.orig/gcc/ipa-chkp.h	2015-01-16 07:08:24.000000000 -0600
+++ gcc-5.2.0/gcc/ipa-chkp.h	2015-07-23 05:09:10.443079000 -0500
@@ -24,5 +24,6 @@
 extern tree chkp_maybe_clone_builtin_fndecl (tree fndecl);
 extern cgraph_node *chkp_maybe_create_clone (tree fndecl);
 extern bool chkp_instrumentable_p (tree fndecl);
+extern bool chkp_wrap_function (tree fndecl);
 
 #endif /* GCC_IPA_CHKP_H */
diff -Naur gcc-5.2.0.orig/gcc/ipa-devirt.c gcc-5.2.0/gcc/ipa-devirt.c
--- gcc-5.2.0.orig/gcc/ipa-devirt.c	2015-03-31 12:03:16.000000000 -0500
+++ gcc-5.2.0/gcc/ipa-devirt.c	2015-07-27 14:53:53.660196000 -0500
@@ -483,7 +483,7 @@
 	return false;
       if (TREE_CODE (type1) == RECORD_TYPE
 	  && (TYPE_BINFO (type1) == NULL_TREE)
-	      != (TYPE_BINFO (type1) == NULL_TREE))
+	      != (TYPE_BINFO (type2) == NULL_TREE))
 	return false;
       if (TREE_CODE (type1) == RECORD_TYPE && TYPE_BINFO (type1)
 	  && (BINFO_VTABLE (TYPE_BINFO (type1)) == NULL_TREE)
diff -Naur gcc-5.2.0.orig/gcc/ipa-inline-analysis.c gcc-5.2.0/gcc/ipa-inline-analysis.c
--- gcc-5.2.0.orig/gcc/ipa-inline-analysis.c	2015-04-03 13:19:53.000000000 -0500
+++ gcc-5.2.0/gcc/ipa-inline-analysis.c	2015-07-24 08:25:06.714732000 -0500
@@ -1602,7 +1602,7 @@
    loaded.  */
 
 static bool
-unmodified_parm_or_parm_agg_item (struct ipa_node_params *info,
+unmodified_parm_or_parm_agg_item (struct ipa_func_body_info *fbi,
 				  gimple stmt, tree op, int *index_p,
 				  struct agg_position_info *aggpos)
 {
@@ -1611,7 +1611,7 @@
   gcc_checking_assert (aggpos);
   if (res)
     {
-      *index_p = ipa_get_param_decl_index (info, res);
+      *index_p = ipa_get_param_decl_index (fbi->info, res);
       if (*index_p < 0)
 	return false;
       aggpos->agg_contents = false;
@@ -1627,13 +1627,14 @@
       stmt = SSA_NAME_DEF_STMT (op);
       op = gimple_assign_rhs1 (stmt);
       if (!REFERENCE_CLASS_P (op))
-	return unmodified_parm_or_parm_agg_item (info, stmt, op, index_p,
+	return unmodified_parm_or_parm_agg_item (fbi, stmt, op, index_p,
 						 aggpos);
     }
 
   aggpos->agg_contents = true;
-  return ipa_load_from_parm_agg (info, stmt, op, index_p, &aggpos->offset,
-				 &aggpos->by_ref);
+  return ipa_load_from_parm_agg (fbi, fbi->info->descriptors,
+				 stmt, op, index_p, &aggpos->offset,
+				 NULL, &aggpos->by_ref);
 }
 
 /* See if statement might disappear after inlining.
@@ -1772,7 +1773,7 @@
    predicates to the CFG edges.   */
 
 static void
-set_cond_stmt_execution_predicate (struct ipa_node_params *info,
+set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,
 				   struct inline_summary *summary,
 				   basic_block bb)
 {
@@ -1795,7 +1796,7 @@
   /* TODO: handle conditionals like
      var = op0 < 4;
      if (var != 0).  */
-  if (unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))
+  if (unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &aggpos))
     {
       code = gimple_cond_code (last);
       inverted_code = invert_tree_comparison (code, HONOR_NANS (op));
@@ -1838,8 +1839,7 @@
       || gimple_call_num_args (set_stmt) != 1)
     return;
   op2 = gimple_call_arg (set_stmt, 0);
-  if (!unmodified_parm_or_parm_agg_item
-      (info, set_stmt, op2, &index, &aggpos))
+  if (!unmodified_parm_or_parm_agg_item (fbi, set_stmt, op2, &index, &aggpos))
     return;
   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)
     {
@@ -1855,7 +1855,7 @@
    predicates to the CFG edges.   */
 
 static void
-set_switch_stmt_execution_predicate (struct ipa_node_params *info,
+set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,
 				     struct inline_summary *summary,
 				     basic_block bb)
 {
@@ -1873,7 +1873,7 @@
     return;
   gswitch *last = as_a <gswitch *> (lastg);
   op = gimple_switch_index (last);
-  if (!unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))
+  if (!unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &aggpos))
     return;
 
   FOR_EACH_EDGE (e, ei, bb->succs)
@@ -1916,8 +1916,8 @@
    which it is executable.  */
 
 static void
-compute_bb_predicates (struct cgraph_node *node,
-		       struct ipa_node_params *parms_info,
+compute_bb_predicates (struct ipa_func_body_info *fbi,
+		       struct cgraph_node *node,
 		       struct inline_summary *summary)
 {
   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);
@@ -1926,8 +1926,8 @@
 
   FOR_EACH_BB_FN (bb, my_function)
     {
-      set_cond_stmt_execution_predicate (parms_info, summary, bb);
-      set_switch_stmt_execution_predicate (parms_info, summary, bb);
+      set_cond_stmt_execution_predicate (fbi, summary, bb);
+      set_switch_stmt_execution_predicate (fbi, summary, bb);
     }
 
   /* Entry block is always executable.  */
@@ -2059,7 +2059,7 @@
    a compile time constant.  */
 
 static struct predicate
-will_be_nonconstant_predicate (struct ipa_node_params *info,
+will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,
 			       struct inline_summary *summary,
 			       gimple stmt,
 			       vec<predicate_t> nonconstant_names)
@@ -2093,7 +2093,7 @@
       tree op;
       gcc_assert (gimple_assign_single_p (stmt));
       op = gimple_assign_rhs1 (stmt);
-      if (!unmodified_parm_or_parm_agg_item (info, stmt, op, &base_index,
+      if (!unmodified_parm_or_parm_agg_item (fbi, stmt, op, &base_index,
 					     &aggpos))
 	return p;
     }
@@ -2106,7 +2106,7 @@
     {
       tree parm = unmodified_parm (stmt, use);
       /* For arguments we can build a condition.  */
-      if (parm && ipa_get_param_decl_index (info, parm) >= 0)
+      if (parm && ipa_get_param_decl_index (fbi->info, parm) >= 0)
 	continue;
       if (TREE_CODE (use) != SSA_NAME)
 	return p;
@@ -2127,7 +2127,7 @@
       tree parm = unmodified_parm (stmt, use);
       int index;
 
-      if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)
+      if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)
 	{
 	  if (index != base_index)
 	    p = add_condition (summary, index, NULL, CHANGED, NULL_TREE);
@@ -2509,13 +2509,17 @@
   int freq;
   struct inline_summary *info = inline_summaries->get (node);
   struct predicate bb_predicate;
-  struct ipa_node_params *parms_info = NULL;
+  struct ipa_func_body_info fbi;
   vec<predicate_t> nonconstant_names = vNULL;
   int nblocks, n;
   int *order;
   predicate array_index = true_predicate ();
   gimple fix_builtin_expect_stmt;
 
+  gcc_assert (my_function && my_function->cfg);
+  gcc_assert (cfun == my_function);
+
+  memset(&fbi, 0, sizeof(fbi));
   info->conds = NULL;
   info->entry = NULL;
 
@@ -2538,7 +2542,11 @@
 
       if (ipa_node_params_sum)
 	{
-	  parms_info = IPA_NODE_REF (node);
+	  fbi.node = node;
+	  fbi.info = IPA_NODE_REF (node);
+	  fbi.bb_infos = vNULL;
+	  fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));
+	  fbi.param_count = count_formal_params(node->decl);
 	  nonconstant_names.safe_grow_cleared
 	    (SSANAMES (my_function)->length ());
 	}
@@ -2556,10 +2564,8 @@
   bb_predicate = not_inlined_predicate ();
   account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate);
 
-  gcc_assert (my_function && my_function->cfg);
-  if (parms_info)
-    compute_bb_predicates (node, parms_info, info);
-  gcc_assert (cfun == my_function);
+  if (fbi.info)
+    compute_bb_predicates (&fbi, node, info);
   order = XNEWVEC (int, n_basic_blocks_for_fn (cfun));
   nblocks = pre_and_rev_post_order_compute (NULL, order, false);
   for (n = 0; n < nblocks; n++)
@@ -2576,7 +2582,7 @@
 	}
 
       /* TODO: Obviously predicates can be propagated down across CFG.  */
-      if (parms_info)
+      if (fbi.info)
 	{
 	  if (bb->aux)
 	    bb_predicate = *(struct predicate *) bb->aux;
@@ -2592,7 +2598,7 @@
 	  dump_predicate (dump_file, info->conds, &bb_predicate);
 	}
 
-      if (parms_info && nonconstant_names.exists ())
+      if (fbi.info && nonconstant_names.exists ())
 	{
 	  struct predicate phi_predicate;
 	  bool first_phi = true;
@@ -2601,7 +2607,7 @@
 	       gsi_next (&bsi))
 	    {
 	      if (first_phi
-		  && !phi_result_unknown_predicate (parms_info, info, bb,
+		  && !phi_result_unknown_predicate (fbi.info, info, bb,
 						    &phi_predicate,
 						    nonconstant_names))
 		break;
@@ -2710,9 +2716,9 @@
 	  /* TODO: When conditional jump or swithc is known to be constant, but
 	     we did not translate it into the predicates, we really can account
 	     just maximum of the possible paths.  */
-	  if (parms_info)
+	  if (fbi.info)
 	    will_be_nonconstant
-	      = will_be_nonconstant_predicate (parms_info, info,
+	      = will_be_nonconstant_predicate (&fbi, info,
 					       stmt, nonconstant_names);
 	  if (this_time || this_size)
 	    {
@@ -2727,7 +2733,7 @@
 	      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))
 		fprintf (dump_file, "\t\tWill be eliminated by inlining\n");
 
-	      if (parms_info)
+	      if (fbi.info)
 		p = and_predicates (info->conds, &bb_predicate,
 				    &will_be_nonconstant);
 	      else
@@ -2795,7 +2801,7 @@
 		&& !is_gimple_min_invariant (niter_desc.niter))
 	    {
 	      predicate will_be_nonconstant
-		= will_be_nonconstant_expr_predicate (parms_info, info,
+		= will_be_nonconstant_expr_predicate (fbi.info, info,
 						      niter_desc.niter,
 						      nonconstant_names);
 	      if (!true_predicate_p (&will_be_nonconstant))
@@ -2833,7 +2839,7 @@
 			|| is_gimple_min_invariant (iv.step))
 		      continue;
 		    will_be_nonconstant
-		      = will_be_nonconstant_expr_predicate (parms_info, info,
+		      = will_be_nonconstant_expr_predicate (fbi.info, info,
 							    iv.step,
 							    nonconstant_names);
 		    if (!true_predicate_p (&will_be_nonconstant))
@@ -3133,6 +3139,9 @@
   struct cgraph_edge *e;
   for (e = node->callees; e; e = e->next_callee)
     {
+      if (inline_edge_summary_vec.length () <= (unsigned) e->uid)
+	continue;
+
       struct inline_edge_summary *es = inline_edge_summary (e);
 
       /* Do not care about zero sized builtins.  */
@@ -3164,6 +3173,9 @@
     }
   for (e = node->indirect_calls; e; e = e->next_callee)
     {
+      if (inline_edge_summary_vec.length () <= (unsigned) e->uid)
+	continue;
+
       struct inline_edge_summary *es = inline_edge_summary (e);
       if (!es->predicate
 	  || evaluate_predicate (es->predicate, possible_truths))
diff -Naur gcc-5.2.0.orig/gcc/ipa-prop.c gcc-5.2.0/gcc/ipa-prop.c
--- gcc-5.2.0.orig/gcc/ipa-prop.c	2015-04-12 00:44:52.000000000 -0500
+++ gcc-5.2.0/gcc/ipa-prop.c	2015-07-23 11:14:00.694724000 -0500
@@ -99,57 +99,6 @@
 #include "domwalk.h"
 #include "builtins.h"
 
-/* Intermediate information that we get from alias analysis about a particular
-   parameter in a particular basic_block.  When a parameter or the memory it
-   references is marked modified, we use that information in all dominatd
-   blocks without cosulting alias analysis oracle.  */
-
-struct param_aa_status
-{
-  /* Set when this structure contains meaningful information.  If not, the
-     structure describing a dominating BB should be used instead.  */
-  bool valid;
-
-  /* Whether we have seen something which might have modified the data in
-     question.  PARM is for the parameter itself, REF is for data it points to
-     but using the alias type of individual accesses and PT is the same thing
-     but for computing aggregate pass-through functions using a very inclusive
-     ao_ref.  */
-  bool parm_modified, ref_modified, pt_modified;
-};
-
-/* Information related to a given BB that used only when looking at function
-   body.  */
-
-struct ipa_bb_info
-{
-  /* Call graph edges going out of this BB.  */
-  vec<cgraph_edge *> cg_edges;
-  /* Alias analysis statuses of each formal parameter at this bb.  */
-  vec<param_aa_status> param_aa_statuses;
-};
-
-/* Structure with global information that is only used when looking at function
-   body. */
-
-struct func_body_info
-{
-  /* The node that is being analyzed.  */
-  cgraph_node *node;
-
-  /* Its info.  */
-  struct ipa_node_params *info;
-
-  /* Information about individual BBs. */
-  vec<ipa_bb_info> bb_infos;
-
-  /* Number of parameters.  */
-  int param_count;
-
-  /* Number of statements already walked by when analyzing this function.  */
-  unsigned int aa_walked;
-};
-
 /* Function summary where the parameter infos are actually stored. */
 ipa_node_params_t *ipa_node_params_sum = NULL;
 /* Vector of IPA-CP transformation data for each clone.  */
@@ -563,7 +512,7 @@
    of this function body.  */
 
 static struct ipa_bb_info *
-ipa_get_bb_info (struct func_body_info *fbi, basic_block bb)
+ipa_get_bb_info (struct ipa_func_body_info *fbi, basic_block bb)
 {
   gcc_checking_assert (fbi);
   return &fbi->bb_infos[bb->index];
@@ -838,7 +787,7 @@
    should really just start giving up.  */
 
 static bool
-aa_overwalked (struct func_body_info *fbi)
+aa_overwalked (struct ipa_func_body_info *fbi)
 {
   gcc_checking_assert (fbi);
   return fbi->aa_walked > (unsigned) PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);
@@ -847,8 +796,8 @@
 /* Find the nearest valid aa status for parameter specified by INDEX that
    dominates BB.  */
 
-static struct param_aa_status *
-find_dominating_aa_status (struct func_body_info *fbi, basic_block bb,
+static struct ipa_param_aa_status *
+find_dominating_aa_status (struct ipa_func_body_info *fbi, basic_block bb,
 			   int index)
 {
   while (true)
@@ -867,21 +816,21 @@
    structures and/or intialize the result with a dominating description as
    necessary.  */
 
-static struct param_aa_status *
-parm_bb_aa_status_for_bb (struct func_body_info *fbi, basic_block bb,
+static struct ipa_param_aa_status *
+parm_bb_aa_status_for_bb (struct ipa_func_body_info *fbi, basic_block bb,
 			  int index)
 {
   gcc_checking_assert (fbi);
   struct ipa_bb_info *bi = ipa_get_bb_info (fbi, bb);
   if (bi->param_aa_statuses.is_empty ())
     bi->param_aa_statuses.safe_grow_cleared (fbi->param_count);
-  struct param_aa_status *paa = &bi->param_aa_statuses[index];
+  struct ipa_param_aa_status *paa = &bi->param_aa_statuses[index];
   if (!paa->valid)
     {
       gcc_checking_assert (!paa->parm_modified
 			   && !paa->ref_modified
 			   && !paa->pt_modified);
-      struct param_aa_status *dom_paa;
+      struct ipa_param_aa_status *dom_paa;
       dom_paa = find_dominating_aa_status (fbi, bb, index);
       if (dom_paa)
 	*paa = *dom_paa;
@@ -898,10 +847,10 @@
    gathered but do not survive the summary building stage.  */
 
 static bool
-parm_preserved_before_stmt_p (struct func_body_info *fbi, int index,
+parm_preserved_before_stmt_p (struct ipa_func_body_info *fbi, int index,
 			      gimple stmt, tree parm_load)
 {
-  struct param_aa_status *paa;
+  struct ipa_param_aa_status *paa;
   bool modified = false;
   ao_ref refd;
 
@@ -937,7 +886,7 @@
    modified.  Otherwise return -1.  */
 
 static int
-load_from_unmodified_param (struct func_body_info *fbi,
+load_from_unmodified_param (struct ipa_func_body_info *fbi,
 			    vec<ipa_param_descriptor> descriptors,
 			    gimple stmt)
 {
@@ -964,10 +913,10 @@
    before reaching statement STMT.  */
 
 static bool
-parm_ref_data_preserved_p (struct func_body_info *fbi,
+parm_ref_data_preserved_p (struct ipa_func_body_info *fbi,
 			   int index, gimple stmt, tree ref)
 {
-  struct param_aa_status *paa;
+  struct ipa_param_aa_status *paa;
   bool modified = false;
   ao_ref refd;
 
@@ -1003,7 +952,7 @@
    CALL into which it is passed.  FBI describes the function body.  */
 
 static bool
-parm_ref_data_pass_through_p (struct func_body_info *fbi, int index,
+parm_ref_data_pass_through_p (struct ipa_func_body_info *fbi, int index,
 			      gimple call, tree parm)
 {
   bool modified = false;
@@ -1017,8 +966,9 @@
       || aa_overwalked (fbi))
     return false;
 
-  struct param_aa_status *paa = parm_bb_aa_status_for_bb (fbi, gimple_bb (call),
-							  index);
+  struct ipa_param_aa_status *paa = parm_bb_aa_status_for_bb (fbi,
+							      gimple_bb (call),
+							      index);
   if (paa->pt_modified)
     return false;
 
@@ -1041,12 +991,12 @@
    within the aggregate and whether it is a load from a value passed by
    reference respectively.  */
 
-static bool
-ipa_load_from_parm_agg_1 (struct func_body_info *fbi,
-			  vec<ipa_param_descriptor> descriptors,
-			  gimple stmt, tree op, int *index_p,
-			  HOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,
-			  bool *by_ref_p)
+bool
+ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,
+			vec<ipa_param_descriptor> descriptors,
+			gimple stmt, tree op, int *index_p,
+			HOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,
+			bool *by_ref_p)
 {
   int index;
   HOST_WIDE_INT size, max_size;
@@ -1113,18 +1063,6 @@
   return false;
 }
 
-/* Just like the previous function, just without the param_analysis_info
-   pointer, for users outside of this file.  */
-
-bool
-ipa_load_from_parm_agg (struct ipa_node_params *info, gimple stmt,
-			tree op, int *index_p, HOST_WIDE_INT *offset_p,
-			bool *by_ref_p)
-{
-  return ipa_load_from_parm_agg_1 (NULL, info->descriptors, stmt, op, index_p,
-				   offset_p, NULL, by_ref_p);
-}
-
 /* Given that an actual argument is an SSA_NAME (given in NAME) and is a result
    of an assignment statement STMT, try to determine whether we are actually
    handling any of the following cases and construct an appropriate jump
@@ -1179,7 +1117,7 @@
    only needed for intraprocedural analysis.  */
 
 static void
-compute_complex_assign_jump_func (struct func_body_info *fbi,
+compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,
 				  struct ipa_node_params *info,
 				  struct ipa_jump_func *jfunc,
 				  gcall *call, gimple stmt, tree name,
@@ -1321,7 +1259,7 @@
      return D.1879_6;  */
 
 static void
-compute_complex_ancestor_jump_func (struct func_body_info *fbi,
+compute_complex_ancestor_jump_func (struct ipa_func_body_info *fbi,
 				    struct ipa_node_params *info,
 				    struct ipa_jump_func *jfunc,
 				    gcall *call, gphi *phi)
@@ -1703,7 +1641,7 @@
    to this callsite.  */
 
 static void
-ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,
+ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,
 				     struct cgraph_edge *cs)
 {
   struct ipa_node_params *info = IPA_NODE_REF (cs->caller);
@@ -1826,7 +1764,7 @@
    from BB.  */
 
 static void
-ipa_compute_jump_functions_for_bb (struct func_body_info *fbi, basic_block bb)
+ipa_compute_jump_functions_for_bb (struct ipa_func_body_info *fbi, basic_block bb)
 {
   struct ipa_bb_info *bi = ipa_get_bb_info (fbi, bb);
   int i;
@@ -1989,7 +1927,7 @@
    passed by value or reference.  */
 
 static void
-ipa_analyze_indirect_call_uses (struct func_body_info *fbi, gcall *call,
+ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,
 				tree target)
 {
   struct ipa_node_params *info = fbi->info;
@@ -2008,9 +1946,9 @@
   int index;
   gimple def = SSA_NAME_DEF_STMT (target);
   if (gimple_assign_single_p (def)
-      && ipa_load_from_parm_agg_1 (fbi, info->descriptors, def,
-				   gimple_assign_rhs1 (def), &index, &offset,
-				   NULL, &by_ref))
+      && ipa_load_from_parm_agg (fbi, info->descriptors, def,
+				 gimple_assign_rhs1 (def), &index, &offset,
+				 NULL, &by_ref))
     {
       struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);
       cs->indirect_info->offset = offset;
@@ -2127,7 +2065,7 @@
    statement.  */
 
 static void
-ipa_analyze_virtual_call_uses (struct func_body_info *fbi,
+ipa_analyze_virtual_call_uses (struct ipa_func_body_info *fbi,
 			       gcall *call, tree target)
 {
   tree obj = OBJ_TYPE_REF_OBJECT (target);
@@ -2184,7 +2122,7 @@
    containing intermediate information about each formal parameter.  */
 
 static void
-ipa_analyze_call_uses (struct func_body_info *fbi, gcall *call)
+ipa_analyze_call_uses (struct ipa_func_body_info *fbi, gcall *call)
 {
   tree target = gimple_call_fn (call);
 
@@ -2230,7 +2168,7 @@
    formal parameters are called.  */
 
 static void
-ipa_analyze_stmt_uses (struct func_body_info *fbi, gimple stmt)
+ipa_analyze_stmt_uses (struct ipa_func_body_info *fbi, gimple stmt)
 {
   if (is_gimple_call (stmt))
     ipa_analyze_call_uses (fbi, as_a <gcall *> (stmt));
@@ -2263,7 +2201,7 @@
    the function being analyzed.  */
 
 static void
-ipa_analyze_params_uses_in_bb (struct func_body_info *fbi, basic_block bb)
+ipa_analyze_params_uses_in_bb (struct ipa_func_body_info *fbi, basic_block bb)
 {
   gimple_stmt_iterator gsi;
   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
@@ -2345,13 +2283,13 @@
 class analysis_dom_walker : public dom_walker
 {
 public:
-  analysis_dom_walker (struct func_body_info *fbi)
+  analysis_dom_walker (struct ipa_func_body_info *fbi)
     : dom_walker (CDI_DOMINATORS), m_fbi (fbi) {}
 
   virtual void before_dom_children (basic_block);
 
 private:
-  struct func_body_info *m_fbi;
+  struct ipa_func_body_info *m_fbi;
 };
 
 void
@@ -2368,7 +2306,7 @@
 void
 ipa_analyze_node (struct cgraph_node *node)
 {
-  struct func_body_info fbi;
+  struct ipa_func_body_info fbi;
   struct ipa_node_params *info;
 
   ipa_check_create_node_params ();
@@ -2472,11 +2410,15 @@
 	      ctx.offset_by (dst->value.ancestor.offset);
 	      if (!ctx.useless_p ())
 		{
-		  vec_safe_grow_cleared (args->polymorphic_call_contexts,
-					 count);
-		  dst_ctx = ipa_get_ith_polymorhic_call_context (args, i);
+		  if (!dst_ctx)
+		    {
+		      vec_safe_grow_cleared (args->polymorphic_call_contexts,
+					     count);
+		      dst_ctx = ipa_get_ith_polymorhic_call_context (args, i);
+		    }
+
+		  dst_ctx->combine_with (ctx);
 		}
-	      dst_ctx->combine_with (ctx);
 	    }
 
 	  if (src->agg.items
@@ -5183,7 +5125,7 @@
 class ipcp_modif_dom_walker : public dom_walker
 {
 public:
-  ipcp_modif_dom_walker (struct func_body_info *fbi,
+  ipcp_modif_dom_walker (struct ipa_func_body_info *fbi,
 			 vec<ipa_param_descriptor> descs,
 			 struct ipa_agg_replacement_value *av,
 			 bool *sc, bool *cc)
@@ -5193,7 +5135,7 @@
   virtual void before_dom_children (basic_block);
 
 private:
-  struct func_body_info *m_fbi;
+  struct ipa_func_body_info *m_fbi;
   vec<ipa_param_descriptor> m_descriptors;
   struct ipa_agg_replacement_value *m_aggval;
   bool *m_something_changed, *m_cfg_changed;
@@ -5234,8 +5176,8 @@
       if (vce)
 	continue;
 
-      if (!ipa_load_from_parm_agg_1 (m_fbi, m_descriptors, stmt, rhs, &index,
-				     &offset, &size, &by_ref))
+      if (!ipa_load_from_parm_agg (m_fbi, m_descriptors, stmt, rhs, &index,
+				   &offset, &size, &by_ref))
 	continue;
       for (v = m_aggval; v; v = v->next)
 	if (v->index == index
@@ -5351,7 +5293,7 @@
 ipcp_transform_function (struct cgraph_node *node)
 {
   vec<ipa_param_descriptor> descriptors = vNULL;
-  struct func_body_info fbi;
+  struct ipa_func_body_info fbi;
   struct ipa_agg_replacement_value *aggval;
   int param_count;
   bool cfg_changed = false, something_changed = false;
diff -Naur gcc-5.2.0.orig/gcc/ipa-prop.h gcc-5.2.0/gcc/ipa-prop.h
--- gcc-5.2.0.orig/gcc/ipa-prop.h	2015-03-29 10:38:52.000000000 -0500
+++ gcc-5.2.0/gcc/ipa-prop.h	2015-07-23 11:14:00.694724000 -0500
@@ -336,6 +336,57 @@
   unsigned node_calling_single_call : 1;
 };
 
+/* Intermediate information that we get from alias analysis about a particular
+   parameter in a particular basic_block.  When a parameter or the memory it
+   references is marked modified, we use that information in all dominated
+   blocks without consulting alias analysis oracle.  */
+
+struct ipa_param_aa_status
+{
+  /* Set when this structure contains meaningful information.  If not, the
+     structure describing a dominating BB should be used instead.  */
+  bool valid;
+
+  /* Whether we have seen something which might have modified the data in
+     question.  PARM is for the parameter itself, REF is for data it points to
+     but using the alias type of individual accesses and PT is the same thing
+     but for computing aggregate pass-through functions using a very inclusive
+     ao_ref.  */
+  bool parm_modified, ref_modified, pt_modified;
+};
+
+/* Information related to a given BB that used only when looking at function
+   body.  */
+
+struct ipa_bb_info
+{
+  /* Call graph edges going out of this BB.  */
+  vec<cgraph_edge *> cg_edges;
+  /* Alias analysis statuses of each formal parameter at this bb.  */
+  vec<ipa_param_aa_status> param_aa_statuses;
+};
+
+/* Structure with global information that is only used when looking at function
+   body. */
+
+struct ipa_func_body_info
+{
+  /* The node that is being analyzed.  */
+  cgraph_node *node;
+
+  /* Its info.  */
+  struct ipa_node_params *info;
+
+  /* Information about individual BBs. */
+  vec<ipa_bb_info> bb_infos;
+
+  /* Number of parameters.  */
+  int param_count;
+
+  /* Number of statements already walked by when analyzing this function.  */
+  unsigned int aa_walked;
+};
+
 /* ipa_node_params access functions.  Please use these to access fields that
    are or will be shared among various passes.  */
 
@@ -585,8 +636,9 @@
 /* Aggregate jump function related functions.  */
 tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *, HOST_WIDE_INT,
 				 bool);
-bool ipa_load_from_parm_agg (struct ipa_node_params *, gimple, tree, int *,
-			     HOST_WIDE_INT *, bool *);
+bool ipa_load_from_parm_agg (struct ipa_func_body_info *,
+			     vec<ipa_param_descriptor>, gimple, tree, int *,
+			     HOST_WIDE_INT *, HOST_WIDE_INT *, bool *);
 
 /* Debugging interface.  */
 void ipa_print_node_params (FILE *, struct cgraph_node *node);
diff -Naur gcc-5.2.0.orig/gcc/ira-color.c gcc-5.2.0/gcc/ira-color.c
--- gcc-5.2.0.orig/gcc/ira-color.c	2015-02-20 12:59:02.000000000 -0600
+++ gcc-5.2.0/gcc/ira-color.c	2015-09-30 11:39:44.799796000 -0500
@@ -63,6 +63,7 @@
 #include "reload.h"
 #include "params.h"
 #include "df.h"
+#include "recog.h"
 #include "ira-int.h"
 
 typedef struct allocno_hard_regs *allocno_hard_regs_t;
diff -Naur gcc-5.2.0.orig/gcc/ira.h gcc-5.2.0/gcc/ira.h
--- gcc-5.2.0.orig/gcc/ira.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/ira.h	2015-09-30 11:39:44.799796000 -0500
@@ -190,7 +190,6 @@
 extern void ira_setup_eliminable_regset (void);
 extern rtx ira_eliminate_regs (rtx, machine_mode);
 extern void ira_set_pseudo_classes (bool, FILE *);
-extern void ira_implicitly_set_insn_hard_regs (HARD_REG_SET *);
 extern void ira_expand_reg_equiv (void);
 extern void ira_update_equiv_info_by_shuffle_insn (int, int, rtx_insn *);
 
diff -Naur gcc-5.2.0.orig/gcc/ira-int.h gcc-5.2.0/gcc/ira-int.h
--- gcc-5.2.0.orig/gcc/ira-int.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/ira-int.h	2015-09-30 11:39:44.799796000 -0500
@@ -1045,6 +1045,8 @@
 extern void ira_create_allocno_live_ranges (void);
 extern void ira_compress_allocno_live_ranges (void);
 extern void ira_finish_allocno_live_ranges (void);
+extern void ira_implicitly_set_insn_hard_regs (HARD_REG_SET *,
+					       alternative_mask);
 
 /* ira-conflicts.c */
 extern void ira_debug_conflicts (bool);
diff -Naur gcc-5.2.0.orig/gcc/ira-lives.c gcc-5.2.0/gcc/ira-lives.c
--- gcc-5.2.0.orig/gcc/ira-lives.c	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/ira-lives.c	2015-09-30 11:39:44.799796000 -0500
@@ -837,7 +837,8 @@
    might be used by insn reloads because the constraints are too
    strict.  */
 void
-ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)
+ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set,
+				   alternative_mask preferred)
 {
   int i, c, regno = 0;
   enum reg_class cl;
@@ -860,7 +861,6 @@
 	  mode = (GET_CODE (op) == SCRATCH
 		  ? GET_MODE (op) : PSEUDO_REGNO_MODE (regno));
 	  cl = NO_REGS;
-	  alternative_mask preferred = preferred_alternatives;
 	  for (; (c = *p); p += CONSTRAINT_LEN (c, p))
 	    if (c == '#')
 	      preferred &= ~ALTERNATIVE_BIT (0);
diff -Naur gcc-5.2.0.orig/gcc/jit/docs/_build/texinfo/libgccjit.texi gcc-5.2.0/gcc/jit/docs/_build/texinfo/libgccjit.texi
--- gcc-5.2.0.orig/gcc/jit/docs/_build/texinfo/libgccjit.texi	2015-07-01 09:44:18.000000000 -0500
+++ gcc-5.2.0/gcc/jit/docs/_build/texinfo/libgccjit.texi	2015-07-23 19:47:10.585322000 -0500
@@ -19,7 +19,7 @@
 
 @copying
 @quotation
-libgccjit 5.1.1 ( 20150701), July 01, 2015
+libgccjit 5.2.1 ( 20150723), July 23, 2015
 
 David Malcolm
 
@@ -14675,7 +14675,7 @@
 generated via this call:
 
 @example
-JIT: libgccjit (GCC) version 5.0.0 20150123 (experimental) (x86_64-unknown-linux-gnu)
+JIT: libgccjit (GCC) version 5.2.1 20150723 (x86_64-unknown-linux-gnu)
 JIT:	compiled by GNU C version 4.8.3 20140911 (Red Hat 4.8.3-7), GMP version 5.1.2, MPFR version 3.1.2, MPC version 1.0.1
 JIT: entering: gcc_jit_context_set_str_option
 JIT:  GCC_JIT_STR_OPTION_PROGNAME: "./test-hello-world.c.exe"
@@ -14741,6 +14741,7 @@
 JIT:   GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING: false
 JIT:   GCC_JIT_BOOL_OPTION_SELFCHECK_GC: true
 JIT:   GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES: false
+JIT:   gcc_jit_context_set_bool_allow_unreachable_blocks: false
 JIT:   entering: void gcc::jit::recording::context::validate()
 JIT:   exiting: void gcc::jit::recording::context::validate()
 JIT:   entering: gcc::jit::playback::context::context(gcc::jit::recording::context*)
@@ -14806,13 +14807,16 @@
 JIT:    entering: virtual void gcc::jit::playback::compile_to_memory::postprocess(const char*)
 JIT:     entering: void gcc::jit::playback::context::convert_to_dso(const char*)
 JIT:      entering: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)
-JIT:       argv[0]: x86_64-unknown-linux-gnu-gcc-5.0.0
-JIT:       argv[1]: -shared
-JIT:       argv[2]: /tmp/libgccjit-CKq1M9/fake.s
-JIT:       argv[3]: -o
-JIT:       argv[4]: /tmp/libgccjit-CKq1M9/fake.so
-JIT:       argv[5]: -fno-use-linker-plugin
-JIT:       argv[6]: (null)
+JIT:       entering: void gcc::jit::playback::context::add_multilib_driver_arguments(vec<char*>*)
+JIT:       exiting: void gcc::jit::playback::context::add_multilib_driver_arguments(vec<char*>*)
+JIT:       argv[0]: x86_64-unknown-linux-gnu-gcc-5.2.1
+JIT:       argv[1]: -m64
+JIT:       argv[2]: -shared
+JIT:       argv[3]: /tmp/libgccjit-CKq1M9/fake.s
+JIT:       argv[4]: -o
+JIT:       argv[5]: /tmp/libgccjit-CKq1M9/fake.so
+JIT:       argv[6]: -fno-use-linker-plugin
+JIT:       argv[7]: (null)
 JIT:      exiting: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)
 JIT:     exiting: void gcc::jit::playback::context::convert_to_dso(const char*)
 JIT:     entering: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()
diff -Naur gcc-5.2.0.orig/gcc/jit/docs/internals/test-hello-world.exe.log.txt gcc-5.2.0/gcc/jit/docs/internals/test-hello-world.exe.log.txt
--- gcc-5.2.0.orig/gcc/jit/docs/internals/test-hello-world.exe.log.txt	2015-02-03 13:28:24.000000000 -0600
+++ gcc-5.2.0/gcc/jit/docs/internals/test-hello-world.exe.log.txt	2015-07-23 19:47:10.585322000 -0500
@@ -1,4 +1,4 @@
-JIT: libgccjit (GCC) version 5.0.0 20150123 (experimental) (x86_64-unknown-linux-gnu)
+JIT: libgccjit (GCC) version 5.2.1 20150723 (x86_64-unknown-linux-gnu)
 JIT:	compiled by GNU C version 4.8.3 20140911 (Red Hat 4.8.3-7), GMP version 5.1.2, MPFR version 3.1.2, MPC version 1.0.1
 JIT: entering: gcc_jit_context_set_str_option
 JIT:  GCC_JIT_STR_OPTION_PROGNAME: "./test-hello-world.c.exe"
@@ -64,6 +64,7 @@
 JIT:   GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING: false
 JIT:   GCC_JIT_BOOL_OPTION_SELFCHECK_GC: true
 JIT:   GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES: false
+JIT:   gcc_jit_context_set_bool_allow_unreachable_blocks: false
 JIT:   entering: void gcc::jit::recording::context::validate()
 JIT:   exiting: void gcc::jit::recording::context::validate()
 JIT:   entering: gcc::jit::playback::context::context(gcc::jit::recording::context*)
@@ -129,13 +130,16 @@
 JIT:    entering: virtual void gcc::jit::playback::compile_to_memory::postprocess(const char*)
 JIT:     entering: void gcc::jit::playback::context::convert_to_dso(const char*)
 JIT:      entering: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)
-JIT:       argv[0]: x86_64-unknown-linux-gnu-gcc-5.0.0
-JIT:       argv[1]: -shared
-JIT:       argv[2]: /tmp/libgccjit-CKq1M9/fake.s
-JIT:       argv[3]: -o
-JIT:       argv[4]: /tmp/libgccjit-CKq1M9/fake.so
-JIT:       argv[5]: -fno-use-linker-plugin
-JIT:       argv[6]: (null)
+JIT:       entering: void gcc::jit::playback::context::add_multilib_driver_arguments(vec<char*>*)
+JIT:       exiting: void gcc::jit::playback::context::add_multilib_driver_arguments(vec<char*>*)
+JIT:       argv[0]: x86_64-unknown-linux-gnu-gcc-5.2.1
+JIT:       argv[1]: -m64
+JIT:       argv[2]: -shared
+JIT:       argv[3]: /tmp/libgccjit-CKq1M9/fake.s
+JIT:       argv[4]: -o
+JIT:       argv[5]: /tmp/libgccjit-CKq1M9/fake.so
+JIT:       argv[6]: -fno-use-linker-plugin
+JIT:       argv[7]: (null)
 JIT:      exiting: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)
 JIT:     exiting: void gcc::jit::playback::context::convert_to_dso(const char*)
 JIT:     entering: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()
diff -Naur gcc-5.2.0.orig/gcc/jit/jit-playback.c gcc-5.2.0/gcc/jit/jit-playback.c
--- gcc-5.2.0.orig/gcc/jit/jit-playback.c	2015-07-01 09:48:55.000000000 -0500
+++ gcc-5.2.0/gcc/jit/jit-playback.c	2015-08-13 20:22:45.550004000 -0500
@@ -2432,14 +2432,16 @@
      TV_ASSEMBLE.  */
   auto_timevar assemble_timevar (tv_id);
   const char *errmsg;
-  auto_vec <const char *> argvec;
-#define ADD_ARG(arg) argvec.safe_push (arg)
+  auto_argvec argvec;
+#define ADD_ARG(arg) argvec.safe_push (xstrdup (arg))
   int exit_status = 0;
   int err = 0;
   const char *gcc_driver_name = GCC_DRIVER_NAME;
 
   ADD_ARG (gcc_driver_name);
 
+  add_multilib_driver_arguments (&argvec);
+
   if (shared)
     ADD_ARG ("-shared");
 
@@ -2459,8 +2461,17 @@
      time.  */
   ADD_ARG ("-fno-use-linker-plugin");
 
+#if defined (DARWIN_X86) || defined (DARWIN_PPC)
+  /* OS X's linker defaults to treating undefined symbols as errors.
+     If the context has any imported functions or globals they will be
+     undefined until the .so is dynamically-linked into the process.
+     Ensure that the driver passes in "-undefined dynamic_lookup" to the
+     linker.  */
+  ADD_ARG ("-Wl,-undefined,dynamic_lookup");
+#endif
+
   /* pex argv arrays are NULL-terminated.  */
-  ADD_ARG (NULL);
+  argvec.safe_push (NULL);
 
   /* pex_one's error-handling requires pname to be non-NULL.  */
   gcc_assert (ctxt_progname);
@@ -2501,6 +2512,36 @@
 #undef ADD_ARG
 }
 
+/* Extract the target-specific MULTILIB_DEFAULTS to
+   multilib_defaults_raw for use by
+   playback::context::add_multilib_driver_arguments ().  */
+
+#ifndef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "" }
+#endif
+
+static const char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;
+
+/* Helper function for playback::context::invoke_driver ().
+
+   32-bit and 64-bit multilib peer builds of libgccjit.so may share
+   a driver binary.  We need to pass in options to the shared driver
+   to get the appropriate assembler/linker options for this multilib
+   peer.  */
+
+void
+playback::context::
+add_multilib_driver_arguments (vec <char *> *argvec)
+{
+  JIT_LOG_SCOPE (get_logger ());
+
+  /* Add copies of the arguments in multilib_defaults_raw to argvec,
+     prepending each with a "-".  */
+  for (size_t i = 0; i < ARRAY_SIZE (multilib_defaults_raw); i++)
+    if (multilib_defaults_raw[i][0])
+      argvec->safe_push (concat ("-", multilib_defaults_raw[i], NULL));
+}
+
 /* Dynamically-link the built DSO file into this process, using dlopen.
    Wrap it up within a jit::result *, and return that.
    Return NULL if any errors occur, reporting them on this context.  */
diff -Naur gcc-5.2.0.orig/gcc/jit/jit-playback.h gcc-5.2.0/gcc/jit/jit-playback.h
--- gcc-5.2.0.orig/gcc/jit/jit-playback.h	2015-07-01 09:40:02.000000000 -0500
+++ gcc-5.2.0/gcc/jit/jit-playback.h	2015-07-23 19:47:10.585322000 -0500
@@ -276,6 +276,9 @@
 		 bool shared,
 		 bool run_linker);
 
+  void
+  add_multilib_driver_arguments (vec <char *> *argvec);
+
   result *
   dlopen_built_dso ();
 
diff -Naur gcc-5.2.0.orig/gcc/lra.c gcc-5.2.0/gcc/lra.c
--- gcc-5.2.0.orig/gcc/lra.c	2015-07-10 08:17:02.000000000 -0500
+++ gcc-5.2.0/gcc/lra.c	2015-07-31 08:52:09.883474000 -0500
@@ -1818,9 +1818,10 @@
 
 
 /* Replace all references to register OLD_REGNO in *LOC with pseudo
-   register NEW_REG.  Return true if any change was made.  */
+   register NEW_REG.  Try to simplify subreg of constant if SUBREG_P.
+   Return true if any change was made.  */
 bool
-lra_substitute_pseudo (rtx *loc, int old_regno, rtx new_reg)
+lra_substitute_pseudo (rtx *loc, int old_regno, rtx new_reg, bool subreg_p)
 {
   rtx x = *loc;
   bool result = false;
@@ -1832,9 +1833,25 @@
     return false;
 
   code = GET_CODE (x);
-  if (code == REG && (int) REGNO (x) == old_regno)
+  if (code == SUBREG && subreg_p)
     {
-      machine_mode mode = GET_MODE (*loc);
+      rtx subst, inner = SUBREG_REG (x);
+      /* Transform subreg of constant while we still have inner mode
+	 of the subreg.  The subreg internal should not be an insn
+	 operand.  */
+      if (REG_P (inner) && (int) REGNO (inner) == old_regno
+	  && CONSTANT_P (new_reg)
+	  && (subst = simplify_subreg (GET_MODE (x), new_reg, GET_MODE (inner),
+				       SUBREG_BYTE (x))) != NULL_RTX)
+	{
+	  *loc = subst;
+	  return true;
+	}
+      
+    }
+  else if (code == REG && (int) REGNO (x) == old_regno)
+    {
+      machine_mode mode = GET_MODE (x);
       machine_mode inner_mode = GET_MODE (new_reg);
 
       if (mode != inner_mode
@@ -1856,26 +1873,30 @@
     {
       if (fmt[i] == 'e')
 	{
-	  if (lra_substitute_pseudo (&XEXP (x, i), old_regno, new_reg))
+	  if (lra_substitute_pseudo (&XEXP (x, i), old_regno,
+				     new_reg, subreg_p))
 	    result = true;
 	}
       else if (fmt[i] == 'E')
 	{
 	  for (j = XVECLEN (x, i) - 1; j >= 0; j--)
-	    if (lra_substitute_pseudo (&XVECEXP (x, i, j), old_regno, new_reg))
+	    if (lra_substitute_pseudo (&XVECEXP (x, i, j), old_regno,
+				       new_reg, subreg_p))
 	      result = true;
 	}
     }
   return result;
 }
 
-/* Call lra_substitute_pseudo within an insn.  This won't update the insn ptr,
-   just the contents of the insn.  */
+/* Call lra_substitute_pseudo within an insn.  Try to simplify subreg
+   of constant if SUBREG_P.  This won't update the insn ptr, just the
+   contents of the insn.  */
 bool
-lra_substitute_pseudo_within_insn (rtx_insn *insn, int old_regno, rtx new_reg)
+lra_substitute_pseudo_within_insn (rtx_insn *insn, int old_regno,
+				   rtx new_reg, bool subreg_p)
 {
   rtx loc = insn;
-  return lra_substitute_pseudo (&loc, old_regno, new_reg);
+  return lra_substitute_pseudo (&loc, old_regno, new_reg, subreg_p);
 }
 
 
diff -Naur gcc-5.2.0.orig/gcc/lra-constraints.c gcc-5.2.0/gcc/lra-constraints.c
--- gcc-5.2.0.orig/gcc/lra-constraints.c	2015-07-10 08:17:02.000000000 -0500
+++ gcc-5.2.0/gcc/lra-constraints.c	2015-07-31 08:52:09.883474000 -0500
@@ -4729,7 +4729,7 @@
 	}
       return false;
     }
-  lra_substitute_pseudo_within_insn (insn, original_regno, new_reg);
+  lra_substitute_pseudo_within_insn (insn, original_regno, new_reg, false);
   lra_update_insn_regno_info (insn);
   if (! def_p)
     /* We now have a new usage insn for original regno.  */
@@ -4761,7 +4761,7 @@
 	  lra_assert (DEBUG_INSN_P (usage_insn));
 	  next_usage_insns = XEXP (next_usage_insns, 1);
 	}
-      lra_substitute_pseudo (&usage_insn, original_regno, new_reg);
+      lra_substitute_pseudo (&usage_insn, original_regno, new_reg, false);
       lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));
       if (lra_dump_file != NULL)
 	{
@@ -5023,7 +5023,7 @@
       usage_insn = XEXP (next_usage_insns, 0);
       lra_assert (DEBUG_INSN_P (usage_insn));
       next_usage_insns = XEXP (next_usage_insns, 1);
-      lra_substitute_pseudo (&usage_insn, original_regno, new_reg);
+      lra_substitute_pseudo (&usage_insn, original_regno, new_reg, false);
       lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));
       if (lra_dump_file != NULL)
 	{
@@ -5955,8 +5955,9 @@
 		    {
 		      if (change_p && bitmap_bit_p (remove_pseudos, regno))
 			{
-			  lra_substitute_pseudo_within_insn (
-			    curr_insn, regno, regno_reg_rtx[restore_regno]);
+			  lra_substitute_pseudo_within_insn
+			    (curr_insn, regno, regno_reg_rtx[restore_regno],
+			     false);
 			  restored_regs_p = true;
 			}
 		      else
@@ -6079,9 +6080,9 @@
 		 we remove the inheritance pseudo and the optional
 		 reload.  */
 	    }
-	  lra_substitute_pseudo_within_insn (
-	    insn, regno,
-	    regno_reg_rtx[lra_reg_info[regno].restore_regno]);
+	  lra_substitute_pseudo_within_insn
+	    (insn, regno, regno_reg_rtx[lra_reg_info[regno].restore_regno],
+	     false);
 	  lra_update_insn_regno_info (insn);
 	  if (lra_dump_file != NULL)
 	    {
diff -Naur gcc-5.2.0.orig/gcc/lra-int.h gcc-5.2.0/gcc/lra-int.h
--- gcc-5.2.0.orig/gcc/lra-int.h	2015-07-10 08:17:02.000000000 -0500
+++ gcc-5.2.0/gcc/lra-int.h	2015-07-31 08:52:09.883474000 -0500
@@ -314,8 +314,8 @@
 extern void lra_process_new_insns (rtx_insn *, rtx_insn *, rtx_insn *,
 				   const char *);
 
-extern bool lra_substitute_pseudo (rtx *, int, rtx);
-extern bool lra_substitute_pseudo_within_insn (rtx_insn *, int, rtx);
+extern bool lra_substitute_pseudo (rtx *, int, rtx, bool);
+extern bool lra_substitute_pseudo_within_insn (rtx_insn *, int, rtx, bool);
 
 extern lra_insn_recog_data_t lra_set_insn_recog_data (rtx_insn *);
 extern lra_insn_recog_data_t lra_update_insn_recog_data (rtx_insn *);
diff -Naur gcc-5.2.0.orig/gcc/lra-lives.c gcc-5.2.0/gcc/lra-lives.c
--- gcc-5.2.0.orig/gcc/lra-lives.c	2015-07-10 08:17:02.000000000 -0500
+++ gcc-5.2.0/gcc/lra-lives.c	2015-07-31 08:52:09.883474000 -0500
@@ -759,7 +759,7 @@
 		    {
 		      insn = lra_insn_recog_data[uid]->insn;
 		      lra_substitute_pseudo_within_insn (insn, dst_regno,
-							 SET_SRC (set));
+							 SET_SRC (set), true);
 		      lra_update_insn_regno_info (insn);
 		    }
 		}
diff -Naur gcc-5.2.0.orig/gcc/lra-remat.c gcc-5.2.0/gcc/lra-remat.c
--- gcc-5.2.0.orig/gcc/lra-remat.c	2015-04-07 10:01:07.000000000 -0500
+++ gcc-5.2.0/gcc/lra-remat.c	2015-09-29 11:37:26.224891000 -0500
@@ -432,6 +432,16 @@
 	  return -1;
 	found_reg = reg;
       }
+    /* IRA calculates conflicts separately for subregs of two words
+       pseudo.  Even if the pseudo lives, e.g. one its subreg can be
+       used lately, another subreg hard register can be already used
+       for something else.  In such case, it is not safe to
+       rematerialize the insn.  */
+    else if (reg->type == OP_IN && reg->subreg_p
+	     && reg->regno >= FIRST_PSEUDO_REGISTER
+	     && (GET_MODE_SIZE (PSEUDO_REGNO_MODE (reg->regno))
+		 == 2 * UNITS_PER_WORD))
+      return -1;
   if (found_reg == NULL)
     return -1;
   if (found_reg->regno < FIRST_PSEUDO_REGISTER)
diff -Naur gcc-5.2.0.orig/gcc/lto-cgraph.c gcc-5.2.0/gcc/lto-cgraph.c
--- gcc-5.2.0.orig/gcc/lto-cgraph.c	2015-06-17 02:40:15.000000000 -0500
+++ gcc-5.2.0/gcc/lto-cgraph.c	2015-10-06 05:19:54.537907000 -0500
@@ -80,6 +80,7 @@
 #include "pass_manager.h"
 #include "ipa-utils.h"
 #include "omp-low.h"
+#include "ipa-chkp.h"
 
 /* True when asm nodes has been output.  */
 bool asm_nodes_output = false;
@@ -918,14 +919,6 @@
       add_node_to (encoder, node, true);
       lto_set_symtab_encoder_in_partition (encoder, node);
       create_references (encoder, node);
-      /* For proper debug info, we need to ship the origins, too.  */
-      if (DECL_ABSTRACT_ORIGIN (node->decl))
-	{
-	  struct cgraph_node *origin_node
-	  = cgraph_node::get_create (DECL_ABSTRACT_ORIGIN (node->decl));
-	  origin_node->used_as_abstract_origin = true;
-	  add_node_to (encoder, origin_node, true);
-	}
     }
   for (lsei = lsei_start_variable_in_partition (in_encoder);
        !lsei_end_p (lsei); lsei_next_variable_in_partition (&lsei))
@@ -937,13 +930,6 @@
       lto_set_symtab_encoder_in_partition (encoder, vnode);
       lto_set_symtab_encoder_encode_initializer (encoder, vnode);
       create_references (encoder, vnode);
-      /* For proper debug info, we need to ship the origins, too.  */
-      if (DECL_ABSTRACT_ORIGIN (vnode->decl))
-	{
-	  varpool_node *origin_node
-	    = varpool_node::get (DECL_ABSTRACT_ORIGIN (vnode->decl));
-	  lto_set_symtab_encoder_in_partition (encoder, origin_node);
-	}
     }
   /* Pickle in also the initializer of all referenced readonly variables
      to help folding.  Constant pool variables are not shared, so we must
@@ -1641,10 +1627,13 @@
 		    cnode->instrumented_version->instrumented_version = cnode;
 		}
 
-	      /* Restore decl names reference.  */
-	      IDENTIFIER_TRANSPARENT_ALIAS (DECL_ASSEMBLER_NAME (cnode->decl)) = 1;
-	      TREE_CHAIN (DECL_ASSEMBLER_NAME (cnode->decl))
-		  = DECL_ASSEMBLER_NAME (cnode->orig_decl);
+	      /* Restore decl names reference except for wrapper functions.  */
+	      if (!chkp_wrap_function (cnode->orig_decl))
+		{
+		  tree name = DECL_ASSEMBLER_NAME (cnode->decl);
+		  IDENTIFIER_TRANSPARENT_ALIAS (name) = 1;
+		  TREE_CHAIN (name) = DECL_ASSEMBLER_NAME (cnode->orig_decl);
+		}
 	    }
 	}
 
diff -Naur gcc-5.2.0.orig/gcc/optabs.c gcc-5.2.0/gcc/optabs.c
--- gcc-5.2.0.orig/gcc/optabs.c	2015-07-02 10:42:37.000000000 -0500
+++ gcc-5.2.0/gcc/optabs.c	2015-10-27 09:03:27.514916000 -0500
@@ -7178,7 +7178,7 @@
   success = NULL_RTX;
   oldval = cmp_reg;
   if (!expand_atomic_compare_and_swap (&success, &oldval, mem, old_reg,
-				       new_reg, false, MEMMODEL_SEQ_CST,
+				       new_reg, false, MEMMODEL_SYNC_SEQ_CST,
 				       MEMMODEL_RELAXED))
     return false;
 
@@ -7239,9 +7239,7 @@
      exists, and the memory model is stronger than acquire, add a release 
      barrier before the instruction.  */
 
-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST
-      || (model & MEMMODEL_MASK) == MEMMODEL_RELEASE
-      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)
+  if (is_mm_seq_cst (model) || is_mm_release (model) || is_mm_acq_rel (model))
     expand_mem_thread_fence (model);
 
   if (icode != CODE_FOR_nothing)
@@ -7348,11 +7346,12 @@
   rtx ret;
 
   /* Try an atomic_exchange first.  */
-  ret = maybe_emit_atomic_exchange (target, mem, val, MEMMODEL_ACQUIRE);
+  ret = maybe_emit_atomic_exchange (target, mem, val, MEMMODEL_SYNC_ACQUIRE);
   if (ret)
     return ret;
 
-  ret = maybe_emit_sync_lock_test_and_set (target, mem, val, MEMMODEL_ACQUIRE);
+  ret = maybe_emit_sync_lock_test_and_set (target, mem, val,
+					   MEMMODEL_SYNC_ACQUIRE);
   if (ret)
     return ret;
 
@@ -7363,7 +7362,7 @@
   /* If there are no other options, try atomic_test_and_set if the value
      being stored is 1.  */
   if (val == const1_rtx)
-    ret = maybe_emit_atomic_test_and_set (target, mem, MEMMODEL_ACQUIRE);
+    ret = maybe_emit_atomic_test_and_set (target, mem, MEMMODEL_SYNC_ACQUIRE);
 
   return ret;
 }
@@ -7458,9 +7457,9 @@
 
    *PTARGET_BOOL is an optional place to store the boolean success/failure.
    *PTARGET_OVAL is an optional place to store the old value from memory.
-   Both target parameters may be NULL to indicate that we do not care about
-   that return value.  Both target parameters are updated on success to
-   the actual location of the corresponding result.
+   Both target parameters may be NULL or const0_rtx to indicate that we do
+   not care about that return value.  Both target parameters are updated on
+   success to the actual location of the corresponding result.
 
    MEMMODEL is the memory model variant to use.
 
@@ -7485,6 +7484,9 @@
   /* Make sure we always have some place to put the return oldval.
      Further, make sure that place is distinct from the input expected,
      just in case we need that path down below.  */
+  if (ptarget_oval && *ptarget_oval == const0_rtx)
+    ptarget_oval = NULL;
+
   if (ptarget_oval == NULL
       || (target_oval = *ptarget_oval) == NULL
       || reg_overlap_mentioned_p (expected, target_oval))
@@ -7495,6 +7497,9 @@
     {
       machine_mode bool_mode = insn_data[icode].operand[0].mode;
 
+      if (ptarget_bool && *ptarget_bool == const0_rtx)
+	ptarget_bool = NULL;
+
       /* Make sure we always have a place for the bool operand.  */
       if (ptarget_bool == NULL
 	  || (target_bool = *ptarget_bool) == NULL
@@ -7558,9 +7563,10 @@
   if (libfunc != NULL)
     {
       rtx addr = convert_memory_address (ptr_mode, XEXP (mem, 0));
-      target_oval = emit_library_call_value (libfunc, NULL_RTX, LCT_NORMAL,
-					     mode, 3, addr, ptr_mode,
-					     expected, mode, desired, mode);
+      rtx target = emit_library_call_value (libfunc, NULL_RTX, LCT_NORMAL,
+					    mode, 3, addr, ptr_mode,
+					    expected, mode, desired, mode);
+      emit_move_insn (target_oval, target);
 
       /* Compute the boolean return value only if requested.  */
       if (ptarget_bool)
@@ -7620,7 +7626,7 @@
 {
   if (HAVE_mem_thread_fence)
     emit_insn (gen_mem_thread_fence (GEN_INT (model)));
-  else if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED)
+  else if (!is_mm_relaxed (model))
     {
       if (HAVE_memory_barrier)
 	emit_insn (gen_memory_barrier ());
@@ -7644,7 +7650,7 @@
 {
   if (HAVE_mem_signal_fence)
     emit_insn (gen_mem_signal_fence (GEN_INT (model)));
-  else if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED)
+  else if (!is_mm_relaxed (model))
     {
       /* By default targets are coherent between a thread and the signal
 	 handler running on the same thread.  Thus this really becomes a
@@ -7699,7 +7705,7 @@
     target = gen_reg_rtx (mode);
 
   /* For SEQ_CST, emit a barrier before the load.  */
-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (model))
     expand_mem_thread_fence (model);
 
   emit_move_insn (target, mem);
@@ -7745,7 +7751,7 @@
 	  if (maybe_expand_insn (icode, 2, ops))
 	    {
 	      /* lock_release is only a release barrier.  */
-	      if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
+	      if (is_mm_seq_cst (model))
 		expand_mem_thread_fence (model);
 	      return const0_rtx;
 	    }
@@ -7772,7 +7778,7 @@
   emit_move_insn (mem, val);
 
   /* For SEQ_CST, also emit a barrier after the store.  */
-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)
+  if (is_mm_seq_cst (model))
     expand_mem_thread_fence (model);
 
   return const0_rtx;
diff -Naur gcc-5.2.0.orig/gcc/postreload.c gcc-5.2.0/gcc/postreload.c
--- gcc-5.2.0.orig/gcc/postreload.c	2015-06-08 12:09:08.000000000 -0500
+++ gcc-5.2.0/gcc/postreload.c	2015-07-17 08:50:38.038863000 -0500
@@ -2164,12 +2164,29 @@
 	 unknown values.  */
       if (CALL_P (insn))
 	{
+	  rtx link;
+
 	  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)
 	    {
 	      if (call_used_regs[i])
 		/* Reset the information about this register.  */
 		reg_mode[i] = VOIDmode;
 	    }
+
+	  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;
+	       link = XEXP (link, 1))
+	    {
+	      rtx setuse = XEXP (link, 0);
+	      rtx usage_rtx = XEXP (setuse, 0);
+	      if (GET_CODE (setuse) == CLOBBER
+		  && REG_P (usage_rtx))
+	        {
+		  unsigned int end_regno = END_REGNO (usage_rtx);
+		  for (unsigned int r = REGNO (usage_rtx); r < end_regno; ++r)
+		    /* Reset the information about this register.  */
+		    reg_mode[r] = VOIDmode;
+		}
+	    }
 	}
     }
   return changed;
diff -Naur gcc-5.2.0.orig/gcc/sched-deps.c gcc-5.2.0/gcc/sched-deps.c
--- gcc-5.2.0.orig/gcc/sched-deps.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/sched-deps.c	2015-09-30 11:39:44.799796000 -0500
@@ -56,6 +56,7 @@
 #include "params.h"
 #include "cselib.h"
 #include "ira.h"
+#include "ira-int.h"
 #include "target.h"
 
 #ifdef INSN_SCHEDULING
@@ -2907,7 +2908,8 @@
 
       extract_insn (insn);
       preprocess_constraints (insn);
-      ira_implicitly_set_insn_hard_regs (&temp);
+      alternative_mask prefrred = get_preferred_alternatives (insn);
+      ira_implicitly_set_insn_hard_regs (&temp, prefrred);
       AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);
       IOR_HARD_REG_SET (implicit_reg_pending_clobbers, temp);
     }
diff -Naur gcc-5.2.0.orig/gcc/sel-sched.c gcc-5.2.0/gcc/sel-sched.c
--- gcc-5.2.0.orig/gcc/sel-sched.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/sel-sched.c	2015-09-30 11:39:44.799796000 -0500
@@ -54,6 +54,7 @@
 #include "rtlhooks-def.h"
 #include "emit-rtl.h"
 #include "ira.h"
+#include "ira-int.h"
 #include "rtl-iter.h"
 
 #ifdef INSN_SCHEDULING
@@ -2124,7 +2125,8 @@
   /* Calculate implicit clobbers.  */
   extract_insn (insn);
   preprocess_constraints (insn);
-  ira_implicitly_set_insn_hard_regs (&temp);
+  alternative_mask prefrred = get_preferred_alternatives (insn);
+  ira_implicitly_set_insn_hard_regs (&temp, prefrred);
   AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);
 
   /* If any implicit clobber registers intersect with regular ones in
diff -Naur gcc-5.2.0.orig/gcc/stor-layout.c gcc-5.2.0/gcc/stor-layout.c
--- gcc-5.2.0.orig/gcc/stor-layout.c	2015-03-04 16:33:41.000000000 -0600
+++ gcc-5.2.0/gcc/stor-layout.c	2015-08-17 10:44:35.750755000 -0500
@@ -1831,9 +1831,13 @@
 	{
 	  TYPE_SIZE (variant) = size;
 	  TYPE_SIZE_UNIT (variant) = size_unit;
-	  TYPE_ALIGN (variant) = align;
+	  unsigned valign = align;
+	  if (TYPE_USER_ALIGN (variant))
+	    valign = MAX (valign, TYPE_ALIGN (variant));
+	  else
+	    TYPE_USER_ALIGN (variant) = user_align;
+	  TYPE_ALIGN (variant) = valign;
 	  TYPE_PRECISION (variant) = precision;
-	  TYPE_USER_ALIGN (variant) = user_align;
 	  SET_TYPE_MODE (variant, mode);
 	}
     }
@@ -2154,6 +2158,10 @@
   if (type == error_mark_node)
     return;
 
+  /* We don't want finalize_type_size to copy an alignment attribute to
+     variants that don't have it.  */
+  type = TYPE_MAIN_VARIANT (type);
+
   /* Do nothing if type has been laid out before.  */
   if (TYPE_SIZE (type))
     return;
@@ -2350,13 +2358,17 @@
 	/* Now round the alignment and size,
 	   using machine-dependent criteria if any.  */
 
+	unsigned align = TYPE_ALIGN (element);
+	if (TYPE_USER_ALIGN (type))
+	  align = MAX (align, TYPE_ALIGN (type));
+	else
+	  TYPE_USER_ALIGN (type) = TYPE_USER_ALIGN (element);
 #ifdef ROUND_TYPE_ALIGN
-	TYPE_ALIGN (type)
-	  = ROUND_TYPE_ALIGN (type, TYPE_ALIGN (element), BITS_PER_UNIT);
+	align = ROUND_TYPE_ALIGN (type, align, BITS_PER_UNIT);
 #else
-	TYPE_ALIGN (type) = MAX (TYPE_ALIGN (element), BITS_PER_UNIT);
+	align = MAX (align, BITS_PER_UNIT);
 #endif
-	TYPE_USER_ALIGN (type) = TYPE_USER_ALIGN (element);
+	TYPE_ALIGN (type) = align;
 	SET_TYPE_MODE (type, BLKmode);
 	if (TYPE_SIZE (type) != 0
 	    && ! targetm.member_type_forces_blk (type, VOIDmode)
diff -Naur gcc-5.2.0.orig/gcc/target-globals.c gcc-5.2.0/gcc/target-globals.c
--- gcc-5.2.0.orig/gcc/target-globals.c	2015-01-15 07:28:42.000000000 -0600
+++ gcc-5.2.0/gcc/target-globals.c	2015-09-30 11:39:44.799796000 -0500
@@ -57,6 +57,7 @@
 #include "optabs.h"
 #include "libfuncs.h"
 #include "cfgloop.h"
+#include "recog.h"
 #include "ira-int.h"
 #include "builtins.h"
 #include "gcse.h"
diff -Naur gcc-5.2.0.orig/gcc/testsuite/c-c++-common/gomp/pr67501.c gcc-5.2.0/gcc/testsuite/c-c++-common/gomp/pr67501.c
--- gcc-5.2.0.orig/gcc/testsuite/c-c++-common/gomp/pr67501.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/c-c++-common/gomp/pr67501.c	2015-09-09 02:31:43.640363000 -0500
@@ -0,0 +1,12 @@
+/* PR c/67501 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+void
+foo (void)
+{
+  int i, j;
+  #pragma omp for simd copyprivate(j	/* { dg-error "before end of line" } */
+  for (i = 0; i < 16; ++i)		/* { dg-error "is not valid for" "" { target *-*-* } 9 } */
+    ;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/c-c++-common/gomp/pr67502.c gcc-5.2.0/gcc/testsuite/c-c++-common/gomp/pr67502.c
--- gcc-5.2.0.orig/gcc/testsuite/c-c++-common/gomp/pr67502.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/c-c++-common/gomp/pr67502.c	2015-09-10 02:37:00.176754000 -0500
@@ -0,0 +1,16 @@
+/* PR c/67502 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+/* { dg-additional-options "-std=c99" { target c } } */
+
+void bar (int, int);
+
+void
+foo (void)
+{
+#pragma omp parallel
+#pragma omp for simd collapse(2)
+  for (int i = 0; i < 16; ++i)
+    for (int j = 0; j < 16; ++j)
+      bar (i, j);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/c-c++-common/gomp/pr67517.c gcc-5.2.0/gcc/testsuite/c-c++-common/gomp/pr67517.c
--- gcc-5.2.0.orig/gcc/testsuite/c-c++-common/gomp/pr67517.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/c-c++-common/gomp/pr67517.c	2015-09-10 02:39:20.440501000 -0500
@@ -0,0 +1,13 @@
+/* PR middle-end/67517 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+int
+foo (int x, int y, int z)
+{
+  int i;
+  #pragma omp parallel for simd linear (y : x & 15) linear (x : 16) linear (z : x & 15)
+  for (i = 0; i < 256; ++i)
+    x += 16, y += x & 15, z += x & 15;
+  return x + y + z;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/c-c++-common/gomp/pr67521.c gcc-5.2.0/gcc/testsuite/c-c++-common/gomp/pr67521.c
--- gcc-5.2.0.orig/gcc/testsuite/c-c++-common/gomp/pr67521.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/c-c++-common/gomp/pr67521.c	2015-09-10 02:39:53.789619000 -0500
@@ -0,0 +1,20 @@
+/* PR middle-end/67521 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+void
+foo (int x)
+{
+  int i = 0;
+  #pragma omp parallel for simd
+  for (i = (i & x); i < 10; i = i + 2)
+    ;
+  i = 0;
+  #pragma omp parallel for simd
+  for (i = 0; i < (i & x) + 10; i = i + 2)
+    ;
+  i = 0;
+  #pragma omp parallel for simd
+  for (i = 0; i < 10; i = i + ((i & x) + 2))
+    ;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/c-c++-common/ubsan/pr64906.c gcc-5.2.0/gcc/testsuite/c-c++-common/ubsan/pr64906.c
--- gcc-5.2.0.orig/gcc/testsuite/c-c++-common/ubsan/pr64906.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/c-c++-common/ubsan/pr64906.c	2015-09-25 05:46:03.665534000 -0500
@@ -0,0 +1,12 @@
+/* PR sanitizer/64906 */
+/* { dg-do compile } */
+/* { dg-options "-fsanitize=integer-divide-by-zero -O -Werror=maybe-uninitialized" } */
+
+int
+fn1 (int f, int s)
+{
+  int ret = 0;
+  if (f)
+    ret = s / (f ? (unsigned long) 8 : 0);
+  return ret;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/c-c++-common/ubsan/pr66908.c gcc-5.2.0/gcc/testsuite/c-c++-common/ubsan/pr66908.c
--- gcc-5.2.0.orig/gcc/testsuite/c-c++-common/ubsan/pr66908.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/c-c++-common/ubsan/pr66908.c	2015-08-11 10:46:56.277876000 -0500
@@ -0,0 +1,15 @@
+/* PR sanitizer/66908 */
+/* { dg-do compile } */
+/* { dg-options "-fsanitize=shift,bounds -O2 -Werror=maybe-uninitialized" } */
+/* { dg-additional-options "-std=gnu90" { target c } } */
+
+struct S { int a[22]; };
+static int const e[22] = { };
+
+void
+foo (struct S const *s, unsigned int m, unsigned int *res)
+{
+  unsigned int i;
+  for (i = 0; i < 22; ++i)
+    res[i] = ((s->a[i] + e[i]) << m);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.c-torture/compile/pr67143.c gcc-5.2.0/gcc/testsuite/gcc.c-torture/compile/pr67143.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.c-torture/compile/pr67143.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.c-torture/compile/pr67143.c	2015-09-23 04:48:16.591988000 -0500
@@ -0,0 +1,21 @@
+long a, c;
+int b;
+int d;
+void ut_dbg_assertion_failed() __attribute__((noreturn));
+long dict_index_is_spatial(int *);
+void btr_block_get_func(char *);
+long btr_page_get_level_low(unsigned char *);
+void btr_validate_level(long p1) {
+  unsigned char *e;
+  while (p1 != btr_page_get_level_low(e)) {
+    if (__builtin_expect(b, 0))
+      ut_dbg_assertion_failed();
+    if (dict_index_is_spatial(&d))
+      while (c != 5535) {
+        __sync_add_and_fetch(&a, 536870912);
+        btr_block_get_func("");
+      }
+  }
+  for (long i; i; ++i)
+    btr_validate_level(-i);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.c-torture/compile/pr67506.c gcc-5.2.0/gcc/testsuite/gcc.c-torture/compile/pr67506.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.c-torture/compile/pr67506.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.c-torture/compile/pr67506.c	2015-09-10 10:07:02.772049000 -0500
@@ -0,0 +1,53 @@
+extern struct _IO_FILE *stderr;
+typedef long integer;
+typedef unsigned char byte;
+short nl;
+byte * tfmfilearray;
+integer charbase, ligkernbase;
+unsigned char charsonline;
+short c;
+unsigned short r;
+struct {
+  short cc;
+  integer rr;
+} labeltable[259];
+short sortptr;
+unsigned char activity[(32510) + 1];
+integer ai, acti;
+extern void _IO_putc (char, struct _IO_FILE *);
+
+void
+mainbody (void)
+{
+  register integer for_end;
+  if (c <= for_end)
+    do {
+      if (((tfmfilearray + 1001)[4 * (charbase + c) + 2] % 4) == 1)
+	{
+	  if ( r < nl )
+	    ;
+	  else
+	    {
+	      while (labeltable[sortptr ].rr > r)
+		labeltable[sortptr + 1 ]= labeltable[sortptr];
+	    }
+	}
+    } while (c++ < for_end);
+
+  if (ai <= for_end)
+    do {
+      if (activity[ai]== 2)
+	{
+	  r = (tfmfilearray + 1001)[4 * (ligkernbase + (ai))];
+	  if (r < 128)
+	    {
+	      r = r + ai + 1 ;
+	      if (r >= nl)
+		{
+		  if (charsonline > 0)
+		    _IO_putc ('\n', stderr);
+		}
+	    }
+	}
+    } while (ai++ < for_end);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/gomp/pr67495.c gcc-5.2.0/gcc/testsuite/gcc.dg/gomp/pr67495.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/gomp/pr67495.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/gomp/pr67495.c	2015-09-09 02:27:15.582643000 -0500
@@ -0,0 +1,38 @@
+/* PR c/67495 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+int a, b, c;
+
+void
+foo (void)
+{
+#pragma omp atomic capture
+  a = (float)a + b;	/* { dg-error "invalid operator" } */
+#pragma omp atomic read
+  (float) a = b;	/* { dg-error "lvalue required" } */
+#pragma omp atomic write
+  (float) a = b;	/* { dg-error "lvalue required" } */
+#pragma omp atomic read
+  a = (float) b;	/* { dg-error "lvalue required" } */
+#pragma omp atomic capture
+  (float) a = b += c;	/* { dg-error "lvalue required" } */
+#pragma omp atomic capture
+  { a += b; (float) c = a; }	/* { dg-error "lvalue required" } */
+#pragma omp atomic capture
+  { a += b; c = (float) a; }	/* { dg-error "uses two different expressions for memory" } */
+#pragma omp atomic capture
+  a = (int)a + b;	/* { dg-error "invalid operator" } */
+#pragma omp atomic read
+  (int) a = b;		/* { dg-error "lvalue required" } */
+#pragma omp atomic write
+  (int) a = b;		/* { dg-error "lvalue required" } */
+#pragma omp atomic read
+  a = (int) b;		/* { dg-error "lvalue required" } */
+#pragma omp atomic capture
+  (int) a = b += c;	/* { dg-error "lvalue required" } */
+#pragma omp atomic capture
+  { a += b; (int) c = a; }	/* { dg-error "lvalue required" } */
+#pragma omp atomic capture
+  { a += b; c = (int) a; }	/* { dg-error "lvalue required" } */
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/gomp/pr67500.c gcc-5.2.0/gcc/testsuite/gcc.dg/gomp/pr67500.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/gomp/pr67500.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/gomp/pr67500.c	2015-09-09 02:30:42.229662000 -0500
@@ -0,0 +1,42 @@
+/* PR c/67500 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+#pragma omp declare simd simdlen(d)	/* { dg-error "clause expression must be positive constant integer expression" } */
+void f1 (int);				/* { dg-error "undeclared here" "" { target *-*-* } 5 } */
+#pragma omp declare simd simdlen(0.5)	/* { dg-error "clause expression must be positive constant integer expression" } */
+void f2 (int);
+#pragma omp declare simd simdlen(-2)	/* { dg-error "clause expression must be positive constant integer expression" } */
+void f3 (int);
+#pragma omp declare simd simdlen(0)	/* { dg-error "clause expression must be positive constant integer expression" } */
+void f4 (int);
+
+void
+foo (int *p)
+{
+  int i;
+  #pragma omp simd safelen(d)		/* { dg-error "must be positive constant integer expression" } */
+  for (i = 0; i < 16; ++i)		/* { dg-error "undeclared" "" { target *-*-* } 18 } */
+    ;
+  #pragma omp simd safelen(0.5)		/* { dg-error "must be positive constant integer expression" } */
+  for (i = 0; i < 16; ++i)
+    ;
+  #pragma omp simd safelen(-2)		/* { dg-error "must be positive constant integer expression" } */
+  for (i = 0; i < 16; ++i)
+    ;
+  #pragma omp simd safelen(0)		/* { dg-error "must be positive constant integer expression" } */
+  for (i = 0; i < 16; ++i)
+    ;
+  #pragma omp simd aligned(p:d)		/* { dg-error "must be positive constant integer expression" } */
+  for (i = 0; i < 16; ++i)
+    ;
+  #pragma omp simd aligned(p:0.5)	/* { dg-error "must be positive constant integer expression" } */
+  for (i = 0; i < 16; ++i)
+    ;
+  #pragma omp simd aligned(p:-2)	/* { dg-error "must be positive constant integer expression" } */
+  for (i = 0; i < 16; ++i)
+    ;
+  #pragma omp simd aligned(p:0)		/* { dg-error "must be positive constant integer expression" } */
+  for (i = 0; i < 16; ++i)
+    ;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/block-1.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/block-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/block-1.c	2011-01-25 00:46:31.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/block-1.c	2015-07-25 03:33:05.285601000 -0500
@@ -45,5 +45,5 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "will be loop blocked" 3 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be loop blocked" 3 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/graphite.exp gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/graphite.exp
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/graphite.exp	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/graphite.exp	2015-07-25 03:33:05.285601000 -0500
@@ -41,8 +41,10 @@
 set scop_files        [lsort [glob -nocomplain $srcdir/$subdir/scop-*.c ] ]
 set id_files          [lsort [glob -nocomplain $srcdir/$subdir/id-*.c ] ]
 set run_id_files      [lsort [glob -nocomplain $srcdir/$subdir/run-id-*.c ] ]
-set interchange_files [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.c ] ]
-set block_files       [lsort [glob -nocomplain $srcdir/$subdir/block-*.c ] ]
+set interchange_files [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.c \
+			      $srcdir/$subdir/uns-interchange-*.c ] ]
+set block_files       [lsort [glob -nocomplain $srcdir/$subdir/block-*.c \
+			      $srcdir/$subdir/uns-block-*.c ] ]
 set vect_files        [lsort [glob -nocomplain $srcdir/$subdir/vect-*.c ] ]
 
 # Tests to be compiled.
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-12.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-12.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-12.c	2011-01-25 00:46:31.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-12.c	2015-07-25 03:33:05.285601000 -0500
@@ -53,5 +53,5 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-14.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-14.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-14.c	2011-10-04 09:02:29.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-14.c	2015-07-25 03:33:05.285601000 -0500
@@ -55,5 +55,5 @@
 }
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-15.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-15.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-15.c	2011-10-04 09:02:29.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-15.c	2015-07-25 03:33:05.285601000 -0500
@@ -49,6 +49,6 @@
 }
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
 
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-9.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-9.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-9.c	2010-08-11 18:38:53.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-9.c	2015-07-25 03:33:05.285601000 -0500
@@ -44,5 +44,5 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-mvt.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-mvt.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/interchange-mvt.c	2011-10-04 09:02:29.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/interchange-mvt.c	2015-07-25 03:33:05.285601000 -0500
@@ -59,6 +59,6 @@
 }
 
 /* PRE destroys the perfect nest and we can't cope with that yet.  */
-/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "graphite" } } */
 
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-block-1.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-block-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-block-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-block-1.c	2015-07-25 03:33:05.285601000 -0500
@@ -0,0 +1,49 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define MAX 100
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned int sum = 0;
+  unsigned int A[MAX * MAX];
+  unsigned int B[MAX * MAX];
+
+  /* These loops should be loop blocked.  */
+  for (i = 0; i < MAX; i++)
+    for (j = 0; j < MAX; j++)
+      {
+	A[i*MAX + j] = j;
+	B[i*MAX + j] = j;
+      }
+
+  /* These loops should be loop blocked.  */
+  for (i = 0; i < MAX; i++)
+    for (j = 0; j < MAX; j++)
+      A[i*MAX + j] += B[j*MAX + i];
+
+  /* These loops should be loop blocked.  */
+  for (i = 0; i < MAX; i++)
+    for (j = 0; j < MAX; j++)
+      sum += A[i*MAX + j];
+
+#if DEBUG
+  fprintf (stderr, "sum = %d \n", sum);
+#endif
+
+  if (sum != 990000)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "will be loop blocked" 3 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c	2015-07-25 03:33:05.285601000 -0500
@@ -0,0 +1,58 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define N 200
+
+unsigned int A[N][N], B[N][N], C[N][N];
+
+static unsigned int __attribute__((noinline))
+matmult (void)
+{
+  int i, j, k;
+
+  /* Loops J and K should be interchanged.  */
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      {
+	A[i][j] = 0;
+	for (k = 0; k < N; k++)
+	  A[i][j] += B[i][k] * C[k][j];
+      }
+
+  return A[0][0] + A[N-1][N-1];
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned int res;
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      {
+	A[i][j] = 0;
+	B[i][j] = i - j;
+	C[i][j] = i + j;
+      }
+
+  res = matmult ();
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 2626800)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c	2015-07-25 03:33:05.285601000 -0500
@@ -0,0 +1,60 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define N 200
+
+unsigned int A[N][N], B[N][N], C[N][N];
+
+static void __attribute__((noinline))
+matmult (void)
+{
+  int i, j, k;
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      A[i][j] = 0;
+
+  /* Loops J and K should be interchanged.  */
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      for (k = 0; k < N; k++)
+	A[i][j] += B[i][k] * C[k][j];
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned res = 0;
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      {
+	B[i][j] = j;
+	C[i][j] = i;
+      }
+
+  matmult ();
+
+  for (i = 0; i < N; i++)
+    res += A[i][i];
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 529340000)
+    abort ();
+
+  return 0;
+}
+
+/* PRE destroys the perfect nest and we can't cope with that yet.  */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c	2015-07-25 03:33:05.285601000 -0500
@@ -0,0 +1,55 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define NMAX 2000
+
+static unsigned int x[NMAX], a[NMAX][NMAX];
+
+static unsigned int __attribute__((noinline))
+mvt (long N)
+{
+  int i,j;
+
+  /* These two loops should be interchanged.  */
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      x[i] += a[j][i];
+
+  return x[1];
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned int res;
+
+  for (i = 0; i < NMAX; i++)
+    for (j = 0; j < NMAX; j++)
+      a[i][j] = j;
+
+  for (i = 0; i < NMAX; i++)
+    x[i] = i;
+
+  res = mvt (NMAX);
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 2001)
+    abort ();
+
+  return 0;
+}
+
+/* PRE destroys the perfect nest and we can't cope with that yet.  */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
+
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c	2015-07-25 03:33:05.285601000 -0500
@@ -0,0 +1,49 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define N 111
+#define M 111
+
+static unsigned int __attribute__((noinline))
+foo (unsigned int *x)
+{
+  int i, j;
+  unsigned int sum = 0;
+
+  for (j = 0; j < M; ++j)
+    for (i = 0;  i < N; ++i)
+      sum += x[M * i + j];
+
+  return sum;
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  unsigned int A[N*M];
+  int i;
+  unsigned int res;
+
+  for (i = 0; i < N*M; i++)
+    A[i] = 2;
+
+  res = foo (A);
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 24642)
+    abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c	2015-07-25 03:33:05.285601000 -0500
@@ -0,0 +1,65 @@
+/* { dg-require-effective-target size32plus } */
+
+#define DEBUG 0
+#if DEBUG
+#include <stdio.h>
+#endif
+
+#define NMAX 2000
+
+static unsigned int x1[NMAX], x2[NMAX], a[NMAX][NMAX], y1[NMAX], y2[NMAX];
+
+static unsigned int __attribute__((noinline))
+mvt (long N)
+{
+
+  int i,j;
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      x1[i] = x1[i] + a[i][j] * y1[j];
+
+  /* These two loops should be interchanged.  */
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      x2[i] = x2[i] + a[j][i] * y2[j];
+
+  return x1[0] + x2[0];
+}
+
+extern void abort ();
+
+int
+main (void)
+{
+  int i, j;
+  unsigned int res;
+
+  for (i = 0; i < NMAX; i++)
+    for (j = 0; j < NMAX; j++)
+      a[i][j] = i + j;
+
+  for (i = 0; i < NMAX; i++)
+    {
+      x1[i] = 0;
+      x2[i] = 2*i;
+      y1[i] = 100 - i;
+      y2[i] = i;
+    }
+
+  res = mvt (NMAX);
+
+#if DEBUG
+  fprintf (stderr, "res = %d \n", res);
+#endif
+
+  if (res != 199900000)
+    abort ();
+
+  return 0;
+}
+
+/* PRE destroys the perfect nest and we can't cope with that yet.  */
+/* { dg-final { scan-tree-dump-times "will be interchanged" 1 "graphite" } } */
+/* { dg-final { cleanup-tree-dump "graphite" } } */
+
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/ipa/ipa-sra-10.c gcc-5.2.0/gcc/testsuite/gcc.dg/ipa/ipa-sra-10.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/ipa/ipa-sra-10.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/ipa/ipa-sra-10.c	2015-10-26 09:36:43.071349000 -0500
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fipa-sra -fdump-tree-eipa_sra-details"  } */
+
+extern void consume (int);
+extern int glob, glob1, glob2;
+extern int get (void);
+
+
+static void __attribute__ ((noinline))
+foo (int a)
+{
+  a = glob;
+  consume (a);
+  a = get ();
+  consume (a);
+  __asm__ volatile("" : : ""(a));
+  consume (a);
+
+  if (glob1)
+    a = glob1;
+  else
+    a = glob2;
+  consume (a);
+}
+
+int
+bar (int a)
+{
+  foo (a);
+  glob = a;
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "replacing an SSA name of a removed param" 4 "eipa_sra" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/lto/chkp-removed-alias_0.c gcc-5.2.0/gcc/testsuite/gcc.dg/lto/chkp-removed-alias_0.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/lto/chkp-removed-alias_0.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/lto/chkp-removed-alias_0.c	2015-07-23 05:00:04.301497000 -0500
@@ -0,0 +1,28 @@
+/* { dg-lto-do link } */
+/* { dg-require-effective-target mpx } */
+/* { dg-lto-options { { -O2 -flto -flto-partition=max -fcheck-pointer-bounds -mmpx } } } */
+
+int test1 (const char *c)
+{
+  return c[0] * 2;
+}
+
+int test2 (const char *c)
+{
+  return c[1] * 3;
+}
+
+int test1_alias (const char *c) __attribute__ ((alias ("test1")));
+int test2_alias (const char *c) __attribute__ ((alias ("test2")));
+
+struct S
+{
+  int (*fnptr[2]) (const char *);
+} S;
+
+struct S s = {test1_alias, test2_alias};
+
+int main (int argc, const char **argv)
+{
+  return s.fnptr[argc] (argv[0]);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/lto/chkp-wrap-asm-name_0.c gcc-5.2.0/gcc/testsuite/gcc.dg/lto/chkp-wrap-asm-name_0.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/lto/chkp-wrap-asm-name_0.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/lto/chkp-wrap-asm-name_0.c	2015-07-23 05:09:10.443079000 -0500
@@ -0,0 +1,20 @@
+/* { dg-lto-do link } */
+/* { dg-require-effective-target mpx } */
+/* { dg-lto-options { { -O2 -flto -fcheck-pointer-bounds -mmpx } } } */
+
+typedef long unsigned int size_t;
+
+extern size_t strlen (const char *);
+extern __typeof (strlen) strlen __asm__ ("" "__hidden_strlen") __attribute__ ((visibility ("hidden")));
+
+size_t
+test1 (const char *p) { return strlen (p); }
+
+size_t
+test2 (const char *p) { return __builtin_strlen (p); }
+
+int
+main (int argc, const char **argv)
+{
+  return test1 (argv[0]) - test2 (argv[0]);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/lto/pr55113_0.c gcc-5.2.0/gcc/testsuite/gcc.dg/lto/pr55113_0.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/lto/pr55113_0.c	2014-04-14 07:52:00.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/lto/pr55113_0.c	2015-10-01 08:02:58.771920000 -0500
@@ -1,8 +1,7 @@
 /* PR 55113 */
 /* { dg-lto-do link } */
 /* { dg-lto-options { { -flto -fshort-double -O0 } } }*/
-/* { dg-skip-if "PR60410" { x86_64-*-* || { i?86-*-* && lp64 } } } */
-/* { dg-skip-if "PR60410" { i?86-*-solaris2.1[0-9]* } } */
+/* { dg-skip-if "PR60410" { i?86-*-* x86_64-*-* } } */
 
 int 
 main(void)
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/lto/pr67452_0.c gcc-5.2.0/gcc/testsuite/gcc.dg/lto/pr67452_0.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/lto/pr67452_0.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/lto/pr67452_0.c	2015-09-04 13:36:59.211750000 -0500
@@ -0,0 +1,23 @@
+/* { dg-lto-do link } */
+/* { dg-lto-options { { -O2 -flto -fopenmp-simd } } } */
+
+float b[3][3];
+
+__attribute__((used, noinline)) void
+foo ()
+{
+  int v1, v2;
+#pragma omp simd collapse(2)
+  for (v1 = 0; v1 < 3; v1++)
+    for (v2 = 0; v2 < 3; v2++)
+      b[v1][v2] = 2.5;
+}
+
+int
+main ()
+{
+  asm volatile ("" : : "g" (b) : "memory");
+  foo ();
+  asm volatile ("" : : "g" (b) : "memory");
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pie-link.c gcc-5.2.0/gcc/testsuite/gcc.dg/pie-link.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pie-link.c	2011-06-10 09:31:31.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pie-link.c	2015-09-11 06:17:33.650504000 -0500
@@ -1,5 +1,5 @@
 /* { dg-do link { target pie } } */
-/* { dg-options "-fpie" } */
+/* { dg-options "-fpie -pie" } */
 
 int main(void)
 {
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67028.c gcc-5.2.0/gcc/testsuite/gcc.dg/pr67028.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67028.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67028.c	2015-08-18 07:21:41.551020000 -0500
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+short c = 0;
+
+int __attribute__ ((noinline)) f(void)
+{
+	int d = 5;
+	signed char e = (c != 1) * -2;
+	int a = (unsigned short)e > d;
+
+	return a;
+}
+
+int main(void)
+{
+	if (!f())
+		__builtin_abort();
+
+	return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67029.c gcc-5.2.0/gcc/testsuite/gcc.dg/pr67029.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67029.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67029.c	2015-09-30 11:39:44.799796000 -0500
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { int128 && scheduling } } } */
+/* { dg-options "-O2 -fschedule-insns" } */
+/* { dg-additional-options "-fstack-protector" { target fstack_protector } } */
+
+extern void fn2 (char *);
+__int128 a, b;
+int
+fn1 (void)
+{
+  char e[32];
+  fn2 (e);
+  b = 9 * (a >> 1);
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67271.c gcc-5.2.0/gcc/testsuite/gcc.dg/pr67271.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67271.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67271.c	2015-09-21 04:55:57.657387000 -0500
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern long int labs (long int j);
+int
+main ()
+{
+  long *a = (long *)"empty";
+  int i = 1441516387;
+  a[i] = labs (a[i]);
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67512.c gcc-5.2.0/gcc/testsuite/gcc.dg/pr67512.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67512.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67512.c	2015-09-09 12:14:29.966193000 -0500
@@ -0,0 +1,15 @@
+/* PR middle-end/67512 */
+/* { dg-do compile }  */
+/* { dg-options "-O -Wuninitialized" } */
+
+extern int fn2 (void);
+extern int fn3 (int);
+void
+fn1 (void)
+{
+  int z, m;
+  if (1 & m) /* { dg-warning "is used uninitialized" } */
+    z = fn2 ();
+  z = 1 == m ? z : 2 == m;
+  fn3 (z);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67563.c gcc-5.2.0/gcc/testsuite/gcc.dg/pr67563.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67563.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67563.c	2015-10-06 05:19:54.537907000 -0500
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fexceptions" } */
+
+static void
+emit_package (int p1)
+{
+  int a;
+  int b[0];
+  a = __fprintf_chk (0, 0, "");
+}
+void emit_lua () { emit_package (0); }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67730-1.c gcc-5.2.0/gcc/testsuite/gcc.dg/pr67730-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67730-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67730-1.c	2015-10-05 07:35:20.216307000 -0500
@@ -0,0 +1,16 @@
+/* PR c/67730 */
+/* { dg-do compile } */
+/* { dg-options "-Wc++-compat" } */
+
+#include "pr67730.h"
+
+extern void bar (unsigned char *);
+
+unsigned char *
+f (void *p)
+{
+   unsigned char *uc = ONEP; /* { dg-warning "request for implicit conversion" } */
+   uc = ONEP; /* { dg-warning "request for implicit conversion" } */
+   bar (ONEP); /* { dg-warning "request for implicit conversion" } */
+   return ONEP; /* { dg-warning "request for implicit conversion" } */
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67730-2.c gcc-5.2.0/gcc/testsuite/gcc.dg/pr67730-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67730-2.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67730-2.c	2015-10-05 07:35:20.216307000 -0500
@@ -0,0 +1,22 @@
+/* PR c/67730 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#include "pr67730.h"
+
+extern void bar (int);
+
+int
+fn1 (void)
+{
+  int a = NULL; /* { dg-warning "initialization makes integer from pointer" } */
+  a = NULL; /* { dg-warning "assignment makes integer from pointer" } */
+  bar (NULL); /* { dg-warning "passing argument 1" } */
+  return NULL; /* { dg-warning "return makes integer from pointer" } */
+}
+
+int
+fn2 (void)
+{
+  RETURN; /* { dg-warning "return makes integer from pointer" } */
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67730.c gcc-5.2.0/gcc/testsuite/gcc.dg/pr67730.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67730.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67730.c	2015-09-30 07:21:03.995567000 -0500
@@ -0,0 +1,11 @@
+/* PR c/67730 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#include <stddef.h>
+
+void
+fn1 (void)
+{
+  return NULL; /* { dg-warning "10:.return. with a value" } */
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67730.h gcc-5.2.0/gcc/testsuite/gcc.dg/pr67730.h
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/pr67730.h	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/pr67730.h	2015-10-05 07:35:20.216307000 -0500
@@ -0,0 +1,32 @@
+#pragma GCC system_header
+#define NULL (void *) 0
+#define ONEP (void *) 1
+#define RETURN return NULL
+
+extern void sysbar (unsigned char *);
+
+unsigned char *
+sysfn1 (void *p)
+{
+   unsigned char *uc = ONEP;
+   uc = ONEP;
+   sysbar (ONEP);
+   return ONEP;
+}
+
+extern void sysbar2 (int);
+
+int
+sysfn2 (void)
+{
+  int a = NULL;
+  a = NULL;
+  sysbar2 (NULL);
+  return NULL;
+}
+
+int
+sysfn3 (void)
+{
+  RETURN;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr66793.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr66793.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr66793.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr66793.c	2015-09-21 04:55:57.657387000 -0500
@@ -0,0 +1,26 @@
+/* { dg-do link } */
+
+int a, b, c; 
+
+struct S0
+{
+  int f1;
+} *d; 
+
+void
+fn1 (struct S0 p)
+{
+  for (p.f1 = 0; p.f1 < 1; p.f1++)
+    c = a && b ? a && b : 1; 
+  for (; c;)
+    ;
+}
+
+int
+main ()
+{
+  struct S0 **f = &d;
+  d = 0; 
+  fn1 (**f); 
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr66952.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr66952.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr66952.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr66952.c	2015-09-22 02:47:21.675222000 -0500
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+
+int a = 128, b;
+
+static int
+fn1 (signed char p1, int p2)
+{
+  return p1 < 0 || p1 > 1 >> p2 ? 0 : p1 << 1;
+}
+
+static int
+fn2 ()
+{
+  signed char c = a;
+  b = fn1 (c, 1);
+  if ((128 | c) < 0 ? 1 : 0)
+    return 1;
+  return 0;
+}
+
+int
+main ()
+{
+  if (fn2 () != 1)
+    __builtin_abort ();
+
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67005.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67005.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67005.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67005.c	2015-08-31 07:46:14.348813000 -0500
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+int a;
+void
+f (void)
+{
+  if (!a);
+  else
+  lbl:
+    a = a;
+
+  if (a)
+    a = 8;
+  goto lbl;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67121.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67121.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67121.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67121.c	2015-09-21 04:55:57.657387000 -0500
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+int a[6], b, c = 226, d, e, f;
+signed char g;
+
+void
+fn1 (int p1)
+{
+  b = a[p1];
+}
+
+int
+main ()
+{
+  a[0] = 1;
+  for (f = 0; f < 9; f++)
+    {
+      signed char h = c;
+      int i = 1;
+      g = h < 0 ? h : h >> i;
+      e = g;
+      for (d = 1; d; d = 0)
+	;
+    }
+  fn1 (g >> 8 & 1);
+
+  if (b != 0) 
+    __builtin_abort (); 
+
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67222.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67222.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67222.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67222.c	2015-09-17 07:50:54.117834000 -0500
@@ -0,0 +1,19 @@
+/* PR middle-end/67222 */
+/* { dg-do compile } */
+
+void
+foo (void **p)
+{
+  posix_memalign (); /* { dg-warning "implicit declaration" } */
+  posix_memalign (p);
+  posix_memalign (0);
+  posix_memalign (p, 1);
+  posix_memalign (p, "foo");
+  posix_memalign ("gnu", "gcc");
+  posix_memalign (1, p);
+  posix_memalign (1, 2);
+  posix_memalign (1, 2, 3);
+  posix_memalign (p, p, p);
+  posix_memalign (p, "qui", 3);
+  posix_memalign (p, 1, 2);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67442.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67442.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67442.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67442.c	2015-09-28 05:45:55.478232000 -0500
@@ -0,0 +1,12 @@
+/* { dg-do run } */
+
+short foo[100];
+
+int main()
+{
+  short* bar = &foo[50];
+  short i = 1;
+  short j = 1;
+  short value = bar[8 - i * 2 * j];
+  return value;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67470.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67470.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67470.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67470.c	2015-09-21 04:55:57.657387000 -0500
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+
+int a, b, *c, d, e;
+
+void abort (void);
+
+int
+main ()
+{
+  int f, *g, **h = &g;
+  for (; b;)
+    {
+      c = &a;
+      for (e = 0; e < 1; e++)
+	*h = 0;
+      for (; d; d++)
+	if (f)
+	  *c = 0;
+	else
+	  {
+	    *c = e = 0;
+	    *h = &a;
+	  }
+
+      if (a && !g)
+	abort ();
+
+    }
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67619.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67619.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67619.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67619.c	2015-09-21 10:23:52.542487000 -0500
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target builtin_eh_return } */
+
+void
+foo ()
+{
+  unsigned long l;
+  void *p = 0; 
+
+  __builtin_unwind_init ();
+  l = 0; 
+  __builtin_eh_return (l, p);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67690.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67690.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67690.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67690.c	2015-09-30 06:45:40.491933000 -0500
@@ -0,0 +1,32 @@
+/* { dg-do run } */
+
+const int c1 = 1;
+const int c2 = 2;
+
+int
+check (int i)
+{
+  int j;
+  if (i >= 0)
+    j = c2 - i;
+  else
+    j = c2 - i;
+  return c2 - c1 + 1 > j;
+}
+
+int invoke (int *pi) __attribute__ ((noinline,noclone));
+int
+invoke (int *pi)
+{
+  return check (*pi);
+}
+
+int
+main ()
+{
+  int i = c1;
+  int ret = invoke (&i);
+  if (!ret)
+    __builtin_abort ();
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67769.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67769.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67769.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67769.c	2015-10-01 14:09:01.088801000 -0500
@@ -0,0 +1,23 @@
+/* { dg-do run } */
+
+static int
+clamp (int x, int lo, int hi)
+{
+  return (x < lo) ? lo : ((x > hi) ? hi : x);
+}
+
+__attribute__ ((noinline))
+short
+foo (int N)
+{
+  short value = clamp (N, 0, 16);
+  return value;
+}
+
+int
+main ()
+{
+  if (foo (-5) != 0)
+    __builtin_abort ();
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67794.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67794.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67794.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67794.c	2015-10-26 09:36:43.071349000 -0500
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+int *b;
+static void fn1(int *best, int *dmin) {
+  int a[64];
+  dmin = a;
+  __asm__ volatile("" : "+&r"(dmin) : ""(best));
+}
+
+__attribute__((always_inline)) static inline void fn2(int *best) { fn1(best, b); }
+
+void fn3(void) {
+  int c[1];
+  fn2(c);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67821-2.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67821-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67821-2.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67821-2.c	2015-10-05 13:39:16.356142000 -0500
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+
+int a, b, c, d, e, g;
+short f;
+
+void
+fn1 ()
+{
+  int i;
+  f = a - b;
+  e = (c && (i = d = (unsigned) f - 1)) || i;
+  g = (unsigned) f - 1;
+  c && (d = 0);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67821.c gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67821.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.dg/torture/pr67821.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.dg/torture/pr67821.c	2015-10-05 13:39:16.356142000 -0500
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+int isdigit (int);
+
+int
+foo (const char *s)
+{
+  int success = 1;
+  const char *p = s + 2;
+  if (!isdigit (*p))
+    success = 0;
+  while (isdigit (*p))
+    ++p;
+  return success;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c	2012-11-20 04:56:52.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/atomic-op-imm.c	2015-09-23 04:48:16.591988000 -0500
@@ -16,6 +16,18 @@
 }
 
 int
+atomic_fetch_add_negative_RELAXED ()
+{
+  return __atomic_fetch_add (&v, -4096, __ATOMIC_RELAXED);
+}
+
+int
+atomic_fetch_sub_negative_ACQUIRE ()
+{
+  return __atomic_fetch_sub (&v, -4096, __ATOMIC_ACQUIRE);
+}
+
+int
 atomic_fetch_and_SEQ_CST ()
 {
   return __atomic_fetch_and (&v, 4096, __ATOMIC_SEQ_CST);
@@ -75,4 +87,4 @@
   return __atomic_or_fetch (&v, 4096, __ATOMIC_CONSUME);
 }
 
-/* { dg-final { scan-assembler-times "\tw\[0-9\]+, w\[0-9\]+, #*4096" 12 } } */
+/* { dg-final { scan-assembler-times "\tw\[0-9\]+, w\[0-9\]+, #*4096" 14 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/fnmul-1.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/fnmul-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/fnmul-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/fnmul-1.c	2015-08-04 12:00:35.940710000 -0500
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmul\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" } } */
+  return -a * b;
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmul\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" } } */
+  return -a * b;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/fnmul-2.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/fnmul-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/fnmul-2.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/fnmul-2.c	2015-08-04 12:00:35.940710000 -0500
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -frounding-math" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fneg\\td\[0-9\]+, d\[0-9\]+" } } */
+  /* { dg-final { scan-assembler "fmul\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" } } */
+  return -a * b;
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fneg\\ts\[0-9\]+, s\[0-9\]+" } } */
+  /* { dg-final { scan-assembler "fmul\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" } } */
+  return -a * b;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/fnmul-3.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/fnmul-3.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/fnmul-3.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/fnmul-3.c	2015-08-04 12:00:35.940710000 -0500
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmul\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" } } */
+  return -(a * b);
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmul\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" } } */
+  return -(a * b);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/fnmul-4.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/fnmul-4.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/fnmul-4.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/fnmul-4.c	2015-08-04 12:00:35.940710000 -0500
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -frounding-math" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "fnmul\\td\[0-9\]+, d\[0-9\]+, d\[0-9\]+" } } */
+  return -(a * b);
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "fnmul\\ts\[0-9\]+, s\[0-9\]+, s\[0-9\]+" } } */
+  return -(a * b);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/pr66912.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/pr66912.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/pr66912.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/pr66912.c	2015-10-20 04:50:58.210558000 -0500
@@ -0,0 +1,42 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-O2 -fpic" } */
+
+__attribute__((visibility("protected")))
+int n_common;
+
+__attribute__((weak, visibility("protected")))
+int n_weak_common;
+
+__attribute__((visibility("protected")))
+int n_init = -1;
+
+__attribute__((weak, visibility("protected")))
+int n_weak_init = -1;
+
+int
+f1 ()
+{
+  /* { dg-final { scan-assembler ":got(page_lo15)?:n_common" } } */
+  return n_common;
+}
+
+int
+f2 ()
+{
+  /* { dg-final { scan-assembler ":got(page_lo15)?:n_weak_common" } } */
+  return n_weak_common;
+}
+
+int
+f3 ()
+{
+  /* { dg-final { scan-assembler ":got(page_lo15)?:n_init" } } */
+  return n_init;
+}
+
+int
+f4 ()
+{
+  /* { dg-final { scan-assembler ":got(page_lo15)?:n_weak_init" } } */
+  return n_weak_init;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/pr68102_1.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/pr68102_1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/pr68102_1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/pr68102_1.c	2015-10-28 08:32:17.454275000 -0500
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef __Float64x1_t float64x1_t;
+
+typedef long int64_t;
+
+extern int64_t bar (float64x1_t f);
+
+int
+foo (void)
+{
+  float64x1_t f = { 3.14159265358979311599796346854 };
+  int64_t c = 0x400921FB54442D18;
+  int64_t r;
+  r = bar (f);
+  return r == c;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.c	2015-08-05 06:48:43.873288000 -0500
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-ipa-icf" } */
+
+#include "sync-comp-swap.x"
+
+/* { dg-final { scan-assembler-times "ldxr\tw\[0-9\]+, \\\[x\[0-9\]+\\\]" 2 } } */
+/* { dg-final { scan-assembler-times "stlxr\tw\[0-9\]+, w\[0-9\]+, \\\[x\[0-9\]+\\\]" 2 } } */
+/* { dg-final { scan-assembler-times "dmb\tish" 2 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.x gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.x
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.x	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-comp-swap.x	2015-08-05 06:48:43.873288000 -0500
@@ -0,0 +1,13 @@
+int v = 0;
+
+int
+sync_bool_compare_swap (int a, int b)
+{
+  return __sync_bool_compare_and_swap (&v, &a, &b);
+}
+
+int
+sync_val_compare_swap (int a, int b)
+{
+  return __sync_val_compare_and_swap (&v, &a, &b);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.c	2015-08-05 06:48:43.873288000 -0500
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include "sync-op-acquire.x"
+
+/* { dg-final { scan-assembler-times "ldxr\tw\[0-9\]+, \\\[x\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-times "stxr\tw\[0-9\]+, w\[0-9\]+, \\\[x\[0-9\]+\\\]" 1 } } */
+/* { dg-final { scan-assembler-times "dmb\tish" 1 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.x gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.x
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.x	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-acquire.x	2015-08-05 06:48:43.873288000 -0500
@@ -0,0 +1,7 @@
+int v;
+
+int
+sync_lock_test_and_set (int a)
+{
+  return __sync_lock_test_and_set (&v, a);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-full.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-full.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-full.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-full.c	2015-08-05 06:48:43.873288000 -0500
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include "sync-op-full.x"
+
+/* { dg-final { scan-assembler-times "ldxr\tw\[0-9\]+, \\\[x\[0-9\]+\\\]" 12 } } */
+/* { dg-final { scan-assembler-times "stlxr\tw\[0-9\]+, w\[0-9\]+, \\\[x\[0-9\]+\\\]" 12 } } */
+/* { dg-final { scan-assembler-times "dmb\tish" 12 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-full.x gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-full.x
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-full.x	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-full.x	2015-08-05 06:48:43.873288000 -0500
@@ -0,0 +1,73 @@
+int v = 0;
+
+int
+sync_fetch_and_add (int a)
+{
+  return __sync_fetch_and_add (&v, a);
+}
+
+int
+sync_fetch_and_sub (int a)
+{
+  return __sync_fetch_and_sub (&v, a);
+}
+
+int
+sync_fetch_and_and (int a)
+{
+  return __sync_fetch_and_and (&v, a);
+}
+
+int
+sync_fetch_and_nand (int a)
+{
+  return __sync_fetch_and_nand (&v, a);
+}
+
+int
+sync_fetch_and_xor (int a)
+{
+  return __sync_fetch_and_xor (&v, a);
+}
+
+int
+sync_fetch_and_or (int a)
+{
+  return __sync_fetch_and_or (&v, a);
+}
+
+int
+sync_add_and_fetch (int a)
+{
+  return __sync_add_and_fetch (&v, a);
+}
+
+int
+sync_sub_and_fetch (int a)
+{
+  return __sync_sub_and_fetch (&v, a);
+}
+
+int
+sync_and_and_fetch (int a)
+{
+  return __sync_and_and_fetch (&v, a);
+}
+
+int
+sync_nand_and_fetch (int a)
+{
+  return __sync_nand_and_fetch (&v, a);
+}
+
+int
+sync_xor_and_fetch (int a)
+{
+  return __sync_xor_and_fetch (&v, a);
+}
+
+int
+sync_or_and_fetch (int a)
+{
+  return __sync_or_and_fetch (&v, a);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-release.c gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-release.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-release.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-release.c	2015-08-05 06:48:43.873288000 -0500
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include "sync-op-release.x"
+
+/* { dg-final { scan-assembler-times "stlr" 1 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-release.x gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-release.x
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/aarch64/sync-op-release.x	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/aarch64/sync-op-release.x	2015-08-05 06:48:43.873288000 -0500
@@ -0,0 +1,7 @@
+int v;
+
+void
+sync_lock_release (void)
+{
+  __sync_lock_release (&v);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/armv8-sync-comp-swap.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/armv8-sync-comp-swap.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/armv8-sync-comp-swap.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/armv8-sync-comp-swap.c	2015-08-05 08:44:52.263004000 -0500
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_arch_v8a } */
+
+#include "../aarch64/sync-comp-swap.x"
+
+/* { dg-final { scan-assembler-times "ldrex" 2 } } */
+/* { dg-final { scan-assembler-times "stlex" 2 } } */
+/* { dg-final { scan-assembler-times "dmb" 2 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/armv8-sync-op-acquire.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/armv8-sync-op-acquire.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/armv8-sync-op-acquire.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/armv8-sync-op-acquire.c	2015-08-05 08:44:52.263004000 -0500
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_arch_v8a } */
+
+#include "../aarch64/sync-op-acquire.x"
+
+/* { dg-final { scan-assembler-times "ldrex" 1 } } */
+/* { dg-final { scan-assembler-times "strex" 1 } } */
+/* { dg-final { scan-assembler-times "dmb" 1 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/armv8-sync-op-full.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/armv8-sync-op-full.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/armv8-sync-op-full.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/armv8-sync-op-full.c	2015-08-05 08:44:52.263004000 -0500
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_arch_v8a } */
+
+#include "../aarch64/sync-op-full.x"
+
+/* { dg-final { scan-assembler-times "ldrex" 12 } } */
+/* { dg-final { scan-assembler-times "stlex" 12 } } */
+/* { dg-final { scan-assembler-times "dmb" 12 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/armv8-sync-op-release.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/armv8-sync-op-release.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/armv8-sync-op-release.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/armv8-sync-op-release.c	2015-08-05 08:44:52.263004000 -0500
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_arch_v8a } */
+
+#include "../aarch64/sync-op-release.x"
+
+/* { dg-final { scan-assembler-times "stl" 1 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/macro_defs0.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/macro_defs0.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/macro_defs0.c	2015-02-09 10:26:22.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/macro_defs0.c	2015-07-21 04:48:59.754695000 -0500
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-march=*" } { "-march=armv7-m" } } */
 /* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=soft" } } */
+/* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-marm" } { "" } } */
 /* { dg-options "-march=armv7-m -mcpu=cortex-m3 -mfloat-abi=soft -mthumb" } */
 
 #ifdef __ARM_FP
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/macro_defs1.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/macro_defs1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/macro_defs1.c	2015-02-05 10:58:58.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/macro_defs1.c	2015-07-21 04:48:59.754695000 -0500
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-march=*" } { "-march=armv6-m" } } */
+/* { dg-skip-if "avoid conflicting multilib options" { *-*-* } { "-marm" } { "" } } */
 /* { dg-options "-march=armv6-m -mthumb" } */
 
 #ifdef __ARM_NEON_FP
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/pr63210.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/pr63210.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/pr63210.c	2014-09-24 02:00:55.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/pr63210.c	2015-09-11 04:37:12.097804000 -0500
@@ -1,6 +1,8 @@
 /* { dg-do assemble } */
 /* { dg-options "-mthumb -Os " }  */
 /* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "do not test on armv4t" { *-*-* } { "-march=armv4t" } } */
+/* { dg-additional-options "-march=armv5t" {target arm_arch_v5t_ok} } */
 
 int foo1 (int c);
 int foo2 (int c);
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/pr66912.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/pr66912.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/pr66912.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/pr66912.c	2015-10-20 04:50:58.210558000 -0500
@@ -0,0 +1,42 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-O2 -fpic" } */
+
+__attribute__((visibility("protected")))
+int n_common;
+
+__attribute__((weak, visibility("protected")))
+int n_weak_common;
+
+__attribute__((visibility("protected")))
+int n_init = -1;
+
+__attribute__((weak, visibility("protected")))
+int n_weak_init = -1;
+
+int
+f1 ()
+{
+  /* { dg-final { scan-assembler "\\.word\\tn_common\\(GOT\\)" } } */
+  return n_common;
+}
+
+int
+f2 ()
+{
+  /* { dg-final { scan-assembler "\\.word\\tn_weak_common\\(GOT\\)" } } */
+  return n_weak_common;
+}
+
+int
+f3 ()
+{
+  /* { dg-final { scan-assembler "\\.word\\tn_init\\(GOT\\)" } } */
+  return n_init;
+}
+
+int
+f4 ()
+{
+  /* { dg-final { scan-assembler "\\.word\\tn_weak_init\\(GOT\\)" } } */
+  return n_weak_init;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/pr67439_1.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/pr67439_1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/pr67439_1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/pr67439_1.c	2015-09-23 05:36:48.364214000 -0500
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-options "-O1 -mfp16-format=ieee -march=armv7-a -mfpu=neon -mthumb -mrestrict-it" } */
+
+__fp16 h0 = -1.0;
+
+void
+f (__fp16 *p)
+{
+  h0 = 1.0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/pr67929_1.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/pr67929_1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/pr67929_1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/pr67929_1.c	2015-10-27 08:46:15.949493000 -0500
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+/* { dg-require-effective-target arm_vfp3_ok } */
+/* { dg-options "-O2 -fno-inline" } */
+/* { dg-add-options arm_vfp3 } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+
+int
+foo (float a)
+{
+  return a * 4.9f;
+}
+
+
+int
+main (void)
+{
+  if (foo (10.0f) != 49)
+    __builtin_abort ();
+
+  return 0;
+}
\ No newline at end of file
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/split-live-ranges-for-shrink-wrap.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/split-live-ranges-for-shrink-wrap.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/split-live-ranges-for-shrink-wrap.c	2014-09-09 00:30:36.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/split-live-ranges-for-shrink-wrap.c	2015-07-28 12:20:56.761460000 -0500
@@ -1,6 +1,8 @@
 /* { dg-do assemble } */
 /* { dg-options "-mthumb -Os -fdump-rtl-ira " }  */
 /* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-skip-if "do not test on armv4t" { *-*-* } { "-march=armv4t" } } */
+/* { dg-additional-options "-march=armv5t" {target arm_arch_v5t_ok} } */
 
 int foo (char *, char *, int);
 int test (int d, char * out, char *in, int len)
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/stl-cond.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/stl-cond.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/stl-cond.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/stl-cond.c	2015-10-01 04:05:45.272698000 -0500
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arm_ok } */ 
+/* { dg-require-effective-target arm_arch_v8a_ok } */
+/* { dg-options "-O2 -marm" } */
+/* { dg-add-options arm_arch_v8a } */
+
+struct backtrace_state
+{
+  int threaded;
+  int lock_alloc;
+};
+
+void foo (struct backtrace_state *state)
+{
+  if (state->threaded)
+    __sync_lock_release (&state->lock_alloc);
+}
+
+/* { dg-final { scan-assembler "stlne" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/thumb1-far-jump-2.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/thumb1-far-jump-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/thumb1-far-jump-2.c	2013-04-15 02:41:27.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/thumb1-far-jump-2.c	2015-07-21 05:09:37.727399000 -0500
@@ -5,7 +5,7 @@
 /* { dg-options "-Os" } */
 /* { dg-skip-if "" { ! { arm_thumb1 } } } */
 
-volatile register r4 asm("r4");
+volatile register int r4 asm ("r4");
 void f3(int i)
 {
 #define GO(n) \
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/thumb-bitfld1.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/thumb-bitfld1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/thumb-bitfld1.c	2011-06-22 15:28:29.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/thumb-bitfld1.c	2015-07-21 09:45:17.877807000 -0500
@@ -10,6 +10,8 @@
   unsigned b28 : 1;
   unsigned rest : 28;
 };
+
+unsigned
 foo(a)
      struct foo a;
 {
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/thumb-ltu.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/thumb-ltu.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/thumb-ltu.c	2013-10-17 15:57:21.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/thumb-ltu.c	2015-07-21 04:52:42.809466000 -0500
@@ -2,6 +2,9 @@
 /* { dg-require-effective-target arm_thumb1_ok } */
 /* { dg-options "-mcpu=arm1136jf-s -mthumb -O2" } */
 
+extern int foo ();
+extern int bar ();
+
 void f(unsigned a, unsigned b, unsigned c, unsigned d)
 {
   if (a <= b || c > d)
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/vnmul-1.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/vnmul-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/vnmul-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/vnmul-1.c	2015-08-03 09:27:43.641873000 -0500
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-O2 -fno-rounding-math -mfpu=vfp -mfloat-abi=hard" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "vnmul\\.f64" } } */
+  return -a * b;
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "vnmul\\.f32" } } */
+  return -a * b;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/vnmul-2.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/vnmul-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/vnmul-2.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/vnmul-2.c	2015-08-03 09:27:43.641873000 -0500
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-O2 -frounding-math -mfpu=vfp -mfloat-abi=hard" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler-not "vnmul\\.f64" } } */
+  return -a * b;
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler-not "vnmul\\.f32" } } */
+  return -a * b;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/vnmul-3.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/vnmul-3.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/vnmul-3.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/vnmul-3.c	2015-08-03 09:27:43.641873000 -0500
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-O2 -fno-rounding-math -mfpu=vfp -mfloat-abi=hard" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "vnmul\\.f64" } } */
+  return -(a * b);
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "vnmul\\.f32" } } */
+  return -(a * b);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/vnmul-4.c gcc-5.2.0/gcc/testsuite/gcc.target/arm/vnmul-4.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/arm/vnmul-4.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/arm/vnmul-4.c	2015-08-03 09:27:43.641873000 -0500
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-skip-if "need fp instructions" { *-*-* } { "-mfloat-abi=soft" } { "" } } */
+/* { dg-options "-O2 -frounding-math -mfpu=vfp -mfloat-abi=hard" } */
+
+double
+foo_d (double a, double b)
+{
+  /* { dg-final { scan-assembler "vnmul\\.f64" } } */
+  return -(a * b);
+}
+
+float
+foo_s (float a, float b)
+{
+  /* { dg-final { scan-assembler "vnmul\\.f32" } } */
+  return -(a * b);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/20060512-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/20060512-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/20060512-1.c	2011-07-09 14:25:11.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/20060512-1.c	2015-10-12 11:29:37.933151000 -0500
@@ -1,5 +1,4 @@
 /* { dg-do run } */
-/* { dg-require-effective-target ia32 } */
 /* { dg-options "-std=gnu99 -msse2 -mpreferred-stack-boundary=4" } */
 /* { dg-require-effective-target sse2 } */
 
@@ -7,6 +6,14 @@
 
 #include <emmintrin.h>
 
+#ifdef __x86_64__
+# define PUSH "pushq %rsi"
+# define POP "popq %rsi"
+#else
+# define PUSH "pushl %esi"
+# define POP "popl %esi"
+#endif
+
 __m128i __attribute__ ((__noinline__))
 vector_using_function ()
 {
@@ -27,9 +34,9 @@
 sse2_test (void)
 {
   int result;
-  asm ("pushl %esi");		/* Disalign runtime stack.  */
+  asm (PUSH);                  /* Misalign runtime stack.  */
   result = self_aligning_function (g_1, g_2);
   if (result != 42)
     abort ();
-  asm ("popl %esi");
+  asm (POP);
 }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/20060512-2.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/20060512-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/20060512-2.c	2011-07-09 14:25:11.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/20060512-2.c	2015-10-12 11:29:37.933151000 -0500
@@ -1,5 +1,4 @@
 /* { dg-do compile } */
-/* { dg-require-effective-target ia32 } */
 /* { dg-options "-std=gnu99 -mpreferred-stack-boundary=4" } */
 int
 outer_function (int x, int y)
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/adx-addcarryx32-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/adx-addcarryx32-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/adx-addcarryx32-1.c	2014-09-03 04:24:34.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/adx-addcarryx32-1.c	2015-09-02 10:06:56.988776000 -0500
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-madx -O2" } */
-/* { dg-final { scan-assembler-times "adcx" 2 } } */
+/* { dg-final { scan-assembler-times "adc\[xl\]" 2 } } */
 /* { dg-final { scan-assembler-times "sbbl" 1 } } */
 
 #include <x86intrin.h>
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/adx-addcarryx64-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/adx-addcarryx64-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/adx-addcarryx64-1.c	2014-09-03 04:24:34.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/adx-addcarryx64-1.c	2015-09-02 10:06:56.988776000 -0500
@@ -1,6 +1,6 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-options "-madx -O2" } */
-/* { dg-final { scan-assembler-times "adcx" 2 } } */
+/* { dg-final { scan-assembler-times "adc\[xq\]" 2 } } */
 /* { dg-final { scan-assembler-times "sbbq" 1 } } */
 
 #include <x86intrin.h>
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/avx512vbmi-check.h gcc-5.2.0/gcc/testsuite/gcc.target/i386/avx512vbmi-check.h
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/avx512vbmi-check.h	2014-11-21 09:44:37.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/avx512vbmi-check.h	2015-09-28 05:24:23.098604000 -0500
@@ -25,7 +25,7 @@
 
       __cpuid_count (7, 0, eax, ebx, ecx, edx);
 
-      if ((avx512f_os_support ()) && ((ebx & bit_AVX512VBMI) == bit_AVX512VBMI))
+      if ((avx512f_os_support ()) && ((ecx & bit_AVX512VBMI) == bit_AVX512VBMI))
 	{
 	  do_test ();
 #ifdef DEBUG
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66048.cc gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66048.cc
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66048.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66048.cc	2015-07-23 05:19:03.740369000 -0500
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcheck-pointer-bounds -mmpx -march=corei7-avx" } */
+
+struct c1
+{
+  c1 (const c1 &other) : p (other.p) { };
+  int *p;
+};
+
+struct c2 : public c1 { };
+
+c1
+test (c2 a)
+{
+  return a;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66134.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66134.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66134.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66134.c	2015-07-23 05:22:21.736830000 -0500
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcheck-pointer-bounds -mmpx -fno-tree-ccp" } */
+
+extern int vfork (void) __attribute__ ((__nothrow__ , __leaf__));
+void test1 (void);
+void test2 (void);
+void test3 (int *);
+
+void test (int *p)
+{
+ test1 ();
+ p++;
+ test2 ();
+ p++;
+ vfork ();
+ test3 (p);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66566.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66566.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66566.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66566.c	2015-07-24 08:25:06.714732000 -0500
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcheck-pointer-bounds -mmpx" } */
+
+union jsval_layout
+{
+  void *asPtr;
+};
+union jsval_layout a;
+union jsval_layout b;
+union jsval_layout __inline__ fn1() { return b; }
+
+void fn2() { a = fn1(); }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66567.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66567.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66567.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66567.c	2015-07-23 05:34:48.781735000 -0500
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-fcheck-pointer-bounds -mmpx" } */
+
+void  (*b) ();
+
+void fn1 (const int *p1)
+{
+  static void *a = &&conv_1234_123C;
+ conv_1234_123C:
+  ;
+}
+
+void fn2 ()
+{
+  b = fn1;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66568.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66568.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66568.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66568.c	2015-07-23 05:39:26.086189000 -0500
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-O2 -fcheck-pointer-bounds -mmpx -O2 -fPIC" } */
+
+extern void exit (int);
+int a, b, c;
+void *set_test () {
+  if (b)
+    a ? exit (0) : exit (1);
+  b = c;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66569.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66569.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66569.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66569.c	2015-07-23 05:44:19.212145000 -0500
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-fcheck-pointer-bounds -mmpx" } */
+
+struct s1 {
+  int *p;
+  int i;
+};
+
+struct s2 {
+  struct s1 s;
+  int i;
+};
+
+int test (struct s2 s, ...) { }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66581.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66581.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/mpx/pr66581.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/mpx/pr66581.c	2015-07-23 08:21:39.586699000 -0500
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-fcheck-pointer-bounds -mmpx" } */
+
+void *a;
+int b;
+
+void
+fn1 (void)
+{
+  void *c = &&l_nop;
+l_nop:
+    for (; b;)
+    ;
+  int *d = c;
+  c = fn1;
+  *d = 1;
+  goto *a;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66424.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66424.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66424.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66424.c	2015-09-29 11:37:26.224891000 -0500
@@ -0,0 +1,51 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+/* { dg-require-effective-target ia32 } */
+int a, b, c, d, e[2], f, l, m, n, o;
+long long g = 1, j;
+static unsigned int h;
+static int i, k;
+
+void
+fn1 (long long p)
+{
+  int q = p;
+  f = 1 ^ e[f ^ (q & 1)];
+}
+
+static void
+fn2 (long long p)
+{
+  f = 1 ^ e[(f ^ 1) & 1];
+  fn1 (p >> 1 & 1);
+  fn1 (p >> 32 & 1);
+}
+
+void
+fn3 (int p)
+{
+  g |= j = p;
+}
+
+int
+main ()
+{
+  e[0] = 1;
+  char p = l;
+  h = --g;
+  i = o = c;
+  m = d ? 1 / d : 0;
+  fn3 (l || 0);
+  b = a;
+  n = j++;
+  k--;
+  fn2 (g);
+  fn2 (h);
+  fn2 (i);
+
+  if (k + f)
+    __builtin_abort ();
+
+  return 0;
+}
+
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66648.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66648.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66648.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66648.c	2015-08-16 12:50:20.783775000 -0500
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -mstringop-strategy=unrolled_loop -mtune=nocona" } */
+
+#define PATTERN 0xdeadbeef
+#define SIZE    32
+
+struct S { int i; char str[SIZE]; int j; };
+
+void __attribute__((noclone, noinline))
+my_memcpy (char *, const char *, unsigned int);
+
+void
+my_memcpy (char *dst, const char *src, unsigned int len)
+{
+  if (len < 8)
+    __builtin_abort ();
+
+  __builtin_memcpy (dst, src, len);
+}
+
+int
+main (void)
+{
+  const char str[SIZE]= "1234567890123456789012345678901";
+  struct S *s = __builtin_malloc (sizeof (struct S));
+
+  s->j = PATTERN;
+  my_memcpy (s->str, str, SIZE);
+  if (s->j != PATTERN)
+    __builtin_abort ();
+
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66691.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66691.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66691.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66691.c	2015-07-31 08:52:09.883474000 -0500
@@ -0,0 +1,64 @@
+/* PR debug/66691 */
+/* { dg-do compile } */
+/* { dg-require-effective-target ia32 } */
+/* { dg-options "-O3 -g -mtune=generic -march=i686" } */
+
+unsigned int a;
+int b[2], c, d, e, f, g, h, i, k[8], l, m, s, t, w;
+static int j;
+
+void
+fn1 (long long p)
+{
+  int t = p;
+  c = c ^ b[c ^ (t & 1)];
+}
+
+static void
+fn2 (long long p)
+{
+  c = c ^ b[1 ^ (d & 1)];
+  fn1 (p >> 1 & 1);
+  fn1 (p >> 2);
+}
+
+static void
+fn3 ()
+{
+  unsigned char p;
+  f = g = 0;
+  for (h = 0; h < 6; h++)
+    {
+      for (s = 0; s < 7; s++)
+	if (k[s+1])
+	  g = 0;
+	else
+	  for (j = 0; j < 2; j++)
+	    ;
+      t = j > 2 ? 0 : 1 >> j;
+    }
+  if (l)
+    {
+      short q[2];
+      q[0] = q[1] = 0;
+      if (m)
+	for (i = 0; i < 2; i++)
+	  {
+	    unsigned char r = q[i];
+	    p = f ? r % f : r;
+	    e = ((p > 0) <= (q[i] ^ 1)) + a;
+	    if (k[1])
+	      for (e = 0; e != 18; ++e)
+		k[0] = 0;
+	  }
+    }
+}
+
+int
+main ()
+{
+  fn3 ();
+  fn2 (w);
+  fn2 (j);
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66703.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66703.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66703.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66703.c	2015-07-17 11:30:53.198188000 -0500
@@ -0,0 +1,4 @@
+/* { dg-do run { target { ia32 } } } */
+/* { dg-options "-O0 -mtune=pentium" } */
+
+#include "readeflags-1.c"
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66814.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66814.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66814.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66814.c	2015-07-17 11:27:58.471071000 -0500
@@ -0,0 +1,4 @@
+/* { dg-do compile { target { ia32 } } } */
+/* { dg-options "-march=i586 -mavx512f -O2" } */
+
+#include "avx512f-klogic-2.c"
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66838.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66838.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66838.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66838.c	2015-07-17 08:50:38.038863000 -0500
@@ -0,0 +1,36 @@
+/* { dg-do run { target lp64 } } */
+/* { dg-options "-O2" } */
+
+void abort (void);
+
+char global;
+
+__attribute__((sysv_abi, noinline, noclone))
+void sysv_abi_func(char const *desc, void *local)
+{
+  register int esi asm ("esi");
+  register int edi asm ("edi");
+  
+  if (local != &global)
+    abort ();
+
+  /* Clobber some of the extra SYSV ABI registers.  */
+  asm volatile ("movl\t%2, %0\n\tmovl\t%2, %1"
+		: "=r" (esi), "=r" (edi)
+		: "i" (0xdeadbeef));
+}
+
+__attribute__((ms_abi, noinline, noclone))
+void ms_abi_func ()
+{
+  sysv_abi_func ("1st call", &global);
+  sysv_abi_func ("2nd call", &global);
+  sysv_abi_func ("3rd call", &global);
+}
+
+int
+main(void)
+{
+  ms_abi_func();
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66891.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66891.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66891.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66891.c	2015-07-23 13:51:56.363755000 -0500
@@ -0,0 +1,16 @@
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2" } */
+
+__attribute__((__stdcall__)) void fn1();
+
+int a;
+
+static void fn2() {
+  for (;;)
+    ;
+}
+
+void fn3() {
+  fn1(0);
+  fn2(a == 0);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66922.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66922.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr66922.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr66922.c	2015-07-18 06:17:49.016534000 -0500
@@ -0,0 +1,23 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -msse2" } */
+/* { dg-require-effective-target sse2 } */
+
+#include "sse2-check.h"
+
+struct S 
+{
+  int:31;
+  int:2;
+  int f0:16;
+  int f1;
+  int f2;
+};
+
+static void 
+sse2_test (void)
+{
+  struct S a = { 1, 0, 0 };
+
+  if (a.f0 != 1)
+    __builtin_abort(); 
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67317-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67317-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67317-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67317-1.c	2015-09-02 10:06:56.988776000 -0500
@@ -0,0 +1,18 @@
+/* PR target/67317 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef unsigned int u32;
+
+u32 testcarry_u32 (u32 a, u32 b, u32 c, u32 d)
+{
+  u32 result0, result1;
+
+  __builtin_ia32_addcarryx_u32
+    (__builtin_ia32_addcarryx_u32 (0, a, c, &result0), b, d, &result1);
+
+  return result0 ^ result1;
+}
+
+/* { dg-final { scan-assembler-not "addb" } } */
+/* { dg-final { scan-assembler-not "setn?c" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67317-2.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67317-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67317-2.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67317-2.c	2015-09-02 10:06:56.988776000 -0500
@@ -0,0 +1,18 @@
+/* PR target/67317 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-O2" } */
+
+typedef unsigned long long u64;
+
+u64 testcarry_u64 (u64 a, u64 b, u64 c, u64 d)
+{
+  u64 result0, result1;
+
+  __builtin_ia32_addcarryx_u64
+    (__builtin_ia32_addcarryx_u64 (0, a, c, &result0), b, d, &result1);
+
+  return result0 ^ result1;
+}
+
+/* { dg-final { scan-assembler-not "addb" } } */
+/* { dg-final { scan-assembler-not "setn?c" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67317-3.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67317-3.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67317-3.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67317-3.c	2015-09-02 10:06:56.988776000 -0500
@@ -0,0 +1,18 @@
+/* PR target/67317 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef unsigned int u32;
+
+u32 testcarry_u32 (u32 a, u32 b, u32 c, u32 d)
+{
+  u32 result0, result1;
+
+  __builtin_ia32_sbb_u32
+    (__builtin_ia32_sbb_u32 (0, a, c, &result0), b, d, &result1);
+
+  return result0 ^ result1;
+}
+
+/* { dg-final { scan-assembler-not "addb" } } */
+/* { dg-final { scan-assembler-not "setn?c" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67317-4.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67317-4.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67317-4.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67317-4.c	2015-09-02 10:06:56.988776000 -0500
@@ -0,0 +1,18 @@
+/* PR target/67317 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-O2" } */
+
+typedef unsigned long long u64;
+
+u64 testcarry_u64 (u64 a, u64 b, u64 c, u64 d)
+{
+  u64 result0, result1;
+
+  __builtin_ia32_sbb_u64
+    (__builtin_ia32_sbb_u64 (0, a, c, &result0), b, d, &result1);
+
+  return result0 ^ result1;
+}
+
+/* { dg-final { scan-assembler-not "addb" } } */
+/* { dg-final { scan-assembler-not "setn?c" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67480.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67480.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr67480.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr67480.c	2015-10-12 06:03:56.562174000 -0500
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx512bw -O2 -ftree-vectorize" } */
+
+void
+foo(const char *in, char *out, unsigned n)
+{
+  unsigned i;
+  for (i = 0; i < n; i++)
+    out[i] &= in[i];
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr68018.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr68018.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/pr68018.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/pr68018.c	2015-10-22 01:52:00.764034000 -0500
@@ -0,0 +1,10 @@
+/* { dg-do compile { target { *-*-linux* && { ! ia32 } } } } */
+/* { dg-options "-O -mabi=ms -mstackrealign" } */
+
+typedef float V __attribute__ ((vector_size (16)));
+
+int fn1 (V * x)
+{
+  V a = *x;
+  return a[0];
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/readeflags-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/readeflags-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/readeflags-1.c	2013-12-05 05:23:39.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/readeflags-1.c	2015-07-17 11:30:53.198188000 -0500
@@ -9,10 +9,11 @@
 #define EFLAGS_TYPE unsigned int
 #endif
 
-static EFLAGS_TYPE
+__attribute__((noinline, noclone))
+EFLAGS_TYPE
 readeflags_test (unsigned int a, unsigned int b)
 {
-  unsigned x = (a == b);
+  volatile char x = (a == b);
   return __readeflags ();
 }
 
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-pack-trunc-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-pack-trunc-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-pack-trunc-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-pack-trunc-1.c	2015-10-06 00:36:11.574638000 -0500
@@ -0,0 +1,29 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-vectorize -ffast-math -mavx512bw -save-temps" } */
+/* { dg-require-effective-target avx512bw } */
+
+#include "avx512bw-check.h"
+
+#define N 400
+unsigned char yy[10000];
+
+void
+__attribute__ ((noinline)) foo (unsigned short s)
+{
+   unsigned short i;
+   for (i = 0; i < s; i++)
+     yy[i] = (unsigned char) i;
+}
+
+void
+avx512bw_test ()
+{
+  unsigned short i;
+  foo (N);
+
+  for (i = 0; i < N; i++)
+    if ( (unsigned char)i != yy [i] )
+      abort ();
+}
+
+/* { dg-final { scan-assembler-times "vpmovwb\[ \\t\]+\[^\n\]*%zmm" 2 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-pack-trunc-2.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-pack-trunc-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-pack-trunc-2.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-pack-trunc-2.c	2015-10-06 00:36:11.574638000 -0500
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-vectorize -ffast-math -mavx512bw -save-temps" } */
+/* { dg-require-effective-target avx512bw } */
+
+#include "avx512bw-check.h"
+
+#define N 400
+unsigned short yy[10000];
+
+void
+__attribute__ ((noinline)) foo (unsigned int s)
+{
+   unsigned int i;
+   for (i = 0; i < s; i++)
+     yy[i] = (unsigned short) i;
+}
+
+void
+avx512bw_test ()
+{
+  unsigned int i;
+  foo (N);
+  for (i = 0; i < N; i++)
+    if ( (unsigned short)i != yy [i] )
+      abort ();
+}
+
+/* { dg-final { scan-assembler-times "vpermi2w\[ \\t\]+\[^\n\]*%zmm" 1 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-perm-even-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-perm-even-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-perm-even-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-perm-even-1.c	2015-10-06 00:36:11.574638000 -0500
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-vectorize -ffast-math -mavx512bw -save-temps" } */
+/* { dg-require-effective-target avx512bw } */
+
+#include "avx512bw-check.h"
+
+#define N 400
+unsigned char yy[10000];
+unsigned char xx[10000];
+
+void
+__attribute__ ((noinline)) foo (unsigned short s)
+{
+   unsigned short i;
+   for (i = 0; i < s; i++)
+     yy[i] = xx [i*2 + 1];
+}
+
+void
+avx512bw_test ()
+{
+  unsigned short i;
+  unsigned char j = 0;
+  for (i = 0; i < 2 * N + 1; i++, j++)
+    xx [i] = j;
+
+  foo (N);
+
+  for (i = 0; i < N; i++)
+    if ( (unsigned char)(2*i+1) != yy [i] )
+      abort ();
+}
+
+/* { dg-final { scan-assembler-times "vpmovwb\[ \\t\]+\[^\n\]*%zmm" 2 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-perm-odd-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-perm-odd-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-perm-odd-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-perm-odd-1.c	2015-10-06 00:36:11.574638000 -0500
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-vectorize -ffast-math -mavx512bw -save-temps" } */
+/* { dg-require-effective-target avx512bw } */
+
+#include "avx512bw-check.h"
+
+#define N 400
+
+typedef struct
+{
+  unsigned char real;
+  unsigned char imag;
+} complex8_t;
+
+void
+__attribute__ ((noinline)) foo (unsigned char *a,
+				complex8_t *x, unsigned len)
+{
+  unsigned i;
+  for (i = 0; i < len; i++)
+    a[i] = x[i].imag + x[i].real;
+}
+
+void
+avx512bw_test ()
+{
+  unsigned short i;
+  unsigned char j = 0;
+  complex8_t x [N];
+  unsigned char a [N];
+
+  for (i = 0; i < N; i++, j++)
+    {
+      x [i].real = j;
+      x [i].imag = j;
+    }
+
+  foo (a, x, N);
+
+  j = 0;
+  for (i = 0; i < N; i++, j++)
+    if ( a[i] != (unsigned char)(j+j) )
+      abort ();
+}
+
+/* { dg-final { scan-assembler-times "vpmovwb\[ \\t\]+\[^\n\]*%zmm" 4 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-unpack-1.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-unpack-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-unpack-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-unpack-1.c	2015-10-06 00:36:11.574638000 -0500
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-vectorize -ffast-math -mavx512bw -save-temps" } */
+/* { dg-require-effective-target avx512bw } */
+
+#include "avx512bw-check.h"
+
+#define N 255
+unsigned int yy[10000];
+
+void
+__attribute__ ((noinline)) foo (unsigned char s)
+{
+   unsigned char i;
+   for (i = 0; i < s; i++)
+     yy[i] = (unsigned int) i;
+}
+
+void
+avx512bw_test ()
+{
+  unsigned char i;
+  foo (N);
+  for (i = 0; i < N; i++)
+    if ( (unsigned int)i != yy [i] )
+      abort ();
+}
+
+/* { dg-final { scan-assembler-times "vpmovzxbw\[ \\t\]+\[^\n\]*%zmm" 2 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-unpack-2.c gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-unpack-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/i386/vect-unpack-2.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/i386/vect-unpack-2.c	2015-10-06 00:36:11.574638000 -0500
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-vectorize -ffast-math -mavx512bw -save-temps" } */
+/* { dg-require-effective-target avx512bw } */
+
+#include "avx512bw-check.h"
+
+#define N 120
+signed int yy[10000];
+
+void
+__attribute__ ((noinline)) foo (signed char s)
+{
+   signed char i;
+   for (i = 0; i < s; i++)
+     yy[i] = (signed int) i;
+}
+
+void
+avx512bw_test ()
+{
+  signed char i;
+  foo (N);
+  for (i = 0; i < N; i++)
+    if ( (signed int)i != yy [i] )
+      abort ();
+}
+
+/* { dg-final { scan-assembler-times "vpmovsxbw\[ \\t\]+\[^\n\]*%zmm" 2 } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/powerpc/htm-tabort-no-r0.c gcc-5.2.0/gcc/testsuite/gcc.target/powerpc/htm-tabort-no-r0.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/powerpc/htm-tabort-no-r0.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/powerpc/htm-tabort-no-r0.c	2015-08-03 21:17:31.763977000 -0500
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_htm_ok } */
+/* { dg-options "-O2 -mhtm -ffixed-r3 -ffixed-r4 -ffixed-r5 -ffixed-r6 -ffixed-r7 -ffixed-r8 -ffixed-r9 -ffixed-r10 -ffixed-r11 -ffixed-r12" } */
+
+/* { dg-final { scan-assembler-not "tabort\\.\[ \t\]0" } } */
+
+int
+foo (void)
+{
+  return __builtin_tabort (10);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/powerpc/vec-shr.c gcc-5.2.0/gcc/testsuite/gcc.target/powerpc/vec-shr.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/powerpc/vec-shr.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/powerpc/vec-shr.c	2015-08-27 13:34:54.229009000 -0500
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-inline" } */
+
+#include <stdlib.h>
+
+typedef struct { double r, i; } complex;
+#define LEN 30
+complex c[LEN];
+double d[LEN];
+
+void
+foo (complex *c, double *d, int len1)
+{
+  int i;
+  for (i = 0; i < len1; i++)
+    {
+      c[i].r = d[i];
+      c[i].i = 0.0;
+    }
+}
+
+int
+main (void)
+{
+  int i;
+  for (i = 0; i < LEN; i++)
+    d[i] = (double) i;
+  foo (c, d, LEN);
+  for (i=0;i<LEN;i++)
+    if ((c[i].r != (double) i) || (c[i].i != 0.0))
+      abort ();
+  return 0;
+}
+
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/s390/pr68015.c gcc-5.2.0/gcc/testsuite/gcc.target/s390/pr68015.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/s390/pr68015.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/s390/pr68015.c	2015-10-22 03:28:57.203960000 -0500
@@ -0,0 +1,24 @@
+/* { dg-compile } */
+/* { dg-options "-O2 -march=z196" } */
+
+extern long useme (long, ...);
+
+void
+foo (void)
+{
+  long secs = useme (41);
+  long utc_secs = useme (42);
+  long h, m;
+
+  utc_secs = useme (42);
+  h = secs / 3600;
+  m = secs / 60;
+  if (utc_secs >= 86400)
+    {
+      m = 59;
+      h--;
+      if (h < 0)
+	h = 23;
+    }
+  useme (h, m);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/s390/vector/vec-genbytemask-1.c gcc-5.2.0/gcc/testsuite/gcc.target/s390/vector/vec-genbytemask-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/s390/vector/vec-genbytemask-1.c	2015-07-02 10:51:41.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/s390/vector/vec-genbytemask-1.c	2015-09-29 05:35:24.320707000 -0500
@@ -1,11 +1,13 @@
 /* { dg-do run } */
 /* { dg-options "-O3 -mzarch -march=z13 --save-temps" } */
 /* { dg-require-effective-target vector } */
+/* { dg-require-effective-target int128 } */
 
 typedef unsigned char     uv16qi __attribute__((vector_size(16)));
 typedef unsigned short     uv8hi __attribute__((vector_size(16)));
 typedef unsigned int       uv4si __attribute__((vector_size(16)));
 typedef unsigned long long uv2di __attribute__((vector_size(16)));
+typedef unsigned __int128  uv1ti __attribute__((vector_size(16)));
 
 uv2di __attribute__((noinline))
 foo1 ()
@@ -45,6 +47,13 @@
       0xff, 0, 0xff, 0,
       0, 0xff, 0, 0xff };
 }
+
+uv1ti __attribute__((noinline))
+foo5 ()
+{
+  return (uv1ti){ 0xff00ff00ff00ff00ULL };
+}
+
 /* { dg-final { scan-assembler-times "vgbm\t%v24,61605" 1 } } */
 
 int
@@ -64,6 +73,10 @@
 
   if (foo4()[1] != 0xff)
     __builtin_abort ();
+
+  if (foo5()[0] != 0xff00ff00ff00ff00ULL)
+    __builtin_abort ();
+
   return 0;
 }
 
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/s390/vector/vec-genmask-2.c gcc-5.2.0/gcc/testsuite/gcc.target/s390/vector/vec-genmask-2.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/s390/vector/vec-genmask-2.c	2015-07-02 10:51:41.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gcc.target/s390/vector/vec-genmask-2.c	2015-09-29 05:35:24.320707000 -0500
@@ -1,10 +1,12 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -mzarch -march=z13" } */
+/* { dg-require-effective-target int128 } */
 
 typedef unsigned char     uv16qi __attribute__((vector_size(16)));
 typedef unsigned short     uv8hi __attribute__((vector_size(16)));
 typedef unsigned int       uv4si __attribute__((vector_size(16)));
 typedef unsigned long long uv2di __attribute__((vector_size(16)));
+typedef unsigned __int128  uv1ti __attribute__((vector_size(16)));
 
 /* The elements differ.  */
 uv2di __attribute__((noinline))
@@ -43,4 +45,11 @@
       0x82, 0x82, 0x82, 0x82,
       0x82, 0x82, 0x82, 0x82 };
 }
+
+/* We do not have vgmq.  */
+uv1ti
+foo5()
+{
+  return (uv1ti){ ((unsigned __int128)1 << 53) - 1 };
+}
 /* { dg-final { scan-assembler-not "vgm" } } */
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gcc.target/s390/zvector/vec-load_bndry-1.c gcc-5.2.0/gcc/testsuite/gcc.target/s390/zvector/vec-load_bndry-1.c
--- gcc-5.2.0.orig/gcc/testsuite/gcc.target/s390/zvector/vec-load_bndry-1.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gcc.target/s390/zvector/vec-load_bndry-1.c	2015-08-25 06:37:49.817958000 -0500
@@ -0,0 +1,80 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O0 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+signed char
+foo64 (signed char *p)
+{
+  return vec_load_bndry (p, 64)[0];
+  /* { dg-final { scan-assembler-times "\tvlbb\t%v..?,0\\(%r..?\\),0" 1 } } */
+}
+
+signed char
+foo128 (signed char *p)
+{
+  return
+    vec_load_bndry (p, 128)[0]
+    + vec_load_bndry (p + 16, 128)[0];
+  /* { dg-final { scan-assembler-times "\tvlbb\t%v..?,0\\(%r..?\\),1" 2 } } */
+}
+
+signed char
+foo256 (signed char *p)
+{
+  return
+    vec_load_bndry (p, 256)[0]
+    + vec_load_bndry (p + 16, 256)[0]
+    + vec_load_bndry (p + 32, 256)[0];
+  /* { dg-final { scan-assembler-times "\tvlbb\t%v..?,0\\(%r..?\\),2" 3 } } */
+}
+
+signed char
+foo512 (signed char *p)
+{
+  return
+    vec_load_bndry (p, 512)[0]
+    + vec_load_bndry (p + 16, 512)[0]
+    + vec_load_bndry (p + 32, 512)[0]
+    + vec_load_bndry (p + 48, 512)[0];
+  /* { dg-final { scan-assembler-times "\tvlbb\t%v..?,0\\(%r..?\\),3" 4 } } */
+}
+
+signed char
+foo1024 (signed char *p)
+{
+  return
+    vec_load_bndry (p, 1024)[0]
+    + vec_load_bndry (p + 16, 1024)[0]
+    + vec_load_bndry (p + 32, 1024)[0]
+    + vec_load_bndry (p + 48, 1024)[0]
+    + vec_load_bndry (p + 64, 1024)[0];
+  /* { dg-final { scan-assembler-times "\tvlbb\t%v..?,0\\(%r..?\\),4" 5 } } */
+}
+
+signed char
+foo2048 (signed char *p)
+{
+  return
+    vec_load_bndry (p, 2048)[0]
+    + vec_load_bndry (p + 16, 2048)[0]
+    + vec_load_bndry (p + 32, 2048)[0]
+    + vec_load_bndry (p + 48, 2048)[0]
+    + vec_load_bndry (p + 64, 2048)[0]
+    + vec_load_bndry (p + 80, 2048)[0];
+  /* { dg-final { scan-assembler-times "\tvlbb\t%v..?,0\\(%r..?\\),5" 6 } } */
+}
+
+signed char
+foo4096 (signed char *p)
+{
+  return
+    vec_load_bndry (p, 4096)[0]
+    + vec_load_bndry (p + 16, 4096)[0]
+    + vec_load_bndry (p + 32, 4096)[0]
+    + vec_load_bndry (p + 48, 4096)[0]
+    + vec_load_bndry (p + 64, 4096)[0]
+    + vec_load_bndry (p + 80, 4096)[0]
+    + vec_load_bndry (p + 96, 4096)[0];
+  /* { dg-final { scan-assembler-times "\tvlbb\t%v..?,0\\(%r..?\\),6" 7 } } */
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/abi/abi-tag15.C gcc-5.2.0/gcc/testsuite/g++.dg/abi/abi-tag15.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/abi/abi-tag15.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/abi/abi-tag15.C	2015-07-16 08:25:25.804895000 -0500
@@ -0,0 +1,3 @@
+// PR c++/66748
+
+enum __attribute__((abi_tag("foo"))) E {}; // { dg-error "redeclaration of" }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/conversion/access1.C gcc-5.2.0/gcc/testsuite/g++.dg/conversion/access1.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/conversion/access1.C	2009-01-16 12:35:28.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/conversion/access1.C	2015-08-18 09:44:06.561968000 -0500
@@ -15,7 +15,7 @@
 struct C : public P
 {
   // C can access P's copy ctor, but can't convert b to const P&.
-  C(const B& b) : P(b) {}	// { dg-error "inaccessible base" }
+  C(const B& b) : P(b) {}	// { dg-error "inaccessible base" "" { xfail *-*-* } }
 };
 
 void foo()
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/alias-decl-52.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/alias-decl-52.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/alias-decl-52.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/alias-decl-52.C	2015-07-30 00:48:40.857863000 -0500
@@ -0,0 +1,24 @@
+// PR c++/67021
+// { dg-do compile { target c++11 } }
+
+template<typename> struct Dummy;
+template<> struct Dummy<int> {};
+
+template <class...>
+struct all_same { static constexpr bool value = true; };
+template <class T, class...Rest>
+struct all_same<T, T, Rest...> : all_same<T, Rest...> {};
+template <class T, class U, class...Rest>
+struct all_same<T, U, Rest...> { static constexpr bool value = false; };
+
+template <class R>
+using ValueType = int;
+
+template <class I>
+constexpr bool A(I i) {
+  return all_same<ValueType<I>, ValueType<decltype(i++)>>::value;
+}
+
+int main() {
+  static_assert(A(42), "");
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/alignas1.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/alignas1.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/alignas1.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/alignas1.C	2015-08-17 10:44:35.750755000 -0500
@@ -0,0 +1,16 @@
+// PR c++/65734
+// { dg-do compile { target c++11 } }
+
+template <class T> struct A
+{
+  T t;
+};
+
+typedef A<int> T[4] alignas (2 * alignof (int));
+A<int> a[4];
+
+typedef A<char> T2[4] alignas (2 * alignof (int));
+
+#define SA(X) static_assert((X),#X)
+SA(alignof (T) == 2 * alignof(int));
+SA(alignof (T2) == 2 * alignof(int));
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/alignas2.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/alignas2.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/alignas2.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/alignas2.C	2015-08-17 10:44:35.750755000 -0500
@@ -0,0 +1,20 @@
+// PR c++/65734
+// { dg-do compile { target c++11 } }
+
+template <typename T>
+struct BVector
+{
+  T t;
+};
+BVector<int> m;
+
+template <template <class> class T>
+struct BV2
+{
+  typedef T<float> value_type alignas (16);
+  value_type v;
+};
+BV2<BVector> m2;
+
+#define SA(X) static_assert((X),#X)
+SA(alignof (BV2<BVector>::value_type) == 16);
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/anon-union1.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/anon-union1.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/anon-union1.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/anon-union1.C	2015-10-21 04:27:18.455628000 -0500
@@ -0,0 +1,27 @@
+// PR c++/66583
+// { dg-do run { target c++11 } }
+
+template <class T>
+T&& move(T& t) { return static_cast<T&&>(t); }
+
+struct A {
+  A() { };
+  A(const A&) { }
+};
+
+struct B {
+  union {
+    int m_1 = 0;
+    int m_2;
+  };
+  A dummy;
+};
+
+int main()
+{
+  B b;
+  b.m_1 = 1;
+  B c = move(b);
+  if (c.m_1 != 1)
+    __builtin_abort();
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nested5.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nested5.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nested5.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nested5.C	2015-08-17 13:42:26.508685000 -0500
@@ -0,0 +1,29 @@
+// PR c++/67244
+// { dg-do compile { target c++11 } }
+
+class A {
+public:
+  int operator*();
+};
+template <typename T, typename Predicate>
+void searchGen(int, int, T, Predicate p4) {
+  p4(0);
+}
+template <typename...> struct B;
+template <typename MetaFunction, typename Type, typename... Types>
+struct B<MetaFunction, Type, Types...> {
+  static void exec() { MetaFunction::template exec<Type>; }
+};
+template <typename MetaFunction, typename... Types> void forEachType() {
+  B<MetaFunction, Types...>::exec;
+}
+namespace {
+struct C {
+  template <typename T> void exec() {
+    A __trans_tmp_1;
+    const auto target = *__trans_tmp_1;
+    searchGen(0, 0, 0, [=](T) { [=] { target; }; });
+  }
+};
+}
+void ____C_A_T_C_H____T_E_S_T____75() { forEachType<C, int>; }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/local-type1.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/local-type1.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp0x/local-type1.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp0x/local-type1.C	2015-10-12 08:15:30.542303000 -0500
@@ -0,0 +1,19 @@
+// PR c++/51048
+// { dg-do compile { target c++11 } }
+
+template<typename X>
+struct A {
+  virtual void DoPush(X const& x) = 0;
+  void Push(X const& x) { DoPush(x); }
+};
+
+template<typename X>
+struct B : A<X> {
+  using A<X>::Push;
+  virtual void DoPush(X const&) { }
+};
+
+int main() {
+  enum S { };
+  B<S>().Push(S());
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/auto-fn27.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/auto-fn27.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/auto-fn27.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/auto-fn27.C	2015-08-17 16:34:50.740417000 -0500
@@ -0,0 +1,42 @@
+// PR c++/66919
+// { dg-do compile { target c++14 } }
+
+template <int>
+struct A {
+  template <typename F, typename R, typename T>
+    static auto run (F fn, R, T) { auto r =  fn (); } // { dg-error "" }
+};
+template <typename F, typename T>
+auto foo (F fn, T)
+{
+  A <0>::run (fn, 0, 0);
+}
+struct B;
+struct C {
+  typedef B D;
+};
+struct E {
+  virtual void bar (const int &);
+};
+template <typename C>
+struct F : E {
+  typedef typename C::D::G G;
+  void bar (const G &);
+  typename C::D::H I;
+};
+struct J { struct K {}; };
+template <typename T>
+void
+F<T>::bar (const G &)
+{
+  auto s = I;
+  typedef decltype (s) L;
+  auto u =[&](L) { auto t = foo (J::K (), 0); }; // { dg-error "" }
+}
+struct B {
+  typedef int G;
+  typedef int H;
+};
+struct M : F <C> {
+  M () {}
+};
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/constexpr-array1.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/constexpr-array1.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/constexpr-array1.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/constexpr-array1.C	2015-08-17 10:44:29.687207000 -0500
@@ -0,0 +1,20 @@
+// PR c++/67104
+// { dg-do compile { target c++14 } }
+
+template <typename T, int N> struct array
+{
+  constexpr T &operator[](int index) { return data[index]; }
+  constexpr T operator[](int index) const { return data[index]; }
+  T data[N];
+};
+
+constexpr array<long unsigned, 1001>
+make_bottle_count ()
+{
+  array<long unsigned, 1001> a{};
+  a[65] = 1;
+  return a;
+}
+
+constexpr auto bottle_count = make_bottle_count ();
+static_assert (bottle_count[65], "");
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice3.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice3.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice3.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice3.C	2015-08-06 11:36:58.677642000 -0500
@@ -0,0 +1,3 @@
+// PR c++/66533
+// { dg-do compile { target c++14 } }
+auto a([](auto) -> decltype((void)0) {});
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice4.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice4.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice4.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-ice4.C	2015-09-08 10:02:27.890508000 -0500
@@ -0,0 +1,10 @@
+// PR c++/67369
+// { dg-do compile { target c++14 } }
+
+int main() {
+  unsigned const nsz = 0;
+  auto repeat_conditional = [&](auto) {
+    auto new_sz = nsz;
+  };
+  repeat_conditional(1);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ32.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ32.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ32.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ32.C	2015-08-05 23:10:01.554759000 -0500
@@ -0,0 +1,7 @@
+// { dg-do compile { target c++14 } }
+
+template<typename T>
+bool V1 = true;
+
+template<typename T>
+bool V1<int> = false; // { dg-error "primary template|not deducible" }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ33.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ33.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ33.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ33.C	2015-08-05 23:09:49.892997000 -0500
@@ -0,0 +1,20 @@
+// Test for variable templates in pack expansion
+// { dg-do compile { target c++14 } }
+
+template <int I> const int Val = I;
+
+constexpr int f () { return 0; }
+template <class T, class ...Ts>
+constexpr int f(T t, Ts... ts)
+{
+  return t + f(ts...);
+}
+
+template <int... Is>
+constexpr int g()
+{
+  return f(Val<Is>...);
+}
+
+#define SA(X) static_assert((X),#X)
+SA((g<1,2,3,4>() == 1+2+3+4));
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ35.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ35.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ35.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ35.C	2015-08-05 23:10:01.554759000 -0500
@@ -0,0 +1,5 @@
+// PR c++/66595
+// { dg-do compile { target c++14 } }
+
+template<typename T> int typeID{42};
+template<typename T> double typeID<double>{10.10}; // { dg-error "primary template|redeclaration|not deducible" }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ36.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ36.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ36.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ36.C	2015-08-05 23:10:01.554759000 -0500
@@ -0,0 +1,15 @@
+// { dg-do compile { target c++14 } }
+
+template <class T>
+constexpr T v = T();
+
+template <class T>
+constexpr T v<T*> = T();
+
+template <class T>
+struct A {
+  static constexpr decltype (v<T>) v = ::v<T>;
+};
+
+double d1 = v<double*>;
+double d2 = A<double*>::v;
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ37.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ37.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ37.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ37.C	2015-08-05 23:09:55.421647000 -0500
@@ -0,0 +1,23 @@
+// PR c++/65195
+// { dg-do compile { target c++14 } }
+
+template<typename T>
+T constant {};
+
+template<typename T>
+struct foo {
+    int operator()() const
+    { return 3; }
+};
+
+template<typename T>
+auto& f = constant<foo<T>>;
+
+int main()
+{
+    // fine
+    auto& ref = f<int>; ref();
+
+    // error: f<int> cannot be used as a function
+    f<int>();
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ38.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ38.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ38.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ38.C	2015-08-05 23:10:01.554759000 -0500
@@ -0,0 +1,9 @@
+// PR c++/66596
+// { dg-do compile { target c++14 } }
+
+struct U { void f() {} };
+struct V { void f() {} };
+template<class T> U t;
+template<> V t<int>;
+template<class T> void g() { t<T>.f(); }
+int main() { g<int>(); }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ39.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ39.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ39.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ39.C	2015-08-05 23:10:01.554759000 -0500
@@ -0,0 +1,16 @@
+// PR c++/66260
+// { dg-do compile { target c++14 } }
+
+template <class>
+constexpr bool foo = false;
+template <>
+constexpr bool foo<int> = true;
+template <class T, int N>
+constexpr bool foo<T[N]> = foo<T>;
+
+static_assert(foo<int>, "");
+static_assert(!foo<double>, "");
+static_assert(foo<int[3]>, "");
+static_assert(!foo<double[3]>, "");
+static_assert(foo<int[2][5][3]>, "");
+static_assert(!foo<double[2][5][3]>, "");
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ40.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ40.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ40.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ40.C	2015-08-05 23:09:55.421647000 -0500
@@ -0,0 +1,9 @@
+// PR c++/66619
+// { dg-do compile { target c++14 } }
+
+int y;
+template<class T> T val1 = y;
+auto&& x1 = val1<int&>;
+
+template<class T> T val2 = 0;
+auto&& x2 = val2<int&&>;
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ42.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ42.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ42.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ42.C	2015-08-06 09:28:26.630372000 -0500
@@ -0,0 +1,17 @@
+// PR c++/67131
+// { dg-do compile { target c++14 } }
+
+template <typename T> typename T::_ type;
+template <template <typename...> class> struct A;
+template <template <typename> class f> A<f> metafunction;
+namespace detail {
+template <typename> struct _decltype;
+}
+template <template <typename...> class F> struct A {
+  template <typename... T>
+  auto operator()() -> decltype(type<F<detail::_decltype<T>...>>);
+};
+template <typename F> auto valid_call(F f) -> decltype(f());
+constexpr auto valid_call(...) { return 0; }
+template <typename> struct no_type;
+static_assert(!valid_call(metafunction<no_type>),""); // { dg-error "" }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ43.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ43.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ43.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ43.C	2015-08-06 09:28:26.630372000 -0500
@@ -0,0 +1,35 @@
+// PR c++/67130
+// { dg-do compile { target c++14 } }
+
+namespace std {
+template <typename> struct __success_type;
+template <typename> void declval();
+template <typename> class decay {
+public:
+  typedef int type;
+};
+template <typename...> struct common_type;
+struct A {
+  template <typename, typename _Up>
+  static __success_type<typename decay<decltype(declval<_Up>)>::type> _S_test;
+};
+template <typename _Tp, typename _Up> struct __common_type_impl : A {
+  typedef decltype(_S_test<_Tp, _Up>) type;
+};
+template <typename _Tp, typename _Up>
+struct common_type<_Tp, _Up> : __common_type_impl<_Tp, _Up> {};
+}
+template <typename> struct B { struct _; };
+template <typename T> typename B<T>::_ type;
+template <template <typename...> class> struct C;
+template <template <typename...> class f> C<f> metafunction;
+template <typename T> struct B<T>::_ {};
+namespace detail {
+template <typename> struct _decltype;
+}
+template <template <typename...> class F> struct C {
+  template <typename... T>
+  auto operator()(T...)
+      -> decltype(type<typename F<detail::_decltype<T>...>::type>);
+};
+auto common_type = metafunction<std::common_type>(0, 0);
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ44.C gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ44.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/cpp1y/var-templ44.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/cpp1y/var-templ44.C	2015-08-12 13:05:49.608889000 -0500
@@ -0,0 +1,29 @@
+// PR c++/67161
+// { dg-do compile { target c++14 } }
+
+template <typename _Tp> struct integral_constant {
+  static constexpr _Tp value = 0;
+};
+template <bool, typename, typename> struct conditional;
+template <typename...> struct __or_;
+template <typename _B1, typename _B2>
+struct __or_<_B1, _B2> : conditional<1, _B1, _B2>::type {};
+template <typename...> struct __and_;
+template <typename> struct __not_ : integral_constant<bool> {};
+template <typename> struct __is_void_helper : integral_constant<bool> {};
+template <typename> struct is_void : __is_void_helper<int> {};
+template <bool, typename _Iftrue, typename> struct conditional {
+  typedef _Iftrue type;
+};
+template <bool _Cond, typename _Iftrue, typename _Iffalse>
+using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;
+template <typename...> using common_type_t = int;
+template <typename, int> struct array {};
+template <typename _Tp> constexpr int is_void_v = is_void<_Tp>::value;
+template <typename _Dest = void, typename... _Types>
+constexpr auto make_array()
+    -> array<conditional_t<is_void_v<_Dest>, common_type_t<>, _Dest>,
+             sizeof...(_Types)> {
+  static_assert(__or_<__not_<is_void<_Dest>>, __and_<>>::value, ""); // { dg-error "static assert" }
+}
+auto d = make_array();
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67504.C gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67504.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67504.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67504.C	2015-09-09 02:32:28.892592000 -0500
@@ -0,0 +1,15 @@
+// PR c++/67504
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+int bar (int);
+double bar (double);
+
+template <typename T>
+void
+foo (T x)
+{
+  #pragma omp for collapse (x + 1) // { dg-error "collapse argument needs positive constant integer expression" }
+  for (int i = 0; i < 10; i++)
+    ;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67511.C gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67511.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67511.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67511.C	2015-09-10 02:37:48.921599000 -0500
@@ -0,0 +1,20 @@
+// PR c++/67511
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+struct I
+{
+  I ();
+  I (const I &);
+  I &operator++ ();
+  bool operator< (const I &) const;
+};
+__PTRDIFF_TYPE__ operator- (const I &, const I &);
+
+void
+foo (I &x, I &y)
+{
+#pragma omp for
+  for (I i = x; i < y; ++i)	// { dg-error "no match for" }
+    ;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67514.C gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67514.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67514.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67514.C	2015-09-10 02:38:30.503582000 -0500
@@ -0,0 +1,30 @@
+// PR c++/67514
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+template <class T>
+void
+foo (T x, T y)
+{
+  #pragma omp parallel
+  #pragma omp for simd
+  for (T i = x; i < y; ++i)
+    ;
+  #pragma omp parallel
+  #pragma omp for simd collapse (2)
+  for (T i = x; i < y; ++i)
+    for (T j = x; j < y; j++)
+      ;
+}
+
+void
+bar (int *x, int *y)
+{
+  foo (x, y);
+}
+
+void
+baz (int x, int y)
+{
+  foo (x, y);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67522.C gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67522.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67522.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67522.C	2015-09-10 02:40:59.531058000 -0500
@@ -0,0 +1,26 @@
+// PR c++/67522
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+struct S;
+
+template <int N>
+void
+foo (void)
+{
+  #pragma omp simd linear (S)			// { dg-error "is not a variable in clause" }
+  for (int i = 0; i < 16; i++)
+    ;
+
+  #pragma omp target map (S[0:10])		// { dg-error "is not a variable in" }
+  ;
+
+  #pragma omp task depend (inout: S[0:10])	// { dg-error "is not a variable in" }
+  ;
+}
+
+void
+bar ()
+{
+  foo <0> ();
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67523.C gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67523.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/gomp/pr67523.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/gomp/pr67523.C	2015-09-10 02:41:34.430878000 -0500
@@ -0,0 +1,29 @@
+// PR c++/67523
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+struct S { int s; };
+
+template <typename T>
+void foo (T &x, T &y)
+{
+#pragma omp for simd
+  for (T i = x; i < y; i++)	// { dg-error "used with class iteration variable" }
+    ;
+#pragma omp parallel for simd
+  for (T i = x; i < y; i++)	// { dg-error "used with class iteration variable" }
+    ;
+#pragma omp target teams distribute parallel for simd
+  for (T i = x; i < y; i++)	// { dg-error "used with class iteration variable" }
+    ;
+#pragma omp target teams distribute simd
+  for (T i = x; i < y; i++)	// { dg-error "used with class iteration variable" }
+    ;
+}
+
+void
+bar ()
+{
+  S x, y;
+  foo <S> (x, y);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/inherit/access9.C gcc-5.2.0/gcc/testsuite/g++.dg/inherit/access9.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/inherit/access9.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/inherit/access9.C	2015-08-18 09:44:06.561968000 -0500
@@ -0,0 +1,14 @@
+// PR c++/66957
+
+class BaseClass {
+protected:
+  static int x;
+};
+
+struct DerivedA : BaseClass { };
+
+struct DerivedB : BaseClass {
+  DerivedB() {
+    (void) DerivedA::x;
+  }
+};
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/init/elide3.C gcc-5.2.0/gcc/testsuite/g++.dg/init/elide3.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/init/elide3.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/init/elide3.C	2015-10-21 04:27:12.283863000 -0500
@@ -0,0 +1,50 @@
+// PR c++/67557
+// { dg-do run }
+
+namespace std
+{
+  struct string
+  {
+    typedef unsigned long size_type;
+    const char* _M_p;
+    char        _M_local_buf[1];
+
+    string(const char* s) : _M_p(_M_local_buf)
+    {
+      __builtin_printf("%p constructed\n", this);
+    }
+
+    string(const string& s) : _M_p(_M_local_buf)
+    {
+      __builtin_printf("%p copied from %p\n", this, &s);
+    }
+
+    ~string()
+    {
+      __builtin_printf("%p destroyed\n", this);
+      if (_M_p != _M_local_buf)
+	__builtin_abort();
+    }
+  };
+}
+
+struct StartTag
+{
+  explicit StartTag(std::string const & tag) : tag_(tag), keepempty_(false) {}
+  std::string tag_;
+  bool keepempty_;
+};
+
+StartTag fontToStartTag() { return StartTag(""); }
+
+struct FontTag : public StartTag
+{
+  FontTag() : StartTag(fontToStartTag()) {}
+};
+
+int main()
+{
+  FontTag x;
+  __builtin_printf("%p x.tag_ in main()\n", &x.tag_);
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/init/pr66857.C gcc-5.2.0/gcc/testsuite/g++.dg/init/pr66857.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/init/pr66857.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/init/pr66857.C	2015-08-14 11:33:10.424885000 -0500
@@ -0,0 +1,19 @@
+// PR c++/66857
+// { dg-do run }
+
+const int i = 0;
+
+struct Test
+{
+  Test (const int &rhs)
+  {
+    if (&rhs != &i)
+      __builtin_abort ();
+  }
+};
+
+int
+main (void)
+{
+  Test test = i;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/lto/pr66705_0.C gcc-5.2.0/gcc/testsuite/g++.dg/lto/pr66705_0.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/lto/pr66705_0.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/lto/pr66705_0.C	2015-09-03 04:25:35.382468000 -0500
@@ -0,0 +1,15 @@
+// { dg-lto-do link }
+// { dg-lto-options { { -O2 -flto -flto-partition=max -fipa-pta } } }
+// { dg-extra-ld-options "-r -nostdlib" }
+
+class A {
+public:
+    A();
+};
+int a = 0;
+void foo() {
+    a = 0;
+    A b;
+    for (; a;)
+      ;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/pr66866.C gcc-5.2.0/gcc/testsuite/g++.dg/pr66866.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/pr66866.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/pr66866.C	2015-07-17 15:25:09.562196000 -0500
@@ -0,0 +1,29 @@
+// { dg-do run { target i?86-*-* x86_64-*-* } }
+// { dg-require-effective-target sse2_runtime }
+// { dg-options "-O -msse2" }
+
+extern "C" void abort (void);
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef short A __attribute__((__may_alias__));
+
+__m128i __attribute__((noinline))
+shuf(const __m128i v)
+{
+  __m128i r;
+
+  reinterpret_cast<A *>(&r)[5] = reinterpret_cast<const A *>(&v)[4];
+  return r;
+}
+
+int main()
+{
+  __attribute__((aligned(16))) short mem[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };
+
+  *reinterpret_cast<__m128i *>(mem) = shuf (*reinterpret_cast<__m128i *>(mem));
+
+  if (mem[5] != 4)
+    abort ();
+
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/pr67211.C gcc-5.2.0/gcc/testsuite/g++.dg/pr67211.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/pr67211.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/pr67211.C	2015-08-24 14:11:02.078717000 -0500
@@ -0,0 +1,50 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-mcpu=power7 -mtune=power8 -O3 -w" } */
+
+/* target/67211, compiler got a 'insn does not satisfy its constraints' error.  */
+
+template <typename _InputIterator, typename _ForwardIterator>
+void find_first_of(_InputIterator, _InputIterator, _ForwardIterator p3,
+                   _ForwardIterator p4) {
+  for (; p3 != p4; ++p3)
+    ;
+}
+
+template <typename, typename, typename> struct A {
+  int _S_buffer_size;
+  int *_M_cur;
+  int *_M_first;
+  int *_M_last;
+  int **_M_node;
+  void operator++() {
+    if (_M_cur == _M_last)
+      m_fn1(_M_node + 1);
+  }
+  void m_fn1(int **p1) {
+    _M_node = p1;
+    _M_first = *p1;
+    _M_last = _M_first + _S_buffer_size;
+  }
+};
+
+template <typename _Tp, typename _Ref, typename _Ptr>
+bool operator==(A<_Tp, _Ref, _Ptr>, A<_Tp, _Ref, _Ptr>);
+template <typename _Tp, typename _Ref, typename _Ptr>
+bool operator!=(A<_Tp, _Ref, _Ptr> p1, A<_Tp, _Ref, _Ptr> p2) {
+  return p1 == p2;
+}
+
+class B {
+public:
+  A<int, int, int> m_fn2();
+};
+struct {
+  B j;
+} a;
+void Linked() {
+  A<int, int, int> b, c, d;
+  find_first_of(d, c, b, a.j.m_fn2());
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/pr67699.C gcc-5.2.0/gcc/testsuite/g++.dg/pr67699.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/pr67699.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/pr67699.C	2015-10-06 05:19:54.537907000 -0500
@@ -0,0 +1,8 @@
+// { dg-do compile }
+// { dg-require-effective-target lto }
+// { dg-options "-flto" }
+
+template <class T> class foo {
+    foo() { int const bar[2] = {1, 1}; }
+};
+template class foo<int>;
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/pr67989.C gcc-5.2.0/gcc/testsuite/g++.dg/pr67989.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/pr67989.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/pr67989.C	2015-10-27 09:03:27.514916000 -0500
@@ -0,0 +1,75 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c++11 -O2" } */
+/* { dg-additional-options "-marm -march=armv4t" { target arm*-*-* } } */
+
+__extension__ typedef unsigned long long int uint64_t;
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  typedef enum memory_order
+  {
+    memory_order_seq_cst
+  } memory_order;
+}
+
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template < typename _Tp > struct atomic
+  {
+    static constexpr int _S_min_alignment
+      = (sizeof (_Tp) & (sizeof (_Tp) - 1)) || sizeof (_Tp) > 16
+      ? 0 : sizeof (_Tp);
+    static constexpr int _S_alignment
+      = _S_min_alignment > alignof (_Tp) ? _S_min_alignment : alignof (_Tp);
+      alignas (_S_alignment) _Tp _M_i;
+    operator  _Tp () const noexcept
+    {
+      return load ();
+    }
+    _Tp load (memory_order __m = memory_order_seq_cst) const noexcept
+    {
+      _Tp tmp;
+        __atomic_load (&_M_i, &tmp, __m);
+    }
+  };
+}
+
+namespace lldb_private
+{
+  namespace imp
+  {
+  }
+  class Address;
+}
+namespace lldb
+{
+  typedef uint64_t addr_t;
+  class SBSection
+  {
+  };
+  class SBAddress
+  {
+    void SetAddress (lldb::SBSection section, lldb::addr_t offset);
+      lldb_private::Address & ref ();
+  };
+}
+namespace lldb_private
+{
+  class Address
+  {
+  public:
+    const Address & SetOffset (lldb::addr_t offset)
+    {
+      bool changed = m_offset != offset;
+    }
+    std::atomic < lldb::addr_t > m_offset;
+  };
+}
+
+using namespace lldb;
+using namespace lldb_private;
+void
+SBAddress::SetAddress (lldb::SBSection section, lldb::addr_t offset)
+{
+  Address & addr = ref ();
+  addr.SetOffset (offset);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/torture/pr67055.C gcc-5.2.0/gcc/testsuite/g++.dg/torture/pr67055.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/torture/pr67055.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/torture/pr67055.C	2015-09-21 04:55:57.657387000 -0500
@@ -0,0 +1,44 @@
+// { dg-do compile }
+// { dg-additional-options "-std=c++14" }
+
+namespace std {
+    typedef __SIZE_TYPE__ size_t;
+    struct nothrow_t;
+}
+namespace vespamalloc {
+    void fn1(void *);
+    template <typename> class A {
+    public:
+	static unsigned long fillStack(unsigned long);
+    };
+    template <typename StackRep>
+	unsigned long A<StackRep>::fillStack(unsigned long p1) {
+	    void *retAddr[p1];
+	    fn1(retAddr);
+	}
+    class B {
+    protected:
+	B(void *);
+    };
+    template <int StackTraceLen> class D : B {
+    public:
+	D() : B(0) {}
+	void alloc(int) { A<int>::fillStack(StackTraceLen); }
+    };
+    template <typename, typename> class C {
+    public:
+	void *malloc(unsigned long);
+    };
+    template <typename MemBlockPtrT, typename ThreadListT>
+	void *C<MemBlockPtrT, ThreadListT>::malloc(unsigned long) {
+	    MemBlockPtrT mem;
+	    mem.alloc(0);
+	}
+    C<D<16>, int> *_GmemP;
+}
+void *operator new(std::size_t, std::nothrow_t &) noexcept {
+    return vespamalloc::_GmemP->malloc(0);
+}
+void *operator new[](std::size_t, std::nothrow_t &) noexcept {
+    return vespamalloc::_GmemP->malloc(0);
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/ubsan/vptr-10.C gcc-5.2.0/gcc/testsuite/g++.dg/ubsan/vptr-10.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/ubsan/vptr-10.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/ubsan/vptr-10.C	2015-09-09 11:39:32.787194000 -0500
@@ -0,0 +1,15 @@
+// { dg-do run }
+// { dg-options "-fsanitize=vptr -fno-sanitize-recover=vptr" }
+
+struct A
+{
+    virtual ~A() {}
+};
+struct B : virtual A {};
+struct C : virtual A {};
+struct D : B, virtual C {};
+
+int main()
+{
+    D d;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/g++.dg/warn/deprecated-9.C gcc-5.2.0/gcc/testsuite/g++.dg/warn/deprecated-9.C
--- gcc-5.2.0.orig/gcc/testsuite/g++.dg/warn/deprecated-9.C	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/g++.dg/warn/deprecated-9.C	2015-08-15 02:59:39.661005000 -0500
@@ -0,0 +1,16 @@
+// PR c++/65974
+// { dg-options "-Wdeprecated" }
+
+struct S {
+    void bar();
+
+    __attribute__((deprecated("use bar() instead.")))
+    virtual void foo();
+};
+
+void S::foo() { bar(); }
+
+int main()
+{
+    return 0;
+}
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/allocatable_scalar_13.f90	2015-10-18 13:36:52.443661000 -0500
@@ -0,0 +1,72 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+!
+! Test the fix for PR66079. The original problem was with the first
+! allocate statement. The rest of the testcase fixes problems found
+! whilst working on it but these have been commented out in 5 branch
+! since the pre-requisite patches in 6 branch have not been back
+! ported.
+!
+! Reported by Damian Rouson  <damian@sourceryinstitute.org>
+!
+  type subdata
+    integer, allocatable :: b
+  endtype
+!  block
+    call newRealVec
+!  end block
+contains
+  subroutine newRealVec
+    type(subdata), allocatable :: d, e, f
+    character(:), allocatable :: g, h, i
+    character(8), allocatable :: j
+    allocate(d,source=subdata(1)) ! memory was lost, now OK
+    allocate(e,source=d) ! OK
+    allocate(f,source=create (99)) ! memory was lost, now OK
+    if (d%b .ne. 1) call abort
+    if (e%b .ne. 1) call abort
+    if (f%b .ne. 99) call abort
+    allocate (g, source = greeting1("good day"))
+    if (g .ne. "good day") call abort
+    allocate (h, source = greeting2("hello"))
+    if (h .ne. "hello") call abort
+!    allocate (i, source = greeting3("hiya!"))
+!    if (i .ne. "hiya!") call abort
+!    call greeting4 (j, "Goodbye ") ! Test that dummy arguments are OK
+!    if (j .ne. "Goodbye ") call abort
+  end subroutine
+
+  function create (arg) result(res)
+    integer :: arg
+    type(subdata), allocatable :: res, res1
+    allocate(res, res1, source = subdata(arg))
+  end function
+
+  function greeting1 (arg) result(res) ! memory was lost, now OK
+    character(*) :: arg
+    Character(:), allocatable :: res
+    allocate(res, source = arg)
+  end function
+
+  function greeting2 (arg) result(res)
+    character(5) :: arg
+    Character(:), allocatable :: res
+    allocate(res, source = arg)
+  end function
+
+!  function greeting3 (arg) result(res)
+!    character(5) :: arg
+!    Character(5), allocatable :: res, res1
+!    allocate(res, res1, source = arg) ! Caused an ICE
+!    if (res1 .ne. res) call abort
+!  end function
+
+!  subroutine greeting4 (res, arg)
+!    character(8), intent(in) :: arg
+!    Character(8), allocatable, intent(out) :: res
+!    allocate(res, source = arg) ! Caused an ICE
+!  end subroutine
+end
+! { dg-final { scan-tree-dump-times "builtin_malloc" 15 "original" } }
+! { dg-final { scan-tree-dump-times "builtin_free" 17 "original" } }
+! { dg-final { cleanup-tree-dump "original" } }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_1.f03 gcc-5.2.0/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_1.f03
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_1.f03	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_1.f03	2015-10-18 10:01:03.189982000 -0500
@@ -0,0 +1,270 @@
+! { dg-do run }
+!
+! Check fix for correctly deep copying allocatable components.
+! PR fortran/59678
+! Contributed by Andre Vehreschild  <vehre@gmx.de>
+!
+program alloc_comp_copy_test
+
+  type InnerT
+    integer :: ii
+    integer, allocatable :: ai
+    integer, allocatable :: v(:)
+  end type InnerT
+
+  type T
+    integer :: i
+    integer, allocatable :: a_i
+    type(InnerT), allocatable :: it
+    type(InnerT), allocatable :: vec(:)
+  end type T
+
+  type(T) :: o1, o2
+  class(T), allocatable :: o3, o4
+  o1%i = 42
+
+  call copyO(o1, o2)
+  if (o2%i /= 42) call abort ()
+  if (allocated(o2%a_i)) call abort()
+  if (allocated(o2%it)) call abort()
+  if (allocated(o2%vec)) call abort()
+
+  allocate (o1%a_i, source=2)
+  call copyO(o1, o2)
+  if (o2%i /= 42) call abort ()
+  if (.not. allocated(o2%a_i)) call abort()
+  if (o2%a_i /= 2) call abort()
+  if (allocated(o2%it)) call abort()
+  if (allocated(o2%vec)) call abort()
+
+  allocate (o1%it)
+  o1%it%ii = 3
+  call copyO(o1, o2)
+  if (o2%i /= 42) call abort ()
+  if (.not. allocated(o2%a_i)) call abort()
+  if (o2%a_i /= 2) call abort()
+  if (.not. allocated(o2%it)) call abort()
+  if (o2%it%ii /= 3) call abort()
+  if (allocated(o2%it%ai)) call abort()
+  if (allocated(o2%it%v)) call abort()
+  if (allocated(o2%vec)) call abort()
+
+  allocate (o1%it%ai)
+  o1%it%ai = 4
+  call copyO(o1, o2)
+  if (o2%i /= 42) call abort ()
+  if (.not. allocated(o2%a_i)) call abort()
+  if (o2%a_i /= 2) call abort()
+  if (.not. allocated(o2%it)) call abort()
+  if (o2%it%ii /= 3) call abort()
+  if (.not. allocated(o2%it%ai)) call abort()
+  if (o2%it%ai /= 4) call abort()
+  if (allocated(o2%it%v)) call abort()
+  if (allocated(o2%vec)) call abort()
+
+  allocate (o1%it%v(3), source= 5)
+  call copyO(o1, o2)
+  if (o2%i /= 42) call abort ()
+  if (.not. allocated(o2%a_i)) call abort()
+  if (o2%a_i /= 2) call abort()
+  if (.not. allocated(o2%it)) call abort()
+  if (o2%it%ii /= 3) call abort()
+  if (.not. allocated(o2%it%ai)) call abort()
+  if (o2%it%ai /= 4) call abort()
+  if (.not. allocated(o2%it%v)) call abort()
+  if (any (o2%it%v /= 5) .or. size (o2%it%v) /= 3) call abort()
+  if (allocated(o2%vec)) call abort()
+
+  allocate (o1%vec(2))
+  o1%vec(:)%ii = 6
+  call copyO(o1, o2)
+  if (o2%i /= 42) call abort ()
+  if (.not. allocated(o2%a_i)) call abort()
+  if (o2%a_i /= 2) call abort()
+  if (.not. allocated(o2%it)) call abort()
+  if (o2%it%ii /= 3) call abort()
+  if (.not. allocated(o2%it%ai)) call abort()
+  if (o2%it%ai /= 4) call abort()
+  if (.not. allocated(o2%it%v)) call abort()
+  if (size (o2%it%v) /= 3) call abort()
+  if (any (o2%it%v /= 5)) call abort()
+  if (.not. allocated(o2%vec)) call abort()
+  if (size(o2%vec) /= 2) call abort()
+  if (any(o2%vec(:)%ii /= 6)) call abort()
+  if (allocated(o2%vec(1)%ai) .or. allocated(o2%vec(2)%ai)) call abort()
+  if (allocated(o2%vec(1)%v) .or. allocated(o2%vec(2)%v)) call abort()
+
+  allocate (o1%vec(2)%ai)
+  o1%vec(2)%ai = 7
+  call copyO(o1, o2)
+  if (o2%i /= 42) call abort ()
+  if (.not. allocated(o2%a_i)) call abort()
+  if (o2%a_i /= 2) call abort()
+  if (.not. allocated(o2%it)) call abort()
+  if (o2%it%ii /= 3) call abort()
+  if (.not. allocated(o2%it%ai)) call abort()
+  if (o2%it%ai /= 4) call abort()
+  if (.not. allocated(o2%it%v)) call abort()
+  if (size (o2%it%v) /= 3) call abort()
+  if (any (o2%it%v /= 5)) call abort()
+  if (.not. allocated(o2%vec)) call abort()
+  if (size(o2%vec) /= 2) call abort()
+  if (any(o2%vec(:)%ii /= 6)) call abort()
+  if (allocated(o2%vec(1)%ai)) call abort()
+  if (.not. allocated(o2%vec(2)%ai)) call abort()
+  if (o2%vec(2)%ai /= 7) call abort()
+  if (allocated(o2%vec(1)%v) .or. allocated(o2%vec(2)%v)) call abort()
+
+  allocate (o1%vec(1)%v(3))
+  o1%vec(1)%v = [8, 9, 10]
+  call copyO(o1, o2)
+  if (o2%i /= 42) call abort ()
+  if (.not. allocated(o2%a_i)) call abort()
+  if (o2%a_i /= 2) call abort()
+  if (.not. allocated(o2%it)) call abort()
+  if (o2%it%ii /= 3) call abort()
+  if (.not. allocated(o2%it%ai)) call abort()
+  if (o2%it%ai /= 4) call abort()
+  if (.not. allocated(o2%it%v)) call abort()
+  if (size (o2%it%v) /= 3) call abort()
+  if (any (o2%it%v /= 5)) call abort()
+  if (.not. allocated(o2%vec)) call abort()
+  if (size(o2%vec) /= 2) call abort()
+  if (any(o2%vec(:)%ii /= 6)) call abort()
+  if (allocated(o2%vec(1)%ai)) call abort()
+  if (.not. allocated(o2%vec(2)%ai)) call abort()
+  if (o2%vec(2)%ai /= 7) call abort()
+  if (.not. allocated(o2%vec(1)%v)) call abort()
+  if (any (o2%vec(1)%v /= [8,9,10])) call abort()
+  if (allocated(o2%vec(2)%v)) call abort()
+
+  ! Now all the above for class objects.
+  allocate (o3, o4)
+  o3%i = 42
+
+  call copyO(o3, o4)
+  if (o4%i /= 42) call abort ()
+  if (allocated(o4%a_i)) call abort()
+  if (allocated(o4%it)) call abort()
+  if (allocated(o4%vec)) call abort()
+
+  allocate (o3%a_i, source=2)
+  call copyO(o3, o4)
+  if (o4%i /= 42) call abort ()
+  if (.not. allocated(o4%a_i)) call abort()
+  if (o4%a_i /= 2) call abort()
+  if (allocated(o4%it)) call abort()
+  if (allocated(o4%vec)) call abort()
+
+  allocate (o3%it)
+  o3%it%ii = 3
+  call copyO(o3, o4)
+  if (o4%i /= 42) call abort ()
+  if (.not. allocated(o4%a_i)) call abort()
+  if (o4%a_i /= 2) call abort()
+  if (.not. allocated(o4%it)) call abort()
+  if (o4%it%ii /= 3) call abort()
+  if (allocated(o4%it%ai)) call abort()
+  if (allocated(o4%it%v)) call abort()
+  if (allocated(o4%vec)) call abort()
+
+  allocate (o3%it%ai)
+  o3%it%ai = 4
+  call copyO(o3, o4)
+  if (o4%i /= 42) call abort ()
+  if (.not. allocated(o4%a_i)) call abort()
+  if (o4%a_i /= 2) call abort()
+  if (.not. allocated(o4%it)) call abort()
+  if (o4%it%ii /= 3) call abort()
+  if (.not. allocated(o4%it%ai)) call abort()
+  if (o4%it%ai /= 4) call abort()
+  if (allocated(o4%it%v)) call abort()
+  if (allocated(o4%vec)) call abort()
+
+  allocate (o3%it%v(3), source= 5)
+  call copyO(o3, o4)
+  if (o4%i /= 42) call abort ()
+  if (.not. allocated(o4%a_i)) call abort()
+  if (o4%a_i /= 2) call abort()
+  if (.not. allocated(o4%it)) call abort()
+  if (o4%it%ii /= 3) call abort()
+  if (.not. allocated(o4%it%ai)) call abort()
+  if (o4%it%ai /= 4) call abort()
+  if (.not. allocated(o4%it%v)) call abort()
+  if (any (o4%it%v /= 5) .or. size (o4%it%v) /= 3) call abort()
+  if (allocated(o4%vec)) call abort()
+
+  allocate (o3%vec(2))
+  o3%vec(:)%ii = 6
+  call copyO(o3, o4)
+  if (o4%i /= 42) call abort ()
+  if (.not. allocated(o4%a_i)) call abort()
+  if (o4%a_i /= 2) call abort()
+  if (.not. allocated(o4%it)) call abort()
+  if (o4%it%ii /= 3) call abort()
+  if (.not. allocated(o4%it%ai)) call abort()
+  if (o4%it%ai /= 4) call abort()
+  if (.not. allocated(o4%it%v)) call abort()
+  if (size (o4%it%v) /= 3) call abort()
+  if (any (o4%it%v /= 5)) call abort()
+  if (.not. allocated(o4%vec)) call abort()
+  if (size(o4%vec) /= 2) call abort()
+  if (any(o4%vec(:)%ii /= 6)) call abort()
+  if (allocated(o4%vec(1)%ai) .or. allocated(o4%vec(2)%ai)) call abort()
+  if (allocated(o4%vec(1)%v) .or. allocated(o4%vec(2)%v)) call abort()
+
+  allocate (o3%vec(2)%ai)
+  o3%vec(2)%ai = 7
+  call copyO(o3, o4)
+  if (o4%i /= 42) call abort ()
+  if (.not. allocated(o4%a_i)) call abort()
+  if (o4%a_i /= 2) call abort()
+  if (.not. allocated(o4%it)) call abort()
+  if (o4%it%ii /= 3) call abort()
+  if (.not. allocated(o4%it%ai)) call abort()
+  if (o4%it%ai /= 4) call abort()
+  if (.not. allocated(o4%it%v)) call abort()
+  if (size (o4%it%v) /= 3) call abort()
+  if (any (o4%it%v /= 5)) call abort()
+  if (.not. allocated(o4%vec)) call abort()
+  if (size(o4%vec) /= 2) call abort()
+  if (any(o4%vec(:)%ii /= 6)) call abort()
+  if (allocated(o4%vec(1)%ai)) call abort()
+  if (.not. allocated(o4%vec(2)%ai)) call abort()
+  if (o4%vec(2)%ai /= 7) call abort()
+  if (allocated(o4%vec(1)%v) .or. allocated(o4%vec(2)%v)) call abort()
+
+  allocate (o3%vec(1)%v(3))
+  o3%vec(1)%v = [8, 9, 10]
+  call copyO(o3, o4)
+  if (o4%i /= 42) call abort ()
+  if (.not. allocated(o4%a_i)) call abort()
+  if (o4%a_i /= 2) call abort()
+  if (.not. allocated(o4%it)) call abort()
+  if (o4%it%ii /= 3) call abort()
+  if (.not. allocated(o4%it%ai)) call abort()
+  if (o4%it%ai /= 4) call abort()
+  if (.not. allocated(o4%it%v)) call abort()
+  if (size (o4%it%v) /= 3) call abort()
+  if (any (o4%it%v /= 5)) call abort()
+  if (.not. allocated(o4%vec)) call abort()
+  if (size(o4%vec) /= 2) call abort()
+  if (any(o4%vec(:)%ii /= 6)) call abort()
+  if (allocated(o4%vec(1)%ai)) call abort()
+  if (.not. allocated(o4%vec(2)%ai)) call abort()
+  if (o4%vec(2)%ai /= 7) call abort()
+  if (.not. allocated(o4%vec(1)%v)) call abort()
+  if (any (o4%vec(1)%v /= [8,9,10])) call abort()
+  if (allocated(o4%vec(2)%v)) call abort()
+
+contains
+
+  subroutine copyO(src, dst)
+    type(T), intent(in) :: src
+    type(T), intent(out) :: dst
+
+    dst = src
+  end subroutine copyO
+
+end program alloc_comp_copy_test
+
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_2.f03 gcc-5.2.0/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_2.f03
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_2.f03	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_2.f03	2015-10-18 10:01:03.189982000 -0500
@@ -0,0 +1,21 @@
+! { dg-do run }
+!
+! Testcase for PR fortran/65841
+! Contributed by Damian Rousson
+!
+program alloc_comp_deep_copy_2
+  type a
+    real, allocatable :: f
+  end type
+  type b
+    type(a), allocatable :: g
+  end type
+
+  type(b) c,d
+
+  c%g=a(1.) 
+  d=c
+  if (d%g%f /= 1.0) call abort()
+  d%g%f = 2.0
+  if (d%g%f /= 2.0) call abort()
+end program
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_3.f03 gcc-5.2.0/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_3.f03
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_3.f03	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_3.f03	2015-10-01 09:01:37.575240000 -0500
@@ -0,0 +1,30 @@
+! { dg-do run }
+!
+! PR fortran/67721
+! Check that scalar to array assignments of derived type constructor
+! deep copy the value when there are allocatable components.
+
+program p
+  implicit none
+
+  type :: t1
+    integer :: c1
+  end type t1
+  type :: t2
+    type(t1), allocatable :: c2
+  end type t2
+
+  block
+    type(t2) :: v(4)
+
+    v = t2(t1(3))
+    v(2)%c2%c1 =  7
+    v(3)%c2%c1 = 11
+    v(4)%c2%c1 = 13
+
+    if (v(1)%c2%c1 /=  3) call abort
+    if (v(2)%c2%c1 /=  7) call abort
+    if (v(3)%c2%c1 /= 11) call abort
+    if (v(4)%c2%c1 /= 13) call abort
+  end block
+end program p
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/array_constructor_26.f03 gcc-5.2.0/gcc/testsuite/gfortran.dg/array_constructor_26.f03
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/array_constructor_26.f03	2012-05-15 05:42:32.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/array_constructor_26.f03	2015-10-29 14:37:59.442021000 -0500
@@ -11,7 +11,6 @@
   integer :: i
   TYPE TWindowData
     CHARACTER (MAX_FLD_HED, 1) :: DWFdHd(MAXFLD) = [(" ", i = 1, MAXFLD)]
-    ! { dg-error "no IMPLICIT type" "" { target *-*-* } 13 }
     ! { dg-error "specification expression" "" { target *-*-* } 13 }
   END TYPE TWindowData
 END MODULE WinData
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/array_constructor_27.f03 gcc-5.2.0/gcc/testsuite/gfortran.dg/array_constructor_27.f03
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/array_constructor_27.f03	2008-08-22 02:13:25.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/array_constructor_27.f03	2015-10-29 14:37:59.442021000 -0500
@@ -9,7 +9,6 @@
 
 type t
   character (a) :: arr (1) = [ "a" ]
-  ! { dg-error "no IMPLICIT type" "" { target *-*-* } 11 }
   ! { dg-error "specification expression" "" { target *-*-* } 11 }
 end type t
 
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/char_length_2.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/char_length_2.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/char_length_2.f90	2010-02-09 04:44:33.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/char_length_2.f90	2015-10-19 13:15:36.693122000 -0500
@@ -1,14 +1,13 @@
-! { dg-do link }
-! { dg-options "-Wsurprising" }
-! Tests the fix for PR 31250
-! CHARACTER lengths weren't reduced early enough for all checks of
-! them to be meaningful.  Furthermore negative string lengths weren't
-! dealt with correctly.
+! { dg-do compile }
+! Tests the fix for PR 31250.
+! The fix for PR fortran/67987 supercedes PR 31250, which removes
+! the -Wsurprising option.
+!
 CHARACTER(len=0) :: c1   ! This is OK.
-CHARACTER(len=-1) :: c2  ! { dg-warning "has negative length" }
+CHARACTER(len=-1) :: c2
 PARAMETER(I=-100)
-CHARACTER(len=I) :: c3   ! { dg-warning "has negative length" }
-CHARACTER(len=min(I,500)) :: c4  ! { dg-warning "has negative length" }
+CHARACTER(len=I) :: c3
+CHARACTER(len=min(I,500)) :: c4
 CHARACTER(len=max(I,500)) :: d1  ! no warning
 CHARACTER(len=5) :: d2   ! no warning
 
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/char_type_len_2.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/char_type_len_2.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/char_type_len_2.f90	2007-10-04 10:08:14.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/char_type_len_2.f90	2015-10-29 14:37:59.442021000 -0500
@@ -1,8 +1,11 @@
 ! { dg-do compile }
 ! PR31251 Non-integer character length leads to segfault
 ! Submitted by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
-  character(len=2.3) :: s ! { dg-error "must be of INTEGER type" }
-  character(kind=1,len=4.3) :: t ! { dg-error "must be of INTEGER type" }
+!
+! Updated to deal with the fix for PR fortran/67805.
+!
+  character(len=2.3) :: s ! { dg-error "INTEGER expression expected" }
+  character(kind=1,len=4.3) :: t ! { dg-error "INTEGER expression expected" }
   character(len=,,7.2,kind=1) :: u ! { dg-error "Syntax error in CHARACTER declaration" }
   character(len=7,kind=2) :: v ! ! { dg-error "Kind 2 is not supported for CHARACTER" }
   character(kind=2) :: w ! ! { dg-error "Kind 2 is not supported for CHARACTER" }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/class_allocate_20.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/class_allocate_20.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/class_allocate_20.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/class_allocate_20.f90	2015-08-05 11:15:40.067149000 -0500
@@ -0,0 +1,32 @@
+! { dg-do run }
+!
+! PR fortran/64921
+! Test that the finalization wrapper procedure get the always_explicit
+! attribute so that the array is not passed without descriptor from 
+! T3's finalization wrapper procedure to T2's one.
+!
+! Contributed by Mat Cross  <mathewc@nag.co.uk>
+
+Program test
+  Implicit None
+  Type :: t1
+    Integer, Allocatable :: i
+  End Type
+  Type :: t2
+    Integer, Allocatable :: i
+  End Type
+  Type, Extends (t1) :: t3
+    Type (t2) :: j
+  End Type
+  Type, Extends (t3) :: t4
+    Integer, Allocatable :: k
+  End Type
+  Call s
+  Print *, 'ok'
+Contains
+  Subroutine s
+    Class (t1), Allocatable :: x
+    Allocate (t4 :: x)
+  End Subroutine
+End Program
+! { dg-output "ok" }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/coarray_collectives_16.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/coarray_collectives_16.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/coarray_collectives_16.f90	2014-10-24 15:52:41.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/coarray_collectives_16.f90	2015-07-17 15:30:03.373689000 -0500
@@ -33,7 +33,7 @@
   end function hc
 end program test
 
-! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&desc.., &fr, 4, _gfortran_caf_num_images \\(0, -1\\), &stat1, errmesg1, 0, 6\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&val2, &gz, 0, 4, &stat2, errmesg2, 0, 7\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&desc.., &hc, 1, res, &stat3, errmesg3, 99, 8\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&desc.., fr, 4, _gfortran_caf_num_images \\(0, -1\\), &stat1, errmesg1, 0, 6\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&val2, gz, 0, 4, &stat2, errmesg2, 0, 7\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_co_reduce \\(&desc.., hc, 1, res, &stat3, errmesg3, 99, 8\\);" 1 "original" } }
 ! { dg-final { cleanup-tree-dump "original" } }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/co_reduce_1.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/co_reduce_1.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/co_reduce_1.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/co_reduce_1.f90	2015-07-17 08:33:09.796220000 -0500
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original -fcoarray=lib" }
+!
+! Check that we don't take twice the address of procedure simple_reduction
+! in the generated code.
+!
+! Contributed by Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>
+
+program simple_reduce
+  implicit none
+
+  integer :: me
+
+  me = this_image()
+
+  sync all
+
+  call co_reduce(me,simple_reduction)
+
+  write(*,*) this_image(),me
+
+contains
+  
+  pure function simple_reduction(a,b)
+    integer,intent(in) :: a,b
+    integer :: simple_reduction
+
+    simple_reduction = a * b
+  end function simple_reduction
+
+end program simple_reduce
+
+! { dg-final { scan-tree-dump "_gfortran_caf_co_reduce \\(&desc\\.\\d+,\\s*simple_reduction," "original" } }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/deferred_character_assignment_1.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/deferred_character_assignment_1.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/deferred_character_assignment_1.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/deferred_character_assignment_1.f90	2015-10-26 12:25:03.496685000 -0500
@@ -0,0 +1,22 @@
+! { dg-do run }
+!
+! Checks the fix for PR67977 in which automatic reallocation on assignment
+! was performed when the lhs had a substring reference.
+!
+! Contributed by Anton Shterenlikht  <mexas@bristol.ac.uk>
+!
+  character(:), allocatable :: z
+  integer :: length
+  z = "cockatoo"
+  length = len (z)
+  z(:) = ''
+  if (len(z) .ne. length) call abort
+  if (trim (z) .ne. '') call abort
+  z(:3) = "foo"
+  if (len(z) .ne. length) call abort
+  if (trim (z) .ne. "foo") call abort
+  z(4:) = "__bar"
+  if (len(z) .ne. length) call abort
+  if (trim (z) .ne. "foo__bar") call abort
+  deallocate (z)
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/generic_30.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/generic_30.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/generic_30.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/generic_30.f90	2015-08-07 04:41:31.378923000 -0500
@@ -0,0 +1,41 @@
+! { dg-do compile }
+!
+! PR fortran/66929
+! Generic procedures as actual argument used to lead to
+! a NULL pointer dereference in gfc_get_proc_ifc_for_expr
+! because the generic symbol was used as procedure symbol,
+! instead of the specific one.
+
+module iso_varying_string
+  type, public :: varying_string
+     character(LEN=1), dimension(:), allocatable :: chars
+  end type varying_string
+  interface operator(/=)
+     module procedure op_ne_VS_CH
+  end interface operator (/=)
+  interface trim
+     module procedure trim_
+  end interface
+contains
+  elemental function op_ne_VS_CH (string_a, string_b) result (op_ne)
+    type(varying_string), intent(in) :: string_a
+    character(LEN=*), intent(in)     :: string_b
+    logical                          :: op_ne
+    op_ne = .true.
+  end function op_ne_VS_CH
+  elemental function trim_ (string) result (trim_string)
+    type(varying_string), intent(in) :: string
+    type(varying_string)             :: trim_string
+    trim_string = varying_string(["t", "r", "i", "m", "m", "e", "d"])
+  end function trim_
+end module iso_varying_string
+module syntax_rules
+  use iso_varying_string, string_t => varying_string
+contains
+  subroutine set_rule_type_and_key
+    type(string_t) :: key
+    if (trim (key) /= "") then
+      print *, "non-empty"
+    end if
+  end subroutine set_rule_type_and_key
+end module syntax_rules
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/generic_31.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/generic_31.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/generic_31.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/generic_31.f90	2015-08-07 04:41:31.378923000 -0500
@@ -0,0 +1,35 @@
+! { dg-do run }
+!
+! PR fortran/66929
+! Check that the specific FIRST symbol is used for the call to FOO,
+! so that the J argument is not assumed to be present
+
+module m
+  interface foo
+    module procedure first
+  end interface foo
+contains
+  elemental function bar(j) result(r)
+    integer, intent(in), optional :: j
+    integer :: r, s(2)
+    ! We used to have NULL dereference here, in case of a missing J argument
+    s = foo(j, [3, 7])
+    r = sum(s)
+  end function bar
+  elemental function first(i, j) result(r)
+    integer, intent(in), optional :: i
+    integer, intent(in) :: j
+    integer :: r
+    if (present(i)) then
+      r = i
+    else
+      r = -5
+    end if
+  end function first
+end module m
+program p
+  use m
+  integer :: i
+  i = bar()
+  if (i /= -10) call abort
+end program p
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/iomsg_2.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/iomsg_2.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/iomsg_2.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/iomsg_2.f90	2015-07-16 13:34:06.093480000 -0500
@@ -0,0 +1,44 @@
+! { dg-do compile }
+subroutine foo1
+   implicit none
+   integer i
+   open(1, iomsg=666)      ! { dg-error "IOMSG must be" }
+   open(1, iomsg='sgk')    ! { dg-error "IOMSG must be" }
+   open(1, iomsg=i)        ! { dg-error "IOMSG must be" }
+   close(1, iomsg=666)     ! { dg-error "IOMSG must be" }
+   close(1, iomsg='sgk')   ! { dg-error "IOMSG must be" }
+   close(1, iomsg=i)       ! { dg-error "IOMSG must be" }
+end subroutine foo1
+
+subroutine foo
+   implicit none
+   integer i
+   real :: x = 1
+   write(1, *, iomsg='sgk') x   ! { dg-error "IOMSG must be" }
+   write(1, *, iomsg=i)     x   ! { dg-error "IOMSG must be" }
+   read(1,  *, iomsg='sgk') x   ! { dg-error "IOMSG must be" }
+   read(1,  *, iomsg=i)     x   ! { dg-error "IOMSG must be" }
+   flush(1,    iomsg='sgk')     ! { dg-error "IOMSG must be" }
+   flush(1,    iomsg=i)         ! { dg-error "IOMSG must be" }
+   rewind(1,   iomsg='sgk')     ! { dg-error "IOMSG must be" }
+   rewind(1,   iomsg=i)         ! { dg-error "IOMSG must be" }
+   backspace(1,iomsg='sgk')     ! { dg-error "IOMSG must be" }
+   backspace(1,iomsg=i)         ! { dg-error "IOMSG must be" }
+   wait(1,     iomsg='sgk')     ! { dg-error "IOMSG must be" }
+   wait(1,     iomsg=i)         ! { dg-error "IOMSG must be" }
+end subroutine foo
+
+subroutine bar
+   implicit none
+   integer i
+   real :: x = 1
+   character(len=20) s(2)
+   open(1, iomsg=s)         ! { dg-error "must be scalar" }
+   close(1, iomsg=s)        ! { dg-error "must be scalar" }
+   write(1, *, iomsg=s) x   ! { dg-error "must be scalar" }
+   read(1,  *, iomsg=s) x   ! { dg-error "must be scalar" }
+   flush(1,    iomsg=s)     ! { dg-error "must be scalar" }
+   rewind(1,   iomsg=s)     ! { dg-error "must be scalar" }
+   backspace(1,iomsg=s)     ! { dg-error "must be scalar" }
+   wait(1,     iomsg=s)     ! { dg-error "must be scalar" }
+end subroutine bar
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/large_real_kind_3.F90 gcc-5.2.0/gcc/testsuite/gfortran.dg/large_real_kind_3.F90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/large_real_kind_3.F90	2008-02-27 16:32:56.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/large_real_kind_3.F90	2015-10-29 14:37:59.442021000 -0500
@@ -1,6 +1,5 @@
 ! { dg-do run }
 ! { dg-require-effective-target fortran_large_real }
-! { dg-xfail-if "" { "*-*-freebsd*" } { "*" }  { "" } }
 
 ! Testing erf and erfc library calls on large real kinds (larger than kind=8)
   implicit none
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/move_alloc_15.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/move_alloc_15.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/move_alloc_15.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/move_alloc_15.f90	2015-10-26 12:25:03.496685000 -0500
@@ -0,0 +1,88 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+!
+! Fix for PR......
+!
+! The 'to' components of 'mytemp' would remain allocated after the call to
+! MOVE_ALLOC, resulting in memory leaks.
+!
+! Contributed by Alberto Luaces.
+!
+! See https://groups.google.com/forum/#!topic/comp.lang.fortran/k3bkKUbOpFU
+!
+module alloctest
+  type myallocatable
+     integer, allocatable:: i(:)
+  end type myallocatable
+
+contains
+  subroutine f(num, array)
+    implicit none
+    integer, intent(in) :: num
+    integer :: i
+    type(myallocatable):: array(:)
+
+    do i = 1, num
+       allocate(array(i)%i(5), source = [1,2,3,4,5])
+    end do
+
+  end subroutine f
+end module alloctest
+
+program name
+  use alloctest
+  implicit none
+  type(myallocatable), allocatable:: myarray(:), mytemp(:)
+  integer, parameter:: OLDSIZE = 7, NEWSIZE = 20
+  logical :: flag
+
+  allocate(myarray(OLDSIZE))
+  call f(size(myarray), myarray)
+
+  allocate(mytemp(NEWSIZE))
+  mytemp(1:OLDSIZE) = myarray
+
+  flag = .false.
+  call foo
+  call bar
+
+  deallocate(myarray)
+  if (allocated (mytemp)) deallocate (mytemp)
+
+  allocate(myarray(OLDSIZE))
+  call f(size(myarray), myarray)
+
+  allocate(mytemp(NEWSIZE))
+  mytemp(1:OLDSIZE) = myarray
+
+! Verfify that there is no segfault if the allocatable components
+! are deallocated before the call to move_alloc
+  flag = .true.
+  call foo
+  call bar
+
+  deallocate(myarray)
+contains
+  subroutine foo
+    integer :: i
+    if (flag) then
+      do i = 1, OLDSIZE
+        deallocate (mytemp(i)%i)
+      end do
+    end if
+    call move_alloc(mytemp, myarray)
+  end subroutine
+
+  subroutine bar
+    integer :: i
+    do i = 1, OLDSIZE
+      if (.not.flag .and. allocated (myarray(i)%i)) then
+        if (any (myarray(i)%i .ne. [1,2,3,4,5])) call abort
+      else
+        if (.not.flag) call abort
+      end if
+    end do
+  end subroutine
+end program name
+! { dg-final { scan-tree-dump-times "__builtin_malloc" 11 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 11 "original" } }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/move_alloc_16.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/move_alloc_16.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/move_alloc_16.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/move_alloc_16.f90	2015-10-26 12:25:03.496685000 -0500
@@ -0,0 +1,44 @@
+! { dg-do run }
+!
+! Tests the fix for PR67177 in which MOVE_ALLOC was not assigning the string
+! length for deferred length characters.
+!
+! Contributed by <templed@tcd.ie>
+!
+program str
+  implicit none
+
+  type string
+    character(:), Allocatable :: text
+  end type string
+
+  type strings
+    type(string), allocatable, dimension(:) :: strlist
+  end type strings
+
+  type(strings) :: teststrs
+  type(string) :: tmpstr
+  integer :: strlen = 20
+
+  allocate (teststrs%strlist(1))
+  allocate (character(len=strlen) :: tmpstr%text)
+
+  allocate (character(len=strlen) :: teststrs%strlist(1)%text)
+
+! Full string reference was required because reallocation on assignment is
+! functioning when it should not if the lhs is a substring - PR67977
+  tmpstr%text(1:3) = 'foo'
+
+  if (.not.allocated (teststrs%strlist(1)%text)) call abort
+  if (len (tmpstr%text) .ne. strlen) call abort
+
+  call move_alloc(tmpstr%text,teststrs%strlist(1)%text)
+
+  if (.not.allocated (teststrs%strlist(1)%text)) call abort
+  if (len (teststrs%strlist(1)%text) .ne. strlen) call abort
+  if (trim (teststrs%strlist(1)%text(1:3)) .ne. 'foo') call abort
+
+! Clean up so that valgrind reports all allocated memory freed.
+  if (allocated (teststrs%strlist(1)%text)) deallocate (teststrs%strlist(1)%text)
+  if (allocated (teststrs%strlist)) deallocate (teststrs%strlist)
+end program str
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr36192_1.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr36192_1.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr36192_1.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr36192_1.f90	2015-10-30 11:58:20.838643000 -0500
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/36192
+program three_body
+   real, parameter ::  n = 2, d = 2
+   real, dimension(n,d) :: x_hq ! { dg-error "of INTEGER type|of INTEGER type" }
+   call step(x_hq)
+   contains
+   subroutine step(x)
+      real, dimension(:,:), intent(in) :: x
+   end subroutine step
+end program three_body
+! { dg-prune-output "must have constant shape" }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr51993.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr51993.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr51993.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr51993.f90	2015-10-30 13:27:14.464395000 -0500
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/51993
+! Code contributed by Sebastien Bardeau <bardeau at iram dot fr>
+module mymod
+  type :: mytyp
+    character(len=3) :: a = .true. ! { dg-error "convert LOGICAL" }
+  end type mytyp
+end module mymod
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr56520.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr56520.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr56520.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr56520.f90	2015-07-16 13:44:56.392659000 -0500
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/56520
+!
+program misleading
+    implicit none
+    real a, c
+    a = 1.0
+    c = exp(+a) )    ! { dg-error "Unclassifiable statement" }
+    c = exp(-a) )    ! { dg-error "Unclassifiable statement" }
+    c = exp((a)) )   ! { dg-error "Unclassifiable statement" }
+    c = exp(a) )     ! { dg-error "Unclassifiable statement" }
+    c = exp(a)
+end program misleading
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr58754.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr58754.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr58754.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr58754.f90	2015-10-22 13:05:21.540564000 -0500
@@ -0,0 +1,24 @@
+! { dg-do compile }
+!
+! Tests the fix for PR58754
+!
+  type :: char_type
+    character, allocatable :: chr (:)
+  end type
+  character, allocatable :: c(:)
+  type(char_type) :: d
+  character :: t(1) = ["w"]
+
+  allocate (c (1), source = t)
+  if (any (c .ne. t)) call abort
+  c = ["a"]
+  if (any (c .ne. ["a"])) call abort
+  deallocate (c)
+
+! Check allocatable character components, whilst we are about it.
+  allocate (d%chr (2), source = [t, char (ichar (t) + 1)])
+  if (any (d%chr .ne. ["w", "x"])) call abort
+  d%chr = ["a","b","c","d"]
+  if (any (d%chr .ne. ["a","b","c","d"])) call abort
+  deallocate (d%chr)
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66311.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66311.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66311.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66311.f90	2015-10-16 22:55:03.723886000 -0500
@@ -0,0 +1,60 @@
+! { dg-do run }
+! { dg-additional-options "-fno-range-check -w" }
+!
+! Check that we can print large constants
+!
+! "-fno-range-check -w" is used so the testcase compiles even with targets
+! that don't support large integer kinds.
+
+program test
+  use iso_fortran_env, only : ikinds => integer_kinds
+  implicit none
+
+  ! Largest integer kind
+  integer, parameter :: k = ikinds(size(ikinds))
+  integer, parameter :: hk = k / 2
+
+  if (k <= 8) stop
+
+  call check(9000000000000000000_k, "9000000000000000000")
+  call check(90000000000000000000_k, "90000000000000000000")
+  call check(int(huge(1_hk), kind=k), "9223372036854775807")
+  call check(2_k**63, "9223372036854775808")
+  call check(10000000000000000000_k, "10000000000000000000")
+  call check(18446744065119617024_k, "18446744065119617024")
+  call check(2_k**64 - 1, "18446744073709551615")
+  call check(2_k**64, "18446744073709551616")
+  call check(20000000000000000000_k, "20000000000000000000")
+  call check(huge(0_k), "170141183460469231731687303715884105727")
+  call check(huge(0_k)-1, "170141183460469231731687303715884105726")
+
+  call check(-9000000000000000000_k, "-9000000000000000000")
+  call check(-90000000000000000000_k, "-90000000000000000000")
+  call check(-int(huge(1_hk), kind=k), "-9223372036854775807")
+  call check(-2_k**63, "-9223372036854775808")
+  call check(-10000000000000000000_k, "-10000000000000000000")
+  call check(-18446744065119617024_k, "-18446744065119617024")
+  call check(-(2_k**64 - 1), "-18446744073709551615")
+  call check(-2_k**64, "-18446744073709551616")
+  call check(-20000000000000000000_k, "-20000000000000000000")
+  call check(-huge(0_k), "-170141183460469231731687303715884105727")
+  call check(-(huge(0_k)-1), "-170141183460469231731687303715884105726")
+  call check(-huge(0_k)-1, "-170141183460469231731687303715884105728")
+
+  call check(2_k * huge(1_hk), "18446744073709551614")
+  call check((-2_k) * huge(1_hk), "-18446744073709551614")
+
+contains
+
+  subroutine check (i, str)
+    implicit none
+    integer(kind=k), intent(in), value :: i
+    character(len=*), intent(in) :: str
+
+    character(len=100) :: buffer
+    write(buffer,*) i
+    if (adjustl(buffer) /= adjustl(str)) call abort
+  end subroutine
+
+end
+
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66545_1.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66545_1.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66545_1.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66545_1.f90	2015-07-16 14:03:05.210435000 -0500
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-options "-Wall" }
+! PR fortran/66545
+!
+subroutine p
+   complex, parameter :: c1 = (c1) ! { dg-error "before its definition" }
+   complex, parameter :: c2 = c2   ! { dg-error "before its definition" }
+   complex :: c3 = (c3)            ! { dg-error "has not been declared or is a variable" }
+   complex :: c4 = c4              ! { dg-error "has not been declared or is a variable" }
+end subroutine p
+
+subroutine q
+   real, parameter :: r1 = (r1)  ! { dg-error "before its definition" }
+   real, parameter :: r2 = r2    ! { dg-error "before its definition" }
+   real :: r3 = (r3)             ! { dg-error "has not been declared or is a variable" }
+   real :: r4 = r4               ! { dg-error "has not been declared or is a variable" }
+end subroutine q
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66545_2.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66545_2.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66545_2.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66545_2.f90	2015-07-16 14:03:05.210435000 -0500
@@ -0,0 +1,23 @@
+! { dg-do compile }
+! { dg-options "-Wuninitialized" }
+! PR fortran/66545
+!
+program foo
+   implicit none
+   call p1
+   call q1
+end program foo
+
+subroutine p1
+   complex :: c5
+   complex :: c6
+   c5 = (c5)      ! { dg-warning "used uninitialized in this" }
+   c6 = c6        ! { dg-warning "used uninitialized in this" }
+end subroutine p1
+
+subroutine q1
+   real :: r5
+   real :: r6
+   r5 = (r5)   ! { dg-warning "used uninitialized in this" }
+   r6 = r6     ! { dg-warning "used uninitialized in this" }
+end subroutine q1
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66725.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66725.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66725.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66725.f90	2015-07-16 13:21:22.221784000 -0500
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! PR fortran/66725
+!
+program foo
+
+   open(unit=1,access = 999)        ! { dg-error "ACCESS requires" }
+   open(unit=1,action = 999)        ! { dg-error "ACTION requires" }
+   open(unit=1,asynchronous = 999)  ! { dg-error "ASYNCHRONOUS requires" }
+   open(unit=1,blank = 999)         ! { dg-error "BLANK requires" }
+   open(unit=1,decimal = 999)       ! { dg-error "DECIMAL requires" }
+   open(unit=1,delim = 999)         ! { dg-error "DELIM requires" }
+   open(unit=1,encoding = 999)      ! { dg-error "ENCODING requires" }
+   open(unit=1,form = 999)          ! { dg-error "FORM requires" }
+   open(unit=1,pad = 999)           ! { dg-error "PAD requires" }
+   open(unit=1,position = 999)      ! { dg-error "POSITION requires" }
+   open(unit=1,round = 999)         ! { dg-error "ROUND requires" }
+   open(unit=1,sign = 999)          ! { dg-error "SIGN requires" }
+   open(unit=1,status = 999)        ! { dg-error "STATUS requires" }
+
+   close(unit=1, status=999)        ! { dg-error "STATUS requires" }
+
+   write (unit=1, asynchronous=257) ! { dg-error "ASYNCHRONOUS requires" }
+   write (unit=1, delim=257)        ! { dg-error "DELIM requires" }
+   write (unit=1, decimal=257)      ! { dg-error "DECIMAL requires" }
+   write (unit=1, round=257)        ! { dg-error "ROUND requires" }
+   write (unit=1, sign=257)         ! { dg-error "SIGN requires" }
+
+   write (unit=1, blank=257)        ! { dg-error "BLANK requires" }
+   write (unit=1, pad=257)          ! { dg-error "PAD requires" }
+
+end program foo
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66864.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66864.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66864.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66864.f90	2015-07-16 14:22:38.836603000 -0500
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR fortran/66864
+!
+program t
+   implicit none
+   real(8) x
+   x = 2.0d0**26.5d0
+   if (floor(x) /= 94906265) call abort
+   if (floor(2.0d0**26.5d0)/= 94906265) call abort
+   x = 777666555.6d0
+   if (floor(x) /= 777666555) call abort
+   if (floor(777666555.6d0) /= 777666555) call abort
+   x = 2000111222.6d0
+   if (floor(x) /= 2000111222) call abort
+   if (floor(2000111222.6d0) /= 2000111222) call abort
+end program t
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66979.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66979.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr66979.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr66979.f90	2015-10-02 15:19:32.809047000 -0500
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/66979
+program p
+  implicit none
+  integer::i
+  flush (iostat=i) ! { dg-error "UNIT number missing" }
+end program p
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67525.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67525.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67525.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67525.f90	2015-09-25 17:45:27.788689000 -0500
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR fortran/67525
+! Code contributed by Gerhard Steinmetz
+!
+real function f(x)
+   select type (x)         ! { dg-error "shall be polymorphic" }
+   end select
+end function f
+
+real function g(x)
+   select type (x=>null()) ! { dg-error "shall be polymorphic" }
+   end select
+end function g
+
+subroutine a(x)
+   select type (x)         ! { dg-error "shall be polymorphic" }
+   end select
+end subroutine a
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67526.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67526.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67526.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67526.f90	2015-09-10 13:07:07.099692000 -0500
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! Original code from gerhard dot steinmetz dot fortran at t-online dot de
+! PR fortran/67526
+program p
+   character :: c1 = 'abc'(:     ! { dg-error "error in SUBSTRING" }
+   character :: c2 = 'abc'(3:    ! { dg-error "error in SUBSTRING" }
+   character :: c3 = 'abc'(:1    ! { dg-error "error in SUBSTRING" }
+   character :: c4 = 'abc'(2:2   ! { dg-error "error in SUBSTRING" }
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67614.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67614.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67614.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67614.f90	2015-09-25 17:59:15.529868000 -0500
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+! PR fortran/67614
+!
+program foo
+   implicit none
+   integer, pointer :: z
+   if (null(z)) 10, 20, 30    ! { dg-error "Invalid NULL" }
+10 continue
+20 continue
+30 continue
+end program foo
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67615.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67615.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67615.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67615.f90	2015-09-21 13:24:52.641825000 -0500
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+! PR fortran/67615
+!
+program foo
+
+   implicit none
+
+   integer i(2), j
+   real x
+   complex z
+ 
+   j = 2
+   if (j) 10, 20, 30
+
+   x = -1
+   if (x) 10, 20, 30
+
+   z = (1,2)
+   if (z) 10, 20, 30                   ! { dg-error "Arithmetic IF statement" }
+
+   i = [1, 2]
+   if (i) 10, 20, 30                   ! { dg-error "Arithmetic IF statement" }
+
+   if ( [1] ) 10, 20, 30               ! { dg-error "Arithmetic IF statement" }
+   if ( [1, -1] ) 10, 20, 30           ! { dg-error "Arithmetic IF statement" }
+   if ( [real :: 1, -1] ) 10, 20, 30   ! { dg-error "Arithmetic IF statement" }
+
+10 stop
+20 stop
+30 stop
+
+end program foo
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67616.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67616.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67616.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67616.f90	2015-10-02 16:11:47.171776000 -0500
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/67616
+! Original code contributed by Gerhard Steinmetz 
+program p
+   type t
+   end type
+   type(t) :: y
+   data y /t()/
+   block
+      type(t) :: x
+      data x /t()/      ! Prior to patch, this would ICE.
+   end block
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67802.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67802.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67802.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67802.f90	2015-10-29 14:37:59.442021000 -0500
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/67802
+! Original code contribute by gerhard.steinmetz.fortran at t-online.de
+program p
+   character(1.) :: c1 = ' '      ! { dg-error "INTEGER expression expected" }
+   character(1d1) :: c2 = ' '     ! { dg-error "INTEGER expression expected" }
+   character((0.,1.)) :: c3 = ' ' ! { dg-error "INTEGER expression expected" }
+   character(.true.) :: c4 = ' '  ! { dg-error "INTEGER expression expected" }
+end program p
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67805_2.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67805_2.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67805_2.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67805_2.f90	2015-10-29 14:37:59.442021000 -0500
@@ -0,0 +1,22 @@
+! { dg-do compile }
+! PR fortran/68108
+! Code contributed by Juergen Reuter (juergen.reuter at desy dot de)
+! Test fix for regression caused by PR fortran/67805.
+module lexers
+  implicit none
+  type :: template_t
+     character(256) :: charset1
+     integer :: len1
+  end type template_t
+
+contains
+
+  subroutine match_quoted (tt, s, n)
+    type(template_t), intent(in) :: tt
+    character(*), intent(in) :: s
+    integer, intent(out) :: n
+    character(tt%len1) :: ch1
+    ch1 = tt%charset1
+  end subroutine match_quoted
+
+end module lexers
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67805.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67805.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67805.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67805.f90	2015-10-29 14:37:59.442021000 -0500
@@ -0,0 +1,37 @@
+! { dg-do compile }
+! PR fortran/67805
+! Original code contributed by Gerhard Steinmetz
+! gerhard dot steinmetz dot fortran at t-online dot de
+!
+subroutine p
+   integer, parameter :: n = 1
+   integer, parameter :: m(3) = [1, 2, 3]
+   character(len=1) s(2)
+   s = [character((m(1))) :: 'x', 'y']    ! OK.
+   s = [character(m(1)) :: 'x', 'y']      ! OK.
+   s = [character(m) :: 'x', 'y']         ! { dg-error "INTEGER expression expected" }
+   
+   ! The next line should case an error, but causes an ICE. 
+   s = [character(m(2:3)) :: 'x', 'y']    ! { dg-error "INTEGER expression expected" }
+   
+   call foo(s)
+   s = [character('') :: 'x', 'y']        ! { dg-error "INTEGER expression expected" }
+   s = [character(['']) :: 'x', 'y']      ! { dg-error "INTEGER expression expected" }
+   s = [character([.true.]) :: 'x', 'y']  ! { dg-error "INTEGER expression expected" }
+   s = [character([.false.]) :: 'x', 'y'] ! { dg-error "INTEGER expression expected" }
+   s = [character([1.]) :: 'x', 'y']      ! { dg-error "INTEGER expression expected" }
+   s = [character([1d1]) :: 'x', 'y']     ! { dg-error "INTEGER expression expected" }
+   s = [character([(0.,1.)]) :: 'x', 'y'] ! { dg-error "INTEGER expression expected" }
+   s = [character([null()]) :: 'x', 'y']  ! { dg-error "INTEGER expression expected" }
+   s =  [character(null()) :: 'x', 'y']   ! { dg-error "INTEGER expression expected" }
+   call foo(s)
+end subroutine p
+
+subroutine q
+   print *, '1: ', [character(.true.) :: 'x', 'y']  ! { dg-error "INTEGER expression expected" }
+   print *, '2: ', [character(.false.) :: 'x', 'y'] ! { dg-error "INTEGER expression expected" }
+   print *, '3: ', [character(1.) :: 'x', 'y']      ! { dg-error "INTEGER expression expected" }
+   print *, '4: ', [character(1d1) :: 'x', 'y']     ! { dg-error "INTEGER expression expected" }
+   print *, '5: ', [character((0.,1.)) :: 'x', 'y'] ! { dg-error "INTEGER expression expected" }
+   print *, '6: ', [character(null()) :: 'x', 'y']  ! { dg-error "INTEGER expression expected" }.
+end subroutine q
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67885.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67885.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67885.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67885.f90	2015-10-29 14:52:56.305599000 -0500
@@ -0,0 +1,12 @@
+! { dg-do run }
+! PR fortran/67885
+! Original code contributed by Gerhard Steinmetz
+! gerhard dot steinmetz dot fortran at t-online dot de
+program p
+   block
+      integer, parameter :: a(2) = [1, 2]
+      integer :: x(2)
+      x = a
+      if (x(1) /= 1) call abort
+   end block
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67900.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67900.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67900.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67900.f90	2015-10-19 19:45:48.201991000 -0500
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/67900
+! Original code contributed by Giorgian Borca-Tasciuc
+! giorgianb at gmail dot com
+! 
+program main
+   implicit none
+   interface f
+      function f_real(x)
+         real, bind(c) :: x
+         real :: f_real
+      end function f_real
+
+      function f_integer(x)
+         integer, bind(c) :: x
+         integer :: f_integer
+      end function f_integer
+   end interface f
+end program main
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67939.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67939.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67939.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67939.f90	2015-10-29 15:07:13.209515000 -0500
@@ -0,0 +1,21 @@
+! { dg-do compile }
+! PR fortran/67939
+! Original code by Gerhard Steinmetz
+! gerhard dot steinmetz dot fortran at t-online dot de
+!
+program p
+   character(100) :: x
+   data x(998:99) /'ab'/   ! { dg-warning "Unused initialization string" }
+   call a
+end
+
+subroutine a
+   character(2) :: x
+   data x(:-1) /'ab'/      ! { dg-warning "Unused initialization string" }
+end subroutine a
+
+subroutine b
+   character(8) :: x
+   data x(3:1) /'abc'/     ! { dg-warning "Unused initialization string" }
+end subroutine b
+
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67987.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67987.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr67987.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr67987.f90	2015-10-19 13:15:36.693122000 -0500
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR fortran/67987
+! PR fortran/67988
+! Original code contributed by Gerhard Steinmetz
+! gerhard dot steinmetz dot fortran at t-online dot de
+subroutine p
+   character(-8) :: c = ' '
+end subroutine p
+
+subroutine pp
+   character(3), parameter :: c = 'abc'
+   character(3) :: x(1)
+   x = c(:-2)
+   print *, len(trim(x(1)))
+   x = [ c(:-2) ]
+   print *, len(trim(x(1)))
+end subroutine pp
+
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr68019.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr68019.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr68019.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr68019.f90	2015-10-19 16:29:15.759266000 -0500
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! Original code from Gerhard Steinmetz
+! Gerhard dot Steinmetz for fortran at t-online dot de
+! PR fortran/68019
+!
+program p
+   integer :: i
+   type t
+      integer :: n
+   end type
+   type(t), parameter :: vec(*) = [(t(i), i = 1, 4)]
+   type(t), parameter :: arr(*) = reshape(vec, [2, 2])   ! { dg-error "ranks 1 and 2 in assignment" }
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr68054.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr68054.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr68054.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr68054.f90	2015-10-29 15:32:41.141178000 -0500
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/68054
+! Original code contributed by Gerhard Steinmetz
+! gerhard dot steinmetz dot fortran at t-online dot de
+!
+!program p
+   real, protected :: x   ! { dg-error "only allowed in specification" }
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr68055.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr68055.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr68055.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr68055.f90	2015-10-29 15:44:09.298039000 -0500
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/68055
+! Original code contributed by Gerhard Steinmetz
+! gerhard dot steinmetz dot fortran at t-online dot de
+! 
+   integer*3 c    ! { dg-error "not supported at" }
+   real*9 x       ! { dg-error "not supported at" }
+   logical*11 a   ! { dg-error "not supported at" }
+   complex*42 z   ! { dg-error "not supported at" }
+   c = 1
+   x = 1
+   call foo(a)
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr68154.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/pr68154.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/pr68154.f90	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/pr68154.f90	2015-10-30 12:00:23.590375000 -0500
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/68154
+! Original code contributed by Gerhard Steinmetz
+! gerhard dot steinmetz dot fortran at t-online dot de
+program p
+   character(1), parameter :: x1(2) = 'a'
+   character(*), parameter :: x2(2) = x1
+   character(*), parameter :: x3(*) = x1
+end
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/structure_constructor_13.f03 gcc-5.2.0/gcc/testsuite/gfortran.dg/structure_constructor_13.f03
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/structure_constructor_13.f03	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/structure_constructor_13.f03	2015-07-21 05:36:06.700735000 -0500
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Contributed by Melven Roehrig-Zoellner  <Melven.Roehrig-Zoellner@DLR.de>
+! PR fortran/66035
+
+program test_pr66035
+  type t
+  end type t
+  type w
+    class(t), allocatable :: c
+  end type w
+
+  type(t) :: o
+
+  call test(o)
+contains
+  subroutine test(o)
+    class(t), intent(inout) :: o
+    type(w), dimension(:), allocatable :: list
+
+    select type (o)
+      class is (t)
+        list = [w(o)] ! This caused an ICE
+      class default
+        call abort()
+    end select
+  end subroutine
+end program
diff -Naur gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/used_before_typed_3.f90 gcc-5.2.0/gcc/testsuite/gfortran.dg/used_before_typed_3.f90
--- gcc-5.2.0.orig/gcc/testsuite/gfortran.dg/used_before_typed_3.f90	2012-05-15 05:42:32.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/gfortran.dg/used_before_typed_3.f90	2015-10-29 14:37:59.442021000 -0500
@@ -17,14 +17,14 @@
     test1 = "foobar"
   END FUNCTION test1
 
-  CHARACTER(len=x) FUNCTION test2 (x) ! { dg-bogus "used before|of INTEGER" }
+  CHARACTER(len=x) FUNCTION test2 (x) ! { dg-error "of INTEGER" }
     IMPLICIT INTEGER(a-z)
     test2 = "foobar"
   END FUNCTION test2
 
 END MODULE testmod
   
-CHARACTER(len=i) FUNCTION test3 (i) ! { dg-bogus "used before|of INTEGER" }
+CHARACTER(len=i) FUNCTION test3 (i)
   ! i is IMPLICIT INTEGER by default
   test3 = "foobar"
 END FUNCTION test3
diff -Naur gcc-5.2.0.orig/gcc/testsuite/jit.dg/test-benchmark.c gcc-5.2.0/gcc/testsuite/jit.dg/test-benchmark.c
--- gcc-5.2.0.orig/gcc/testsuite/jit.dg/test-benchmark.c	2015-06-29 09:56:36.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/jit.dg/test-benchmark.c	2015-08-06 14:18:16.001134000 -0500
@@ -209,13 +209,14 @@
 {
   int opt_level;
   int num_iterations = 100;
+  double elapsed_time[4];
 
   ticks_to_msec = TICKS_TO_MSEC;
 
   for (opt_level = 0; opt_level < 4; opt_level++)
     {
       int i;
-      double start_time, end_time, elapsed_time;
+      double start_time, end_time;
       start_time = get_wallclock_time ();
       for (i = 1; i <= num_iterations; i++)
 	{
@@ -226,15 +227,26 @@
 	  test_jit (argv[0], opt_level);
 	}
       end_time = get_wallclock_time ();
-      elapsed_time = end_time - start_time;
+      elapsed_time[opt_level] = end_time - start_time;
       pass ("%s: survived %i iterations at optlevel %i",
 	    argv[0], num_iterations, opt_level);
       note (("%s: %i iterations at optlevel %i"
 	     " took a total of %.3fs (%.3fs per iteration)"),
 	    argv[0], num_iterations, opt_level,
-	    elapsed_time, elapsed_time / num_iterations);
+	    elapsed_time[opt_level],
+	    elapsed_time[opt_level] / num_iterations);
     }
+
   totals ();
 
+  /* Print a summary.  */
+  printf ("%s: %i iterations: time taken (lower is better)\n",
+	  argv[0], num_iterations);
+  for (opt_level = 0; opt_level < 4; opt_level++)
+    printf ("optlevel %i: %.3fs (%.3fs per iteration)\n",
+	    opt_level,
+	    elapsed_time[opt_level],
+	    elapsed_time[opt_level] / num_iterations);
+
   return 0;
 }
diff -Naur gcc-5.2.0.orig/gcc/testsuite/lib/target-supports.exp gcc-5.2.0/gcc/testsuite/lib/target-supports.exp
--- gcc-5.2.0.orig/gcc/testsuite/lib/target-supports.exp	2015-07-02 11:03:59.000000000 -0500
+++ gcc-5.2.0/gcc/testsuite/lib/target-supports.exp	2015-10-01 07:01:18.897040000 -0500
@@ -957,6 +957,13 @@
 	 || [istarget *-*-gnu*] } {
 	return 1;
     }
+    if { [istarget *-*-solaris2.1\[1-9\]*] } {
+	# Full PIE support was added in Solaris 11.x and Solaris 12, but gcc
+	# errors out if missing, so check for that.
+	return [check_no_compiler_messages pie executable {
+	    int main (void) { return 0; }
+	} "-pie -fpie"]
+    }
     return 0
 }
 
@@ -6277,3 +6284,13 @@
 	int (*fn) () = foo;
     }]
 }
+
+# Return 1 if target supports __builtin_eh_return
+proc check_effective_target_builtin_eh_return { } {
+    return [check_no_compiler_messages builtin_eh_return object {
+	void test (long l, void *p)
+	{
+	    __builtin_eh_return (l, p);
+	}
+    } "" ]
+}
diff -Naur gcc-5.2.0.orig/gcc/tree.c gcc-5.2.0/gcc/tree.c
--- gcc-5.2.0.orig/gcc/tree.c	2015-03-31 12:03:16.000000000 -0500
+++ gcc-5.2.0/gcc/tree.c	2015-10-27 11:55:03.896786000 -0500
@@ -1349,7 +1349,7 @@
   int i;
 
   for (i = 0; i < TREE_INT_CST_NUNITS (t); i++)
-    code ^= TREE_INT_CST_ELT (t, i);
+    code = iterative_hash_host_wide_int (TREE_INT_CST_ELT(t, i), code);
 
   return code;
 }
diff -Naur gcc-5.2.0.orig/gcc/tree-chkp.c gcc-5.2.0/gcc/tree-chkp.c
--- gcc-5.2.0.orig/gcc/tree-chkp.c	2015-06-17 02:42:39.000000000 -0500
+++ gcc-5.2.0/gcc/tree-chkp.c	2015-07-23 08:21:39.586699000 -0500
@@ -479,6 +479,21 @@
   return false;
 }
 
+/* Emit code to build zero bounds and return RTL holding
+   the result.  */
+rtx
+chkp_expand_zero_bounds ()
+{
+  tree zero_bnd;
+
+  if (flag_chkp_use_static_const_bounds)
+    zero_bnd = chkp_get_zero_bounds_var ();
+  else
+    zero_bnd = chkp_build_make_bounds_call (integer_zero_node,
+					    integer_zero_node);
+  return expand_normal (zero_bnd);
+}
+
 /* Emit code to store zero bounds for PTR located at MEM.  */
 void
 chkp_expand_bounds_reset_for_mem (tree mem, tree ptr)
@@ -1161,7 +1176,20 @@
   return bnd_var;
 }
 
+/* If BND is an abnormal bounds copy, return a copied value.
+   Otherwise return BND.  */
+static tree
+chkp_get_orginal_bounds_for_abnormal_copy (tree bnd)
+{
+  if (bitmap_bit_p (chkp_abnormal_copies, SSA_NAME_VERSION (bnd)))
+    {
+      gimple bnd_def = SSA_NAME_DEF_STMT (bnd);
+      gcc_checking_assert (gimple_code (bnd_def) == GIMPLE_ASSIGN);
+      bnd = gimple_assign_rhs1 (bnd_def);
+    }
 
+  return bnd;
+}
 
 /* Register bounds BND for object PTR in global bounds table.
    A copy of bounds may be created for abnormal ssa names.
@@ -1205,11 +1233,7 @@
       /* For abnormal copies we may just find original
 	 bounds and use them.  */
       if (!abnormal_ptr && !SSA_NAME_IS_DEFAULT_DEF (bnd))
-	{
-	  gimple bnd_def = SSA_NAME_DEF_STMT (bnd);
-	  gcc_checking_assert (gimple_code (bnd_def) == GIMPLE_ASSIGN);
-	  bnd = gimple_assign_rhs1 (bnd_def);
-	}
+	bnd = chkp_get_orginal_bounds_for_abnormal_copy (bnd);
       /* For undefined values we usually use none bounds
 	 value but in case of abnormal edge it may cause
 	 coalescing failures.  Use default definition of
@@ -1241,6 +1265,7 @@
 	    copy = make_temp_ssa_name (pointer_bounds_type_node,
 				       gimple_build_nop (),
 				       CHKP_BOUND_TMP_NAME);
+	  bnd = chkp_get_orginal_bounds_for_abnormal_copy (bnd);
 	  assign = gimple_build_assign (copy, bnd);
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -2513,6 +2538,7 @@
   tree rhs1 = gimple_assign_rhs1 (assign);
   tree bounds = NULL_TREE;
   gimple_stmt_iterator iter = gsi_for_stmt (assign);
+  tree base = NULL;
 
   if (dump_file && (dump_flags & TDF_DETAILS))
     {
@@ -2539,6 +2565,7 @@
     case INTEGER_CST:
       /* Bounds are just propagated from RHS.  */
       bounds = chkp_find_bounds (rhs1, &iter);
+      base = rhs1;
       break;
 
     case VIEW_CONVERT_EXPR:
@@ -2609,6 +2636,8 @@
 	     (e.g. pointer minus pointer).  In such case
 	     use default invalid op bounds.  */
 	  bounds = chkp_get_invalid_op_bounds ();
+
+	base = (bounds == bnd1) ? rhs1 : (bounds == bnd2) ? rhs2 : NULL;
       }
       break;
 
@@ -2704,6 +2733,19 @@
 
   gcc_assert (bounds);
 
+  /* We may reuse bounds of other pointer we copy/modify.  But it is not
+     allowed for abnormal ssa names.  If we produced a pointer using
+     abnormal ssa name, we better make a bounds copy to avoid coalescing
+     issues.  */
+  if (base
+      && TREE_CODE (base) == SSA_NAME
+      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (base))
+    {
+      gimple stmt = gimple_build_assign (chkp_get_tmp_reg (NULL), bounds);
+      gsi_insert_after (&iter, stmt, GSI_SAME_STMT);
+      bounds = gimple_assign_lhs (stmt);
+    }
+
   if (node)
     bounds = chkp_maybe_copy_and_register_bounds (node, bounds);
 
@@ -4090,7 +4132,7 @@
 			       void *data ATTRIBUTE_UNUSED)
 {
   if (TREE_CODE (*op) == FUNCTION_DECL
-      && !lookup_attribute ("bnd_legacy", DECL_ATTRIBUTES (*op))
+      && chkp_instrumentable_p (*op)
       && (DECL_BUILT_IN_CLASS (*op) == NOT_BUILT_IN
 	  /* For builtins we replace pointers only for selected
 	     function and functions having definitions.  */
diff -Naur gcc-5.2.0.orig/gcc/tree-chkp.h gcc-5.2.0/gcc/tree-chkp.h
--- gcc-5.2.0.orig/gcc/tree-chkp.h	2015-06-17 02:42:39.000000000 -0500
+++ gcc-5.2.0/gcc/tree-chkp.h	2015-07-23 05:39:26.086189000 -0500
@@ -53,6 +53,7 @@
 					 struct cgraph_edge *edge);
 extern bool chkp_gimple_call_builtin_p (gimple call,
 					enum built_in_function code);
+extern rtx chkp_expand_zero_bounds (void);
 extern void chkp_expand_bounds_reset_for_mem (tree mem, tree ptr);
 extern tree chkp_insert_retbnd_call (tree bndval, tree retval,
 				     gimple_stmt_iterator *gsi);
diff -Naur gcc-5.2.0.orig/gcc/tree.h gcc-5.2.0/gcc/tree.h
--- gcc-5.2.0.orig/gcc/tree.h	2015-05-22 03:10:32.000000000 -0500
+++ gcc-5.2.0/gcc/tree.h	2015-08-05 06:20:59.983324000 -0500
@@ -4381,6 +4381,69 @@
 extern void warn_deprecated_use (tree, tree);
 extern void cache_integer_cst (tree);
 
+/* Return the memory model from a host integer.  */
+static inline enum memmodel
+memmodel_from_int (unsigned HOST_WIDE_INT val)
+{
+  return (enum memmodel) (val & MEMMODEL_MASK);
+}
+
+/* Return the base memory model from a host integer.  */
+static inline enum memmodel
+memmodel_base (unsigned HOST_WIDE_INT val)
+{
+  return (enum memmodel) (val & MEMMODEL_BASE_MASK);
+}
+
+/* Return TRUE if the memory model is RELAXED.  */
+static inline bool
+is_mm_relaxed (enum memmodel model)
+{
+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_RELAXED;
+}
+
+/* Return TRUE if the memory model is CONSUME.  */
+static inline bool
+is_mm_consume (enum memmodel model)
+{
+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_CONSUME;
+}
+
+/* Return TRUE if the memory model is ACQUIRE.  */
+static inline bool
+is_mm_acquire (enum memmodel model)
+{
+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_ACQUIRE;
+}
+
+/* Return TRUE if the memory model is RELEASE.  */
+static inline bool
+is_mm_release (enum memmodel model)
+{
+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_RELEASE;
+}
+
+/* Return TRUE if the memory model is ACQ_REL.  */
+static inline bool
+is_mm_acq_rel (enum memmodel model)
+{
+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_ACQ_REL;
+}
+
+/* Return TRUE if the memory model is SEQ_CST.  */
+static inline bool
+is_mm_seq_cst (enum memmodel model)
+{
+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_SEQ_CST;
+}
+
+/* Return TRUE if the memory model is a SYNC variant.  */
+static inline bool
+is_mm_sync (enum memmodel model)
+{
+  return (model & MEMMODEL_SYNC);
+}
+
 /* Compare and hash for any structure which begins with a canonical
    pointer.  Assumes all pointers are interchangeable, which is sort
    of already assumed by gcc elsewhere IIRC.  */
diff -Naur gcc-5.2.0.orig/gcc/tree-if-conv.c gcc-5.2.0/gcc/tree-if-conv.c
--- gcc-5.2.0.orig/gcc/tree-if-conv.c	2015-07-10 07:33:28.000000000 -0500
+++ gcc-5.2.0/gcc/tree-if-conv.c	2015-09-21 04:55:57.657387000 -0500
@@ -2266,9 +2266,11 @@
   /* Merge basic blocks: first remove all the edges in the loop,
      except for those from the exit block.  */
   exit_bb = NULL;
+  bool *predicated = XNEWVEC (bool, orig_loop_num_nodes);
   for (i = 0; i < orig_loop_num_nodes; i++)
     {
       bb = ifc_bbs[i];
+      predicated[i] = !is_true_predicate (bb_predicate (bb));
       free_bb_predicate (bb);
       if (bb_with_exit_edge_p (loop, bb))
 	{
@@ -2326,9 +2328,21 @@
       if (bb == exit_bb || bb == loop->latch)
 	continue;
 
-      /* Make stmts member of loop->header.  */
+      /* Make stmts member of loop->header and clear range info from all stmts
+	 in BB which is now no longer executed conditional on a predicate we
+	 could have derived it from.  */
       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
-	gimple_set_bb (gsi_stmt (gsi), merge_target_bb);
+	{
+	  gimple stmt = gsi_stmt (gsi);
+	  gimple_set_bb (stmt, merge_target_bb);
+	  if (predicated[i])
+	    {
+	      ssa_op_iter i;
+	      tree op;
+	      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_DEF)
+		reset_flow_sensitive_info (op);
+	    }
+	}
 
       /* Update stmt list.  */
       last = gsi_last_bb (merge_target_bb);
@@ -2348,6 +2362,7 @@
 
   free (ifc_bbs);
   ifc_bbs = NULL;
+  free (predicated);
 }
 
 /* Version LOOP before if-converting it, the original loop
diff -Naur gcc-5.2.0.orig/gcc/tree-inline.c gcc-5.2.0/gcc/tree-inline.c
--- gcc-5.2.0.orig/gcc/tree-inline.c	2015-06-23 05:02:38.000000000 -0500
+++ gcc-5.2.0/gcc/tree-inline.c	2015-10-10 07:05:56.035655000 -0500
@@ -4347,6 +4347,60 @@
       }
 }
 
+/* Add to BINDINGS a debug stmt resetting SRCVAR if inlining might
+   have brought in or introduced any debug stmts for SRCVAR.  */
+
+static inline void
+reset_debug_binding (copy_body_data *id, tree srcvar, gimple_seq *bindings)
+{
+  tree *remappedvarp = id->decl_map->get (srcvar);
+
+  if (!remappedvarp)
+    return;
+
+  if (TREE_CODE (*remappedvarp) != VAR_DECL)
+    return;
+
+  if (*remappedvarp == id->retvar || *remappedvarp == id->retbnd)
+    return;
+
+  tree tvar = target_for_debug_bind (*remappedvarp);
+  if (!tvar)
+    return;
+
+  gdebug *stmt = gimple_build_debug_bind (tvar, NULL_TREE,
+					  id->call_stmt);
+  gimple_seq_add_stmt (bindings, stmt);
+}
+
+/* For each inlined variable for which we may have debug bind stmts,
+   add before GSI a final debug stmt resetting it, marking the end of
+   its life, so that var-tracking knows it doesn't have to compute
+   further locations for it.  */
+
+static inline void
+reset_debug_bindings (copy_body_data *id, gimple_stmt_iterator gsi)
+{
+  tree var;
+  unsigned ix;
+  gimple_seq bindings = NULL;
+
+  if (!gimple_in_ssa_p (id->src_cfun))
+    return;
+
+  if (!opt_for_fn (id->dst_fn, flag_var_tracking_assignments))
+    return;
+
+  for (var = DECL_ARGUMENTS (id->src_fn);
+       var; var = DECL_CHAIN (var))
+    reset_debug_binding (id, var, &bindings);
+
+  FOR_EACH_LOCAL_DECL (id->src_cfun, ix, var)
+    reset_debug_binding (id, var, &bindings);
+
+  gsi_insert_seq_before_without_update (&gsi, bindings, GSI_SAME_STMT);
+}
+
 /* If STMT is a GIMPLE_CALL, replace it with its inline expansion.  */
 
 static bool
@@ -4652,6 +4706,8 @@
   	     GCOV_COMPUTE_SCALE (cg_edge->frequency, CGRAPH_FREQ_BASE),
 	     bb, return_block, NULL);
 
+  reset_debug_bindings (id, stmt_gsi);
+
   /* Reset the escaped solution.  */
   if (cfun->gimple_df)
     pt_solution_reset (&cfun->gimple_df->escaped);
diff -Naur gcc-5.2.0.orig/gcc/tree-sra.c gcc-5.2.0/gcc/tree-sra.c
--- gcc-5.2.0.orig/gcc/tree-sra.c	2015-07-03 04:52:20.000000000 -0500
+++ gcc-5.2.0/gcc/tree-sra.c	2015-10-27 07:23:24.090045000 -0500
@@ -4580,61 +4580,45 @@
   return NULL;
 }
 
-/* If the statement STMT defines an SSA_NAME of a parameter which is to be
-   removed because its value is not used, replace the SSA_NAME with a one
-   relating to a created VAR_DECL together all of its uses and return true.
-   ADJUSTMENTS is a pointer to an adjustments vector.  */
+/* If OLD_NAME, which is being defined by statement STMT, is an SSA_NAME of a
+   parameter which is to be removed because its value is not used, create a new
+   SSA_NAME relating to a replacement VAR_DECL, replace all uses of the
+   original with it and return it.  If there is no need to re-map, return NULL.
+   ADJUSTMENTS is a pointer to a vector of IPA-SRA adjustments.  */
 
-static bool
-replace_removed_params_ssa_names (gimple stmt,
+static tree
+replace_removed_params_ssa_names (tree old_name, gimple stmt,
 				  ipa_parm_adjustment_vec adjustments)
 {
   struct ipa_parm_adjustment *adj;
-  tree lhs, decl, repl, name;
-
-  if (gimple_code (stmt) == GIMPLE_PHI)
-    lhs = gimple_phi_result (stmt);
-  else if (is_gimple_assign (stmt))
-    lhs = gimple_assign_lhs (stmt);
-  else if (is_gimple_call (stmt))
-    lhs = gimple_call_lhs (stmt);
-  else
-    gcc_unreachable ();
+  tree decl, repl, new_name;
 
-  if (TREE_CODE (lhs) != SSA_NAME)
-    return false;
+  if (TREE_CODE (old_name) != SSA_NAME)
+    return NULL;
 
-  decl = SSA_NAME_VAR (lhs);
+  decl = SSA_NAME_VAR (old_name);
   if (decl == NULL_TREE
       || TREE_CODE (decl) != PARM_DECL)
-    return false;
+    return NULL;
 
   adj = get_adjustment_for_base (adjustments, decl);
   if (!adj)
-    return false;
+    return NULL;
 
   repl = get_replaced_param_substitute (adj);
-  name = make_ssa_name (repl, stmt);
+  new_name = make_ssa_name (repl, stmt);
 
   if (dump_file)
     {
       fprintf (dump_file, "replacing an SSA name of a removed param ");
-      print_generic_expr (dump_file, lhs, 0);
+      print_generic_expr (dump_file, old_name, 0);
       fprintf (dump_file, " with ");
-      print_generic_expr (dump_file, name, 0);
+      print_generic_expr (dump_file, new_name, 0);
       fprintf (dump_file, "\n");
     }
 
-  if (is_gimple_assign (stmt))
-    gimple_assign_set_lhs (stmt, name);
-  else if (is_gimple_call (stmt))
-    gimple_call_set_lhs (stmt, name);
-  else
-    gimple_phi_set_result (as_a <gphi *> (stmt), name);
-
-  replace_uses_by (lhs, name);
-  release_ssa_name (lhs);
-  return true;
+  replace_uses_by (old_name, new_name);
+  return new_name;
 }
 
 /* If the statement STMT contains any expressions that need to replaced with a
@@ -4713,7 +4697,16 @@
       gimple_stmt_iterator gsi;
 
       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
-	replace_removed_params_ssa_names (gsi_stmt (gsi), adjustments);
+	{
+	  gphi *phi = as_a <gphi *> (gsi_stmt (gsi));
+	  tree new_lhs, old_lhs = gimple_phi_result (phi);
+	  new_lhs = replace_removed_params_ssa_names (old_lhs, phi, adjustments);
+	  if (new_lhs)
+	    {
+	      gimple_phi_set_result (phi, new_lhs);
+	      release_ssa_name (old_lhs);
+	    }
+	}
 
       gsi = gsi_start_bb (bb);
       while (!gsi_end_p (gsi))
@@ -4733,7 +4726,6 @@
 
 	    case GIMPLE_ASSIGN:
 	      modified |= sra_ipa_modify_assign (stmt, &gsi, adjustments);
-	      modified |= replace_removed_params_ssa_names (stmt, adjustments);
 	      break;
 
 	    case GIMPLE_CALL:
@@ -4748,8 +4740,6 @@
 		{
 		  t = gimple_call_lhs_ptr (stmt);
 		  modified |= ipa_modify_expr (t, false, adjustments);
-		  modified |= replace_removed_params_ssa_names (stmt,
-								adjustments);
 		}
 	      break;
 
@@ -4773,6 +4763,20 @@
 	      break;
 	    }
 
+	  def_operand_p defp;
+	  ssa_op_iter iter;
+	  FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_DEF)
+	    {
+	      tree old_def = DEF_FROM_PTR (defp);
+	      if (tree new_def = replace_removed_params_ssa_names (old_def, stmt,
+								   adjustments))
+		{
+		  SET_DEF (defp, new_def);
+		  release_ssa_name (old_def);
+		  modified = true;
+		}
+	    }
+
 	  if (modified)
 	    {
 	      update_stmt (stmt);
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-alias.c gcc-5.2.0/gcc/tree-ssa-alias.c
--- gcc-5.2.0.orig/gcc/tree-ssa-alias.c	2015-01-15 16:58:42.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssa-alias.c	2015-09-17 07:50:54.117834000 -0500
@@ -1570,7 +1570,7 @@
      escape points.  See tree-ssa-structalias.c:find_func_aliases
      for the list of builtins we might need to handle here.  */
   if (callee != NULL_TREE
-      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)
+      && gimple_call_builtin_p (call, BUILT_IN_NORMAL))
     switch (DECL_FUNCTION_CODE (callee))
       {
 	/* All the following functions read memory pointed to by
@@ -1976,7 +1976,7 @@
      escape points.  See tree-ssa-structalias.c:find_func_aliases
      for the list of builtins we might need to handle here.  */
   if (callee != NULL_TREE
-      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)
+      && gimple_call_builtin_p (call, BUILT_IN_NORMAL))
     switch (DECL_FUNCTION_CODE (callee))
       {
 	/* All the following functions clobber memory pointed to by
@@ -2376,7 +2376,7 @@
     {
       tree callee = gimple_call_fndecl (stmt);
       if (callee != NULL_TREE
-	  && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)
+	  && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))
 	switch (DECL_FUNCTION_CODE (callee))
 	  {
 	  case BUILT_IN_FREE:
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-ccp.c gcc-5.2.0/gcc/tree-ssa-ccp.c
--- gcc-5.2.0.orig/gcc/tree-ssa-ccp.c	2015-02-02 09:01:28.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssa-ccp.c	2015-09-21 04:55:57.657387000 -0500
@@ -2064,6 +2064,7 @@
      as a declared array, so we allow a larger size.  */
   block = gimple_block (stmt);
   if (!(cfun->after_inlining
+	&& block
         && TREE_CODE (BLOCK_SUPERCONTEXT (block)) == FUNCTION_DECL))
     threshold /= 10;
   if (size > threshold)
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-dce.c gcc-5.2.0/gcc/tree-ssa-dce.c
--- gcc-5.2.0.orig/gcc/tree-ssa-dce.c	2015-05-27 09:05:37.000000000 -0500
+++ gcc-5.2.0/gcc/tree-ssa-dce.c	2015-08-31 07:46:14.348813000 -0500
@@ -1149,10 +1149,11 @@
 	if (e != e2)
 	  {
 	    cfg_altered = true;
-	    /* If we made a BB unconditionally exit a loop then this
-	       transform alters the set of BBs in the loop.  Schedule
-	       a fixup.  */
-	    if (loop_exit_edge_p (bb->loop_father, e))
+	    /* If we made a BB unconditionally exit a loop or removed
+	       an entry into an irreducible region, then this transform
+	       alters the set of BBs in the loop.  Schedule a fixup.  */
+	    if (loop_exit_edge_p (bb->loop_father, e)
+		|| (e2->dest->flags & BB_IRREDUCIBLE_LOOP))
 	      loops_state_set (LOOPS_NEED_FIXUP);
 	    remove_edge (e2);
 	  }
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-ifcombine.c gcc-5.2.0/gcc/tree-ssa-ifcombine.c
--- gcc-5.2.0.orig/gcc/tree-ssa-ifcombine.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssa-ifcombine.c	2015-09-30 06:45:40.491933000 -0500
@@ -60,6 +60,8 @@
 #include "tree-phinodes.h"
 #include "ssa-iterators.h"
 #include "tree-pass.h"
+#include "stringpool.h"
+#include "tree-ssanames.h"
 
 #ifndef LOGICAL_OP_NON_SHORT_CIRCUIT
 #define LOGICAL_OP_NON_SHORT_CIRCUIT \
@@ -800,7 +802,13 @@
 
       if (stmt
 	  && gimple_code (stmt) == GIMPLE_COND)
-	cfg_changed |= tree_ssa_ifcombine_bb (bb);
+	if (tree_ssa_ifcombine_bb (bb))
+	  {
+	    /* Clear range info from all stmts in BB which is now executed
+	       conditional on a always true/false condition.  */
+	    reset_flow_sensitive_info_in_bb (bb);
+	    cfg_changed |= true;
+	  }
     }
 
   free (bbs);
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-live.c gcc-5.2.0/gcc/tree-ssa-live.c
--- gcc-5.2.0.orig/gcc/tree-ssa-live.c	2015-03-30 16:56:02.000000000 -0500
+++ gcc-5.2.0/gcc/tree-ssa-live.c	2015-09-04 13:36:59.211750000 -0500
@@ -80,6 +80,7 @@
 #include "ipa-ref.h"
 #include "cgraph.h"
 #include "ipa-utils.h"
+#include "cfgloop.h"
 
 #ifdef ENABLE_CHECKING
 static void  verify_live_on_entry (tree_live_info_p);
@@ -941,6 +942,14 @@
 	  }
       }
 
+  if (cfun->has_simduid_loops)
+    {
+      struct loop *loop;
+      FOR_EACH_LOOP (loop, 0)
+	if (loop->simduid && !is_used_p (loop->simduid))
+	  loop->simduid = NULL_TREE;
+    }
+
   cfun->has_local_explicit_reg_vars = false;
 
   /* Remove unmarked local and global vars from local_decls.  */
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-loop-im.c gcc-5.2.0/gcc/tree-ssa-loop-im.c
--- gcc-5.2.0.orig/gcc/tree-ssa-loop-im.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssa-loop-im.c	2015-09-21 04:55:57.657387000 -0500
@@ -1862,6 +1862,23 @@
 
   if (loop_has_only_one_exit)
     ex = split_block_after_labels (ex->dest);
+  else
+    {
+      for (gphi_iterator gpi = gsi_start_phis (ex->dest);
+	   !gsi_end_p (gpi); gsi_next (&gpi))
+	{
+	  gphi *phi = gpi.phi ();
+	  if (virtual_operand_p (gimple_phi_result (phi)))
+	    continue;
+
+	  /* When the destination has a non-virtual PHI node with multiple
+	     predecessors make sure we preserve the PHI structure by
+	     forcing a forwarder block so that hoisting of that PHI will
+	     still work.  */
+	  split_edge (ex);
+	  break;
+	}
+    }
 
   old_dest = ex->dest;
   new_bb = split_edge (ex);
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-math-opts.c gcc-5.2.0/gcc/tree-ssa-math-opts.c
--- gcc-5.2.0.orig/gcc/tree-ssa-math-opts.c	2015-02-26 15:01:59.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssa-math-opts.c	2015-08-11 02:58:07.302195000 -0500
@@ -1856,7 +1856,7 @@
      the same base (array, structure, ...).  */
   if (gimple_assign_rhs1 (source_stmt1) != gimple_assign_rhs1 (source_stmt2))
     {
-      int64_t inc;
+      uint64_t inc;
       HOST_WIDE_INT start_sub, end_sub, end1, end2, end;
       struct symbolic_number *toinc_n_ptr, *n_end;
 
diff -Naur gcc-5.2.0.orig/gcc/tree-ssanames.c gcc-5.2.0/gcc/tree-ssanames.c
--- gcc-5.2.0.orig/gcc/tree-ssanames.c	2015-01-09 14:18:42.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssanames.c	2015-10-05 13:39:16.356142000 -0500
@@ -44,6 +44,7 @@
 #include "is-a.h"
 #include "gimple.h"
 #include "gimple-ssa.h"
+#include "gimple-iterator.h"
 #include "tree-phinodes.h"
 #include "ssa-iterators.h"
 #include "stringpool.h"
@@ -502,7 +503,6 @@
 
   gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));
   gcc_assert (!SSA_NAME_RANGE_INFO (name));
-  gcc_assert (!SSA_NAME_ANTI_RANGE_P (name));
 
   if (!range_info)
     return;
@@ -547,6 +547,46 @@
 }
 
 
+/* Reset all flow sensitive data on NAME such as range-info, nonzero
+   bits and alignment.  */
+
+void
+reset_flow_sensitive_info (tree name)
+{
+  if (POINTER_TYPE_P (TREE_TYPE (name)))
+    {
+      /* points-to info is not flow-sensitive.  */
+      if (SSA_NAME_PTR_INFO (name))
+	mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+    }
+  else
+    SSA_NAME_RANGE_INFO (name) = NULL;
+}
+
+/* Clear all flow sensitive data from all statements and PHI definitions
+   in BB.  */
+
+void
+reset_flow_sensitive_info_in_bb (basic_block bb)
+{
+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+      gimple stmt = gsi_stmt (gsi);
+      ssa_op_iter i;
+      tree op;
+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_DEF)
+	reset_flow_sensitive_info (op);
+    }
+
+  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+       gsi_next (&gsi))
+    {
+      tree phi_def = gimple_phi_result (gsi.phi ());
+      reset_flow_sensitive_info (phi_def);
+    }
+}
+
 /* Release all the SSA_NAMEs created by STMT.  */
 
 void
diff -Naur gcc-5.2.0.orig/gcc/tree-ssanames.h gcc-5.2.0/gcc/tree-ssanames.h
--- gcc-5.2.0.orig/gcc/tree-ssanames.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssanames.h	2015-09-30 06:45:40.491933000 -0500
@@ -94,6 +94,8 @@
 extern tree duplicate_ssa_name_fn (struct function *, tree, gimple);
 extern void duplicate_ssa_name_range_info (tree, enum value_range_type,
 					   struct range_info_def *);
+extern void reset_flow_sensitive_info (tree);
+extern void reset_flow_sensitive_info_in_bb (basic_block);
 extern void release_defs (gimple);
 extern void replace_ssa_name_symbol (tree, tree);
 
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-phiopt.c gcc-5.2.0/gcc/tree-ssa-phiopt.c
--- gcc-5.2.0.orig/gcc/tree-ssa-phiopt.c	2015-03-06 10:35:30.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssa-phiopt.c	2015-10-01 14:09:01.088801000 -0500
@@ -544,6 +544,7 @@
     }
 
   replace_phi_edge_with_variable (cond_bb, e1, phi, new_var);
+  reset_flow_sensitive_info_in_bb (cond_bb);
 
   /* Note that we optimized this PHI.  */
   return true;
@@ -1174,6 +1175,8 @@
   gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);
 
   replace_phi_edge_with_variable (cond_bb, e1, phi, result);
+  reset_flow_sensitive_info_in_bb (cond_bb);
+
   return true;
 }
 
@@ -1292,6 +1295,7 @@
     }
 
   replace_phi_edge_with_variable (cond_bb, e1, phi, result);
+  reset_flow_sensitive_info_in_bb (cond_bb);
 
   /* Note that we optimized this PHI.  */
   return true;
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-structalias.c gcc-5.2.0/gcc/tree-ssa-structalias.c
--- gcc-5.2.0.orig/gcc/tree-ssa-structalias.c	2015-02-16 12:15:19.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssa-structalias.c	2015-09-03 04:25:35.382468000 -0500
@@ -5650,7 +5650,6 @@
   auto_vec<fieldoff_s> fieldstack;
   fieldoff_s *fo;
   unsigned int i;
-  varpool_node *vnode;
 
   if (!declsize
       || !tree_fits_uhwi_p (declsize))
@@ -5668,12 +5667,10 @@
   /* Collect field information.  */
   if (use_field_sensitive
       && var_can_have_subvars (decl)
-      /* ???  Force us to not use subfields for global initializers
-	 in IPA mode.  Else we'd have to parse arbitrary initializers.  */
+      /* ???  Force us to not use subfields for globals in IPA mode.
+	 Else we'd have to parse arbitrary initializers.  */
       && !(in_ipa_mode
-	   && is_global_var (decl)
-	   && (vnode = varpool_node::get (decl))
-	   && vnode->get_constructor ()))
+	   && is_global_var (decl)))
     {
       fieldoff_s *fo = NULL;
       bool notokay = false;
@@ -5805,13 +5802,13 @@
 
 	  /* If this is a global variable with an initializer and we are in
 	     IPA mode generate constraints for it.  */
-	  if (vnode->get_constructor ()
-	      && vnode->definition)
+	  ipa_ref *ref;
+	  for (unsigned idx = 0; vnode->iterate_reference (idx, ref); ++idx)
 	    {
 	      auto_vec<ce_s> rhsc;
 	      struct constraint_expr lhs, *rhsp;
 	      unsigned i;
-	      get_constraint_for_rhs (vnode->get_constructor (), &rhsc);
+	      get_constraint_for_address_of (ref->referred->decl, &rhsc);
 	      lhs.var = vi->id;
 	      lhs.offset = 0;
 	      lhs.type = SCALAR;
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-tail-merge.c gcc-5.2.0/gcc/tree-ssa-tail-merge.c
--- gcc-5.2.0.orig/gcc/tree-ssa-tail-merge.c	2015-03-11 15:36:56.000000000 -0500
+++ gcc-5.2.0/gcc/tree-ssa-tail-merge.c	2015-09-30 06:45:40.491933000 -0500
@@ -235,6 +235,8 @@
 #include "cfgloop.h"
 #include "tree-pass.h"
 #include "trans-mem.h"
+#include "stringpool.h"
+#include "tree-ssanames.h"
 
 /* Describes a group of bbs with the same successors.  The successor bbs are
    cached in succs, and the successor edge flags are cached in succ_flags.
@@ -1558,6 +1560,10 @@
       e2->probability = GCOV_COMPUTE_SCALE (e2->count, out_sum);
     }
 
+  /* Clear range info from all stmts in BB2 -- this transformation
+     could make them out of date.  */
+  reset_flow_sensitive_info_in_bb (bb2);
+
   /* Do updates that use bb1, before deleting bb1.  */
   release_last_vdef (bb1);
   same_succ_flush_bb (bb1);
diff -Naur gcc-5.2.0.orig/gcc/tree-ssa-uninit.c gcc-5.2.0/gcc/tree-ssa-uninit.c
--- gcc-5.2.0.orig/gcc/tree-ssa-uninit.c	2015-02-12 15:29:21.000000000 -0600
+++ gcc-5.2.0/gcc/tree-ssa-uninit.c	2015-09-09 12:14:29.966193000 -0500
@@ -1310,7 +1310,8 @@
     return false;
 
   c1 = x1.cond_code;
-  if (x1.invert != x2.invert)
+  if (x1.invert != x2.invert
+      && TREE_CODE_CLASS (x2.cond_code) == tcc_comparison)
     c2 = invert_tree_comparison (x2.cond_code, false);
   else
     c2 = x2.cond_code;
diff -Naur gcc-5.2.0.orig/gcc/tree-vect-data-refs.c gcc-5.2.0/gcc/tree-vect-data-refs.c
--- gcc-5.2.0.orig/gcc/tree-vect-data-refs.c	2015-04-04 05:47:08.000000000 -0500
+++ gcc-5.2.0/gcc/tree-vect-data-refs.c	2015-09-28 05:45:55.478232000 -0500
@@ -648,7 +648,6 @@
   tree ref = DR_REF (dr);
   tree vectype;
   tree base, base_addr;
-  bool base_aligned;
   tree misalign;
   tree aligned_to;
   unsigned HOST_WIDE_INT alignment;
@@ -721,6 +720,19 @@
 	}
     }
 
+  /* To look at alignment of the base we have to preserve an inner MEM_REF
+     as that carries alignment information of the actual access.  */
+  base = ref;
+  while (handled_component_p (base))
+    base = TREE_OPERAND (base, 0);
+  if (TREE_CODE (base) == MEM_REF)
+    base = build2 (MEM_REF, TREE_TYPE (base), base_addr,
+		   build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)), 0));
+  unsigned int base_alignment = get_object_alignment (base);
+
+  if (base_alignment >= TYPE_ALIGN (TREE_TYPE (vectype)))
+    DR_VECT_AUX (dr)->base_element_aligned = true;
+
   alignment = TYPE_ALIGN_UNIT (vectype);
 
   if ((compare_tree_int (aligned_to, alignment) < 0)
@@ -736,21 +748,7 @@
       return true;
     }
 
-  /* To look at alignment of the base we have to preserve an inner MEM_REF
-     as that carries alignment information of the actual access.  */
-  base = ref;
-  while (handled_component_p (base))
-    base = TREE_OPERAND (base, 0);
-  if (TREE_CODE (base) == MEM_REF)
-    base = build2 (MEM_REF, TREE_TYPE (base), base_addr,
-		   build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)), 0));
-
-  if (get_object_alignment (base) >= TYPE_ALIGN (vectype))
-    base_aligned = true;
-  else
-    base_aligned = false;
-
-  if (!base_aligned)
+  if (base_alignment < TYPE_ALIGN (vectype))
     {
       /* Strip an inner MEM_REF to a bare decl if possible.  */
       if (TREE_CODE (base) == MEM_REF
@@ -780,8 +778,9 @@
           dump_printf (MSG_NOTE, "\n");
         }
 
-      ((dataref_aux *)dr->aux)->base_decl = base;
-      ((dataref_aux *)dr->aux)->base_misaligned = true;
+      DR_VECT_AUX (dr)->base_decl = base;
+      DR_VECT_AUX (dr)->base_misaligned = true;
+      DR_VECT_AUX (dr)->base_element_aligned = true;
     }
 
   /* If this is a backward running DR then first access in the larger
diff -Naur gcc-5.2.0.orig/gcc/tree-vectorizer.h gcc-5.2.0/gcc/tree-vectorizer.h
--- gcc-5.2.0.orig/gcc/tree-vectorizer.h	2015-04-04 05:47:08.000000000 -0500
+++ gcc-5.2.0/gcc/tree-vectorizer.h	2015-09-28 05:45:55.478232000 -0500
@@ -705,11 +705,16 @@
 #define STMT_SLP_TYPE(S)                   (S)->slp_type
 
 struct dataref_aux {
-  tree base_decl;
-  bool base_misaligned;
   int misalignment;
+  /* If true the alignment of base_decl needs to be increased.  */
+  bool base_misaligned;
+  /* If true we know the base is at least vector element alignment aligned.  */
+  bool base_element_aligned;
+  tree base_decl;
 };
 
+#define DR_VECT_AUX(dr) ((dataref_aux *)(dr)->aux)
+
 #define VECT_MAX_COST 1000
 
 /* The maximum number of intermediate steps required in multi-step type
@@ -908,14 +913,13 @@
   targetm.vectorize.destroy_cost_data (data);
 }
 
-
 /*-----------------------------------------------------------------*/
 /* Info on data references alignment.                              */
 /*-----------------------------------------------------------------*/
 inline void
 set_dr_misalignment (struct data_reference *dr, int val)
 {
-  dataref_aux *data_aux = (dataref_aux *) dr->aux;
+  dataref_aux *data_aux = DR_VECT_AUX (dr);
 
   if (!data_aux)
     {
@@ -929,8 +933,7 @@
 inline int
 dr_misalignment (struct data_reference *dr)
 {
-  gcc_assert (dr->aux);
-  return ((dataref_aux *) dr->aux)->misalignment;
+  return DR_VECT_AUX (dr)->misalignment;
 }
 
 /* Reflects actual alignment of first access in the vectorized loop,
diff -Naur gcc-5.2.0.orig/gcc/tree-vect-stmts.c gcc-5.2.0/gcc/tree-vect-stmts.c
--- gcc-5.2.0.orig/gcc/tree-vect-stmts.c	2015-06-16 09:25:55.000000000 -0500
+++ gcc-5.2.0/gcc/tree-vect-stmts.c	2015-09-28 05:45:55.478232000 -0500
@@ -4951,10 +4951,10 @@
   if (!dr->aux)
     return;
 
-  if (((dataref_aux *)dr->aux)->base_misaligned)
+  if (DR_VECT_AUX (dr)->base_misaligned)
     {
       tree vectype = STMT_VINFO_VECTYPE (stmt_info);
-      tree base_decl = ((dataref_aux *)dr->aux)->base_decl;
+      tree base_decl = DR_VECT_AUX (dr)->base_decl;
 
       if (decl_in_symtab_p (base_decl))
 	symtab_node::get (base_decl)->increase_alignment (TYPE_ALIGN (vectype));
@@ -4963,7 +4963,7 @@
           DECL_ALIGN (base_decl) = TYPE_ALIGN (vectype);
           DECL_USER_ALIGN (base_decl) = 1;
 	}
-      ((dataref_aux *)dr->aux)->base_misaligned = false;
+      DR_VECT_AUX (dr)->base_misaligned = false;
     }
 }
 
@@ -5449,11 +5449,15 @@
 		misalign = 0;
 	      else if (DR_MISALIGNMENT (first_dr) == -1)
 		{
+		  if (DR_VECT_AUX (first_dr)->base_element_aligned)
+		    align = TYPE_ALIGN_UNIT (elem_type);
+		  else
+		    align = get_object_alignment (DR_REF (first_dr))
+			/ BITS_PER_UNIT;
+		  misalign = 0;
 		  TREE_TYPE (data_ref)
 		    = build_aligned_type (TREE_TYPE (data_ref),
-					  TYPE_ALIGN (elem_type));
-		  align = TYPE_ALIGN_UNIT (elem_type);
-		  misalign = 0;
+					  align * BITS_PER_UNIT);
 		}
 	      else
 		{
@@ -6463,11 +6467,15 @@
 		      }
 		    else if (DR_MISALIGNMENT (first_dr) == -1)
 		      {
+			if (DR_VECT_AUX (first_dr)->base_element_aligned)
+			  align = TYPE_ALIGN_UNIT (elem_type);
+			else
+			  align = (get_object_alignment (DR_REF (first_dr))
+				   / BITS_PER_UNIT);
+			misalign = 0;
 			TREE_TYPE (data_ref)
 			  = build_aligned_type (TREE_TYPE (data_ref),
-						TYPE_ALIGN (elem_type));
-			align = TYPE_ALIGN_UNIT (elem_type);
-			misalign = 0;
+						align * BITS_PER_UNIT);
 		      }
 		    else
 		      {
diff -Naur gcc-5.2.0.orig/gcc/tsan.c gcc-5.2.0/gcc/tsan.c
--- gcc-5.2.0.orig/gcc/tsan.c	2015-03-19 05:12:34.000000000 -0500
+++ gcc-5.2.0/gcc/tsan.c	2015-08-05 06:20:59.983324000 -0500
@@ -535,7 +535,7 @@
 	  case fetch_op:
 	    last_arg = gimple_call_arg (stmt, num - 1);
 	    if (!tree_fits_uhwi_p (last_arg)
-		|| tree_to_uhwi (last_arg) > MEMMODEL_SEQ_CST)
+		|| memmodel_base (tree_to_uhwi (last_arg)) >= MEMMODEL_LAST)
 	      return;
 	    gimple_call_set_fndecl (stmt, decl);
 	    update_stmt (stmt);
@@ -600,10 +600,10 @@
 	    for (j = 0; j < 6; j++)
 	      args[j] = gimple_call_arg (stmt, j);
 	    if (!tree_fits_uhwi_p (args[4])
-		|| tree_to_uhwi (args[4]) > MEMMODEL_SEQ_CST)
+		|| memmodel_base (tree_to_uhwi (args[4])) >= MEMMODEL_LAST)
 	      return;
 	    if (!tree_fits_uhwi_p (args[5])
-		|| tree_to_uhwi (args[5]) > MEMMODEL_SEQ_CST)
+		|| memmodel_base (tree_to_uhwi (args[5])) >= MEMMODEL_LAST)
 	      return;
 	    update_gimple_call (gsi, decl, 5, args[0], args[1], args[2],
 				args[4], args[5]);
diff -Naur gcc-5.2.0.orig/gcc/varasm.c gcc-5.2.0/gcc/varasm.c
--- gcc-5.2.0.orig/gcc/varasm.c	2015-06-24 03:41:33.000000000 -0500
+++ gcc-5.2.0/gcc/varasm.c	2015-10-20 04:50:58.210558000 -0500
@@ -6908,12 +6908,13 @@
   return default_binds_local_p_3 (exp, flag_shlib != 0, true, false, false);
 }
 
-/* Similar to default_binds_local_p, but common symbol may be local.  */
+/* Similar to default_binds_local_p, but common symbol may be local and
+   extern protected data is non-local.  */
 
 bool
 default_binds_local_p_2 (const_tree exp)
 {
-  return default_binds_local_p_3 (exp, flag_shlib != 0, true, false,
+  return default_binds_local_p_3 (exp, flag_shlib != 0, true, true,
 				  !flag_pic);
 }
 
diff -Naur gcc-5.2.0.orig/gcc/version.c gcc-5.2.0/gcc/version.c
--- gcc-5.2.0.orig/gcc/version.c	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/version.c	2015-10-31 19:05:35.192183533 -0500
@@ -32,4 +32,4 @@
    Makefile.  */
 
 const char version_string[] = BASEVER DATESTAMP DEVPHASE REVISION;
-const char pkgversion_string[] = PKGVERSION;
+const char pkgversion_string[] = "(GCC for Cross-LFS 5.2.0.20151031) ";
diff -Naur gcc-5.2.0.orig/gcc/wide-int.cc gcc-5.2.0/gcc/wide-int.cc
--- gcc-5.2.0.orig/gcc/wide-int.cc	2015-02-24 02:07:10.000000000 -0600
+++ gcc-5.2.0/gcc/wide-int.cc	2015-10-16 22:55:03.723886000 -0500
@@ -258,13 +258,15 @@
     }
 
   /* Determine the number of unsigned HOST_WIDE_INTs that are required
-     for representing the value.  The code to calculate count is
+     for representing the absolute value.  The code to calculate count is
      extracted from the GMP manual, section "Integer Import and Export":
      http://gmplib.org/manual/Integer-Import-and-Export.html  */
   numb = CHAR_BIT * sizeof (HOST_WIDE_INT);
   count = (mpz_sizeinbase (x, 2) + numb - 1) / numb;
   HOST_WIDE_INT *val = res.write_val ();
-  /* Write directly to the wide_int storage if possible, otherwise leave
+  /* Read the absolute value.
+
+     Write directly to the wide_int storage if possible, otherwise leave
      GMP to allocate the memory for us.  It might be slightly more efficient
      to use mpz_tdiv_r_2exp for the latter case, but the situation is
      pathological and it seems safer to operate on the original mpz value
@@ -282,7 +284,12 @@
       memcpy (val, valres, count * sizeof (HOST_WIDE_INT));
       free (valres);
     }
-  res.set_len (canonize (val, count, prec));
+  /* Zero-extend the absolute value to PREC bits.  */
+  if (count < BLOCKS_NEEDED (prec) && val[count - 1] < 0)
+    val[count++] = 0;
+  else
+    count = canonize (val, count, prec);
+  res.set_len (count);
 
   if (mpz_sgn (x) < 0)
     res = -res;
diff -Naur gcc-5.2.0.orig/gcc/wide-int.h gcc-5.2.0/gcc/wide-int.h
--- gcc-5.2.0.orig/gcc/wide-int.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/gcc/wide-int.h	2015-10-19 14:44:58.238794000 -0500
@@ -365,21 +365,18 @@
      inputs.  Note that CONST_PRECISION and VAR_PRECISION cannot be
      mixed, in order to give stronger type checking.  When both inputs
      are CONST_PRECISION, they must have the same precision.  */
-  template <>
   template <typename T1, typename T2>
   struct binary_traits <T1, T2, FLEXIBLE_PRECISION, FLEXIBLE_PRECISION>
   {
     typedef widest_int result_type;
   };
 
-  template <>
   template <typename T1, typename T2>
   struct binary_traits <T1, T2, FLEXIBLE_PRECISION, VAR_PRECISION>
   {
     typedef wide_int result_type;
   };
 
-  template <>
   template <typename T1, typename T2>
   struct binary_traits <T1, T2, FLEXIBLE_PRECISION, CONST_PRECISION>
   {
@@ -389,14 +386,12 @@
 			       <int_traits <T2>::precision> > result_type;
   };
 
-  template <>
   template <typename T1, typename T2>
   struct binary_traits <T1, T2, VAR_PRECISION, FLEXIBLE_PRECISION>
   {
     typedef wide_int result_type;
   };
 
-  template <>
   template <typename T1, typename T2>
   struct binary_traits <T1, T2, CONST_PRECISION, FLEXIBLE_PRECISION>
   {
@@ -406,7 +401,6 @@
 			       <int_traits <T1>::precision> > result_type;
   };
 
-  template <>
   template <typename T1, typename T2>
   struct binary_traits <T1, T2, CONST_PRECISION, CONST_PRECISION>
   {
@@ -417,7 +411,6 @@
 			       <int_traits <T1>::precision> > result_type;
   };
 
-  template <>
   template <typename T1, typename T2>
   struct binary_traits <T1, T2, VAR_PRECISION, VAR_PRECISION>
   {
@@ -881,7 +874,6 @@
 
 namespace wi
 {
-  template <>
   template <typename storage>
   struct int_traits < generic_wide_int <storage> >
     : public wi::int_traits <storage>
@@ -960,7 +952,6 @@
 
 namespace wi
 {
-  template <>
   template <bool SE>
   struct int_traits <wide_int_ref_storage <SE> >
   {
@@ -1147,7 +1138,6 @@
 
 namespace wi
 {
-  template <>
   template <int N>
   struct int_traits < fixed_wide_int_storage <N> >
   {
diff -Naur gcc-5.2.0.orig/libffi/doc/libffi.info gcc-5.2.0/libffi/doc/libffi.info
--- gcc-5.2.0.orig/libffi/doc/libffi.info	2015-07-16 06:30:03.000000000 -0500
+++ gcc-5.2.0/libffi/doc/libffi.info	1969-12-31 18:00:00.000000000 -0600
@@ -1,762 +0,0 @@
-This is doc/libffi.info, produced by makeinfo version 4.12 from
-/space/rguenther/gcc-5.2.0/gcc-5.2.0/libffi/doc/libffi.texi.
-
-This manual is for Libffi, a portable foreign-function interface
-library.
-
-   Copyright (C) 2008, 2010, 2011 Red Hat, Inc.
-
-     Permission is granted to copy, distribute and/or modify this
-     document under the terms of the GNU General Public License as
-     published by the Free Software Foundation; either version 2, or
-     (at your option) any later version.  A copy of the license is
-     included in the section entitled "GNU General Public License".
-
-
-INFO-DIR-SECTION Development
-START-INFO-DIR-ENTRY
-* libffi: (libffi).             Portable foreign-function interface library.
-END-INFO-DIR-ENTRY
-
-
-File: libffi.info,  Node: Top,  Next: Introduction,  Up: (dir)
-
-libffi
-******
-
-This manual is for Libffi, a portable foreign-function interface
-library.
-
-   Copyright (C) 2008, 2010, 2011 Red Hat, Inc.
-
-     Permission is granted to copy, distribute and/or modify this
-     document under the terms of the GNU General Public License as
-     published by the Free Software Foundation; either version 2, or
-     (at your option) any later version.  A copy of the license is
-     included in the section entitled "GNU General Public License".
-
-
-* Menu:
-
-* Introduction::                What is libffi?
-* Using libffi::                How to use libffi.
-* Missing Features::            Things libffi can't do.
-* Index::                       Index.
-
-
-File: libffi.info,  Node: Introduction,  Next: Using libffi,  Prev: Top,  Up: Top
-
-1 What is libffi?
-*****************
-
-Compilers for high level languages generate code that follow certain
-conventions.  These conventions are necessary, in part, for separate
-compilation to work.  One such convention is the "calling convention".
-The calling convention is a set of assumptions made by the compiler
-about where function arguments will be found on entry to a function.  A
-calling convention also specifies where the return value for a function
-is found.  The calling convention is also sometimes called the "ABI" or
-"Application Binary Interface".  
-
-   Some programs may not know at the time of compilation what arguments
-are to be passed to a function.  For instance, an interpreter may be
-told at run-time about the number and types of arguments used to call a
-given function.  `Libffi' can be used in such programs to provide a
-bridge from the interpreter program to compiled code.
-
-   The `libffi' library provides a portable, high level programming
-interface to various calling conventions.  This allows a programmer to
-call any function specified by a call interface description at run time.
-
-   FFI stands for Foreign Function Interface.  A foreign function
-interface is the popular name for the interface that allows code
-written in one language to call code written in another language.  The
-`libffi' library really only provides the lowest, machine dependent
-layer of a fully featured foreign function interface.  A layer must
-exist above `libffi' that handles type conversions for values passed
-between the two languages.  
-
-
-File: libffi.info,  Node: Using libffi,  Next: Missing Features,  Prev: Introduction,  Up: Top
-
-2 Using libffi
-**************
-
-* Menu:
-
-* The Basics::                  The basic libffi API.
-* Simple Example::              A simple example.
-* Types::                       libffi type descriptions.
-* Multiple ABIs::               Different passing styles on one platform.
-* The Closure API::             Writing a generic function.
-* Closure Example::             A closure example.
-
-
-File: libffi.info,  Node: The Basics,  Next: Simple Example,  Up: Using libffi
-
-2.1 The Basics
-==============
-
-`Libffi' assumes that you have a pointer to the function you wish to
-call and that you know the number and types of arguments to pass it, as
-well as the return type of the function.
-
-   The first thing you must do is create an `ffi_cif' object that
-matches the signature of the function you wish to call.  This is a
-separate step because it is common to make multiple calls using a
-single `ffi_cif'.  The "cif" in `ffi_cif' stands for Call InterFace.
-To prepare a call interface object, use the function `ffi_prep_cif'.  
-
- -- Function: ffi_status ffi_prep_cif (ffi_cif *CIF, ffi_abi ABI,
-          unsigned int NARGS, ffi_type *RTYPE, ffi_type **ARGTYPES)
-     This initializes CIF according to the given parameters.
-
-     ABI is the ABI to use; normally `FFI_DEFAULT_ABI' is what you
-     want.  *note Multiple ABIs:: for more information.
-
-     NARGS is the number of arguments that this function accepts.
-
-     RTYPE is a pointer to an `ffi_type' structure that describes the
-     return type of the function.  *Note Types::.
-
-     ARGTYPES is a vector of `ffi_type' pointers.  ARGTYPES must have
-     NARGS elements.  If NARGS is 0, this argument is ignored.
-
-     `ffi_prep_cif' returns a `libffi' status code, of type
-     `ffi_status'.  This will be either `FFI_OK' if everything worked
-     properly; `FFI_BAD_TYPEDEF' if one of the `ffi_type' objects is
-     incorrect; or `FFI_BAD_ABI' if the ABI parameter is invalid.
-
-   If the function being called is variadic (varargs) then
-`ffi_prep_cif_var' must be used instead of `ffi_prep_cif'.
-
- -- Function: ffi_status ffi_prep_cif_var (ffi_cif *CIF, ffi_abi
-          varabi, unsigned int NFIXEDARGS, unsigned int varntotalargs,
-          ffi_type *RTYPE, ffi_type **ARGTYPES)
-     This initializes CIF according to the given parameters for a call
-     to a variadic function.  In general it's operation is the same as
-     for `ffi_prep_cif' except that:
-
-     NFIXEDARGS is the number of fixed arguments, prior to any variadic
-     arguments.  It must be greater than zero.
-
-     NTOTALARGS the total number of arguments, including variadic and
-     fixed arguments.
-
-     Note that, different cif's must be prepped for calls to the same
-     function when different numbers of arguments are passed.
-
-     Also note that a call to `ffi_prep_cif_var' with
-     NFIXEDARGS=NOTOTALARGS is NOT equivalent to a call to
-     `ffi_prep_cif'.
-
-
-   To call a function using an initialized `ffi_cif', use the
-`ffi_call' function:
-
- -- Function: void ffi_call (ffi_cif *CIF, void *FN, void *RVALUE, void
-          **AVALUES)
-     This calls the function FN according to the description given in
-     CIF.  CIF must have already been prepared using `ffi_prep_cif'.
-
-     RVALUE is a pointer to a chunk of memory that will hold the result
-     of the function call.  This must be large enough to hold the
-     result, no smaller than the system register size (generally 32 or
-     64 bits), and must be suitably aligned; it is the caller's
-     responsibility to ensure this.  If CIF declares that the function
-     returns `void' (using `ffi_type_void'), then RVALUE is ignored.
-
-     AVALUES is a vector of `void *' pointers that point to the memory
-     locations holding the argument values for a call.  If CIF declares
-     that the function has no arguments (i.e., NARGS was 0), then
-     AVALUES is ignored.  Note that argument values may be modified by
-     the callee (for instance, structs passed by value); the burden of
-     copying pass-by-value arguments is placed on the caller.
-
-
-File: libffi.info,  Node: Simple Example,  Next: Types,  Prev: The Basics,  Up: Using libffi
-
-2.2 Simple Example
-==================
-
-Here is a trivial example that calls `puts' a few times.
-
-     #include <stdio.h>
-     #include <ffi.h>
-
-     int main()
-     {
-       ffi_cif cif;
-       ffi_type *args[1];
-       void *values[1];
-       char *s;
-       ffi_arg rc;
-
-       /* Initialize the argument info vectors */
-       args[0] = &ffi_type_pointer;
-       values[0] = &s;
-
-       /* Initialize the cif */
-       if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
-     		       &ffi_type_sint, args) == FFI_OK)
-         {
-           s = "Hello World!";
-           ffi_call(&cif, puts, &rc, values);
-           /* rc now holds the result of the call to puts */
-
-           /* values holds a pointer to the function's arg, so to
-              call puts() again all we need to do is change the
-              value of s */
-           s = "This is cool!";
-           ffi_call(&cif, puts, &rc, values);
-         }
-
-       return 0;
-     }
-
-
-File: libffi.info,  Node: Types,  Next: Multiple ABIs,  Prev: Simple Example,  Up: Using libffi
-
-2.3 Types
-=========
-
-* Menu:
-
-* Primitive Types::             Built-in types.
-* Structures::                  Structure types.
-* Type Example::                Structure type example.
-* Complex::                     Complex types.
-* Complex Type Example::        Complex type example.
-
-
-File: libffi.info,  Node: Primitive Types,  Next: Structures,  Up: Types
-
-2.3.1 Primitive Types
----------------------
-
-`Libffi' provides a number of built-in type descriptors that can be
-used to describe argument and return types:
-
-`ffi_type_void'
-     The type `void'.  This cannot be used for argument types, only for
-     return values.
-
-`ffi_type_uint8'
-     An unsigned, 8-bit integer type.
-
-`ffi_type_sint8'
-     A signed, 8-bit integer type.
-
-`ffi_type_uint16'
-     An unsigned, 16-bit integer type.
-
-`ffi_type_sint16'
-     A signed, 16-bit integer type.
-
-`ffi_type_uint32'
-     An unsigned, 32-bit integer type.
-
-`ffi_type_sint32'
-     A signed, 32-bit integer type.
-
-`ffi_type_uint64'
-     An unsigned, 64-bit integer type.
-
-`ffi_type_sint64'
-     A signed, 64-bit integer type.
-
-`ffi_type_float'
-     The C `float' type.
-
-`ffi_type_double'
-     The C `double' type.
-
-`ffi_type_uchar'
-     The C `unsigned char' type.
-
-`ffi_type_schar'
-     The C `signed char' type.  (Note that there is not an exact
-     equivalent to the C `char' type in `libffi'; ordinarily you should
-     either use `ffi_type_schar' or `ffi_type_uchar' depending on
-     whether `char' is signed.)
-
-`ffi_type_ushort'
-     The C `unsigned short' type.
-
-`ffi_type_sshort'
-     The C `short' type.
-
-`ffi_type_uint'
-     The C `unsigned int' type.
-
-`ffi_type_sint'
-     The C `int' type.
-
-`ffi_type_ulong'
-     The C `unsigned long' type.
-
-`ffi_type_slong'
-     The C `long' type.
-
-`ffi_type_longdouble'
-     On platforms that have a C `long double' type, this is defined.
-     On other platforms, it is not.
-
-`ffi_type_pointer'
-     A generic `void *' pointer.  You should use this for all pointers,
-     regardless of their real type.
-
-`ffi_type_complex_float'
-     The C `_Complex float' type.
-
-`ffi_type_complex_double'
-     The C `_Complex double' type.
-
-`ffi_type_complex_longdouble'
-     The C `_Complex long double' type.  On platforms that have a C
-     `long double' type, this is defined.  On other platforms, it is
-     not.
-
-   Each of these is of type `ffi_type', so you must take the address
-when passing to `ffi_prep_cif'.
-
-
-File: libffi.info,  Node: Structures,  Next: Type Example,  Prev: Primitive Types,  Up: Types
-
-2.3.2 Structures
-----------------
-
-Although `libffi' has no special support for unions or bit-fields, it
-is perfectly happy passing structures back and forth.  You must first
-describe the structure to `libffi' by creating a new `ffi_type' object
-for it.
-
- -- Data type: ffi_type
-     The `ffi_type' has the following members:
-    `size_t size'
-          This is set by `libffi'; you should initialize it to zero.
-
-    `unsigned short alignment'
-          This is set by `libffi'; you should initialize it to zero.
-
-    `unsigned short type'
-          For a structure, this should be set to `FFI_TYPE_STRUCT'.
-
-    `ffi_type **elements'
-          This is a `NULL'-terminated array of pointers to `ffi_type'
-          objects.  There is one element per field of the struct.
-
-
-File: libffi.info,  Node: Type Example,  Next: Complex,  Prev: Structures,  Up: Types
-
-2.3.3 Type Example
-------------------
-
-The following example initializes a `ffi_type' object representing the
-`tm' struct from Linux's `time.h'.
-
-   Here is how the struct is defined:
-
-     struct tm {
-         int tm_sec;
-         int tm_min;
-         int tm_hour;
-         int tm_mday;
-         int tm_mon;
-         int tm_year;
-         int tm_wday;
-         int tm_yday;
-         int tm_isdst;
-         /* Those are for future use. */
-         long int __tm_gmtoff__;
-         __const char *__tm_zone__;
-     };
-
-   Here is the corresponding code to describe this struct to `libffi':
-
-         {
-           ffi_type tm_type;
-           ffi_type *tm_type_elements[12];
-           int i;
-
-           tm_type.size = tm_type.alignment = 0;
-           tm_type.type = FFI_TYPE_STRUCT;
-           tm_type.elements = &tm_type_elements;
-
-           for (i = 0; i < 9; i++)
-               tm_type_elements[i] = &ffi_type_sint;
-
-           tm_type_elements[9] = &ffi_type_slong;
-           tm_type_elements[10] = &ffi_type_pointer;
-           tm_type_elements[11] = NULL;
-
-           /* tm_type can now be used to represent tm argument types and
-     	 return types for ffi_prep_cif() */
-         }
-
-
-File: libffi.info,  Node: Complex,  Next: Complex Type Example,  Prev: Type Example,  Up: Types
-
-2.3.4 Complex Types
--------------------
-
-`libffi' supports the complex types defined by the C99 standard
-(`_Complex float', `_Complex double' and `_Complex long double' with
-the built-in type descriptors `ffi_type_complex_float',
-`ffi_type_complex_double' and `ffi_type_complex_longdouble'.
-
-   Custom complex types like `_Complex int' can also be used.  An
-`ffi_type' object has to be defined to describe the complex type to
-`libffi'.
-
- -- Data type: ffi_type
-    `size_t size'
-          This must be manually set to the size of the complex type.
-
-    `unsigned short alignment'
-          This must be manually set to the alignment of the complex
-          type.
-
-    `unsigned short type'
-          For a complex type, this must be set to `FFI_TYPE_COMPLEX'.
-
-    `ffi_type **elements'
-          This is a `NULL'-terminated array of pointers to `ffi_type'
-          objects.  The first element is set to the `ffi_type' of the
-          complex's base type.  The second element must be set to
-          `NULL'.
-
-   The section *note Complex Type Example:: shows a way to determine
-the `size' and `alignment' members in a platform independent way.
-
-   For platforms that have no complex support in `libffi' yet, the
-functions `ffi_prep_cif' and `ffi_prep_args' abort the program if they
-encounter a complex type.
-
-
-File: libffi.info,  Node: Complex Type Example,  Prev: Complex,  Up: Types
-
-2.3.5 Complex Type Example
---------------------------
-
-This example demonstrates how to use complex types:
-
-     #include <stdio.h>
-     #include <ffi.h>
-     #include <complex.h>
-
-     void complex_fn(_Complex float cf,
-                     _Complex double cd,
-                     _Complex long double cld)
-     {
-       printf("cf=%f+%fi\ncd=%f+%fi\ncld=%f+%fi\n",
-              (float)creal (cf), (float)cimag (cf),
-              (float)creal (cd), (float)cimag (cd),
-              (float)creal (cld), (float)cimag (cld));
-     }
-
-     int main()
-     {
-       ffi_cif cif;
-       ffi_type *args[3];
-       void *values[3];
-       _Complex float cf;
-       _Complex double cd;
-       _Complex long double cld;
-
-       /* Initialize the argument info vectors */
-       args[0] = &ffi_type_complex_float;
-       args[1] = &ffi_type_complex_double;
-       args[2] = &ffi_type_complex_longdouble;
-       values[0] = &cf;
-       values[1] = &cd;
-       values[2] = &cld;
-
-       /* Initialize the cif */
-       if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
-                        &ffi_type_void, args) == FFI_OK)
-         {
-           cf = 1.0 + 20.0 * I;
-           cd = 300.0 + 4000.0 * I;
-           cld = 50000.0 + 600000.0 * I;
-           /* Call the function */
-           ffi_call(&cif, (void (*)(void))complex_fn, 0, values);
-         }
-
-       return 0;
-     }
-
-   This is an example for defining a custom complex type descriptor for
-compilers that support them:
-
-     /*
-      * This macro can be used to define new complex type descriptors
-      * in a platform independent way.
-      *
-      * name: Name of the new descriptor is ffi_type_complex_<name>.
-      * type: The C base type of the complex type.
-      */
-     #define FFI_COMPLEX_TYPEDEF(name, type, ffitype)             \
-       static ffi_type *ffi_elements_complex_##name [2] = {      \
-         (ffi_type *)(&ffitype), NULL                             \
-       };                                                        \
-       struct struct_align_complex_##name {                      \
-         char c;                                                  \
-         _Complex type x;                                         \
-       };                                                        \
-       ffi_type ffi_type_complex_##name = {                      \
-         sizeof(_Complex type),                                   \
-         offsetof(struct struct_align_complex_##name, x),         \
-         FFI_TYPE_COMPLEX,                                        \
-         (ffi_type **)ffi_elements_complex_##name                 \
-       }
-
-     /* Define new complex type descriptors using the macro: */
-     /* ffi_type_complex_sint */
-     FFI_COMPLEX_TYPEDEF(sint, int, ffi_type_sint);
-     /* ffi_type_complex_uchar */
-     FFI_COMPLEX_TYPEDEF(uchar, unsigned char, ffi_type_uint8);
-
-   The new type descriptors can then be used like one of the built-in
-type descriptors in the previous example.
-
-
-File: libffi.info,  Node: Multiple ABIs,  Next: The Closure API,  Prev: Types,  Up: Using libffi
-
-2.4 Multiple ABIs
-=================
-
-A given platform may provide multiple different ABIs at once.  For
-instance, the x86 platform has both `stdcall' and `fastcall' functions.
-
-   `libffi' provides some support for this.  However, this is
-necessarily platform-specific.
-
-
-File: libffi.info,  Node: The Closure API,  Next: Closure Example,  Prev: Multiple ABIs,  Up: Using libffi
-
-2.5 The Closure API
-===================
-
-`libffi' also provides a way to write a generic function - a function
-that can accept and decode any combination of arguments.  This can be
-useful when writing an interpreter, or to provide wrappers for
-arbitrary functions.
-
-   This facility is called the "closure API".  Closures are not
-supported on all platforms; you can check the `FFI_CLOSURES' define to
-determine whether they are supported on the current platform.  
-
-   Because closures work by assembling a tiny function at runtime, they
-require special allocation on platforms that have a non-executable
-heap.  Memory management for closures is handled by a pair of functions:
-
- -- Function: void *ffi_closure_alloc (size_t SIZE, void **CODE)
-     Allocate a chunk of memory holding SIZE bytes.  This returns a
-     pointer to the writable address, and sets *CODE to the
-     corresponding executable address.
-
-     SIZE should be sufficient to hold a `ffi_closure' object.
-
- -- Function: void ffi_closure_free (void *WRITABLE)
-     Free memory allocated using `ffi_closure_alloc'.  The argument is
-     the writable address that was returned.
-
-   Once you have allocated the memory for a closure, you must construct
-a `ffi_cif' describing the function call.  Finally you can prepare the
-closure function:
-
- -- Function: ffi_status ffi_prep_closure_loc (ffi_closure *CLOSURE,
-          ffi_cif *CIF, void (*FUN) (ffi_cif *CIF, void *RET, void
-          **ARGS, void *USER_DATA), void *USER_DATA, void *CODELOC)
-     Prepare a closure function.
-
-     CLOSURE is the address of a `ffi_closure' object; this is the
-     writable address returned by `ffi_closure_alloc'.
-
-     CIF is the `ffi_cif' describing the function parameters.
-
-     USER_DATA is an arbitrary datum that is passed, uninterpreted, to
-     your closure function.
-
-     CODELOC is the executable address returned by `ffi_closure_alloc'.
-
-     FUN is the function which will be called when the closure is
-     invoked.  It is called with the arguments:
-    CIF
-          The `ffi_cif' passed to `ffi_prep_closure_loc'.
-
-    RET
-          A pointer to the memory used for the function's return value.
-          FUN must fill this, unless the function is declared as
-          returning `void'.
-
-    ARGS
-          A vector of pointers to memory holding the arguments to the
-          function.
-
-    USER_DATA
-          The same USER_DATA that was passed to `ffi_prep_closure_loc'.
-
-     `ffi_prep_closure_loc' will return `FFI_OK' if everything went ok,
-     and something else on error.
-
-     After calling `ffi_prep_closure_loc', you can cast CODELOC to the
-     appropriate pointer-to-function type.
-
-   You may see old code referring to `ffi_prep_closure'.  This function
-is deprecated, as it cannot handle the need for separate writable and
-executable addresses.
-
-
-File: libffi.info,  Node: Closure Example,  Prev: The Closure API,  Up: Using libffi
-
-2.6 Closure Example
-===================
-
-A trivial example that creates a new `puts' by binding `fputs' with
-`stdout'.
-
-     #include <stdio.h>
-     #include <ffi.h>
-
-     /* Acts like puts with the file given at time of enclosure. */
-     void puts_binding(ffi_cif *cif, void *ret, void* args[],
-                       void *stream)
-     {
-       *(ffi_arg *)ret = fputs(*(char **)args[0], (FILE *)stream);
-     }
-
-     typedef int (*puts_t)(char *);
-
-     int main()
-     {
-       ffi_cif cif;
-       ffi_type *args[1];
-       ffi_closure *closure;
-
-       void *bound_puts;
-       int rc;
-
-       /* Allocate closure and bound_puts */
-       closure = ffi_closure_alloc(sizeof(ffi_closure), &bound_puts);
-
-       if (closure)
-         {
-           /* Initialize the argument info vectors */
-           args[0] = &ffi_type_pointer;
-
-           /* Initialize the cif */
-           if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
-                            &ffi_type_sint, args) == FFI_OK)
-             {
-               /* Initialize the closure, setting stream to stdout */
-               if (ffi_prep_closure_loc(closure, &cif, puts_binding,
-                                        stdout, bound_puts) == FFI_OK)
-                 {
-                   rc = ((puts_t)bound_puts)("Hello World!");
-                   /* rc now holds the result of the call to fputs */
-                 }
-             }
-         }
-
-       /* Deallocate both closure, and bound_puts */
-       ffi_closure_free(closure);
-
-       return 0;
-     }
-
-
-File: libffi.info,  Node: Missing Features,  Next: Index,  Prev: Using libffi,  Up: Top
-
-3 Missing Features
-******************
-
-`libffi' is missing a few features.  We welcome patches to add support
-for these.
-
-   * Variadic closures.
-
-   * There is no support for bit fields in structures.
-
-   * The "raw" API is undocumented.
-
-   Note that variadic support is very new and tested on a relatively
-small number of platforms.
-
-
-File: libffi.info,  Node: Index,  Prev: Missing Features,  Up: Top
-
-Index
-*****
-
- [index ]
-* Menu:
-
-* ABI:                                   Introduction.         (line 13)
-* Application Binary Interface:          Introduction.         (line 13)
-* calling convention:                    Introduction.         (line 13)
-* cif:                                   The Basics.           (line 14)
-* closure API:                           The Closure API.      (line 13)
-* closures:                              The Closure API.      (line 13)
-* FFI:                                   Introduction.         (line 31)
-* ffi_call:                              The Basics.           (line 63)
-* ffi_closure_alloc:                     The Closure API.      (line 19)
-* ffi_closure_free:                      The Closure API.      (line 26)
-* FFI_CLOSURES:                          The Closure API.      (line 13)
-* ffi_prep_cif:                          The Basics.           (line 16)
-* ffi_prep_cif_var:                      The Basics.           (line 39)
-* ffi_prep_closure_loc:                  The Closure API.      (line 34)
-* ffi_status <1>:                        The Closure API.      (line 37)
-* ffi_status:                            The Basics.           (line 18)
-* ffi_type <1>:                          Complex.              (line 15)
-* ffi_type:                              Structures.           (line 11)
-* ffi_type_complex_double:               Primitive Types.      (line 82)
-* ffi_type_complex_float:                Primitive Types.      (line 79)
-* ffi_type_complex_longdouble:           Primitive Types.      (line 85)
-* ffi_type_double:                       Primitive Types.      (line 41)
-* ffi_type_float:                        Primitive Types.      (line 38)
-* ffi_type_longdouble:                   Primitive Types.      (line 71)
-* ffi_type_pointer:                      Primitive Types.      (line 75)
-* ffi_type_schar:                        Primitive Types.      (line 47)
-* ffi_type_sint:                         Primitive Types.      (line 62)
-* ffi_type_sint16:                       Primitive Types.      (line 23)
-* ffi_type_sint32:                       Primitive Types.      (line 29)
-* ffi_type_sint64:                       Primitive Types.      (line 35)
-* ffi_type_sint8:                        Primitive Types.      (line 17)
-* ffi_type_slong:                        Primitive Types.      (line 68)
-* ffi_type_sshort:                       Primitive Types.      (line 56)
-* ffi_type_uchar:                        Primitive Types.      (line 44)
-* ffi_type_uint:                         Primitive Types.      (line 59)
-* ffi_type_uint16:                       Primitive Types.      (line 20)
-* ffi_type_uint32:                       Primitive Types.      (line 26)
-* ffi_type_uint64:                       Primitive Types.      (line 32)
-* ffi_type_uint8:                        Primitive Types.      (line 14)
-* ffi_type_ulong:                        Primitive Types.      (line 65)
-* ffi_type_ushort:                       Primitive Types.      (line 53)
-* ffi_type_void:                         Primitive Types.      (line 10)
-* Foreign Function Interface:            Introduction.         (line 31)
-* void <1>:                              The Closure API.      (line 20)
-* void:                                  The Basics.           (line 65)
-
-
-
-Tag Table:
-Node: Top736
-Node: Introduction1484
-Node: Using libffi3120
-Node: The Basics3606
-Node: Simple Example7260
-Node: Types8291
-Node: Primitive Types8675
-Node: Structures10795
-Node: Type Example11665
-Node: Complex12947
-Node: Complex Type Example14360
-Node: Multiple ABIs17412
-Node: The Closure API17783
-Node: Closure Example20727
-Node: Missing Features22336
-Node: Index22764
-
-End Tag Table
diff -Naur gcc-5.2.0.orig/libffi/testsuite/lib/libffi.exp gcc-5.2.0/libffi/testsuite/lib/libffi.exp
--- gcc-5.2.0.orig/libffi/testsuite/lib/libffi.exp	2015-03-29 15:46:17.000000000 -0500
+++ gcc-5.2.0/libffi/testsuite/lib/libffi.exp	2015-10-26 19:41:31.527984000 -0500
@@ -24,6 +24,7 @@
 load_lib dg.exp
 load_lib libgloss.exp
 load_gcc_lib target-supports.exp
+load_gcc_lib target-supports-dg.exp
 load_gcc_lib target-libpath.exp
 load_gcc_lib wrapper.exp
 
diff -Naur gcc-5.2.0.orig/libffi/testsuite/libffi.call/float2.c gcc-5.2.0/libffi/testsuite/libffi.call/float2.c
--- gcc-5.2.0.orig/libffi/testsuite/libffi.call/float2.c	2015-01-12 10:19:59.000000000 -0600
+++ gcc-5.2.0/libffi/testsuite/libffi.call/float2.c	2015-10-26 19:41:31.527984000 -0500
@@ -3,7 +3,7 @@
    Limitations:	none.
    PR:		none.
    Originator:	From the original ffitest.c  */
-/* { dg-do run } */
+/* { dg-do run { target { ! hppa*-*-hpux* } } } */
 
 #include "ffitest.h"
 #include "float.h"
diff -Naur gcc-5.2.0.orig/libgcc/config/gmon-sol2.c gcc-5.2.0/libgcc/config/gmon-sol2.c
--- gcc-5.2.0.orig/libgcc/config/gmon-sol2.c	2011-06-01 09:46:24.000000000 -0500
+++ gcc-5.2.0/libgcc/config/gmon-sol2.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,444 +0,0 @@
-/*-
- * Copyright (c) 1991 The Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. [rescinded 22 July 1999]
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/* Mangled into a form that works on Solaris 2/SPARC by Mark Eichin
- * for Cygnus Support, July 1992.
- *
- * Modified to support Solaris 2/x86 by J.W.Hawtin <oolon@ankh.org>, 14/8/96.
- *
- * It must be used in conjunction with sol2-gc1.S, which is used to start
- * and stop process monitoring.
- */
-
-#include "tconfig.h"
-#include "tsystem.h"
-#include <fcntl.h>		/* For creat.  */
-
-extern void monstartup (char *, char *);
-extern void _mcleanup (void);
-#ifdef __i386__
-static void internal_mcount (void) __attribute__ ((used));
-#else
-static void internal_mcount (char *, unsigned short *) __attribute__ ((used));
-#endif
-static void moncontrol (int);
-
-struct phdr {
-  char *lpc;
-  char *hpc;
-  int ncnt;
-};
-
-#define HISTFRACTION	2
-#define HISTCOUNTER	unsigned short
-#define HASHFRACTION	1
-#define ARCDENSITY	2
-#define MINARCS		50
-
-struct tostruct {
-  char *selfpc;
-  long count;
-  unsigned short link;
-};
-
-struct rawarc {
-  unsigned long raw_frompc;
-  unsigned long raw_selfpc;
-  long raw_count;
-};
-
-#define ROUNDDOWN(x, y)	(((x) / (y)) * (y))
-#define ROUNDUP(x, y)	((((x) + (y) - 1) / (y)) * (y))
-
-/* froms is actually a bunch of unsigned shorts indexing tos.  */
-static int profiling = 3;
-static unsigned short *froms;
-static struct tostruct *tos = NULL;
-static long tolimit = 0;
-static char *s_lowpc = NULL;
-static char *s_highpc = NULL;
-static size_t s_textsize = 0;
-
-static int ssiz;
-static char *sbuf;
-static int s_scale;
-/* See profil(2) where this is describe (incorrectly).  */
-#define	SCALE_1_TO_1	0x10000L
-
-#define	MSG "No space for profiling buffer(s)\n"
-
-void
-monstartup (char *lowpc, char *highpc)
-{
-  size_t monsize;
-  char *buffer;
-  size_t o;
-
-  /* Round lowpc and highpc to multiples of the density we're using
-     so the rest of the scaling (here and in gprof) stays in ints.  */
-  lowpc = (char *) ROUNDDOWN ((size_t) lowpc,
-			      HISTFRACTION * sizeof (HISTCOUNTER));
-  s_lowpc = lowpc;
-  highpc = (char *) ROUNDUP ((size_t) highpc,
-			     HISTFRACTION * sizeof (HISTCOUNTER));
-  s_highpc = highpc;
-  s_textsize = highpc - lowpc;
-  monsize = (s_textsize / HISTFRACTION) + sizeof (struct phdr);
-  buffer = sbrk (monsize);
-  if (buffer == (void *) -1) {
-    write (STDERR_FILENO, MSG, sizeof (MSG));
-    return;
-  }
-  froms = sbrk (s_textsize / HASHFRACTION);
-  if (froms == (void *) -1) {
-    write (STDERR_FILENO, MSG, sizeof (MSG));
-    froms = NULL;
-    return;
-  }
-  tolimit = s_textsize * ARCDENSITY / 100;
-  if (tolimit < MINARCS) {
-    tolimit = MINARCS;
-  } else if (tolimit > 65534) {
-    tolimit = 65534;
-  }
-  tos = sbrk (tolimit * sizeof (struct tostruct));
-  if (tos == (void *) -1) {
-    write (STDERR_FILENO, MSG, sizeof (MSG));
-    froms = NULL;
-    tos = NULL;
-    return;
-  }
-  tos[0].link = 0;
-  sbuf = buffer;
-  ssiz = monsize;
-  ((struct phdr *) buffer)->lpc = lowpc;
-  ((struct phdr *) buffer)->hpc = highpc;
-  ((struct phdr *) buffer)->ncnt = ssiz;
-  monsize -= sizeof (struct phdr);
-  if (monsize <= 0)
-    return;
-  o = highpc - lowpc;
-  if(monsize < o)
-    s_scale = ((float) monsize / o) * SCALE_1_TO_1;
-  else
-    s_scale = SCALE_1_TO_1;
-  moncontrol (1);
-}
-
-void
-_mcleanup (void)
-{
-  int fd;
-  int fromindex;
-  int endfrom;
-  char *frompc;
-  int toindex;
-  struct rawarc	rawarc;
-  char *profdir;
-  const char *proffile;
-  char *progname;
-  char buf[PATH_MAX];
-  extern char **___Argv;
-
-  moncontrol (0);
-
-  if ((profdir = getenv ("PROFDIR")) != NULL) {
-    /* If PROFDIR contains a null value, no profiling output is produced.  */
-    if (*profdir == '\0') {
-      return;
-    }
-
-    progname = strrchr (___Argv[0], '/');
-    if (progname == NULL)
-      progname = ___Argv[0];
-    else
-      progname++;
-
-    sprintf (buf, "%s/%ld.%s", profdir, (long) getpid (), progname);
-    proffile = buf;
-  } else {
-    proffile = "gmon.out";
-  }
-
-  fd = creat (proffile, 0666);
-  if (fd < 0) {
-    perror (proffile);
-    return;
-  }
-#ifdef DEBUG
-  fprintf (stderr, "[mcleanup] sbuf %#x ssiz %d\n", sbuf, ssiz);
-#endif /* DEBUG */
-
-  write (fd, sbuf, ssiz);
-  endfrom = s_textsize / (HASHFRACTION * sizeof (*froms));
-  for (fromindex = 0; fromindex < endfrom; fromindex++) {
-    if (froms[fromindex] == 0) {
-      continue;
-    }
-    frompc = s_lowpc + (fromindex * HASHFRACTION * sizeof (*froms));
-    for (toindex = froms[fromindex];
-	 toindex != 0;
-	 toindex = tos[toindex].link) {
-#ifdef DEBUG
-      fprintf (stderr, "[mcleanup] frompc %#x selfpc %#x count %d\n",
-	       frompc, tos[toindex].selfpc, tos[toindex].count);
-#endif /* DEBUG */
-      rawarc.raw_frompc = (unsigned long) frompc;
-      rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;
-      rawarc.raw_count = tos[toindex].count;
-      write (fd, &rawarc, sizeof (rawarc));
-    }
-  }
-  close (fd);
-}
-
-/* Solaris 2 libraries use _mcount.  */
-#if defined __i386__
-asm(".globl _mcount\n"
-    "_mcount:\n"
-    "	jmp	internal_mcount\n");
-#elif defined __x86_64__
-/* See GLIBC for additional information about this technique.  */
-asm(".globl _mcount\n" 
-    "	.type	_mcount, @function\n"
-    "_mcount:\n"
-    /* The compiler calls _mcount after the prologue, and does not
-       save any of the registers.  Therefore we must preserve all
-       seven registers which may contain function arguments.  */
-    "	subq	$0x38, %rsp\n"
-    "	movq	%rax, (%rsp)\n"
-    "	movq	%rcx, 0x08(%rsp)\n"
-    "	movq	%rdx, 0x10(%rsp)\n"
-    "	movq	%rsi, 0x18(%rsp)\n"
-    "	movq	%rdi, 0x20(%rsp)\n"
-    "	movq	%r8, 0x28(%rsp)\n"
-    "	movq	%r9, 0x30(%rsp)\n"
-    /* Get SELFPC (pushed by the call to this function) and
-       FROMPCINDEX (via the frame pointer).  */
-    "	movq	0x38(%rsp), %rdi\n"
-    "	movq	0x8(%rbp), %rsi\n"
-    "	call	internal_mcount\n"
-    /* Restore the saved registers.  */
-    "	movq	0x30(%rsp), %r9\n"
-    "	movq	0x28(%rsp), %r8\n"
-    "	movq	0x20(%rsp), %rdi\n"
-    "	movq	0x18(%rsp), %rsi\n"
-    "	movq	0x10(%rsp), %rdx\n"
-    "	movq	0x08(%rsp), %rcx\n"
-    "	movq	(%rsp), %rax\n"
-    "	addq	$0x38, %rsp\n"
-    "	retq\n");
-#elif defined __sparc__
-/* The SPARC stack frame is only held together by the frame pointers
-   in the register windows. According to the SVR4 SPARC ABI
-   Supplement, Low Level System Information/Operating System
-   Interface/Software Trap Types, a type 3 trap will flush all of the
-   register windows to the stack, which will make it possible to walk
-   the frames and find the return addresses.
-	However, it seems awfully expensive to incur a trap (system
-   call) for every function call. It turns out that "call" simply puts
-   the return address in %o7 expecting the "save" in the procedure to
-   shift it into %i7; this means that before the "save" occurs, %o7
-   contains the address of the call to mcount, and %i7 still contains
-   the caller above that. The asm mcount here simply saves those
-   registers in argument registers and branches to internal_mcount,
-   simulating a call with arguments.
-	Kludges:
-	1) the branch to internal_mcount is hard coded; it should be
-   possible to tell asm to use the assembler-name of a symbol.
-	2) in theory, the function calling mcount could have saved %i7
-   somewhere and reused the register; in practice, I *think* this will
-   break longjmp (and maybe the debugger) but I'm not certain. (I take
-   some comfort in the knowledge that it will break the native mcount
-   as well.)
-	3) if builtin_return_address worked, this could be portable.
-   However, it would really have to be optimized for arguments of 0
-   and 1 and do something like what we have here in order to avoid the
-   trap per function call performance hit. 
-	4) the atexit and monsetup calls prevent this from simply
-   being a leaf routine that doesn't do a "save" (and would thus have
-   access to %o7 and %i7 directly) but the call to write() at the end
-   would have also prevented this.
-
-   -- [eichin:19920702.1107EST]  */
-asm(".global _mcount\n"
-    "_mcount:\n"
-    /* i7 == last ret, -> frompcindex.  */
-    "	mov	%i7, %o1\n"
-    /* o7 == current ret, -> selfpc.  */
-    "	mov	%o7, %o0\n"
-    "	b,a	internal_mcount\n");
-#endif
-
-static void
-#ifdef __i386__
-internal_mcount (void)
-#else
-internal_mcount (char *selfpc, unsigned short *frompcindex)
-#endif
-{
-  struct tostruct *top;
-  struct tostruct *prevtop;
-  long toindex;
-  static char already_setup;
-
-#ifdef __i386__
-  char *selfpc;
-  unsigned short *frompcindex;
-
-  /* Find the return address for mcount and the return address for mcount's
-     caller.  */
-
-  /* selfpc = pc pushed by mcount call.
-     This identifies the function that was just entered.  */
-  selfpc = (void *) __builtin_return_address (0);
-  /* frompcindex = pc in preceding frame.
-     This identifies the caller of the function just entered.  */
-  frompcindex = (void *) __builtin_return_address (1);
-#endif
-
-  if(!already_setup) {
-    extern char etext[];
-
-    already_setup = 1;
-
-#if defined __i386__
-    /* <sys/vmparam.h> USERSTACK.  */
-    monstartup ((char *) 0x8048000, etext);
-#elif defined __x86_64__
-    monstartup (NULL, etext);
-#elif defined __sparc__
-    {
-      extern char _start[];
-      extern char _init[];
-
-      monstartup (_start < _init ? _start : _init, etext);
-    }
-#endif
-    atexit (_mcleanup);
-  }
-  /* Check that we are profiling and that we aren't recursively invoked.  */
-  if (profiling) {
-    goto out;
-  }
-  profiling++;
-  /* Check that frompcindex is a reasonable pc value.  For example: signal
-     catchers get called from the stack, not from text space.  too bad.  */
-  frompcindex = (unsigned short *) ((long) frompcindex - (long) s_lowpc);
-  if ((unsigned long) frompcindex > s_textsize) {
-    goto done;
-  }
-  frompcindex = &froms[((long) frompcindex) / (HASHFRACTION * sizeof (*froms))];
-  toindex = *frompcindex;
-  if (toindex == 0) {
-    /* First time traversing this arc.  */
-    toindex = ++tos[0].link;
-    if (toindex >= tolimit) {
-      goto overflow;
-    }
-    *frompcindex = toindex;
-    top = &tos[toindex];
-    top->selfpc = selfpc;
-    top->count = 1;
-    top->link = 0;
-    goto done;
-  }
-  top = &tos[toindex];
-  if (top->selfpc == selfpc) {
-    /* arc at front of chain; usual case.  */
-    top->count++;
-    goto done;
-  }
-  /* Have to go looking down chain for it.  Top points to what we are
-     looking at, prevtop points to previous top.  We know it is not at the
-     head of the chain.  */
-  for (; /* goto done */; ) {
-    if (top->link == 0) {
-      /* top is end of the chain and none of the chain had top->selfpc ==
-	 selfpc, so we allocate a new tostruct and link it to the head of
-	 the chain.  */
-      toindex = ++tos[0].link;
-      if (toindex >= tolimit) {
-	goto overflow;
-      }
-      top = &tos[toindex];
-      top->selfpc = selfpc;
-      top->count = 1;
-      top->link = *frompcindex;
-      *frompcindex = toindex;
-      goto done;
-    }
-    /* Otherwise, check the next arc on the chain.  */
-    prevtop = top;
-    top = &tos[top->link];
-    if (top->selfpc == selfpc) {
-      /* There it is.  Increment its count move it to the head of the
-	 chain.  */
-      top->count++;
-      toindex = prevtop->link;
-      prevtop->link = top->link;
-      top->link = *frompcindex;
-      *frompcindex = toindex;
-      goto done;
-    }
-
-  }
- done:
-  profiling--;
-  /* ... and fall through. */
- out:
-  /* Normal return restores saved registers.  */
-  return;
-
- overflow:
-  /* Halt further profiling.  */
-  profiling++;
-
-#define	TOLIMIT	"mcount: tos overflow\n"
-  write (STDERR_FILENO, TOLIMIT, sizeof (TOLIMIT));
-  goto out;
-}
-
-/* Control profiling.  Profiling is what mcount checks to see if all the
-   data structures are ready.  */
-static void
-moncontrol (int mode)
-{
-  if (mode) {
-    /* Start.  */
-    profil ((unsigned short *) (sbuf + sizeof (struct phdr)),
-	    ssiz - sizeof (struct phdr), (size_t) s_lowpc, s_scale);
-    profiling = 0;
-  } else {
-    /* Stop.  */
-    profil ((unsigned short *) 0, 0, 0, 0);
-    profiling = 3;
-  }
-}
diff -Naur gcc-5.2.0.orig/libgcc/config/i386/cpuinfo.c gcc-5.2.0/libgcc/config/i386/cpuinfo.c
--- gcc-5.2.0.orig/libgcc/config/i386/cpuinfo.c	2015-01-25 12:17:46.000000000 -0600
+++ gcc-5.2.0/libgcc/config/i386/cpuinfo.c	2015-10-18 13:35:25.884360000 -0500
@@ -156,6 +156,9 @@
       /* Bulldozer version 3 "Steamroller"  */
       if (model >= 0x30 && model <= 0x4f)
 	__cpu_model.__cpu_subtype = AMDFAM15H_BDVER3;
+      /* Bulldozer version 4 "Excavator"   */
+      if (model >= 0x60 && model <= 0x7f)
+	__cpu_model.__cpu_subtype = AMDFAM15H_BDVER4;
       break;
     /* AMD Family 16h "btver2" */
     case 0x16:
@@ -406,7 +409,7 @@
       if (family == 0x0f)
 	{
 	  family += extended_family;
-	  model += (extended_model << 4);
+	  model += extended_model;
 	}
 
       /* Get CPU type.  */
diff -Naur gcc-5.2.0.orig/libgcc/config/nios2/linux-atomic.c gcc-5.2.0/libgcc/config/nios2/linux-atomic.c
--- gcc-5.2.0.orig/libgcc/config/nios2/linux-atomic.c	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libgcc/config/nios2/linux-atomic.c	2015-07-23 04:03:33.148977000 -0500
@@ -20,11 +20,6 @@
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
-#include <asm/unistd.h>
-#define EFAULT  14
-#define EBUSY   16
-#define ENOSYS  38
-
 /* We implement byte, short and int versions of each atomic operation
    using the kernel helper defined below.  There is no support for
    64-bit operations yet.  */
diff -Naur gcc-5.2.0.orig/libgcc/config/pa/linux-atomic.c gcc-5.2.0/libgcc/config/pa/linux-atomic.c
--- gcc-5.2.0.orig/libgcc/config/pa/linux-atomic.c	2015-07-01 12:43:35.000000000 -0500
+++ gcc-5.2.0/libgcc/config/pa/linux-atomic.c	2015-09-23 18:29:08.993775000 -0500
@@ -88,12 +88,17 @@
 	: "i" (2)
 	: "r1", "r20", "r22", "r29", "r31", "fr4", "memory"
   );
+
+  /* If the kernel LWS call is successful, lws_ret contains 0.  */
+  if (__builtin_expect (lws_ret == 0, 1))
+    return 0;
+
   if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
     __builtin_trap ();
 
-  /* If the kernel LWS call fails, return EBUSY */
-  if (!lws_errno && lws_ret)
-    lws_errno = -EBUSY;
+  /* If the kernel LWS call fails with no error, return -EBUSY */
+  if (__builtin_expect (!lws_errno, 0))
+    return -EBUSY;
 
   return lws_errno;
 }
@@ -111,7 +116,7 @@
   __sync_fetch_and_##OP##_##WIDTH (TYPE *ptr, TYPE val)			\
   {									\
     TYPE tmp, newval;							\
-    int failure;							\
+    long failure;							\
 									\
     do {								\
       tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
@@ -122,6 +127,13 @@
     return tmp;								\
   }
 
+FETCH_AND_OP_2 (add,   , +, long long, 8, 3)
+FETCH_AND_OP_2 (sub,   , -, long long, 8, 3)
+FETCH_AND_OP_2 (or,    , |, long long, 8, 3)
+FETCH_AND_OP_2 (and,   , &, long long, 8, 3)
+FETCH_AND_OP_2 (xor,   , ^, long long, 8, 3)
+FETCH_AND_OP_2 (nand, ~, &, long long, 8, 3)
+
 FETCH_AND_OP_2 (add,   , +, short, 2, 1)
 FETCH_AND_OP_2 (sub,   , -, short, 2, 1)
 FETCH_AND_OP_2 (or,    , |, short, 2, 1)
@@ -141,7 +153,7 @@
   __sync_##OP##_and_fetch_##WIDTH (TYPE *ptr, TYPE val)			\
   {									\
     TYPE tmp, newval;							\
-    int failure;							\
+    long failure;							\
 									\
     do {								\
       tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
@@ -152,6 +164,13 @@
     return PFX_OP (tmp INF_OP val);					\
   }
 
+OP_AND_FETCH_2 (add,   , +, long long, 8, 3)
+OP_AND_FETCH_2 (sub,   , -, long long, 8, 3)
+OP_AND_FETCH_2 (or,    , |, long long, 8, 3)
+OP_AND_FETCH_2 (and,   , &, long long, 8, 3)
+OP_AND_FETCH_2 (xor,   , ^, long long, 8, 3)
+OP_AND_FETCH_2 (nand, ~, &, long long, 8, 3)
+
 OP_AND_FETCH_2 (add,   , +, short, 2, 1)
 OP_AND_FETCH_2 (sub,   , -, short, 2, 1)
 OP_AND_FETCH_2 (or,    , |, short, 2, 1)
@@ -170,7 +189,8 @@
   int HIDDEN								\
   __sync_fetch_and_##OP##_4 (int *ptr, int val)				\
   {									\
-    int failure, tmp;							\
+    int tmp;								\
+    long failure;							\
 									\
     do {								\
       tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
@@ -191,7 +211,8 @@
   int HIDDEN								\
   __sync_##OP##_and_fetch_4 (int *ptr, int val)				\
   {									\
-    int tmp, failure;							\
+    int tmp;								\
+    long failure;							\
 									\
     do {								\
       tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
@@ -216,7 +237,7 @@
 				       TYPE newval)			\
   {									\
     TYPE actual_oldval;							\
-    int fail;								\
+    long fail;								\
 									\
     while (1)								\
       {									\
@@ -236,17 +257,19 @@
   __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
 					TYPE newval)			\
   {									\
-    int failure = __kernel_cmpxchg2 (ptr, &oldval, &newval, INDEX);	\
-    return (failure != 0);						\
+    long failure = __kernel_cmpxchg2 (ptr, &oldval, &newval, INDEX);	\
+    return (failure == 0);						\
   }
 
+COMPARE_AND_SWAP_2 (long long, 8, 3)
 COMPARE_AND_SWAP_2 (short, 2, 1)
 COMPARE_AND_SWAP_2 (char, 1, 0)
 
 int HIDDEN
 __sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)
 {
-  int actual_oldval, fail;
+  long fail;
+  int actual_oldval;
     
   while (1)
     {
@@ -265,7 +288,7 @@
 bool HIDDEN
 __sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)
 {
-  int failure = __kernel_cmpxchg (ptr, oldval, newval);
+  long failure = __kernel_cmpxchg (ptr, oldval, newval);
   return (failure == 0);
 }
 
@@ -274,7 +297,7 @@
   __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)		\
   {									\
     TYPE oldval;							\
-    int failure;							\
+    long failure;							\
 									\
     do {								\
       oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
@@ -284,13 +307,15 @@
     return oldval;							\
   }
 
+SYNC_LOCK_TEST_AND_SET_2 (long long, 8, 3)
 SYNC_LOCK_TEST_AND_SET_2 (short, 2, 1)
 SYNC_LOCK_TEST_AND_SET_2 (signed char, 1, 0)
 
 int HIDDEN
 __sync_lock_test_and_set_4 (int *ptr, int val)
 {
-  int failure, oldval;
+  long failure;
+  int oldval;
 
   do {
     oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
@@ -304,7 +329,8 @@
   void HIDDEN							\
   __sync_lock_release_##WIDTH (TYPE *ptr)			\
   {								\
-    TYPE failure, oldval, zero = 0;				\
+    TYPE oldval, zero = 0;					\
+    long failure;						\
 								\
     do {							\
       oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);		\
@@ -312,13 +338,15 @@
     } while (failure != 0);					\
   }
 
+SYNC_LOCK_RELEASE_2 (long long, 8, 3)
 SYNC_LOCK_RELEASE_2 (short, 2, 1)
 SYNC_LOCK_RELEASE_2 (signed char, 1, 0)
 
 void HIDDEN
 __sync_lock_release_4 (int *ptr)
 {
-  int failure, oldval;
+  long failure;
+  int oldval;
 
   do {
     oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
diff -Naur gcc-5.2.0.orig/libgcc/config/sol2/crtp.c gcc-5.2.0/libgcc/config/sol2/crtp.c
--- gcc-5.2.0.orig/libgcc/config/sol2/crtp.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libgcc/config/sol2/crtp.c	2015-10-01 06:51:45.551063000 -0500
@@ -0,0 +1,33 @@
+/* Dummy _mcount when mixing profiling and non-profiling objects.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+void _mcount (void);
+
+/* A dummy profiling support routine for non-profiling executables,
+   in case we link in some objects that have been compiled for profiling.  */
+
+void __attribute__((weak))
+_mcount (void)
+{
+}
diff -Naur gcc-5.2.0.orig/libgcc/config/sol2/crtpg.c gcc-5.2.0/libgcc/config/sol2/crtpg.c
--- gcc-5.2.0.orig/libgcc/config/sol2/crtpg.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libgcc/config/sol2/crtpg.c	2015-10-01 06:51:45.551063000 -0500
@@ -0,0 +1,47 @@
+/* Register profiling startup and cleanup with Solaris CRTs.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+
+extern void monstartup (char *, char *);
+extern void _mcleanup (void);
+
+extern char _start[], _etext[];
+
+int __start_crt_compiler (int, char **);
+
+/* Since Solaris 11.x and Solaris 12, the system-provided CRTs provide a
+   hook to invoke initialization code early during process startup.
+   __start_crt_compiler is documented in crt1.o(5).  We use it to perform
+   initialization for profiling as a substitute for the earlier separate
+   gcrt1.o.  */
+
+int
+__start_crt_compiler (int argc __attribute__ ((unused)),
+		      char **argv __attribute__ ((unused)))
+{
+  monstartup (_start, _etext);
+  atexit (_mcleanup);
+  return 0;
+}
diff -Naur gcc-5.2.0.orig/libgcc/config/sol2/gmon.c gcc-5.2.0/libgcc/config/sol2/gmon.c
--- gcc-5.2.0.orig/libgcc/config/sol2/gmon.c	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libgcc/config/sol2/gmon.c	2015-10-01 07:01:18.897040000 -0500
@@ -0,0 +1,451 @@
+/*-
+ * Copyright (c) 1991 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. [rescinded 22 July 1999]
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* Mangled into a form that works on Solaris 2/SPARC by Mark Eichin
+ * for Cygnus Support, July 1992.
+ *
+ * Modified to support Solaris 2/x86 by J.W.Hawtin <oolon@ankh.org>, 14/8/96.
+ *
+ * It must be used in conjunction with sol2-gc1.S, which is used to start
+ * and stop process monitoring.
+ */
+
+#include "tconfig.h"
+#include "tsystem.h"
+#include "auto-target.h"
+#include <fcntl.h>		/* For creat.  */
+
+extern void monstartup (char *, char *);
+extern void _mcleanup (void);
+#ifdef __i386__
+static void internal_mcount (void) __attribute__ ((used));
+#else
+static void internal_mcount (char *, unsigned short *) __attribute__ ((used));
+#endif
+static void moncontrol (int);
+
+struct phdr {
+  char *lpc;
+  char *hpc;
+  int ncnt;
+};
+
+#define HISTFRACTION	2
+#define HISTCOUNTER	unsigned short
+#define HASHFRACTION	1
+#define ARCDENSITY	2
+#define MINARCS		50
+
+struct tostruct {
+  char *selfpc;
+  long count;
+  unsigned short link;
+};
+
+struct rawarc {
+  unsigned long raw_frompc;
+  unsigned long raw_selfpc;
+  long raw_count;
+};
+
+#define ROUNDDOWN(x, y)	(((x) / (y)) * (y))
+#define ROUNDUP(x, y)	((((x) + (y) - 1) / (y)) * (y))
+
+/* froms is actually a bunch of unsigned shorts indexing tos.  */
+static int profiling = 3;
+static unsigned short *froms;
+static struct tostruct *tos = NULL;
+static long tolimit = 0;
+static char *s_lowpc = NULL;
+static char *s_highpc = NULL;
+static size_t s_textsize = 0;
+
+static int ssiz;
+static char *sbuf;
+static int s_scale;
+/* See profil(2) where this is describe (incorrectly).  */
+#define	SCALE_1_TO_1	0x10000L
+
+#define	MSG "No space for profiling buffer(s)\n"
+
+void
+monstartup (char *lowpc, char *highpc)
+{
+  size_t monsize;
+  char *buffer;
+  size_t o;
+
+  /* Round lowpc and highpc to multiples of the density we're using
+     so the rest of the scaling (here and in gprof) stays in ints.  */
+  lowpc = (char *) ROUNDDOWN ((size_t) lowpc,
+			      HISTFRACTION * sizeof (HISTCOUNTER));
+  s_lowpc = lowpc;
+  highpc = (char *) ROUNDUP ((size_t) highpc,
+			     HISTFRACTION * sizeof (HISTCOUNTER));
+  s_highpc = highpc;
+  s_textsize = highpc - lowpc;
+  monsize = (s_textsize / HISTFRACTION) + sizeof (struct phdr);
+  buffer = sbrk (monsize);
+  if (buffer == (void *) -1) {
+    write (STDERR_FILENO, MSG, sizeof (MSG) - 1);
+    return;
+  }
+  froms = sbrk (s_textsize / HASHFRACTION);
+  if (froms == (void *) -1) {
+    write (STDERR_FILENO, MSG, sizeof (MSG) - 1);
+    froms = NULL;
+    return;
+  }
+  tolimit = s_textsize * ARCDENSITY / 100;
+  if (tolimit < MINARCS) {
+    tolimit = MINARCS;
+  } else if (tolimit > 65534) {
+    tolimit = 65534;
+  }
+  tos = sbrk (tolimit * sizeof (struct tostruct));
+  if (tos == (void *) -1) {
+    write (STDERR_FILENO, MSG, sizeof (MSG) - 1);
+    froms = NULL;
+    tos = NULL;
+    return;
+  }
+  tos[0].link = 0;
+  sbuf = buffer;
+  ssiz = monsize;
+  ((struct phdr *) buffer)->lpc = lowpc;
+  ((struct phdr *) buffer)->hpc = highpc;
+  ((struct phdr *) buffer)->ncnt = ssiz;
+  monsize -= sizeof (struct phdr);
+  if (monsize <= 0)
+    return;
+  o = highpc - lowpc;
+  if(monsize < o)
+    s_scale = ((float) monsize / o) * SCALE_1_TO_1;
+  else
+    s_scale = SCALE_1_TO_1;
+  moncontrol (1);
+}
+
+void
+_mcleanup (void)
+{
+  int fd;
+  int fromindex;
+  int endfrom;
+  char *frompc;
+  int toindex;
+  struct rawarc	rawarc;
+  char *profdir;
+  const char *proffile;
+  char *progname;
+  char buf[PATH_MAX];
+  extern char **___Argv;
+
+  moncontrol (0);
+
+  if ((profdir = getenv ("PROFDIR")) != NULL) {
+    /* If PROFDIR contains a null value, no profiling output is produced.  */
+    if (*profdir == '\0') {
+      return;
+    }
+
+    progname = strrchr (___Argv[0], '/');
+    if (progname == NULL)
+      progname = ___Argv[0];
+    else
+      progname++;
+
+    sprintf (buf, "%s/%ld.%s", profdir, (long) getpid (), progname);
+    proffile = buf;
+  } else {
+    proffile = "gmon.out";
+  }
+
+  fd = creat (proffile, 0666);
+  if (fd < 0) {
+    perror (proffile);
+    return;
+  }
+#ifdef DEBUG
+  fprintf (stderr, "[mcleanup] sbuf %#x ssiz %d\n", sbuf, ssiz);
+#endif /* DEBUG */
+
+  write (fd, sbuf, ssiz);
+  endfrom = s_textsize / (HASHFRACTION * sizeof (*froms));
+  for (fromindex = 0; fromindex < endfrom; fromindex++) {
+    if (froms[fromindex] == 0) {
+      continue;
+    }
+    frompc = s_lowpc + (fromindex * HASHFRACTION * sizeof (*froms));
+    for (toindex = froms[fromindex];
+	 toindex != 0;
+	 toindex = tos[toindex].link) {
+#ifdef DEBUG
+      fprintf (stderr, "[mcleanup] frompc %#x selfpc %#x count %d\n",
+	       frompc, tos[toindex].selfpc, tos[toindex].count);
+#endif /* DEBUG */
+      rawarc.raw_frompc = (unsigned long) frompc;
+      rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;
+      rawarc.raw_count = tos[toindex].count;
+      write (fd, &rawarc, sizeof (rawarc));
+    }
+  }
+  close (fd);
+}
+
+/* Solaris 2 libraries use _mcount.  */
+#if defined __i386__
+asm(".globl _mcount\n"
+    "_mcount:\n"
+    "	jmp	internal_mcount\n");
+#elif defined __x86_64__
+/* See GLIBC for additional information about this technique.  */
+asm(".globl _mcount\n" 
+    "	.type	_mcount, @function\n"
+    "_mcount:\n"
+    /* The compiler calls _mcount after the prologue, and does not
+       save any of the registers.  Therefore we must preserve all
+       seven registers which may contain function arguments.  */
+    "	subq	$0x38, %rsp\n"
+    "	movq	%rax, (%rsp)\n"
+    "	movq	%rcx, 0x08(%rsp)\n"
+    "	movq	%rdx, 0x10(%rsp)\n"
+    "	movq	%rsi, 0x18(%rsp)\n"
+    "	movq	%rdi, 0x20(%rsp)\n"
+    "	movq	%r8, 0x28(%rsp)\n"
+    "	movq	%r9, 0x30(%rsp)\n"
+    /* Get SELFPC (pushed by the call to this function) and
+       FROMPCINDEX (via the frame pointer).  */
+    "	movq	0x38(%rsp), %rdi\n"
+    "	movq	0x8(%rbp), %rsi\n"
+    "	call	internal_mcount\n"
+    /* Restore the saved registers.  */
+    "	movq	0x30(%rsp), %r9\n"
+    "	movq	0x28(%rsp), %r8\n"
+    "	movq	0x20(%rsp), %rdi\n"
+    "	movq	0x18(%rsp), %rsi\n"
+    "	movq	0x10(%rsp), %rdx\n"
+    "	movq	0x08(%rsp), %rcx\n"
+    "	movq	(%rsp), %rax\n"
+    "	addq	$0x38, %rsp\n"
+    "	retq\n");
+#elif defined __sparc__
+/* The SPARC stack frame is only held together by the frame pointers
+   in the register windows. According to the SVR4 SPARC ABI
+   Supplement, Low Level System Information/Operating System
+   Interface/Software Trap Types, a type 3 trap will flush all of the
+   register windows to the stack, which will make it possible to walk
+   the frames and find the return addresses.
+	However, it seems awfully expensive to incur a trap (system
+   call) for every function call. It turns out that "call" simply puts
+   the return address in %o7 expecting the "save" in the procedure to
+   shift it into %i7; this means that before the "save" occurs, %o7
+   contains the address of the call to mcount, and %i7 still contains
+   the caller above that. The asm mcount here simply saves those
+   registers in argument registers and branches to internal_mcount,
+   simulating a call with arguments.
+	Kludges:
+	1) the branch to internal_mcount is hard coded; it should be
+   possible to tell asm to use the assembler-name of a symbol.
+	2) in theory, the function calling mcount could have saved %i7
+   somewhere and reused the register; in practice, I *think* this will
+   break longjmp (and maybe the debugger) but I'm not certain. (I take
+   some comfort in the knowledge that it will break the native mcount
+   as well.)
+	3) if builtin_return_address worked, this could be portable.
+   However, it would really have to be optimized for arguments of 0
+   and 1 and do something like what we have here in order to avoid the
+   trap per function call performance hit. 
+	4) the atexit and monsetup calls prevent this from simply
+   being a leaf routine that doesn't do a "save" (and would thus have
+   access to %o7 and %i7 directly) but the call to write() at the end
+   would have also prevented this.
+
+   -- [eichin:19920702.1107EST]  */
+asm(".global _mcount\n"
+    "_mcount:\n"
+    /* i7 == last ret, -> frompcindex.  */
+    "	mov	%i7, %o1\n"
+    /* o7 == current ret, -> selfpc.  */
+    "	mov	%o7, %o0\n"
+    "	b,a	internal_mcount\n");
+#endif
+
+static void
+#ifdef __i386__
+internal_mcount (void)
+#else
+internal_mcount (char *selfpc, unsigned short *frompcindex)
+#endif
+{
+  struct tostruct *top;
+  struct tostruct *prevtop;
+  long toindex;
+  static char already_setup;
+
+#ifdef __i386__
+  char *selfpc;
+  unsigned short *frompcindex;
+
+  /* Find the return address for mcount and the return address for mcount's
+     caller.  */
+
+  /* selfpc = pc pushed by mcount call.
+     This identifies the function that was just entered.  */
+  selfpc = (void *) __builtin_return_address (0);
+  /* frompcindex = pc in preceding frame.
+     This identifies the caller of the function just entered.  */
+  frompcindex = (void *) __builtin_return_address (1);
+#endif
+
+/* Only necessary without the Solaris CRTs or a proper gcrt1.o, otherwise
+   crtpg.o or gcrt1.o take care of that.
+
+   FIXME: What about _init vs. _start on sparc?  */
+#ifndef HAVE_SOLARIS_CRTS
+  if(!already_setup) {
+    extern char etext[];
+
+    already_setup = 1;
+
+#if defined __i386__
+    /* <sys/vmparam.h> USERSTACK.  */
+    monstartup ((char *) 0x8048000, etext);
+#elif defined __x86_64__
+    monstartup (NULL, etext);
+#elif defined __sparc__
+    {
+      extern char _start[];
+      extern char _init[];
+
+      monstartup (_start < _init ? _start : _init, etext);
+    }
+#endif
+    atexit (_mcleanup);
+  }
+#endif /* !HAVE_SOLARIS_CRTS */
+  /* Check that we are profiling and that we aren't recursively invoked.  */
+  if (profiling) {
+    goto out;
+  }
+  profiling++;
+  /* Check that frompcindex is a reasonable pc value.  For example: signal
+     catchers get called from the stack, not from text space.  too bad.  */
+  frompcindex = (unsigned short *) ((long) frompcindex - (long) s_lowpc);
+  if ((unsigned long) frompcindex > s_textsize) {
+    goto done;
+  }
+  frompcindex = &froms[((long) frompcindex) / (HASHFRACTION * sizeof (*froms))];
+  toindex = *frompcindex;
+  if (toindex == 0) {
+    /* First time traversing this arc.  */
+    toindex = ++tos[0].link;
+    if (toindex >= tolimit) {
+      goto overflow;
+    }
+    *frompcindex = toindex;
+    top = &tos[toindex];
+    top->selfpc = selfpc;
+    top->count = 1;
+    top->link = 0;
+    goto done;
+  }
+  top = &tos[toindex];
+  if (top->selfpc == selfpc) {
+    /* arc at front of chain; usual case.  */
+    top->count++;
+    goto done;
+  }
+  /* Have to go looking down chain for it.  Top points to what we are
+     looking at, prevtop points to previous top.  We know it is not at the
+     head of the chain.  */
+  for (; /* goto done */; ) {
+    if (top->link == 0) {
+      /* top is end of the chain and none of the chain had top->selfpc ==
+	 selfpc, so we allocate a new tostruct and link it to the head of
+	 the chain.  */
+      toindex = ++tos[0].link;
+      if (toindex >= tolimit) {
+	goto overflow;
+      }
+      top = &tos[toindex];
+      top->selfpc = selfpc;
+      top->count = 1;
+      top->link = *frompcindex;
+      *frompcindex = toindex;
+      goto done;
+    }
+    /* Otherwise, check the next arc on the chain.  */
+    prevtop = top;
+    top = &tos[top->link];
+    if (top->selfpc == selfpc) {
+      /* There it is.  Increment its count move it to the head of the
+	 chain.  */
+      top->count++;
+      toindex = prevtop->link;
+      prevtop->link = top->link;
+      top->link = *frompcindex;
+      *frompcindex = toindex;
+      goto done;
+    }
+
+  }
+ done:
+  profiling--;
+  /* ... and fall through. */
+ out:
+  /* Normal return restores saved registers.  */
+  return;
+
+ overflow:
+  /* Halt further profiling.  */
+  profiling++;
+
+#define	TOLIMIT	"mcount: tos overflow\n"
+  write (STDERR_FILENO, TOLIMIT, sizeof (TOLIMIT) - 1);
+  goto out;
+}
+
+/* Control profiling.  Profiling is what mcount checks to see if all the
+   data structures are ready.  */
+static void
+moncontrol (int mode)
+{
+  if (mode) {
+    /* Start.  */
+    profil ((unsigned short *) (sbuf + sizeof (struct phdr)),
+	    ssiz - sizeof (struct phdr), (size_t) s_lowpc, s_scale);
+    profiling = 0;
+  } else {
+    /* Stop.  */
+    profil ((unsigned short *) 0, 0, 0, 0);
+    profiling = 3;
+  }
+}
diff -Naur gcc-5.2.0.orig/libgcc/config/sol2/t-sol2 gcc-5.2.0/libgcc/config/sol2/t-sol2
--- gcc-5.2.0.orig/libgcc/config/sol2/t-sol2	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libgcc/config/sol2/t-sol2	2015-10-01 07:01:18.897040000 -0500
@@ -0,0 +1,33 @@
+# Copyright (C) 2004-2015 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# crtp, crtpg build rules
+crtp.o: $(srcdir)/config/sol2/crtp.c
+	$(crt_compile) $(CRTSTUFF_T_CFLAGS_S) -c $<
+crtpg.o: $(srcdir)/config/sol2/crtpg.c
+	$(crt_compile) $(CRTSTUFF_T_CFLAGS_S) -c $<
+
+# gmon build rule
+gmon.o:	$(srcdir)/config/sol2/gmon.c
+	$(crt_compile) $(CRTSTUFF_T_CFLAGS_S) -c $<
+
+# Assemble startup files.
+crt1.o: $(srcdir)/config/$(cpu_type)/sol2-c1.S
+	$(crt_compile) -c $<
+gcrt1.o: $(srcdir)/config/$(cpu_type)/sol2-c1.S
+	$(crt_compile) -c -DGCRT1 $<
diff -Naur gcc-5.2.0.orig/libgcc/config/t-sol2 gcc-5.2.0/libgcc/config/t-sol2
--- gcc-5.2.0.orig/libgcc/config/t-sol2	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libgcc/config/t-sol2	1969-12-31 18:00:00.000000000 -0600
@@ -1,27 +0,0 @@
-# Copyright (C) 2004-2015 Free Software Foundation, Inc.
-#
-# This file is part of GCC.
-#
-# GCC is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
-#
-# GCC is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GCC; see the file COPYING3.  If not see
-# <http://www.gnu.org/licenses/>.
-
-# gmon build rule:
-gmon.o:	$(srcdir)/config/gmon-sol2.c
-	$(gcc_compile) -c $<
-
-# Assemble startup files.
-crt1.o: $(srcdir)/config/$(cpu_type)/sol2-c1.S
-	$(crt_compile) -c $<
-gcrt1.o: $(srcdir)/config/$(cpu_type)/sol2-c1.S
-	$(crt_compile) -c -DGCRT1 $<
diff -Naur gcc-5.2.0.orig/libgcc/config.host gcc-5.2.0/libgcc/config.host
--- gcc-5.2.0.orig/libgcc/config.host	2015-06-25 12:55:02.000000000 -0500
+++ gcc-5.2.0/libgcc/config.host	2015-10-01 07:01:18.897040000 -0500
@@ -265,7 +265,7 @@
 *-*-solaris2*)
   # Unless linker support and dl_iterate_phdr are present,
   # unwind-dw2-fde-dip.c automatically falls back to unwind-dw2-fde.c.
-  tmake_file="$tmake_file t-sol2 t-eh-dw2-dip t-libgcc-pic t-slibgcc t-slibgcc-elf-ver"
+  tmake_file="$tmake_file sol2/t-sol2 t-eh-dw2-dip t-crtstuff-pic t-libgcc-pic t-slibgcc t-slibgcc-elf-ver"
   if test $with_gnu_ld = yes; then
     tmake_file="$tmake_file t-slibgcc-gld"
   else
@@ -274,19 +274,24 @@
   # Add cpu-specific t-sol2 after t-slibgcc-* so it can augment SHLIB_MAPFILES.
   tmake_file="$tmake_file $cpu_type/t-sol2"
   extra_parts="gmon.o crtbegin.o crtend.o"
-  case ${host} in
-    i?86-*-solaris2.1[0-9]* | x86_64-*-solaris2.1[0-9]*)
-      # Solaris 10+/x86 provides crt1.o, crti.o, crtn.o, and gcrt1.o as
-      # part of the base system.
-      ;;
-    sparc*-*-solaris2.1[0-9]*)
-      # Solaris 10+/SPARC lacks crt1.o and gcrt1.o.
-      extra_parts="$extra_parts crt1.o gcrt1.o"
-      ;;
-    *)
-      extra_parts="$extra_parts crt1.o crti.o crtn.o gcrt1.o"
-      ;;
-  esac
+  if test "${libgcc_cv_solaris_crts}" = yes; then
+    # Solaris 11.x and 12 provide crt1.o, crti.o, and crtn.o as part of the
+    # base system.  crtp.o and crtpg.o implement the compiler-dependent parts.
+    extra_parts="$extra_parts crtp.o crtpg.o"
+    # If the Solaris CRTs are present, both ld and gld will have PIE support.
+    extra_parts="$extra_parts crtbeginS.o crtendS.o"
+  else
+    case ${host} in
+      i?86-*-solaris2.1[0-9]* | x86_64-*-solaris2.1[0-9]*)
+        # Solaris 10+/x86 provides crt1.o, crti.o, crtn.o, and gcrt1.o as
+        # part of the base system.
+        ;;
+      sparc*-*-solaris2.1[0-9]*)
+        # Solaris 10+/SPARC lacks crt1.o and gcrt1.o.
+        extra_parts="$extra_parts crt1.o gcrt1.o"
+        ;;
+    esac
+  fi
   ;;
 *-*-uclinux*)
   extra_parts="crtbegin.o crtend.o"
diff -Naur gcc-5.2.0.orig/libgcc/config.in gcc-5.2.0/libgcc/config.in
--- gcc-5.2.0.orig/libgcc/config.in	2015-02-27 07:19:38.000000000 -0600
+++ gcc-5.2.0/libgcc/config.in	2015-10-01 07:01:18.897040000 -0500
@@ -18,6 +18,12 @@
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
+/* Define if the system-provided CRTs are present on Solaris. */
+#undef HAVE_SOLARIS_CRTS
+
+/* Define if the system-provided CRTs are present on Solaris. */
+#undef HAVE_SOLARIS_CRTS
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
diff -Naur gcc-5.2.0.orig/libgcc/configure gcc-5.2.0/libgcc/configure
--- gcc-5.2.0.orig/libgcc/configure	2015-04-10 01:43:52.000000000 -0500
+++ gcc-5.2.0/libgcc/configure	2015-10-01 06:51:45.551063000 -0500
@@ -4704,6 +4704,38 @@
 $as_echo "$libgcc_cv_mips_hard_float" >&6; }
 esac
 
+case ${host} in
+*-*-solaris2*)
+  # Check for system-provided CRTs on Solaris 11.x and Solaris 12.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking system-provided CRTs on Solaris" >&5
+$as_echo_n "checking system-provided CRTs on Solaris... " >&6; }
+if test "${libgcc_cv_solaris_crts+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  libgcc_cv_solaris_crts=no
+     libgcc_sysroot="`${CC} -print-sysroot`"
+     libgcc_libdir="$libgcc_sysroot/usr/lib"
+     # At the time they were added, gcrt1.o became a symlink for backwards
+     # compatibility on x86, while crt1.o was added on sparc, so check for that.
+     case ${host} in
+       i?86-*-solaris2* | x86_64-*-solaris2*)
+         if test -h "$libgcc_libdir/gcrt1.o"; then libgcc_cv_solaris_crts=yes; fi
+	 ;;
+       sparc*-*-solaris2*)
+         if test -f "$libgcc_libdir/crt1.o"; then libgcc_cv_solaris_crts=yes; fi
+	 ;;
+     esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libgcc_cv_solaris_crts" >&5
+$as_echo "$libgcc_cv_solaris_crts" >&6; }
+  if test $libgcc_cv_solaris_crts = yes; then
+
+$as_echo "#define HAVE_SOLARIS_CRTS 1" >>confdefs.h
+
+  fi
+  ;;
+esac
+
 # Determine the version of glibc, if any, used on the target.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for target glibc version" >&5
 $as_echo_n "checking for target glibc version... " >&6; }
diff -Naur gcc-5.2.0.orig/libgcc/configure.ac gcc-5.2.0/libgcc/configure.ac
--- gcc-5.2.0.orig/libgcc/configure.ac	2015-03-03 11:44:01.000000000 -0600
+++ gcc-5.2.0/libgcc/configure.ac	2015-10-01 06:51:45.551063000 -0500
@@ -342,6 +342,31 @@
     [libgcc_cv_mips_hard_float=no])])
 esac
 
+case ${host} in
+*-*-solaris2*)
+  # Check for system-provided CRTs on Solaris 11.x and Solaris 12.
+  AC_CACHE_CHECK([system-provided CRTs on Solaris],
+    		 [libgcc_cv_solaris_crts],
+    [libgcc_cv_solaris_crts=no
+     libgcc_sysroot="`${CC} -print-sysroot`"
+     libgcc_libdir="$libgcc_sysroot/usr/lib"
+     # At the time they were added, gcrt1.o became a symlink for backwards
+     # compatibility on x86, while crt1.o was added on sparc, so check for that.
+     case ${host} in
+       i?86-*-solaris2* | x86_64-*-solaris2*)
+         if test -h "$libgcc_libdir/gcrt1.o"; then libgcc_cv_solaris_crts=yes; fi
+	 ;;
+       sparc*-*-solaris2*)
+         if test -f "$libgcc_libdir/crt1.o"; then libgcc_cv_solaris_crts=yes; fi
+	 ;;
+     esac])
+  if test $libgcc_cv_solaris_crts = yes; then
+    AC_DEFINE(HAVE_SOLARIS_CRTS, 1,
+      [Define if the system-provided CRTs are present on Solaris.])
+  fi
+  ;;
+esac
+
 # Determine the version of glibc, if any, used on the target.
 AC_MSG_CHECKING([for target glibc version])
 AC_ARG_WITH([glibc-version],
diff -Naur gcc-5.2.0.orig/libgfortran/configure gcc-5.2.0/libgfortran/configure
--- gcc-5.2.0.orig/libgfortran/configure	2015-07-16 04:16:25.000000000 -0500
+++ gcc-5.2.0/libgfortran/configure	2015-08-28 10:03:26.299701000 -0500
@@ -16525,6 +16525,15 @@
 $as_echo "#define HAVE_STRTOLD 1" >>confdefs.h
 
    fi
+
+  # ARM, AArch64 and SH also provide ftruncate.
+  case "${host}" in
+     arm* | aarch64* | sh*)
+
+$as_echo "#define HAVE_FTRUNCATE 1" >>confdefs.h
+
+       ;;
+  esac
 else
 
 
diff -Naur gcc-5.2.0.orig/libgfortran/configure.ac gcc-5.2.0/libgfortran/configure.ac
--- gcc-5.2.0.orig/libgfortran/configure.ac	2014-11-28 11:39:15.000000000 -0600
+++ gcc-5.2.0/libgfortran/configure.ac	2015-08-28 10:03:26.299701000 -0500
@@ -295,6 +295,13 @@
    if test x"long_double_math_on_this_cpu" = x"yes"; then
      AC_DEFINE(HAVE_STRTOLD, 1, [Define if you have strtold.])
    fi
+
+  # ARM, AArch64 and SH also provide ftruncate.
+  case "${host}" in
+     arm* | aarch64* | sh*)
+       AC_DEFINE(HAVE_FTRUNCATE, 1, [Define if you have ftruncate.])
+       ;;
+  esac
 else
    AC_CHECK_FUNCS_ONCE(getrusage times mkstemp strtof strtold snprintf \
    ftruncate chsize chdir getlogin gethostname kill link symlink sleep ttyname \
diff -Naur gcc-5.2.0.orig/libgfortran/io/unix.c gcc-5.2.0/libgfortran/io/unix.c
--- gcc-5.2.0.orig/libgfortran/io/unix.c	2015-07-15 02:00:23.000000000 -0500
+++ gcc-5.2.0/libgfortran/io/unix.c	2015-08-18 14:56:20.416817000 -0500
@@ -101,6 +101,12 @@
 }
 
 #endif /* HAVE_WORKING_STAT */
+
+
+/* On mingw, we don't use umask in tempfile_open(), because it
+   doesn't support the user/group/other-based permissions.  */
+#undef HAVE_UMASK
+
 #endif /* __MINGW32__ */
 
 
diff -Naur gcc-5.2.0.orig/libgfortran/libgfortran.h gcc-5.2.0/libgfortran/libgfortran.h
--- gcc-5.2.0.orig/libgfortran/libgfortran.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libgfortran/libgfortran.h	2015-07-29 12:12:28.716517000 -0500
@@ -404,8 +404,7 @@
 
 /* Macros to get both the size and the type with a single masking operation  */
 
-#define GFC_DTYPE_SIZE_MASK \
-  ((~((index_type) 0) >> GFC_DTYPE_SIZE_SHIFT) << GFC_DTYPE_SIZE_SHIFT)
+#define GFC_DTYPE_SIZE_MASK (-((index_type) 1 << GFC_DTYPE_SIZE_SHIFT))
 #define GFC_DTYPE_TYPE_SIZE_MASK (GFC_DTYPE_SIZE_MASK | GFC_DTYPE_TYPE_MASK)
 
 #define GFC_DTYPE_TYPE_SIZE(desc) ((desc)->dtype & GFC_DTYPE_TYPE_SIZE_MASK)
diff -Naur gcc-5.2.0.orig/libgfortran/runtime/error.c gcc-5.2.0/libgfortran/runtime/error.c
--- gcc-5.2.0.orig/libgfortran/runtime/error.c	2015-01-14 21:57:29.000000000 -0600
+++ gcc-5.2.0/libgfortran/runtime/error.c	2015-09-02 10:13:35.394965000 -0500
@@ -221,8 +221,16 @@
 #ifdef HAVE_STRERROR_L
   locale_t myloc = newlocale (LC_CTYPE_MASK | LC_MESSAGES_MASK, "",
 			      (locale_t) 0);
-  char *p = strerror_l (errnum, myloc);
-  freelocale (myloc);
+  char *p;
+  if (myloc)
+    {
+      p = strerror_l (errnum, myloc);
+      freelocale (myloc);
+    }
+  else
+    /* newlocale might fail e.g. due to running out of memory, fall
+       back to the simpler strerror.  */
+    p = strerror (errnum);
   return p;
 #elif defined(HAVE_STRERROR_R)
 #ifdef HAVE_USELOCALE
diff -Naur gcc-5.2.0.orig/libgo/aclocal.m4 gcc-5.2.0/libgo/aclocal.m4
--- gcc-5.2.0.orig/libgo/aclocal.m4	2010-11-12 14:52:54.000000000 -0600
+++ gcc-5.2.0/libgo/aclocal.m4	2015-09-17 07:46:06.987832000 -0500
@@ -1,7 +1,8 @@
-# generated automatically by aclocal 1.11.1 -*- Autoconf -*-
+# generated automatically by aclocal 1.11.6 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
+# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,
+# Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -19,12 +20,15 @@
 If you have problems, you may need to regenerate the build system entirely.
 To do so, use the procedure documented by the package, typically `autoreconf'.])])
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software
+# Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
 # Automake X.Y traces this macro to ensure aclocal.m4 has been
@@ -34,7 +38,7 @@
 [am__api_version='1.11'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.1], [],
+m4_if([$1], [1.11.6], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -50,19 +54,21 @@
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.1])dnl
+[AM_AUTOMAKE_VERSION([1.11.6])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
 # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
 # `$srcdir', `$srcdir/..', or `$srcdir/../..'.
@@ -144,14 +150,14 @@
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009
-# Free Software Foundation, Inc.
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,
+# 2010, 2011 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 10
+# serial 12
 
 # There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
@@ -191,6 +197,7 @@
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
+  rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
@@ -255,7 +262,7 @@
 	break
       fi
       ;;
-    msvisualcpp | msvcmsys)
+    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
       # This compiler won't grok `-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
@@ -320,10 +327,13 @@
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
+  am__nodep='_no'
 fi
 AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
 AC_SUBST([AMDEPBACKSLASH])dnl
 _AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
+AC_SUBST([am__nodep])dnl
+_AM_SUBST_NOTMAKE([am__nodep])dnl
 ])
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
@@ -545,12 +555,15 @@
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,
+# Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # AM_PROG_INSTALL_SH
 # ------------------
 # Define $install_sh.
@@ -569,8 +582,8 @@
 # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,
+# 2011 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -590,7 +603,7 @@
        [disable], [m4_define([am_maintainer_other], [enable])],
        [m4_define([am_maintainer_other], [enable])
         m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
-AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])
+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
   dnl maintainer-mode's default is 'disable' unless 'enable' is passed
   AC_ARG_ENABLE([maintainer-mode],
 [  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
@@ -701,12 +714,15 @@
 fi
 ])
 
-# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,
+# Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # AM_PROG_MKDIR_P
 # ---------------
 # Check for `mkdir -p'.
@@ -729,13 +745,14 @@
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software
+# Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 4
+# serial 5
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -743,13 +760,13 @@
 [[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
 
 # _AM_SET_OPTION(NAME)
-# ------------------------------
+# --------------------
 # Set option NAME.  Presently that only means defining a flag for this option.
 AC_DEFUN([_AM_SET_OPTION],
 [m4_define(_AM_MANGLE_OPTION([$1]), 1)])
 
 # _AM_SET_OPTIONS(OPTIONS)
-# ----------------------------------
+# ------------------------
 # OPTIONS is a space-separated list of Automake options.
 AC_DEFUN([_AM_SET_OPTIONS],
 [m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
@@ -825,12 +842,14 @@
 fi
 AC_MSG_RESULT(yes)])
 
-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # AM_PROG_INSTALL_STRIP
 # ---------------------
 # One issue with vendor `install' (even GNU) is that you can't
@@ -853,13 +872,13 @@
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # _AM_SUBST_NOTMAKE(VARIABLE)
 # ---------------------------
@@ -868,13 +887,13 @@
 AC_DEFUN([_AM_SUBST_NOTMAKE])
 
 # AM_SUBST_NOTMAKE(VARIABLE)
-# ---------------------------
+# --------------------------
 # Public sister of _AM_SUBST_NOTMAKE.
 AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -896,10 +915,11 @@
 # a tarball read from stdin.
 #     $(am__untar) < result.tar
 AC_DEFUN([_AM_PROG_TAR],
-[# Always define AMTAR for backward compatibility.
-AM_MISSING_PROG([AMTAR], [tar])
+[# Always define AMTAR for backward compatibility.  Yes, it's still used
+# in the wild :-(  We should find a proper way to deprecate it ...
+AC_SUBST([AMTAR], ['$${TAR-tar}'])
 m4_if([$1], [v7],
-     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
      [m4_case([$1], [ustar],, [pax],,
               [m4_fatal([Unknown tar format])])
 AC_MSG_CHECKING([how to create a $1 tar archive])
diff -Naur gcc-5.2.0.orig/libgo/configure gcc-5.2.0/libgo/configure
--- gcc-5.2.0.orig/libgo/configure	2015-01-14 18:52:38.000000000 -0600
+++ gcc-5.2.0/libgo/configure	2015-09-17 07:46:06.987832000 -0500
@@ -602,6 +602,8 @@
 am__EXEEXT_TRUE
 LTLIBOBJS
 LIBOBJS
+HAVE_STAT_TIMESPEC_FALSE
+HAVE_STAT_TIMESPEC_TRUE
 STRUCT_EPOLL_EVENT_FD_OFFSET
 SIZEOF_STRUCT_EPOLL_EVENT
 MATH_FLAG
@@ -723,6 +725,7 @@
 am__fastdepCC_FALSE
 am__fastdepCC_TRUE
 CCDEPMODE
+am__nodep
 AMDEPBACKSLASH
 AMDEP_FALSE
 AMDEP_TRUE
@@ -3147,11 +3150,11 @@
 
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
-# Always define AMTAR for backward compatibility.
+# Always define AMTAR for backward compatibility.  Yes, it's still used
+# in the wild :-(  We should find a proper way to deprecate it ...
+AMTAR='$${TAR-tar}'
 
-AMTAR=${AMTAR-"${am_missing_run}tar"}
-
-am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
 
 
 
@@ -3978,6 +3981,7 @@
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
+  am__nodep='_no'
 fi
  if test "x$enable_dependency_tracking" != xno; then
   AMDEP_TRUE=
@@ -4002,6 +4006,7 @@
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
+  rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
@@ -4061,7 +4066,7 @@
 	break
       fi
       ;;
-    msvisualcpp | msvcmsys)
+    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
       # This compiler won't grok `-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
@@ -11121,7 +11126,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11124 "configure"
+#line 11129 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11227,7 +11232,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11230 "configure"
+#line 11235 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15141,6 +15146,28 @@
 STRUCT_EPOLL_EVENT_FD_OFFSET=${libgo_cv_c_epoll_event_fd_offset}
 
 
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/stat.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "timespec_t.*st_atim" >/dev/null 2>&1; then :
+  have_stat_timespec=yes
+else
+  have_stat_timespec=no
+fi
+rm -f conftest*
+
+ if test $have_stat_timespec = yes; then
+  HAVE_STAT_TIMESPEC_TRUE=
+  HAVE_STAT_TIMESPEC_FALSE='#'
+else
+  HAVE_STAT_TIMESPEC_TRUE='#'
+  HAVE_STAT_TIMESPEC_FALSE=
+fi
+
+
 ac_fn_c_check_type "$LINENO" "struct exception" "ac_cv_type_struct_exception" "#include <math.h>
 "
 if test "x$ac_cv_type_struct_exception" = x""yes; then :
@@ -15761,6 +15788,10 @@
   as_fn_error "conditional \"HAVE_WAIT4\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${HAVE_STAT_TIMESPEC_TRUE}" && test -z "${HAVE_STAT_TIMESPEC_FALSE}"; then
+  as_fn_error "conditional \"HAVE_STAT_TIMESPEC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
diff -Naur gcc-5.2.0.orig/libgo/configure.ac gcc-5.2.0/libgo/configure.ac
--- gcc-5.2.0.orig/libgo/configure.ac	2015-01-14 18:52:38.000000000 -0600
+++ gcc-5.2.0/libgo/configure.ac	2015-09-17 07:46:06.987832000 -0500
@@ -695,6 +695,12 @@
 STRUCT_EPOLL_EVENT_FD_OFFSET=${libgo_cv_c_epoll_event_fd_offset}
 AC_SUBST(STRUCT_EPOLL_EVENT_FD_OFFSET)
 
+dnl Check if <sys/stat.h> uses timespec_t for st_?tim members.  Introduced
+dnl in Solaris 12 for XPG7 compatibility.
+AC_EGREP_HEADER([timespec_t.*st_atim], [sys/stat.h],
+		[have_stat_timespec=yes], [have_stat_timespec=no])
+AM_CONDITIONAL(HAVE_STAT_TIMESPEC, test $have_stat_timespec = yes)
+
 dnl See if struct exception is defined in <math.h>.
 AC_CHECK_TYPE([struct exception],
 [libgo_has_struct_exception=yes],
diff -Naur gcc-5.2.0.orig/libgo/go/syscall/socket_linux.go gcc-5.2.0/libgo/go/syscall/socket_linux.go
--- gcc-5.2.0.orig/libgo/go/syscall/socket_linux.go	2013-07-24 11:53:17.000000000 -0500
+++ gcc-5.2.0/libgo/go/syscall/socket_linux.go	2015-08-04 17:04:04.652309000 -0500
@@ -136,11 +136,6 @@
 	Groups uint32
 }
 
-type RawSockaddr struct {
-	Family uint16
-	Data   [14]int8
-}
-
 // BindToDevice binds the socket associated with fd to device.
 func BindToDevice(fd int, device string) (err error) {
 	return SetsockoptString(fd, SOL_SOCKET, SO_BINDTODEVICE, device)
diff -Naur gcc-5.2.0.orig/libgo/go/syscall/socket_linux_ppc64x_type.go gcc-5.2.0/libgo/go/syscall/socket_linux_ppc64x_type.go
--- gcc-5.2.0.orig/libgo/go/syscall/socket_linux_ppc64x_type.go	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libgo/go/syscall/socket_linux_ppc64x_type.go	2015-08-04 17:04:04.652309000 -0500
@@ -0,0 +1,14 @@
+// socket_linux_ppc64x_type.go -- Socket handling specific to ppc64 GNU/Linux.
+
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
+
+// Type needed on ppc64le & ppc64
+
+type RawSockaddr struct {
+	Family uint16
+	Data   [14]uint8
+}
diff -Naur gcc-5.2.0.orig/libgo/go/syscall/socket_linux_type.go gcc-5.2.0/libgo/go/syscall/socket_linux_type.go
--- gcc-5.2.0.orig/libgo/go/syscall/socket_linux_type.go	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libgo/go/syscall/socket_linux_type.go	2015-08-04 17:04:04.652309000 -0500
@@ -0,0 +1,14 @@
+// socket_linux_type.go -- Socket handling specific to GNU/Linux.
+
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package syscall
+
+// Type needed if not on ppc64le or ppc64
+
+type RawSockaddr struct {
+	Family uint16
+	Data   [14]int8
+}
diff -Naur gcc-5.2.0.orig/libgo/Makefile.am gcc-5.2.0/libgo/Makefile.am
--- gcc-5.2.0.orig/libgo/Makefile.am	2015-04-29 16:32:07.000000000 -0500
+++ gcc-5.2.0/libgo/Makefile.am	2015-09-17 07:46:06.987832000 -0500
@@ -880,7 +880,11 @@
 endif
 
 if LIBGO_IS_SOLARIS
+if HAVE_STAT_TIMESPEC
+go_os_stat_file = go/os/stat_atim.go
+else
 go_os_stat_file = go/os/stat_solaris.go
+endif
 else
 if LIBGO_IS_LINUX
 go_os_stat_file = go/os/stat_atim.go
@@ -1676,7 +1680,17 @@
 # Define socket sizes and types.
 if LIBGO_IS_LINUX
 syscall_socket_file = go/syscall/socket_linux.go epoll.go
+if LIBGO_IS_PPC64LE
+syscall_socket_type_file = go/syscall/socket_linux_ppc64x_type.go
+else
+if LIBGO_IS_PPC64
+syscall_socket_type_file = go/syscall/socket_linux_ppc64x_type.go
+else
+syscall_socket_type_file = go/syscall/socket_linux_type.go
+endif
+endif
 else
+syscall_socket_type_file =
 if LIBGO_IS_SOLARIS
 syscall_socket_file = go/syscall/socket_solaris.go
 else
@@ -1762,6 +1776,7 @@
 	$(syscall_size_file) \
 	$(syscall_socket_file) \
 	$(syscall_socket_os_file) \
+	$(syscall_socket_type_file) \
 	$(syscall_uname_file) \
 	$(syscall_netlink_file) \
 	$(syscall_lsf_file) \
diff -Naur gcc-5.2.0.orig/libgo/Makefile.in gcc-5.2.0/libgo/Makefile.in
--- gcc-5.2.0.orig/libgo/Makefile.in	2015-04-29 16:32:07.000000000 -0500
+++ gcc-5.2.0/libgo/Makefile.in	2015-09-17 07:46:06.987832000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -26,6 +26,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -91,6 +108,12 @@
 am__base_list = \
   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
   sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
 am__installdirs = "$(DESTDIR)$(toolexeclibdir)" \
 	"$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(toolexeclibgodir)" \
 	"$(DESTDIR)$(toolexeclibgoarchivedir)" \
@@ -283,6 +306,11 @@
 	install-pdf-recursive install-ps-recursive install-recursive \
 	installcheck-recursive installdirs-recursive pdf-recursive \
 	ps-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 DATA = $(noinst_DATA) $(toolexeclibgo_DATA) \
 	$(toolexeclibgoarchive_DATA) $(toolexeclibgocompress_DATA) \
 	$(toolexeclibgocontainer_DATA) $(toolexeclibgocrypto_DATA) \
@@ -1107,6 +1135,8 @@
 @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@go_os_cloexec_file = go/os/sys_unix.go
 @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_FREEBSD_FALSE@go_os_cloexec_file = go/os/sys_darwin.go
 @LIBGO_IS_FREEBSD_TRUE@go_os_cloexec_file = go/os/sys_freebsd.go
+@HAVE_STAT_TIMESPEC_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_os_stat_file = go/os/stat_solaris.go
+@HAVE_STAT_TIMESPEC_TRUE@@LIBGO_IS_SOLARIS_TRUE@go_os_stat_file = go/os/stat_atim.go
 @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat.go
 @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_DRAGONFLY_TRUE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_dragonfly.go
 @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atimespec.go
@@ -1114,7 +1144,6 @@
 @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atimespec.go
 @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_OPENBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atim.go
 @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_SOLARIS_FALSE@go_os_stat_file = go/os/stat_atim.go
-@LIBGO_IS_SOLARIS_TRUE@go_os_stat_file = go/os/stat_solaris.go
 @LIBGO_IS_LINUX_FALSE@go_os_pipe_file = go/os/pipe_bsd.go
 @LIBGO_IS_LINUX_TRUE@go_os_pipe_file = go/os/pipe_linux.go
 go_os_files = \
@@ -1848,6 +1877,10 @@
 
 # Define socket sizes and types.
 @LIBGO_IS_LINUX_TRUE@syscall_socket_file = go/syscall/socket_linux.go epoll.go
+@LIBGO_IS_LINUX_FALSE@syscall_socket_type_file = 
+@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_PPC64LE_FALSE@@LIBGO_IS_PPC64_FALSE@syscall_socket_type_file = go/syscall/socket_linux_type.go
+@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_PPC64LE_FALSE@@LIBGO_IS_PPC64_TRUE@syscall_socket_type_file = go/syscall/socket_linux_ppc64x_type.go
+@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_PPC64LE_TRUE@syscall_socket_type_file = go/syscall/socket_linux_ppc64x_type.go
 @LIBGO_IS_SOLARIS_FALSE@syscall_socket_os_file = go/syscall/socket_posix.go
 
 # Define socket functions.
@@ -1898,6 +1931,7 @@
 	$(syscall_size_file) \
 	$(syscall_socket_file) \
 	$(syscall_socket_os_file) \
+	$(syscall_socket_type_file) \
 	$(syscall_uname_file) \
 	$(syscall_netlink_file) \
 	$(syscall_lsf_file) \
@@ -2338,7 +2372,7 @@
 
 .SUFFIXES:
 .SUFFIXES: .c .go .gox .o .obj .lo .a
-am--refresh:
+am--refresh: Makefile
 	@:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
@@ -2374,10 +2408,8 @@
 $(am__aclocal_m4_deps):
 
 config.h: stamp-h1
-	@if test ! -f $@; then \
-	  rm -f stamp-h1; \
-	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
-	else :; fi
+	@if test ! -f $@; then rm -f stamp-h1; else :; fi
+	@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi
 
 stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
 	@rm -f stamp-h1
@@ -2391,7 +2423,6 @@
 	-rm -f config.h stamp-h1
 install-toolexeclibLIBRARIES: $(toolexeclib_LIBRARIES)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)"
 	@list='$(toolexeclib_LIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
 	list2=; for p in $$list; do \
 	  if test -f $$p; then \
@@ -2399,6 +2430,8 @@
 	  else :; fi; \
 	done; \
 	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)" || exit 1; \
 	  echo " $(INSTALL_DATA) $$list2 '$(DESTDIR)$(toolexeclibdir)'"; \
 	  $(INSTALL_DATA) $$list2 "$(DESTDIR)$(toolexeclibdir)" || exit $$?; }
 	@$(POST_INSTALL)
@@ -2415,31 +2448,28 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclib_LIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibdir)' && rm -f "$$files" )"; \
-	cd "$(DESTDIR)$(toolexeclibdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibdir)'; $(am__uninstall_files_from_dir)
 
 clean-toolexeclibLIBRARIES:
 	-test -z "$(toolexeclib_LIBRARIES)" || rm -f $(toolexeclib_LIBRARIES)
-libgobegin-llgo.a: $(libgobegin_llgo_a_OBJECTS) $(libgobegin_llgo_a_DEPENDENCIES) 
+libgobegin-llgo.a: $(libgobegin_llgo_a_OBJECTS) $(libgobegin_llgo_a_DEPENDENCIES) $(EXTRA_libgobegin_llgo_a_DEPENDENCIES) 
 	-rm -f libgobegin-llgo.a
 	$(libgobegin_llgo_a_AR) libgobegin-llgo.a $(libgobegin_llgo_a_OBJECTS) $(libgobegin_llgo_a_LIBADD)
 	$(RANLIB) libgobegin-llgo.a
-libgobegin.a: $(libgobegin_a_OBJECTS) $(libgobegin_a_DEPENDENCIES) 
+libgobegin.a: $(libgobegin_a_OBJECTS) $(libgobegin_a_DEPENDENCIES) $(EXTRA_libgobegin_a_DEPENDENCIES) 
 	-rm -f libgobegin.a
 	$(libgobegin_a_AR) libgobegin.a $(libgobegin_a_OBJECTS) $(libgobegin_a_LIBADD)
 	$(RANLIB) libgobegin.a
-libgolibbegin.a: $(libgolibbegin_a_OBJECTS) $(libgolibbegin_a_DEPENDENCIES) 
+libgolibbegin.a: $(libgolibbegin_a_OBJECTS) $(libgolibbegin_a_DEPENDENCIES) $(EXTRA_libgolibbegin_a_DEPENDENCIES) 
 	-rm -f libgolibbegin.a
 	$(libgolibbegin_a_AR) libgolibbegin.a $(libgolibbegin_a_OBJECTS) $(libgolibbegin_a_LIBADD)
 	$(RANLIB) libgolibbegin.a
-libnetgo.a: $(libnetgo_a_OBJECTS) $(libnetgo_a_DEPENDENCIES) 
+libnetgo.a: $(libnetgo_a_OBJECTS) $(libnetgo_a_DEPENDENCIES) $(EXTRA_libnetgo_a_DEPENDENCIES) 
 	-rm -f libnetgo.a
 	$(libnetgo_a_AR) libnetgo.a $(libnetgo_a_OBJECTS) $(libnetgo_a_LIBADD)
 	$(RANLIB) libnetgo.a
 install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)"
 	@list='$(toolexeclib_LTLIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
 	list2=; for p in $$list; do \
 	  if test -f $$p; then \
@@ -2447,6 +2477,8 @@
 	  else :; fi; \
 	done; \
 	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)" || exit 1; \
 	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'"; \
 	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(toolexeclibdir)"; \
 	}
@@ -2468,9 +2500,9 @@
 	  echo "rm -f \"$${dir}/so_locations\""; \
 	  rm -f "$${dir}/so_locations"; \
 	done
-libgo-llgo.la: $(libgo_llgo_la_OBJECTS) $(libgo_llgo_la_DEPENDENCIES) 
+libgo-llgo.la: $(libgo_llgo_la_OBJECTS) $(libgo_llgo_la_DEPENDENCIES) $(EXTRA_libgo_llgo_la_DEPENDENCIES) 
 	$(libgo_llgo_la_LINK) $(am_libgo_llgo_la_rpath) $(libgo_llgo_la_OBJECTS) $(libgo_llgo_la_LIBADD) $(LIBS)
-libgo.la: $(libgo_la_OBJECTS) $(libgo_la_DEPENDENCIES) 
+libgo.la: $(libgo_la_OBJECTS) $(libgo_la_DEPENDENCIES) $(EXTRA_libgo_la_DEPENDENCIES) 
 	$(libgo_la_LINK) $(am_libgo_la_rpath) $(libgo_la_OBJECTS) $(libgo_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
@@ -3364,8 +3396,11 @@
 	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)
 install-toolexeclibgoDATA: $(toolexeclibgo_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgodir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgodir)"
 	@list='$(toolexeclibgo_DATA)'; test -n "$(toolexeclibgodir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgodir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgodir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3379,13 +3414,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgo_DATA)'; test -n "$(toolexeclibgodir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgodir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgodir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgodir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoarchiveDATA: $(toolexeclibgoarchive_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoarchivedir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoarchivedir)"
 	@list='$(toolexeclibgoarchive_DATA)'; test -n "$(toolexeclibgoarchivedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoarchivedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoarchivedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3399,13 +3435,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoarchive_DATA)'; test -n "$(toolexeclibgoarchivedir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoarchivedir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoarchivedir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoarchivedir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgocompressDATA: $(toolexeclibgocompress_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgocompressdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgocompressdir)"
 	@list='$(toolexeclibgocompress_DATA)'; test -n "$(toolexeclibgocompressdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgocompressdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgocompressdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3419,13 +3456,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgocompress_DATA)'; test -n "$(toolexeclibgocompressdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgocompressdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgocompressdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgocompressdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgocontainerDATA: $(toolexeclibgocontainer_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgocontainerdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgocontainerdir)"
 	@list='$(toolexeclibgocontainer_DATA)'; test -n "$(toolexeclibgocontainerdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgocontainerdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgocontainerdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3439,13 +3477,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgocontainer_DATA)'; test -n "$(toolexeclibgocontainerdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgocontainerdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgocontainerdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgocontainerdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgocryptoDATA: $(toolexeclibgocrypto_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgocryptodir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgocryptodir)"
 	@list='$(toolexeclibgocrypto_DATA)'; test -n "$(toolexeclibgocryptodir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgocryptodir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgocryptodir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3459,13 +3498,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgocrypto_DATA)'; test -n "$(toolexeclibgocryptodir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgocryptodir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgocryptodir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgocryptodir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgocryptox509DATA: $(toolexeclibgocryptox509_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgocryptox509dir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgocryptox509dir)"
 	@list='$(toolexeclibgocryptox509_DATA)'; test -n "$(toolexeclibgocryptox509dir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgocryptox509dir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgocryptox509dir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3479,13 +3519,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgocryptox509_DATA)'; test -n "$(toolexeclibgocryptox509dir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgocryptox509dir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgocryptox509dir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgocryptox509dir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgodatabaseDATA: $(toolexeclibgodatabase_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgodatabasedir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgodatabasedir)"
 	@list='$(toolexeclibgodatabase_DATA)'; test -n "$(toolexeclibgodatabasedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgodatabasedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgodatabasedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3499,13 +3540,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgodatabase_DATA)'; test -n "$(toolexeclibgodatabasedir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgodatabasedir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgodatabasedir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgodatabasedir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgodatabasesqlDATA: $(toolexeclibgodatabasesql_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgodatabasesqldir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgodatabasesqldir)"
 	@list='$(toolexeclibgodatabasesql_DATA)'; test -n "$(toolexeclibgodatabasesqldir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgodatabasesqldir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgodatabasesqldir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3519,13 +3561,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgodatabasesql_DATA)'; test -n "$(toolexeclibgodatabasesqldir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgodatabasesqldir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgodatabasesqldir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgodatabasesqldir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgodebugDATA: $(toolexeclibgodebug_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgodebugdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgodebugdir)"
 	@list='$(toolexeclibgodebug_DATA)'; test -n "$(toolexeclibgodebugdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgodebugdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgodebugdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3539,13 +3582,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgodebug_DATA)'; test -n "$(toolexeclibgodebugdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgodebugdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgodebugdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgodebugdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoencodingDATA: $(toolexeclibgoencoding_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoencodingdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoencodingdir)"
 	@list='$(toolexeclibgoencoding_DATA)'; test -n "$(toolexeclibgoencodingdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoencodingdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoencodingdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3559,13 +3603,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoencoding_DATA)'; test -n "$(toolexeclibgoencodingdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoencodingdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoencodingdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoencodingdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoexpDATA: $(toolexeclibgoexp_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoexpdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoexpdir)"
 	@list='$(toolexeclibgoexp_DATA)'; test -n "$(toolexeclibgoexpdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoexpdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoexpdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3579,13 +3624,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoexp_DATA)'; test -n "$(toolexeclibgoexpdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoexpdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoexpdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoexpdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgogoDATA: $(toolexeclibgogo_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgogodir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgogodir)"
 	@list='$(toolexeclibgogo_DATA)'; test -n "$(toolexeclibgogodir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgogodir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgogodir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3599,13 +3645,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgogo_DATA)'; test -n "$(toolexeclibgogodir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgogodir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgogodir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgogodir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgohashDATA: $(toolexeclibgohash_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgohashdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgohashdir)"
 	@list='$(toolexeclibgohash_DATA)'; test -n "$(toolexeclibgohashdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgohashdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgohashdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3619,13 +3666,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgohash_DATA)'; test -n "$(toolexeclibgohashdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgohashdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgohashdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgohashdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgohtmlDATA: $(toolexeclibgohtml_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgohtmldir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgohtmldir)"
 	@list='$(toolexeclibgohtml_DATA)'; test -n "$(toolexeclibgohtmldir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgohtmldir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgohtmldir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3639,13 +3687,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgohtml_DATA)'; test -n "$(toolexeclibgohtmldir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgohtmldir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgohtmldir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgohtmldir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoimageDATA: $(toolexeclibgoimage_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoimagedir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoimagedir)"
 	@list='$(toolexeclibgoimage_DATA)'; test -n "$(toolexeclibgoimagedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoimagedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoimagedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3659,13 +3708,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoimage_DATA)'; test -n "$(toolexeclibgoimagedir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoimagedir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoimagedir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoimagedir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoimagecolorDATA: $(toolexeclibgoimagecolor_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoimagecolordir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoimagecolordir)"
 	@list='$(toolexeclibgoimagecolor_DATA)'; test -n "$(toolexeclibgoimagecolordir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoimagecolordir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoimagecolordir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3679,13 +3729,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoimagecolor_DATA)'; test -n "$(toolexeclibgoimagecolordir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoimagecolordir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoimagecolordir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoimagecolordir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoindexDATA: $(toolexeclibgoindex_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoindexdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoindexdir)"
 	@list='$(toolexeclibgoindex_DATA)'; test -n "$(toolexeclibgoindexdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoindexdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoindexdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3699,13 +3750,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoindex_DATA)'; test -n "$(toolexeclibgoindexdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoindexdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoindexdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoindexdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoioDATA: $(toolexeclibgoio_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoiodir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoiodir)"
 	@list='$(toolexeclibgoio_DATA)'; test -n "$(toolexeclibgoiodir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoiodir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoiodir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3719,13 +3771,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoio_DATA)'; test -n "$(toolexeclibgoiodir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoiodir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoiodir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoiodir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgologDATA: $(toolexeclibgolog_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgologdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgologdir)"
 	@list='$(toolexeclibgolog_DATA)'; test -n "$(toolexeclibgologdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgologdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgologdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3739,13 +3792,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgolog_DATA)'; test -n "$(toolexeclibgologdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgologdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgologdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgologdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgomathDATA: $(toolexeclibgomath_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgomathdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgomathdir)"
 	@list='$(toolexeclibgomath_DATA)'; test -n "$(toolexeclibgomathdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgomathdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgomathdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3759,13 +3813,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgomath_DATA)'; test -n "$(toolexeclibgomathdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgomathdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgomathdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgomathdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgomimeDATA: $(toolexeclibgomime_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgomimedir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgomimedir)"
 	@list='$(toolexeclibgomime_DATA)'; test -n "$(toolexeclibgomimedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgomimedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgomimedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3779,13 +3834,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgomime_DATA)'; test -n "$(toolexeclibgomimedir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgomimedir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgomimedir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgomimedir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgonetDATA: $(toolexeclibgonet_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgonetdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgonetdir)"
 	@list='$(toolexeclibgonet_DATA)'; test -n "$(toolexeclibgonetdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgonetdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgonetdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3799,13 +3855,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgonet_DATA)'; test -n "$(toolexeclibgonetdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgonetdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgonetdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgonetdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgonethttpDATA: $(toolexeclibgonethttp_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgonethttpdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgonethttpdir)"
 	@list='$(toolexeclibgonethttp_DATA)'; test -n "$(toolexeclibgonethttpdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgonethttpdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgonethttpdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3819,13 +3876,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgonethttp_DATA)'; test -n "$(toolexeclibgonethttpdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgonethttpdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgonethttpdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgonethttpdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgonetrpcDATA: $(toolexeclibgonetrpc_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgonetrpcdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgonetrpcdir)"
 	@list='$(toolexeclibgonetrpc_DATA)'; test -n "$(toolexeclibgonetrpcdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgonetrpcdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgonetrpcdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3839,13 +3897,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgonetrpc_DATA)'; test -n "$(toolexeclibgonetrpcdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgonetrpcdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgonetrpcdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgonetrpcdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgooldDATA: $(toolexeclibgoold_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoolddir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoolddir)"
 	@list='$(toolexeclibgoold_DATA)'; test -n "$(toolexeclibgoolddir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoolddir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoolddir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3859,13 +3918,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoold_DATA)'; test -n "$(toolexeclibgoolddir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoolddir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoolddir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoolddir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoosDATA: $(toolexeclibgoos_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoosdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoosdir)"
 	@list='$(toolexeclibgoos_DATA)'; test -n "$(toolexeclibgoosdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoosdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoosdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3879,13 +3939,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoos_DATA)'; test -n "$(toolexeclibgoosdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoosdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoosdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoosdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgopathDATA: $(toolexeclibgopath_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgopathdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgopathdir)"
 	@list='$(toolexeclibgopath_DATA)'; test -n "$(toolexeclibgopathdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgopathdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgopathdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3899,13 +3960,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgopath_DATA)'; test -n "$(toolexeclibgopathdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgopathdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgopathdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgopathdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoregexpDATA: $(toolexeclibgoregexp_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoregexpdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoregexpdir)"
 	@list='$(toolexeclibgoregexp_DATA)'; test -n "$(toolexeclibgoregexpdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoregexpdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoregexpdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3919,13 +3981,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoregexp_DATA)'; test -n "$(toolexeclibgoregexpdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoregexpdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoregexpdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoregexpdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgoruntimeDATA: $(toolexeclibgoruntime_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgoruntimedir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoruntimedir)"
 	@list='$(toolexeclibgoruntime_DATA)'; test -n "$(toolexeclibgoruntimedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgoruntimedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgoruntimedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3939,13 +4002,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgoruntime_DATA)'; test -n "$(toolexeclibgoruntimedir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgoruntimedir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgoruntimedir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgoruntimedir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgosyncDATA: $(toolexeclibgosync_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgosyncdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgosyncdir)"
 	@list='$(toolexeclibgosync_DATA)'; test -n "$(toolexeclibgosyncdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgosyncdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgosyncdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3959,13 +4023,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgosync_DATA)'; test -n "$(toolexeclibgosyncdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgosyncdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgosyncdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgosyncdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgotestingDATA: $(toolexeclibgotesting_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgotestingdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgotestingdir)"
 	@list='$(toolexeclibgotesting_DATA)'; test -n "$(toolexeclibgotestingdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgotestingdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgotestingdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3979,13 +4044,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgotesting_DATA)'; test -n "$(toolexeclibgotestingdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgotestingdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgotestingdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgotestingdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgotextDATA: $(toolexeclibgotext_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgotextdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgotextdir)"
 	@list='$(toolexeclibgotext_DATA)'; test -n "$(toolexeclibgotextdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgotextdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgotextdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -3999,13 +4065,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgotext_DATA)'; test -n "$(toolexeclibgotextdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgotextdir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgotextdir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgotextdir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgotexttemplateDATA: $(toolexeclibgotexttemplate_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgotexttemplatedir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgotexttemplatedir)"
 	@list='$(toolexeclibgotexttemplate_DATA)'; test -n "$(toolexeclibgotexttemplatedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgotexttemplatedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgotexttemplatedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -4019,13 +4086,14 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgotexttemplate_DATA)'; test -n "$(toolexeclibgotexttemplatedir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgotexttemplatedir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgotexttemplatedir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgotexttemplatedir)'; $(am__uninstall_files_from_dir)
 install-toolexeclibgounicodeDATA: $(toolexeclibgounicode_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibgounicodedir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibgounicodedir)"
 	@list='$(toolexeclibgounicode_DATA)'; test -n "$(toolexeclibgounicodedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibgounicodedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibgounicodedir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -4039,9 +4107,7 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclibgounicode_DATA)'; test -n "$(toolexeclibgounicodedir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibgounicodedir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(toolexeclibgounicodedir)" && rm -f $$files
+	dir='$(DESTDIR)$(toolexeclibgounicodedir)'; $(am__uninstall_files_from_dir)
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -4196,10 +4262,15 @@
 
 installcheck: installcheck-recursive
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libgo/mksysinfo.sh gcc-5.2.0/libgo/mksysinfo.sh
--- gcc-5.2.0.orig/libgo/mksysinfo.sh	2015-04-08 09:17:13.000000000 -0500
+++ gcc-5.2.0/libgo/mksysinfo.sh	2015-08-04 17:04:04.652309000 -0500
@@ -201,6 +201,67 @@
 #ifdef TCSETS
   TCSETS_val = TCSETS,
 #endif
+#ifdef TUNSETIFF
+  TUNSETIFF_val = TUNSETIFF,
+#endif
+#ifdef TUNSETNOCSUM
+  TUNSETNOCSUM_val = TUNSETNOCSUM,
+#endif
+#ifdef TUNSETDEBUG
+  TUNSETDEBUG_val = TUNSETDEBUG,
+#endif
+#ifdef TUNSETPERSIST
+  TUNSETPERSIST_val = TUNSETPERSIST,
+#endif
+#ifdef TUNSETOWNER
+  TUNSETOWNER_val = TUNSETOWNER,
+#endif
+#ifdef TUNSETLINK
+  TUNSETLINK_val = TUNSETLINK,
+#endif
+#ifdef TUNSETGROUP
+  TUNSETGROUP_val = TUNSETGROUP,
+#endif
+#ifdef TUNGETFEATURES
+  TUNGETFEATURES_val = TUNGETFEATURES,
+#endif
+#ifdef TUNSETOFFLOAD
+  TUNSETOFFLOAD_val = TUNSETOFFLOAD,
+#endif
+#ifdef TUNSETTXFILTER
+  TUNSETTXFILTER_val = TUNSETTXFILTER,
+#endif
+#ifdef TUNGETIFF
+  TUNGETIFF_val = TUNGETIFF,
+#endif
+#ifdef TUNGETSNDBUF
+  TUNGETSNDBUF_val = TUNGETSNDBUF,
+#endif
+#ifdef TUNSETSNDBUF
+  TUNSETSNDBUF_val = TUNSETSNDBUF,
+#endif
+#ifdef TUNATTACHFILTER
+  TUNATTACHFILTER_val = TUNATTACHFILTER,
+#endif
+#ifdef TUNDETACHFILTER
+  TUNDETACHFILTER_val = TUNDETACHFILTER,
+#endif
+#ifdef TUNGETVNETHDRSZ
+  TUNGETVNETHDRSZ_val = TUNGETVNETHDRSZ,
+#endif
+#ifdef TUNSETVNETHDRSZ
+  TUNSETVNETHDRSZ_val = TUNSETVNETHDRSZ,
+#endif
+#ifdef TUNSETQUEUE
+  TUNSETQUEUE_val = TUNSETQUEUE,
+#endif
+#ifdef TUNSETIFINDEX
+  TUNSETIFINDEX_val = TUNSETIFINDEX,
+#endif
+#ifdef TUNGETFILTER
+  TUNGETFILTER_val = TUNGETFILTER,
+#endif
+
 };
 EOF
 
@@ -830,6 +891,9 @@
 grep '^const _TIOC' gen-sysinfo.go | \
     grep -v '_val =' | \
     sed -e 's/^\(const \)_\(TIOC[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
+grep '^const _TUNSET' gen-sysinfo.go | \
+    grep -v '_val =' | \
+    sed -e 's/^\(const \)_\(TUNSET[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
 # We need TIOCGWINSZ.
 if ! grep '^const TIOCGWINSZ' ${OUT} >/dev/null 2>&1; then
   if grep '^const _TIOCGWINSZ_val' ${OUT} >/dev/null 2>&1; then
@@ -872,6 +936,129 @@
   fi
 fi
 
+if ! grep '^const TUNSETNOCSUM' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETNOCSUM_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETNOCSUM = _TUNSETNOCSUM_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETDEBUG' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETDEBUG_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETDEBUG = _TUNSETDEBUG_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETIFF' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETIFF_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETIFF = _TUNSETIFF_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETPERSIST' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETPERSIST_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETPERSIST = _TUNSETPERSIST_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETOWNER' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETOWNER_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETOWNER = _TUNSETOWNER_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETLINK' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETLINK_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETLINK = _TUNSETLINK_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETGROUP' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETGROUP_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETGROUP = _TUNSETGROUP_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNGETFEATURES' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNGETFEATURES_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNGETFEATURES = _TUNGETFEATURES_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETOFFLOAD' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETOFFLOAD_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETOFFLOAD = _TUNSETOFFLOAD_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETTXFILTER' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETTXFILTER_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETTXFILTER = _TUNSETTXFILTER_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNGETIFF' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNGETIFF_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNGETIFF = _TUNGETIFF_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNGETSNDBUF' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNGETSNDBUF_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNGETSNDBUF = _TUNGETSNDBUF_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETSNDBUF' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETSNDBUF_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETSNDBUF = _TUNSETSNDBUF_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNATTACHFILTER' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNATTACHFILTER_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNATTACHFILTER = _TUNATTACHFILTER_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNDETACHFILTER' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNDETACHFILTER_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNDETACHFILTER = _TUNDETACHFILTER_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNGETVNETHDRSZ' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNGETVNETHDRSZ_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNGETVNETHDRSZ = _TUNGETVNETHDRSZ_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETVNETHDRSZ' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETVNETHDRSZ_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETVNETHDRSZ = _TUNSETVNETHDRSZ_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNSETQUEUE' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETQUEUE_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETQUEUE = _TUNSETQUEUE_val' >> ${OUT}
+  fi
+fi
+
+
+if ! grep '^const TUNSETIFINDEX' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNSETIFINDEX_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNSETIFINDEX = _TUNSETIFINDEX_val' >> ${OUT}
+  fi
+fi
+
+if ! grep '^const TUNGETFILTER' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TUNGETFILTER_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TUNGETFILTER = _TUNGETFILTER_val' >> ${OUT}
+  fi
+fi
+
+
+
 # The ioctl flags for terminal control
 grep '^const _TC[GS]ET' gen-sysinfo.go | grep -v _val | \
     sed -e 's/^\(const \)_\(TC[GS]ET[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
diff -Naur gcc-5.2.0.orig/libgo/runtime/go-main.c gcc-5.2.0/libgo/runtime/go-main.c
--- gcc-5.2.0.orig/libgo/runtime/go-main.c	2015-04-29 16:32:07.000000000 -0500
+++ gcc-5.2.0/libgo/runtime/go-main.c	2015-10-05 05:21:45.150512000 -0500
@@ -38,7 +38,7 @@
   runtime_isarchive = false;
 
   if (runtime_isstarted)
-    return NULL;
+    return 0;
   runtime_isstarted = true;
 
   runtime_check ();
diff -Naur gcc-5.2.0.orig/libgo/runtime/mgc0.c gcc-5.2.0/libgo/runtime/mgc0.c
--- gcc-5.2.0.orig/libgo/runtime/mgc0.c	2015-01-16 16:58:53.000000000 -0600
+++ gcc-5.2.0/libgo/runtime/mgc0.c	2015-09-15 07:32:59.668269000 -0500
@@ -2280,7 +2280,7 @@
 	heap0 = mstats.next_gc*100/(gcpercent+100);
 	// conservatively set next_gc to high value assuming that everything is live
 	// concurrent/lazy sweep will reduce this number while discovering new garbage
-	mstats.next_gc = mstats.heap_alloc+mstats.heap_alloc*gcpercent/100;
+	mstats.next_gc = mstats.heap_alloc+(mstats.heap_alloc-runtime_stacks_sys)*gcpercent/100;
 
 	t4 = runtime_nanotime();
 	mstats.last_gc = runtime_unixnanotime();  // must be Unix time to make sense to user
diff -Naur gcc-5.2.0.orig/libgomp/config/linux/wait.h gcc-5.2.0/libgomp/config/linux/wait.h
--- gcc-5.2.0.orig/libgomp/config/linux/wait.h	2015-01-10 13:10:37.000000000 -0600
+++ gcc-5.2.0/libgomp/config/linux/wait.h	2015-08-24 07:17:07.003659000 -0500
@@ -49,7 +49,9 @@
 {
   unsigned long long i, count = gomp_spin_count_var;
 
-  if (__builtin_expect (gomp_managed_threads > gomp_available_cpus, 0))
+  if (__builtin_expect (__atomic_load_n (&gomp_managed_threads,
+                                         MEMMODEL_RELAXED)
+                        > gomp_available_cpus, 0))
     count = gomp_throttled_spin_count_var;
   for (i = 0; i < count; i++)
     if (__builtin_expect (__atomic_load_n (addr, MEMMODEL_RELAXED) != val, 0))
diff -Naur gcc-5.2.0.orig/libgomp/iter.c gcc-5.2.0/libgomp/iter.c
--- gcc-5.2.0.orig/libgomp/iter.c	2015-01-10 13:10:37.000000000 -0600
+++ gcc-5.2.0/libgomp/iter.c	2015-08-24 07:17:07.003659000 -0500
@@ -218,7 +218,7 @@
 	}
     }
 
-  start = ws->next;
+  start = __atomic_load_n (&ws->next, MEMMODEL_RELAXED);
   while (1)
     {
       long left = end - start;
@@ -301,7 +301,7 @@
   long start, end, nend, incr;
   unsigned long chunk_size;
 
-  start = ws->next;
+  start = __atomic_load_n (&ws->next, MEMMODEL_RELAXED);
   end = ws->end;
   incr = ws->incr;
   chunk_size = ws->chunk_size;
diff -Naur gcc-5.2.0.orig/libgomp/iter_ull.c gcc-5.2.0/libgomp/iter_ull.c
--- gcc-5.2.0.orig/libgomp/iter_ull.c	2015-01-10 13:10:37.000000000 -0600
+++ gcc-5.2.0/libgomp/iter_ull.c	2015-08-24 07:17:07.003659000 -0500
@@ -219,7 +219,7 @@
 	}
     }
 
-  start = ws->next_ull;
+  start = __atomic_load_n (&ws->next_ull, MEMMODEL_RELAXED);
   while (1)
     {
       gomp_ull left = end - start;
@@ -305,7 +305,7 @@
   gomp_ull start, end, nend, incr;
   gomp_ull chunk_size;
 
-  start = ws->next_ull;
+  start = __atomic_load_n (&ws->next_ull, MEMMODEL_RELAXED);
   end = ws->end_ull;
   incr = ws->incr_ull;
   chunk_size = ws->chunk_size_ull;
diff -Naur gcc-5.2.0.orig/libgomp/oacc-host.c gcc-5.2.0/libgomp/oacc-host.c
--- gcc-5.2.0.orig/libgomp/oacc-host.c	2015-04-08 10:58:33.000000000 -0500
+++ gcc-5.2.0/libgomp/oacc-host.c	2015-09-22 06:18:23.719126000 -0500
@@ -82,8 +82,8 @@
   };
 
 /* Register this device type.  */
-static __attribute__ ((constructor))
-void goacc_host_init (void)
+void
+goacc_host_init (void)
 {
   gomp_mutex_init (&host_dispatch.lock);
   goacc_register (&host_dispatch);
diff -Naur gcc-5.2.0.orig/libgomp/oacc-init.c gcc-5.2.0/libgomp/oacc-init.c
--- gcc-5.2.0.orig/libgomp/oacc-init.c	2015-07-15 06:55:00.000000000 -0500
+++ gcc-5.2.0/libgomp/oacc-init.c	2015-09-22 06:18:23.719126000 -0500
@@ -580,6 +580,9 @@
 
   goacc_threads = NULL;
   gomp_mutex_init (&goacc_thread_lock);
+
+  /* Initialize and register the 'host' device type.  */
+  goacc_host_init ();
 }
 
 /* Compiler helper functions */
diff -Naur gcc-5.2.0.orig/libgomp/oacc-int.h gcc-5.2.0/libgomp/oacc-int.h
--- gcc-5.2.0.orig/libgomp/oacc-int.h	2015-04-08 10:58:33.000000000 -0500
+++ gcc-5.2.0/libgomp/oacc-int.h	2015-09-22 06:18:23.719126000 -0500
@@ -97,6 +97,7 @@
 void goacc_save_and_set_bind (acc_device_t);
 void goacc_restore_bind (void);
 void goacc_lazy_initialize (void);
+void goacc_host_init (void);
 
 #ifdef HAVE_ATTRIBUTE_VISIBILITY
 # pragma GCC visibility pop
diff -Naur gcc-5.2.0.orig/libitm/libitm.info gcc-5.2.0/libitm/libitm.info
--- gcc-5.2.0.orig/libitm/libitm.info	2015-07-16 06:38:33.000000000 -0500
+++ gcc-5.2.0/libitm/libitm.info	1969-12-31 18:00:00.000000000 -0600
@@ -1,1307 +0,0 @@
-This is libitm.info, produced by makeinfo version 4.12 from
-/space/rguenther/gcc-5.2.0/gcc-5.2.0/libitm/libitm.texi.
-
-Copyright (C) 2011-2015 Free Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this document
-under the terms of the GNU Free Documentation License, Version 1.2 or
-any later version published by the Free Software Foundation; with no
-Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
-copy of the license is included in the section entitled "GNU Free
-Documentation License".
-
-INFO-DIR-SECTION GNU Libraries
-START-INFO-DIR-ENTRY
-* libitm: (libitm).                    GNU Transactional Memory Library
-END-INFO-DIR-ENTRY
-
-   This manual documents the GNU Transactional Memory Library.
-
-   Copyright (C) 2011-2015 Free Software Foundation, Inc.
-
-   Permission is granted to copy, distribute and/or modify this document
-under the terms of the GNU Free Documentation License, Version 1.2 or
-any later version published by the Free Software Foundation; with no
-Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
-copy of the license is included in the section entitled "GNU Free
-Documentation License".
-
-
-File: libitm.info,  Node: Top,  Next: Enabling libitm,  Up: (dir)
-
-Introduction
-************
-
-This manual documents the usage and internals of libitm, the GNU
-Transactional Memory Library. It provides transaction support for
-accesses to a process' memory, enabling easy-to-use synchronization of
-accesses to shared memory by several threads.
-
-* Menu:
-
-* Enabling libitm::            How to enable libitm for your applications.
-* C/C++ Language Constructs for TM::
-                               Notes on the language-level interface supported
-                               by gcc.
-* The libitm ABI::             Notes on the external ABI provided by libitm.
-* Internals::                  Notes on libitm's internal synchronization.
-* GNU Free Documentation License::
-                               How you can copy and share this manual.
-* Library Index::              Index of this documentation.
-
-
-File: libitm.info,  Node: Enabling libitm,  Next: C/C++ Language Constructs for TM,  Prev: Top,  Up: Top
-
-1 Enabling libitm
-*****************
-
-To activate support for TM in C/C++, the compile-time flag `-fgnu-tm'
-must be specified. This enables TM language-level constructs such as
-transaction statements (e.g., `__transaction_atomic', *note C/C++
-Language Constructs for TM:: for details).
-
-
-File: libitm.info,  Node: C/C++ Language Constructs for TM,  Next: The libitm ABI,  Prev: Enabling libitm,  Up: Top
-
-2 C/C++ Language Constructs for TM
-**********************************
-
-Transactions are supported in C++ and C in the form of transaction
-statements, transaction expressions, and function transactions. In the
-following example, both `a' and `b' will be read and the difference
-will be written to `c', all atomically and isolated from other
-transactions:
-
-     __transaction_atomic { c = a - b; }
-
-   Therefore, another thread can use the following code to concurrently
-update `b' without ever causing `c' to hold a negative value (and
-without having to use other synchronization constructs such as locks or
-C++11 atomics):
-
-     __transaction_atomic { if (a > b) b++; }
-
-   GCC follows the Draft Specification of Transactional Language
-Constructs for C++ (v1.1)
-(https://sites.google.com/site/tmforcplusplus/) in its implementation
-of transactions.
-
-   The precise semantics of transactions are defined in terms of the
-C++11/C11 memory model (see the specification). Roughly, transactions
-provide synchronization guarantees that are similar to what would be
-guaranteed when using a single global lock as a guard for all
-transactions. Note that like other synchronization constructs in C/C++,
-transactions rely on a data-race-free program (e.g., a nontransactional
-write that is concurrent with a transactional read to the same memory
-location is a data race).
-
-
-File: libitm.info,  Node: The libitm ABI,  Next: Internals,  Prev: C/C++ Language Constructs for TM,  Up: Top
-
-3 The libitm ABI
-****************
-
-The ABI provided by libitm is basically equal to the Linux variant of
-Intel's current TM ABI specification document (Revision 1.1, May 6
-2009) but with the differences listed in this chapter. It would be good
-if these changes would eventually be merged into a future version of
-this specification. To ease look-up, the following subsections mirror
-the structure of this specification.
-
-3.1 [No changes] Objectives
-===========================
-
-3.2 [No changes] Non-objectives
-===============================
-
-3.3 Library design principles
-=============================
-
-3.3.1 [No changes] Calling conventions
---------------------------------------
-
-3.3.2 [No changes] TM library algorithms
-----------------------------------------
-
-3.3.3 [No changes] Optimized load and store routines
-----------------------------------------------------
-
-3.3.4 [No changes] Aligned load and store routines
---------------------------------------------------
-
-3.3.5 Data logging functions
-----------------------------
-
-The memory locations accessed with transactional loads and stores and
-the memory locations whose values are logged must not overlap. This
-required separation only extends to the scope of the execution of one
-transaction including all the executions of all nested transactions.
-
-   The compiler must be consistent (within the scope of a single
-transaction) about which memory locations are shared and which are not
-shared with other threads (i.e., data must be accessed either
-transactionally or nontransactionally). Otherwise, non-write-through TM
-algorithms would not work.
-
-   For memory locations on the stack, this requirement extends to only
-the lifetime of the stack frame that the memory location belongs to (or
-the lifetime of the transaction, whichever is shorter).  Thus, memory
-that is reused for several stack frames could be target of both data
-logging and transactional accesses; however, this is harmless because
-these stack frames' lifetimes will end before the transaction finishes.
-
-3.3.6 [No changes] Scatter/gather calls
----------------------------------------
-
-3.3.7 [No changes] Serial and irrevocable mode
-----------------------------------------------
-
-3.3.8 [No changes] Transaction descriptor
------------------------------------------
-
-3.3.9 Store allocation
-----------------------
-
-There is no `getTransaction' function.
-
-3.3.10 [No changes] Naming conventions
---------------------------------------
-
-3.3.11 Function pointer encryption
-----------------------------------
-
-Currently, this is not implemented.
-
-3.4 Types and macros list
-=========================
-
-`_ITM_codeProperties' has changed, *note Starting a transaction:
-txn-code-properties.  `_ITM_srcLocation' is not used.
-
-3.5 Function list
-=================
-
-3.5.1 Initialization and finalization functions
------------------------------------------------
-
-These functions are not part of the ABI.
-
-3.5.2 [No changes] Version checking
------------------------------------
-
-3.5.3 [No changes] Error reporting
-----------------------------------
-
-3.5.4 [No changes] inTransaction call
--------------------------------------
-
-3.5.5 State manipulation functions
-----------------------------------
-
-There is no `getTransaction' function. Transaction identifiers for
-nested transactions will be ordered but not necessarily sequential
-(i.e., for a nested transaction's identifier IN and its enclosing
-transaction's identifier IE, it is guaranteed that IN >= IE).
-
-3.5.6 [No changes] Source locations
------------------------------------
-
-3.5.7 Starting a transaction
-----------------------------
-
-3.5.7.1 Transaction code properties
-...................................
-
-The bit `hasNoXMMUpdate' is instead called `hasNoVectorUpdate'.  Iff it
-is set, vector register save/restore is not necessary for any target
-machine.
-
-   The `hasNoFloatUpdate' bit (`0x0010') is new. Iff it is set, floating
-point register save/restore is not necessary for any target machine.
-
-   `undoLogCode' is not supported and a fatal runtime error will be
-raised if this bit is set. It is not properly defined in the ABI why
-barriers other than undo logging are not present; Are they not
-necessary (e.g., a transaction operating purely on thread-local data)
-or have they been omitted by the compiler because it thinks that some
-kind of global synchronization (e.g., serial mode) might perform
-better? The specification suggests that the latter might be the case,
-but the former seems to be more useful.
-
-   The `readOnly' bit (`0x4000') is new. *TODO* Lexical or dynamic
-scope?
-
-   `hasNoRetry' is not supported. If this bit is not set, but
-`hasNoAbort' is set, the library can assume that transaction rollback
-will not be requested.
-
-   It would be useful if the absence of externally-triggered rollbacks
-would be reported for the dynamic scope as well, not just for the
-lexical scope (`hasNoAbort'). Without this, a library cannot exploit
-this together with flat nesting.
-
-   `exceptionBlock' is not supported because exception blocks are not
-used.
-
-3.5.7.2 [No changes] Windows exception state
-............................................
-
-3.5.7.3 [No changes] Other machine state
-........................................
-
-3.5.7.4 [No changes] Results from beginTransaction
-..................................................
-
-3.5.8 Aborting a transaction
-----------------------------
-
-`_ITM_rollbackTransaction' is not supported. `_ITM_abortTransaction' is
-supported but the abort reasons `exceptionBlockAbort', `TMConflict',
-and `userRetry' are not supported. There are no exception blocks in
-general, so the related cases also do not have to be considered. To
-encode `__transaction_cancel [[outer]]', compilers must set the new
-`outerAbort' bit (`0x10') additionally to the `userAbort' bit in the
-abort reason.
-
-3.5.9 Committing a transaction
-------------------------------
-
-The exception handling (EH) scheme is different. The Intel ABI requires
-the `_ITM_tryCommitTransaction' function that will return even when the
-commit failed and will have to be matched with calls to either
-`_ITM_abortTransaction' or `_ITM_commitTransaction'. In contrast, gcc
-relies on transactional wrappers for the functions of the Exception
-Handling ABI and on one additional commit function (shown below). This
-allows the TM to keep track of EH internally and thus it does not have
-to embed the cleanup of EH state into the existing EH code in the
-program.  `_ITM_tryCommitTransaction' is not supported.
-`_ITM_commitTransactionToId' is also not supported because the
-propagation of thrown exceptions will not bypass commits of nested
-transactions.
-
-     void _ITM_commitTransactionEH(void *exc_ptr) ITM_REGPARM;
-     void *_ITM_cxa_allocate_exception (size_t);
-     void _ITM_cxa_throw (void *obj, void *tinfo, void *dest);
-     void *_ITM_cxa_begin_catch (void *exc_ptr);
-     void _ITM_cxa_end_catch (void);
-
-   `_ITM_commitTransactionEH' must be called to commit a transaction if
-an exception could be in flight at this position in the code. `exc_ptr'
-is the current exception or zero if there is no current exception.  The
-`_ITM_cxa...' functions are transactional wrappers for the respective
-`__cxa...' functions and must be called instead of these in
-transactional code.
-
-   To support this EH scheme, libstdc++ needs to provide one additional
-function (`_cxa_tm_cleanup'), which is used by the TM to clean up the
-exception handling state while rolling back a transaction:
-
-     void __cxa_tm_cleanup (void *unthrown_obj, void *cleanup_exc,
-                            unsigned int caught_count);
-
-   `unthrown_obj' is non-null if the program called
-`__cxa_allocate_exception' for this exception but did not yet called
-`__cxa_throw' for it. `cleanup_exc' is non-null if the program is
-currently processing a cleanup along an exception path but has not
-caught this exception yet. `caught_count' is the nesting depth of
-`__cxa_begin_catch' within the transaction (which can be counted by the
-TM using `_ITM_cxa_begin_catch' and `_ITM_cxa_end_catch');
-`__cxa_tm_cleanup' then performs rollback by essentially performing
-`__cxa_end_catch' that many times.
-
-3.5.10 Exception handling support
----------------------------------
-
-Currently, there is no support for functionality like
-`__transaction_cancel throw' as described in the C++ TM specification.
-Supporting this should be possible with the EH scheme explained
-previously because via the transactional wrappers for the EH ABI, the
-TM is able to observe and intercept EH.
-
-3.5.11 [No changes] Transition to serial-irrevocable mode
----------------------------------------------------------
-
-3.5.12 [No changes] Data transfer functions
--------------------------------------------
-
-3.5.13 [No changes] Transactional memory copies
------------------------------------------------
-
-3.5.14 Transactional versions of memmove
-----------------------------------------
-
-If either the source or destination memory region is to be accessed
-nontransactionally, then source and destination regions must not be
-overlapping. The respective `_ITM_memmove' functions are still
-available but a fatal runtime error will be raised if such regions do
-overlap.  To support this functionality, the ABI would have to specify
-how the intersection of the regions has to be accessed (i.e.,
-transactionally or nontransactionally).
-
-3.5.15 [No changes] Transactional versions of memset
-----------------------------------------------------
-
-3.5.16 [No changes] Logging functions
--------------------------------------
-
-3.5.17 User-registered commit and undo actions
-----------------------------------------------
-
-Commit actions will get executed in the same order in which the
-respective calls to `_ITM_addUserCommitAction' happened. Only
-`_ITM_noTransactionId' is allowed as value for the
-`resumingTransactionId' argument. Commit actions get executed after
-privatization safety has been ensured.
-
-   Undo actions will get executed in reverse order compared to the
-order in which the respective calls to `_ITM_addUserUndoAction'
-happened. The ordering of undo actions w.r.t. the roll-back of other
-actions (e.g., data transfers or memory allocations) is undefined.
-
-   `_ITM_getThreadnum' is not supported currently because its only
-purpose is to provide a thread ID that matches some assumed performance
-tuning output, but this output is not part of the ABI nor further
-defined by it.
-
-   `_ITM_dropReferences' is not supported currently because its
-semantics and the intention behind it is not entirely clear. The
-specification suggests that this function is necessary because of
-certain orderings of data transfer undos and the releasing of memory
-regions (i.e., privatization). However, this ordering is never defined,
-nor is the ordering of dropping references w.r.t. other events.
-
-3.5.18 [New] Transactional indirect calls
------------------------------------------
-
-Indirect calls (i.e., calls through a function pointer) within
-transactions should execute the transactional clone of the original
-function (i.e., a clone of the original that has been fully
-instrumented to use the TM runtime), if such a clone is available. The
-runtime provides two functions to register/deregister clone tables:
-
-     struct clone_entry
-     {
-       void *orig, *clone;
-     };
-
-     void _ITM_registerTMCloneTable (clone_entry *table, size_t entries);
-     void _ITM_deregisterTMCloneTable (clone_entry *table);
-
-   Registered tables must be writable by the TM runtime, and must be
-live throughout the life-time of the TM runtime.
-
-   *TODO* The intention was always to drop the registration functions
-entirely, and create a new ELF Phdr describing the linker-sorted table.
-Much like what currently happens for `PT_GNU_EH_FRAME'.  This work kept
-getting bogged down in how to represent the N different code generation
-variants.  We clearly needed at least two--SW and HW transactional
-clones--but there was always a suggestion of more variants for
-different TM assumptions/invariants.
-
-   The compiler can then use two TM runtime functions to perform
-indirect calls in transactions:
-     void *_ITM_getTMCloneOrIrrevocable (void *function) ITM_REGPARM;
-     void *_ITM_getTMCloneSafe (void *function) ITM_REGPARM;
-
-   If there is a registered clone for supplied function, both will
-return a pointer to the clone. If not, the first runtime function will
-attempt to switch to serial-irrevocable mode and return the original
-pointer, whereas the second will raise a fatal runtime error.
-
-3.5.19 [New] Transactional dynamic memory management
-----------------------------------------------------
-
-     void *_ITM_malloc (size_t)
-            __attribute__((__malloc__)) ITM_PURE;
-     void *_ITM_calloc (size_t, size_t)
-            __attribute__((__malloc__)) ITM_PURE;
-     void _ITM_free (void *) ITM_PURE;
-
-   These functions are essentially transactional wrappers for `malloc',
-`calloc', and `free'. Within transactions, the compiler should replace
-calls to the original functions with calls to the wrapper functions.
-
-3.6 [No changes] Future Enhancements to the ABI
-===============================================
-
-3.7 Sample code
-===============
-
-The code examples might not be correct w.r.t. the current version of
-the ABI, especially everything related to exception handling.
-
-3.8 [New] Memory model
-======================
-
-The ABI should define a memory model and the ordering that is
-guaranteed for data transfers and commit/undo actions, or at least
-refer to another memory model that needs to be preserved. Without that,
-the compiler cannot ensure the memory model specified on the level of
-the programming language (e.g., by the C++ TM specification).
-
-   For example, if a transactional load is ordered before another
-load/store, then the TM runtime must also ensure this ordering when
-accessing shared state. If not, this might break the kind of
-publication safety used in the C++ TM specification. Likewise, the TM
-runtime must ensure privatization safety.
-
-
-File: libitm.info,  Node: Internals,  Next: GNU Free Documentation License,  Prev: The libitm ABI,  Up: Top
-
-4 Internals
-***********
-
-4.1 TM methods and method groups
-================================
-
-libitm supports several ways of synchronizing transactions with each
-other.  These TM methods (or TM algorithms) are implemented in the form
-of subclasses of `abi_dispatch', which provide methods for
-transactional loads and stores as well as callbacks for rollback and
-commit.  All methods that are compatible with each other (i.e., that
-let concurrently running transactions still synchronize correctly even
-if different methods are used) belong to the same TM method group.
-Pointers to TM methods can be obtained using the factory methods
-prefixed with `dispatch_' in `libitm_i.h'. There are two special
-methods, `dispatch_serial' and `dispatch_serialirr', that are
-compatible with all methods because they run transactions completely in
-serial mode.
-
-4.1.1 TM method life cycle
---------------------------
-
-The state of TM methods does not change after construction, but they do
-alter the state of transactions that use this method. However, because
-per-transaction data gets used by several methods, `gtm_thread' is
-responsible for setting an initial state that is useful for all methods.
-After that, methods are responsible for resetting/clearing this state
-on each rollback or commit (of outermost transactions), so that the
-transaction executed next is not affected by the previous transaction.
-
-   There is also global state associated with each method group, which
-is initialized and shut down (`method_group::init()' and `fini()') when
-switching between method groups (see `retry.cc').
-
-4.1.2 Selecting the default method
-----------------------------------
-
-The default method that libitm uses for freshly started transactions
-(but not necessarily for restarted transactions) can be set via an
-environment variable (`ITM_DEFAULT_METHOD'), whose value should be
-equal to the name of one of the factory methods returning abi_dispatch
-subclasses but without the "dispatch_" prefix (e.g., "serialirr"
-instead of `GTM::dispatch_serialirr()').
-
-   Note that this environment variable is only a hint for libitm and
-might not be supported in the future.
-
-4.2 Nesting: flat vs. closed
-============================
-
-We support two different kinds of nesting of transactions. In the case
-of _flat nesting_, the nesting structure is flattened and all nested
-transactions are subsumed by the enclosing transaction. In contrast,
-with _closed nesting_, nested transactions that have not yet committed
-can be rolled back separately from the enclosing transactions; when they
-commit, they are subsumed by the enclosing transaction, and their
-effects will be finally committed when the outermost transaction
-commits.  _Open nesting_ (where nested transactions can commit
-independently of the enclosing transactions) are not supported.
-
-   Flat nesting is the default nesting mode, but closed nesting is
-supported and used when transactions contain user-controlled aborts
-(`__transaction_cancel' statements). We assume that user-controlled
-aborts are rare in typical code and used mostly in exceptional
-situations.  Thus, it makes more sense to use flat nesting by default
-to avoid the performance overhead of the additional checkpoints
-required for closed nesting. User-controlled aborts will correctly
-abort the innermost enclosing transaction, whereas the whole (i.e.,
-outermost) transaction will be restarted otherwise (e.g., when a
-transaction encounters data conflicts during optimistic execution).
-
-4.3 Locking conventions
-=======================
-
-This section documents the locking scheme and rules for all uses of
-locking in libitm. We have to support serial(-irrevocable) mode, which
-is implemented using a global lock as explained next (called the
-_serial lock_). To simplify the overall design, we use the same lock as
-catch-all locking mechanism for other infrequent tasks such as
-(de)registering clone tables or threads. Besides the serial lock, there
-are _per-method-group locks_ that are managed by specific method groups
-(i.e., groups of similar TM concurrency control algorithms), and
-lock-like constructs for quiescence-based operations such as ensuring
-privatization safety.
-
-   Thus, the actions that participate in the libitm-internal locking
-are either _active transactions_ that do not run in serial mode, _serial
-transactions_ (which (are about to) run in serial mode), and management
-tasks that do not execute within a transaction but have acquired the
-serial mode like a serial transaction would do (e.g., to be able to
-register threads with libitm). Transactions become active as soon as
-they have successfully used the serial lock to announce this globally
-(*note Serial lock implementation: serial-lock-impl.). Likewise,
-transactions become serial transactions as soon as they have acquired
-the exclusive rights provided by the serial lock (i.e., serial mode,
-which also means that there are no other concurrent active or serial
-transactions). Note that active transactions can become serial
-transactions when they enter serial mode during the runtime of the
-transaction.
-
-4.3.1 State-to-lock mapping
----------------------------
-
-Application data is protected by the serial lock if there is a serial
-transaction and no concurrently running active transaction (i.e.,
-non-serial).  Otherwise, application data is protected by the currently
-selected method group, which might use per-method-group locks or other
-mechanisms. Also note that application data that is about to be
-privatized might not be allowed to be accessed by nontransactional code
-until privatization safety has been ensured; the details of this are
-handled by the current method group.
-
-   libitm-internal state is either protected by the serial lock or
-accessed through custom concurrent code. The latter applies to the
-public/shared part of a transaction object and most typical
-method-group-specific state.
-
-   The former category (protected by the serial lock) includes:
-   * The list of active threads that have used transactions.
-
-   * The tables that map functions to their transactional clones.
-
-   * The current selection of which method group to use.
-
-   * Some method-group-specific data, or invariants of this data. For
-     example, resetting a method group to its initial state is handled
-     by switching to the same method group, so the serial lock protects
-     such resetting as well.
-   In general, such state is immutable whenever there exists an active
-(non-serial) transaction. If there is no active transaction, a serial
-transaction (or a thread that is not currently executing a transaction
-but has acquired the serial lock) is allowed to modify this state (but
-must of course be careful to not surprise the current method group's
-implementation with such modifications).
-
-4.3.2 Lock acquisition order
-----------------------------
-
-To prevent deadlocks, locks acquisition must happen in a globally
-agreed-upon order. Note that this applies to other forms of blocking
-too, but does not necessarily apply to lock acquisitions that do not
-block (e.g., trylock() calls that do not get retried forever). Note
-that serial transactions are never return back to active transactions
-until the transaction has committed.  Likewise, active transactions
-stay active until they have committed.  Per-method-group locks are
-typically also not released before commit.
-
-   Lock acquisition / blocking rules:
-   * Transactions must become active or serial before they are allowed
-     to use method-group-specific locks or blocking (i.e., the serial
-     lock must be acquired before those other locks, either in serial
-     or nonserial mode).
-
-   * Any number of threads that do not currently run active
-     transactions can block while trying to get the serial lock in
-     exclusive mode. Note that active transactions must not block when
-     trying to upgrade to serial mode unless there is no other
-     transaction that is trying that (the latter is ensured by the
-     serial lock implementation.
-
-   * Method groups must prevent deadlocks on their locks. In
-     particular, they must also be prepared for another active
-     transaction that has acquired method-group-specific locks but is
-     blocked during an attempt to upgrade to being a serial
-     transaction. See below for details.
-
-   * Serial transactions can acquire method-group-specific locks
-     because there will be no other active nor serial transaction.
-
-
-   There is no single rule for per-method-group blocking because this
-depends on when a TM method might acquire locks. If no active
-transaction can upgrade to being a serial transaction after it has
-acquired per-method-group locks (e.g., when those locks are only
-acquired during an attempt to commit), then the TM method does not need
-to consider a potential deadlock due to serial mode.
-
-   If there can be upgrades to serial mode after the acquisition of
-per-method-group locks, then TM methods need to avoid those deadlocks:
-   * When upgrading to a serial transaction, after acquiring exclusive
-     rights to the serial lock but before waiting for concurrent active
-     transactions to finish (*note Serial lock implementation:
-     serial-lock-impl. for details), we have to wake up all active
-     transactions waiting on the upgrader's per-method-group locks.
-
-   * Active transactions blocking on per-method-group locks need to
-     check the serial lock and abort if there is a pending serial
-     transaction.
-
-   * Lost wake-ups have to be prevented (e.g., by changing a bit in each
-     per-method-group lock before doing the wake-up, and only blocking
-     on this lock using a futex if this bit is not group).
-
-   *TODO*: Can reuse serial lock for gl-*? And if we can, does it make
-sense to introduce further complexity in the serial lock? For gl-*, we
-can really only avoid an abort if we do -wb and -vbv.
-
-4.3.3 Serial lock implementation
---------------------------------
-
-The serial lock implementation is optimized towards assuming that serial
-transactions are infrequent and not the common case. However, the
-performance of entering serial mode can matter because when only few
-transactions are run concurrently or if there are few threads, then it
-can be efficient to run transactions serially.
-
-   The serial lock is similar to a multi-reader-single-writer lock in
-that there can be several active transactions but only one serial
-transaction. However, we do want to avoid contention (in the lock
-implementation) between active transactions, so we split up the reader
-side of the lock into per-transaction flags that are true iff the
-transaction is active. The exclusive writer side remains a shared
-single flag, which is acquired using a CAS, for example.  On the
-fast-path, the serial lock then works similar to Dekker's algorithm but
-with several reader flags that a serial transaction would have to check.
-A serial transaction thus requires a list of all threads with
-potentially active transactions; we can use the serial lock itself to
-protect this list (i.e., only threads that have acquired the serial
-lock can modify this list).
-
-   We want starvation-freedom for the serial lock to allow for using it
-to ensure progress for potentially starved transactions (*note Progress
-Guarantees: progress-guarantees. for details). However, this is
-currently not enforced by the implementation of the serial lock.
-
-   Here is pseudo-code for the read/write fast paths of acquiring the
-serial lock (read-to-write upgrade is similar to write_lock:
-     // read_lock:
-     tx->shared_state |= active;
-     __sync_synchronize(); // or STLD membar, or C++0x seq-cst fence
-     while (!serial_lock.exclusive)
-       if (spinning_for_too_long) goto slowpath;
-
-     // write_lock:
-     if (CAS(&serial_lock.exclusive, 0, this) != 0)
-       goto slowpath; // writer-writer contention
-     // need a membar here, but CAS already has full membar semantics
-     bool need_blocking = false;
-     for (t: all txns)
-       {
-         for (;t->shared_state & active;)
-           if (spinning_for_too_long) { need_blocking = true; break; }
-       }
-     if (need_blocking) goto slowpath;
-
-   Releasing a lock in this spin-lock version then just consists of
-resetting `tx->shared_state' to inactive or clearing
-`serial_lock.exclusive'.
-
-   However, we can't rely on a pure spinlock because we need to get the
-OS involved at some time (e.g., when there are more threads than CPUs
-to run on).  Therefore, the real implementation falls back to a
-blocking slow path, either based on pthread mutexes or Linux futexes.
-
-4.3.4 Reentrancy
-----------------
-
-libitm has to consider the following cases of reentrancy:
-   * Transaction calls unsafe code that starts a new transaction: The
-     outer transaction will become a serial transaction before
-     executing unsafe code.  Therefore, nesting within serial
-     transactions must work, even if the nested transaction is called
-     from within uninstrumented code.
-
-   * Transaction calls either a transactional wrapper or safe code,
-     which in turn starts a new transaction: It is not yet defined in
-     the specification whether this is allowed. Thus, it is undefined
-     whether libitm supports this.
-
-   * Code that starts new transactions might be called from within any
-     part of libitm: This kind of reentrancy would likely be rather
-     complex and can probably be avoided. Therefore, it is not
-     supported.
-
-
-4.3.5 Privatization safety
---------------------------
-
-Privatization safety is ensured by libitm using a quiescence-based
-approach.  Basically, a privatizing transaction waits until all
-concurrent active transactions will either have finished (are not
-active anymore) or operate on a sufficiently recent snapshot to not
-access the privatized data anymore. This happens after the privatizing
-transaction has stopped being an active transaction, so waiting for
-quiescence does not contribute to deadlocks.
-
-   In method groups that need to ensure publication safety explicitly,
-active transactions maintain a flag or timestamp in the public/shared
-part of the transaction descriptor. Before blocking, privatizers need
-to let the other transactions know that they should wake up the
-privatizer.
-
-   *TODO* Ho to implement the waiters? Should those flags be
-per-transaction or at a central place? We want to avoid one wake/wait
-call per active transactions, so we might want to use either a tree or
-combining to reduce the syscall overhead, or rather spin for a long
-amount of time instead of doing blocking. Also, it would be good if
-only the last transaction that the privatizer waits for would do the
-wake-up.
-
-4.3.6 Progress guarantees
--------------------------
-
-Transactions that do not make progress when using the current TM method
-will eventually try to execute in serial mode. Thus, the serial lock's
-progress guarantees determine the progress guarantees of the whole TM.
-Obviously, we at least need deadlock-freedom for the serial lock, but
-it would also be good to provide starvation-freedom (informally, all
-threads will finish executing a transaction eventually iff they get
-enough cycles).
-
-   However, the scheduling of transactions (e.g., thread scheduling by
-the OS) also affects the handling of progress guarantees by the TM.
-First, the TM can only guarantee deadlock-freedom if threads do not get
-stopped. Likewise, low-priority threads can starve if they do not get
-scheduled when other high-priority threads get those cycles instead.
-
-   If all threads get scheduled eventually, correct lock
-implementations will provide deadlock-freedom, but might not provide
-starvation-freedom. We can either enforce the latter in the TM's lock
-implementation, or assume that the scheduling is sufficiently random to
-yield a probabilistic guarantee that no thread will starve (because
-eventually, a transaction will encounter a scheduling that will allow
-it to run). This can indeed work well in practice but is not
-necessarily guaranteed to work (e.g., simple spin locks can be pretty
-efficient).
-
-   Because enforcing stronger progress guarantees in the TM has a
-higher runtime overhead, we focus on deadlock-freedom right now and
-assume that the threads will get scheduled eventually by the OS (but
-don't consider threads with different priorities). We should support
-starvation-freedom for serial transactions in the future. Everything
-beyond that is highly related to proper contention management across
-all of the TM (including with TM method to choose), and is future work.
-
-   *TODO* Handling thread priorities: We want to avoid priority
-inversion but it's unclear how often that actually matters in practice.
-Workloads that have threads with different priorities will likely also
-require lower latency or higher throughput for high-priority threads.
-Therefore, it probably makes not that much sense (except for eventual
-progress guarantees) to use priority inheritance until the TM has
-priority-aware contention management.
-
-
-File: libitm.info,  Node: GNU Free Documentation License,  Next: Library Index,  Prev: Internals,  Up: Top
-
-GNU Free Documentation License
-******************************
-
-                     Version 1.3, 3 November 2008
-
-     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
-     `http://fsf.org/'
-
-     Everyone is permitted to copy and distribute verbatim copies
-     of this license document, but changing it is not allowed.
-
-  0. PREAMBLE
-
-     The purpose of this License is to make a manual, textbook, or other
-     functional and useful document "free" in the sense of freedom: to
-     assure everyone the effective freedom to copy and redistribute it,
-     with or without modifying it, either commercially or
-     noncommercially.  Secondarily, this License preserves for the
-     author and publisher a way to get credit for their work, while not
-     being considered responsible for modifications made by others.
-
-     This License is a kind of "copyleft", which means that derivative
-     works of the document must themselves be free in the same sense.
-     It complements the GNU General Public License, which is a copyleft
-     license designed for free software.
-
-     We have designed this License in order to use it for manuals for
-     free software, because free software needs free documentation: a
-     free program should come with manuals providing the same freedoms
-     that the software does.  But this License is not limited to
-     software manuals; it can be used for any textual work, regardless
-     of subject matter or whether it is published as a printed book.
-     We recommend this License principally for works whose purpose is
-     instruction or reference.
-
-  1. APPLICABILITY AND DEFINITIONS
-
-     This License applies to any manual or other work, in any medium,
-     that contains a notice placed by the copyright holder saying it
-     can be distributed under the terms of this License.  Such a notice
-     grants a world-wide, royalty-free license, unlimited in duration,
-     to use that work under the conditions stated herein.  The
-     "Document", below, refers to any such manual or work.  Any member
-     of the public is a licensee, and is addressed as "you".  You
-     accept the license if you copy, modify or distribute the work in a
-     way requiring permission under copyright law.
-
-     A "Modified Version" of the Document means any work containing the
-     Document or a portion of it, either copied verbatim, or with
-     modifications and/or translated into another language.
-
-     A "Secondary Section" is a named appendix or a front-matter section
-     of the Document that deals exclusively with the relationship of the
-     publishers or authors of the Document to the Document's overall
-     subject (or to related matters) and contains nothing that could
-     fall directly within that overall subject.  (Thus, if the Document
-     is in part a textbook of mathematics, a Secondary Section may not
-     explain any mathematics.)  The relationship could be a matter of
-     historical connection with the subject or with related matters, or
-     of legal, commercial, philosophical, ethical or political position
-     regarding them.
-
-     The "Invariant Sections" are certain Secondary Sections whose
-     titles are designated, as being those of Invariant Sections, in
-     the notice that says that the Document is released under this
-     License.  If a section does not fit the above definition of
-     Secondary then it is not allowed to be designated as Invariant.
-     The Document may contain zero Invariant Sections.  If the Document
-     does not identify any Invariant Sections then there are none.
-
-     The "Cover Texts" are certain short passages of text that are
-     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
-     that says that the Document is released under this License.  A
-     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
-     be at most 25 words.
-
-     A "Transparent" copy of the Document means a machine-readable copy,
-     represented in a format whose specification is available to the
-     general public, that is suitable for revising the document
-     straightforwardly with generic text editors or (for images
-     composed of pixels) generic paint programs or (for drawings) some
-     widely available drawing editor, and that is suitable for input to
-     text formatters or for automatic translation to a variety of
-     formats suitable for input to text formatters.  A copy made in an
-     otherwise Transparent file format whose markup, or absence of
-     markup, has been arranged to thwart or discourage subsequent
-     modification by readers is not Transparent.  An image format is
-     not Transparent if used for any substantial amount of text.  A
-     copy that is not "Transparent" is called "Opaque".
-
-     Examples of suitable formats for Transparent copies include plain
-     ASCII without markup, Texinfo input format, LaTeX input format,
-     SGML or XML using a publicly available DTD, and
-     standard-conforming simple HTML, PostScript or PDF designed for
-     human modification.  Examples of transparent image formats include
-     PNG, XCF and JPG.  Opaque formats include proprietary formats that
-     can be read and edited only by proprietary word processors, SGML or
-     XML for which the DTD and/or processing tools are not generally
-     available, and the machine-generated HTML, PostScript or PDF
-     produced by some word processors for output purposes only.
-
-     The "Title Page" means, for a printed book, the title page itself,
-     plus such following pages as are needed to hold, legibly, the
-     material this License requires to appear in the title page.  For
-     works in formats which do not have any title page as such, "Title
-     Page" means the text near the most prominent appearance of the
-     work's title, preceding the beginning of the body of the text.
-
-     The "publisher" means any person or entity that distributes copies
-     of the Document to the public.
-
-     A section "Entitled XYZ" means a named subunit of the Document
-     whose title either is precisely XYZ or contains XYZ in parentheses
-     following text that translates XYZ in another language.  (Here XYZ
-     stands for a specific section name mentioned below, such as
-     "Acknowledgements", "Dedications", "Endorsements", or "History".)
-     To "Preserve the Title" of such a section when you modify the
-     Document means that it remains a section "Entitled XYZ" according
-     to this definition.
-
-     The Document may include Warranty Disclaimers next to the notice
-     which states that this License applies to the Document.  These
-     Warranty Disclaimers are considered to be included by reference in
-     this License, but only as regards disclaiming warranties: any other
-     implication that these Warranty Disclaimers may have is void and
-     has no effect on the meaning of this License.
-
-  2. VERBATIM COPYING
-
-     You may copy and distribute the Document in any medium, either
-     commercially or noncommercially, provided that this License, the
-     copyright notices, and the license notice saying this License
-     applies to the Document are reproduced in all copies, and that you
-     add no other conditions whatsoever to those of this License.  You
-     may not use technical measures to obstruct or control the reading
-     or further copying of the copies you make or distribute.  However,
-     you may accept compensation in exchange for copies.  If you
-     distribute a large enough number of copies you must also follow
-     the conditions in section 3.
-
-     You may also lend copies, under the same conditions stated above,
-     and you may publicly display copies.
-
-  3. COPYING IN QUANTITY
-
-     If you publish printed copies (or copies in media that commonly
-     have printed covers) of the Document, numbering more than 100, and
-     the Document's license notice requires Cover Texts, you must
-     enclose the copies in covers that carry, clearly and legibly, all
-     these Cover Texts: Front-Cover Texts on the front cover, and
-     Back-Cover Texts on the back cover.  Both covers must also clearly
-     and legibly identify you as the publisher of these copies.  The
-     front cover must present the full title with all words of the
-     title equally prominent and visible.  You may add other material
-     on the covers in addition.  Copying with changes limited to the
-     covers, as long as they preserve the title of the Document and
-     satisfy these conditions, can be treated as verbatim copying in
-     other respects.
-
-     If the required texts for either cover are too voluminous to fit
-     legibly, you should put the first ones listed (as many as fit
-     reasonably) on the actual cover, and continue the rest onto
-     adjacent pages.
-
-     If you publish or distribute Opaque copies of the Document
-     numbering more than 100, you must either include a
-     machine-readable Transparent copy along with each Opaque copy, or
-     state in or with each Opaque copy a computer-network location from
-     which the general network-using public has access to download
-     using public-standard network protocols a complete Transparent
-     copy of the Document, free of added material.  If you use the
-     latter option, you must take reasonably prudent steps, when you
-     begin distribution of Opaque copies in quantity, to ensure that
-     this Transparent copy will remain thus accessible at the stated
-     location until at least one year after the last time you
-     distribute an Opaque copy (directly or through your agents or
-     retailers) of that edition to the public.
-
-     It is requested, but not required, that you contact the authors of
-     the Document well before redistributing any large number of
-     copies, to give them a chance to provide you with an updated
-     version of the Document.
-
-  4. MODIFICATIONS
-
-     You may copy and distribute a Modified Version of the Document
-     under the conditions of sections 2 and 3 above, provided that you
-     release the Modified Version under precisely this License, with
-     the Modified Version filling the role of the Document, thus
-     licensing distribution and modification of the Modified Version to
-     whoever possesses a copy of it.  In addition, you must do these
-     things in the Modified Version:
-
-       A. Use in the Title Page (and on the covers, if any) a title
-          distinct from that of the Document, and from those of
-          previous versions (which should, if there were any, be listed
-          in the History section of the Document).  You may use the
-          same title as a previous version if the original publisher of
-          that version gives permission.
-
-       B. List on the Title Page, as authors, one or more persons or
-          entities responsible for authorship of the modifications in
-          the Modified Version, together with at least five of the
-          principal authors of the Document (all of its principal
-          authors, if it has fewer than five), unless they release you
-          from this requirement.
-
-       C. State on the Title page the name of the publisher of the
-          Modified Version, as the publisher.
-
-       D. Preserve all the copyright notices of the Document.
-
-       E. Add an appropriate copyright notice for your modifications
-          adjacent to the other copyright notices.
-
-       F. Include, immediately after the copyright notices, a license
-          notice giving the public permission to use the Modified
-          Version under the terms of this License, in the form shown in
-          the Addendum below.
-
-       G. Preserve in that license notice the full lists of Invariant
-          Sections and required Cover Texts given in the Document's
-          license notice.
-
-       H. Include an unaltered copy of this License.
-
-       I. Preserve the section Entitled "History", Preserve its Title,
-          and add to it an item stating at least the title, year, new
-          authors, and publisher of the Modified Version as given on
-          the Title Page.  If there is no section Entitled "History" in
-          the Document, create one stating the title, year, authors,
-          and publisher of the Document as given on its Title Page,
-          then add an item describing the Modified Version as stated in
-          the previous sentence.
-
-       J. Preserve the network location, if any, given in the Document
-          for public access to a Transparent copy of the Document, and
-          likewise the network locations given in the Document for
-          previous versions it was based on.  These may be placed in
-          the "History" section.  You may omit a network location for a
-          work that was published at least four years before the
-          Document itself, or if the original publisher of the version
-          it refers to gives permission.
-
-       K. For any section Entitled "Acknowledgements" or "Dedications",
-          Preserve the Title of the section, and preserve in the
-          section all the substance and tone of each of the contributor
-          acknowledgements and/or dedications given therein.
-
-       L. Preserve all the Invariant Sections of the Document,
-          unaltered in their text and in their titles.  Section numbers
-          or the equivalent are not considered part of the section
-          titles.
-
-       M. Delete any section Entitled "Endorsements".  Such a section
-          may not be included in the Modified Version.
-
-       N. Do not retitle any existing section to be Entitled
-          "Endorsements" or to conflict in title with any Invariant
-          Section.
-
-       O. Preserve any Warranty Disclaimers.
-
-     If the Modified Version includes new front-matter sections or
-     appendices that qualify as Secondary Sections and contain no
-     material copied from the Document, you may at your option
-     designate some or all of these sections as invariant.  To do this,
-     add their titles to the list of Invariant Sections in the Modified
-     Version's license notice.  These titles must be distinct from any
-     other section titles.
-
-     You may add a section Entitled "Endorsements", provided it contains
-     nothing but endorsements of your Modified Version by various
-     parties--for example, statements of peer review or that the text
-     has been approved by an organization as the authoritative
-     definition of a standard.
-
-     You may add a passage of up to five words as a Front-Cover Text,
-     and a passage of up to 25 words as a Back-Cover Text, to the end
-     of the list of Cover Texts in the Modified Version.  Only one
-     passage of Front-Cover Text and one of Back-Cover Text may be
-     added by (or through arrangements made by) any one entity.  If the
-     Document already includes a cover text for the same cover,
-     previously added by you or by arrangement made by the same entity
-     you are acting on behalf of, you may not add another; but you may
-     replace the old one, on explicit permission from the previous
-     publisher that added the old one.
-
-     The author(s) and publisher(s) of the Document do not by this
-     License give permission to use their names for publicity for or to
-     assert or imply endorsement of any Modified Version.
-
-  5. COMBINING DOCUMENTS
-
-     You may combine the Document with other documents released under
-     this License, under the terms defined in section 4 above for
-     modified versions, provided that you include in the combination
-     all of the Invariant Sections of all of the original documents,
-     unmodified, and list them all as Invariant Sections of your
-     combined work in its license notice, and that you preserve all
-     their Warranty Disclaimers.
-
-     The combined work need only contain one copy of this License, and
-     multiple identical Invariant Sections may be replaced with a single
-     copy.  If there are multiple Invariant Sections with the same name
-     but different contents, make the title of each such section unique
-     by adding at the end of it, in parentheses, the name of the
-     original author or publisher of that section if known, or else a
-     unique number.  Make the same adjustment to the section titles in
-     the list of Invariant Sections in the license notice of the
-     combined work.
-
-     In the combination, you must combine any sections Entitled
-     "History" in the various original documents, forming one section
-     Entitled "History"; likewise combine any sections Entitled
-     "Acknowledgements", and any sections Entitled "Dedications".  You
-     must delete all sections Entitled "Endorsements."
-
-  6. COLLECTIONS OF DOCUMENTS
-
-     You may make a collection consisting of the Document and other
-     documents released under this License, and replace the individual
-     copies of this License in the various documents with a single copy
-     that is included in the collection, provided that you follow the
-     rules of this License for verbatim copying of each of the
-     documents in all other respects.
-
-     You may extract a single document from such a collection, and
-     distribute it individually under this License, provided you insert
-     a copy of this License into the extracted document, and follow
-     this License in all other respects regarding verbatim copying of
-     that document.
-
-  7. AGGREGATION WITH INDEPENDENT WORKS
-
-     A compilation of the Document or its derivatives with other
-     separate and independent documents or works, in or on a volume of
-     a storage or distribution medium, is called an "aggregate" if the
-     copyright resulting from the compilation is not used to limit the
-     legal rights of the compilation's users beyond what the individual
-     works permit.  When the Document is included in an aggregate, this
-     License does not apply to the other works in the aggregate which
-     are not themselves derivative works of the Document.
-
-     If the Cover Text requirement of section 3 is applicable to these
-     copies of the Document, then if the Document is less than one half
-     of the entire aggregate, the Document's Cover Texts may be placed
-     on covers that bracket the Document within the aggregate, or the
-     electronic equivalent of covers if the Document is in electronic
-     form.  Otherwise they must appear on printed covers that bracket
-     the whole aggregate.
-
-  8. TRANSLATION
-
-     Translation is considered a kind of modification, so you may
-     distribute translations of the Document under the terms of section
-     4.  Replacing Invariant Sections with translations requires special
-     permission from their copyright holders, but you may include
-     translations of some or all Invariant Sections in addition to the
-     original versions of these Invariant Sections.  You may include a
-     translation of this License, and all the license notices in the
-     Document, and any Warranty Disclaimers, provided that you also
-     include the original English version of this License and the
-     original versions of those notices and disclaimers.  In case of a
-     disagreement between the translation and the original version of
-     this License or a notice or disclaimer, the original version will
-     prevail.
-
-     If a section in the Document is Entitled "Acknowledgements",
-     "Dedications", or "History", the requirement (section 4) to
-     Preserve its Title (section 1) will typically require changing the
-     actual title.
-
-  9. TERMINATION
-
-     You may not copy, modify, sublicense, or distribute the Document
-     except as expressly provided under this License.  Any attempt
-     otherwise to copy, modify, sublicense, or distribute it is void,
-     and will automatically terminate your rights under this License.
-
-     However, if you cease all violation of this License, then your
-     license from a particular copyright holder is reinstated (a)
-     provisionally, unless and until the copyright holder explicitly
-     and finally terminates your license, and (b) permanently, if the
-     copyright holder fails to notify you of the violation by some
-     reasonable means prior to 60 days after the cessation.
-
-     Moreover, your license from a particular copyright holder is
-     reinstated permanently if the copyright holder notifies you of the
-     violation by some reasonable means, this is the first time you have
-     received notice of violation of this License (for any work) from
-     that copyright holder, and you cure the violation prior to 30 days
-     after your receipt of the notice.
-
-     Termination of your rights under this section does not terminate
-     the licenses of parties who have received copies or rights from
-     you under this License.  If your rights have been terminated and
-     not permanently reinstated, receipt of a copy of some or all of
-     the same material does not give you any rights to use it.
-
- 10. FUTURE REVISIONS OF THIS LICENSE
-
-     The Free Software Foundation may publish new, revised versions of
-     the GNU Free Documentation License from time to time.  Such new
-     versions will be similar in spirit to the present version, but may
-     differ in detail to address new problems or concerns.  See
-     `http://www.gnu.org/copyleft/'.
-
-     Each version of the License is given a distinguishing version
-     number.  If the Document specifies that a particular numbered
-     version of this License "or any later version" applies to it, you
-     have the option of following the terms and conditions either of
-     that specified version or of any later version that has been
-     published (not as a draft) by the Free Software Foundation.  If
-     the Document does not specify a version number of this License,
-     you may choose any version ever published (not as a draft) by the
-     Free Software Foundation.  If the Document specifies that a proxy
-     can decide which future versions of this License can be used, that
-     proxy's public statement of acceptance of a version permanently
-     authorizes you to choose that version for the Document.
-
- 11. RELICENSING
-
-     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
-     World Wide Web server that publishes copyrightable works and also
-     provides prominent facilities for anybody to edit those works.  A
-     public wiki that anybody can edit is an example of such a server.
-     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
-     site means any set of copyrightable works thus published on the MMC
-     site.
-
-     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
-     license published by Creative Commons Corporation, a not-for-profit
-     corporation with a principal place of business in San Francisco,
-     California, as well as future copyleft versions of that license
-     published by that same organization.
-
-     "Incorporate" means to publish or republish a Document, in whole or
-     in part, as part of another Document.
-
-     An MMC is "eligible for relicensing" if it is licensed under this
-     License, and if all works that were first published under this
-     License somewhere other than this MMC, and subsequently
-     incorporated in whole or in part into the MMC, (1) had no cover
-     texts or invariant sections, and (2) were thus incorporated prior
-     to November 1, 2008.
-
-     The operator of an MMC Site may republish an MMC contained in the
-     site under CC-BY-SA on the same site at any time before August 1,
-     2009, provided the MMC is eligible for relicensing.
-
-
-ADDENDUM: How to use this License for your documents
-====================================================
-
-To use this License in a document you have written, include a copy of
-the License in the document and put the following copyright and license
-notices just after the title page:
-
-       Copyright (C)  YEAR  YOUR NAME.
-       Permission is granted to copy, distribute and/or modify this document
-       under the terms of the GNU Free Documentation License, Version 1.3
-       or any later version published by the Free Software Foundation;
-       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
-       Texts.  A copy of the license is included in the section entitled ``GNU
-       Free Documentation License''.
-
-   If you have Invariant Sections, Front-Cover Texts and Back-Cover
-Texts, replace the "with...Texts." line with this:
-
-         with the Invariant Sections being LIST THEIR TITLES, with
-         the Front-Cover Texts being LIST, and with the Back-Cover Texts
-         being LIST.
-
-   If you have Invariant Sections without Cover Texts, or some other
-combination of the three, merge those two alternatives to suit the
-situation.
-
-   If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License, to
-permit their use in free software.
-
-
-File: libitm.info,  Node: Library Index,  Prev: GNU Free Documentation License,  Up: Top
-
-Library Index
-*************
-
- [index ]
-* Menu:
-
-* FDL, GNU Free Documentation License:   GNU Free Documentation License.
-                                                                (line 6)
-* Introduction:                          Top.                   (line 6)
-
-
-
-Tag Table:
-Node: Top1187
-Node: Enabling libitm2090
-Node: C/C++ Language Constructs for TM2484
-Node: The libitm ABI3964
-Ref: txn-code-properties7757
-Node: Internals18032
-Ref: serial-lock-impl28057
-Ref: progress-guarantees32807
-Node: GNU Free Documentation License35081
-Node: Library Index60230
-
-End Tag Table
diff -Naur gcc-5.2.0.orig/libquadmath/libquadmath.info gcc-5.2.0/libquadmath/libquadmath.info
--- gcc-5.2.0.orig/libquadmath/libquadmath.info	2015-07-16 06:26:15.000000000 -0500
+++ gcc-5.2.0/libquadmath/libquadmath.info	1969-12-31 18:00:00.000000000 -0600
@@ -1,924 +0,0 @@
-This is libquadmath.info, produced by makeinfo version 4.12 from
-/space/rguenther/gcc-5.2.0/gcc-5.2.0/libquadmath/libquadmath.texi.
-
-Copyright (C) 2010-2015 Free Software Foundation, Inc.
-
-     Permission is granted to copy, distribute and/or modify this
-     document under the terms of the GNU Free Documentation License,
-     Version 1.2 or any later version published by the Free Software
-     Foundation; with no Invariant Sections, with the Front-Cover Texts
-     being "A GNU Manual," and with the Back-Cover Texts as in (a)
-     below.  A copy of the license is included in the section entitled
-     "GNU Free Documentation License."
-
-     (a) The FSF's Back-Cover Text is: "You have the freedom to copy
-     and modify this GNU manual.
-
-INFO-DIR-SECTION GNU Libraries
-START-INFO-DIR-ENTRY
-* libquadmath: (libquadmath).                  GCC Quad-Precision Math Library
-END-INFO-DIR-ENTRY
-
-   This manual documents the GCC Quad-Precision Math Library API.
-
-   Published by the Free Software Foundation 51 Franklin Street, Fifth
-Floor Boston, MA 02110-1301 USA
-
-   Copyright (C) 2010-2015 Free Software Foundation, Inc.
-
-     Permission is granted to copy, distribute and/or modify this
-     document under the terms of the GNU Free Documentation License,
-     Version 1.2 or any later version published by the Free Software
-     Foundation; with no Invariant Sections, with the Front-Cover Texts
-     being "A GNU Manual," and with the Back-Cover Texts as in (a)
-     below.  A copy of the license is included in the section entitled
-     "GNU Free Documentation License."
-
-     (a) The FSF's Back-Cover Text is: "You have the freedom to copy
-     and modify this GNU manual.
-
-
-File: libquadmath.info,  Node: Top,  Next: Typedef and constants,  Up: (dir)
-
-Introduction
-************
-
-This manual documents the usage of libquadmath, the GCC Quad-Precision
-Math Library Application Programming Interface (API).
-
-* Menu:
-
-* Typedef and constants::      Defined data types and constants
-* Math Library Routines::      The Libquadmath math runtime application
-                               programming interface.
-* I/O Library Routines::       The Libquadmath I/O runtime application
-                               programming interface.
-* GNU Free Documentation License::
-                               How you can copy and share this manual.
-* Reporting Bugs::             How to report bugs in GCC Libquadmath.
-
-
-File: libquadmath.info,  Node: Typedef and constants,  Next: Math Library Routines,  Prev: Top,  Up: Top
-
-1 Typedef and constants
-***********************
-
-The following data type has been defined via `typedef'.
-
-`__complex128': `__float128'-based complex number
-
-   The following macros are defined, which give the numeric limits of
-the `__float128' data type.
-
-`FLT128_MAX': largest finite number
-
-`FLT128_MIN': smallest positive number with full precision
-
-`FLT128_EPSILON': difference between 1 and the next larger
-     representable number
-
-`FLT128_DENORM_MIN': smallest positive denormalized number
-
-`FLT128_MANT_DIG': number of digits in the mantissa (bit precision)
-
-`FLT128_MIN_EXP': maximal negative exponent
-
-`FLT128_MAX_EXP': maximal positive exponent
-
-`FLT128_DIG': number of decimal digits in the mantissa
-
-`FLT128_MIN_10_EXP': maximal negative decimal exponent
-
-`FLT128_MAX_10_EXP': maximal positive decimal exponent
-
-   The following mathematical constants of type `__float128' are
-defined.
-
-`M_Eq': the constant e (Euler's number)
-
-`M_LOG2Eq': binary logarithm of 2
-
-`M_LOG10Eq': common, decimal logarithm of 2
-
-`M_LN2q': natural logarithm of 2
-
-`M_LN10q': natural logarithm of 10
-
-`M_PIq': pi
-
-`M_PI_2q': pi divided by two
-
-`M_PI_4q': pi divided by four
-
-`M_1_PIq': one over pi
-
-`M_2_PIq': one over two pi
-
-`M_2_SQRTPIq': two over square root of pi
-
-`M_SQRT2q': square root of 2
-
-`M_SQRT1_2q': one over square root of 2
-
-
-File: libquadmath.info,  Node: Math Library Routines,  Next: I/O Library Routines,  Prev: Typedef and constants,  Up: Top
-
-2 Math Library Routines
-***********************
-
-The following mathematical functions are available:
-
-`acosq': arc cosine function
-
-`acoshq': inverse hyperbolic cosine function
-
-`asinq': arc sine function
-
-`asinhq': inverse hyperbolic sine function
-
-`atanq': arc tangent function
-
-`atanhq': inverse hyperbolic tangent function
-
-`atan2q': arc tangent function
-
-`cbrtq': cube root function
-
-`ceilq': ceiling value function
-
-`copysignq': copy sign of a number
-
-`coshq': hyperbolic cosine function
-
-`cosq': cosine function
-
-`erfq': error function
-
-`erfcq': complementary error function
-
-`expq': exponential function
-
-`expm1q': exponential minus 1 function
-
-`fabsq': absolute value function
-
-`fdimq': positive difference function
-
-`finiteq': check finiteness of value
-
-`floorq': floor value function
-
-`fmaq': fused multiply and add
-
-`fmaxq': determine maximum of two values
-
-`fminq': determine minimum of two values
-
-`fmodq': remainder value function
-
-`frexpq': extract mantissa and exponent
-
-`hypotq': Eucledian distance function
-
-`ilogbq': get exponent of the value
-
-`isinfq': check for infinity
-
-`isnanq': check for not a number
-
-`j0q': Bessel function of the first kind, first order
-
-`j1q': Bessel function of the first kind, second order
-
-`jnq': Bessel function of the first kind, N-th order
-
-`ldexpq': load exponent of the value
-
-`lgammaq': logarithmic gamma function
-
-`llrintq': round to nearest integer value
-
-`llroundq': round to nearest integer value away from zero
-
-`logq': natural logarithm function
-
-`log10q': base 10 logarithm function
-
-`log1pq': compute natural logarithm of the value plus one
-
-`log2q': base 2 logarithm function
-
-`lrintq': round to nearest integer value
-
-`lroundq': round to nearest integer value away from zero
-
-`modfq': decompose the floating-point number
-
-`nanq': return quiet NaN
-
-`nearbyintq': round to nearest integer
-
-`nextafterq': next representable floating-point number
-
-`powq': power function
-
-`remainderq': remainder function
-
-`remquoq': remainder and part of quotient
-
-`rintq': round-to-nearest integral value
-
-`roundq': round-to-nearest integral value, return `__float128'
-
-`scalblnq': compute exponent using `FLT_RADIX'
-
-`scalbnq': compute exponent using `FLT_RADIX'
-
-`signbitq': return sign bit
-
-`sincosq': calculate sine and cosine simultaneously
-
-`sinhq': hyperbolic sine function
-
-`sinq': sine function
-
-`sqrtq': square root function
-
-`tanq': tangent function
-
-`tanhq': hyperbolic tangent function
-
-`tgammaq': true gamma function
-
-`truncq': round to integer, towards zero
-
-`y0q': Bessel function of the second kind, first order
-
-`y1q': Bessel function of the second kind, second order
-
-`ynq': Bessel function of the second kind, N-th order
-
-`cabsq' complex absolute value function
-
-`cargq': calculate the argument
-
-`cimagq' imaginary part of complex number
-
-`crealq': real part of complex number
-
-`cacoshq': complex arc hyperbolic cosine function
-
-`cacosq': complex arc cosine function
-
-`casinhq': complex arc hyperbolic sine function
-
-`casinq': complex arc sine function
-
-`catanhq': complex arc hyperbolic tangent function
-
-`catanq': complex arc tangent function
-
-`ccosq' complex cosine function:
-
-`ccoshq': complex hyperbolic cosine function
-
-`cexpq': complex exponential function
-
-`cexpiq': computes the exponential function of "i" times a
-     real value
-
-`clogq': complex natural logarithm
-
-`clog10q': complex base 10 logarithm
-
-`conjq': complex conjugate function
-
-`cpowq': complex power function
-
-`cprojq': project into Riemann Sphere
-
-`csinq': complex sine function
-
-`csinhq': complex hyperbolic sine function
-
-`csqrtq': complex square root
-
-`ctanq': complex tangent function
-
-`ctanhq': complex hyperbolic tangent function
-
-
-File: libquadmath.info,  Node: I/O Library Routines,  Next: GNU Free Documentation License,  Prev: Math Library Routines,  Up: Top
-
-3 I/O Library Routines
-**********************
-
-* Menu:
-
-* `strtoflt128':          strtoflt128,          Convert from string
-* `quadmath_snprintf':    quadmath_snprintf,    Convert to string
-
-
-File: libquadmath.info,  Node: strtoflt128,  Next: quadmath_snprintf,  Up: I/O Library Routines
-
-3.1 `strtoflt128' -- Convert from string
-========================================
-
-The function `strtoflt128' converts a string into a `__float128' number.
-
-Syntax
-     `__float128 strtoflt128 (const char *s, char **sp)'
-
-_Arguments_:
-     S          input string
-     SP         the address of the next character in the string
-
-     The argument SP contains, if not `NULL', the address of the next
-     character following the parts of the string, which have been read.
-
-Example
-          #include <quadmath.h>
-
-          int main ()
-          {
-            __float128 r;
-
-            r = strtoflt128 ("1.2345678", NULL);
-
-            return 0;
-          }
-
-
-File: libquadmath.info,  Node: quadmath_snprintf,  Prev: strtoflt128,  Up: I/O Library Routines
-
-3.2 `quadmath_snprintf' -- Convert to string
-============================================
-
-The function `quadmath_snprintf' converts a `__float128' floating-point
-number into a string.  It is a specialized alternative to `snprintf',
-where the format string is restricted to a single conversion specifier
-with `Q' modifier and conversion specifier `e', `E', `f', `F', `g',
-`G', `a' or `A', with no extra characters before or after the
-conversion specifier.  The `%m$' or `*m$' style must not be used in the
-format.
-
-Syntax
-     `int quadmath_snprintf (char *s, size_t size, const char *format,
-     ...)'
-
-_Arguments_:
-     S          output string
-     SIZE       byte size of the string, including tailing NUL
-     FORMAT     conversion specifier string
-
-Note
-     On some targets when supported by the C library hooks are installed
-     for `printf' family of functions, so that `printf ("%Qe", 1.2Q);'
-     etc. works too.
-
-Example
-          #include <quadmath.h>
-          #include <stdlib.h>
-          #include <stdio.h>
-
-          int main ()
-          {
-            __float128 r;
-            int prec = 20;
-            int width = 46;
-            char buf[128];
-
-            r = 2.0q;
-            r = sqrtq (r);
-            int n = quadmath_snprintf (buf, sizeof buf, "%+-#*.20Qe", width, r);
-            if ((size_t) n < sizeof buf)
-              printf ("%s\n", buf);
-              /* Prints: +1.41421356237309504880e+00 */
-            quadmath_snprintf (buf, sizeof buf, "%Qa", r);
-            if ((size_t) n < sizeof buf)
-              printf ("%s\n", buf);
-              /* Prints: 0x1.6a09e667f3bcc908b2fb1366ea96p+0 */
-            n = quadmath_snprintf (NULL, 0, "%+-#46.*Qe", prec, r);
-            if (n > -1)
-              {
-                char *str = malloc (n + 1);
-                if (str)
-                  {
-                    quadmath_snprintf (str, n + 1, "%+-#46.*Qe", prec, r);
-                    printf ("%s\n", str);
-                    /* Prints: +1.41421356237309504880e+00 */
-                  }
-                free (str);
-              }
-            return 0;
-          }
-
-
-
-File: libquadmath.info,  Node: GNU Free Documentation License,  Next: Reporting Bugs,  Prev: I/O Library Routines,  Up: Top
-
-GNU Free Documentation License
-******************************
-
-                     Version 1.3, 3 November 2008
-
-     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
-     `http://fsf.org/'
-
-     Everyone is permitted to copy and distribute verbatim copies
-     of this license document, but changing it is not allowed.
-
-  0. PREAMBLE
-
-     The purpose of this License is to make a manual, textbook, or other
-     functional and useful document "free" in the sense of freedom: to
-     assure everyone the effective freedom to copy and redistribute it,
-     with or without modifying it, either commercially or
-     noncommercially.  Secondarily, this License preserves for the
-     author and publisher a way to get credit for their work, while not
-     being considered responsible for modifications made by others.
-
-     This License is a kind of "copyleft", which means that derivative
-     works of the document must themselves be free in the same sense.
-     It complements the GNU General Public License, which is a copyleft
-     license designed for free software.
-
-     We have designed this License in order to use it for manuals for
-     free software, because free software needs free documentation: a
-     free program should come with manuals providing the same freedoms
-     that the software does.  But this License is not limited to
-     software manuals; it can be used for any textual work, regardless
-     of subject matter or whether it is published as a printed book.
-     We recommend this License principally for works whose purpose is
-     instruction or reference.
-
-  1. APPLICABILITY AND DEFINITIONS
-
-     This License applies to any manual or other work, in any medium,
-     that contains a notice placed by the copyright holder saying it
-     can be distributed under the terms of this License.  Such a notice
-     grants a world-wide, royalty-free license, unlimited in duration,
-     to use that work under the conditions stated herein.  The
-     "Document", below, refers to any such manual or work.  Any member
-     of the public is a licensee, and is addressed as "you".  You
-     accept the license if you copy, modify or distribute the work in a
-     way requiring permission under copyright law.
-
-     A "Modified Version" of the Document means any work containing the
-     Document or a portion of it, either copied verbatim, or with
-     modifications and/or translated into another language.
-
-     A "Secondary Section" is a named appendix or a front-matter section
-     of the Document that deals exclusively with the relationship of the
-     publishers or authors of the Document to the Document's overall
-     subject (or to related matters) and contains nothing that could
-     fall directly within that overall subject.  (Thus, if the Document
-     is in part a textbook of mathematics, a Secondary Section may not
-     explain any mathematics.)  The relationship could be a matter of
-     historical connection with the subject or with related matters, or
-     of legal, commercial, philosophical, ethical or political position
-     regarding them.
-
-     The "Invariant Sections" are certain Secondary Sections whose
-     titles are designated, as being those of Invariant Sections, in
-     the notice that says that the Document is released under this
-     License.  If a section does not fit the above definition of
-     Secondary then it is not allowed to be designated as Invariant.
-     The Document may contain zero Invariant Sections.  If the Document
-     does not identify any Invariant Sections then there are none.
-
-     The "Cover Texts" are certain short passages of text that are
-     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
-     that says that the Document is released under this License.  A
-     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
-     be at most 25 words.
-
-     A "Transparent" copy of the Document means a machine-readable copy,
-     represented in a format whose specification is available to the
-     general public, that is suitable for revising the document
-     straightforwardly with generic text editors or (for images
-     composed of pixels) generic paint programs or (for drawings) some
-     widely available drawing editor, and that is suitable for input to
-     text formatters or for automatic translation to a variety of
-     formats suitable for input to text formatters.  A copy made in an
-     otherwise Transparent file format whose markup, or absence of
-     markup, has been arranged to thwart or discourage subsequent
-     modification by readers is not Transparent.  An image format is
-     not Transparent if used for any substantial amount of text.  A
-     copy that is not "Transparent" is called "Opaque".
-
-     Examples of suitable formats for Transparent copies include plain
-     ASCII without markup, Texinfo input format, LaTeX input format,
-     SGML or XML using a publicly available DTD, and
-     standard-conforming simple HTML, PostScript or PDF designed for
-     human modification.  Examples of transparent image formats include
-     PNG, XCF and JPG.  Opaque formats include proprietary formats that
-     can be read and edited only by proprietary word processors, SGML or
-     XML for which the DTD and/or processing tools are not generally
-     available, and the machine-generated HTML, PostScript or PDF
-     produced by some word processors for output purposes only.
-
-     The "Title Page" means, for a printed book, the title page itself,
-     plus such following pages as are needed to hold, legibly, the
-     material this License requires to appear in the title page.  For
-     works in formats which do not have any title page as such, "Title
-     Page" means the text near the most prominent appearance of the
-     work's title, preceding the beginning of the body of the text.
-
-     The "publisher" means any person or entity that distributes copies
-     of the Document to the public.
-
-     A section "Entitled XYZ" means a named subunit of the Document
-     whose title either is precisely XYZ or contains XYZ in parentheses
-     following text that translates XYZ in another language.  (Here XYZ
-     stands for a specific section name mentioned below, such as
-     "Acknowledgements", "Dedications", "Endorsements", or "History".)
-     To "Preserve the Title" of such a section when you modify the
-     Document means that it remains a section "Entitled XYZ" according
-     to this definition.
-
-     The Document may include Warranty Disclaimers next to the notice
-     which states that this License applies to the Document.  These
-     Warranty Disclaimers are considered to be included by reference in
-     this License, but only as regards disclaiming warranties: any other
-     implication that these Warranty Disclaimers may have is void and
-     has no effect on the meaning of this License.
-
-  2. VERBATIM COPYING
-
-     You may copy and distribute the Document in any medium, either
-     commercially or noncommercially, provided that this License, the
-     copyright notices, and the license notice saying this License
-     applies to the Document are reproduced in all copies, and that you
-     add no other conditions whatsoever to those of this License.  You
-     may not use technical measures to obstruct or control the reading
-     or further copying of the copies you make or distribute.  However,
-     you may accept compensation in exchange for copies.  If you
-     distribute a large enough number of copies you must also follow
-     the conditions in section 3.
-
-     You may also lend copies, under the same conditions stated above,
-     and you may publicly display copies.
-
-  3. COPYING IN QUANTITY
-
-     If you publish printed copies (or copies in media that commonly
-     have printed covers) of the Document, numbering more than 100, and
-     the Document's license notice requires Cover Texts, you must
-     enclose the copies in covers that carry, clearly and legibly, all
-     these Cover Texts: Front-Cover Texts on the front cover, and
-     Back-Cover Texts on the back cover.  Both covers must also clearly
-     and legibly identify you as the publisher of these copies.  The
-     front cover must present the full title with all words of the
-     title equally prominent and visible.  You may add other material
-     on the covers in addition.  Copying with changes limited to the
-     covers, as long as they preserve the title of the Document and
-     satisfy these conditions, can be treated as verbatim copying in
-     other respects.
-
-     If the required texts for either cover are too voluminous to fit
-     legibly, you should put the first ones listed (as many as fit
-     reasonably) on the actual cover, and continue the rest onto
-     adjacent pages.
-
-     If you publish or distribute Opaque copies of the Document
-     numbering more than 100, you must either include a
-     machine-readable Transparent copy along with each Opaque copy, or
-     state in or with each Opaque copy a computer-network location from
-     which the general network-using public has access to download
-     using public-standard network protocols a complete Transparent
-     copy of the Document, free of added material.  If you use the
-     latter option, you must take reasonably prudent steps, when you
-     begin distribution of Opaque copies in quantity, to ensure that
-     this Transparent copy will remain thus accessible at the stated
-     location until at least one year after the last time you
-     distribute an Opaque copy (directly or through your agents or
-     retailers) of that edition to the public.
-
-     It is requested, but not required, that you contact the authors of
-     the Document well before redistributing any large number of
-     copies, to give them a chance to provide you with an updated
-     version of the Document.
-
-  4. MODIFICATIONS
-
-     You may copy and distribute a Modified Version of the Document
-     under the conditions of sections 2 and 3 above, provided that you
-     release the Modified Version under precisely this License, with
-     the Modified Version filling the role of the Document, thus
-     licensing distribution and modification of the Modified Version to
-     whoever possesses a copy of it.  In addition, you must do these
-     things in the Modified Version:
-
-       A. Use in the Title Page (and on the covers, if any) a title
-          distinct from that of the Document, and from those of
-          previous versions (which should, if there were any, be listed
-          in the History section of the Document).  You may use the
-          same title as a previous version if the original publisher of
-          that version gives permission.
-
-       B. List on the Title Page, as authors, one or more persons or
-          entities responsible for authorship of the modifications in
-          the Modified Version, together with at least five of the
-          principal authors of the Document (all of its principal
-          authors, if it has fewer than five), unless they release you
-          from this requirement.
-
-       C. State on the Title page the name of the publisher of the
-          Modified Version, as the publisher.
-
-       D. Preserve all the copyright notices of the Document.
-
-       E. Add an appropriate copyright notice for your modifications
-          adjacent to the other copyright notices.
-
-       F. Include, immediately after the copyright notices, a license
-          notice giving the public permission to use the Modified
-          Version under the terms of this License, in the form shown in
-          the Addendum below.
-
-       G. Preserve in that license notice the full lists of Invariant
-          Sections and required Cover Texts given in the Document's
-          license notice.
-
-       H. Include an unaltered copy of this License.
-
-       I. Preserve the section Entitled "History", Preserve its Title,
-          and add to it an item stating at least the title, year, new
-          authors, and publisher of the Modified Version as given on
-          the Title Page.  If there is no section Entitled "History" in
-          the Document, create one stating the title, year, authors,
-          and publisher of the Document as given on its Title Page,
-          then add an item describing the Modified Version as stated in
-          the previous sentence.
-
-       J. Preserve the network location, if any, given in the Document
-          for public access to a Transparent copy of the Document, and
-          likewise the network locations given in the Document for
-          previous versions it was based on.  These may be placed in
-          the "History" section.  You may omit a network location for a
-          work that was published at least four years before the
-          Document itself, or if the original publisher of the version
-          it refers to gives permission.
-
-       K. For any section Entitled "Acknowledgements" or "Dedications",
-          Preserve the Title of the section, and preserve in the
-          section all the substance and tone of each of the contributor
-          acknowledgements and/or dedications given therein.
-
-       L. Preserve all the Invariant Sections of the Document,
-          unaltered in their text and in their titles.  Section numbers
-          or the equivalent are not considered part of the section
-          titles.
-
-       M. Delete any section Entitled "Endorsements".  Such a section
-          may not be included in the Modified Version.
-
-       N. Do not retitle any existing section to be Entitled
-          "Endorsements" or to conflict in title with any Invariant
-          Section.
-
-       O. Preserve any Warranty Disclaimers.
-
-     If the Modified Version includes new front-matter sections or
-     appendices that qualify as Secondary Sections and contain no
-     material copied from the Document, you may at your option
-     designate some or all of these sections as invariant.  To do this,
-     add their titles to the list of Invariant Sections in the Modified
-     Version's license notice.  These titles must be distinct from any
-     other section titles.
-
-     You may add a section Entitled "Endorsements", provided it contains
-     nothing but endorsements of your Modified Version by various
-     parties--for example, statements of peer review or that the text
-     has been approved by an organization as the authoritative
-     definition of a standard.
-
-     You may add a passage of up to five words as a Front-Cover Text,
-     and a passage of up to 25 words as a Back-Cover Text, to the end
-     of the list of Cover Texts in the Modified Version.  Only one
-     passage of Front-Cover Text and one of Back-Cover Text may be
-     added by (or through arrangements made by) any one entity.  If the
-     Document already includes a cover text for the same cover,
-     previously added by you or by arrangement made by the same entity
-     you are acting on behalf of, you may not add another; but you may
-     replace the old one, on explicit permission from the previous
-     publisher that added the old one.
-
-     The author(s) and publisher(s) of the Document do not by this
-     License give permission to use their names for publicity for or to
-     assert or imply endorsement of any Modified Version.
-
-  5. COMBINING DOCUMENTS
-
-     You may combine the Document with other documents released under
-     this License, under the terms defined in section 4 above for
-     modified versions, provided that you include in the combination
-     all of the Invariant Sections of all of the original documents,
-     unmodified, and list them all as Invariant Sections of your
-     combined work in its license notice, and that you preserve all
-     their Warranty Disclaimers.
-
-     The combined work need only contain one copy of this License, and
-     multiple identical Invariant Sections may be replaced with a single
-     copy.  If there are multiple Invariant Sections with the same name
-     but different contents, make the title of each such section unique
-     by adding at the end of it, in parentheses, the name of the
-     original author or publisher of that section if known, or else a
-     unique number.  Make the same adjustment to the section titles in
-     the list of Invariant Sections in the license notice of the
-     combined work.
-
-     In the combination, you must combine any sections Entitled
-     "History" in the various original documents, forming one section
-     Entitled "History"; likewise combine any sections Entitled
-     "Acknowledgements", and any sections Entitled "Dedications".  You
-     must delete all sections Entitled "Endorsements."
-
-  6. COLLECTIONS OF DOCUMENTS
-
-     You may make a collection consisting of the Document and other
-     documents released under this License, and replace the individual
-     copies of this License in the various documents with a single copy
-     that is included in the collection, provided that you follow the
-     rules of this License for verbatim copying of each of the
-     documents in all other respects.
-
-     You may extract a single document from such a collection, and
-     distribute it individually under this License, provided you insert
-     a copy of this License into the extracted document, and follow
-     this License in all other respects regarding verbatim copying of
-     that document.
-
-  7. AGGREGATION WITH INDEPENDENT WORKS
-
-     A compilation of the Document or its derivatives with other
-     separate and independent documents or works, in or on a volume of
-     a storage or distribution medium, is called an "aggregate" if the
-     copyright resulting from the compilation is not used to limit the
-     legal rights of the compilation's users beyond what the individual
-     works permit.  When the Document is included in an aggregate, this
-     License does not apply to the other works in the aggregate which
-     are not themselves derivative works of the Document.
-
-     If the Cover Text requirement of section 3 is applicable to these
-     copies of the Document, then if the Document is less than one half
-     of the entire aggregate, the Document's Cover Texts may be placed
-     on covers that bracket the Document within the aggregate, or the
-     electronic equivalent of covers if the Document is in electronic
-     form.  Otherwise they must appear on printed covers that bracket
-     the whole aggregate.
-
-  8. TRANSLATION
-
-     Translation is considered a kind of modification, so you may
-     distribute translations of the Document under the terms of section
-     4.  Replacing Invariant Sections with translations requires special
-     permission from their copyright holders, but you may include
-     translations of some or all Invariant Sections in addition to the
-     original versions of these Invariant Sections.  You may include a
-     translation of this License, and all the license notices in the
-     Document, and any Warranty Disclaimers, provided that you also
-     include the original English version of this License and the
-     original versions of those notices and disclaimers.  In case of a
-     disagreement between the translation and the original version of
-     this License or a notice or disclaimer, the original version will
-     prevail.
-
-     If a section in the Document is Entitled "Acknowledgements",
-     "Dedications", or "History", the requirement (section 4) to
-     Preserve its Title (section 1) will typically require changing the
-     actual title.
-
-  9. TERMINATION
-
-     You may not copy, modify, sublicense, or distribute the Document
-     except as expressly provided under this License.  Any attempt
-     otherwise to copy, modify, sublicense, or distribute it is void,
-     and will automatically terminate your rights under this License.
-
-     However, if you cease all violation of this License, then your
-     license from a particular copyright holder is reinstated (a)
-     provisionally, unless and until the copyright holder explicitly
-     and finally terminates your license, and (b) permanently, if the
-     copyright holder fails to notify you of the violation by some
-     reasonable means prior to 60 days after the cessation.
-
-     Moreover, your license from a particular copyright holder is
-     reinstated permanently if the copyright holder notifies you of the
-     violation by some reasonable means, this is the first time you have
-     received notice of violation of this License (for any work) from
-     that copyright holder, and you cure the violation prior to 30 days
-     after your receipt of the notice.
-
-     Termination of your rights under this section does not terminate
-     the licenses of parties who have received copies or rights from
-     you under this License.  If your rights have been terminated and
-     not permanently reinstated, receipt of a copy of some or all of
-     the same material does not give you any rights to use it.
-
- 10. FUTURE REVISIONS OF THIS LICENSE
-
-     The Free Software Foundation may publish new, revised versions of
-     the GNU Free Documentation License from time to time.  Such new
-     versions will be similar in spirit to the present version, but may
-     differ in detail to address new problems or concerns.  See
-     `http://www.gnu.org/copyleft/'.
-
-     Each version of the License is given a distinguishing version
-     number.  If the Document specifies that a particular numbered
-     version of this License "or any later version" applies to it, you
-     have the option of following the terms and conditions either of
-     that specified version or of any later version that has been
-     published (not as a draft) by the Free Software Foundation.  If
-     the Document does not specify a version number of this License,
-     you may choose any version ever published (not as a draft) by the
-     Free Software Foundation.  If the Document specifies that a proxy
-     can decide which future versions of this License can be used, that
-     proxy's public statement of acceptance of a version permanently
-     authorizes you to choose that version for the Document.
-
- 11. RELICENSING
-
-     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
-     World Wide Web server that publishes copyrightable works and also
-     provides prominent facilities for anybody to edit those works.  A
-     public wiki that anybody can edit is an example of such a server.
-     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
-     site means any set of copyrightable works thus published on the MMC
-     site.
-
-     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
-     license published by Creative Commons Corporation, a not-for-profit
-     corporation with a principal place of business in San Francisco,
-     California, as well as future copyleft versions of that license
-     published by that same organization.
-
-     "Incorporate" means to publish or republish a Document, in whole or
-     in part, as part of another Document.
-
-     An MMC is "eligible for relicensing" if it is licensed under this
-     License, and if all works that were first published under this
-     License somewhere other than this MMC, and subsequently
-     incorporated in whole or in part into the MMC, (1) had no cover
-     texts or invariant sections, and (2) were thus incorporated prior
-     to November 1, 2008.
-
-     The operator of an MMC Site may republish an MMC contained in the
-     site under CC-BY-SA on the same site at any time before August 1,
-     2009, provided the MMC is eligible for relicensing.
-
-
-ADDENDUM: How to use this License for your documents
-====================================================
-
-To use this License in a document you have written, include a copy of
-the License in the document and put the following copyright and license
-notices just after the title page:
-
-       Copyright (C)  YEAR  YOUR NAME.
-       Permission is granted to copy, distribute and/or modify this document
-       under the terms of the GNU Free Documentation License, Version 1.3
-       or any later version published by the Free Software Foundation;
-       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
-       Texts.  A copy of the license is included in the section entitled ``GNU
-       Free Documentation License''.
-
-   If you have Invariant Sections, Front-Cover Texts and Back-Cover
-Texts, replace the "with...Texts." line with this:
-
-         with the Invariant Sections being LIST THEIR TITLES, with
-         the Front-Cover Texts being LIST, and with the Back-Cover Texts
-         being LIST.
-
-   If you have Invariant Sections without Cover Texts, or some other
-combination of the three, merge those two alternatives to suit the
-situation.
-
-   If your document contains nontrivial examples of program code, we
-recommend releasing these examples in parallel under your choice of
-free software license, such as the GNU General Public License, to
-permit their use in free software.
-
-
-File: libquadmath.info,  Node: Reporting Bugs,  Prev: GNU Free Documentation License,  Up: Top
-
-4 Reporting Bugs
-****************
-
-Bugs in the GCC Quad-Precision Math Library implementation should be
-reported via `http://gcc.gnu.org/bugs.html'.
-
-
-
-Tag Table:
-Node: Top1684
-Node: Typedef and constants2418
-Node: Math Library Routines3858
-Node: I/O Library Routines7662
-Node: strtoflt1287987
-Node: quadmath_snprintf8745
-Node: GNU Free Documentation License10953
-Node: Reporting Bugs36119
-
-End Tag Table
diff -Naur gcc-5.2.0.orig/libsanitizer/ubsan/ubsan_type_hash.cc gcc-5.2.0/libsanitizer/ubsan/ubsan_type_hash.cc
--- gcc-5.2.0.orig/libsanitizer/ubsan/ubsan_type_hash.cc	2015-01-20 14:39:52.000000000 -0600
+++ gcc-5.2.0/libsanitizer/ubsan/ubsan_type_hash.cc	2015-09-09 11:39:32.787194000 -0500
@@ -186,8 +186,8 @@
 
 struct VtablePrefix {
   /// The offset from the vptr to the start of the most-derived object.
-  /// This should never be greater than zero, and will usually be exactly
-  /// zero.
+  /// This will only be greater than zero in some virtual base class vtables
+  /// used during object con-/destruction, and will usually be exactly zero.
   sptr Offset;
   /// The type_info object describing the most-derived class type.
   std::type_info *TypeInfo;
@@ -197,7 +197,7 @@
   if (!*VptrPtr)
     return 0;
   VtablePrefix *Prefix = *VptrPtr - 1;
-  if (Prefix->Offset > 0 || !Prefix->TypeInfo)
+  if (!Prefix->TypeInfo)
     // This can't possibly be a valid vtable.
     return 0;
   return Prefix;
diff -Naur gcc-5.2.0.orig/libstdc++-v3/acinclude.m4 gcc-5.2.0/libstdc++-v3/acinclude.m4
--- gcc-5.2.0.orig/libstdc++-v3/acinclude.m4	2015-07-02 17:54:50.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/acinclude.m4	2015-10-07 16:00:50.975754000 -0500
@@ -49,7 +49,7 @@
   # Keep these sync'd with the list in Makefile.am.  The first provides an
   # expandable list at autoconf time; the second provides an expandable list
   # (i.e., shell variable) at configure time.
-  m4_define([glibcxx_SUBDIRS],[include libsupc++ python src src/c++98 src/c++11 doc po testsuite])
+  m4_define([glibcxx_SUBDIRS],[include libsupc++ src src/c++98 src/c++11 src/filesystem doc po testsuite python])
   SUBDIRS='glibcxx_SUBDIRS'
 
   # These need to be absolute paths, yet at the same time need to
@@ -3905,6 +3905,178 @@
   GLIBCXX_CONDITIONAL(ENABLE_CXX11_ABI, test $glibcxx_cxx11_abi = 1)
 ])
 
+dnl
+dnl Check to see whether to build libstdc++fs.a
+dnl
+dnl --enable-libstdcxx-filesystem-ts
+dnl
+AC_DEFUN([GLIBCXX_ENABLE_FILESYSTEM_TS], [
+  GLIBCXX_ENABLE(libstdcxx-filesystem-ts,auto,,
+    [turns on ISO/IEC TS 18822 support],
+    [permit yes|no|auto])
+
+  AC_MSG_CHECKING([whether to build Filesystem TS support])
+  if test x"$ac_cv_header_dirent_h" != x"yes"; then
+    enable_libstdcxx_filesystem_ts=no
+  fi
+  if test x"$enable_libstdcxx_filesystem_ts" = x"auto"; then
+    case "${target_os}" in
+      freebsd*|netbsd*|openbsd*|dragonfly*|darwin*)
+        enable_libstdcxx_filesystem_ts=yes
+        ;;
+      gnu* | linux* | kfreebsd*-gnu | knetbsd*-gnu)
+        enable_libstdcxx_filesystem_ts=yes
+        ;;
+      solaris*)
+        enable_libstdcxx_filesystem_ts=yes
+        ;;
+      *)
+        enable_libstdcxx_filesystem_ts=no
+        ;;
+    esac
+  fi
+  AC_MSG_RESULT($enable_libstdcxx_filesystem_ts)
+  GLIBCXX_CONDITIONAL(ENABLE_FILESYSTEM_TS, test $enable_libstdcxx_filesystem_ts = yes)
+])
+
+dnl
+dnl Check whether the library calls required by the Filesystem TS are present
+dnl and define _GLIBCXX_USE_REALPATH and _GLIBCXX_USE_UTIMENSAT.
+dnl
+AC_DEFUN([GLIBCXX_CHECK_FILESYSTEM_DEPS], [dnl
+dnl
+  AC_LANG_SAVE
+  AC_LANG_CPLUSPLUS
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -fno-exceptions"
+dnl
+  AC_MSG_CHECKING([for struct dirent.d_type])
+  AC_CACHE_VAL(glibcxx_cv_dirent_d_type, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <dirent.h>],
+      [
+       struct dirent d;
+       if (sizeof d.d_type) return 0;
+      ],
+      [glibcxx_cv_dirent_d_type=yes],
+      [glibcxx_cv_dirent_d_type=no])
+  ])
+  if test $glibcxx_cv_dirent_d_type = yes; then
+    AC_DEFINE(HAVE_STRUCT_DIRENT_D_TYPE, 1, [Define to 1 if `d_type' is a member of `struct dirent'.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_dirent_d_type)
+dnl
+  AC_MSG_CHECKING([for realpath])
+  AC_CACHE_VAL(glibcxx_cv_realpath, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [
+       #include <stdlib.h>
+       #include <unistd.h>
+      ],
+      [
+       #if _XOPEN_VERSION < 500
+       #error
+       #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
+       char *tmp = realpath((const char*)NULL, (char*)NULL);
+       #else
+       #error
+       #endif
+      ],
+      [glibcxx_cv_realpath=yes],
+      [glibcxx_cv_realpath=no])
+  ])
+  if test $glibcxx_cv_realpath = yes; then
+    AC_DEFINE(_GLIBCXX_USE_REALPATH, 1, [Define if usable realpath is available in <stdlib.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_realpath)
+dnl
+  AC_MSG_CHECKING([for utimensat])
+  AC_CACHE_VAL(glibcxx_cv_utimensat, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [
+        #include <fcntl.h>
+        #include <sys/stat.h>
+      ],
+      [
+        struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
+        int i = utimensat(AT_FDCWD, "path", ts, 0);
+      ],
+      [glibcxx_cv_utimensat=yes],
+      [glibcxx_cv_utimensat=no])
+  ])
+  if test $glibcxx_cv_utimensat = yes; then
+    AC_DEFINE(_GLIBCXX_USE_UTIMENSAT, 1, [Define if utimensat and UTIME_OMIT are available in <sys/stat.h> and AT_FDCWD in <fcntl.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_utimensat)
+dnl
+  AC_MSG_CHECKING([for struct stat.st_mtim.tv_nsec])
+  AC_CACHE_VAL(glibcxx_cv_st_mtim, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [ #include <sys/stat.h> ],
+      [
+        struct stat st;
+        return st.st_mtim.tv_nsec;
+      ],
+      [glibcxx_cv_st_mtim=yes],
+      [glibcxx_cv_st_mtim=no])
+  ])
+  if test $glibcxx_cv_st_mtim = yes; then
+    AC_DEFINE(_GLIBCXX_USE_ST_MTIM, 1, [Define if struct stat has timespec members.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_st_mtim)
+dnl
+  AC_MSG_CHECKING([for fchmod])
+  AC_CACHE_VAL(glibcxx_cv_fchmod, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <sys/stat.h>],
+      [fchmod(1, S_IWUSR);],
+      [glibcxx_cv_fchmod=yes],
+      [glibcxx_cv_fchmod=no])
+  ])
+  if test $glibcxx_cv_fchmod = yes; then
+    AC_DEFINE(_GLIBCXX_USE_FCHMOD, 1, [Define if fchmod is available in <sys/stat.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_fchmod)
+dnl
+  AC_MSG_CHECKING([for fchmodat])
+  AC_CACHE_VAL(glibcxx_cv_fchmodat, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [
+        #include <fcntl.h>
+        #include <sys/stat.h>
+      ],
+      [fchmodat(AT_FDCWD, "", 0, AT_SYMLINK_NOFOLLOW);],
+      [glibcxx_cv_fchmodat=yes],
+      [glibcxx_cv_fchmodat=no])
+  ])
+  if test $glibcxx_cv_fchmodat = yes; then
+    AC_DEFINE(_GLIBCXX_USE_FCHMODAT, 1, [Define if fchmodat is available in <sys/stat.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_fchmodat)
+dnl
+  AC_MSG_CHECKING([for sendfile that can copy files])
+  AC_CACHE_VAL(glibcxx_cv_sendfile, [dnl
+    case "${target_os}" in
+      gnu* | linux* | solaris*)
+        GCC_TRY_COMPILE_OR_LINK(
+          [#include <sys/sendfile.h>],
+          [sendfile(1, 2, (off_t*)NULL, sizeof 1);],
+          [glibcxx_cv_sendfile=yes],
+          [glibcxx_cv_sendfile=no])
+        ;;
+      *)
+        glibcxx_cv_sendfile=no
+        ;;
+    esac
+  ])
+  if test $glibcxx_cv_sendfile = yes; then
+    AC_DEFINE(_GLIBCXX_USE_SENDFILE, 1, [Define if sendfile is available in <sys/stat.h>.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_sendfile)
+dnl
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  AC_LANG_RESTORE
+])
 
 # Macros from the top-level gcc directory.
 m4_include([../config/gc++filt.m4])
diff -Naur gcc-5.2.0.orig/libstdc++-v3/aclocal.m4 gcc-5.2.0/libstdc++-v3/aclocal.m4
--- gcc-5.2.0.orig/libstdc++-v3/aclocal.m4	2012-09-28 14:48:27.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/aclocal.m4	2015-08-18 12:58:06.792617000 -0500
@@ -1,7 +1,8 @@
-# generated automatically by aclocal 1.11.1 -*- Autoconf -*-
+# generated automatically by aclocal 1.11.6 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
+# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,
+# Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -19,12 +20,15 @@
 If you have problems, you may need to regenerate the build system entirely.
 To do so, use the procedure documented by the package, typically `autoreconf'.])])
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software
+# Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
 # Automake X.Y traces this macro to ensure aclocal.m4 has been
@@ -34,7 +38,7 @@
 [am__api_version='1.11'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.1], [],
+m4_if([$1], [1.11.6], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -50,19 +54,21 @@
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.1])dnl
+[AM_AUTOMAKE_VERSION([1.11.6])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
 # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
 # `$srcdir', `$srcdir/..', or `$srcdir/../..'.
@@ -283,12 +289,15 @@
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,
+# Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # AM_PROG_INSTALL_SH
 # ------------------
 # Define $install_sh.
@@ -307,8 +316,8 @@
 # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,
+# 2011 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -328,7 +337,7 @@
        [disable], [m4_define([am_maintainer_other], [enable])],
        [m4_define([am_maintainer_other], [enable])
         m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
-AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])
+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
   dnl maintainer-mode's default is 'disable' unless 'enable' is passed
   AC_ARG_ENABLE([maintainer-mode],
 [  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
@@ -387,12 +396,15 @@
 fi
 ])
 
-# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,
+# Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # AM_PROG_MKDIR_P
 # ---------------
 # Check for `mkdir -p'.
@@ -415,13 +427,14 @@
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software
+# Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 4
+# serial 5
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -429,13 +442,13 @@
 [[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
 
 # _AM_SET_OPTION(NAME)
-# ------------------------------
+# --------------------
 # Set option NAME.  Presently that only means defining a flag for this option.
 AC_DEFUN([_AM_SET_OPTION],
 [m4_define(_AM_MANGLE_OPTION([$1]), 1)])
 
 # _AM_SET_OPTIONS(OPTIONS)
-# ----------------------------------
+# ------------------------
 # OPTIONS is a space-separated list of Automake options.
 AC_DEFUN([_AM_SET_OPTIONS],
 [m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
@@ -511,12 +524,14 @@
 fi
 AC_MSG_RESULT(yes)])
 
-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
+# serial 1
+
 # AM_PROG_INSTALL_STRIP
 # ---------------------
 # One issue with vendor `install' (even GNU) is that you can't
@@ -539,13 +554,13 @@
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # _AM_SUBST_NOTMAKE(VARIABLE)
 # ---------------------------
@@ -554,13 +569,13 @@
 AC_DEFUN([_AM_SUBST_NOTMAKE])
 
 # AM_SUBST_NOTMAKE(VARIABLE)
-# ---------------------------
+# --------------------------
 # Public sister of _AM_SUBST_NOTMAKE.
 AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -582,10 +597,11 @@
 # a tarball read from stdin.
 #     $(am__untar) < result.tar
 AC_DEFUN([_AM_PROG_TAR],
-[# Always define AMTAR for backward compatibility.
-AM_MISSING_PROG([AMTAR], [tar])
+[# Always define AMTAR for backward compatibility.  Yes, it's still used
+# in the wild :-(  We should find a proper way to deprecate it ...
+AC_SUBST([AMTAR], ['$${TAR-tar}'])
 m4_if([$1], [v7],
-     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
      [m4_case([$1], [ustar],, [pax],,
               [m4_fatal([Unknown tar format])])
 AC_MSG_CHECKING([how to create a $1 tar archive])
diff -Naur gcc-5.2.0.orig/libstdc++-v3/config.h.in gcc-5.2.0/libstdc++-v3/config.h.in
--- gcc-5.2.0.orig/libstdc++-v3/config.h.in	2015-03-18 05:53:38.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/config.h.in	2015-10-07 16:00:50.975754000 -0500
@@ -54,6 +54,9 @@
 /* Define to 1 if you have the `cosl' function. */
 #undef HAVE_COSL
 
+/* Define to 1 if you have the <dirent.h> header file. */
+#undef HAVE_DIRENT_H
+
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #undef HAVE_DLFCN_H
 
@@ -132,6 +135,9 @@
 /* Define to 1 if you have the `fabsl' function. */
 #undef HAVE_FABSL
 
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
 /* Define to 1 if you have the <fenv.h> header file. */
 #undef HAVE_FENV_H
 
@@ -372,6 +378,9 @@
 /* Define to 1 if you have the `strtold' function. */
 #undef HAVE_STRTOLD
 
+/* Define to 1 if `d_type' is a member of `struct dirent'. */
+#undef HAVE_STRUCT_DIRENT_D_TYPE
+
 /* Define if strxfrm_l is available in <string.h>. */
 #undef HAVE_STRXFRM_L
 
@@ -406,6 +415,9 @@
 /* Define to 1 if you have the <sys/sem.h> header file. */
 #undef HAVE_SYS_SEM_H
 
+/* Define to 1 if you have the <sys/statvfs.h> header file. */
+#undef HAVE_SYS_STATVFS_H
+
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #undef HAVE_SYS_STAT_H
 
@@ -451,6 +463,9 @@
 /* Defined if usleep exists. */
 #undef HAVE_USLEEP
 
+/* Define to 1 if you have the <utime.h> header file. */
+#undef HAVE_UTIME_H
+
 /* Defined if vfwscanf exists. */
 #undef HAVE_VFWSCANF
 
@@ -824,6 +839,12 @@
    this host. */
 #undef _GLIBCXX_USE_DECIMAL_FLOAT
 
+/* Define if fchmod is available in <sys/stat.h>. */
+#undef _GLIBCXX_USE_FCHMOD
+
+/* Define if fchmodat is available in <sys/stat.h>. */
+#undef _GLIBCXX_USE_FCHMODAT
+
 /* Define if __float128 is supported on this host. */
 #undef _GLIBCXX_USE_FLOAT128
 
@@ -858,6 +879,9 @@
    of TR1 (Chapter 5.1). */
 #undef _GLIBCXX_USE_RANDOM_TR1
 
+/* Define if usable realpath is available in <stdlib.h>. */
+#undef _GLIBCXX_USE_REALPATH
+
 /* Defined if sched_yield is available. */
 #undef _GLIBCXX_USE_SCHED_YIELD
 
@@ -867,12 +891,22 @@
 /* Define if _SC_NPROC_ONLN is available in <unistd.h>. */
 #undef _GLIBCXX_USE_SC_NPROC_ONLN
 
+/* Define if sendfile is available in <sys/stat.h>. */
+#undef _GLIBCXX_USE_SENDFILE
+
+/* Define if struct stat has timespec members. */
+#undef _GLIBCXX_USE_ST_MTIM
+
 /* Define if sysctl(), CTL_HW and HW_NCPU are available in <sys/sysctl.h>. */
 #undef _GLIBCXX_USE_SYSCTL_HW_NCPU
 
 /* Define if obsolescent tmpnam is available in <stdio.h>. */
 #undef _GLIBCXX_USE_TMPNAM
 
+/* Define if utimensat and UTIME_OMIT are available in <sys/stat.h> and
+   AT_FDCWD in <fcntl.h>. */
+#undef _GLIBCXX_USE_UTIMENSAT
+
 /* Define if code specialized for wchar_t should be used. */
 #undef _GLIBCXX_USE_WCHAR_T
 
diff -Naur gcc-5.2.0.orig/libstdc++-v3/configure gcc-5.2.0/libstdc++-v3/configure
--- gcc-5.2.0.orig/libstdc++-v3/configure	2015-07-02 17:54:50.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/configure	2015-10-07 16:00:50.975754000 -0500
@@ -638,6 +638,8 @@
 DOXYGEN
 BUILD_INFO_FALSE
 BUILD_INFO_TRUE
+ENABLE_FILESYSTEM_TS_FALSE
+ENABLE_FILESYSTEM_TS_TRUE
 baseline_subdir_switch
 baseline_dir
 HWCAP_FLAGS
@@ -890,6 +892,7 @@
 enable_libstdcxx_dual_abi
 with_default_libstdcxx_abi
 enable_libstdcxx_threads
+enable_libstdcxx_filesystem_ts
 with_gxx_include_dir
 enable_version_specific_runtime_libs
 '
@@ -1588,6 +1591,8 @@
                           support two versions of std::string [default=yes]
   --enable-libstdcxx-threads
                           enable C++11 threads support [default=auto]
+  --enable-libstdcxx-filesystem-ts
+                          turns on ISO/IEC TS 18822 support [default=auto]
   --enable-version-specific-runtime-libs
                           Specify that runtime libraries should be installed
                           in a compiler-specific directory
@@ -3604,11 +3609,11 @@
 
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
-# Always define AMTAR for backward compatibility.
+# Always define AMTAR for backward compatibility.  Yes, it's still used
+# in the wild :-(  We should find a proper way to deprecate it ...
+AMTAR='$${TAR-tar}'
 
-AMTAR=${AMTAR-"${am_missing_run}tar"}
-
-am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
 
 
 
@@ -4951,7 +4956,7 @@
   # expandable list at autoconf time; the second provides an expandable list
   # (i.e., shell variable) at configure time.
 
-  SUBDIRS='include libsupc++ python src src/c++98 src/c++11 doc po testsuite'
+  SUBDIRS='include libsupc++ src src/c++98 src/c++11 src/filesystem doc po testsuite python'
 
   # These need to be absolute paths, yet at the same time need to
   # canonicalize only relative paths, because then amd will not unmount
@@ -11593,7 +11598,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11596 "configure"
+#line 11601 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11699,7 +11704,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11702 "configure"
+#line 11707 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15119,7 +15124,7 @@
     #
     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.
     cat > conftest.$ac_ext << EOF
-#line 15122 "configure"
+#line 15127 "configure"
 struct S { ~S(); };
 void bar();
 void foo()
@@ -15471,7 +15476,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15474 "configure"
+#line 15479 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15506,7 +15511,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15509 "configure"
+#line 15514 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15541,7 +15546,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15544 "configure"
+#line 15549 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15577,7 +15582,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15580 "configure"
+#line 15585 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15656,7 +15661,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15659 "configure"
+#line 15664 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15698,7 +15703,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15701 "configure"
+#line 15706 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15732,7 +15737,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15735 "configure"
+#line 15740 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -78867,6 +78872,530 @@
 
 
 
+# For Filesystem TS.
+for ac_header in fcntl.h dirent.h sys/statvfs.h utime.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+   # Check whether --enable-libstdcxx-filesystem-ts was given.
+if test "${enable_libstdcxx_filesystem_ts+set}" = set; then :
+  enableval=$enable_libstdcxx_filesystem_ts;
+      case "$enableval" in
+       yes|no|auto) ;;
+       *) as_fn_error "Unknown argument to enable/disable libstdcxx-filesystem-ts" "$LINENO" 5 ;;
+	  	        esac
+
+else
+  enable_libstdcxx_filesystem_ts=auto
+fi
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build Filesystem TS support" >&5
+$as_echo_n "checking whether to build Filesystem TS support... " >&6; }
+  if test x"$ac_cv_header_dirent_h" != x"yes"; then
+    enable_libstdcxx_filesystem_ts=no
+  fi
+  if test x"$enable_libstdcxx_filesystem_ts" = x"auto"; then
+    case "${target_os}" in
+      freebsd*|netbsd*|openbsd*|dragonfly*|darwin*)
+        enable_libstdcxx_filesystem_ts=yes
+        ;;
+      gnu* | linux* | kfreebsd*-gnu | knetbsd*-gnu)
+        enable_libstdcxx_filesystem_ts=yes
+        ;;
+      solaris*)
+        enable_libstdcxx_filesystem_ts=yes
+        ;;
+      *)
+        enable_libstdcxx_filesystem_ts=no
+        ;;
+    esac
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_libstdcxx_filesystem_ts" >&5
+$as_echo "$enable_libstdcxx_filesystem_ts" >&6; }
+
+
+
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+  ac_save_CXXFLAGS="$CXXFLAGS"
+  CXXFLAGS="$CXXFLAGS -fno-exceptions"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct dirent.d_type" >&5
+$as_echo_n "checking for struct dirent.d_type... " >&6; }
+  if test "${glibcxx_cv_dirent_d_type+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <dirent.h>
+int
+main ()
+{
+
+       struct dirent d;
+       if (sizeof d.d_type) return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_dirent_d_type=yes
+else
+  glibcxx_cv_dirent_d_type=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <dirent.h>
+int
+main ()
+{
+
+       struct dirent d;
+       if (sizeof d.d_type) return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_dirent_d_type=yes
+else
+  glibcxx_cv_dirent_d_type=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+
+  if test $glibcxx_cv_dirent_d_type = yes; then
+
+$as_echo "#define HAVE_STRUCT_DIRENT_D_TYPE 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_dirent_d_type" >&5
+$as_echo "$glibcxx_cv_dirent_d_type" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for realpath" >&5
+$as_echo_n "checking for realpath... " >&6; }
+  if test "${glibcxx_cv_realpath+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+       #include <stdlib.h>
+       #include <unistd.h>
+
+int
+main ()
+{
+
+       #if _XOPEN_VERSION < 500
+       #error
+       #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
+       char *tmp = realpath((const char*)NULL, (char*)NULL);
+       #else
+       #error
+       #endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_realpath=yes
+else
+  glibcxx_cv_realpath=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+       #include <stdlib.h>
+       #include <unistd.h>
+
+int
+main ()
+{
+
+       #if _XOPEN_VERSION < 500
+       #error
+       #elif _XOPEN_VERSION >= 700 || defined(PATH_MAX)
+       char *tmp = realpath((const char*)NULL, (char*)NULL);
+       #else
+       #error
+       #endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_realpath=yes
+else
+  glibcxx_cv_realpath=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+
+  if test $glibcxx_cv_realpath = yes; then
+
+$as_echo "#define _GLIBCXX_USE_REALPATH 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_realpath" >&5
+$as_echo "$glibcxx_cv_realpath" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for utimensat" >&5
+$as_echo_n "checking for utimensat... " >&6; }
+  if test "${glibcxx_cv_utimensat+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+        #include <fcntl.h>
+        #include <sys/stat.h>
+
+int
+main ()
+{
+
+        struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
+        int i = utimensat(AT_FDCWD, "path", ts, 0);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_utimensat=yes
+else
+  glibcxx_cv_utimensat=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+        #include <fcntl.h>
+        #include <sys/stat.h>
+
+int
+main ()
+{
+
+        struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };
+        int i = utimensat(AT_FDCWD, "path", ts, 0);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_utimensat=yes
+else
+  glibcxx_cv_utimensat=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+
+  if test $glibcxx_cv_utimensat = yes; then
+
+$as_echo "#define _GLIBCXX_USE_UTIMENSAT 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_utimensat" >&5
+$as_echo "$glibcxx_cv_utimensat" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct stat.st_mtim.tv_nsec" >&5
+$as_echo_n "checking for struct stat.st_mtim.tv_nsec... " >&6; }
+  if test "${glibcxx_cv_st_mtim+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+ #include <sys/stat.h>
+int
+main ()
+{
+
+        struct stat st;
+        return st.st_mtim.tv_nsec;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_st_mtim=yes
+else
+  glibcxx_cv_st_mtim=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+ #include <sys/stat.h>
+int
+main ()
+{
+
+        struct stat st;
+        return st.st_mtim.tv_nsec;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_st_mtim=yes
+else
+  glibcxx_cv_st_mtim=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+
+  if test $glibcxx_cv_st_mtim = yes; then
+
+$as_echo "#define _GLIBCXX_USE_ST_MTIM 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_st_mtim" >&5
+$as_echo "$glibcxx_cv_st_mtim" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fchmod" >&5
+$as_echo_n "checking for fchmod... " >&6; }
+  if test "${glibcxx_cv_fchmod+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/stat.h>
+int
+main ()
+{
+fchmod(1, S_IWUSR);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_fchmod=yes
+else
+  glibcxx_cv_fchmod=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/stat.h>
+int
+main ()
+{
+fchmod(1, S_IWUSR);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_fchmod=yes
+else
+  glibcxx_cv_fchmod=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+
+  if test $glibcxx_cv_fchmod = yes; then
+
+$as_echo "#define _GLIBCXX_USE_FCHMOD 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_fchmod" >&5
+$as_echo "$glibcxx_cv_fchmod" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fchmodat" >&5
+$as_echo_n "checking for fchmodat... " >&6; }
+  if test "${glibcxx_cv_fchmodat+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+        #include <fcntl.h>
+        #include <sys/stat.h>
+
+int
+main ()
+{
+fchmodat(AT_FDCWD, "", 0, AT_SYMLINK_NOFOLLOW);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_fchmodat=yes
+else
+  glibcxx_cv_fchmodat=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+        #include <fcntl.h>
+        #include <sys/stat.h>
+
+int
+main ()
+{
+fchmodat(AT_FDCWD, "", 0, AT_SYMLINK_NOFOLLOW);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_fchmodat=yes
+else
+  glibcxx_cv_fchmodat=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+
+  if test $glibcxx_cv_fchmodat = yes; then
+
+$as_echo "#define _GLIBCXX_USE_FCHMODAT 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_fchmodat" >&5
+$as_echo "$glibcxx_cv_fchmodat" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sendfile that can copy files" >&5
+$as_echo_n "checking for sendfile that can copy files... " >&6; }
+  if test "${glibcxx_cv_sendfile+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      case "${target_os}" in
+      gnu* | linux* | solaris*)
+        if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/sendfile.h>
+int
+main ()
+{
+sendfile(1, 2, (off_t*)NULL, sizeof 1);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_sendfile=yes
+else
+  glibcxx_cv_sendfile=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/sendfile.h>
+int
+main ()
+{
+sendfile(1, 2, (off_t*)NULL, sizeof 1);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_sendfile=yes
+else
+  glibcxx_cv_sendfile=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+        ;;
+      *)
+        glibcxx_cv_sendfile=no
+        ;;
+    esac
+
+fi
+
+  if test $glibcxx_cv_sendfile = yes; then
+
+$as_echo "#define _GLIBCXX_USE_SENDFILE 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_sendfile" >&5
+$as_echo "$glibcxx_cv_sendfile" >&6; }
+  CXXFLAGS="$ac_save_CXXFLAGS"
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
 # Define documentation rules conditionally.
 
 # See if makeinfo has been installed and is modern enough
@@ -79490,6 +80019,15 @@
 fi
 
 
+    if test $enable_libstdcxx_filesystem_ts = yes; then
+  ENABLE_FILESYSTEM_TS_TRUE=
+  ENABLE_FILESYSTEM_TS_FALSE='#'
+else
+  ENABLE_FILESYSTEM_TS_TRUE='#'
+  ENABLE_FILESYSTEM_TS_FALSE=
+fi
+
+
 
 
 cat >confcache <<\_ACEOF
@@ -79715,7 +80253,7 @@
 # append it here.  Only modify Makefiles that have just been created.
 #
 # Also, get rid of this simulated-VPATH thing that automake does.
-ac_config_files="$ac_config_files include/Makefile libsupc++/Makefile python/Makefile src/Makefile src/c++98/Makefile src/c++11/Makefile doc/Makefile po/Makefile testsuite/Makefile"
+ac_config_files="$ac_config_files include/Makefile libsupc++/Makefile src/Makefile src/c++98/Makefile src/c++11/Makefile src/filesystem/Makefile doc/Makefile po/Makefile testsuite/Makefile python/Makefile"
 
 
 ac_config_commands="$ac_config_commands generate-headers"
@@ -79914,6 +80452,10 @@
   as_fn_error "conditional \"GLIBCXX_LDBL_COMPAT\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${ENABLE_FILESYSTEM_TS_TRUE}" && test -z "${ENABLE_FILESYSTEM_TS_FALSE}"; then
+  as_fn_error "conditional \"ENABLE_FILESYSTEM_TS\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${BUILD_INFO_TRUE}" && test -z "${BUILD_INFO_FALSE}"; then
   as_fn_error "conditional \"BUILD_INFO\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -80932,13 +81474,14 @@
     "doc/xsl/customization.xsl") CONFIG_FILES="$CONFIG_FILES doc/xsl/customization.xsl" ;;
     "include/Makefile") CONFIG_FILES="$CONFIG_FILES include/Makefile" ;;
     "libsupc++/Makefile") CONFIG_FILES="$CONFIG_FILES libsupc++/Makefile" ;;
-    "python/Makefile") CONFIG_FILES="$CONFIG_FILES python/Makefile" ;;
     "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
     "src/c++98/Makefile") CONFIG_FILES="$CONFIG_FILES src/c++98/Makefile" ;;
     "src/c++11/Makefile") CONFIG_FILES="$CONFIG_FILES src/c++11/Makefile" ;;
+    "src/filesystem/Makefile") CONFIG_FILES="$CONFIG_FILES src/filesystem/Makefile" ;;
     "doc/Makefile") CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
     "po/Makefile") CONFIG_FILES="$CONFIG_FILES po/Makefile" ;;
     "testsuite/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/Makefile" ;;
+    "python/Makefile") CONFIG_FILES="$CONFIG_FILES python/Makefile" ;;
     "generate-headers") CONFIG_COMMANDS="$CONFIG_COMMANDS generate-headers" ;;
 
   *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
@@ -82738,7 +83281,7 @@
    . ${multi_basedir}/config-ml.in
    { ml_norecursion=; unset ml_norecursion;}
  ;;
-    "python/Makefile":F) cat > vpsed$$ << \_EOF
+    "src/Makefile":F) cat > vpsed$$ << \_EOF
 s!`test -f '$<' || echo '$(srcdir)/'`!!
 _EOF
    sed -f vpsed$$ $ac_file > tmp$$
@@ -82749,7 +83292,7 @@
    . ${multi_basedir}/config-ml.in
    { ml_norecursion=; unset ml_norecursion;}
  ;;
-    "src/Makefile":F) cat > vpsed$$ << \_EOF
+    "src/c++98/Makefile":F) cat > vpsed$$ << \_EOF
 s!`test -f '$<' || echo '$(srcdir)/'`!!
 _EOF
    sed -f vpsed$$ $ac_file > tmp$$
@@ -82760,7 +83303,7 @@
    . ${multi_basedir}/config-ml.in
    { ml_norecursion=; unset ml_norecursion;}
  ;;
-    "src/c++98/Makefile":F) cat > vpsed$$ << \_EOF
+    "src/c++11/Makefile":F) cat > vpsed$$ << \_EOF
 s!`test -f '$<' || echo '$(srcdir)/'`!!
 _EOF
    sed -f vpsed$$ $ac_file > tmp$$
@@ -82771,7 +83314,7 @@
    . ${multi_basedir}/config-ml.in
    { ml_norecursion=; unset ml_norecursion;}
  ;;
-    "src/c++11/Makefile":F) cat > vpsed$$ << \_EOF
+    "src/filesystem/Makefile":F) cat > vpsed$$ << \_EOF
 s!`test -f '$<' || echo '$(srcdir)/'`!!
 _EOF
    sed -f vpsed$$ $ac_file > tmp$$
@@ -82808,6 +83351,17 @@
 s!`test -f '$<' || echo '$(srcdir)/'`!!
 _EOF
    sed -f vpsed$$ $ac_file > tmp$$
+   mv tmp$$ $ac_file
+   rm vpsed$$
+   echo 'MULTISUBDIR =' >> $ac_file
+   ml_norecursion=yes
+   . ${multi_basedir}/config-ml.in
+   { ml_norecursion=; unset ml_norecursion;}
+ ;;
+    "python/Makefile":F) cat > vpsed$$ << \_EOF
+s!`test -f '$<' || echo '$(srcdir)/'`!!
+_EOF
+   sed -f vpsed$$ $ac_file > tmp$$
    mv tmp$$ $ac_file
    rm vpsed$$
    echo 'MULTISUBDIR =' >> $ac_file
diff -Naur gcc-5.2.0.orig/libstdc++-v3/configure.ac gcc-5.2.0/libstdc++-v3/configure.ac
--- gcc-5.2.0.orig/libstdc++-v3/configure.ac	2014-12-19 12:16:39.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/configure.ac	2015-08-18 12:58:22.597022000 -0500
@@ -402,6 +402,11 @@
 # For gthread support.  Depends on GLIBCXX_ENABLE_SYMVERS.
 GLIBCXX_CHECK_GTHREADS
 
+# For Filesystem TS.
+AC_CHECK_HEADERS([fcntl.h dirent.h sys/statvfs.h utime.h])
+GLIBCXX_ENABLE_FILESYSTEM_TS
+GLIBCXX_CHECK_FILESYSTEM_DEPS
+
 # Define documentation rules conditionally.
 
 # See if makeinfo has been installed and is modern enough
diff -Naur gcc-5.2.0.orig/libstdc++-v3/doc/Makefile.in gcc-5.2.0/libstdc++-v3/doc/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/doc/Makefile.in	2014-12-19 12:16:39.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/doc/Makefile.in	2015-08-18 12:58:06.792617000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +15,23 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -67,6 +84,11 @@
 depcomp =
 am__depfiles_maybe =
 SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
 ACLOCAL = @ACLOCAL@
 ALLOCATOR_H = @ALLOCATOR_H@
@@ -604,6 +626,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -639,10 +662,15 @@
 
 installcheck: installcheck-am
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/atomic_base.h gcc-5.2.0/libstdc++-v3/include/bits/atomic_base.h
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/atomic_base.h	2015-04-09 06:15:44.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/include/bits/atomic_base.h	2015-10-08 11:54:23.551701000 -0500
@@ -350,17 +350,17 @@
       bool
       is_lock_free() const noexcept
       {
-	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_i));
-	return __atomic_is_lock_free(sizeof(_M_i), __a);
+	// Use a fake, minimally aligned pointer.
+	return __atomic_is_lock_free(sizeof(_M_i),
+	    reinterpret_cast<void *>(-__alignof(_M_i)));
       }
 
       bool
       is_lock_free() const volatile noexcept
       {
-	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_i));
-	return __atomic_is_lock_free(sizeof(_M_i), __a);
+	// Use a fake, minimally aligned pointer.
+	return __atomic_is_lock_free(sizeof(_M_i),
+	    reinterpret_cast<void *>(-__alignof(_M_i)));
       }
 
       _GLIBCXX_ALWAYS_INLINE void
@@ -666,16 +666,16 @@
       is_lock_free() const noexcept
       {
 	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_p));
-	return __atomic_is_lock_free(sizeof(_M_p), __a);
+	return __atomic_is_lock_free(sizeof(_M_p),
+	    reinterpret_cast<void *>(-__alignof(_M_p)));
       }
 
       bool
       is_lock_free() const volatile noexcept
       {
 	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_p));
-	return __atomic_is_lock_free(sizeof(_M_p), __a);
+	return __atomic_is_lock_free(sizeof(_M_p),
+	    reinterpret_cast<void *>(-__alignof(_M_p)));
       }
 
       _GLIBCXX_ALWAYS_INLINE void
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/atomic_futex.h gcc-5.2.0/libstdc++-v3/include/bits/atomic_futex.h
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/atomic_futex.h	2015-01-29 06:47:20.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/bits/atomic_futex.h	2015-09-03 10:10:37.057335000 -0500
@@ -93,15 +93,15 @@
     {
       for (;;)
 	{
-	  // Don't bother checking the value again because we expect the caller to
-	  // have done it recently.
+	  // Don't bother checking the value again because we expect the caller
+	  // to have done it recently.
 	  // memory_order_relaxed is sufficient because we can rely on just the
 	  // modification order (store_notify uses an atomic RMW operation too),
 	  // and the futex syscalls synchronize between themselves.
 	  _M_data.fetch_or(_Waiter_bit, memory_order_relaxed);
-	  bool __ret;
-	  __ret = _M_futex_wait_until((unsigned*)(void*)&_M_data,
-	      __assumed | _Waiter_bit, __has_timeout, __s, __ns);
+	  bool __ret = _M_futex_wait_until((unsigned*)(void*)&_M_data,
+					   __assumed | _Waiter_bit,
+					   __has_timeout, __s, __ns);
 	  // Fetch the current value after waiting (clears _Waiter_bit).
 	  __assumed = _M_load(__mo);
 	  if (!__ret || ((__operand == __assumed) == __equal))
@@ -119,7 +119,7 @@
 	bool __equal, memory_order __mo)
     {
       return _M_load_and_test_until(__assumed, __operand, __equal, __mo,
-	  false, chrono::seconds(0), chrono::nanoseconds(0));
+				    false, {}, {});
     }
 
     // If a timeout occurs, returns a current value after the timeout;
@@ -146,7 +146,8 @@
     _M_load_when_not_equal(unsigned __val, memory_order __mo)
     {
       unsigned __i = _M_load(__mo);
-      if ((__i & ~_Waiter_bit) != __val) return;
+      if ((__i & ~_Waiter_bit) != __val)
+	return (__i & ~_Waiter_bit);
       // TODO Spin-wait first.
       return _M_load_and_test(__i, __val, false, __mo);
     }
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/char_traits.h gcc-5.2.0/libstdc++-v3/include/bits/char_traits.h
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/char_traits.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/bits/char_traits.h	2015-10-02 15:08:17.234342000 -0500
@@ -256,7 +256,11 @@
 
       static int
       compare(const char_type* __s1, const char_type* __s2, size_t __n)
-      { return __builtin_memcmp(__s1, __s2, __n); }
+      {
+	if (__n == 0)
+	  return 0;
+	return __builtin_memcmp(__s1, __s2, __n);
+      }
 
       static size_t
       length(const char_type* __s)
@@ -264,19 +268,35 @@
 
       static const char_type*
       find(const char_type* __s, size_t __n, const char_type& __a)
-      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }
+      {
+	if (__n == 0)
+	  return 0;
+	return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
+      }
 
       static char_type*
       move(char_type* __s1, const char_type* __s2, size_t __n)
-      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }
+      {
+	if (__n == 0)
+	  return __s1;
+	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
+      }
 
       static char_type*
       copy(char_type* __s1, const char_type* __s2, size_t __n)
-      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }
+      {
+	if (__n == 0)
+	  return __s1;
+	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
+      }
 
       static char_type*
       assign(char_type* __s, size_t __n, char_type __a)
-      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }
+      {
+	if (__n == 0)
+	  return __s;
+	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
+      }
 
       static _GLIBCXX_CONSTEXPR char_type
       to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
@@ -327,7 +347,11 @@
 
       static int
       compare(const char_type* __s1, const char_type* __s2, size_t __n)
-      { return wmemcmp(__s1, __s2, __n); }
+      {
+	if (__n == 0)
+	  return 0;
+	return wmemcmp(__s1, __s2, __n);
+      }
 
       static size_t
       length(const char_type* __s)
@@ -335,19 +359,35 @@
 
       static const char_type*
       find(const char_type* __s, size_t __n, const char_type& __a)
-      { return wmemchr(__s, __a, __n); }
+      {
+	if (__n == 0)
+	  return 0;
+	return wmemchr(__s, __a, __n);
+      }
 
       static char_type*
       move(char_type* __s1, const char_type* __s2, size_t __n)
-      { return wmemmove(__s1, __s2, __n); }
+      {
+	if (__n == 0)
+	  return __s1;
+	return wmemmove(__s1, __s2, __n);
+      }
 
       static char_type*
       copy(char_type* __s1, const char_type* __s2, size_t __n)
-      { return wmemcpy(__s1, __s2, __n); }
+      {
+	if (__n == 0)
+	  return __s1;
+	return wmemcpy(__s1, __s2, __n);
+      }
 
       static char_type*
       assign(char_type* __s, size_t __n, char_type __a)
-      { return wmemset(__s, __a, __n); }
+      {
+	if (__n == 0)
+	  return __s;
+	return wmemset(__s, __a, __n);
+      }
 
       static _GLIBCXX_CONSTEXPR char_type
       to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
@@ -436,6 +476,8 @@
       static char_type*
       move(char_type* __s1, const char_type* __s2, size_t __n)
       {
+	if (__n == 0)
+	  return __s1;
 	return (static_cast<char_type*>
 		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
       }
@@ -443,6 +485,8 @@
       static char_type*
       copy(char_type* __s1, const char_type* __s2, size_t __n)
       {
+	if (__n == 0)
+	  return __s1;
 	return (static_cast<char_type*>
 		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
       }
@@ -529,6 +573,8 @@
       static char_type*
       move(char_type* __s1, const char_type* __s2, size_t __n)
       {
+	if (__n == 0)
+	  return __s1;
 	return (static_cast<char_type*>
 		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
       }
@@ -536,6 +582,8 @@
       static char_type*
       copy(char_type* __s1, const char_type* __s2, size_t __n)
       { 
+	if (__n == 0)
+	  return __s1;
 	return (static_cast<char_type*>
 		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
       }
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/locale_conv.h gcc-5.2.0/libstdc++-v3/include/bits/locale_conv.h
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/locale_conv.h	2015-07-02 17:54:45.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/include/bits/locale_conv.h	2015-10-07 16:00:50.975754000 -0500
@@ -44,14 +44,121 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-#ifdef _GLIBCXX_USE_WCHAR_T
-
   /**
    * @addtogroup locales
    * @{
    */
 
+  template<typename _OutStr, typename _InChar, typename _Codecvt,
+	   typename _State, typename _Fn>
+    bool
+    __do_str_codecvt(const _InChar* __first, const _InChar* __last,
+		     _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,
+		     size_t& __count, _Fn __fn)
+    {
+      if (__first == __last)
+	{
+	  __outstr.clear();
+	  __count = 0;
+	  return true;
+	}
+
+      size_t __outchars = 0;
+      auto __next = __first;
+      const auto __maxlen = __cvt.max_length() + 1;
+
+      codecvt_base::result __result;
+      do
+	{
+	  __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
+	  auto __outnext = &__outstr.front() + __outchars;
+	  auto const __outlast = &__outstr.back() + 1;
+	  __result = (__cvt.*__fn)(__state, __next, __last, __next,
+					__outnext, __outlast, __outnext);
+	  __outchars = __outnext - &__outstr.front();
+	}
+      while (__result == codecvt_base::partial && __next != __last
+	     && (__outstr.size() - __outchars) < __maxlen);
+
+      if (__result == codecvt_base::error)
+	return false;
+
+      if (__result == codecvt_base::noconv)
+	{
+	  __outstr.assign(__first, __last);
+	  __count = __last - __first;
+	}
+      else
+	{
+	  __outstr.resize(__outchars);
+	  __count = __next - __first;
+	}
+
+      return true;
+    }
+
+  // Convert narrow character string to wide.
+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
+    inline bool
+    __str_codecvt_in(const char* __first, const char* __last,
+		     basic_string<_CharT, _Traits, _Alloc>& __outstr,
+		     const codecvt<_CharT, char, _State>& __cvt,
+		     _State& __state, size_t& __count)
+    {
+      using _Codecvt = codecvt<_CharT, char, _State>;
+      using _ConvFn
+	= codecvt_base::result
+	  (_Codecvt::*)(_State&, const char*, const char*, const char*&,
+			_CharT*, _CharT*, _CharT*&) const;
+      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;
+      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
+			      __count, __fn);
+    }
+
+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
+    inline bool
+    __str_codecvt_in(const char* __first, const char* __last,
+		     basic_string<_CharT, _Traits, _Alloc>& __outstr,
+		     const codecvt<_CharT, char, _State>& __cvt)
+    {
+      _State __state = {};
+      size_t __n;
+      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);
+    }
+
+  // Convert wide character string to narrow.
+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
+    inline bool
+    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
+		      basic_string<char, _Traits, _Alloc>& __outstr,
+		      const codecvt<_CharT, char, _State>& __cvt,
+		      _State& __state, size_t& __count)
+    {
+      using _Codecvt = codecvt<_CharT, char, _State>;
+      using _ConvFn
+	= codecvt_base::result
+	  (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,
+			char*, char*, char*&) const;
+      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;
+      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
+			      __count, __fn);
+    }
+
+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
+    inline bool
+    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
+		      basic_string<char, _Traits, _Alloc>& __outstr,
+		      const codecvt<_CharT, char, _State>& __cvt)
+    {
+      _State __state = {};
+      size_t __n;
+      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);
+    }
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+
 _GLIBCXX_BEGIN_NAMESPACE_CXX11
+
   /// String conversions
   template<typename _Codecvt, typename _Elem = wchar_t,
 	   typename _Wide_alloc = allocator<_Elem>,
@@ -137,9 +244,15 @@
       wide_string
       from_bytes(const char* __first, const char* __last)
       {
-	auto __errstr = _M_with_strings ? &_M_wide_err_string : nullptr;
-	_ConvFn<char, _Elem> __fn = &_Codecvt::in;
-	return _M_conv(__first, __last, __errstr, __fn);
+	if (!_M_with_cvtstate)
+	  _M_state = state_type();
+	wide_string __out{ _M_wide_err_string.get_allocator() };
+	if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
+			     _M_count))
+	  return __out;
+	if (_M_with_strings)
+	  return _M_wide_err_string;
+	__throw_range_error("wstring_convert::from_bytes");
       }
       /// @}
 
@@ -167,9 +280,15 @@
       byte_string
       to_bytes(const _Elem* __first, const _Elem* __last)
       {
-	auto __errstr = _M_with_strings ? &_M_byte_err_string : nullptr;
-	_ConvFn<_Elem, char> __fn = &_Codecvt::out;
-	return _M_conv(__first, __last, __errstr, __fn);
+	if (!_M_with_cvtstate)
+	  _M_state = state_type();
+	byte_string __out{ _M_byte_err_string.get_allocator() };
+	if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
+			      _M_count))
+	  return __out;
+	if (_M_with_strings)
+	  return _M_byte_err_string;
+	__throw_range_error("wstring_convert::to_bytes");
       }
       /// @}
 
@@ -182,63 +301,6 @@
       state_type state() const { return _M_state; }
 
     private:
-      template<typename _InC, typename _OutC>
-	using _ConvFn
-	  = codecvt_base::result
-	    (_Codecvt::*)(state_type&, const _InC*, const _InC*, const _InC*&,
-			  _OutC*, _OutC*, _OutC*&) const;
-
-      template<typename _InChar, typename _OutStr, typename _MemFn>
-	_OutStr
-	_M_conv(const _InChar* __first, const _InChar* __last,
-		const _OutStr* __err, _MemFn __memfn)
-	{
-	  auto __outstr = __err ? _OutStr(__err->get_allocator()) : _OutStr();
-
-	  if (__first == __last)
-	    {
-	      _M_count = 0;
-	      return __outstr;
-	    }
-
-	  if (!_M_with_cvtstate)
-	    _M_state = state_type();
-
-	  size_t __outchars = 0;
-	  auto __next = __first;
-	  const auto __maxlen = _M_cvt->max_length() + 1;
-
-	  codecvt_base::result __result;
-	  do
-	    {
-	      __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
-	      auto __outnext = &__outstr.front() + __outchars;
-	      auto const __outlast = &__outstr.back() + 1;
-	      __result = ((*_M_cvt).*__memfn)(_M_state, __next, __last, __next,
-					    __outnext, __outlast, __outnext);
-	      __outchars = __outnext - &__outstr.front();
-	    }
-	  while (__result == codecvt_base::partial && __next != __last
-		 && (__outstr.size() - __outchars) < __maxlen);
-
-	  if (__result == codecvt_base::noconv)
-	    {
-	      __outstr.assign(__first, __last);
-	      _M_count = __outstr.size();
-	      return __outstr;
-	    }
-
-	  __outstr.resize(__outchars);
-	  _M_count = __next - __first;
-
-	  if (__result != codecvt_base::error)
-	    return __outstr;
-	  else if (__err)
-	    return *__err;
-	  else
-	    __throw_range_error("wstring_convert");
-	}
-
       unique_ptr<_Codecvt>	_M_cvt;
       byte_string		_M_byte_err_string;
       wide_string		_M_wide_err_string;
@@ -247,6 +309,7 @@
       bool			_M_with_cvtstate = false;
       bool			_M_with_strings = false;
     };
+
 _GLIBCXX_END_NAMESPACE_CXX11
 
   /// Buffer conversions
@@ -470,10 +533,10 @@
       bool			_M_always_noconv;
     };
 
-  /// @} group locales
-
 #endif  // _GLIBCXX_USE_WCHAR_T
 
+  /// @} group locales
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/quoted_string.h gcc-5.2.0/libstdc++-v3/include/bits/quoted_string.h
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/quoted_string.h	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/bits/quoted_string.h	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,164 @@
+// Helpers for quoted stream manipulators -*- C++ -*-
+
+// Copyright (C) 2013-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/quoted_string.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iomanip}
+ */
+
+#ifndef _GLIBCXX_QUOTED_STRING_H
+#define _GLIBCXX_QUOTED_STRING_H 1
+
+#pragma GCC system_header
+
+#if __cplusplus < 201103L
+# include <bits/c++0x_warning.h>
+#else
+#include <sstream>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+  namespace __detail {
+  _GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+    /**
+     * @brief Struct for delimited strings.
+     */
+    template<typename _String, typename _CharT>
+      struct _Quoted_string
+      {
+	static_assert(is_reference<_String>::value
+		   || is_pointer<_String>::value,
+		      "String type must be pointer or reference");
+
+	_Quoted_string(_String __str, _CharT __del, _CharT __esc)
+	: _M_string(__str), _M_delim{__del}, _M_escape{__esc}
+	{ }
+
+	_Quoted_string&
+	operator=(_Quoted_string&) = delete;
+
+	_String _M_string;
+	_CharT _M_delim;
+	_CharT _M_escape;
+      };
+
+    /**
+     * @brief Inserter for quoted strings.
+     *
+     *  _GLIBCXX_RESOLVE_LIB_DEFECTS
+     *  DR 2344 quoted()'s interaction with padding is unclear
+     */
+    template<typename _CharT, typename _Traits>
+      std::basic_ostream<_CharT, _Traits>&
+      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
+		 const _Quoted_string<const _CharT*, _CharT>& __str)
+      {
+	std::basic_ostringstream<_CharT, _Traits> __ostr;
+	__ostr << __str._M_delim;
+	for (const _CharT* __c = __str._M_string; *__c; ++__c)
+	  {
+	    if (*__c == __str._M_delim || *__c == __str._M_escape)
+	      __ostr << __str._M_escape;
+	    __ostr << *__c;
+	  }
+	__ostr << __str._M_delim;
+
+	return __os << __ostr.str();
+      }
+
+    /**
+     * @brief Inserter for quoted strings.
+     *
+     *  _GLIBCXX_RESOLVE_LIB_DEFECTS
+     *  DR 2344 quoted()'s interaction with padding is unclear
+     */
+    template<typename _CharT, typename _Traits, typename _String>
+      std::basic_ostream<_CharT, _Traits>&
+      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
+		 const _Quoted_string<_String, _CharT>& __str)
+      {
+	std::basic_ostringstream<_CharT, _Traits> __ostr;
+	__ostr << __str._M_delim;
+	for (auto& __c : __str._M_string)
+	  {
+	    if (__c == __str._M_delim || __c == __str._M_escape)
+	      __ostr << __str._M_escape;
+	    __ostr << __c;
+	  }
+	__ostr << __str._M_delim;
+
+	return __os << __ostr.str();
+      }
+
+    /**
+     * @brief Extractor for delimited strings.
+     *        The left and right delimiters can be different.
+     */
+    template<typename _CharT, typename _Traits, typename _Alloc>
+      std::basic_istream<_CharT, _Traits>&
+      operator>>(std::basic_istream<_CharT, _Traits>& __is,
+		 const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,
+				      _CharT>& __str)
+      {
+	_CharT __c;
+	__is >> __c;
+	if (!__is.good())
+	  return __is;
+	if (__c != __str._M_delim)
+	  {
+	    __is.unget();
+	    __is >> __str._M_string;
+	    return __is;
+	  }
+	__str._M_string.clear();
+	std::ios_base::fmtflags __flags
+	  = __is.flags(__is.flags() & ~std::ios_base::skipws);
+	do
+	  {
+	    __is >> __c;
+	    if (!__is.good())
+	      break;
+	    if (__c == __str._M_escape)
+	      {
+		__is >> __c;
+		if (!__is.good())
+		  break;
+	      }
+	    else if (__c == __str._M_delim)
+	      break;
+	    __str._M_string += __c;
+	  }
+	while (true);
+	__is.setf(__flags);
+
+	return __is;
+      }
+
+  _GLIBCXX_END_NAMESPACE_VERSION
+  } // namespace __detail
+} // namespace std
+
+#endif // C++11
+#endif /* _GLIBCXX_QUOTED_STRING_H */
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/range_access.h gcc-5.2.0/libstdc++-v3/include/bits/range_access.h
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/range_access.h	2015-01-19 08:37:03.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/bits/range_access.h	2015-09-03 10:10:42.436559000 -0500
@@ -98,6 +98,14 @@
     { return __arr + _Nm; }
 
 #if __cplusplus >= 201402L
+
+  template<typename _Tp> class valarray;
+  // These overloads must be declared for cbegin and cend to use them.
+  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
+  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
+  template<typename _Tp> _Tp* end(valarray<_Tp>&);
+  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);
+
   /**
    *  @brief  Return an iterator pointing to the first element of
    *          the const container.
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/regex_compiler.h gcc-5.2.0/libstdc++-v3/include/bits/regex_compiler.h
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/regex_compiler.h	2015-01-19 16:56:04.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/bits/regex_compiler.h	2015-07-28 23:30:25.427925000 -0500
@@ -116,8 +116,10 @@
 	void
 	_M_insert_bracket_matcher(bool __neg);
 
+      // Returns true if successfully matched one term and should continue.
+      // Returns false if the compiler should move on.
       template<bool __icase, bool __collate>
-	void
+	bool
 	_M_expression_term(pair<bool, _CharT>& __last_char,
 			   _BracketMatcher<_TraitsT, __icase, __collate>&
 			   __matcher);
@@ -389,8 +391,8 @@
 #endif
       }
 
-      void
-      _M_add_collating_element(const _StringT& __s)
+      _StringT
+      _M_add_collate_element(const _StringT& __s)
       {
 	auto __st = _M_traits.lookup_collatename(__s.data(),
 						 __s.data() + __s.size());
@@ -400,6 +402,7 @@
 #ifdef _GLIBCXX_DEBUG
 	_M_is_ready = false;
 #endif
+	return __st;
       }
 
       void
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/regex_compiler.tcc gcc-5.2.0/libstdc++-v3/include/bits/regex_compiler.tcc
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/regex_compiler.tcc	2015-01-08 21:58:59.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/bits/regex_compiler.tcc	2015-07-28 23:30:25.427925000 -0500
@@ -424,8 +424,7 @@
 	    __last_char.first = true;
 	    __last_char.second = _M_value[0];
 	  }
-      while (!_M_match_token(_ScannerT::_S_token_bracket_end))
-	_M_expression_term(__last_char, __matcher);
+      while (_M_expression_term(__last_char, __matcher));
       __matcher._M_ready();
       _M_stack.push(_StateSeqT(
 		      *_M_nfa,
@@ -434,21 +433,31 @@
 
   template<typename _TraitsT>
   template<bool __icase, bool __collate>
-    void
+    bool
     _Compiler<_TraitsT>::
     _M_expression_term(pair<bool, _CharT>& __last_char,
 		       _BracketMatcher<_TraitsT, __icase, __collate>& __matcher)
     {
+      if (_M_match_token(_ScannerT::_S_token_bracket_end))
+	return false;
+
       if (_M_match_token(_ScannerT::_S_token_collsymbol))
-	__matcher._M_add_collating_element(_M_value);
+	{
+	  auto __symbol = __matcher._M_add_collate_element(_M_value);
+	  if (__symbol.size() == 1)
+	    {
+	      __last_char.first = true;
+	      __last_char.second = __symbol[0];
+	    }
+	}
       else if (_M_match_token(_ScannerT::_S_token_equiv_class_name))
 	__matcher._M_add_equivalence_class(_M_value);
       else if (_M_match_token(_ScannerT::_S_token_char_class_name))
 	__matcher._M_add_character_class(_M_value, false);
-      // POSIX doesn't permit '-' as a start-range char (say [a-z--0]),
-      // except when the '-' is the first character in the bracket expression
-      // ([--0]). ECMAScript treats all '-' after a range as a normal character.
-      // Also see above, where _M_expression_term gets called.
+      // POSIX doesn't allow '-' as a start-range char (say [a-z--0]),
+      // except when the '-' is the first or last character in the bracket
+      // expression ([--0]). ECMAScript treats all '-' after a range as a
+      // normal character. Also see above, where _M_expression_term gets called.
       //
       // As a result, POSIX rejects [-----], but ECMAScript doesn't.
       // Boost (1.57.0) always uses POSIX style even in its ECMAScript syntax.
@@ -459,10 +468,14 @@
 	{
 	  if (!__last_char.first)
 	    {
+	      __matcher._M_add_char(_M_value[0]);
 	      if (_M_value[0] == '-'
 		  && !(_M_flags & regex_constants::ECMAScript))
-		__throw_regex_error(regex_constants::error_range);
-	      __matcher._M_add_char(_M_value[0]);
+		{
+		  if (_M_match_token(_ScannerT::_S_token_bracket_end))
+		    return false;
+		  __throw_regex_error(regex_constants::error_range);
+		}
 	      __last_char.first = true;
 	      __last_char.second = _M_value[0];
 	    }
@@ -496,6 +509,8 @@
 						     _M_value[0]));
       else
 	__throw_regex_error(regex_constants::error_brack);
+
+      return true;
     }
 
   template<typename _TraitsT>
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/regex_scanner.tcc gcc-5.2.0/libstdc++-v3/include/bits/regex_scanner.tcc
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/regex_scanner.tcc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/bits/regex_scanner.tcc	2015-08-27 22:03:55.801997000 -0500
@@ -99,6 +99,12 @@
       auto __c = *_M_current++;
       const char* __pos;
 
+      if (std::strchr(_M_spec_char, _M_ctype.narrow(__c, '\0')) == nullptr)
+	{
+	  _M_token = _S_token_ord_char;
+	  _M_value.assign(1, __c);
+	  return;
+	}
       if (__c == '\\')
 	{
 	  if (_M_current == _M_end)
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/bits/stl_deque.h gcc-5.2.0/libstdc++-v3/include/bits/stl_deque.h
--- gcc-5.2.0.orig/libstdc++-v3/include/bits/stl_deque.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/bits/stl_deque.h	2015-10-02 15:08:11.094111000 -0500
@@ -645,6 +645,7 @@
 	_Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};
 	// Create an empty map that allocates using the moved-from allocator.
 	_Deque_base __empty{__alloc};
+	__empty._M_initialize_map(0);
 	// Now safe to modify current allocator and perform non-throwing swaps.
 	_Deque_impl __ret{std::move(_M_get_Tp_allocator())};
 	_M_impl._M_swap_data(__ret);
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/experimental/filesystem gcc-5.2.0/libstdc++-v3/include/experimental/filesystem
--- gcc-5.2.0.orig/libstdc++-v3/include/experimental/filesystem	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/experimental/filesystem	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,77 @@
+// <experimental/filesystem> -*- C++ -*-
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file experimental/filesystem
+ *  This is a TS C++ Library header.
+ */
+
+#ifndef _GLIBCXX_EXPERIMENTAL_FILESYSTEM
+#define _GLIBCXX_EXPERIMENTAL_FILESYSTEM 1
+
+#pragma GCC system_header
+
+#if __cplusplus < 201103L
+# include <bits/c++0x_warning.h>
+#else
+
+#include <experimental/fs_fwd.h>
+#include <experimental/fs_path.h>
+#include <experimental/fs_dir.h>
+#include <experimental/fs_ops.h>
+
+#define __cpp_lib_experimental_filesystem 201406
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+namespace experimental
+{
+namespace filesystem
+{
+inline namespace v1
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /**
+   * @ingroup filesystem
+   */
+    inline std::string filesystem_error::_M_gen_what()
+    {
+      std::string __what = "filesystem error: ";
+      __what += system_error::what();
+      if (!_M_path1.empty())
+	  __what += " [" + _M_path1.string() + ']';
+      if (!_M_path2.empty())
+	  __what += " [" + _M_path2.string() + ']';
+      return __what;
+    }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace v1
+} // namespace filesystem
+} // namespace experimental
+} // namespace std
+
+#endif // C++11
+
+#endif // _GLIBCXX_EXPERIMENTAL_FILESYSTEM
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/experimental/fs_dir.h gcc-5.2.0/libstdc++-v3/include/experimental/fs_dir.h
--- gcc-5.2.0.orig/libstdc++-v3/include/experimental/fs_dir.h	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/experimental/fs_dir.h	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,338 @@
+// Filesystem directory utilities -*- C++ -*-
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file experimental/fs_dir.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{experimental/filesystem}
+ */
+
+#ifndef _GLIBCXX_EXPERIMENTAL_FS_DIR_H
+#define _GLIBCXX_EXPERIMENTAL_FS_DIR_H 1
+
+#if __cplusplus < 201103L
+# include <bits/c++0x_warning.h>
+#else
+# include <typeinfo>
+# include <ext/concurrence.h>
+# include <bits/unique_ptr.h>
+# include <bits/shared_ptr.h>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+namespace experimental
+{
+namespace filesystem
+{
+inline namespace v1
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /**
+   * @ingroup filesystem
+   * @{
+   */
+
+  class file_status
+  {
+  public:
+    // constructors
+    explicit
+    file_status(file_type __ft = file_type::none,
+	        perms __prms = perms::unknown) noexcept
+    : _M_type(__ft), _M_perms(__prms) { }
+
+    file_status(const file_status&) noexcept = default;
+    file_status(file_status&&) noexcept = default;
+    ~file_status() = default;
+
+    file_status& operator=(const file_status&) noexcept = default;
+    file_status& operator=(file_status&&) noexcept = default;
+
+    // observers
+    file_type  type() const noexcept { return _M_type; }
+    perms      permissions() const noexcept { return _M_perms; }
+
+    // modifiers
+    void       type(file_type __ft) noexcept { _M_type = __ft; }
+    void       permissions(perms __prms) noexcept { _M_perms = __prms; }
+
+  private:
+    file_type	_M_type;
+    perms	_M_perms;
+  };
+
+_GLIBCXX_BEGIN_NAMESPACE_CXX11
+
+  class directory_entry
+  {
+  public:
+    // constructors and destructor
+    directory_entry() noexcept = default;
+    directory_entry(const directory_entry&) = default;
+    directory_entry(directory_entry&&) noexcept = default;
+    explicit directory_entry(const filesystem::path& __p) : _M_path(__p) { }
+    ~directory_entry() = default;
+
+    // modifiers
+    directory_entry& operator=(const directory_entry&) = default;
+    directory_entry& operator=(directory_entry&&) noexcept = default;
+
+    void assign(const filesystem::path& __p) { _M_path = __p; }
+
+    void
+    replace_filename(const filesystem::path& __p)
+    { _M_path = _M_path.parent_path() / __p; }
+
+    // observers
+    const filesystem::path&  path() const noexcept { return _M_path; }
+    operator const filesystem::path&() const noexcept { return _M_path; }
+
+    file_status
+    status() const
+    { return filesystem::status(_M_path); }
+
+    file_status
+    status(error_code& __ec) const noexcept
+    { return filesystem::status(_M_path, __ec); }
+
+    file_status
+    symlink_status() const
+    { return filesystem::symlink_status(_M_path); }
+
+    file_status
+    symlink_status(error_code& __ec) const noexcept
+    { return filesystem::symlink_status(_M_path, __ec); }
+
+    bool
+    operator< (const directory_entry& __rhs) const noexcept
+    { return _M_path < __rhs._M_path; }
+
+    bool
+    operator==(const directory_entry& __rhs) const noexcept
+    { return _M_path == __rhs._M_path; }
+
+    bool
+    operator!=(const directory_entry& __rhs) const noexcept
+    { return _M_path != __rhs._M_path; }
+
+    bool
+    operator<=(const directory_entry& __rhs) const noexcept
+    { return _M_path <= __rhs._M_path; }
+
+    bool
+    operator> (const directory_entry& __rhs) const noexcept
+    { return _M_path > __rhs._M_path; }
+
+    bool
+    operator>=(const directory_entry& __rhs) const noexcept
+    { return _M_path >= __rhs._M_path; }
+
+  private:
+    filesystem::path    _M_path;
+  };
+
+  struct _Dir;
+  class recursive_directory_iterator;
+
+  class directory_iterator
+  {
+  public:
+    typedef directory_entry        value_type;
+    typedef ptrdiff_t              difference_type;
+    typedef const directory_entry* pointer;
+    typedef const directory_entry& reference;
+    typedef input_iterator_tag     iterator_category;
+
+    directory_iterator() noexcept = default;
+
+    explicit
+    directory_iterator(const path& __p)
+    : directory_iterator(__p, directory_options::none, nullptr) { }
+
+    directory_iterator(const path& __p, directory_options __options)
+    : directory_iterator(__p, __options, nullptr) { }
+
+    directory_iterator(const path& __p, error_code& __ec) noexcept
+    : directory_iterator(__p, directory_options::none, __ec) { }
+
+    directory_iterator(const path& __p,
+      directory_options __options, error_code& __ec) noexcept
+    : directory_iterator(__p, __options, &__ec) { }
+
+    directory_iterator(const directory_iterator& __rhs) = default;
+
+    directory_iterator(directory_iterator&& __rhs) noexcept = default;
+
+    ~directory_iterator() = default;
+
+    directory_iterator& operator=(const directory_iterator& __rhs) = default;
+    directory_iterator& operator=(directory_iterator&& __rhs) noexcept = default;
+
+    const directory_entry& operator*() const;
+    const directory_entry* operator->() const { return &**this; }
+    directory_iterator&    operator++();
+    directory_iterator&    increment(error_code& __ec) noexcept;
+
+    directory_iterator operator++(int)
+    {
+      auto __tmp = *this;
+      ++*this;
+      return __tmp;
+    }
+
+  private:
+    directory_iterator(const path&, directory_options, error_code*);
+
+    friend bool
+    operator==(const directory_iterator& __lhs,
+               const directory_iterator& __rhs);
+
+    friend class recursive_directory_iterator;
+
+    std::shared_ptr<_Dir> _M_dir;
+  };
+
+  inline directory_iterator
+  begin(directory_iterator __iter) { return __iter; }
+
+  inline directory_iterator
+  end(directory_iterator) { return directory_iterator(); }
+
+  inline bool
+  operator==(const directory_iterator& __lhs, const directory_iterator& __rhs)
+  {
+    return !__rhs._M_dir.owner_before(__lhs._M_dir)
+      && !__lhs._M_dir.owner_before(__rhs._M_dir);
+  }
+
+  inline bool
+  operator!=(const directory_iterator& __lhs, const directory_iterator& __rhs)
+  { return !(__lhs == __rhs); }
+
+  class recursive_directory_iterator
+  {
+  public:
+    typedef directory_entry        value_type;
+    typedef ptrdiff_t              difference_type;
+    typedef const directory_entry* pointer;
+    typedef const directory_entry& reference;
+    typedef input_iterator_tag     iterator_category;
+
+    recursive_directory_iterator() noexcept = default;
+
+    explicit
+    recursive_directory_iterator(const path& __p)
+    : recursive_directory_iterator(__p, directory_options::none, nullptr) { }
+
+    recursive_directory_iterator(const path& __p, directory_options __options)
+    : recursive_directory_iterator(__p, __options, nullptr) { }
+
+    recursive_directory_iterator(const path& __p,
+                                 directory_options __options,
+                                 error_code& __ec) noexcept
+    : recursive_directory_iterator(__p, __options, &__ec) { }
+
+    recursive_directory_iterator(const path& __p, error_code& __ec) noexcept
+    : recursive_directory_iterator(__p, directory_options::none, &__ec) { }
+
+    recursive_directory_iterator(
+        const recursive_directory_iterator&) = default;
+
+    recursive_directory_iterator(
+        recursive_directory_iterator&&) noexcept = default;
+
+    ~recursive_directory_iterator();
+
+    // observers
+    directory_options  options() const { return _M_options; }
+    int                depth() const;
+    bool               recursion_pending() const { return _M_pending; }
+
+    const directory_entry& operator*() const;
+    const directory_entry* operator->() const { return &**this; }
+
+    // modifiers
+    recursive_directory_iterator&
+      operator=(const recursive_directory_iterator& __rhs) noexcept;
+    recursive_directory_iterator&
+      operator=(recursive_directory_iterator&& __rhs) noexcept;
+
+    recursive_directory_iterator& operator++();
+    recursive_directory_iterator& increment(error_code& __ec) noexcept;
+
+    recursive_directory_iterator operator++(int)
+    {
+      auto __tmp = *this;
+      ++*this;
+      return __tmp;
+    }
+
+    void pop();
+
+    void disable_recursion_pending() { _M_pending = false; }
+
+  private:
+    recursive_directory_iterator(const path&, directory_options, error_code*);
+
+    friend bool
+    operator==(const recursive_directory_iterator& __lhs,
+               const recursive_directory_iterator& __rhs);
+
+    struct _Dir_stack;
+    std::shared_ptr<_Dir_stack> _M_dirs;
+    directory_options _M_options;
+    bool _M_pending;
+  };
+
+  inline recursive_directory_iterator
+  begin(recursive_directory_iterator __iter) { return __iter; }
+
+  inline recursive_directory_iterator
+  end(recursive_directory_iterator) { return recursive_directory_iterator(); }
+
+  inline bool
+  operator==(const recursive_directory_iterator& __lhs,
+             const recursive_directory_iterator& __rhs)
+  {
+    return !__rhs._M_dirs.owner_before(__lhs._M_dirs)
+      && !__lhs._M_dirs.owner_before(__rhs._M_dirs);
+  }
+
+  inline bool
+  operator!=(const recursive_directory_iterator& __lhs,
+             const recursive_directory_iterator& __rhs)
+  { return !(__lhs == __rhs); }
+
+_GLIBCXX_END_NAMESPACE_CXX11
+
+  // @} group filesystem
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace v1
+} // namespace filesystem
+} // namespace experimental
+} // namespace std
+
+#endif // C++11
+
+#endif // _GLIBCXX_EXPERIMENTAL_FS_DIR_H
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/experimental/fs_fwd.h gcc-5.2.0/libstdc++-v3/include/experimental/fs_fwd.h
--- gcc-5.2.0.orig/libstdc++-v3/include/experimental/fs_fwd.h	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/experimental/fs_fwd.h	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,289 @@
+// Filesystem declarations -*- C++ -*-
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file experimental/filesystem
+ *  This is a TS C++ Library header.
+ */
+
+#ifndef _GLIBCXX_EXPERIMENTAL_FS_FWD_H
+#define _GLIBCXX_EXPERIMENTAL_FS_FWD_H 1
+
+#if __cplusplus < 201103L
+# include <bits/c++0x_warning.h>
+#else
+
+#include <system_error>
+#include <cstdint>
+#include <chrono>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+namespace experimental
+{
+namespace filesystem
+{
+inline namespace v1
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+#if _GLIBCXX_USE_CXX11_ABI
+  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
+#endif
+
+  /**
+   * @defgroup filesystem
+   * @ingroup experimental
+   *
+   * Utilities for performing operations on file systems and their components,
+   * such as paths, regular files, and directories.
+   *
+   * @{
+   */
+
+  class file_status;
+_GLIBCXX_BEGIN_NAMESPACE_CXX11
+  class path;
+  class filesystem_error;
+  class directory_entry;
+  class directory_iterator;
+  class recursive_directory_iterator;
+_GLIBCXX_END_NAMESPACE_CXX11
+
+  struct space_info
+  {
+    uintmax_t capacity;
+    uintmax_t free;
+    uintmax_t available;
+  };
+
+  enum class file_type : signed char {
+      none = 0, not_found = -1, regular = 1, directory = 2, symlink = 3,
+      block = 4, character = 5, fifo = 6, socket = 7, unknown = 8
+  };
+
+  /// Bitmask type
+  enum class copy_options : unsigned short {
+      none = 0,
+      skip_existing = 1, overwrite_existing = 2, update_existing = 4,
+      recursive = 8,
+      copy_symlinks = 16, skip_symlinks = 32,
+      directories_only = 64, create_symlinks = 128, create_hard_links = 256
+  };
+
+  constexpr copy_options
+  operator&(copy_options __x, copy_options __y)
+  {
+    using __utype = typename std::underlying_type<copy_options>::type;
+    return static_cast<copy_options>(
+	static_cast<__utype>(__x) & static_cast<__utype>(__y));
+  }
+
+  constexpr copy_options
+  operator|(copy_options __x, copy_options __y)
+  {
+    using __utype = typename std::underlying_type<copy_options>::type;
+    return static_cast<copy_options>(
+	static_cast<__utype>(__x) | static_cast<__utype>(__y));
+  }
+
+  constexpr copy_options
+  operator^(copy_options __x, copy_options __y)
+  {
+    using __utype = typename std::underlying_type<copy_options>::type;
+    return static_cast<copy_options>(
+	static_cast<__utype>(__x) ^ static_cast<__utype>(__y));
+  }
+
+  constexpr copy_options
+  operator~(copy_options __x)
+  {
+    using __utype = typename std::underlying_type<copy_options>::type;
+    return static_cast<copy_options>(~static_cast<__utype>(__x));
+  }
+
+  inline copy_options&
+  operator&=(copy_options& __x, copy_options __y)
+  { return __x = __x & __y; }
+
+  inline copy_options&
+  operator|=(copy_options& __x, copy_options __y)
+  { return __x = __x | __y; }
+
+  inline copy_options&
+  operator^=(copy_options& __x, copy_options __y)
+  { return __x = __x ^ __y; }
+
+
+  /// Bitmask type
+  enum class perms : unsigned {
+      none		=  0,
+      owner_read	=  0400,
+      owner_write	=  0200,
+      owner_exec	=  0100,
+      owner_all		=  0700,
+      group_read	=   040,
+      group_write	=   020,
+      group_exec	=   010,
+      group_all		=   070,
+      others_read	=    04,
+      others_write	=    02,
+      others_exec	=    01,
+      others_all	=    07,
+      all		=  0777,
+      set_uid		= 04000,
+      set_gid		= 02000,
+      sticky_bit	= 01000,
+      mask		= 07777,
+      unknown		=  0xFFFF,
+      add_perms		= 0x10000,
+      remove_perms	= 0x20000,
+      resolve_symlinks	= 0x40000
+  };
+
+  constexpr perms
+  operator&(perms __x, perms __y)
+  {
+    using __utype = typename std::underlying_type<perms>::type;
+    return static_cast<perms>(
+	static_cast<__utype>(__x) & static_cast<__utype>(__y));
+  }
+
+  constexpr perms
+  operator|(perms __x, perms __y)
+  {
+    using __utype = typename std::underlying_type<perms>::type;
+    return static_cast<perms>(
+	static_cast<__utype>(__x) | static_cast<__utype>(__y));
+  }
+
+  constexpr perms
+  operator^(perms __x, perms __y)
+  {
+    using __utype = typename std::underlying_type<perms>::type;
+    return static_cast<perms>(
+	static_cast<__utype>(__x) ^ static_cast<__utype>(__y));
+  }
+
+  constexpr perms
+  operator~(perms __x)
+  {
+    using __utype = typename std::underlying_type<perms>::type;
+    return static_cast<perms>(~static_cast<__utype>(__x));
+  }
+
+  inline perms&
+  operator&=(perms& __x, perms __y)
+  { return __x = __x & __y; }
+
+  inline perms&
+  operator|=(perms& __x, perms __y)
+  { return __x = __x | __y; }
+
+  inline perms&
+  operator^=(perms& __x, perms __y)
+  { return __x = __x ^ __y; }
+
+  // Bitmask type
+  enum class directory_options : unsigned char {
+      none = 0, follow_directory_symlink = 1, skip_permission_denied = 2
+  };
+
+  constexpr directory_options
+  operator&(directory_options __x, directory_options __y)
+  {
+    using __utype = typename std::underlying_type<directory_options>::type;
+    return static_cast<directory_options>(
+	static_cast<__utype>(__x) & static_cast<__utype>(__y));
+  }
+
+  constexpr directory_options
+  operator|(directory_options __x, directory_options __y)
+  {
+    using __utype = typename std::underlying_type<directory_options>::type;
+    return static_cast<directory_options>(
+	static_cast<__utype>(__x) | static_cast<__utype>(__y));
+  }
+
+  constexpr directory_options
+  operator^(directory_options __x, directory_options __y)
+  {
+    using __utype = typename std::underlying_type<directory_options>::type;
+    return static_cast<directory_options>(
+	static_cast<__utype>(__x) ^ static_cast<__utype>(__y));
+  }
+
+  constexpr directory_options
+  operator~(directory_options __x)
+  {
+    using __utype = typename std::underlying_type<directory_options>::type;
+    return static_cast<directory_options>(~static_cast<__utype>(__x));
+  }
+
+  inline directory_options&
+  operator&=(directory_options& __x, directory_options __y)
+  { return __x = __x & __y; }
+
+  inline directory_options&
+  operator|=(directory_options& __x, directory_options __y)
+  { return __x = __x | __y; }
+
+  inline directory_options&
+  operator^=(directory_options& __x, directory_options __y)
+  { return __x = __x ^ __y; }
+
+  typedef chrono::time_point<chrono::system_clock> file_time_type;
+
+  // operational functions
+
+  void copy(const path& __from, const path& __to, copy_options __options);
+  void copy(const path& __from, const path& __to, copy_options __options,
+	    error_code&) noexcept;
+
+  bool copy_file(const path& __from, const path& __to, copy_options __option);
+  bool copy_file(const path& __from, const path& __to, copy_options __option,
+		 error_code&) noexcept;
+
+  path current_path();
+
+  file_status status(const path&);
+  file_status status(const path&, error_code&) noexcept;
+
+  bool status_known(file_status) noexcept;
+
+  file_status symlink_status(const path&);
+  file_status symlink_status(const path&, error_code&) noexcept;
+
+  bool is_regular_file(file_status) noexcept;
+  bool is_symlink(file_status) noexcept;
+
+  // @} group filesystem
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace v1
+} // namespace filesystem
+} // namespace experimental
+} // namespace std
+
+#endif // C++11
+
+#endif // _GLIBCXX_EXPERIMENTAL_FS_FWD_H
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/experimental/fs_ops.h gcc-5.2.0/libstdc++-v3/include/experimental/fs_ops.h
--- gcc-5.2.0.orig/libstdc++-v3/include/experimental/fs_ops.h	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/experimental/fs_ops.h	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,291 @@
+// Filesystem operational functions -*- C++ -*-
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your __option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file experimental/filesystem
+ *  This is a TS C++ Library header.
+ */
+
+#ifndef _GLIBCXX_EXPERIMENTAL_FS_OPS_H
+#define _GLIBCXX_EXPERIMENTAL_FS_OPS_H 1
+
+#if __cplusplus < 201103L
+# include <bits/c++0x_warning.h>
+#else
+
+#include <cstdint>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+namespace experimental
+{
+namespace filesystem
+{
+inline namespace v1
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /**
+   * @ingroup filesystem
+   * @{
+   */
+
+  path absolute(const path& __p, const path& __base = current_path());
+
+  path canonical(const path& __p, const path& __base = current_path());
+  path canonical(const path& __p, error_code& __ec);
+  path canonical(const path& __p, const path& __base, error_code& __ec);
+
+  inline void
+  copy(const path& __from, const path& __to)
+  { copy(__from, __to, copy_options::none); }
+
+  inline void
+  copy(const path& __from, const path& __to, error_code& __ec) noexcept
+  { copy(__from, __to, copy_options::none, __ec); }
+
+  void copy(const path& __from, const path& __to, copy_options __options);
+  void copy(const path& __from, const path& __to, copy_options __options,
+	    error_code& __ec) noexcept;
+
+  inline bool
+  copy_file(const path& __from, const path& __to)
+  { return copy_file(__from, __to, copy_options::none); }
+
+  inline bool
+  copy_file(const path& __from, const path& __to, error_code& __ec) noexcept
+  { return copy_file(__from, __to, copy_options::none, __ec); }
+
+  bool copy_file(const path& __from, const path& __to, copy_options __option);
+  bool copy_file(const path& __from, const path& __to, copy_options __option,
+		 error_code& __ec) noexcept;
+
+  void copy_symlink(const path& __existing_symlink, const path& __new_symlink);
+  void copy_symlink(const path& __existing_symlink, const path& __new_symlink,
+		    error_code& __ec) noexcept;
+
+  bool create_directories(const path& __p);
+  bool create_directories(const path& __p, error_code& __ec) noexcept;
+
+  bool create_directory(const path& __p);
+  bool create_directory(const path& __p, error_code& __ec) noexcept;
+
+  bool create_directory(const path& __p, const path& attributes);
+  bool create_directory(const path& __p, const path& attributes,
+			error_code& __ec) noexcept;
+
+  void create_directory_symlink(const path& __to, const path& __new_symlink);
+  void create_directory_symlink(const path& __to, const path& __new_symlink,
+				error_code& __ec) noexcept;
+
+  void create_hard_link(const path& __to, const path& __new_hard_link);
+  void create_hard_link(const path& __to, const path& __new_hard_link,
+			error_code& __ec) noexcept;
+
+  void create_symlink(const path& __to, const path& __new_symlink);
+  void create_symlink(const path& __to, const path& __new_symlink,
+		      error_code& __ec) noexcept;
+
+  path current_path();
+  path current_path(error_code& __ec);
+  void current_path(const path& __p);
+  void current_path(const path& __p, error_code& __ec) noexcept;
+
+  inline bool
+  exists(file_status __s) noexcept
+  { return status_known(__s) && __s.type() != file_type::not_found; }
+
+  inline bool
+  exists(const path& __p)
+  { return exists(status(__p)); }
+
+  inline bool
+  exists(const path& __p, error_code& __ec) noexcept
+  { return exists(status(__p, __ec)); }
+
+  bool
+  equivalent(const path& __p1, const path& __p2);
+
+  bool
+  equivalent(const path& __p1, const path& __p2, error_code& __ec) noexcept;
+
+  uintmax_t file_size(const path& __p);
+  uintmax_t file_size(const path& __p, error_code& __ec) noexcept;
+
+  uintmax_t hard_link_count(const path& __p);
+  uintmax_t hard_link_count(const path& __p, error_code& __ec) noexcept;
+
+  inline bool
+  is_block_file(file_status __s) noexcept
+  { return __s.type() == file_type::block; }
+
+  inline bool
+  is_block_file(const path& __p)
+  { return is_block_file(status(__p)); }
+
+  inline bool
+  is_block_file(const path& __p, error_code& __ec) noexcept
+  { return is_block_file(status(__p, __ec)); }
+
+  inline bool
+  is_character_file(file_status __s) noexcept
+  { return __s.type() == file_type::character; }
+
+  inline bool
+  is_character_file(const path& __p)
+  { return is_character_file(status(__p)); }
+
+  inline bool
+  is_character_file(const path& __p, error_code& __ec) noexcept
+  { return is_character_file(status(__p, __ec)); }
+
+  inline bool
+  is_directory(file_status __s) noexcept
+  { return __s.type() == file_type::directory; }
+
+  inline bool
+  is_directory(const path& __p)
+  { return is_directory(status(__p)); }
+
+  inline bool
+  is_directory(const path& __p, error_code& __ec) noexcept
+  { return is_directory(status(__p, __ec)); }
+
+  bool is_empty(const path& __p);
+  bool is_empty(const path& __p, error_code& __ec) noexcept;
+
+  inline bool
+  is_fifo(file_status __s) noexcept
+  { return __s.type() == file_type::fifo; }
+
+  inline bool
+  is_fifo(const path& __p)
+  { return is_fifo(status(__p)); }
+
+  inline bool
+  is_fifo(const path& __p, error_code& __ec) noexcept
+  { return is_fifo(status(__p, __ec)); }
+
+  inline bool
+  is_other(file_status __s) noexcept
+  {
+    return exists(__s) && !is_regular_file(__s) && !is_directory(__s)
+      && !is_symlink(__s);
+  }
+
+  inline bool
+  is_other(const path& __p)
+  { return is_other(status(__p)); }
+
+  inline bool
+  is_other(const path& __p, error_code& __ec) noexcept
+  { return is_other(status(__p, __ec)); }
+
+  inline bool
+  is_regular_file(file_status __s) noexcept
+  { return __s.type() == file_type::regular; }
+
+  inline bool
+  is_regular_file(const path& __p)
+  { return is_regular_file(status(__p)); }
+
+  inline bool
+  is_regular_file(const path& __p, error_code& __ec) noexcept
+  { return is_regular_file(status(__p, __ec)); }
+
+  inline bool
+  is_socket(file_status __s) noexcept
+  { return __s.type() == file_type::socket; }
+
+  inline bool
+  is_socket(const path& __p)
+  { return is_socket(status(__p)); }
+
+  inline bool
+  is_socket(const path& __p, error_code& __ec) noexcept
+  { return is_socket(status(__p, __ec)); }
+
+  inline bool
+  is_symlink(file_status __s) noexcept
+  { return __s.type() == file_type::symlink; }
+
+  inline bool
+  is_symlink(const path& __p)
+  { return is_symlink(symlink_status(__p)); }
+
+  inline bool
+  is_symlink(const path& __p, error_code& __ec) noexcept
+  { return is_symlink(symlink_status(__p, __ec)); }
+
+  file_time_type  last_write_time(const path& __p);
+  file_time_type  last_write_time(const path& __p, error_code& __ec) noexcept;
+  void last_write_time(const path& __p, file_time_type __new_time);
+  void last_write_time(const path& __p, file_time_type __new_time,
+		       error_code& __ec) noexcept;
+
+  void permissions(const path& __p, perms __prms);
+  void permissions(const path& __p, perms __prms, error_code& __ec) noexcept;
+
+  path read_symlink(const path& __p);
+  path read_symlink(const path& __p, error_code& __ec);
+
+  bool remove(const path& __p);
+  bool remove(const path& __p, error_code& __ec) noexcept;
+
+  uintmax_t remove_all(const path& __p);
+  uintmax_t remove_all(const path& __p, error_code& __ec) noexcept;
+
+  void rename(const path& __from, const path& __to);
+  void rename(const path& __from, const path& __to, error_code& __ec) noexcept;
+
+  void resize_file(const path& __p, uintmax_t __size);
+  void resize_file(const path& __p, uintmax_t __size, error_code& __ec) noexcept;
+
+  space_info space(const path& __p);
+  space_info space(const path& __p, error_code& __ec) noexcept;
+
+  file_status status(const path& __p);
+  file_status status(const path& __p, error_code& __ec) noexcept;
+
+  inline bool status_known(file_status __s) noexcept
+  { return __s.type() != file_type::none; }
+
+  file_status symlink_status(const path& __p);
+  file_status symlink_status(const path& __p, error_code& __ec) noexcept;
+
+  path system_complete(const path& __p);
+  path system_complete(const path& __p, error_code& __ec);
+
+  path temp_directory_path();
+  path temp_directory_path(error_code& __ec);
+
+  // @} group filesystem
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace v1
+} // namespace filesystem
+} // namespace experimental
+} // namespace std
+
+#endif // C++11
+
+#endif // _GLIBCXX_EXPERIMENTAL_FS_OPS_H
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/experimental/fs_path.h gcc-5.2.0/libstdc++-v3/include/experimental/fs_path.h
--- gcc-5.2.0.orig/libstdc++-v3/include/experimental/fs_path.h	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/experimental/fs_path.h	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,1024 @@
+// Class filesystem::path -*- C++ -*-
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file experimental/fs_path.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{experimental/filesystem}
+ */
+
+#ifndef _GLIBCXX_EXPERIMENTAL_FS_PATH_H
+#define _GLIBCXX_EXPERIMENTAL_FS_PATH_H 1
+
+#if __cplusplus < 201103L
+# include <bits/c++0x_warning.h>
+#else
+
+#include <utility>
+#include <type_traits>
+#include <vector>
+#include <locale>
+#include <iosfwd>
+#include <codecvt>
+#include <system_error>
+#include <bits/stl_algobase.h>
+#include <bits/quoted_string.h>
+#include <bits/locale_conv.h>
+
+#if defined(_WIN32) && !defined(__CYGWIN__)
+# define _GLIBCXX_FILESYSTEM_IS_WINDOWS 1
+# include <algorithm>
+#endif
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+namespace experimental
+{
+namespace filesystem
+{
+inline namespace v1
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+_GLIBCXX_BEGIN_NAMESPACE_CXX11
+
+  /**
+   * @ingroup filesystem
+   * @{
+   */
+
+  /// A filesystem path.
+  class path
+  {
+    template<typename _CharT>
+      struct __is_encoded_char : std::false_type { };
+
+    template<typename _Iter,
+	     typename _Iter_traits = std::iterator_traits<_Iter>>
+      using __is_path_iter_src
+	= __and_<__is_encoded_char<typename _Iter_traits::value_type>,
+		 std::is_base_of<std::input_iterator_tag,
+				 typename _Iter_traits::iterator_category>>;
+
+    template<typename _Iter>
+      static __is_path_iter_src<_Iter>
+      __is_path_src(_Iter, int);
+
+    template<typename _CharT, typename _Traits, typename _Alloc>
+      static __is_encoded_char<_CharT>
+      __is_path_src(const basic_string<_CharT, _Traits, _Alloc>&, int);
+
+    template<typename _Unknown>
+      static std::false_type
+      __is_path_src(const _Unknown&, ...);
+
+    template<typename _Tp1, typename _Tp2>
+      struct __constructible_from;
+
+    template<typename _Iter>
+      struct __constructible_from<_Iter, _Iter>
+      : __is_path_iter_src<_Iter>
+      { };
+
+    template<typename _Source>
+      struct __constructible_from<_Source, void>
+      : decltype(__is_path_src(std::declval<_Source>(), 0))
+      { };
+
+    template<typename _Tp1, typename _Tp2 = void>
+      using _Path = typename
+	std::enable_if<__and_<__not_<is_same<_Tp1, path>>,
+			      __constructible_from<_Tp1, _Tp2>>::value,
+		       path>::type;
+
+    template<typename _Source>
+      static _Source
+      _S_range_begin(_Source __begin) { return __begin; }
+
+    struct __null_terminated { };
+
+    template<typename _Source>
+      static __null_terminated
+      _S_range_end(_Source) { return {}; }
+
+    template<typename _CharT, typename _Traits, typename _Alloc>
+      static const _CharT*
+      _S_range_begin(const basic_string<_CharT, _Traits, _Alloc>& __str)
+      { return __str.data(); }
+
+    template<typename _CharT, typename _Traits, typename _Alloc>
+      static const _CharT*
+      _S_range_end(const basic_string<_CharT, _Traits, _Alloc>& __str)
+      { return __str.data() + __str.size(); }
+
+    template<typename _Tp,
+	     typename _Iter = decltype(_S_range_begin(std::declval<_Tp>())),
+	     typename _Val = typename std::iterator_traits<_Iter>::value_type>
+      using __value_type_is_char
+	= typename std::enable_if<std::is_same<_Val, char>::value>::type;
+
+  public:
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+    typedef wchar_t				value_type;
+    static constexpr value_type			preferred_separator = L'\\';
+#else
+    typedef char				value_type;
+    static constexpr value_type			preferred_separator = '/';
+#endif
+    typedef std::basic_string<value_type>	string_type;
+
+    // constructors and destructor
+
+    path() noexcept { }
+
+    path(const path& __p) = default;
+
+    path(path&& __p) noexcept
+    : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)
+    {
+      _M_split_cmpts();
+      __p.clear();
+    }
+
+    template<typename _Source,
+	     typename _Require = _Path<_Source>>
+      path(_Source const& __source)
+      : _M_pathname(_S_convert(_S_range_begin(__source),
+			       _S_range_end(__source)))
+      { _M_split_cmpts(); }
+
+    template<typename _InputIterator,
+	     typename _Require = _Path<_InputIterator, _InputIterator>>
+      path(_InputIterator __first, _InputIterator __last)
+      : _M_pathname(_S_convert(__first, __last))
+      { _M_split_cmpts(); }
+
+    template<typename _Source,
+	     typename _Require = _Path<_Source>,
+	     typename _Require2 = __value_type_is_char<_Source>>
+      path(_Source const& __source, const locale& __loc)
+      : _M_pathname(_S_convert_loc(_S_range_begin(__source),
+				   _S_range_end(__source), __loc))
+      { _M_split_cmpts(); }
+
+    template<typename _InputIterator,
+	     typename _Require = _Path<_InputIterator, _InputIterator>,
+	     typename _Require2 = __value_type_is_char<_InputIterator>>
+      path(_InputIterator __first, _InputIterator __last, const locale& __loc)
+      : _M_pathname(_S_convert_loc(__first, __last, __loc))
+      { _M_split_cmpts(); }
+
+    ~path() = default;
+
+    // assignments
+
+    path& operator=(const path& __p) = default;
+    path& operator=(path&& __p) noexcept;
+
+    template<typename _Source>
+      _Path<_Source>&
+      operator=(_Source const& __source)
+      { return *this = path(__source); }
+
+    template<typename _Source>
+      _Path<_Source>&
+      assign(_Source const& __source)
+      { return *this = path(__source); }
+
+    template<typename _InputIterator>
+      _Path<_InputIterator, _InputIterator>&
+      assign(_InputIterator __first, _InputIterator __last)
+      { return *this = path(__first, __last); }
+
+    // appends
+
+    path& operator/=(const path& __p) { return _M_append(__p._M_pathname); }
+
+    template <class _Source>
+      _Path<_Source>&
+      operator/=(_Source const& __source)
+      { return append(__source); }
+
+    template<typename _Source>
+      _Path<_Source>&
+      append(_Source const& __source)
+      {
+	return _M_append(_S_convert(_S_range_begin(__source),
+				    _S_range_end(__source)));
+      }
+
+    template<typename _InputIterator>
+      _Path<_InputIterator, _InputIterator>&
+      append(_InputIterator __first, _InputIterator __last)
+      { return _M_append(_S_convert(__first, __last)); }
+
+    // concatenation
+
+    path& operator+=(const path& __x);
+    path& operator+=(const string_type& __x);
+    path& operator+=(const value_type* __x);
+    path& operator+=(value_type __x);
+
+    template<typename _Source>
+      _Path<_Source>&
+      operator+=(_Source const& __x) { return concat(__x); }
+
+    template<typename _CharT>
+      _Path<_CharT*, _CharT*>&
+      operator+=(_CharT __x);
+
+    template<typename _Source>
+      _Path<_Source>&
+      concat(_Source const& __x)
+      { return *this += _S_convert(_S_range_begin(__x), _S_range_end(__x)); }
+
+    template<typename _InputIterator>
+      _Path<_InputIterator, _InputIterator>&
+      concat(_InputIterator __first, _InputIterator __last)
+      { return *this += _S_convert(__first, __last); }
+
+    // modifiers
+
+    void clear() noexcept { _M_pathname.clear(); _M_split_cmpts(); }
+
+    path& make_preferred();
+    path& remove_filename();
+    path& replace_filename(const path& __replacement);
+    path& replace_extension(const path& __replacement = path());
+
+    void swap(path& __rhs) noexcept;
+
+    // native format observers
+
+    const string_type&  native() const noexcept { return _M_pathname; }
+    const value_type*   c_str() const noexcept { return _M_pathname.c_str(); }
+    operator string_type() const { return _M_pathname; }
+
+    template<typename _CharT, typename _Traits = std::char_traits<_CharT>,
+	     typename _Allocator = std::allocator<_CharT>>
+      std::basic_string<_CharT, _Traits, _Allocator>
+      string(const _Allocator& __a = _Allocator()) const;
+
+    std::string    string() const;
+#if _GLIBCXX_USE_WCHAR_T
+    std::wstring   wstring() const;
+#endif
+    std::string    u8string() const;
+    std::u16string u16string() const;
+    std::u32string u32string() const;
+
+    // generic format observers
+    template<typename _CharT, typename _Traits = std::char_traits<_CharT>,
+	     typename _Allocator = std::allocator<_CharT>>
+      std::basic_string<_CharT, _Traits, _Allocator>
+      generic_string(const _Allocator& __a = _Allocator()) const;
+
+    std::string    generic_string() const;
+#if _GLIBCXX_USE_WCHAR_T
+    std::wstring   generic_wstring() const;
+#endif
+    std::string    generic_u8string() const;
+    std::u16string generic_u16string() const;
+    std::u32string generic_u32string() const;
+
+    // compare
+
+    int compare(const path& __p) const noexcept;
+    int compare(const string_type& __s) const;
+    int compare(const value_type* __s) const;
+
+    // decomposition
+
+    path root_name() const;
+    path root_directory() const;
+    path root_path() const;
+    path relative_path() const;
+    path parent_path() const;
+    path filename() const;
+    path stem() const;
+    path extension() const;
+
+    // query
+
+    bool empty() const noexcept { return _M_pathname.empty(); }
+    bool has_root_name() const;
+    bool has_root_directory() const;
+    bool has_root_path() const;
+    bool has_relative_path() const;
+    bool has_parent_path() const;
+    bool has_filename() const;
+    bool has_stem() const;
+    bool has_extension() const;
+    bool is_absolute() const;
+    bool is_relative() const { return !is_absolute(); }
+
+    // iterators
+    class iterator;
+    typedef iterator const_iterator;
+
+    iterator begin() const;
+    iterator end() const;
+
+  private:
+    enum class _Type : unsigned char {
+	_Multi, _Root_name, _Root_dir, _Filename
+    };
+
+    path(string_type __str, _Type __type) : _M_pathname(__str), _M_type(__type)
+    {
+      _GLIBCXX_DEBUG_ASSERT(!empty());
+      _GLIBCXX_DEBUG_ASSERT(_M_type != _Type::_Multi);
+    }
+
+    enum class _Split { _Stem, _Extension };
+
+    path& _M_append(const string_type& __str)
+    {
+      if (!_M_pathname.empty() && !_S_is_dir_sep(_M_pathname.back())
+	  && !__str.empty() && !_S_is_dir_sep(__str.front()))
+	_M_pathname += preferred_separator;
+      _M_pathname += __str;
+      _M_split_cmpts();
+      return *this;
+    }
+
+    pair<const string_type*, size_t> _M_find_extension() const;
+
+    template<typename _CharT>
+      struct _Cvt;
+
+    static string_type
+    _S_convert(value_type* __src, __null_terminated)
+    { return string_type(__src); }
+
+    static string_type
+    _S_convert(const value_type* __src, __null_terminated)
+    { return string_type(__src); }
+
+    template<typename _Iter>
+      static string_type
+      _S_convert(_Iter __first, _Iter __last)
+      {
+	using __value_type = typename std::iterator_traits<_Iter>::value_type;
+	return _Cvt<__value_type>::_S_convert(__first, __last);
+      }
+
+    template<typename _InputIterator>
+      static string_type
+      _S_convert(_InputIterator __src, __null_terminated)
+      {
+	using _Tp = typename std::iterator_traits<_InputIterator>::value_type;
+	std::basic_string<_Tp> __tmp;
+	while (*__src != _Tp{})
+	  __tmp.push_back(*__src++);
+	return _S_convert(__tmp.data(), __tmp.data() + __tmp.size());
+      }
+
+    static string_type
+    _S_convert_loc(const char* __first, const char* __last,
+		   const std::locale& __loc);
+
+    template<typename _Iter>
+      static string_type
+      _S_convert_loc(_Iter __first, _Iter __last, const std::locale& __loc)
+      {
+	const std::string __str(__first, __last);
+	return _S_convert_loc(__str.data(), __str.data()+__str.size(), __loc);
+      }
+
+    template<typename _InputIterator>
+      static string_type
+      _S_convert_loc(_InputIterator __src, __null_terminated,
+		     const std::locale& __loc)
+      {
+	std::string __tmp;
+	while (*__src != '\0')
+	  __tmp.push_back(*__src++);
+	return _S_convert_loc(__tmp.data(), __tmp.data()+__tmp.size(), __loc);
+      }
+
+    bool _S_is_dir_sep(value_type __ch)
+    {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      return __ch == L'/' || __ch == preferred_separator;
+#else
+      return __ch == '/';
+#endif
+    }
+
+    void _M_split_cmpts();
+    void _M_trim();
+    void _M_add_root_name(size_t __n);
+    void _M_add_root_dir(size_t __pos);
+    void _M_add_filename(size_t __pos, size_t __n);
+
+    string_type _M_pathname;
+
+    struct _Cmpt;
+    using _List = _GLIBCXX_STD_C::vector<_Cmpt>;
+    _List _M_cmpts; // empty unless _M_type == _Type::_Multi
+    _Type _M_type = _Type::_Multi;
+  };
+
+  inline void swap(path& __lhs, path& __rhs) noexcept { __lhs.swap(__rhs); }
+
+  size_t hash_value(const path& __p) noexcept;
+
+  /// Compare paths
+  inline bool operator<(const path& __lhs, const path& __rhs) noexcept
+  { return __lhs.compare(__rhs) < 0; }
+
+  /// Compare paths
+  inline bool operator<=(const path& __lhs, const path& __rhs) noexcept
+  { return !(__rhs < __lhs); }
+
+  /// Compare paths
+  inline bool operator>(const path& __lhs, const path& __rhs) noexcept
+  { return __rhs < __lhs; }
+
+  /// Compare paths
+  inline bool operator>=(const path& __lhs, const path& __rhs) noexcept
+  { return !(__lhs < __rhs); }
+
+  /// Compare paths
+  inline bool operator==(const path& __lhs, const path& __rhs) noexcept
+  { return __lhs.compare(__rhs) == 0; }
+
+  /// Compare paths
+  inline bool operator!=(const path& __lhs, const path& __rhs) noexcept
+  { return !(__lhs == __rhs); }
+
+  /// Append one path to another
+  inline path operator/(const path& __lhs, const path& __rhs)
+  { return path(__lhs) /= __rhs; }
+
+  /// Write a path to a stream
+  template<typename _CharT, typename _Traits>
+    basic_ostream<_CharT, _Traits>&
+    operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p)
+    {
+      auto __tmp = __p.string<_CharT, _Traits>();
+      using __quoted_string
+	= std::__detail::_Quoted_string<decltype(__tmp)&, _CharT>;
+      __os << __quoted_string{__tmp, '"', '\\'};
+      return __os;
+    }
+
+  /// Read a path from a stream
+  template<typename _CharT, typename _Traits>
+    basic_istream<_CharT, _Traits>&
+    operator>>(basic_istream<_CharT, _Traits>& __is, path& __p)
+    {
+      basic_string<_CharT, _Traits> __tmp;
+      using __quoted_string
+	= std::__detail::_Quoted_string<decltype(__tmp)&, _CharT>;
+      if (__is >> __quoted_string{ __tmp, '"', '\\' })
+	__p = std::move(__tmp);
+      return __is;
+    }
+
+  // TODO constrain with _Path<Source> and __value_type_is_char
+  template<typename _Source>
+    inline path
+    u8path(const _Source& __source)
+    {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      return path{ path::string_type{__source} };
+#else
+      return path{ __source };
+#endif
+    }
+
+  // TODO constrain with _Path<InputIterator, InputIterator> and __value_type_is_char
+  template<typename _InputIterator>
+    inline path
+    u8path(_InputIterator __first, _InputIterator __last)
+    {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      return path{ path::string_type{__first, __last} };
+#else
+      return path{ __first, __last };
+#endif
+    }
+
+  class filesystem_error : public std::system_error
+  {
+  public:
+    filesystem_error(const string& __what_arg, error_code __ec)
+    : system_error(__ec, __what_arg) { }
+
+    filesystem_error(const string& __what_arg, const path& __p1,
+		     error_code __ec)
+    : system_error(__ec, __what_arg), _M_path1(__p1) { }
+
+    filesystem_error(const string& __what_arg, const path& __p1,
+		     const path& __p2, error_code __ec)
+    : system_error(__ec, __what_arg), _M_path1(__p1), _M_path2(__p2)
+    { }
+
+    ~filesystem_error();
+
+    const path& path1() const noexcept { return _M_path1; }
+    const path& path2() const noexcept { return _M_path2; }
+    const char* what() const noexcept { return _M_what.c_str(); }
+
+  private:
+    std::string _M_gen_what();
+
+    path _M_path1;
+    path _M_path2;
+    std::string _M_what = _M_gen_what();
+  };
+
+  struct path::_Cmpt : path
+  {
+    _Cmpt(string_type __s, _Type __t, size_t __pos)
+      : path(std::move(__s), __t), _M_pos(__pos) { }
+
+    _Cmpt() : _M_pos(-1) { }
+
+    size_t _M_pos;
+  };
+
+  template<>
+    struct path::__is_encoded_char<char> : std::true_type
+    { using value_type = char; };
+
+  template<>
+    struct path::__is_encoded_char<wchar_t> : std::true_type
+    { using value_type = wchar_t; };
+
+  template<>
+    struct path::__is_encoded_char<char16_t> : std::true_type
+    { using value_type = char16_t; };
+
+  template<>
+    struct path::__is_encoded_char<char32_t> : std::true_type
+    { using value_type = char32_t; };
+
+  // specialize _Cvt for degenerate 'noconv' case
+  template<>
+    struct path::_Cvt<path::value_type>
+    {
+      template<typename _Iter>
+	static string_type
+	_S_convert(_Iter __first, _Iter __last)
+	{ return string_type{__first, __last}; }
+    };
+
+  template<typename _CharT>
+    struct path::_Cvt
+    {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      static string_type
+      _S_wconvert(const char* __f, const char* __l, true_type)
+      {
+	using _Cvt = std::codecvt<wchar_t, char, mbstate_t>;
+	const auto& __cvt = std::use_facet<_Cvt>(std::locale{});
+	std::wstring __wstr;
+	if (__str_codecvt_in(__f, __l, __wstr, __cvt))
+	    return __wstr;
+	_GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	      "Cannot convert character sequence",
+	      std::make_error_code(errc::illegal_byte_sequence)));
+      }
+
+      static string_type
+      _S_wconvert(const _CharT* __f, const _CharT* __l, false_type)
+      {
+	std::codecvt_utf8<_CharT> __cvt;
+	std::string __str;
+	if (__str_codecvt_out(__f, __l, __str, __cvt))
+	  {
+	    const char* __f2 = __str.data();
+	    const char* __l2 = __f2 + __str.size();
+	    std::codecvt_utf8<wchar_t> __wcvt;
+	    std::wstring __wstr;
+	    if (__str_codecvt_in(__f2, __l2, __wstr, __wcvt))
+	      return __wstr;
+	  }
+	_GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	      "Cannot convert character sequence",
+	      std::make_error_code(errc::illegal_byte_sequence)));
+      }
+
+      static string_type
+      _S_convert(const _CharT* __f, const _CharT* __l)
+      {
+	return _S_wconvert(__f, __l, is_same<_CharT, char>{});
+      }
+#else
+      static string_type
+      _S_convert(const _CharT* __f, const _CharT* __l)
+      {
+	std::codecvt_utf8<_CharT> __cvt;
+	std::string __str;
+	if (__str_codecvt_out(__f, __l, __str, __cvt))
+	  return __str;
+	_GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	      "Cannot convert character sequence",
+	      std::make_error_code(errc::illegal_byte_sequence)));
+      }
+#endif
+
+      static string_type
+      _S_convert(_CharT* __f, _CharT* __l)
+      {
+	return _S_convert(const_cast<const _CharT*>(__f),
+			  const_cast<const _CharT*>(__l));
+      }
+
+      template<typename _Iter>
+	static string_type
+	_S_convert(_Iter __first, _Iter __last)
+	{
+	  const std::basic_string<_CharT> __str(__first, __last);
+	  return _S_convert(__str.data(), __str.data() + __str.size());
+	}
+
+      template<typename _Iter, typename _Cont>
+	static string_type
+	_S_convert(__gnu_cxx::__normal_iterator<_Iter, _Cont> __first,
+		  __gnu_cxx::__normal_iterator<_Iter, _Cont> __last)
+	{ return _S_convert(__first.base(), __last.base()); }
+    };
+
+  /// An iterator for the components of a path
+  class path::iterator
+  {
+  public:
+    using difference_type	= std::ptrdiff_t;
+    using value_type		= path;
+    using reference		= const path&;
+    using pointer		= const path*;
+    using iterator_category	= std::bidirectional_iterator_tag;
+
+    iterator() : _M_path(nullptr), _M_cur(), _M_at_end() { }
+
+    iterator(const iterator&) = default;
+    iterator& operator=(const iterator&) = default;
+
+    reference operator*() const;
+    pointer   operator->() const { return std::__addressof(**this); }
+
+    iterator& operator++();
+    iterator  operator++(int) { auto __tmp = *this; ++_M_cur; return __tmp; }
+
+    iterator& operator--();
+    iterator  operator--(int) { auto __tmp = *this; --_M_cur; return __tmp; }
+
+    friend bool operator==(const iterator& __lhs, const iterator& __rhs)
+    { return __lhs._M_equals(__rhs); }
+
+    friend bool operator!=(const iterator& __lhs, const iterator& __rhs)
+    { return !__lhs._M_equals(__rhs); }
+
+  private:
+    friend class path;
+
+    iterator(const path* __path, path::_List::const_iterator __iter)
+    : _M_path(__path), _M_cur(__iter), _M_at_end()
+    { }
+
+    iterator(const path* __path, bool __at_end)
+    : _M_path(__path), _M_cur(), _M_at_end(__at_end)
+    { }
+
+    bool _M_equals(iterator) const;
+
+    const path* 		_M_path;
+    path::_List::const_iterator _M_cur;
+    bool			_M_at_end;  // only used when type != _Multi
+  };
+
+
+  inline path&
+  path::operator=(path&& __p) noexcept
+  {
+    _M_pathname = std::move(__p._M_pathname);
+    _M_cmpts = std::move(__p._M_cmpts);
+    _M_type = __p._M_type;
+    __p.clear();
+    return *this;
+  }
+
+  inline path&
+  path::operator+=(const path& __p)
+  {
+    return operator+=(__p.native());
+  }
+
+  inline path&
+  path::operator+=(const string_type& __x)
+  {
+    _M_pathname += __x;
+    _M_split_cmpts();
+    return *this;
+  }
+
+  inline path&
+  path::operator+=(const value_type* __x)
+  {
+    _M_pathname += __x;
+    _M_split_cmpts();
+    return *this;
+  }
+
+  inline path&
+  path::operator+=(value_type __x)
+  {
+    _M_pathname += __x;
+    _M_split_cmpts();
+    return *this;
+  }
+
+  template<typename _CharT>
+    inline path::_Path<_CharT*, _CharT*>&
+    path::operator+=(_CharT __x)
+    {
+      auto* __addr = std::__addressof(__x);
+      return concat(__addr, __addr + 1);
+    }
+
+  inline path&
+  path::make_preferred()
+  {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+    std::replace(_M_pathname.begin(), _M_pathname.end(), L'/',
+		 preferred_separator);
+#endif
+    return *this;
+  }
+
+  inline void path::swap(path& __rhs) noexcept
+  {
+    _M_pathname.swap(__rhs._M_pathname);
+    _M_cmpts.swap(__rhs._M_cmpts);
+    std::swap(_M_type, __rhs._M_type);
+  }
+
+  template<typename _CharT, typename _Traits, typename _Allocator>
+    inline std::basic_string<_CharT, _Traits, _Allocator>
+    path::string(const _Allocator& __a) const
+    {
+      if (is_same<_CharT, value_type>::value)
+	return { _M_pathname.begin(), _M_pathname.end(), __a };
+
+      const value_type* __first = _M_pathname.data();
+      const value_type* __last = __first + _M_pathname.size();
+
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      using _CharAlloc = __alloc_rebind<_Allocator, char>;
+      using _String = basic_string<char, char_traits<char>, _CharAlloc>;
+      using _WString = basic_string<_CharT, _Traits, _Allocator>;
+
+      // use codecvt_utf8<wchar_t> to convert native string to UTF-8
+      codecvt_utf8<value_type> __cvt;
+      _String __u8str{_CharAlloc{__a}};
+      if (__str_codecvt_out(__first, __last, __u8str, __cvt))
+	{
+	  struct
+	  {
+	    const _String*
+	    operator()(const _String& __from, _String&, true_type)
+	    { return std::__addressof(__from); }
+
+	    _WString*
+	    operator()(const _String& __from, _WString& __to, false_type)
+	    {
+	      // use codecvt_utf8<_CharT> to convert UTF-8 to wide string
+	      codecvt_utf8<_CharT> __cvt;
+	      const char* __f = __from.data();
+	      const char* __l = __f + __from.size();
+	      if (__str_codecvt_in(__f, __l, __to, __cvt))
+		return std::__addressof(__to);
+	      return nullptr;
+	    }
+	  } __dispatch;
+	  _WString __wstr;
+	  if (auto* __p = __dispatch(__u8str, __wstr, is_same<_CharT, char>{}))
+	    return *__p;
+	}
+#else
+      codecvt_utf8<_CharT> __cvt;
+      basic_string<_CharT, _Traits, _Allocator> __wstr{__a};
+      if (__str_codecvt_in(__first, __last, __wstr, __cvt))
+	return __wstr;
+#endif
+      _GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	    "Cannot convert character sequence",
+	    std::make_error_code(errc::illegal_byte_sequence)));
+    }
+
+  inline std::string
+  path::string() const { return string<char>(); }
+
+#if _GLIBCXX_USE_WCHAR_T
+  inline std::wstring
+  path::wstring() const { return string<wchar_t>(); }
+#endif
+
+  inline std::string
+  path::u8string() const
+  {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+    std::string __str;
+    // convert from native encoding to UTF-8
+    codecvt_utf8<value_type> __cvt;
+    const value_type* __first = _M_pathname.data();
+    const value_type* __last = __first + _M_pathname.size();
+    if (__str_codecvt_out(__first, __last, __str, __cvt))
+      return __str;
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	  "Cannot convert character sequence",
+	  std::make_error_code(errc::illegal_byte_sequence)));
+#else
+    return _M_pathname;
+#endif
+  }
+
+  inline std::u16string
+  path::u16string() const { return string<char16_t>(); }
+
+  inline std::u32string
+  path::u32string() const { return string<char32_t>(); }
+
+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  template<typename _CharT, typename _Traits, typename _Allocator>
+    inline std::basic_string<_CharT, _Traits, _Allocator>
+    path::generic_string(const _Allocator& __a) const
+    { return string<_CharT, _Traits, _Allocator>(__a); }
+
+  inline std::string
+  path::generic_string() const { return string(); }
+
+#if _GLIBCXX_USE_WCHAR_T
+  inline std::wstring
+  path::generic_wstring() const { return wstring(); }
+#endif
+
+  inline std::string
+  path::generic_u8string() const { return u8string(); }
+
+  inline std::u16string
+  path::generic_u16string() const { return u16string(); }
+
+  inline std::u32string
+  path::generic_u32string() const { return u32string(); }
+#endif
+
+  inline int
+  path::compare(const string_type& __s) const { return compare(path(__s)); }
+
+  inline int
+  path::compare(const value_type* __s) const { return compare(path(__s)); }
+
+  inline path
+  path::filename() const { return empty() ? path() : *--end(); }
+
+  inline path
+  path::stem() const
+  {
+    auto ext = _M_find_extension();
+    if (ext.first && ext.second != 0)
+      return path{ext.first->substr(0, ext.second)};
+    return {};
+  }
+
+  inline path
+  path::extension() const
+  {
+    auto ext = _M_find_extension();
+    if (ext.first && ext.second != string_type::npos)
+      return path{ext.first->substr(ext.second)};
+    return {};
+  }
+
+  inline bool
+  path::has_stem() const
+  {
+    auto ext = _M_find_extension();
+    return ext.first && ext.second != 0;
+  }
+
+  inline bool
+  path::has_extension() const
+  {
+    auto ext = _M_find_extension();
+    return ext.first && ext.second != string_type::npos;
+  }
+
+  inline bool
+  path::is_absolute() const
+  {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+    return has_root_name();
+#else
+    return has_root_directory();
+#endif
+  }
+
+  inline path::iterator
+  path::begin() const
+  {
+    if (_M_type == _Type::_Multi)
+      return iterator(this, _M_cmpts.begin());
+    return iterator(this, false);
+  }
+
+  inline path::iterator
+  path::end() const
+  {
+    if (_M_type == _Type::_Multi)
+      return iterator(this, _M_cmpts.end());
+    return iterator(this, true);
+  }
+
+  inline path::iterator&
+  path::iterator::operator++()
+  {
+    _GLIBCXX_DEBUG_ASSERT(_M_path != nullptr);
+    if (_M_path->_M_type == _Type::_Multi)
+      {
+	_GLIBCXX_DEBUG_ASSERT(_M_cur != _M_path->_M_cmpts.end());
+	++_M_cur;
+      }
+    else
+      {
+	_GLIBCXX_DEBUG_ASSERT(!_M_at_end);
+	_M_at_end = true;
+      }
+    return *this;
+  }
+
+  inline path::iterator&
+  path::iterator::operator--()
+  {
+    _GLIBCXX_DEBUG_ASSERT(_M_path != nullptr);
+    if (_M_path->_M_type == _Type::_Multi)
+      {
+	_GLIBCXX_DEBUG_ASSERT(_M_cur != _M_path->_M_cmpts.begin());
+	--_M_cur;
+      }
+    else
+      {
+	_GLIBCXX_DEBUG_ASSERT(_M_at_end);
+	_M_at_end = false;
+      }
+    return *this;
+  }
+
+  inline path::iterator::reference
+  path::iterator::operator*() const
+  {
+    _GLIBCXX_DEBUG_ASSERT(_M_path != nullptr);
+    if (_M_path->_M_type == _Type::_Multi)
+      {
+	_GLIBCXX_DEBUG_ASSERT(_M_cur != _M_path->_M_cmpts.end());
+	return *_M_cur;
+      }
+    return *_M_path;
+  }
+
+  inline bool
+  path::iterator::_M_equals(iterator __rhs) const
+  {
+    if (_M_path != __rhs._M_path)
+      return false;
+    if (_M_path == nullptr)
+      return true;
+    if (_M_path->_M_type == path::_Type::_Multi)
+      return _M_cur == __rhs._M_cur;
+    return _M_at_end == __rhs._M_at_end;
+  }
+
+  // @} group filesystem
+_GLIBCXX_END_NAMESPACE_CXX11
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace v1
+} // namespace filesystem
+} // namespace experimental
+} // namespace std
+
+#endif // C++11
+
+#endif // _GLIBCXX_EXPERIMENTAL_FS_PATH_H
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/experimental/functional gcc-5.2.0/libstdc++-v3/include/experimental/functional
--- gcc-5.2.0.orig/libstdc++-v3/include/experimental/functional	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/experimental/functional	2015-09-03 10:10:52.511551000 -0500
@@ -376,8 +376,11 @@
 
   /// Generalized negator.
   template<typename _Fn>
-    struct _Not_fn
+    class _Not_fn
     {
+      _Fn _M_fn;
+
+    public:
       template<typename _Fn2>
 	explicit
 	_Not_fn(_Fn2&& __fn) : _M_fn(std::forward<_Fn2>(__fn)) { }
@@ -389,34 +392,43 @@
       ~_Not_fn() = default;
 
       template<typename... _Args>
-	decltype(auto)
+	auto
 	operator()(_Args&&... __args)
+	noexcept(noexcept(!_M_fn(std::forward<_Args>(__args)...)))
+	-> decltype(!_M_fn(std::forward<_Args>(__args)...))
 	{ return !_M_fn(std::forward<_Args>(__args)...); }
 
       template<typename... _Args>
-	decltype(auto)
+	auto
 	operator()(_Args&&... __args) const
+	noexcept(noexcept(!_M_fn(std::forward<_Args>(__args)...)))
+	-> decltype(!_M_fn(std::forward<_Args>(__args)...))
 	{ return !_M_fn(std::forward<_Args>(__args)...); }
 
       template<typename... _Args>
-	decltype(auto)
+	auto
 	operator()(_Args&&... __args) volatile
+	noexcept(noexcept(!_M_fn(std::forward<_Args>(__args)...)))
+	-> decltype(!_M_fn(std::forward<_Args>(__args)...))
 	{ return !_M_fn(std::forward<_Args>(__args)...); }
 
       template<typename... _Args>
-	decltype(auto)
+	auto
 	operator()(_Args&&... __args) const volatile
+	noexcept(noexcept(!_M_fn(std::forward<_Args>(__args)...)))
+	-> decltype(!_M_fn(std::forward<_Args>(__args)...))
 	{ return !_M_fn(std::forward<_Args>(__args)...); }
-
-    private:
-      _Fn _M_fn;
     };
 
   /// [func.not_fn] Function template not_fn
-  template <class _Fn>
+  template<typename _Fn>
     inline auto
     not_fn(_Fn&& __fn)
-    { return _Not_fn<std::decay_t<_Fn>>{std::forward<_Fn>(__fn)}; }
+    noexcept(std::is_nothrow_constructible<std::decay_t<_Fn>, _Fn&&>::value)
+    {
+      using __maybe_type = _Maybe_wrap_member_pointer<std::decay_t<_Fn>>;
+      return _Not_fn<typename __maybe_type::type>{std::forward<_Fn>(__fn)};
+    }
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace fundamentals_v2
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/ext/pod_char_traits.h gcc-5.2.0/libstdc++-v3/include/ext/pod_char_traits.h
--- gcc-5.2.0.orig/libstdc++-v3/include/ext/pod_char_traits.h	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/ext/pod_char_traits.h	2015-10-02 15:08:17.234342000 -0500
@@ -144,6 +144,8 @@
       static char_type*
       move(char_type* __s1, const char_type* __s2, size_t __n)
       { 
+	if (__n == 0)
+	  return __s1;
 	return static_cast<char_type*>
 	  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type)));
       }
@@ -151,6 +153,8 @@
       static char_type*
       copy(char_type* __s1, const char_type* __s2, size_t __n)
       {
+	if (__n == 0)
+	  return __s1;
 	std::copy(__s2, __s2 + __n, __s1);
 	return __s1;
       }
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/Makefile.am gcc-5.2.0/libstdc++-v3/include/Makefile.am
--- gcc-5.2.0.orig/libstdc++-v3/include/Makefile.am	2015-01-16 17:38:48.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/Makefile.am	2015-08-18 12:58:22.597022000 -0500
@@ -128,6 +128,7 @@
 	${bits_srcdir}/postypes.h \
 	${bits_srcdir}/predefined_ops.h \
 	${bits_srcdir}/ptr_traits.h \
+	${bits_srcdir}/quoted_string.h \
 	${bits_srcdir}/random.h \
 	${bits_srcdir}/random.tcc \
 	${bits_srcdir}/range_access.h \
@@ -650,10 +651,22 @@
 	${experimental_srcdir}/optional \
 	${experimental_srcdir}/ratio \
 	${experimental_srcdir}/string_view \
-	${experimental_srcdir}/system_error \
 	${experimental_srcdir}/string_view.tcc \
+	${experimental_srcdir}/system_error \
 	${experimental_srcdir}/tuple \
-	${experimental_srcdir}/type_traits
+	${experimental_srcdir}/type_traits \
+	${experimental_filesystem_headers}
+
+if ENABLE_FILESYSTEM_TS
+experimental_filesystem_headers = \
+	${experimental_srcdir}/filesystem \
+	${experimental_srcdir}/fs_dir.h \
+	${experimental_srcdir}/fs_fwd.h \
+	${experimental_srcdir}/fs_ops.h \
+	${experimental_srcdir}/fs_path.h
+else
+experimental_filesystem_headers =
+endif
 
 # This is the common subset of C++ files that all three "C" header models use.
 c_base_srcdir = $(C_INCLUDE_DIR)
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/Makefile.in gcc-5.2.0/libstdc++-v3/include/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/include/Makefile.in	2015-01-16 17:38:48.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/Makefile.in	2015-08-18 12:58:22.597022000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +15,23 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -67,6 +84,11 @@
 depcomp =
 am__depfiles_maybe =
 SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
 ACLOCAL = @ACLOCAL@
 ALLOCATOR_H = @ALLOCATOR_H@
@@ -396,6 +418,7 @@
 	${bits_srcdir}/postypes.h \
 	${bits_srcdir}/predefined_ops.h \
 	${bits_srcdir}/ptr_traits.h \
+	${bits_srcdir}/quoted_string.h \
 	${bits_srcdir}/random.h \
 	${bits_srcdir}/random.tcc \
 	${bits_srcdir}/range_access.h \
@@ -917,10 +940,19 @@
 	${experimental_srcdir}/optional \
 	${experimental_srcdir}/ratio \
 	${experimental_srcdir}/string_view \
-	${experimental_srcdir}/system_error \
 	${experimental_srcdir}/string_view.tcc \
+	${experimental_srcdir}/system_error \
 	${experimental_srcdir}/tuple \
-	${experimental_srcdir}/type_traits
+	${experimental_srcdir}/type_traits \
+	${experimental_filesystem_headers}
+
+@ENABLE_FILESYSTEM_TS_FALSE@experimental_filesystem_headers = 
+@ENABLE_FILESYSTEM_TS_TRUE@experimental_filesystem_headers = \
+@ENABLE_FILESYSTEM_TS_TRUE@	${experimental_srcdir}/filesystem \
+@ENABLE_FILESYSTEM_TS_TRUE@	${experimental_srcdir}/fs_dir.h \
+@ENABLE_FILESYSTEM_TS_TRUE@	${experimental_srcdir}/fs_fwd.h \
+@ENABLE_FILESYSTEM_TS_TRUE@	${experimental_srcdir}/fs_ops.h \
+@ENABLE_FILESYSTEM_TS_TRUE@	${experimental_srcdir}/fs_path.h
 
 
 # This is the common subset of C++ files that all three "C" header models use.
@@ -1232,6 +1264,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -1267,10 +1300,15 @@
 
 installcheck: installcheck-am
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/std/atomic gcc-5.2.0/libstdc++-v3/include/std/atomic
--- gcc-5.2.0.orig/libstdc++-v3/include/std/atomic	2015-04-09 06:15:44.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/include/std/atomic	2015-10-08 11:54:23.551701000 -0500
@@ -208,16 +208,16 @@
       is_lock_free() const noexcept
       {
 	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_i));
-	return __atomic_is_lock_free(sizeof(_M_i), __a);
+	return __atomic_is_lock_free(sizeof(_M_i),
+	    reinterpret_cast<void *>(-__alignof(_M_i)));
       }
 
       bool
       is_lock_free() const volatile noexcept
       {
 	// Produce a fake, minimally aligned pointer.
-	void *__a = reinterpret_cast<void *>(-__alignof(_M_i));
-	return __atomic_is_lock_free(sizeof(_M_i), __a);
+	return __atomic_is_lock_free(sizeof(_M_i),
+	    reinterpret_cast<void *>(-__alignof(_M_i)));
       }
 
       void
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/std/iomanip gcc-5.2.0/libstdc++-v3/include/std/iomanip
--- gcc-5.2.0.orig/libstdc++-v3/include/std/iomanip	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/include/std/iomanip	2015-08-18 12:58:22.597022000 -0500
@@ -42,7 +42,7 @@
 #if __cplusplus >= 201103L
 #include <locale>
 #if __cplusplus > 201103L
-#include <sstream> // used in quoted.
+#include <bits/quoted_string.h>
 #endif
 #endif
 
@@ -450,127 +450,6 @@
 
 #define __cpp_lib_quoted_string_io 201304
 
-_GLIBCXX_END_NAMESPACE_VERSION
-  namespace __detail {
-  _GLIBCXX_BEGIN_NAMESPACE_VERSION
-
-    /**
-     * @brief Struct for delimited strings.
-     */
-    template<typename _String, typename _CharT>
-      struct _Quoted_string
-      {
-	static_assert(is_reference<_String>::value
-		   || is_pointer<_String>::value,
-		      "String type must be pointer or reference");
-
-	_Quoted_string(_String __str, _CharT __del, _CharT __esc)
-	: _M_string(__str), _M_delim{__del}, _M_escape{__esc}
-	{ }
-
-	_Quoted_string&
-	operator=(_Quoted_string&) = delete;
-
-	_String _M_string;
-	_CharT _M_delim;
-	_CharT _M_escape;
-      };
-
-    /**
-     * @brief Inserter for quoted strings.
-     *
-     *  _GLIBCXX_RESOLVE_LIB_DEFECTS
-     *  DR 2344 quoted()'s interaction with padding is unclear
-     */
-    template<typename _CharT, typename _Traits>
-      auto&
-      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
-		 const _Quoted_string<const _CharT*, _CharT>& __str)
-      {
-	std::basic_ostringstream<_CharT, _Traits> __ostr;
-	__ostr << __str._M_delim;
-	for (const _CharT* __c = __str._M_string; *__c; ++__c)
-	  {
-	    if (*__c == __str._M_delim || *__c == __str._M_escape)
-	      __ostr << __str._M_escape;
-	    __ostr << *__c;
-	  }
-	__ostr << __str._M_delim;
-
-	return __os << __ostr.str();
-      }
-
-    /**
-     * @brief Inserter for quoted strings.
-     *
-     *  _GLIBCXX_RESOLVE_LIB_DEFECTS
-     *  DR 2344 quoted()'s interaction with padding is unclear
-     */
-    template<typename _CharT, typename _Traits, typename _String>
-      auto&
-      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
-		 const _Quoted_string<_String, _CharT>& __str)
-      {
-	std::basic_ostringstream<_CharT, _Traits> __ostr;
-	__ostr << __str._M_delim;
-	for (auto& __c : __str._M_string)
-	  {
-	    if (__c == __str._M_delim || __c == __str._M_escape)
-	      __ostr << __str._M_escape;
-	    __ostr << __c;
-	  }
-	__ostr << __str._M_delim;
-
-	return __os << __ostr.str();
-      }
-
-    /**
-     * @brief Extractor for delimited strings.
-     *        The left and right delimiters can be different.
-     */
-    template<typename _CharT, typename _Traits, typename _Alloc>
-      auto&
-      operator>>(std::basic_istream<_CharT, _Traits>& __is,
-		 const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,
-				      _CharT>& __str)
-      {
-	_CharT __c;
-	__is >> __c;
-	if (!__is.good())
-	  return __is;
-	if (__c != __str._M_delim)
-	  {
-	    __is.unget();
-	    __is >> __str._M_string;
-	    return __is;
-	  }
-	__str._M_string.clear();
-	std::ios_base::fmtflags __flags
-	  = __is.flags(__is.flags() & ~std::ios_base::skipws);
-	do
-	  {
-	    __is >> __c;
-	    if (!__is.good())
-	      break;
-	    if (__c == __str._M_escape)
-	      {
-		__is >> __c;
-		if (!__is.good())
-		  break;
-	      }
-	    else if (__c == __str._M_delim)
-	      break;
-	    __str._M_string += __c;
-	  }
-	while (true);
-	__is.setf(__flags);
-
-	return __is;
-      }
-  _GLIBCXX_END_NAMESPACE_VERSION
-  } // namespace __detail
-_GLIBCXX_BEGIN_NAMESPACE_VERSION
-
   /**
    * @brief Manipulator for quoted strings.
    * @param __string String to quote.
diff -Naur gcc-5.2.0.orig/libstdc++-v3/include/std/shared_mutex gcc-5.2.0/libstdc++-v3/include/std/shared_mutex
--- gcc-5.2.0.orig/libstdc++-v3/include/std/shared_mutex	2015-04-10 04:00:00.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/include/std/shared_mutex	2015-09-03 17:12:00.308260000 -0500
@@ -74,7 +74,7 @@
     {
       int __ret = pthread_rwlock_init(&_M_rwlock, NULL);
       if (__ret == ENOMEM)
-	throw bad_alloc();
+	__throw_bad_alloc();
       else if (__ret == EAGAIN)
 	__throw_system_error(int(errc::resource_unavailable_try_again));
       else if (__ret == EPERM)
diff -Naur gcc-5.2.0.orig/libstdc++-v3/libsupc++/eh_ptr.cc gcc-5.2.0/libstdc++-v3/libsupc++/eh_ptr.cc
--- gcc-5.2.0.orig/libstdc++-v3/libsupc++/eh_ptr.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/libsupc++/eh_ptr.cc	2015-09-03 10:10:25.457825000 -0500
@@ -245,6 +245,9 @@
   __GXX_INIT_DEPENDENT_EXCEPTION_CLASS(dep->unwindHeader.exception_class);
   dep->unwindHeader.exception_cleanup = __gxx_dependent_exception_cleanup;
 
+  __cxa_eh_globals *globals = __cxa_get_globals ();
+  globals->uncaughtExceptions += 1;
+
 #ifdef _GLIBCXX_SJLJ_EXCEPTIONS
   _Unwind_SjLj_RaiseException (&dep->unwindHeader);
 #else
diff -Naur gcc-5.2.0.orig/libstdc++-v3/libsupc++/Makefile.in gcc-5.2.0/libstdc++-v3/libsupc++/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/libsupc++/Makefile.in	2015-01-29 10:47:25.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/libsupc++/Makefile.in	2015-08-18 12:58:06.792617000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -17,6 +17,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -87,6 +104,12 @@
 am__base_list = \
   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
   sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
 am__installdirs = "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(bitsdir)" \
 	"$(DESTDIR)$(stddir)"
 LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
@@ -129,6 +152,11 @@
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 CXXLD = $(CXX)
 SOURCES = $(libsupc___la_SOURCES) $(libsupc__convenience_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 HEADERS = $(bits_HEADERS) $(std_HEADERS)
 ETAGS = etags
 CTAGS = ctags
@@ -544,6 +572,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -564,7 +593,6 @@
 	done
 install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)"
 	@list='$(toolexeclib_LTLIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
 	list2=; for p in $$list; do \
 	  if test -f $$p; then \
@@ -572,6 +600,8 @@
 	  else :; fi; \
 	done; \
 	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)" || exit 1; \
 	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'"; \
 	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(toolexeclibdir)"; \
 	}
@@ -593,9 +623,9 @@
 	  echo "rm -f \"$${dir}/so_locations\""; \
 	  rm -f "$${dir}/so_locations"; \
 	done
-libsupc++.la: $(libsupc___la_OBJECTS) $(libsupc___la_DEPENDENCIES) 
+libsupc++.la: $(libsupc___la_OBJECTS) $(libsupc___la_DEPENDENCIES) $(EXTRA_libsupc___la_DEPENDENCIES) 
 	$(CXXLINK) -rpath $(toolexeclibdir) $(libsupc___la_OBJECTS) $(libsupc___la_LIBADD) $(LIBS)
-libsupc++convenience.la: $(libsupc__convenience_la_OBJECTS) $(libsupc__convenience_la_DEPENDENCIES) 
+libsupc++convenience.la: $(libsupc__convenience_la_OBJECTS) $(libsupc__convenience_la_DEPENDENCIES) $(EXTRA_libsupc__convenience_la_DEPENDENCIES) 
 	$(CXXLINK)  $(libsupc__convenience_la_OBJECTS) $(libsupc__convenience_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
@@ -696,10 +726,15 @@
 
 installcheck: installcheck-am
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/Makefile.in gcc-5.2.0/libstdc++-v3/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/Makefile.in	2014-12-19 12:16:39.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/Makefile.in	2015-08-18 12:58:06.792617000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +15,23 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -88,6 +105,11 @@
 	install-pdf-recursive install-ps-recursive install-recursive \
 	installcheck-recursive installdirs-recursive pdf-recursive \
 	ps-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
 AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
@@ -392,7 +414,7 @@
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
 .SUFFIXES:
-am--refresh:
+am--refresh: Makefile
 	@:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/fragment.am $(am__configure_deps)
 	@for dep in $?; do \
@@ -417,6 +439,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	$(SHELL) ./config.status --recheck
@@ -428,10 +451,8 @@
 $(am__aclocal_m4_deps):
 
 config.h: stamp-h1
-	@if test ! -f $@; then \
-	  rm -f stamp-h1; \
-	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
-	else :; fi
+	@if test ! -f $@; then rm -f stamp-h1; else :; fi
+	@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi
 
 stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
 	@rm -f stamp-h1
@@ -590,10 +611,15 @@
 
 installcheck: installcheck-recursive
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/po/Makefile.in gcc-5.2.0/libstdc++-v3/po/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/po/Makefile.in	2014-12-19 12:16:39.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/po/Makefile.in	2015-08-18 12:58:06.792617000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +15,23 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -67,6 +84,11 @@
 depcomp =
 am__depfiles_maybe =
 SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
 ACLOCAL = @ACLOCAL@
 ALLOCATOR_H = @ALLOCATOR_H@
@@ -330,6 +352,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -365,10 +388,15 @@
 
 installcheck: installcheck-am
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/python/libstdcxx/v6/printers.py gcc-5.2.0/libstdc++-v3/python/libstdcxx/v6/printers.py
--- gcc-5.2.0.orig/libstdc++-v3/python/libstdcxx/v6/printers.py	2015-05-28 07:33:36.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/python/libstdcxx/v6/printers.py	2015-08-18 12:58:22.597022000 -0500
@@ -980,6 +980,57 @@
     def display_hint (self):
         return 'string'
 
+class StdExpPathPrinter:
+    "Print a std::experimental::filesystem::path"
+
+    def __init__ (self, typename, val):
+        self.val = val
+        start = self.val['_M_cmpts']['_M_impl']['_M_start']
+        finish = self.val['_M_cmpts']['_M_impl']['_M_finish']
+        self.num_cmpts = int (finish - start)
+
+    def _path_type(self):
+        t = str(self.val['_M_type'])
+        if t[-9:] == '_Root_dir':
+            return "root-directory"
+        if t[-10:] == '_Root_name':
+            return "root-name"
+        return None
+
+    def to_string (self):
+        path = "%s" % self.val ['_M_pathname']
+        if self.num_cmpts == 0:
+            t = self._path_type()
+            if t:
+                path = '%s [%s]' % (path, t)
+        return "filesystem::path %s" % path
+
+    class _iterator(Iterator):
+        def __init__(self, cmpts):
+            self.item = cmpts['_M_impl']['_M_start']
+            self.finish = cmpts['_M_impl']['_M_finish']
+            self.count = 0
+
+        def __iter__(self):
+            return self
+
+        def __next__(self):
+            if self.item == self.finish:
+                raise StopIteration
+            item = self.item.dereference()
+            count = self.count
+            self.count = self.count + 1
+            self.item = self.item + 1
+            path = item['_M_pathname']
+            t = StdExpPathPrinter(item.type.name, item)._path_type()
+            if not t:
+                t = count
+            return ('[%s]' % t, path)
+
+    def children(self):
+        return self._iterator(self.val['_M_cmpts'])
+
+
 # A "regular expression" printer which conforms to the
 # "SubPrettyPrinter" protocol from gdb.printing.
 class RxPrinter(object):
@@ -1365,6 +1416,11 @@
                                   'optional', StdExpOptionalPrinter)
     libstdcxx_printer.add_version('std::experimental::fundamentals_v1::',
                                   'basic_string_view', StdExpStringViewPrinter)
+    # Filesystem TS components
+    libstdcxx_printer.add_version('std::experimental::filesystem::v1::',
+                                  'path', StdExpPathPrinter)
+    libstdcxx_printer.add_version('std::experimental::filesystem::v1::__cxx11::',
+                                  'path', StdExpPathPrinter)
 
     # Extensions.
     libstdcxx_printer.add_version('__gnu_cxx::', 'slist', StdSlistPrinter)
diff -Naur gcc-5.2.0.orig/libstdc++-v3/python/Makefile.am gcc-5.2.0/libstdc++-v3/python/Makefile.am
--- gcc-5.2.0.orig/libstdc++-v3/python/Makefile.am	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/python/Makefile.am	2015-08-20 05:26:55.590596000 -0500
@@ -49,7 +49,7 @@
 ## fragile, but there does not seem to be a better option, because
 ## libtool hides the real names from us.
 	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++*; do \
+	  for file in libstdc++.*; do \
 	    case $$file in \
 	      *-gdb.py) ;; \
 	      *.la) ;; \
diff -Naur gcc-5.2.0.orig/libstdc++-v3/python/Makefile.in gcc-5.2.0/libstdc++-v3/python/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/python/Makefile.in	2014-12-19 12:16:39.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/python/Makefile.in	2015-08-20 05:26:55.590596000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +16,23 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -68,6 +85,11 @@
 depcomp =
 am__depfiles_maybe =
 SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -89,6 +111,12 @@
 am__base_list = \
   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
   sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
 am__installdirs = "$(DESTDIR)$(pythondir)"
 DATA = $(nobase_python_DATA)
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
@@ -345,6 +373,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -362,15 +391,18 @@
 	-rm -rf .libs _libs
 install-nobase_pythonDATA: $(nobase_python_DATA)
 	@$(NORMAL_INSTALL)
-	test -z "$(pythondir)" || $(MKDIR_P) "$(DESTDIR)$(pythondir)"
 	@list='$(nobase_python_DATA)'; test -n "$(pythondir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(pythondir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(pythondir)" || exit 1; \
+	fi; \
 	$(am__nobase_list) | while read dir files; do \
 	  xfiles=; for file in $$files; do \
 	    if test -f "$$file"; then xfiles="$$xfiles $$file"; \
 	    else xfiles="$$xfiles $(srcdir)/$$file"; fi; done; \
 	  test -z "$$xfiles" || { \
 	    test "x$$dir" = x. || { \
-	      echo "$(MKDIR_P) '$(DESTDIR)$(pythondir)/$$dir'"; \
+	      echo " $(MKDIR_P) '$(DESTDIR)$(pythondir)/$$dir'"; \
 	      $(MKDIR_P) "$(DESTDIR)$(pythondir)/$$dir"; }; \
 	    echo " $(INSTALL_DATA) $$xfiles '$(DESTDIR)$(pythondir)/$$dir'"; \
 	    $(INSTALL_DATA) $$xfiles "$(DESTDIR)$(pythondir)/$$dir" || exit $$?; }; \
@@ -380,9 +412,7 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(nobase_python_DATA)'; test -n "$(pythondir)" || list=; \
 	$(am__nobase_strip_setup); files=`$(am__nobase_strip)`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(pythondir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(pythondir)" && rm -f $$files
+	dir='$(DESTDIR)$(pythondir)'; $(am__uninstall_files_from_dir)
 tags: TAGS
 TAGS:
 
@@ -406,10 +436,15 @@
 
 installcheck: installcheck-am
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
@@ -512,7 +547,7 @@
 install-data-local: gdb.py
 	@$(mkdir_p) $(DESTDIR)$(toolexeclibdir)
 	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++*; do \
+	  for file in libstdc++.*; do \
 	    case $$file in \
 	      *-gdb.py) ;; \
 	      *.la) ;; \
diff -Naur gcc-5.2.0.orig/libstdc++-v3/scripts/testsuite_flags.in gcc-5.2.0/libstdc++-v3/scripts/testsuite_flags.in
--- gcc-5.2.0.orig/libstdc++-v3/scripts/testsuite_flags.in	2014-05-20 16:31:30.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/scripts/testsuite_flags.in	2015-08-18 12:58:22.597022000 -0500
@@ -77,7 +77,8 @@
       echo ${PCHFLAGS}
       ;;
     --cxxldflags)
-      SECTIONLDFLAGS="@SECTION_LDFLAGS@ @LIBICONV@"
+      SECTIONLDFLAGS="@SECTION_LDFLAGS@ @LIBICONV@
+                      -L${BUILD_DIR}/src/filesystem/.libs"
       echo ${SECTIONLDFLAGS}
       ;;
     *)
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/c++11/codecvt.cc gcc-5.2.0/libstdc++-v3/src/c++11/codecvt.cc
--- gcc-5.2.0.orig/libstdc++-v3/src/c++11/codecvt.cc	2015-06-12 06:22:01.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/src/c++11/codecvt.cc	2015-09-03 10:10:32.211657000 -0500
@@ -1264,7 +1264,11 @@
 {
   range<const char> from{ __from, __from_end };
   range<char16_t> to{ __to, __to_end };
-  auto res = utf16_in(from, to, _M_maxcode, _M_mode);
+  codecvt_mode mode = codecvt_mode(_M_mode | (consume_header|generate_header));
+#if __BYTE_ORDER__ != __ORDER_BIG_ENDIAN__
+  mode = codecvt_mode(mode | little_endian);
+#endif
+  auto res = utf16_in(from, to, _M_maxcode, mode);
   __from_next = from.next;
   __to_next = to.next;
   return res;
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/c++11/Makefile.in gcc-5.2.0/libstdc++-v3/src/c++11/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/src/c++11/Makefile.in	2015-01-28 09:02:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/c++11/Makefile.in	2015-08-18 12:58:06.792617000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +16,23 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -98,6 +115,11 @@
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 CXXLD = $(CXX)
 SOURCES = $(libc__11convenience_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 ETAGS = etags
 CTAGS = ctags
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
@@ -485,6 +507,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -503,7 +526,7 @@
 	  echo "rm -f \"$${dir}/so_locations\""; \
 	  rm -f "$${dir}/so_locations"; \
 	done
-libc++11convenience.la: $(libc__11convenience_la_OBJECTS) $(libc__11convenience_la_DEPENDENCIES) 
+libc++11convenience.la: $(libc__11convenience_la_OBJECTS) $(libc__11convenience_la_DEPENDENCIES) $(EXTRA_libc__11convenience_la_DEPENDENCIES) 
 	$(CXXLINK)  $(libc__11convenience_la_OBJECTS) $(libc__11convenience_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
@@ -592,10 +615,15 @@
 
 installcheck: installcheck-am
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/c++11/random.cc gcc-5.2.0/libstdc++-v3/src/c++11/random.cc
--- gcc-5.2.0.orig/libstdc++-v3/src/c++11/random.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/c++11/random.cc	2015-10-02 15:08:04.934553000 -0500
@@ -31,6 +31,7 @@
 # include <cpuid.h>
 #endif
 
+#include <cerrno>
 #include <cstdio>
 
 #ifdef _GLIBCXX_HAVE_UNISTD_H
@@ -130,13 +131,27 @@
 #endif
 
     result_type __ret;
+    void* p = &__ret;
+    size_t n = sizeof(result_type);
 #ifdef _GLIBCXX_HAVE_UNISTD_H
-    read(fileno(static_cast<FILE*>(_M_file)),
-	 static_cast<void*>(&__ret), sizeof(result_type));
+    do
+      {
+	const int e = read(fileno(static_cast<FILE*>(_M_file)), p, n);
+	if (e > 0)
+	  {
+	    n -= e;
+	    p = static_cast<char*>(p) + e;
+	  }
+	else if (e != -1 || errno != EINTR)
+	  __throw_runtime_error(__N("random_device could not be read"));
+      }
+    while (n > 0);
 #else
-    std::fread(static_cast<void*>(&__ret), sizeof(result_type),
-	       1, static_cast<FILE*>(_M_file));
+    const size_t e = std::fread(p, n, 1, static_cast<FILE*>(_M_file));
+    if (e != 1)
+      __throw_runtime_error(__N("random_device could not be read"));
 #endif
+
     return __ret;
   }
 
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/c++98/Makefile.in gcc-5.2.0/libstdc++-v3/src/c++98/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/src/c++98/Makefile.in	2015-01-16 09:02:35.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/c++98/Makefile.in	2015-08-18 12:58:06.792617000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +16,23 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -99,6 +116,11 @@
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 CXXLD = $(CXX)
 SOURCES = $(libc__98convenience_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 ETAGS = etags
 CTAGS = ctags
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
@@ -501,6 +523,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -519,7 +542,7 @@
 	  echo "rm -f \"$${dir}/so_locations\""; \
 	  rm -f "$${dir}/so_locations"; \
 	done
-libc++98convenience.la: $(libc__98convenience_la_OBJECTS) $(libc__98convenience_la_DEPENDENCIES) 
+libc++98convenience.la: $(libc__98convenience_la_OBJECTS) $(libc__98convenience_la_DEPENDENCIES) $(EXTRA_libc__98convenience_la_DEPENDENCIES) 
 	$(CXXLINK)  $(libc__98convenience_la_OBJECTS) $(libc__98convenience_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
@@ -608,10 +631,15 @@
 
 installcheck: installcheck-am
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/filesystem/cow-dir.cc gcc-5.2.0/libstdc++-v3/src/filesystem/cow-dir.cc
--- gcc-5.2.0.orig/libstdc++-v3/src/filesystem/cow-dir.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/filesystem/cow-dir.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,26 @@
+// Class filesystem::directory_entry etc. -*- C++ -*-
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include "dir.cc"
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/filesystem/cow-ops.cc gcc-5.2.0/libstdc++-v3/src/filesystem/cow-ops.cc
--- gcc-5.2.0.orig/libstdc++-v3/src/filesystem/cow-ops.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/filesystem/cow-ops.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,26 @@
+// Filesystem operations -*- C++ -*-
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include "ops.cc"
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/filesystem/cow-path.cc gcc-5.2.0/libstdc++-v3/src/filesystem/cow-path.cc
--- gcc-5.2.0.orig/libstdc++-v3/src/filesystem/cow-path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/filesystem/cow-path.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,26 @@
+// Class filesystem::path -*- C++ -*-
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include "path.cc"
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/filesystem/dir.cc gcc-5.2.0/libstdc++-v3/src/filesystem/dir.cc
--- gcc-5.2.0.orig/libstdc++-v3/src/filesystem/dir.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/filesystem/dir.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,390 @@
+// Class filesystem::directory_entry etc. -*- C++ -*-
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#ifndef _GLIBCXX_USE_CXX11_ABI
+# define _GLIBCXX_USE_CXX11_ABI 1
+#endif
+
+#include <experimental/filesystem>
+#include <utility>
+#include <stack>
+#include <string.h>
+#include <errno.h>
+#ifdef _GLIBCXX_HAVE_DIRENT_H
+# ifdef _GLIBCXX_HAVE_SYS_TYPES_H
+#  include <sys/types.h>
+# endif
+# include <dirent.h>
+#else
+# error "the <dirent.h> header is needed to build the Filesystem TS"
+#endif
+
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+# undef opendir
+# define opendir _wopendir
+#endif
+
+namespace fs = std::experimental::filesystem;
+
+struct fs::_Dir
+{
+  _Dir() : dirp(nullptr) { }
+
+  _Dir(DIR* dirp, const fs::path& path) : dirp(dirp), path(path) { }
+
+  _Dir(_Dir&& d)
+  : dirp(std::exchange(d.dirp, nullptr)), path(std::move(d.path)),
+    entry(std::move(d.entry)), type(d.type)
+  { }
+
+  _Dir& operator=(_Dir&&) = delete;
+
+  ~_Dir() { if (dirp) ::closedir(dirp); }
+
+  bool advance(std::error_code*, directory_options = directory_options::none);
+
+  DIR*			dirp;
+  fs::path		path;
+  directory_entry	entry;
+  file_type		type = file_type::none;
+};
+
+namespace
+{
+  template<typename Bitmask>
+    inline bool
+    is_set(Bitmask obj, Bitmask bits)
+    {
+      return (obj & bits) != Bitmask::none;
+    }
+
+  // Returns {dirp, p} on success, {nullptr, p} on error.
+  // If an ignored EACCES error occurs returns {}.
+  inline fs::_Dir
+  open_dir(const fs::path& p, fs::directory_options options,
+	   std::error_code* ec)
+  {
+    if (ec)
+      ec->clear();
+
+    if (DIR* dirp = ::opendir(p.c_str()))
+      return {dirp, p};
+
+    const int err = errno;
+    if (err == EACCES
+        && is_set(options, fs::directory_options::skip_permission_denied))
+      return {};
+
+    if (!ec)
+      _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(
+            "directory iterator cannot open directory", p,
+            std::error_code(err, std::generic_category())));
+
+    ec->assign(err, std::generic_category());
+    return {nullptr, p};
+  }
+
+  inline fs::file_type
+  get_file_type(const ::dirent& d __attribute__((__unused__)))
+  {
+#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE
+    switch (d.d_type)
+    {
+    case DT_BLK:
+      return fs::file_type::block;
+    case DT_CHR:
+      return fs::file_type::character;
+    case DT_DIR:
+      return fs::file_type::directory;
+    case DT_FIFO:
+      return fs::file_type::fifo;
+    case DT_LNK:
+      return fs::file_type::symlink;
+    case DT_REG:
+      return fs::file_type::regular;
+    case DT_SOCK:
+      return fs::file_type::socket;
+    case DT_UNKNOWN:
+      return fs::file_type::unknown;
+    default:
+      return fs::file_type::none;
+    }
+#else
+    return fs::file_type::none;
+#endif
+  }
+}
+
+
+// Returns false when the end of the directory entries is reached.
+// Reports errors by setting ec or throwing.
+bool
+fs::_Dir::advance(error_code* ec, directory_options options)
+{
+  if (ec)
+    ec->clear();
+
+  int err = std::exchange(errno, 0);
+  const auto entp = readdir(dirp);
+  std::swap(errno, err);
+
+  if (entp)
+    {
+      // skip past dot and dot-dot
+      if (!strcmp(entp->d_name, ".") || !strcmp(entp->d_name, ".."))
+	return advance(ec, options);
+      entry = fs::directory_entry{path / entp->d_name};
+      type = get_file_type(*entp);
+      return true;
+    }
+  else if (err)
+    {
+      if (err == EACCES
+        && is_set(options, directory_options::skip_permission_denied))
+	return false;
+
+      if (!ec)
+	_GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	      "directory iterator cannot advance",
+	      std::error_code(err, std::generic_category())));
+      ec->assign(err, std::generic_category());
+      return true;
+    }
+  else
+    {
+      // reached the end
+      entry = {};
+      type = fs::file_type::none;
+      return false;
+    }
+}
+
+fs::directory_iterator::
+directory_iterator(const path& p, directory_options options, error_code* ec)
+{
+  _Dir dir = open_dir(p, options, ec);
+
+  if (dir.dirp)
+    {
+      auto sp = std::make_shared<fs::_Dir>(std::move(dir));
+      if (sp->advance(ec, options))
+	_M_dir.swap(sp);
+    }
+  else if (!dir.path.empty())
+    {
+      // An error occurred, we need a non-empty shared_ptr so that *this will
+      // not compare equal to the end iterator.
+      _M_dir.reset(static_cast<fs::_Dir*>(nullptr));
+    }
+}
+
+const fs::directory_entry&
+fs::directory_iterator::operator*() const
+{
+  if (!_M_dir)
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	  "non-dereferenceable directory iterator",
+	  std::make_error_code(errc::invalid_argument)));
+  return _M_dir->entry;
+}
+
+fs::directory_iterator&
+fs::directory_iterator::operator++()
+{
+  if (!_M_dir)
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	  "cannot advance non-dereferenceable directory iterator",
+	  std::make_error_code(errc::invalid_argument)));
+  if (!_M_dir->advance(nullptr))
+    _M_dir.reset();
+  return *this;
+}
+
+fs::directory_iterator&
+fs::directory_iterator::increment(error_code& ec) noexcept
+{
+  if (!_M_dir)
+    {
+      ec = std::make_error_code(errc::invalid_argument);
+      return *this;
+    }
+  if (!_M_dir->advance(&ec))
+    _M_dir.reset();
+  return *this;
+}
+
+using Dir_iter_pair = std::pair<fs::_Dir, fs::directory_iterator>;
+
+struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>
+{
+  void clear() { c.clear(); }
+};
+
+fs::recursive_directory_iterator::
+recursive_directory_iterator(const path& p, directory_options options,
+                             error_code* ec)
+: _M_options(options), _M_pending(true)
+{
+  if (DIR* dirp = ::opendir(p.c_str()))
+    {
+      auto sp = std::make_shared<_Dir_stack>();
+      sp->push(_Dir{ dirp, p });
+      if (sp->top().advance(ec))
+	_M_dirs.swap(sp);
+    }
+  else
+    {
+      const int err = errno;
+      if (err == EACCES
+	  && is_set(options, fs::directory_options::skip_permission_denied))
+	{
+	  if (ec)
+	    ec->clear();
+	  return;
+	}
+
+      if (!ec)
+	_GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	      "recursive directory iterator cannot open directory", p,
+	      std::error_code(err, std::generic_category())));
+
+      ec->assign(err, std::generic_category());
+
+      // An error occurred, we need a non-empty shared_ptr so that *this will
+      // not compare equal to the end iterator.
+      _M_dirs.reset(static_cast<_Dir_stack*>(nullptr));
+    }
+}
+
+fs::recursive_directory_iterator::~recursive_directory_iterator() = default;
+
+int
+fs::recursive_directory_iterator::depth() const
+{
+  return int(_M_dirs->size()) - 1;
+}
+
+const fs::directory_entry&
+fs::recursive_directory_iterator::operator*() const
+{
+  return _M_dirs->top().entry;
+}
+
+fs::recursive_directory_iterator&
+fs::recursive_directory_iterator::
+operator=(const recursive_directory_iterator& other) noexcept = default;
+
+fs::recursive_directory_iterator&
+fs::recursive_directory_iterator::
+operator=(recursive_directory_iterator&& other) noexcept = default;
+
+fs::recursive_directory_iterator&
+fs::recursive_directory_iterator::operator++()
+{
+  error_code ec;
+  increment(ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	  "cannot increment recursive directory iterator", ec));
+  return *this;
+}
+
+namespace
+{
+  bool
+  recurse(const fs::_Dir& d, fs::directory_options options, std::error_code& ec)
+  {
+    bool follow_symlink
+      = is_set(options, fs::directory_options::follow_directory_symlink);
+#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE
+    if (d.type == fs::file_type::directory)
+      return true;
+    if (d.type == fs::file_type::symlink && follow_symlink)
+      return d.entry.status().type() == fs::file_type::directory;
+    if (d.type != fs::file_type::none && d.type != fs::file_type::unknown)
+      return false;
+#endif
+    const fs::path& path = d.entry.path();
+    auto type = fs::symlink_status(path, ec).type();
+    if (ec.value())
+      return false;
+    if (type == fs::file_type::symlink)
+      {
+	if (!follow_symlink)
+	  return false;
+	type = fs::status(path, ec).type();
+      }
+    return type == fs::file_type::directory;
+  }
+}
+
+fs::recursive_directory_iterator&
+fs::recursive_directory_iterator::increment(error_code& ec) noexcept
+{
+  if (!_M_dirs)
+    {
+      ec = std::make_error_code(errc::invalid_argument);
+      return *this;
+    }
+
+  auto& top = _M_dirs->top();
+
+  if (std::exchange(_M_pending, true) && recurse(top, _M_options, ec))
+    {
+      _Dir dir = open_dir(top.entry.path(), _M_options, &ec);
+      if (ec)
+	return *this;
+      if (dir.dirp)
+	  _M_dirs->push(std::move(dir));
+    }
+
+  while (!_M_dirs->top().advance(&ec, _M_options) && !ec)
+    {
+      _M_dirs->pop();
+      if (_M_dirs->empty())
+	{
+	  _M_dirs.reset();
+	  return *this;
+	}
+    }
+  return *this;
+}
+
+void
+fs::recursive_directory_iterator::pop()
+{
+  if (!_M_dirs)
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	  "cannot pop non-dereferenceable recursive directory iterator",
+	  std::make_error_code(errc::invalid_argument)));
+
+  do {
+    _M_dirs->pop();
+    if (_M_dirs->empty())
+      {
+	_M_dirs.reset();
+	return;
+      }
+  } while (!_M_dirs->top().advance(nullptr, _M_options));
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/filesystem/Makefile.am gcc-5.2.0/libstdc++-v3/src/filesystem/Makefile.am
--- gcc-5.2.0.orig/libstdc++-v3/src/filesystem/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/filesystem/Makefile.am	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,110 @@
+## Makefile for the GNU C++ Filesystem library.
+##
+## Copyright (C) 2014-2015 Free Software Foundation, Inc.
+##
+## Process this file with automake to produce Makefile.in.
+##
+## This file is part of GCC.
+##
+## GCC is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3, or (at your option)
+## any later version.
+##
+## GCC is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with GCC; see the file COPYING3.  If not see
+## <http://www.gnu.org/licenses/>.
+
+include $(top_srcdir)/fragment.am
+
+toolexeclib_LTLIBRARIES = libstdc++fs.la
+
+headers =
+
+if ENABLE_DUAL_ABI
+cxx11_abi_sources = \
+	cow-dir.cc \
+	cow-ops.cc \
+	cow-path.cc
+else
+cxx11_abi_sources =
+endif
+
+sources = \
+	dir.cc \
+	ops.cc \
+	path.cc \
+	${cxx11_abi_sources}
+
+# vpath % $(top_srcdir)/src/filesystem
+
+libstdc__fs_la_SOURCES = $(sources)
+
+# AM_CXXFLAGS needs to be in each subdirectory so that it can be
+# modified in a per-library or per-sub-library way.  Need to manually
+# set this option because CONFIG_CXXFLAGS has to be after
+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden
+# as the occasion call for it.
+AM_CXXFLAGS = \
+	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
+	-std=gnu++14 \
+	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS)
+
+AM_MAKEFLAGS = \
+	"gxx_include_dir=$(gxx_include_dir)"
+
+
+# Libtool notes
+
+# 1) In general, libtool expects an argument such as `--tag=CXX' when
+# using the C++ compiler, because that will enable the settings
+# detected when C++ support was being configured.  However, when no
+# such flag is given in the command line, libtool attempts to figure
+# it out by matching the compiler name in each configuration section
+# against a prefix of the command line.  The problem is that, if the
+# compiler name and its initial flags stored in the libtool
+# configuration file don't match those in the command line, libtool
+# can't decide which configuration to use, and it gives up.  The
+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe
+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to
+# attempt to infer which configuration to use.
+# 
+# The second tag argument, `--tag disable-shared` means that libtool
+# only compiles each source once, for static objects. In actuality,
+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to
+# the libtool command that is used create the object, which is
+# suitable for shared libraries.  The `--tag disable-shared` must be
+# placed after --tag CXX lest things CXX undo the affect of
+# disable-shared.
+
+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is
+# last. (That way, things like -O2 passed down from the toplevel can
+# be overridden by --enable-debug.)
+LTCXXCOMPILE = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)
+
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+
+# 3) We'd have a problem when building the shared libstdc++ object if
+# the rules automake generates would be used.  We cannot allow g++ to
+# be used since this would add -lstdc++ to the link line which of
+# course is problematic at this point.  So, we get the top-level
+# directory to configure libstdc++-v3 to use gcc as the C++
+# compilation driver.
+CXXLINK = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CXX) \
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+
+# By adding these files here, automake will remove them for 'make clean'
+CLEANFILES = stamp-*
+
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/filesystem/Makefile.in gcc-5.2.0/libstdc++-v3/src/filesystem/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/src/filesystem/Makefile.in	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/filesystem/Makefile.in	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,705 @@
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+DIST_COMMON = $(top_srcdir)/fragment.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am
+subdir = src/filesystem
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/enable.m4 \
+	$(top_srcdir)/../config/futex.m4 \
+	$(top_srcdir)/../config/iconv.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
+	$(top_srcdir)/../config/lib-ld.m4 \
+	$(top_srcdir)/../config/lib-link.m4 \
+	$(top_srcdir)/../config/lib-prefix.m4 \
+	$(top_srcdir)/../config/lthostflags.m4 \
+	$(top_srcdir)/../config/multi.m4 \
+	$(top_srcdir)/../config/no-executables.m4 \
+	$(top_srcdir)/../config/override.m4 \
+	$(top_srcdir)/../config/stdint.m4 \
+	$(top_srcdir)/../config/unwind_ipinfo.m4 \
+	$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \
+	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
+	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/crossconfig.m4 \
+	$(top_srcdir)/linkage.m4 $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/../config/gc++filt.m4 \
+	$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../config/gthr.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(toolexeclibdir)"
+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)
+libstdc__fs_la_LIBADD =
+@ENABLE_DUAL_ABI_TRUE@am__objects_1 = cow-dir.lo cow-ops.lo \
+@ENABLE_DUAL_ABI_TRUE@	cow-path.lo
+am__objects_2 = dir.lo ops.lo path.lo $(am__objects_1)
+am_libstdc__fs_la_OBJECTS = $(am__objects_2)
+libstdc__fs_la_OBJECTS = $(am_libstdc__fs_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+SOURCES = $(libstdc__fs_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+ETAGS = etags
+CTAGS = ctags
+ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
+ACLOCAL = @ACLOCAL@
+ALLOCATOR_H = @ALLOCATOR_H@
+ALLOCATOR_NAME = @ALLOCATOR_NAME@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@
+ATOMIC_FLAGS = @ATOMIC_FLAGS@
+ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BASIC_FILE_CC = @BASIC_FILE_CC@
+BASIC_FILE_H = @BASIC_FILE_H@
+CC = @CC@
+CCODECVT_CC = @CCODECVT_CC@
+CCOLLATE_CC = @CCOLLATE_CC@
+CCTYPE_CC = @CCTYPE_CC@
+CFLAGS = @CFLAGS@
+CLOCALE_CC = @CLOCALE_CC@
+CLOCALE_H = @CLOCALE_H@
+CLOCALE_INTERNAL_H = @CLOCALE_INTERNAL_H@
+CMESSAGES_CC = @CMESSAGES_CC@
+CMESSAGES_H = @CMESSAGES_H@
+CMONEY_CC = @CMONEY_CC@
+CNUMERIC_CC = @CNUMERIC_CC@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPU_DEFINES_SRCDIR = @CPU_DEFINES_SRCDIR@
+CPU_OPT_BITS_RANDOM = @CPU_OPT_BITS_RANDOM@
+CPU_OPT_EXT_RANDOM = @CPU_OPT_EXT_RANDOM@
+CSTDIO_H = @CSTDIO_H@
+CTIME_CC = @CTIME_CC@
+CTIME_H = @CTIME_H@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXFILT = @CXXFILT@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+C_INCLUDE_DIR = @C_INCLUDE_DIR@
+DBLATEX = @DBLATEX@
+DEBUG_FLAGS = @DEBUG_FLAGS@
+DEFS = @DEFS@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ERROR_CONSTANTS_SRCDIR = @ERROR_CONSTANTS_SRCDIR@
+EXEEXT = @EXEEXT@
+EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@
+FGREP = @FGREP@
+GLIBCXX_INCLUDES = @GLIBCXX_INCLUDES@
+GLIBCXX_LIBS = @GLIBCXX_LIBS@
+GREP = @GREP@
+HWCAP_FLAGS = @HWCAP_FLAGS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBICONV = @LTLIBICONV@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@
+OPT_LDFLAGS = @OPT_LDFLAGS@
+OS_INC_SRCDIR = @OS_INC_SRCDIR@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PDFLATEX = @PDFLATEX@
+RANLIB = @RANLIB@
+SECTION_FLAGS = @SECTION_FLAGS@
+SECTION_LDFLAGS = @SECTION_LDFLAGS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+SYMVER_FILE = @SYMVER_FILE@
+TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+VTV_CXXFLAGS = @VTV_CXXFLAGS@
+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@
+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
+WARN_FLAGS = @WARN_FLAGS@
+WERROR = @WERROR@
+XMLLINT = @XMLLINT@
+XSLTPROC = @XSLTPROC@
+XSL_STYLE_DIR = @XSL_STYLE_DIR@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__leading_dot = @am__leading_dot@
+am__tar = @am__tar@
+am__untar = @am__untar@
+baseline_dir = @baseline_dir@
+baseline_subdir_switch = @baseline_subdir_switch@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+check_msgfmt = @check_msgfmt@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_shared = @enable_shared@
+enable_static = @enable_static@
+exec_prefix = @exec_prefix@
+glibcxx_MOFILES = @glibcxx_MOFILES@
+glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
+glibcxx_POFILES = @glibcxx_POFILES@
+glibcxx_builddir = @glibcxx_builddir@
+glibcxx_compiler_pic_flag = @glibcxx_compiler_pic_flag@
+glibcxx_compiler_shared_flag = @glibcxx_compiler_shared_flag@
+glibcxx_cxx98_abi = @glibcxx_cxx98_abi@
+glibcxx_localedir = @glibcxx_localedir@
+glibcxx_lt_pic_flag = @glibcxx_lt_pic_flag@
+glibcxx_prefixdir = @glibcxx_prefixdir@
+glibcxx_srcdir = @glibcxx_srcdir@
+glibcxx_toolexecdir = @glibcxx_toolexecdir@
+glibcxx_toolexeclibdir = @glibcxx_toolexeclibdir@
+gxx_include_dir = @gxx_include_dir@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+libtool_VERSION = @libtool_VERSION@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_host_flags = @lt_host_flags@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+multi_basedir = @multi_basedir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+port_specific_symbol_files = @port_specific_symbol_files@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+python_mod_dir = @python_mod_dir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+thread_header = @thread_header@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+toplevel_builddir = @toplevel_builddir@
+toplevel_srcdir = @toplevel_srcdir@
+
+# May be used by various substitution variables.
+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
+MAINT_CHARSET = latin1
+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs
+PWD_COMMAND = $${PWDCMD-pwd}
+STAMP = echo timestamp >
+toolexecdir = $(glibcxx_toolexecdir)
+toolexeclibdir = $(glibcxx_toolexeclibdir)
+@ENABLE_WERROR_FALSE@WERROR_FLAG = 
+@ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)
+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = 
+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates
+
+# These bits are all figured out from configure.  Look in acinclude.m4
+# or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.
+CONFIG_CXXFLAGS = \
+	$(SECTION_FLAGS) $(HWCAP_FLAGS) -frandom-seed=$@
+
+WARN_CXXFLAGS = \
+	$(WARN_FLAGS) $(WERROR_FLAG) -fdiagnostics-show-location=once 
+
+
+# -I/-D flags to pass when compiling.
+AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)
+toolexeclib_LTLIBRARIES = libstdc++fs.la
+headers = 
+@ENABLE_DUAL_ABI_FALSE@cxx11_abi_sources = 
+@ENABLE_DUAL_ABI_TRUE@cxx11_abi_sources = \
+@ENABLE_DUAL_ABI_TRUE@	cow-dir.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-ops.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-path.cc
+
+sources = \
+	dir.cc \
+	ops.cc \
+	path.cc \
+	${cxx11_abi_sources}
+
+
+# vpath % $(top_srcdir)/src/filesystem
+libstdc__fs_la_SOURCES = $(sources)
+
+# AM_CXXFLAGS needs to be in each subdirectory so that it can be
+# modified in a per-library or per-sub-library way.  Need to manually
+# set this option because CONFIG_CXXFLAGS has to be after
+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden
+# as the occasion call for it.
+AM_CXXFLAGS = \
+	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
+	-std=gnu++14 \
+	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS)
+
+AM_MAKEFLAGS = \
+	"gxx_include_dir=$(gxx_include_dir)"
+
+
+# Libtool notes
+
+# 1) In general, libtool expects an argument such as `--tag=CXX' when
+# using the C++ compiler, because that will enable the settings
+# detected when C++ support was being configured.  However, when no
+# such flag is given in the command line, libtool attempts to figure
+# it out by matching the compiler name in each configuration section
+# against a prefix of the command line.  The problem is that, if the
+# compiler name and its initial flags stored in the libtool
+# configuration file don't match those in the command line, libtool
+# can't decide which configuration to use, and it gives up.  The
+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe
+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to
+# attempt to infer which configuration to use.
+# 
+# The second tag argument, `--tag disable-shared` means that libtool
+# only compiles each source once, for static objects. In actuality,
+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to
+# the libtool command that is used create the object, which is
+# suitable for shared libraries.  The `--tag disable-shared` must be
+# placed after --tag CXX lest things CXX undo the affect of
+# disable-shared.
+
+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is
+# last. (That way, things like -O2 passed down from the toplevel can
+# be overridden by --enable-debug.)
+LTCXXCOMPILE = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)
+
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+
+# 3) We'd have a problem when building the shared libstdc++ object if
+# the rules automake generates would be used.  We cannot allow g++ to
+# be used since this would add -lstdc++ to the link line which of
+# course is problematic at this point.  So, we get the top-level
+# directory to configure libstdc++-v3 to use gcc as the C++
+# compilation driver.
+CXXLINK = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CXX) \
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+
+
+# By adding these files here, automake will remove them for 'make clean'
+CLEANFILES = stamp-*
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cc .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/fragment.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps src/filesystem/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign --ignore-deps src/filesystem/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+$(top_srcdir)/fragment.am:
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(toolexeclib_LTLIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(toolexeclibdir)"; \
+	}
+
+uninstall-toolexeclibLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(toolexeclib_LTLIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(toolexeclibdir)/$$f"; \
+	done
+
+clean-toolexeclibLTLIBRARIES:
+	-test -z "$(toolexeclib_LTLIBRARIES)" || rm -f $(toolexeclib_LTLIBRARIES)
+	@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libstdc++fs.la: $(libstdc__fs_la_OBJECTS) $(libstdc__fs_la_DEPENDENCIES) $(EXTRA_libstdc__fs_la_DEPENDENCIES) 
+	$(CXXLINK) -rpath $(toolexeclibdir) $(libstdc__fs_la_OBJECTS) $(libstdc__fs_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.cc.o:
+	$(CXXCOMPILE) -c -o $@ $<
+
+.cc.obj:
+	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cc.lo:
+	$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(toolexeclibdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am: install-toolexeclibLTLIBRARIES
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-toolexeclibLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-toolexeclibLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags dvi dvi-am html html-am info info-am install \
+	install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip install-toolexeclibLTLIBRARIES installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-toolexeclibLTLIBRARIES
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/filesystem/ops.cc gcc-5.2.0/libstdc++-v3/src/filesystem/ops.cc
--- gcc-5.2.0.orig/libstdc++-v3/src/filesystem/ops.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/filesystem/ops.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,1346 @@
+// Filesystem operations -*- C++ -*-
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#ifndef _GLIBCXX_USE_CXX11_ABI
+# define _GLIBCXX_USE_CXX11_ABI 1
+#endif
+
+#include <experimental/filesystem>
+#include <functional>
+#include <stack>
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <limits.h>  // PATH_MAX
+#ifdef _GLIBCXX_HAVE_UNISTD_H
+# include <unistd.h>
+# if defined(_GLIBCXX_HAVE_SYS_STAT_H) && defined(_GLIBCXX_HAVE_SYS_TYPES_H)
+#  include <sys/types.h>
+#  include <sys/stat.h>
+# endif
+#endif
+#ifdef _GLIBCXX_HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+#ifdef _GLIBCXX_HAVE_SYS_STATVFS_H
+# include <sys/statvfs.h>
+#endif
+#ifdef _GLIBCXX_USE_SENDFILE
+# include <sys/sendfile.h>
+#else
+# include <ext/stdio_filebuf.h>
+# include <ostream>
+#endif
+#if _GLIBCXX_HAVE_UTIME_H
+# include <utime.h>
+#endif
+
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+# undef utime
+# define utime _wutime
+# undef chmod
+# define chmod _wchmod
+#endif
+
+namespace fs = std::experimental::filesystem;
+
+fs::path
+fs::absolute(const path& p, const path& base)
+{
+  const bool has_root_dir = p.has_root_directory();
+  const bool has_root_name = p.has_root_name();
+  path abs;
+  if (has_root_dir && has_root_name)
+    abs = p;
+  else
+    {
+      abs = base.is_absolute() ? base : absolute(base);
+      if (has_root_dir)
+	abs = abs.root_name() / p;
+      else if (has_root_name)
+	abs = p.root_name() / abs.root_directory() / abs.relative_path()
+	  / p.relative_path();
+      else
+	abs = abs / p;
+    }
+  return abs;
+}
+
+namespace
+{
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  inline bool is_dot(wchar_t c) { return c == L'.'; }
+#else
+  inline bool is_dot(char c) { return c == '.'; }
+#endif
+
+  inline bool is_dot(const fs::path& path)
+  {
+    const auto& filename = path.native();
+    return filename.size() == 1 && is_dot(filename[0]);
+  }
+
+  inline bool is_dotdot(const fs::path& path)
+  {
+    const auto& filename = path.native();
+    return filename.size() == 2 && is_dot(filename[0]) && is_dot(filename[1]);
+  }
+
+  struct free_as_in_malloc
+  {
+    void operator()(void* p) const { ::free(p); }
+  };
+
+  using char_ptr = std::unique_ptr<char[], free_as_in_malloc>;
+}
+
+fs::path
+fs::canonical(const path& p, const path& base, error_code& ec)
+{
+  const path pa = absolute(p, base);
+  path result;
+
+#ifdef _GLIBCXX_USE_REALPATH
+  char_ptr buf{ nullptr };
+# if _XOPEN_VERSION < 700
+  // Not safe to call realpath(path, NULL)
+  buf.reset( (char*)::malloc(PATH_MAX) );
+# endif
+  if (char* rp = ::realpath(pa.c_str(), buf.get()))
+    {
+      if (buf == nullptr)
+	buf.reset(rp);
+      result.assign(rp);
+      ec.clear();
+      return result;
+    }
+  if (errno != ENAMETOOLONG)
+    {
+      ec.assign(errno, std::generic_category());
+      return result;
+    }
+#endif
+
+  if (!exists(pa, ec))
+    return result;
+  // else: we know there are (currently) no unresolvable symlink loops
+
+  result = pa.root_path();
+
+  deque<path> cmpts;
+  for (auto& f : pa.relative_path())
+    cmpts.push_back(f);
+
+  int max_allowed_symlinks = 40;
+
+  while (!cmpts.empty() && !ec)
+    {
+      path f = std::move(cmpts.front());
+      cmpts.pop_front();
+
+      if (is_dot(f))
+	{
+	  if (!is_directory(result, ec) && !ec)
+	    ec.assign(ENOTDIR, std::generic_category());
+	}
+      else if (is_dotdot(f))
+	{
+	  auto parent = result.parent_path();
+	  if (parent.empty())
+	    result = pa.root_path();
+	  else
+	    result.swap(parent);
+	}
+      else
+	{
+	  result /= f;
+
+	  if (is_symlink(result, ec))
+	    {
+	      path link = read_symlink(result, ec);
+	      if (!ec)
+		{
+		  if (--max_allowed_symlinks == 0)
+		    ec.assign(ELOOP, std::generic_category());
+		  else
+		    {
+		      if (link.is_absolute())
+			{
+			  result = link.root_path();
+			  link = link.relative_path();
+			}
+		      else
+			result.remove_filename();
+
+		      cmpts.insert(cmpts.begin(), link.begin(), link.end());
+		    }
+		}
+	    }
+	}
+    }
+
+  if (ec || !exists(result, ec))
+    result.clear();
+
+  return result;
+}
+
+fs::path
+fs::canonical(const path& p, error_code& ec)
+{
+  path cur = current_path(ec);
+  if (ec.value())
+    return {};
+  return canonical(p, cur, ec);
+}
+
+fs::path
+fs::canonical(const path& p, const path& base)
+{
+  error_code ec;
+  path can = canonical(p, base, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot canonicalize", p, ec));
+  return can;
+}
+
+void
+fs::copy(const path& from, const path& to, copy_options options)
+{
+  error_code ec;
+  copy(from, to, options, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot copy", from, to, ec));
+}
+
+namespace
+{
+  template<typename Bitmask>
+    inline bool is_set(Bitmask obj, Bitmask bits)
+    {
+      return (obj & bits) != Bitmask::none;
+    }
+}
+
+#ifdef _GLIBCXX_HAVE_SYS_STAT_H
+namespace
+{
+  typedef struct ::stat stat_type;
+
+  inline fs::file_type
+  make_file_type(const stat_type& st)
+  {
+    using fs::file_type;
+#ifdef _GLIBCXX_HAVE_S_ISREG
+    if (S_ISREG(st.st_mode))
+      return file_type::regular;
+    else if (S_ISDIR(st.st_mode))
+      return file_type::directory;
+    else if (S_ISCHR(st.st_mode))
+      return file_type::character;
+    else if (S_ISBLK(st.st_mode))
+      return file_type::block;
+    else if (S_ISFIFO(st.st_mode))
+      return file_type::fifo;
+    else if (S_ISLNK(st.st_mode))
+      return file_type::symlink;
+    else if (S_ISSOCK(st.st_mode))
+      return file_type::socket;
+#endif
+    return file_type::unknown;
+
+  }
+
+  inline fs::file_status
+  make_file_status(const stat_type& st)
+  {
+    return fs::file_status{
+	make_file_type(st),
+	static_cast<fs::perms>(st.st_mode) & fs::perms::mask
+    };
+  }
+
+  inline bool
+  is_not_found_errno(int err)
+  {
+    return err == ENOENT || err == ENOTDIR;
+  }
+
+  inline fs::file_time_type
+  file_time(const stat_type& st)
+  {
+    using namespace std::chrono;
+    return fs::file_time_type{
+#ifdef _GLIBCXX_USE_ST_MTIM
+	seconds{st.st_mtim.tv_sec} + nanoseconds{st.st_mtim.tv_nsec}
+#else
+	seconds{st.st_mtime}
+#endif
+    };
+  }
+
+  bool
+  do_copy_file(const fs::path& from, const fs::path& to,
+	       fs::copy_options option,
+	       stat_type* from_st, stat_type* to_st,
+	       std::error_code& ec) noexcept
+  {
+    stat_type st1, st2;
+    fs::file_status t, f;
+
+    if (to_st == nullptr)
+      {
+	if (::stat(to.c_str(), &st1))
+	  {
+	    int err = errno;
+	    if (!is_not_found_errno(err))
+	      {
+		ec.assign(err, std::generic_category());
+		return false;
+	      }
+	  }
+	else
+	  to_st = &st1;
+      }
+    else if (to_st == from_st)
+      to_st = nullptr;
+
+    if (to_st == nullptr)
+      t = fs::file_status{fs::file_type::not_found};
+    else
+      t = make_file_status(*to_st);
+
+    if (from_st == nullptr)
+      {
+	if (::stat(from.c_str(), &st2))
+	  {
+	    ec.assign(errno, std::generic_category());
+	    return false;
+	  }
+	else
+	  from_st = &st2;
+      }
+    f = make_file_status(*from_st);
+
+    using opts = fs::copy_options;
+
+    if (exists(t))
+      {
+	if (!is_other(t) && !is_other(f)
+	    && to_st->st_dev == from_st->st_dev
+	    && to_st->st_ino == from_st->st_ino)
+	  {
+	    ec = std::make_error_code(std::errc::file_exists);
+	    return false;
+	  }
+
+	if (is_set(option, opts::skip_existing))
+	  {
+	    ec.clear();
+	    return false;
+	  }
+	else if (is_set(option, opts::update_existing))
+	  {
+	    if (file_time(*from_st) <= file_time(*to_st))
+	      {
+		ec.clear();
+		return false;
+	      }
+	  }
+	else if (!is_set(option, opts::overwrite_existing))
+	  {
+	    ec = std::make_error_code(std::errc::file_exists);
+	    return false;
+	  }
+      }
+
+    struct CloseFD {
+      ~CloseFD() { if (fd != -1) ::close(fd); }
+      int fd;
+    };
+
+    CloseFD in = { ::open(from.c_str(), O_RDONLY) };
+    if (in.fd == -1)
+      {
+	ec.assign(errno, std::generic_category());
+	return false;
+      }
+    int oflag = O_WRONLY|O_CREAT;
+    if (is_set(option, opts::overwrite_existing|opts::update_existing))
+      oflag |= O_TRUNC;
+    else
+      oflag |= O_EXCL;
+    CloseFD out = { ::open(to.c_str(), oflag, S_IWUSR) };
+    if (out.fd == -1)
+      {
+	if (errno == EEXIST && is_set(option, opts::skip_existing))
+	  ec.clear();
+	else
+	  ec.assign(errno, std::generic_category());
+	return false;
+      }
+
+#ifdef _GLIBCXX_USE_SENDFILE
+    auto n = ::sendfile(out.fd, in.fd, nullptr, from_st->st_size);
+    if (n != from_st->st_size)
+      {
+	ec.assign(errno, std::generic_category());
+	return false;
+      }
+#else
+    __gnu_cxx::stdio_filebuf<char> sbin(in.fd, std::ios::in);
+    __gnu_cxx::stdio_filebuf<char> sbout(out.fd, std::ios::out);
+    if ( !(std::ostream(&sbout) << &sbin) )
+      {
+	ec = std::make_error_code(std::errc::io_error);
+	return false;
+      }
+#endif
+
+#ifdef _GLIBCXX_USE_FCHMOD
+    if (::fchmod(out.fd, from_st->st_mode))
+#elif _GLIBCXX_USE_FCHMODAT
+    if (::fchmodat(AT_FDCWD, to.c_str(), from_st->st_mode, 0))
+#else
+    if (::chmod(to.c_str(), from_st->st_mode))
+#endif
+      {
+	ec.assign(errno, std::generic_category());
+	return false;
+      }
+    ec.clear();
+    return true;
+  }
+}
+#endif
+
+void
+fs::copy(const path& from, const path& to, copy_options options,
+	 error_code& ec) noexcept
+{
+  bool skip_symlinks = is_set(options, copy_options::skip_symlinks);
+  bool create_symlinks = is_set(options, copy_options::create_symlinks);
+  bool use_lstat = create_symlinks || skip_symlinks;
+
+  file_status f, t;
+  stat_type from_st, to_st;
+  if (use_lstat
+      ? ::lstat(from.c_str(), &from_st)
+      : ::stat(from.c_str(), &from_st))
+    {
+      ec.assign(errno, std::generic_category());
+      return;
+    }
+  if (use_lstat
+      ? ::lstat(to.c_str(), &to_st)
+      : ::stat(to.c_str(), &to_st))
+    {
+      if (!is_not_found_errno(errno))
+	{
+	  ec.assign(errno, std::generic_category());
+	  return;
+	}
+      t = file_status{file_type::not_found};
+    }
+  else
+    t = make_file_status(to_st);
+  f = make_file_status(from_st);
+
+  if (exists(t) && !is_other(t) && !is_other(f)
+      && to_st.st_dev == from_st.st_dev && to_st.st_ino == from_st.st_ino)
+    {
+      ec = std::make_error_code(std::errc::file_exists);
+      return;
+    }
+  if (is_other(f) || is_other(t))
+    {
+      ec = std::make_error_code(std::errc::not_supported);
+      return;
+    }
+  if (is_directory(f) && is_regular_file(t))
+    {
+      ec = std::make_error_code(std::errc::is_a_directory);
+      return;
+    }
+
+  if (is_symlink(f))
+    {
+      if (skip_symlinks)
+	ec.clear();
+      else if (!exists(t) && is_set(options, copy_options::copy_symlinks))
+	copy_symlink(from, to, ec);
+      else
+	// Not clear what should be done here.
+	// "Otherwise report an error as specified in Error reporting (7)."
+	ec = std::make_error_code(std::errc::invalid_argument);
+    }
+  else if (is_regular_file(f))
+    {
+      if (is_set(options, copy_options::directories_only))
+	ec.clear();
+      else if (create_symlinks)
+	create_symlink(from, to, ec);
+      else if (is_set(options, copy_options::create_hard_links))
+	create_hard_link(from, to, ec);
+      else if (is_directory(t))
+	do_copy_file(from, to / from.filename(), options, &from_st, 0, ec);
+      else
+	{
+	  auto ptr = exists(t) ? &to_st : &from_st;
+	  do_copy_file(from, to, options, &from_st, ptr,  ec);
+	}
+    }
+  else if (is_directory(f) && (is_set(options, copy_options::recursive)
+			       || options == copy_options::none))
+    {
+      if (!exists(t))
+	if (!create_directory(to, from, ec))
+	  return;
+      // set an unused bit in options to disable further recursion
+      if (!is_set(options, copy_options::recursive))
+	options |= static_cast<copy_options>(4096);
+      for (const directory_entry& x : directory_iterator(from))
+	copy(x.path(), to/x.path().filename(), options, ec);
+    }
+  // "Otherwise no effects." (should ec.clear() be called?)
+}
+
+bool
+fs::copy_file(const path& from, const path& to, copy_options option)
+{
+  error_code ec;
+  bool result = copy_file(from, to, option, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot copy file", from, to,
+	  ec));
+  return result;
+}
+
+bool
+fs::copy_file(const path& from, const path& to, copy_options option,
+	      error_code& ec) noexcept
+{
+#ifdef _GLIBCXX_HAVE_SYS_STAT_H
+  return do_copy_file(from, to, option, nullptr, nullptr, ec);
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+  return false;
+#endif
+}
+
+
+void
+fs::copy_symlink(const path& existing_symlink, const path& new_symlink)
+{
+  error_code ec;
+  copy_symlink(existing_symlink, new_symlink, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot copy symlink",
+	  existing_symlink, new_symlink, ec));
+}
+
+void
+fs::copy_symlink(const path& existing_symlink, const path& new_symlink,
+		 error_code& ec) noexcept
+{
+  auto p = read_symlink(existing_symlink, ec);
+  if (ec.value())
+    return;
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  if (is_directory(p))
+    {
+      create_directory_symlink(p, new_symlink, ec);
+      return;
+    }
+#endif
+  create_symlink(p, new_symlink, ec);
+}
+
+
+bool
+fs::create_directories(const path& p)
+{
+  error_code ec;
+  bool result = create_directories(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot create directories", p,
+	  ec));
+  return result;
+}
+
+bool
+fs::create_directories(const path& p, error_code& ec) noexcept
+{
+  if (p.empty())
+    {
+      ec = std::make_error_code(errc::invalid_argument);
+      return false;
+    }
+  std::stack<path> missing;
+  path pp = p;
+
+  while (!pp.empty() && status(pp, ec).type() == file_type::not_found)
+    {
+      ec.clear();
+      const auto& filename = pp.filename();
+      if (!is_dot(filename) && !is_dotdot(filename))
+	missing.push(pp);
+      pp.remove_filename();
+    }
+
+  if (ec || missing.empty())
+    return false;
+
+  do
+    {
+      const path& top = missing.top();
+      create_directory(top, ec);
+      if (ec && is_directory(top))
+	ec.clear();
+      missing.pop();
+    }
+  while (!missing.empty() && !ec);
+
+  return missing.empty();
+}
+
+namespace
+{
+  bool
+  create_dir(const fs::path& p, fs::perms perm, std::error_code& ec)
+  {
+#ifdef _GLIBCXX_HAVE_SYS_STAT_H
+    ::mode_t mode = static_cast<std::underlying_type_t<fs::perms>>(perm);
+    if (::mkdir(p.c_str(), mode))
+      {
+	ec.assign(errno, std::generic_category());
+	return false;
+      }
+    else
+      {
+	ec.clear();
+	return true;
+      }
+#else
+    ec = std::make_error_code(std::errc::not_supported);
+    return false;
+#endif
+  }
+} // namespace
+
+bool
+fs::create_directory(const path& p)
+{
+  error_code ec;
+  bool result = create_directory(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot create directory", p,
+	  ec));
+  return result;
+}
+
+bool
+fs::create_directory(const path& p, error_code& ec) noexcept
+{
+  return create_dir(p, perms::all, ec);
+}
+
+
+bool
+fs::create_directory(const path& p, const path& attributes)
+{
+  error_code ec;
+  bool result = create_directory(p, attributes, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot create directory", p,
+	  ec));
+  return result;
+}
+
+bool
+fs::create_directory(const path& p, const path& attributes,
+		     error_code& ec) noexcept
+{
+#ifdef _GLIBCXX_HAVE_SYS_STAT_H
+  stat_type st;
+  if (::stat(attributes.c_str(), &st))
+    {
+      ec.assign(errno, std::generic_category());
+      return false;
+    }
+  return create_dir(p, static_cast<perms>(st.st_mode), ec);
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+  return false;
+#endif
+}
+
+
+void
+fs::create_directory_symlink(const path& to, const path& new_symlink)
+{
+  error_code ec;
+  create_directory_symlink(to, new_symlink, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot create directory symlink",
+	  to, new_symlink, ec));
+}
+
+void
+fs::create_directory_symlink(const path& to, const path& new_symlink,
+			     error_code& ec) noexcept
+{
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  ec = std::make_error_code(std::errc::not_supported);
+#else
+  create_symlink(to, new_symlink, ec);
+#endif
+}
+
+
+void
+fs::create_hard_link(const path& to, const path& new_hard_link)
+{
+  error_code ec;
+  create_hard_link(to, new_hard_link, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot create hard link",
+	  to, new_hard_link, ec));
+}
+
+void
+fs::create_hard_link(const path& to, const path& new_hard_link,
+		     error_code& ec) noexcept
+{
+#ifdef _GLIBCXX_HAVE_UNISTD_H
+  if (::link(to.c_str(), new_hard_link.c_str()))
+    ec.assign(errno, std::generic_category());
+  else
+    ec.clear();
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+#endif
+}
+
+void
+fs::create_symlink(const path& to, const path& new_symlink)
+{
+  error_code ec;
+  create_symlink(to, new_symlink, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot create symlink",
+	  to, new_symlink, ec));
+}
+
+void
+fs::create_symlink(const path& to, const path& new_symlink,
+		   error_code& ec) noexcept
+{
+#ifdef _GLIBCXX_HAVE_UNISTD_H
+  if (::symlink(to.c_str(), new_symlink.c_str()))
+    ec.assign(errno, std::generic_category());
+  else
+    ec.clear();
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+#endif
+}
+
+
+fs::path
+fs::current_path()
+{
+  error_code ec;
+  path p = current_path(ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot get current path", ec));
+  return p;
+}
+
+fs::path
+fs::current_path(error_code& ec)
+{
+  path p;
+#ifdef _GLIBCXX_HAVE_UNISTD_H
+#ifdef __GLIBC__
+  if (char_ptr cwd = char_ptr{::getcwd(nullptr, 0)})
+    {
+      p.assign(cwd.get());
+      ec.clear();
+    }
+  else
+    ec.assign(errno, std::generic_category());
+#else
+  long path_max = pathconf(".", _PC_PATH_MAX);
+  size_t size;
+  if (path_max == -1)
+      size = 1024;
+  else if (path_max > 10240)
+      size = 10240;
+  else
+      size = path_max;
+  for (char_ptr buf; p.empty(); size *= 2)
+    {
+      buf.reset((char*)malloc(size));
+      if (buf)
+	{
+	  if (getcwd(buf.get(), size))
+	    {
+	      p.assign(buf.get());
+	      ec.clear();
+	    }
+	  else if (errno != ERANGE)
+	    {
+	      ec.assign(errno, std::generic_category());
+	      return {};
+	    }
+	}
+      else
+	{
+	  ec = std::make_error_code(std::errc::not_enough_memory);
+	  return {};
+	}
+    }
+#endif  // __GLIBC__
+#else   // _GLIBCXX_HAVE_UNISTD_H
+  ec = std::make_error_code(std::errc::not_supported);
+#endif
+  return p;
+}
+
+void
+fs::current_path(const path& p)
+{
+  error_code ec;
+  current_path(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot set current path", ec));
+}
+
+void
+fs::current_path(const path& p, error_code& ec) noexcept
+{
+#ifdef _GLIBCXX_HAVE_UNISTD_H
+  if (::chdir(p.c_str()))
+    ec.assign(errno, std::generic_category());
+  else
+    ec.clear();
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+#endif
+}
+
+bool
+fs::equivalent(const path& p1, const path& p2)
+{
+  error_code ec;
+  auto result = equivalent(p1, p2, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot check file equivalence",
+	  p1, p2, ec));
+  return result;
+}
+
+bool
+fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept
+{
+#ifdef _GLIBCXX_HAVE_SYS_STAT_H
+  stat_type st1, st2;
+  if (::stat(p1.c_str(), &st1) == 0 && ::stat(p2.c_str(), &st2) == 0)
+    {
+      file_status s1 = make_file_status(st1);
+      file_status s2 = make_file_status(st2);
+      if (is_other(s1) && is_other(s2))
+	{
+	  ec = std::make_error_code(std::errc::not_supported);
+	  return false;
+	}
+      ec.clear();
+      return st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino;
+    }
+  else if (is_not_found_errno(errno))
+    {
+      ec = std::make_error_code(std::errc::no_such_file_or_directory);
+      return false;
+    }
+  ec.assign(errno, std::generic_category());
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+#endif
+  return false;
+}
+
+std::uintmax_t
+fs::file_size(const path& p)
+{
+  error_code ec;
+  auto sz = file_size(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot get file size", p, ec));
+  return sz;
+}
+
+namespace
+{
+  template<typename Accessor, typename T>
+    inline T
+    do_stat(const fs::path& p, std::error_code& ec, Accessor f, T deflt)
+    {
+#ifdef _GLIBCXX_HAVE_SYS_STAT_H
+      stat_type st;
+      if (::stat(p.c_str(), &st))
+	{
+	  ec.assign(errno, std::generic_category());
+	  return deflt;
+	}
+      ec.clear();
+      return f(st);
+#else
+      ec = std::make_error_code(std::errc::not_supported);
+      return deflt;
+#endif
+    }
+}
+
+std::uintmax_t
+fs::file_size(const path& p, error_code& ec) noexcept
+{
+  struct S
+  {
+    S(const stat_type& st) : type(make_file_type(st)), size(st.st_size) { }
+    S() : type(file_type::not_found) { }
+    file_type type;
+    size_t size;
+  };
+  auto s = do_stat(p, ec, [](const auto& st) { return S{st}; }, S{});
+  if (s.type == file_type::regular)
+    return s.size;
+  if (!ec)
+    {
+      if (s.type == file_type::directory)
+	ec = std::make_error_code(std::errc::is_a_directory);
+      else
+	ec = std::make_error_code(std::errc::not_supported);
+    }
+  return -1;
+}
+
+std::uintmax_t
+fs::hard_link_count(const path& p)
+{
+  error_code ec;
+  auto count = hard_link_count(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot get link count", p, ec));
+  return count;
+}
+
+std::uintmax_t
+fs::hard_link_count(const path& p, error_code& ec) noexcept
+{
+  return do_stat(p, ec, std::mem_fn(&stat::st_nlink),
+		 static_cast<uintmax_t>(-1));
+}
+
+bool
+fs::is_empty(const path& p)
+{
+  return fs::is_directory(status(p))
+    ? fs::directory_iterator(p) == fs::directory_iterator()
+    : fs::file_size(p) == 0;
+}
+
+bool
+fs::is_empty(const path& p, error_code& ec) noexcept
+{
+  auto s = status(p, ec);
+  if (ec.value())
+    return false;
+  return fs::is_directory(s)
+    ? fs::directory_iterator(p, ec) == fs::directory_iterator()
+    : fs::file_size(p, ec) == 0;
+}
+
+fs::file_time_type
+fs::last_write_time(const path& p)
+{
+  error_code ec;
+  auto t = last_write_time(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot get file time", p, ec));
+  return t;
+}
+
+fs::file_time_type
+fs::last_write_time(const path& p, error_code& ec) noexcept
+{
+  return do_stat(p, ec, [](const auto& st) { return file_time(st); },
+		 file_time_type::min());
+}
+
+void
+fs::last_write_time(const path& p, file_time_type new_time)
+{
+  error_code ec;
+  last_write_time(p, new_time, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot set file time", p, ec));
+}
+
+void
+fs::last_write_time(const path& p __attribute__((__unused__)),
+		    file_time_type new_time, error_code& ec) noexcept
+{
+  auto d = new_time.time_since_epoch();
+  auto s = chrono::duration_cast<chrono::seconds>(d);
+#if _GLIBCXX_USE_UTIMENSAT
+  auto ns = chrono::duration_cast<chrono::nanoseconds>(d - s);
+  struct ::timespec ts[2];
+  ts[0].tv_sec = 0;
+  ts[0].tv_nsec = UTIME_OMIT;
+  ts[1].tv_sec = static_cast<std::time_t>(s.count());
+  ts[1].tv_nsec = static_cast<long>(ns.count());
+  if (::utimensat(AT_FDCWD, p.c_str(), ts, 0))
+    ec.assign(errno, std::generic_category());
+  else
+    ec.clear();
+#elif _GLIBCXX_HAVE_UTIME_H
+  ::utimbuf times;
+  times.modtime = s.count();
+  times.actime = do_stat(p, ec, [](const auto& st) { return st.st_atime; },
+			 times.modtime);
+  if (::utime(p.c_str(), &times))
+    ec.assign(errno, std::generic_category());
+  else
+    ec.clear();
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+#endif
+}
+
+void
+fs::permissions(const path& p, perms prms)
+{
+  error_code ec;
+  permissions(p, prms, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot set permissions", p, ec));
+}
+
+void fs::permissions(const path& p, perms prms, error_code& ec) noexcept
+{
+#if _GLIBCXX_USE_FCHMODAT
+  if (::fchmodat(AT_FDCWD, p.c_str(), static_cast<mode_t>(prms), 0))
+#else
+  if (::chmod(p.c_str(), static_cast<mode_t>(prms)))
+#endif
+    ec.assign(errno, std::generic_category());
+  else
+    ec.clear();
+}
+
+fs::path
+fs::read_symlink(const path& p)
+{
+  error_code ec;
+  path tgt = read_symlink(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("read_symlink", p, ec));
+  return tgt;
+}
+
+fs::path fs::read_symlink(const path& p, error_code& ec)
+{
+#ifdef _GLIBCXX_HAVE_SYS_STAT_H
+  stat_type st;
+  if (::lstat(p.c_str(), &st))
+    {
+      ec.assign(errno, std::generic_category());
+      return {};
+    }
+  std::string buf(st.st_size, '\0');
+  ssize_t len = ::readlink(p.c_str(), &buf.front(), buf.size());
+  if (len == -1)
+    {
+      ec.assign(errno, std::generic_category());
+      return {};
+    }
+  return path{buf.data(), buf.data()+len};
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+  return {};
+#endif
+}
+
+
+bool
+fs::remove(const path& p)
+{
+  error_code ec;
+  bool result = fs::remove(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot remove", p, ec));
+  return result;
+}
+
+bool
+fs::remove(const path& p, error_code& ec) noexcept
+{
+  if (exists(symlink_status(p, ec)))
+    {
+      if (::remove(p.c_str()) == 0)
+	{
+	  ec.clear();
+	  return true;
+	}
+      else
+	ec.assign(errno, std::generic_category());
+    }
+  return false;
+}
+
+
+std::uintmax_t
+fs::remove_all(const path& p)
+{
+  error_code ec;
+  bool result = remove_all(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot remove all", p, ec));
+  return result;
+}
+
+std::uintmax_t
+fs::remove_all(const path& p, error_code& ec) noexcept
+{
+  auto fs = symlink_status(p, ec);
+  uintmax_t count = 0;
+  if (ec.value() == 0 && fs.type() == file_type::directory)
+    for (directory_iterator d(p, ec), end; ec.value() == 0 && d != end; ++d)
+      count += fs::remove(d->path(), ec);
+  if (ec.value())
+    return -1;
+  return fs::remove(p, ec) ? ++count : -1;  // fs:remove() calls ec.clear()
+}
+
+void
+fs::rename(const path& from, const path& to)
+{
+  error_code ec;
+  rename(from, to, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot rename", from, to, ec));
+}
+
+void
+fs::rename(const path& from, const path& to, error_code& ec) noexcept
+{
+  if (::rename(from.c_str(), to.c_str()))
+    ec.assign(errno, std::generic_category());
+  else
+    ec.clear();
+}
+
+void
+fs::resize_file(const path& p, uintmax_t size)
+{
+  error_code ec;
+  resize_file(p, size, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot resize file", p, ec));
+}
+
+void
+fs::resize_file(const path& p, uintmax_t size, error_code& ec) noexcept
+{
+#ifdef _GLIBCXX_HAVE_UNISTD_H
+  if (size > static_cast<uintmax_t>(std::numeric_limits<off_t>::max()))
+    ec.assign(EINVAL, std::generic_category());
+  else if (::truncate(p.c_str(), size))
+    ec.assign(errno, std::generic_category());
+  else
+    ec.clear();
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+#endif
+}
+
+
+fs::space_info
+fs::space(const path& p)
+{
+  error_code ec;
+  space_info s = space(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot get free space", p, ec));
+  return s;
+}
+
+fs::space_info
+fs::space(const path& p, error_code& ec) noexcept
+{
+  space_info info = {
+    static_cast<uintmax_t>(-1),
+    static_cast<uintmax_t>(-1),
+    static_cast<uintmax_t>(-1)
+  };
+#ifdef _GLIBCXX_HAVE_SYS_STATVFS_H
+  struct ::statvfs f;
+  if (::statvfs(p.c_str(), &f))
+      ec.assign(errno, std::generic_category());
+  else
+    {
+      info = space_info{
+	f.f_blocks * f.f_frsize,
+	f.f_bfree * f.f_frsize,
+	f.f_bavail * f.f_frsize
+      };
+      ec.clear();
+    }
+#else
+  ec = std::make_error_code(std::errc::not_supported);
+#endif
+  return info;
+}
+
+#ifdef _GLIBCXX_HAVE_SYS_STAT_H
+fs::file_status
+fs::status(const fs::path& p, std::error_code& ec) noexcept
+{
+  file_status status;
+  stat_type st;
+  if (::stat(p.c_str(), &st))
+    {
+      int err = errno;
+      ec.assign(err, std::generic_category());
+      if (is_not_found_errno(err))
+	status.type(file_type::not_found);
+    }
+  else
+    {
+      status = make_file_status(st);
+      ec.clear();
+    }
+  return status;
+}
+
+fs::file_status
+fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept
+{
+  file_status status;
+  stat_type st;
+  if (::lstat(p.c_str(), &st))
+    {
+      int err = errno;
+      ec.assign(err, std::generic_category());
+      if (is_not_found_errno(err))
+	status.type(file_type::not_found);
+    }
+  else
+    {
+      status = make_file_status(st);
+      ec.clear();
+    }
+  return status;
+}
+#endif
+
+fs::file_status
+fs::status(const fs::path& p)
+{
+  std::error_code ec;
+  auto result = status(p, ec);
+  if (result.type() == file_type::none)
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("status", p, ec));
+  return result;
+}
+
+fs::file_status
+fs::symlink_status(const fs::path& p)
+{
+  std::error_code ec;
+  auto result = symlink_status(p, ec);
+  if (result.type() == file_type::none)
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("symlink_status", p, ec));
+  return result;
+}
+
+fs::path
+fs::system_complete(const path& p)
+{
+  error_code ec;
+  path comp = system_complete(p, ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("system_complete", p, ec));
+  return comp;
+}
+
+fs::path
+fs::system_complete(const path& p, error_code& ec)
+{
+  path base = current_path(ec);
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  if (p.is_absolute() || !p.has_root_name()
+      || p.root_name() == base.root_name())
+    return absolute(p, base);
+  // else TODO
+  ec = std::make_error_code(std::errc::not_supported);
+  return {};
+#else
+  if (ec.value())
+    return {};
+  return absolute(p, base);
+#endif
+}
+
+fs::path fs::temp_directory_path()
+{
+  error_code ec;
+  path tmp = temp_directory_path(ec);
+  if (ec.value())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("temp_directory_path", ec));
+  return tmp;
+}
+
+fs::path fs::temp_directory_path(error_code& ec)
+{
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  ec = std::make_error_code(std::errc::not_supported);
+  return {}; // TODO
+#else
+  const char* tmpdir = nullptr;
+  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
+  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
+    tmpdir = ::getenv(*e);
+  path p = tmpdir ? tmpdir : "/tmp";
+  if (exists(p) && is_directory(p))
+    {
+      ec.clear();
+      return p;
+    }
+  ec = std::make_error_code(std::errc::not_a_directory);
+  return {};
+#endif
+}
+
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/filesystem/path.cc gcc-5.2.0/libstdc++-v3/src/filesystem/path.cc
--- gcc-5.2.0.orig/libstdc++-v3/src/filesystem/path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/filesystem/path.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,479 @@
+// Class filesystem::path -*- C++ -*-
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#ifndef _GLIBCXX_USE_CXX11_ABI
+# define _GLIBCXX_USE_CXX11_ABI 1
+#endif
+
+#include <experimental/filesystem>
+
+using std::experimental::filesystem::path;
+
+std::experimental::filesystem::filesystem_error::~filesystem_error() = default;
+
+constexpr path::value_type path::preferred_separator;
+
+path&
+path::remove_filename()
+{
+  if (_M_type == _Type::_Multi)
+    {
+      if (!_M_cmpts.empty())
+	{
+	  auto cmpt = std::prev(_M_cmpts.end());
+	  _M_pathname.erase(cmpt->_M_pos);
+	  _M_cmpts.erase(cmpt);
+	  _M_trim();
+	}
+    }
+  else
+    clear();
+  return *this;
+}
+
+path&
+path::replace_filename(const path& replacement)
+{
+  remove_filename();
+  operator/=(replacement);
+  return *this;
+}
+
+path&
+path::replace_extension(const path& replacement)
+{
+  auto ext = _M_find_extension();
+  if (ext.first && ext.second != string_type::npos)
+    {
+      if (ext.first == &_M_pathname)
+	_M_pathname.erase(ext.second);
+      else
+	{
+	  const auto& back = _M_cmpts.back();
+	  if (ext.first != &back._M_pathname)
+	    _GLIBCXX_THROW_OR_ABORT(
+		std::logic_error("path::replace_extension failed"));
+	  _M_pathname.erase(back._M_pos + ext.second);
+	}
+    }
+  if (!replacement.empty() && replacement.native()[0] != '.')
+    _M_pathname += '.';
+  _M_pathname += replacement.native();
+  _M_split_cmpts();
+  return *this;
+}
+
+namespace
+{
+  template<typename Iter1, typename Iter2>
+    int do_compare(Iter1 begin1, Iter1 end1, Iter2 begin2, Iter2 end2)
+    {
+      int cmpt = 1;
+      while (begin1 != end1 && begin2 != end2)
+	{
+	  if (begin1->native() < begin2->native())
+	    return -cmpt;
+	  if (begin1->native() > begin2->native())
+	    return +cmpt;
+	  ++begin1;
+	  ++begin2;
+	  ++cmpt;
+	}
+      if (begin1 == end1)
+	{
+	  if (begin2 == end2)
+	    return 0;
+	  return -cmpt;
+	}
+      return +cmpt;
+    }
+}
+
+int
+path::compare(const path& p) const noexcept
+{
+  struct CmptRef
+  {
+    const path* ptr;
+    const string_type& native() const noexcept { return ptr->native(); }
+  };
+
+  if (_M_type == _Type::_Multi && p._M_type == _Type::_Multi)
+    return do_compare(_M_cmpts.begin(), _M_cmpts.end(),
+		      p._M_cmpts.begin(), p._M_cmpts.end());
+  else if (_M_type == _Type::_Multi)
+    {
+      CmptRef c[1] = { { &p } };
+      return do_compare(_M_cmpts.begin(), _M_cmpts.end(), c, c+1);
+    }
+  else if (p._M_type == _Type::_Multi)
+    {
+      CmptRef c[1] = { { this } };
+      return do_compare(c, c+1, p._M_cmpts.begin(), p._M_cmpts.end());
+    }
+  else
+    return _M_pathname.compare(p._M_pathname);
+}
+
+path
+path::root_name() const
+{
+  path __ret;
+  if (_M_type == _Type::_Root_name)
+    __ret = *this;
+  else if (_M_cmpts.size() && _M_cmpts.begin()->_M_type == _Type::_Root_name)
+    __ret = *_M_cmpts.begin();
+  return __ret;
+}
+
+path
+path::root_directory() const
+{
+  path __ret;
+  if (_M_type == _Type::_Root_dir)
+    __ret = *this;
+  else if (!_M_cmpts.empty())
+    {
+      auto __it = _M_cmpts.begin();
+      if (__it->_M_type == _Type::_Root_name)
+        ++__it;
+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)
+        __ret = *__it;
+    }
+  return __ret;
+}
+
+
+path
+path::root_path() const
+{
+  path __ret;
+  if (_M_type == _Type::_Root_name || _M_type == _Type::_Root_dir)
+    __ret = *this;
+  else if (!_M_cmpts.empty())
+    {
+      auto __it = _M_cmpts.begin();
+      if (__it->_M_type == _Type::_Root_name)
+        {
+          __ret = *__it++;
+          if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)
+            {
+              __ret._M_pathname += preferred_separator;
+              __ret._M_split_cmpts();
+            }
+        }
+      else if (__it->_M_type == _Type::_Root_dir)
+        __ret = *__it;
+    }
+  return __ret;
+}
+
+path
+path::relative_path() const
+{
+  path __ret;
+  if (_M_type == _Type::_Filename)
+    __ret = *this;
+  else if (!_M_cmpts.empty())
+    {
+      auto __it = _M_cmpts.begin();
+      if (__it->_M_type == _Type::_Root_name)
+        ++__it;
+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)
+        ++__it;
+      if (__it != _M_cmpts.end())
+        __ret.assign(_M_pathname.substr(__it->_M_pos));
+    }
+  return __ret;
+}
+
+path
+path::parent_path() const
+{
+  path __ret;
+  if (_M_cmpts.size() < 2)
+    return __ret;
+  for (auto __it = _M_cmpts.begin(), __end = std::prev(_M_cmpts.end());
+       __it != __end; ++__it)
+    {
+      __ret /= *__it;
+    }
+  return __ret;
+}
+
+bool
+path::has_root_name() const
+{
+  if (_M_type == _Type::_Root_name)
+    return true;
+  if (!_M_cmpts.empty() && _M_cmpts.begin()->_M_type == _Type::_Root_name)
+    return true;
+  return false;
+}
+
+bool
+path::has_root_directory() const
+{
+  if (_M_type == _Type::_Root_dir)
+    return true;
+  if (!_M_cmpts.empty())
+    {
+      auto __it = _M_cmpts.begin();
+      if (__it->_M_type == _Type::_Root_name)
+        ++__it;
+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)
+        return true;
+    }
+  return false;
+}
+
+bool
+path::has_root_path() const
+{
+  if (_M_type == _Type::_Root_name || _M_type == _Type::_Root_dir)
+    return true;
+  if (!_M_cmpts.empty())
+    {
+      auto __type = _M_cmpts.front()._M_type;
+      if (__type == _Type::_Root_name || __type == _Type::_Root_dir)
+        return true;
+    }
+  return false;
+}
+
+bool
+path::has_relative_path() const
+{
+  if (_M_type == _Type::_Filename)
+    return true;
+  if (!_M_cmpts.empty())
+    {
+      auto __it = _M_cmpts.begin();
+      if (__it->_M_type == _Type::_Root_name)
+        ++__it;
+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)
+        ++__it;
+      if (__it != _M_cmpts.end())
+        return true;
+    }
+  return false;
+}
+
+
+bool
+path::has_parent_path() const
+{
+  return _M_cmpts.size() > 1;
+}
+
+bool
+path::has_filename() const
+{
+  return !empty();
+}
+
+std::pair<const path::string_type*, std::size_t>
+path::_M_find_extension() const
+{
+  const std::string* s = nullptr;
+
+  if (_M_type != _Type::_Multi)
+    s = &_M_pathname;
+  else if (!_M_cmpts.empty())
+    {
+      const auto& c = _M_cmpts.back();
+      if (c._M_type == _Type::_Filename)
+	s = &c._M_pathname;
+    }
+
+  if (s)
+    {
+      if (auto sz = s->size())
+	{
+	  if (sz <= 2 && (*s)[0] == '.')
+	    {
+	      if (sz == 1 || (*s)[1] == '.')  // filename is "." or ".."
+		return { s, string_type::npos };
+	      else
+		return { s, 0 };  // filename is like ".?"
+	    }
+	  return { s, s->rfind('.') };
+	}
+    }
+  return {};
+}
+
+void
+path::_M_split_cmpts()
+{
+  _M_type = _Type::_Multi;
+  _M_cmpts.clear();
+
+  if (_M_pathname.empty())
+    return;
+
+  size_t pos = 0;
+  const size_t len = _M_pathname.size();
+
+  // look for root name or root directory
+  if (_S_is_dir_sep(_M_pathname[0]))
+    {
+      // look for root name, such as "//" or "//foo"
+      if (len > 1 && _M_pathname[1] == _M_pathname[0])
+	{
+	  if (len == 2)
+	    {
+	      // entire path is just "//"
+	      _M_type = _Type::_Root_name;
+	      return;
+	    }
+
+	  if (!_S_is_dir_sep(_M_pathname[2]))
+	    {
+	      // got root name, find its end
+	      pos = 3;
+	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
+		++pos;
+	      _M_add_root_name(pos);
+	      if (pos < len) // also got root directory
+		_M_add_root_dir(pos);
+	    }
+	  else
+	    {
+	      // got something like "///foo" which is just a root directory
+	      // composed of multiple redundant directory separators
+	      _M_add_root_dir(0);
+	    }
+	}
+      else // got root directory
+	_M_add_root_dir(0);
+      ++pos;
+    }
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  else if (len > 1 && _M_pathname[1] == L':')
+    {
+      // got disk designator
+      _M_add_root_name(2);
+      if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
+	_M_add_root_dir(2);
+      pos = 2;
+    }
+#endif
+
+  size_t back = pos;
+  while (pos < len)
+    {
+      if (_S_is_dir_sep(_M_pathname[pos]))
+	{
+	  if (back != pos)
+	    _M_add_filename(back, pos - back);
+	  back = ++pos;
+	}
+      else
+	++pos;
+    }
+
+  if (back != pos)
+    _M_add_filename(back, pos - back);
+  else if (_S_is_dir_sep(_M_pathname.back()))
+    {
+      // [path.itr]/8
+      // "Dot, if one or more trailing non-root slash characters are present."
+      if (_M_cmpts.back()._M_type == _Type::_Filename)
+	{
+	  const auto& last = _M_cmpts.back();
+	  pos = last._M_pos + last._M_pathname.size();
+	  _M_cmpts.emplace_back(string_type(1, '.'), _Type::_Filename, pos);
+	}
+    }
+
+  _M_trim();
+}
+
+void
+path::_M_add_root_name(size_t n)
+{
+  _M_cmpts.emplace_back(_M_pathname.substr(0, n), _Type::_Root_name, 0);
+}
+
+void
+path::_M_add_root_dir(size_t pos)
+{
+  _M_cmpts.emplace_back(_M_pathname.substr(pos, 1), _Type::_Root_dir, pos);
+}
+
+void
+path::_M_add_filename(size_t pos, size_t n)
+{
+  _M_cmpts.emplace_back(_M_pathname.substr(pos, n), _Type::_Filename, pos);
+}
+
+void
+path::_M_trim()
+{
+  if (_M_cmpts.size() == 1)
+    {
+      _M_type = _M_cmpts.front()._M_type;
+      _M_cmpts.clear();
+    }
+}
+
+path::string_type
+path::_S_convert_loc(const char* __first, const char* __last,
+		     const std::locale& __loc)
+{
+#if _GLIBCXX_USE_WCHAR_T
+  auto& __cvt = std::use_facet<codecvt<wchar_t, char, mbstate_t>>(__loc);
+  basic_string<wchar_t> __ws;
+  if (!__str_codecvt_in(__first, __last, __ws, __cvt))
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(
+	  "Cannot convert character sequence",
+	  std::make_error_code(errc::illegal_byte_sequence)));
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  return __ws;
+#else
+  return _Cvt<wchar_t>::_S_convert(__ws.data(), __ws.data() + __ws.size());
+#endif
+#else
+  return {__first, __last};
+#endif
+}
+
+std::size_t
+std::experimental::filesystem::hash_value(const path& p) noexcept
+{
+  // [path.non-member]
+  // "If for two paths, p1 == p2 then hash_value(p1) == hash_value(p2)."
+  // Equality works as if by traversing the range [begin(), end()), meaning
+  // e.g. path("a//b") == path("a/b"), so we cannot simply hash _M_pathname
+  // but need to iterate over individual elements. Use the hash_combine from
+  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3876.pdf
+  size_t seed = 0;
+  for (const auto& x : p)
+    {
+      seed ^= std::hash<path::string_type>()(x.native()) + 0x9e3779b9
+	+ (seed<<6) + (seed>>2);
+    }
+  return seed;
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/Makefile.am gcc-5.2.0/libstdc++-v3/src/Makefile.am
--- gcc-5.2.0.orig/libstdc++-v3/src/Makefile.am	2015-01-29 02:03:56.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/Makefile.am	2015-08-18 12:58:22.597022000 -0500
@@ -22,7 +22,13 @@
 
 include $(top_srcdir)/fragment.am
 
-SUBDIRS = c++98 c++11
+if ENABLE_FILESYSTEM_TS
+filesystem_dir = filesystem
+else
+filesystem_dir =
+endif
+
+SUBDIRS = c++98 c++11 $(filesystem_dir)
 
 # Cross compiler support.
 if VTV_CYGMIN
@@ -52,6 +58,9 @@
 
 vpath % $(top_srcdir)/src/c++98
 vpath % $(top_srcdir)/src/c++11
+if ENABLE_FILESYSTEM_TS
+vpath % $(top_srcdir)/src/filesystem
+endif
 
 if GLIBCXX_LDBL_COMPAT
 ldbl_compat_sources = compatibility-ldbl.cc
diff -Naur gcc-5.2.0.orig/libstdc++-v3/src/Makefile.in gcc-5.2.0/libstdc++-v3/src/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/src/Makefile.in	2015-01-29 10:47:25.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/src/Makefile.in	2015-08-18 12:58:22.597022000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -16,6 +16,23 @@
 @SET_MAKE@
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -86,6 +103,12 @@
 am__base_list = \
   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
   sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
 am__installdirs = "$(DESTDIR)$(toolexeclibdir)"
 LTLIBRARIES = $(toolexeclib_LTLIBRARIES)
 am__DEPENDENCIES_1 =
@@ -117,13 +140,18 @@
 	install-pdf-recursive install-ps-recursive install-recursive \
 	installcheck-recursive installdirs-recursive pdf-recursive \
 	ps-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
 AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
 	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS
 ETAGS = etags
 CTAGS = ctags
-DIST_SUBDIRS = $(SUBDIRS)
+DIST_SUBDIRS = c++98 c++11 filesystem
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
 ACLOCAL = @ACLOCAL@
 ALLOCATOR_H = @ALLOCATOR_H@
@@ -346,7 +374,9 @@
 
 # -I/-D flags to pass when compiling.
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES)
-SUBDIRS = c++98 c++11
+@ENABLE_FILESYSTEM_TS_FALSE@filesystem_dir = 
+@ENABLE_FILESYSTEM_TS_TRUE@filesystem_dir = filesystem
+SUBDIRS = c++98 c++11 $(filesystem_dir)
 @VTV_CYGMIN_FALSE@toolexeclib_LTLIBRARIES = libstdc++.la
 
 # Cross compiler support.
@@ -529,6 +559,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -540,7 +571,6 @@
 $(am__aclocal_m4_deps):
 install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)"
 	@list='$(toolexeclib_LTLIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
 	list2=; for p in $$list; do \
 	  if test -f $$p; then \
@@ -548,6 +578,8 @@
 	  else :; fi; \
 	done; \
 	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)" || exit 1; \
 	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'"; \
 	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(toolexeclibdir)"; \
 	}
@@ -569,9 +601,9 @@
 	  echo "rm -f \"$${dir}/so_locations\""; \
 	  rm -f "$${dir}/so_locations"; \
 	done
-libstdc++.la: $(libstdc___la_OBJECTS) $(libstdc___la_DEPENDENCIES) 
+libstdc++.la: $(libstdc___la_OBJECTS) $(libstdc___la_DEPENDENCIES) $(EXTRA_libstdc___la_DEPENDENCIES) 
 	$(libstdc___la_LINK) $(am_libstdc___la_rpath) $(libstdc___la_OBJECTS) $(libstdc___la_LIBADD) $(LIBS)
-libvtv.la: $(libvtv_la_OBJECTS) $(libvtv_la_DEPENDENCIES) 
+libvtv.la: $(libvtv_la_OBJECTS) $(libvtv_la_DEPENDENCIES) $(EXTRA_libvtv_la_DEPENDENCIES) 
 	$(libvtv_la_LINK) $(am_libvtv_la_rpath) $(libvtv_la_OBJECTS) $(libvtv_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
@@ -747,10 +779,15 @@
 
 installcheck: installcheck-recursive
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
@@ -859,6 +896,7 @@
 
 vpath % $(top_srcdir)/src/c++98
 vpath % $(top_srcdir)/src/c++11
+@ENABLE_FILESYSTEM_TS_TRUE@vpath % $(top_srcdir)/src/filesystem
 
 # Use special rules for compatibility-ldbl.cc compilation, as we need to
 # pass -mlong-double-64.
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/18_support/exception_ptr/62258.cc gcc-5.2.0/libstdc++-v3/testsuite/18_support/exception_ptr/62258.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/18_support/exception_ptr/62258.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/18_support/exception_ptr/62258.cc	2015-09-03 10:10:25.457825000 -0500
@@ -0,0 +1,61 @@
+// { dg-options "-std=gnu++11" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/62258
+
+#include <exception>
+#include <testsuite_hooks.h>
+
+struct check_on_destruct
+{
+  ~check_on_destruct();
+};
+
+check_on_destruct::~check_on_destruct()
+{
+  VERIFY(std::uncaught_exception());
+}
+
+int main ()
+{
+  VERIFY(!std::uncaught_exception());
+
+  try
+    {
+      check_on_destruct check;
+
+      try
+        {
+          throw 1;
+        }
+      catch (...)
+        {
+          VERIFY(!std::uncaught_exception());
+
+          std::rethrow_exception(std::current_exception());
+        }
+    }
+  catch (...)
+    {
+      VERIFY(!std::uncaught_exception());
+    }
+
+  VERIFY(!std::uncaught_exception());
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char/65049.cc gcc-5.2.0/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char/65049.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char/65049.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char/65049.cc	2015-10-02 15:08:17.234342000 -0500
@@ -0,0 +1,48 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+// libstdc++/65049
+
+#include <string>
+#include <testsuite_hooks.h>
+
+using C = char;
+
+void
+test01()
+{
+  const C* p = 0;
+  C* q = 0;
+  auto c = std::char_traits<C>::compare(p, q, 0);
+  VERIFY( c == 0 );
+  auto r = std::char_traits<C>::find(p, 0, '0');
+  VERIFY( r == nullptr );
+  r = std::char_traits<C>::move(q, p, 0);
+  VERIFY( r == q );
+  r = std::char_traits<C>::copy(q, p, 0);
+  VERIFY( r == q );
+  r = std::char_traits<C>::assign(q, 0, '0');
+  VERIFY( r == q );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char16_t/65049.cc gcc-5.2.0/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char16_t/65049.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char16_t/65049.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char16_t/65049.cc	2015-10-02 15:08:17.234342000 -0500
@@ -0,0 +1,48 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+// libstdc++/65049
+
+#include <string>
+#include <testsuite_hooks.h>
+
+using C = char16_t;
+
+void
+test01()
+{
+  const C* p = 0;
+  C* q = 0;
+  auto c = std::char_traits<C>::compare(p, q, 0);
+  VERIFY( c == 0 );
+  auto r = std::char_traits<C>::find(p, 0, '0');
+  VERIFY( r == nullptr );
+  r = std::char_traits<C>::move(q, p, 0);
+  VERIFY( r == q );
+  r = std::char_traits<C>::copy(q, p, 0);
+  VERIFY( r == q );
+  r = std::char_traits<C>::assign(q, 0, '0');
+  VERIFY( r == q );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char32_t/65049.cc gcc-5.2.0/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char32_t/65049.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char32_t/65049.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/21_strings/char_traits/requirements/char32_t/65049.cc	2015-10-02 15:08:17.234342000 -0500
@@ -0,0 +1,48 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+// libstdc++/65049
+
+#include <string>
+#include <testsuite_hooks.h>
+
+using C = char32_t;
+
+void
+test01()
+{
+  const C* p = 0;
+  C* q = 0;
+  auto c = std::char_traits<C>::compare(p, q, 0);
+  VERIFY( c == 0 );
+  auto r = std::char_traits<C>::find(p, 0, '0');
+  VERIFY( r == nullptr );
+  r = std::char_traits<C>::move(q, p, 0);
+  VERIFY( r == q );
+  r = std::char_traits<C>::copy(q, p, 0);
+  VERIFY( r == q );
+  r = std::char_traits<C>::assign(q, 0, '0');
+  VERIFY( r == q );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/21_strings/char_traits/requirements/wchar_t/65049.cc gcc-5.2.0/libstdc++-v3/testsuite/21_strings/char_traits/requirements/wchar_t/65049.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/21_strings/char_traits/requirements/wchar_t/65049.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/21_strings/char_traits/requirements/wchar_t/65049.cc	2015-10-02 15:08:17.234342000 -0500
@@ -0,0 +1,48 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+// libstdc++/65049
+
+#include <string>
+#include <testsuite_hooks.h>
+
+using C = wchar_t;
+
+void
+test01()
+{
+  const C* p = 0;
+  C* q = 0;
+  auto c = std::char_traits<C>::compare(p, q, 0);
+  VERIFY( c == 0 );
+  auto r = std::char_traits<C>::find(p, 0, '0');
+  VERIFY( r == nullptr );
+  r = std::char_traits<C>::move(q, p, 0);
+  VERIFY( r == q );
+  r = std::char_traits<C>::copy(q, p, 0);
+  VERIFY( r == q );
+  r = std::char_traits<C>::assign(q, 0, '0');
+  VERIFY( r == q );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc gcc-5.2.0/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8_utf16/66855.cc	2015-09-03 10:10:32.211657000 -0500
@@ -0,0 +1,52 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <codecvt>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::codecvt_utf8_utf16<char16_t> cvt;
+  char16_t utf16[] = u"\ub098\ub294\ud0dc\uc624";
+  const char16_t* nf16;
+  char utf8[16];
+  char* nt8;
+  std::mbstate_t st{};
+  auto res = cvt.out(st, utf16, utf16+4, nf16, utf8, utf8+16, nt8);
+  VERIFY( res == std::codecvt_base::ok );
+
+  st = {};
+  char16_t buf[4] = {};
+  const char* nf8 = nt8;
+  char16_t* nt16;
+  res = cvt.in(st, utf8, nf8, nf8, buf, buf+4, nt16);
+  VERIFY( res == std::codecvt_base::ok );
+  VERIFY( nt16 == buf+4 );
+  VERIFY( buf[0] == utf16[0] );
+  VERIFY( buf[1] == utf16[1] );
+  VERIFY( buf[2] == utf16[2] );
+  VERIFY( buf[3] == utf16[3] );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/allocator/move.cc gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/allocator/move.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/allocator/move.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/allocator/move.cc	2015-10-02 15:08:11.094111000 -0500
@@ -36,6 +36,11 @@
   VERIFY(1 == v1.get_allocator().get_personality());
   VERIFY(1 == v2.get_allocator().get_personality());
   VERIFY( it == v2.begin() );
+
+  // PR libstdc++/67707
+  VERIFY( v1.size() == 0 );
+  v1 = test_type();
+  VERIFY( v1.size() == 0 );
 }
 
 void test02()
@@ -47,6 +52,11 @@
   test_type v2(std::move(v1), alloc_type(2));
   VERIFY(1 == v1.get_allocator().get_personality());
   VERIFY(2 == v2.get_allocator().get_personality());
+
+  // PR libstdc++/67707
+  VERIFY( v1.size() == 0 );
+  v1 = test_type();
+  VERIFY( v1.size() == 0 );
 }
 
 int main()
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc	2015-10-02 15:08:11.094111000 -0500
@@ -18,7 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
-// { dg-error "no matching" "" { target *-*-* } 1881 }
+// { dg-error "no matching" "" { target *-*-* } 1882 }
 
 #include <deque>
 
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc	2015-10-02 15:08:11.094111000 -0500
@@ -18,7 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
-// { dg-error "no matching" "" { target *-*-* } 1814 }
+// { dg-error "no matching" "" { target *-*-* } 1815 }
 
 #include <deque>
 
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc	2015-10-02 15:08:11.094111000 -0500
@@ -18,7 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
-// { dg-error "no matching" "" { target *-*-* } 1814 }
+// { dg-error "no matching" "" { target *-*-* } 1815 }
 
 #include <deque>
 #include <utility>
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc	2015-10-02 15:08:11.094111000 -0500
@@ -18,7 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
-// { dg-error "no matching" "" { target *-*-* } 1965 }
+// { dg-error "no matching" "" { target *-*-* } 1966 }
 
 #include <deque>
 
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc gcc-5.2.0/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/26_numerics/valarray/range_access2.cc	2015-09-03 10:10:42.436559000 -0500
@@ -0,0 +1,36 @@
+// { dg-do compile }
+// { dg-options "-std=gnu++14" }
+
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 26.6.10 valarray range access: [valarray.range]
+
+#include <iterator>
+#include <valarray>
+
+// PR libstdc++/67374
+void
+test01()
+{
+  std::valarray<double> va{1.0, 2.0, 3.0};
+  std::cbegin(va);
+  std::cend(va);
+  const auto& cva = va;
+  std::cbegin(cva);
+  std::cend(cva);
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc gcc-5.2.0/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/26_numerics/valarray/range_access.cc	2015-09-03 10:10:42.436559000 -0500
@@ -28,4 +28,7 @@
   std::valarray<double> va{1.0, 2.0, 3.0};
   std::begin(va);
   std::end(va);
+  const auto& cva = va;
+  std::begin(cva);
+  std::end(cva);
 }
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc gcc-5.2.0/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc	2015-07-28 23:30:25.427925000 -0500
@@ -82,6 +82,22 @@
     VERIFY(e.code() == std::regex_constants::error_range);
   }
   std::regex re("[-----]", std::regex::ECMAScript);
+
+  VERIFY(!regex_match("b", regex("[-ac]", regex_constants::extended)));
+  VERIFY(!regex_match("b", regex("[ac-]", regex_constants::extended)));
+  VERIFY(regex_match("b", regex("[^-ac]", regex_constants::extended)));
+  VERIFY(regex_match("b", regex("[^ac-]", regex_constants::extended)));
+  VERIFY(regex_match("&", regex("[%--]", regex_constants::extended)));
+  VERIFY(regex_match(".", regex("[--@]", regex_constants::extended)));
+  try
+  {
+    regex("[a--@]", regex_constants::extended);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+  }
+  VERIFY(regex_match("].", regex("[][.hyphen.]-0]*", regex_constants::extended)));
 }
 
 void
@@ -115,6 +131,44 @@
   VERIFY(regex_match_debug("w", re));
 }
 
+// libstdc++/67015
+void
+test05()
+{
+  bool test __attribute__((unused)) = true;
+
+  regex lanana_namespace("^[a-z0-9]+$", regex::extended);
+  regex lsb_namespace("^_?([a-z0-9_.]+-, regex::extended)+[a-z0-9]+$");
+  regex debian_dpkg_conffile_cruft("dpkg-(old|dist|new|tmp, regex::extended)$");
+  regex debian_cron_namespace("^[a-z0-9][a-z0-9-]*$", regex::extended);
+  VERIFY(regex_match("test", debian_cron_namespace));
+  VERIFY(!regex_match("-a", debian_cron_namespace));
+  VERIFY(regex_match("a-", debian_cron_namespace));
+  regex debian_cron_namespace_ok("^[a-z0-9][-a-z0-9]*$", regex::extended);
+  VERIFY(regex_match("test", debian_cron_namespace_ok));
+  VERIFY(!regex_match("-a", debian_cron_namespace_ok));
+  VERIFY(regex_match("a-", debian_cron_namespace_ok));
+}
+
+// libstdc++/67015
+void
+test06()
+{
+  bool test __attribute__((unused)) = true;
+
+  regex lanana_namespace("^[a-z0-9]+$");
+  regex lsb_namespace("^_?([a-z0-9_.]+-)+[a-z0-9]+$");
+  regex debian_dpkg_conffile_cruft("dpkg-(old|dist|new|tmp)$");
+  regex debian_cron_namespace("^[a-z0-9][a-z0-9-]*$");
+  VERIFY(regex_match("test", debian_cron_namespace));
+  VERIFY(!regex_match("-a", debian_cron_namespace));
+  VERIFY(regex_match("a-", debian_cron_namespace));
+  regex debian_cron_namespace_ok("^[a-z0-9][-a-z0-9]*$");
+  VERIFY(regex_match("test", debian_cron_namespace_ok));
+  VERIFY(!regex_match("-a", debian_cron_namespace_ok));
+  VERIFY(regex_match("a-", debian_cron_namespace_ok));
+}
+
 int
 main()
 {
@@ -122,5 +176,8 @@
   test02();
   test03();
   test04();
+  test05();
+  test06();
+
   return 0;
 }
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/28_regex/regression.cc gcc-5.2.0/libstdc++-v3/testsuite/28_regex/regression.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/28_regex/regression.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/28_regex/regression.cc	2015-08-27 22:03:55.801997000 -0500
@@ -0,0 +1,42 @@
+// { dg-options "-std=gnu++11" }
+
+//
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <testsuite_hooks.h>
+#include <testsuite_regex.h>
+
+using namespace __gnu_test;
+using namespace std;
+
+// PR libstdc++/67362
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  regex re("((.)", regex_constants::basic);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
+
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/29_atomics/atomic/65913.cc gcc-5.2.0/libstdc++-v3/testsuite/29_atomics/atomic/65913.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/29_atomics/atomic/65913.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/29_atomics/atomic/65913.cc	2015-10-08 11:54:23.551701000 -0500
@@ -0,0 +1,39 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target x86_64-*-linux* powerpc*-*-linux* } }
+// { dg-options "-std=gnu++11 -O0" }
+
+#include <atomic>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/65913
+
+void
+test01()
+{
+  struct Int { int i; };
+  VERIFY( std::atomic<Int>{}.is_lock_free() );
+  VERIFY( std::atomic<int>{}.is_lock_free() );
+  VERIFY( std::atomic<int*>{}.is_lock_free() );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,77 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+  std::error_code ec;
+
+  // Test non-existent path.
+  const auto p = __gnu_test::nonexistent_path();
+  fs::directory_iterator iter(p, ec);
+  VERIFY( ec );
+  VERIFY( iter != fs::directory_iterator() );
+
+  // Test empty directory.
+  create_directory(p, fs::current_path(), ec);
+  VERIFY( !ec );
+  iter = fs::directory_iterator(p, ec);
+  VERIFY( !ec );
+  VERIFY( iter == fs::directory_iterator() );
+
+  // Test non-empty directory.
+  create_directory_symlink(p, p / "l", ec);
+  VERIFY( !ec );
+  iter = fs::directory_iterator(p, ec);
+  VERIFY( !ec );
+  VERIFY( iter != fs::directory_iterator() );
+  VERIFY( iter->path() == p/"l" );
+  ++iter;
+  VERIFY( iter == fs::directory_iterator() );
+
+  // Test inaccessible directory.
+  permissions(p, fs::perms::none, ec);
+  VERIFY( !ec );
+  iter = fs::directory_iterator(p, ec);
+  VERIFY( ec );
+  VERIFY( iter != fs::directory_iterator() );
+
+  // Test inaccessible directory, skipping permission denied.
+  const auto opts = fs::directory_options::skip_permission_denied;
+  iter = fs::directory_iterator(p, opts, ec);
+  VERIFY( !ec );
+  VERIFY( iter == fs::directory_iterator() );
+
+  permissions(p, fs::perms::owner_all, ec);
+  remove_all(p, ec);
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,104 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+  std::error_code ec;
+
+  // Test non-existent path.
+  const auto p = __gnu_test::nonexistent_path();
+  fs::recursive_directory_iterator iter(p, ec);
+  VERIFY( ec );
+  VERIFY( iter != fs::recursive_directory_iterator() );
+
+  // Test empty directory.
+  create_directory(p, fs::current_path(), ec);
+  VERIFY( !ec );
+  iter = fs::recursive_directory_iterator(p, ec);
+  VERIFY( !ec );
+  VERIFY( iter == fs::recursive_directory_iterator() );
+
+  // Test non-empty directory.
+  create_directories(p / "d1/d2");
+  VERIFY( !ec );
+  iter = fs::recursive_directory_iterator(p, ec);
+  VERIFY( !ec );
+  VERIFY( iter != fs::recursive_directory_iterator() );
+  VERIFY( iter->path() == p/"d1" );
+  ++iter;
+  VERIFY( iter->path() == p/"d1/d2" );
+  ++iter;
+  VERIFY( iter == fs::recursive_directory_iterator() );
+
+  // Test inaccessible directory.
+  permissions(p, fs::perms::none, ec);
+  VERIFY( !ec );
+  iter = fs::recursive_directory_iterator(p, ec);
+  VERIFY( ec );
+  VERIFY( iter != fs::recursive_directory_iterator() );
+
+  // Test inaccessible directory, skipping permission denied.
+  const auto opts = fs::directory_options::skip_permission_denied;
+  iter = fs::recursive_directory_iterator(p, opts, ec);
+  VERIFY( !ec );
+  VERIFY( iter == fs::recursive_directory_iterator() );
+
+  // Test inaccessible sub-directory.
+  permissions(p, fs::perms::owner_all, ec);
+  VERIFY( !ec );
+  permissions(p/"d1/d2", fs::perms::none, ec);
+  VERIFY( !ec );
+  iter = fs::recursive_directory_iterator(p, ec);
+  VERIFY( !ec );
+  VERIFY( iter != fs::recursive_directory_iterator() );
+  VERIFY( iter->path() == p/"d1" );
+  ++iter;              // should recurse into d1
+  VERIFY( iter->path() == p/"d1/d2" );
+  iter.increment(ec);  // should fail to recurse into p/d1/d2
+  VERIFY( ec );
+
+  // Test inaccessible sub-directory, skipping permission denied.
+  iter = fs::recursive_directory_iterator(p, opts, ec);
+  VERIFY( !ec );
+  VERIFY( iter != fs::recursive_directory_iterator() );
+  VERIFY( iter->path() == p/"d1" );
+  ++iter;              // should recurse into d1
+  VERIFY( iter->path() == p/"d1/d2" );
+  iter.increment(ec);  // should fail to recurse into p/d1/d2, so skip it
+  VERIFY( !ec );
+  VERIFY( iter == fs::recursive_directory_iterator() );
+
+  permissions(p/"d1/d2", fs::perms::owner_all, ec);
+  remove_all(p, ec);
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/absolute.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/absolute.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/absolute.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/absolute.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,59 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 15.1 Absolute [fs.op.absolute]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+
+  for (const path& p : __gnu_test::test_paths)
+    VERIFY( absolute(p).is_absolute() );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  path p1("/");
+  VERIFY( absolute(p1) == p1 );
+  VERIFY( absolute(p1, "/bar") == p1 );
+  path p2("/foo");
+  VERIFY( absolute(p2) == p2 );
+  VERIFY( absolute(p2, "/bar") == p2 );
+  path p3("foo");
+  VERIFY( absolute(p3) != p3 );
+  VERIFY( absolute(p3, "/bar") == "/bar/foo" );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,66 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+
+  std::error_code ec;
+  auto p = __gnu_test::nonexistent_path();
+  canonical( p, ec );
+  VERIFY( ec );
+
+  p = fs::current_path();
+  canonical( p, ec );
+  VERIFY( !ec );
+
+  p = "/";
+  p = canonical( p, ec );
+  VERIFY( p == "/" );
+  VERIFY( !ec );
+
+  p = "/.";
+  p = canonical( p, ec );
+  VERIFY( p == "/" );
+  VERIFY( !ec );
+
+  p = "/..";
+  p = canonical( p, ec );
+  VERIFY( p == "/" );
+  VERIFY( !ec );
+
+  p = "/../.././.";
+  p = canonical( p, ec );
+  VERIFY( p == "/" );
+  VERIFY( !ec );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,59 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 15.3 Copy [fs.op.copy]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+
+  for (const path& p : __gnu_test::test_paths)
+    VERIFY( absolute(p).is_absolute() );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  path p1("/");
+  VERIFY( absolute(p1) == p1 );
+  VERIFY( absolute(p1, "/bar") == p1 );
+  path p2("/foo");
+  VERIFY( absolute(p2) == p2 );
+  VERIFY( absolute(p2, "/bar") == p2 );
+  path p3("foo");
+  VERIFY( absolute(p3) != p3 );
+  VERIFY( absolute(p3, "/bar") == "/bar/foo" );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/create_directories.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,75 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+  std::error_code ec;
+
+  // Test empty path.
+  bool b = fs::create_directories( "", ec );
+  VERIFY( ec );
+  VERIFY( !b );
+
+  // Test existing path.
+  b = fs::create_directories( fs::current_path(), ec );
+  VERIFY( !ec );
+  VERIFY( !b );
+
+  // Test non-existent path.
+  const auto p = __gnu_test::nonexistent_path();
+  b = fs::create_directories( p, ec );
+  VERIFY( !ec );
+  VERIFY( b );
+  VERIFY( is_directory(p) );
+
+  b = fs::create_directories( p/".", ec );
+  VERIFY( !ec );
+  VERIFY( !b );
+
+  b = fs::create_directories( p/"..", ec );
+  VERIFY( !ec );
+  VERIFY( !b );
+
+  b = fs::create_directories( p/"d1/d2/d3", ec );
+  VERIFY( !ec );
+  VERIFY( b );
+  VERIFY( is_directory(p/"d1/d2/d3") );
+
+  b = fs::create_directories( p/"./d4/../d5", ec );
+  VERIFY( !ec );
+  VERIFY( b );
+  VERIFY( is_directory(p/"./d4/../d5") );
+
+  remove_all(p, ec);
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/current_path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/current_path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/current_path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/current_path.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,61 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 15.11 Current path [fs.op.current_path]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+
+  fs::path dot(".");
+  fs::path cwd = fs::current_path();
+  std::error_code ec;
+  fs::path cwd2 = fs::current_path(ec);
+  VERIFY( cwd == cwd2 );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  auto oldwd = fs::current_path();
+  auto tmpdir = fs::temp_directory_path();
+  current_path(tmpdir);
+  VERIFY( canonical(fs::current_path()) == canonical(tmpdir) );
+  std::error_code ec;
+  current_path(oldwd, ec);
+  VERIFY( canonical(fs::current_path()) == canonical(oldwd) );
+  VERIFY( canonical(fs::current_path(ec)) == canonical(oldwd) );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,63 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+
+  VERIFY( exists(path{"/"}) );
+  VERIFY( exists(path{"/."}) );
+  VERIFY( exists(path{"."}) );
+  VERIFY( exists(path{".."}) );
+  VERIFY( exists(std::experimental::filesystem::current_path()) );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  path rel = __gnu_test::nonexistent_path();
+  VERIFY( !exists(rel) );
+}
+
+void
+test03()
+{
+  bool test __attribute__((unused)) = false;
+
+  path abs = absolute(__gnu_test::nonexistent_path());
+  VERIFY( !exists(abs) );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/file_size.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,74 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+
+  std::error_code ec;
+  size_t size = fs::file_size(".", ec);
+  VERIFY( ec == std::errc::is_a_directory );
+  VERIFY( size == -1 );
+
+  try {
+    size = fs::file_size(".");
+    ec.clear();
+  } catch (const fs::filesystem_error& e) {
+    ec = e.code();
+  }
+  VERIFY( ec == std::errc::is_a_directory );
+  VERIFY( size == -1 );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  fs::path p = __gnu_test::nonexistent_path();
+
+  std::error_code ec;
+  size_t size = fs::file_size(p, ec);
+  VERIFY( ec );
+  VERIFY( size == -1 );
+
+  try {
+    size = fs::file_size(p);
+    ec.clear();
+  } catch (const fs::filesystem_error& e) {
+    ec = e.code();
+  }
+  VERIFY( ec );
+  VERIFY( size == -1 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/status.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/status.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/status.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/status.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,62 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+
+  std::error_code ec;
+  fs::file_status st1 = fs::status(".", ec);
+  VERIFY( !ec );
+  VERIFY( st1.type() == fs::file_type::directory );
+
+  fs::file_status st2 = fs::status(".");
+  VERIFY( st2.type() == fs::file_type::directory );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  fs::path p = __gnu_test::nonexistent_path();
+
+  std::error_code ec;
+  fs::file_status st1 = fs::status(p, ec);
+  VERIFY( ec );
+  VERIFY( st1.type() == fs::file_type::not_found );
+
+  fs::file_status st2 = fs::status(p);
+  VERIFY( st2.type() == fs::file_type::not_found );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,84 @@
+// Copyright (C) 2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <stdlib.h>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+void
+clean_env()
+{
+  ::unsetenv("TMPDIR");
+  ::unsetenv("TMP");
+  ::unsetenv("TEMPDIR");
+  ::unsetenv("TEMP");
+}
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = false;
+
+  clean_env();
+
+  if (!fs::exists("/tmp"))
+    return; // just give up
+
+  std::error_code ec;
+  fs::path p1 = fs::temp_directory_path(ec);
+  VERIFY( exists(p1) );
+
+  fs::path p2 = fs::temp_directory_path();
+  VERIFY( p1 == p2 );
+}
+
+void
+test02()
+{
+  bool test __attribute__((unused)) = false;
+
+  clean_env();
+
+  if (::setenv("TMPDIR", __gnu_test::nonexistent_path().string().c_str(), 1))
+    return; // just give up
+
+  std::error_code ec;
+  fs::path p = fs::temp_directory_path(ec);
+  VERIFY( ec );
+
+  std::error_code ec2;
+  try {
+    p = fs::temp_directory_path();
+  } catch (const fs::filesystem_error& e) {
+    ec2 = e.code();
+  }
+  VERIFY( ec2 == ec );
+}
+
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/append/path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/append/path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/append/path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/append/path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,63 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.3 path appends [path.append]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  const path p("/foo/bar");
+
+  path pp = p;
+  pp /= p;
+  VERIFY( pp.native() == "/foo/bar/foo/bar" );
+
+  path q("baz");
+
+  path qq = q;
+  qq /= q;
+  VERIFY( qq.native() == "baz/baz" );
+
+  q /= p;
+  VERIFY( q.native() == "baz/foo/bar" );
+
+  path r = "";
+  r /= path();
+  VERIFY( r.empty() );
+
+  r /= path("rel");
+  VERIFY( !r.is_absolute() );
+
+  path s = "dir/";
+  s /= path("/file");
+  VERIFY( s.native() == "dir//file" );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/assign/assign.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/assign/assign.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/assign/assign.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/assign/assign.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,93 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+using __gnu_test::compare_paths;
+
+void
+test01()
+{
+  for (std::string s : __gnu_test::test_paths)
+  {
+    path p0 = s, p1, p2, p3, p4;
+
+    p1 = s;
+    compare_paths(p0, p1);
+
+    p2 = s.c_str();
+    compare_paths(p0, p2);
+
+#if _GLIBCXX_USE_WCHAR_T
+    std::wstring ws(s.begin(), s.end());
+
+    p3 = ws;
+    compare_paths(p0, p3);
+
+    p4 = ws.c_str();
+    compare_paths(p0, p4);
+#endif
+  }
+}
+
+void
+test02()
+{
+  for (std::string s : __gnu_test::test_paths)
+  {
+    path p0 = s, p1, p2, p3, p4, p5, p6, p7, p8;
+
+    p1.assign(s);
+    compare_paths(p0, p1);
+
+    p2.assign( s.begin(), s.end() );
+    compare_paths(p0, p2);
+
+    p3.assign( s.c_str() );
+    compare_paths(p0, p3);
+
+    p4.assign( s.c_str(), s.c_str() + s.size() );
+    compare_paths(p0, p4);
+
+#if _GLIBCXX_USE_WCHAR_T
+    std::wstring ws(s.begin(), s.end());
+
+    p5.assign(ws);
+    compare_paths(p0, p5);
+
+    p6.assign( ws.begin(), ws.end() );
+    compare_paths(p0, p6);
+
+    p7.assign( ws.c_str() );
+    compare_paths(p0, p7);
+
+    p8.assign( ws.c_str(), ws.c_str() + ws.size() );
+    compare_paths(p0, p8);
+#endif
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/assign/copy.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/assign/copy.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/assign/copy.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/assign/copy.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,55 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+using __gnu_test::compare_paths;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path copy;
+    copy = p;
+    __gnu_test::compare_paths(p, copy);
+  }
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path copy = p;
+    path move;
+    move = std::move(copy);
+    __gnu_test::compare_paths(p, move);
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/compare/compare.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/compare/compare.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/compare/compare.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/compare/compare.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,50 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.8 path compare [path.compare]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p("/foo/bar");
+  VERIFY( p.compare(p) == 0 );
+  VERIFY( p.compare("/foo//bar") == 0 );
+
+  path q("/foo/baz");
+  VERIFY( p.compare(q) < 0 );
+  VERIFY( q.compare(p) > 0 );
+
+  path r("/foo/bar/.");
+  VERIFY( p.compare(r) < 0 );
+
+  VERIFY( path("a/b/").compare("a/b/.") == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/compare/path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/compare/path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/compare/path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/compare/path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,50 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.8 path compare [path.compare]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  const path p0 = "/a/a/b/b";
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.compare(p) == 0 );
+    int cmp = p.compare(p0);
+    if (cmp == 0)
+      VERIFY( p0.compare(p) == 0 );
+    else if (cmp < 0)
+      VERIFY( p0.compare(p) > 0 );
+    else if (cmp > 0)
+      VERIFY( p0.compare(p) < 0 );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/compare/strings.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/compare/strings.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/compare/strings.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/compare/strings.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,48 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.8 path compare [path.compare]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  const std::string s0 = "/a/a/b/b";
+  const path p0 = s0;
+  for (const std::string& s : __gnu_test::test_paths)
+  {
+    path p(s);
+    VERIFY( p.compare(s) == 0 );
+    VERIFY( p.compare(s.c_str()) == 0 );
+    VERIFY( p.compare(p0) == p.compare(s0) );
+    VERIFY( p.compare(p0) == p.compare(s0.c_str()) );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/concat/path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/concat/path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/concat/path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/concat/path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,68 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.4 path concatenation [path.concat]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  const path p("/foo/bar");
+
+  path pp = p;
+  pp += p;
+  VERIFY( pp.native() == "/foo/bar/foo/bar" );
+  VERIFY( std::distance(pp.begin(), pp.end()) == 5 );
+
+  path q("foo/bar");
+
+  path qq = q;
+  qq += q;
+  VERIFY( qq.native() == "foo/barfoo/bar" );
+  VERIFY( std::distance(qq.begin(), qq.end()) == 3 );
+
+  q += p;
+  VERIFY( q.native() == "foo/bar/foo/bar" );
+  VERIFY( std::distance(q.begin(), q.end()) == 4 );
+}
+
+void
+test02()
+{
+  for (path p : __gnu_test::test_paths)
+  {
+    auto prior_native = p.native();
+    path x("//blah/di/blah");
+    p += x;
+    VERIFY( p.native() == prior_native + x.native() );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/concat/strings.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/concat/strings.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/concat/strings.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/concat/strings.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,55 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.4 path concatenation [path.concat]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p("/");
+  p += path::string_type("foo");
+  VERIFY( p.filename() == "foo" );
+  p += "bar";
+  VERIFY( p.filename() == "foobar" );
+  p += '/';
+  VERIFY( p.parent_path() == "/foobar" && p.filename() == "." );
+#if _GLIBCXX_USE_WCHAR_T
+  p += L"baz.txt";
+#else
+  p += "baz.txt";
+#endif
+  VERIFY( p.filename() == "baz.txt" );
+  p.concat("/dir/");
+  VERIFY( p.parent_path() == "/foobar/baz.txt/dir" && p.filename() == "." );
+  std::string file = "file";
+  p.concat(file.begin(), file.end());
+  VERIFY( p.filename() == "file" );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/construct/copy.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/construct/copy.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/construct/copy.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/construct/copy.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,54 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.1 path constructors [path.construct]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path copy = p;
+    __gnu_test::compare_paths(p, copy);
+  }
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path copy = p;
+    path move = std::move(copy);
+    __gnu_test::compare_paths(p, move);
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/construct/default.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/construct/default.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/construct/default.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/construct/default.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,50 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.1 path constructors [path.construct]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p;
+  VERIFY(  p.empty() );
+  VERIFY( !p.has_root_path() );
+  VERIFY( !p.has_root_name() );
+  VERIFY( !p.has_root_directory() );
+  VERIFY( !p.has_relative_path() );
+  VERIFY( !p.has_parent_path() );
+  VERIFY( !p.has_filename() );
+  VERIFY( !p.has_stem() );
+  VERIFY( !p.has_extension() );
+  VERIFY( !p.is_absolute() );
+  VERIFY(  p.is_relative() );
+  VERIFY( std::distance(p.begin(), p.end()) == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/construct/locale.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/construct/locale.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/construct/locale.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/construct/locale.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,39 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.1 path constructors [path.construct]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p("/foo/bar", std::locale::classic());
+  VERIFY( p.string() == "/foo/bar" );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/construct/range.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/construct/range.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/construct/range.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/construct/range.cc	2015-10-07 16:00:50.975754000 -0500
@@ -0,0 +1,63 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.1 path constructors [path.construct]
+
+#include <experimental/filesystem>
+#include <string>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+using __gnu_test::compare_paths;
+
+void
+test01()
+{
+  for (std::string s : __gnu_test::test_paths)
+  {
+    path p1 = s;
+    path p2( s.begin(), s.end() );
+    path p3( s.c_str() );
+    path p4( s.c_str(), s.c_str() + s.size() );
+
+    compare_paths(p1, p2);
+    compare_paths(p1, p3);
+    compare_paths(p1, p4);
+
+#if _GLIBCXX_USE_WCHAR_T
+    std::wstring ws(s.begin(), s.end());
+    path p5 = ws;
+    path p6( ws.begin(), ws.end() );
+    path p7( ws.c_str() );
+    path p8( ws.c_str(), ws.c_str() + ws.size() );
+
+    compare_paths(p1, p5);
+    compare_paths(p1, p6);
+    compare_paths(p1, p7);
+    compare_paths(p1, p8);
+#endif
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/extension.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/extension.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/extension.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/extension.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,61 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path("/foo/bar.txt").extension() == path(".txt") );
+  VERIFY( path("/foo/bar.baz.txt").extension() == path(".txt") );
+  VERIFY( path(".bar.baz.txt").extension() == path(".txt") );
+
+  VERIFY( path(".hidden").extension() == path(".hidden") );
+
+  VERIFY( path().extension() == path() );
+  VERIFY( path(".").extension() == path() );
+  VERIFY( path("..").extension() == path() );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    auto stem = p.stem();
+    auto ext = p.extension();
+    auto file = p.filename();
+    VERIFY( stem.native() + ext.native() == file.native() );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/filename.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/filename.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/filename.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/filename.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,58 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path("/foo/bar.txt").filename() == "bar.txt"  );
+  VERIFY( path("/").filename()            == "/"        );
+  VERIFY( path(".").filename()            == "."        );
+  VERIFY( path("..").filename()           == ".."       );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path f = p.filename();
+    if (p.empty())
+      VERIFY( f.empty() );
+    else
+      VERIFY( f == *--p.end() );
+    if (p != p.root_path())
+      VERIFY( !f.has_root_path() );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/parent_path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/parent_path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/parent_path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/parent_path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,63 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p0;
+  VERIFY( p0.parent_path() == p0 );
+  path p1 = "foo";
+  VERIFY( p1.parent_path() == p0 );
+  path p2 = "foo/bar";
+  VERIFY( p2.parent_path() == p1 );
+  path p3 = "/foo/bar";
+  VERIFY( p3.parent_path() == path("/foo") );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    if (p.begin() == p.end())
+      continue;
+    path pp;
+    for (auto i = p.begin(), end = --p.end(); i != end; ++i)
+    {
+      pp /= *i;
+    }
+    VERIFY( p.parent_path() == pp );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/relative_path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/relative_path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/relative_path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/relative_path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,65 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p1 = "foo";
+  VERIFY( p1.relative_path() == p1 );
+  path p2 = "foo/bar";
+  VERIFY( p2.relative_path() == p2 );
+  path p3 = "/foo/bar";
+  VERIFY( p3.relative_path() == p2 );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    bool after_root = false;
+    const path prel = p.relative_path();
+    VERIFY( !prel.has_root_name() );
+    path rel;
+    for (const auto& cmpt : p)
+    {
+      if (!cmpt.has_root_path())
+        after_root = true;
+      if (after_root)
+        rel /= cmpt;
+    }
+    VERIFY( prel == rel );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_directory.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_directory.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_directory.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_directory.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,60 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p1 = "foo/bar";
+  VERIFY( p1.root_directory() == path() );
+  path p2 = "/foo/bar";
+  VERIFY( p2.root_directory() == path("/") );
+  path p3 = "//foo";
+  VERIFY( p3.root_directory() == path() );
+  path p4 = "///foo";
+  VERIFY( p4.root_directory() == path("/") );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path rootdir = p.root_directory();
+    // If root-directory is composed of 'slash name',
+    // 'slash' is excluded from the returned string.
+    if (!rootdir.empty() && rootdir.native() != "/")
+      VERIFY( rootdir.native()[0] != '/' );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_name.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_name.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_name.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_name.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,42 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path("/foo/bar.txt").extension() == ".txt" );
+  VERIFY( path("/foo/bar.baz.txt").extension() == ".txt" );
+  VERIFY( path(".").extension().empty() );
+  VERIFY( path("..").extension().empty() );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,55 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p1 = "foo/bar";
+  VERIFY( p1.root_path() == path() );
+  path p2 = "/foo/bar";
+  VERIFY( p2.root_path() == path("/") );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path rootp = p.root_path();
+    path rootn = p.root_name();
+    path rootd = p.root_directory();
+    VERIFY( rootp == (rootn / rootd) );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/stem.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/stem.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/stem.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/decompose/stem.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path("/foo/bar.txt").stem() == path("bar") );
+  path p = "foo.bar.baz.tar";
+  std::vector<std::string> v;
+  for (; !p.extension().empty(); p = p.stem())
+    v.push_back(p.extension().native());
+  VERIFY( v.at(0) == ".tar" );
+  VERIFY( v.at(1) == ".baz" );
+  VERIFY( v.at(2) == ".bar" );
+
+  VERIFY( path(".hidden").stem() == path() );
+
+  VERIFY( path().stem() == path() );
+  VERIFY( path(".").stem() == path(".") );
+  VERIFY( path("..").stem() == path("..") );
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,48 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.7 path generic format observers [path.generic.obs]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path p2(p), p3;
+    p2.swap(p3);
+    VERIFY( p2 == path() );
+    VERIFY( p3 == p );
+    p2.swap(p3);
+    VERIFY( p2 == p );
+    VERIFY( p3 == path() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/itr/traversal.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/itr/traversal.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/itr/traversal.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/itr/traversal.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,86 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.5 path iterators [path.itr]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <algorithm>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  path p;
+  VERIFY( p.begin() == p.end() );
+
+  std::vector<path> v, v2;
+
+  p = "/";
+  v.assign(p.begin(), p.end());
+  v2 = { "/" };
+  VERIFY( v == v2 );
+
+  p = "filename";
+  v.assign(p.begin(), p.end());
+  v2 = { "filename" };
+  VERIFY( v == v2 );
+
+  p = "dir/";
+  v.assign(p.begin(), p.end());
+  v2 = { "dir", "." };
+  VERIFY( v == v2 );
+
+  p = "//rootname/dir/";
+  v.assign(p.begin(), p.end());
+  v2 = { "//rootname", "/", "dir", "." };
+  VERIFY( v == v2 );
+
+  p = "//rootname/dir/filename";
+  v.assign(p.begin(), p.end());
+  v2 = { "//rootname", "/", "dir", "filename" };
+  VERIFY( v == v2 );
+}
+
+void
+test02()
+{
+  using reverse_iterator = std::reverse_iterator<path::iterator>;
+  std::vector<path> fwd, rev;
+
+  for (const path& p : __gnu_test::test_paths)
+  {
+    const auto begin = p.begin(), end = p.end();
+    fwd.assign(begin, end);
+    rev.assign(reverse_iterator(end), reverse_iterator(begin));
+    VERIFY( fwd.size() == rev.size() );
+    VERIFY( std::equal(fwd.begin(), fwd.end(), rev.rbegin()) );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/clear.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/clear.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/clear.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/clear.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,45 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.5 path modifiers [path.modifiers]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (path p : __gnu_test::test_paths)
+  {
+    path empty;
+    p.clear();
+    VERIFY( p.empty() );
+    __gnu_test::compare_paths(p, empty);
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/make_preferred.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/make_preferred.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/make_preferred.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/make_preferred.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,63 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.5 path modifiers [path.modifiers]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+template<typename T, T sep>
+struct checker
+{
+  static void check(const char* s) { }
+};
+
+template<>
+struct checker<char, '/'>
+{
+  static void check()
+  {
+    VERIFY( path("foo/bar").make_preferred() == "foo/bar" );
+  }
+};
+
+template<>
+struct checker<wchar_t, L'\\'>
+{
+  static void check()
+  {
+    VERIFY( path("foo/bar").make_preferred() == L"foo\\bar" );
+  }
+};
+
+void
+test01()
+{
+  checker<path::value_type, path::preferred_separator>::check();
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/remove_filename.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/remove_filename.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/remove_filename.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/remove_filename.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.5 path modifiers [path.modifiers]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path("/foo").remove_filename() == "/" );
+  VERIFY( path("/").remove_filename() == "" );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path p2(p);
+    p2.remove_filename();
+    p2 /= p.filename();
+    VERIFY( p2 == p );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_extension.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_extension.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_extension.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_extension.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,52 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.5 path modifiers [path.modifiers]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path("/foo.txt").replace_extension("cpp") == "/foo.cpp" );
+  VERIFY( path("/foo.txt").replace_extension(".cpp") == "/foo.cpp" );
+  VERIFY( path("/").replace_extension("bar") == "/.bar" );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path p2 = p;
+    VERIFY(p2.replace_extension(p2.extension()) == p);
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_filename.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_filename.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_filename.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_filename.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,52 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.5 path modifiers [path.modifiers]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path("/foo").replace_filename("bar") == "/bar" );
+  VERIFY( path("/").replace_filename("bar") == "bar" );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path p2(p);
+    p2.replace_filename(p.filename());
+    VERIFY( p2 == p );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/swap.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/swap.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/swap.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/swap.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,44 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.5 path modifiers [path.modifiers]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  const path p("/foo/bar");
+  path p1;
+  path p2 = p;
+  p1.swap(p2);
+  VERIFY( p2.empty() );
+  __gnu_test::compare_paths(p1, p);
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/nonmember/hash_value.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/nonmember/hash_value.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/nonmember/hash_value.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/nonmember/hash_value.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,51 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.6 path non-member functions [path.non-member]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( hash_value(path("a//b")) == hash_value(path("a/b")) );
+  VERIFY( hash_value(path("a/")) == hash_value(path("a/.")) );
+}
+
+void
+test02()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    path pp = p.native();
+    VERIFY( hash_value(p) == hash_value(pp) );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/empty.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/empty.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/empty.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/empty.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const std::string& s : __gnu_test::test_paths)
+  {
+    VERIFY( s.empty() == path(s).empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_extension.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_extension.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_extension.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_extension.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.has_extension() == !p.extension().empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_filename.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_filename.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_filename.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_filename.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.has_filename() == !p.filename().empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_parent_path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_parent_path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_parent_path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_parent_path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.has_parent_path() == !p.parent_path().empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_relative_path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_relative_path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_relative_path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_relative_path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.has_relative_path() == !p.relative_path().empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_directory.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_directory.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_directory.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_directory.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.has_root_directory() == !p.root_directory().empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_name.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_name.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_name.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_name.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.has_root_name() == !p.root_name().empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_path.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_path.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_path.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_path.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.has_root_path() == !p.root_path().empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_stem.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_stem.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_stem.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/has_stem.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.has_stem() == !p.stem().empty() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/is_relative.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/is_relative.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/filesystem/path/query/is_relative.cc	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/filesystem/path/query/is_relative.cc	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++11 -lstdc++fs" }
+// { dg-require-filesystem-ts "" }
+
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 8.4.9 path decomposition [path.decompose]
+
+#include <experimental/filesystem>
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_fs.h>
+
+using std::experimental::filesystem::path;
+
+void
+test01()
+{
+  for (const path& p : __gnu_test::test_paths)
+  {
+    VERIFY( p.is_relative() == !p.is_absolute() );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/functional/not_fn.cc gcc-5.2.0/libstdc++-v3/testsuite/experimental/functional/not_fn.cc
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/experimental/functional/not_fn.cc	2015-01-05 06:33:28.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/experimental/functional/not_fn.cc	2015-09-03 10:10:52.511551000 -0500
@@ -20,6 +20,8 @@
 #include <experimental/functional>
 #include <testsuite_hooks.h>
 
+using std::experimental::not_fn;
+
 int func(int, char) { return 0; }
 
 struct F
@@ -33,8 +35,6 @@
 void
 test01()
 {
-  using std::experimental::not_fn;
-
   auto f1 = not_fn(func);
   VERIFY( f1(1, '2') == true );
 
@@ -50,8 +50,36 @@
   VERIFY( f5(1) == false );
 }
 
+template<typename F, typename Arg>
+auto foo(F f, Arg arg) -> decltype(not_fn(f)(arg)) { return not_fn(f)(arg); }
+
+template<typename F, typename Arg>
+auto foo(F f, Arg arg) -> decltype(not_fn(f)()) { return not_fn(f)(); }
+
+struct negator
+{
+    bool operator()(int) const { return false; }
+    void operator()() const {}
+};
+
+void 
+test02()
+{
+  foo(negator{}, 1); // PR libstdc++/66998
+}
+
+void
+test03()
+{
+  struct X { bool b; };
+  X x{ false };
+  VERIFY( not_fn(&X::b)(x) );
+}
+
 int
 main()
 {
   test01();
+  test02();
+  test03();
 }
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/lib/dg-options.exp gcc-5.2.0/libstdc++-v3/testsuite/lib/dg-options.exp
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/lib/dg-options.exp	2015-05-07 06:58:16.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/testsuite/lib/dg-options.exp	2015-08-18 12:58:22.597022000 -0500
@@ -223,6 +223,15 @@
     return
 }
 
+proc dg-require-filesystem-ts { args } {
+    if { ![ check_v3_target_filesystem_ts ] } {
+	upvar dg-do-what dg-do-what
+	set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
+	return
+    }
+    return
+}
+
 proc add_options_for_no_pch { flags } {
     # This forces any generated and possibly included PCH to be invalid.
     return "-D__GLIBCXX__=99999999"
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/lib/libstdc++.exp gcc-5.2.0/libstdc++-v3/testsuite/lib/libstdc++.exp
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/lib/libstdc++.exp	2015-06-08 09:19:15.000000000 -0500
+++ gcc-5.2.0/libstdc++-v3/testsuite/lib/libstdc++.exp	2015-08-18 12:58:22.597022000 -0500
@@ -1894,6 +1894,59 @@
     return $et_little_endian
 }
 
+proc check_v3_target_filesystem_ts { } {
+    global cxxflags
+    global DEFAULT_CXXFLAGS
+    global et_filesystem_ts
+    global tool
+
+    if { ![info exists et_filesystem_ts_target_name] } {
+	set et_filesystem_ts_target_name ""
+    }
+
+    # If the target has changed since we set the cached value, clear it.
+    set current_target [current_target_name]
+    if { $current_target != $et_filesystem_ts_target_name } {
+	verbose "check_v3_target_filesystem_ts: `$et_filesystem_ts_target_name'" 2
+	set et_filesystem_ts_target_name $current_target
+	if [info exists et_filesystem_ts] {
+	    verbose "check_v3_target_filesystem_ts: removing cached result" 2
+	    unset et_filesystem_ts
+	}
+    }
+
+    if [info exists et_filesystem_ts] {
+	verbose "check_v3_target_filesystem_ts: using cached result" 2
+    } else {
+	set et_filesystem_ts 0
+
+	# Set up and preprocess a C++ test program that depends
+	# on debug mode activated.
+	set src filesystem_ts[pid].cc
+
+	set f [open $src "w"]
+	puts $f "#include <experimental/filesystem>"
+	puts $f "#if ! __cpp_lib_experimental_filesystem"
+	puts $f "#  error No Filesystem TS support"
+	puts $f "#endif"
+	close $f
+
+	set cxxflags_saved $cxxflags
+	set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror -std=gnu++11"
+
+	set lines [v3_target_compile $src /dev/null preprocess ""]
+	set cxxflags $cxxflags_saved
+	file delete $src
+
+	if [string match "" $lines] {
+	    # No error message, preprocessing succeeded.
+	    set et_filesystem_ts 1
+	}
+    }
+    verbose "check_v3_target_filesystem_ts: $et_filesystem_ts" 2
+    return $et_filesystem_ts
+}
+
 set additional_prunes ""
 
 if { [info exists env(GCC_RUNTEST_PARALLELIZE_DIR)] \
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/Makefile.in gcc-5.2.0/libstdc++-v3/testsuite/Makefile.in
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/Makefile.in	2014-12-19 12:16:39.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/Makefile.in	2015-08-18 12:58:06.792617000 -0500
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,6 +15,23 @@
 
 @SET_MAKE@
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -67,6 +84,11 @@
 depcomp =
 am__depfiles_maybe =
 SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
 ACLOCAL = @ACLOCAL@
 ALLOCATOR_H = @ALLOCATOR_H@
@@ -370,6 +392,7 @@
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/fragment.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -405,10 +428,15 @@
 
 installcheck: installcheck-am
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 
 clean-generic:
diff -Naur gcc-5.2.0.orig/libstdc++-v3/testsuite/util/testsuite_fs.h gcc-5.2.0/libstdc++-v3/testsuite/util/testsuite_fs.h
--- gcc-5.2.0.orig/libstdc++-v3/testsuite/util/testsuite_fs.h	1969-12-31 18:00:00.000000000 -0600
+++ gcc-5.2.0/libstdc++-v3/testsuite/util/testsuite_fs.h	2015-08-18 12:58:22.597022000 -0500
@@ -0,0 +1,93 @@
+// -*- C++ -*-
+// Filesystem utils for the C++ library testsuite.
+//
+// Copyright (C) 2014-2015 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+//
+
+#ifndef _TESTSUITE_FS_H
+#define _TESTSUITE_FS_H 1
+
+#include <experimental/filesystem>
+#include <iostream>
+#include <string>
+#include <cstdio>
+#include <stdlib.h>
+#include <unistd.h>
+
+namespace __gnu_test
+{
+#define PATH_CHK(p1, p2, fn) \
+    if ( p1.fn() != p2.fn() ) \
+      throw std::experimental::filesystem::filesystem_error( #fn, p1, p2, \
+	  std::make_error_code(std::errc::invalid_argument) )
+
+  void
+  compare_paths(const std::experimental::filesystem::path& p1,
+		const std::experimental::filesystem::path& p2)
+  {
+    // std::cout << "Comparing " << p1 << " and " << p2 << std::endl;
+    PATH_CHK( p1, p2, string );
+    PATH_CHK( p1, p2, empty );
+    PATH_CHK( p1, p2, has_root_path );
+    PATH_CHK( p1, p2, has_root_name );
+    PATH_CHK( p1, p2, has_root_directory );
+    PATH_CHK( p1, p2, has_relative_path );
+    PATH_CHK( p1, p2, has_parent_path );
+    PATH_CHK( p1, p2, has_filename );
+    PATH_CHK( p1, p2, has_stem );
+    PATH_CHK( p1, p2, has_extension );
+    PATH_CHK( p1, p2, is_absolute );
+    PATH_CHK( p1, p2, is_relative );
+    auto d1 = std::distance(p1.begin(), p1.end());
+    auto d2 = std::distance(p2.begin(), p2.end());
+    if( d1 != d2 )
+      throw std::experimental::filesystem::filesystem_error(
+	  "distance(begin, end)", p1, p2,
+	  std::make_error_code(std::errc::invalid_argument) );
+  }
+
+  const std::string test_paths[] = {
+    "", "/", "//", "/.", "/./", "/a", "/a/", "/a//", "/a/b/c/d", "/a//b",
+    "a", "a/b", "a/b/", "a/b/c", "a/b/c.d", "a/b/..", "a/b/c.", "a/b/.c"
+  };
+
+  // This is NOT supposed to be a secure way to get a unique name!
+  // We just need a path that doesn't exist for testing purposes.
+  std::experimental::filesystem::path
+  nonexistent_path()
+  {
+    std::experimental::filesystem::path p;
+#if defined(_GNU_SOURCE) || _XOPEN_SOURCE >= 500 || _POSIX_C_SOURCE >= 200112L
+    char tmp[] = "test.XXXXXX";
+    int fd = ::mkstemp(tmp);
+    if (fd == -1)
+      throw std::experimental::filesystem::filesystem_error("mkstemp failed",
+	  std::error_code(errno, std::generic_category()));
+    ::unlink(tmp);
+    ::close(fd);
+    p = tmp;
+#else
+    char buf[64];
+    std::sprintf(buf, "test.%lu", (unsigned long)::getpid());
+    p = buf;
+#endif
+    return p;
+  }
+
+} // namespace __gnu_test
+#endif
