Submitted By: Jim Gifford (jim at cross-lfs dot org)
Date: 01-01-2010
Initial Package Version: 4.4.2
Origin: Upstream
Upstream Status: Applied
Description: This is a branch update for gcc-4.4.2, and should be
             rechecked periodically.

This patch was made from Revision # 155542.

diff -Naur gcc-4.4.2.orig/config.guess gcc-4.4.2/config.guess
--- gcc-4.4.2.orig/config.guess	2008-12-17 22:27:27.000000000 -0500
+++ gcc-4.4.2/config.guess	2009-11-22 18:09:41.974616000 -0500
@@ -1,10 +1,10 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
 #   Free Software Foundation, Inc.
 
-timestamp='2008-12-18'
+timestamp='2009-11-19'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -27,16 +27,16 @@
 # the same distribution terms that you use for the rest of that program.
 
 
-# Originally written by Per Bothner <per@bothner.com>.
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# Originally written by Per Bothner.  Please send patches (context
+# diff format) to <config-patches@gnu.org> and include a ChangeLog
+# entry.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -170,7 +170,7 @@
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep __ELF__ >/dev/null
+			| grep -q __ELF__
 		then
 		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
 		    # Return netbsd for either.  FIX?
@@ -324,6 +324,9 @@
 	case `/usr/bin/uname -p` in
 	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
+    s390x:SunOS:*:*)
+	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
@@ -653,7 +656,7 @@
 	    # => hppa64-hp-hpux11.23
 
 	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
-		grep __LP64__ >/dev/null
+		grep -q __LP64__
 	    then
 		HP_ARCH="hppa2.0w"
 	    else
@@ -804,12 +807,12 @@
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
 	exit ;;
-    *:Interix*:[3456]*)
+    *:Interix*:*)
     	case ${UNAME_MACHINE} in
 	    x86)
 		echo i586-pc-interix${UNAME_RELEASE}
 		exit ;;
-	    EM64T | authenticamd | genuineintel)
+	    authenticamd | genuineintel | EM64T)
 		echo x86_64-unknown-interix${UNAME_RELEASE}
 		exit ;;
 	    IA64)
@@ -819,6 +822,9 @@
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
 	exit ;;
+    8664:Windows_NT:*)
+	echo x86_64-pc-mks
+	exit ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
@@ -848,6 +854,20 @@
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit ;;
     arm*:Linux:*:*)
 	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -870,6 +890,17 @@
     frv:Linux:*:*)
     	echo frv-unknown-linux-gnu
 	exit ;;
+    i*86:Linux:*:*)
+	LIBC=gnu
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	exit ;;
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit ;;
@@ -879,78 +910,34 @@
     m68*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit ;;
-    mips:Linux:*:*)
+    mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
-	#undef mips
-	#undef mipsel
+	#undef ${UNAME_MACHINE}
+	#undef ${UNAME_MACHINE}el
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mipsel
+	CPU=${UNAME_MACHINE}el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips
+	CPU=${UNAME_MACHINE}
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
-	;;
-    mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips64
-	#undef mips64el
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mips64el
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips64
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
     or32:Linux:*:*)
 	echo or32-unknown-linux-gnu
 	exit ;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit ;;
     padre:Linux:*:*)
 	echo sparc-unknown-linux-gnu
 	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
@@ -959,8 +946,11 @@
 	  *)    echo hppa-unknown-linux-gnu ;;
 	esac
 	exit ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux
@@ -983,66 +973,6 @@
     xtensa*:Linux:*:*)
     	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit ;;
-    i*86:Linux:*:*)
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
-			 | sed -ne '/supported targets:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
-				    s/ .*//
-				    p'`
-        case "$ld_supported_targets" in
-	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
-		;;
-	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit ;;
-	  "")
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ >= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^LIBC/{
-		s: ::g
-		p
-	    }'`"
-	test x"${LIBC}" != x && {
-		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
-		exit
-	}
-	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
-	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
@@ -1071,7 +1001,7 @@
     i*86:syllable:*:*)
 	echo ${UNAME_MACHINE}-pc-syllable
 	exit ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
 	echo i386-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     i*86:*DOS:*:*)
@@ -1115,8 +1045,11 @@
     pc:*:*:*)
 	# Left here for compatibility:
         # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
+        # the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configury will decide that
+	# this is a cross-build.
+	echo i586-pc-msdosdjgpp
         exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
@@ -1154,6 +1087,16 @@
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
         /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
           && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
@@ -1166,7 +1109,7 @@
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
 	echo powerpc-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     SM[BE]S:UNIX_SV:*:*)
@@ -1259,6 +1202,16 @@
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
 	case $UNAME_PROCESSOR in
+	    i386)
+		eval $set_cc_for_build
+		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		      grep IS_64BIT_ARCH >/dev/null
+		  then
+		      UNAME_PROCESSOR="x86_64"
+		  fi
+		fi ;;
 	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
@@ -1340,6 +1293,9 @@
     i*86:rdos:*:*)
 	echo ${UNAME_MACHINE}-pc-rdos
 	exit ;;
+    i*86:AROS:*:*)
+	echo ${UNAME_MACHINE}-pc-aros
+	exit ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
diff -Naur gcc-4.4.2.orig/config.sub gcc-4.4.2/config.sub
--- gcc-4.4.2.orig/config.sub	2008-12-17 22:27:27.000000000 -0500
+++ gcc-4.4.2/config.sub	2009-11-22 18:09:41.974616000 -0500
@@ -1,10 +1,10 @@
 #! /bin/sh
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
 #   Free Software Foundation, Inc.
 
-timestamp='2008-12-11'
+timestamp='2009-11-07'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
@@ -32,13 +32,16 @@
 
 
 # Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# diff and a properly formatted GNU ChangeLog entry.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
 # that are meaningful with *any* GNU software.
@@ -122,6 +125,7 @@
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
   uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
@@ -148,10 +152,13 @@
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
+	-apple | -axis | -knuth | -cray | -microblaze)
 		os=
 		basic_machine=$1
 		;;
+        -bluegene*)
+	        os=-cnk
+		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
 		basic_machine=$1
@@ -271,6 +278,7 @@
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
+	| moxie \
 	| mt \
 	| msp430 \
 	| nios | nios2 \
@@ -279,6 +287,7 @@
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
+	| rx \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
@@ -286,13 +295,14 @@
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
 	| spu | strongarm \
 	| tahoe | thumb | tic4x | tic80 | tron \
+	| ubicom32 \
 	| v850 | v850e \
 	| we32k \
 	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
 	| z8k | z80)
 		basic_machine=$basic_machine-unknown
 		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
+	m6811 | m68hc11 | m6812 | m68hc12 | picochip)
 		# Motorola 68HC11/12.
 		basic_machine=$basic_machine-unknown
 		os=-none
@@ -335,7 +345,7 @@
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -363,7 +373,7 @@
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
 	| pyramid-* \
-	| romp-* | rs6000-* \
+	| romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
@@ -372,6 +382,7 @@
 	| tahoe-* | thumb-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* | tile-* \
 	| tron-* \
+	| ubicom32-* \
 	| v850-* | v850e-* | vax-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
@@ -445,6 +456,10 @@
 		basic_machine=m68k-apollo
 		os=-bsd
 		;;
+	aros)
+		basic_machine=i386-pc
+		os=-aros
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -461,6 +476,10 @@
 		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
 		os=-linux
 		;;
+	bluegene*)
+		basic_machine=powerpc-ibm
+		os=-cnk
+		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
@@ -713,6 +732,9 @@
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
+        microblaze)
+		basic_machine=microblaze-xilinx
+		;;
 	mingw32)
 		basic_machine=i386-pc
 		os=-mingw32
@@ -1254,10 +1276,11 @@
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -kopensolaris* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
+	      | -aos* | -aros* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
@@ -1276,7 +1299,7 @@
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1606,7 +1629,7 @@
 			-sunos*)
 				vendor=sun
 				;;
-			-aix*)
+			-cnk*|-aix*)
 				vendor=ibm
 				;;
 			-beos*)
diff -Naur gcc-4.4.2.orig/gcc/ada/gcc-interface/Makefile.in gcc-4.4.2/gcc/ada/gcc-interface/Makefile.in
--- gcc-4.4.2.orig/gcc/ada/gcc-interface/Makefile.in	2009-06-18 10:15:32.000000000 -0400
+++ gcc-4.4.2/gcc/ada/gcc-interface/Makefile.in	2009-10-24 06:58:53.054307000 -0400
@@ -106,8 +106,11 @@
 FORCE_DEBUG_ADAFLAGS = -g
 GNATLIBFLAGS = -gnatpg -nostdinc
 GNATLIBCFLAGS = -g -O2
+# Pretend that _Unwind_GetIPInfo is available for the target by default.  This
+# should be autodetected during the configuration of libada and passed down to
+# here, but we need something for --disable-libada and hope for the best.
 GNATLIBCFLAGS_FOR_C = $(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) -fexceptions \
-	-DIN_RTS
+	-DIN_RTS -DHAVE_GETIPINFO
 ALL_ADAFLAGS = $(CFLAGS) $(ADA_CFLAGS) $(ADAFLAGS)
 MOST_ADAFLAGS = $(CFLAGS) $(ADA_CFLAGS) $(SOME_ADAFLAGS)
 THREAD_KIND = native
@@ -2074,6 +2077,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2099,6 +2103,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib-shared-default
@@ -2107,6 +2112,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2116,6 +2122,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib-shared-win32
@@ -2124,6 +2131,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2137,6 +2145,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2156,6 +2165,7 @@
 	     GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) \
 	                    -fno-common" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C) -fno-common" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
 	     gnatlib
@@ -2179,6 +2189,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
@@ -2207,6 +2218,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
 	     TARGET_LIBGCC2_CFLAGS="$(TARGET_LIBGCC2_CFLAGS)" \
@@ -2220,6 +2232,7 @@
 	     EH_MECHANISM="" \
 	     GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
 	     TARGET_LIBGCC2_CFLAGS="$(TARGET_LIBGCC2_CFLAGS)" gnatlib
@@ -2232,6 +2245,7 @@
 	     EH_MECHANISM="-gcc" \
 	     GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
 	     TARGET_LIBGCC2_CFLAGS="$(TARGET_LIBGCC2_CFLAGS)" gnatlib
diff -Naur gcc-4.4.2.orig/gcc/ada/init.c gcc-4.4.2/gcc/ada/init.c
--- gcc-4.4.2.orig/gcc/ada/init.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/gcc/ada/init.c	2009-10-24 06:58:53.054307000 -0400
@@ -290,28 +290,21 @@
 extern void __gnat_set_code_loc (struct sigcontext *, char *);
 extern size_t __gnat_machine_state_length (void);
 
-/* __gnat_adjust_context_for_raise - see comments along with the default
-   version later in this file.  */
-
 #define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE
 
 void
-__gnat_adjust_context_for_raise (int signo, void *context)
+__gnat_adjust_context_for_raise (int signo, void *ucontext)
 {
-  struct sigcontext * sigcontext = (struct sigcontext *) context;
+  struct sigcontext *sigcontext = (struct sigcontext *) ucontext;
 
-  /* The fallback code fetches the faulting insn address from sc_pc, so
-     adjust that when need be.  For SIGFPE, the required adjustment depends
-     on the trap shadow situation (see man ieee).  */
+  /* The unwinder expects the signal context to contain the address of the
+     faulting instruction.  For SIGFPE, this depends on the trap shadow
+     situation (see man ieee).  We nonetheless always compensate for it,
+     considering that PC designates the instruction following the one that
+     trapped.  This is not necessarily true but corresponds to what we have
+     always observed.  */
   if (signo == SIGFPE)
-    {
-      /* ??? We never adjust here, considering that sc_pc always
-	 designates the instruction following the one which trapped.
-	 This is not necessarily true but corresponds to what we have
-	 always observed.  */
-    }
-  else
-    sigcontext->sc_pc ++;
+    sigcontext->sc_pc--;
 }
 
 static void
@@ -2154,8 +2147,11 @@
 				 void *ucontext ATTRIBUTE_UNUSED)
 {
   /* We used to compensate here for the raised from call vs raised from signal
-     exception discrepancy with the GCC ZCX scheme, but this is now dealt with
-     generically (except for the Alpha and IA-64), see GCC PR other/26208.
+     exception discrepancy with the GCC ZCX scheme, but this now can be dealt
+     with generically in the unwinder (see GCC PR other/26208).  This however
+     requires the use of the _Unwind_GetIPInfo routine in raise-gcc.c, which
+     is predicated on the definition of HAVE_GETIPINFO at compile time.  Only
+     the VMS ports still do the compensation described in the few lines below.
 
      *** Call vs signal exception discrepancy with GCC ZCX scheme ***
 
diff -Naur gcc-4.4.2.orig/gcc/ada/raise-gcc.c gcc-4.4.2/gcc/ada/raise-gcc.c
--- gcc-4.4.2.orig/gcc/ada/raise-gcc.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/gcc/ada/raise-gcc.c	2009-10-27 15:42:17.506639000 -0400
@@ -56,6 +56,14 @@
 #include "adaint.h"
 #include "raise.h"
 
+#ifdef __APPLE__
+/* On MacOS X, versions older than 10.5 don't export _Unwind_GetIPInfo.  */
+#undef HAVE_GETIPINFO
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1050
+#define HAVE_GETIPINFO 1
+#endif
+#endif
+
 /* The names of a couple of "standard" routines for unwinding/propagation
    actually vary depending on the underlying GCC scheme for exception handling
    (SJLJ or DWARF). We need a consistently named interface to import from
@@ -501,7 +509,14 @@
 static void
 db_region_for (region_descriptor *region, _Unwind_Context *uw_context)
 {
-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;
+  int ip_before_insn = 0;
+#ifdef HAVE_GETIPINFO
+  _Unwind_Ptr ip = _Unwind_GetIPInfo (uw_context, &ip_before_insn);
+#else
+  _Unwind_Ptr ip = _Unwind_GetIP (uw_context);
+#endif
+  if (!ip_before_insn)
+    ip--;
 
   if (! (db_accepted_codes () & DB_REGIONS))
     return;
@@ -631,7 +646,14 @@
 static void
 db_action_for (action_descriptor *action, _Unwind_Context *uw_context)
 {
-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;
+  int ip_before_insn = 0;
+#ifdef HAVE_GETIPINFO
+  _Unwind_Ptr ip = _Unwind_GetIPInfo (uw_context, &ip_before_insn);
+#else
+  _Unwind_Ptr ip = _Unwind_GetIP (uw_context);
+#endif
+  if (!ip_before_insn)
+    ip--;
 
   db (DB_ACTIONS, "For ip @ 0x%08x => ", ip);
 
@@ -670,14 +692,6 @@
    There are two variants of this routine, depending on the underlying
    mechanism (DWARF/SJLJ), which account for differences in the tables.  */
 
-#ifdef __APPLE__
-/* On MacOS X, versions older than 10.5 don't export _Unwind_GetIPInfo.  */
-#undef HAVE_GETIPINFO
-#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1050
-#define HAVE_GETIPINFO 1
-#endif
-#endif
-
 #ifdef __USING_SJLJ_EXCEPTIONS__
 
 #define __builtin_eh_return_data_regno(x) x
diff -Naur gcc-4.4.2.orig/gcc/builtins.c gcc-4.4.2/gcc/builtins.c
--- gcc-4.4.2.orig/gcc/builtins.c	2009-08-24 05:52:03.000000000 -0400
+++ gcc-4.4.2/gcc/builtins.c	2009-12-03 10:33:18.053138000 -0500
@@ -3712,7 +3712,15 @@
 {
   tree result = fold_builtin_strcpy (fndecl, dest, src, 0);
   if (result)
-    return expand_expr (result, target, mode, EXPAND_NORMAL);
+    {
+      while (TREE_CODE (result) == COMPOUND_EXPR)
+	{
+	  expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,
+		       EXPAND_NORMAL);
+	  result = TREE_OPERAND (result, 1);
+	}
+      return expand_expr (result, target, mode, EXPAND_NORMAL);
+    }
   return expand_movstr (dest, src, target, /*endp=*/0);
 
 }
diff -Naur gcc-4.4.2.orig/gcc/c-common.c gcc-4.4.2/gcc/c-common.c
--- gcc-4.4.2.orig/gcc/c-common.c	2009-09-23 10:58:58.000000000 -0400
+++ gcc-4.4.2/gcc/c-common.c	2009-11-05 09:57:57.733685000 -0500
@@ -7633,15 +7633,14 @@
       error ("cannot apply %<offsetof%> when %<operator[]%> is overloaded");
       return error_mark_node;
 
-    case INTEGER_CST:
-      gcc_assert (integer_zerop (expr));
-      return size_zero_node;
-
     case NOP_EXPR:
     case INDIRECT_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);
-      gcc_assert (base == error_mark_node || base == size_zero_node);
-      return base;
+      if (!integer_zerop (TREE_OPERAND (expr, 0)))
+	{
+	  error ("cannot apply %<offsetof%> to a non constant address");
+	  return error_mark_node;
+	}
+      return size_zero_node;
 
     case COMPONENT_REF:
       base = fold_offsetof_1 (TREE_OPERAND (expr, 0), stop_ref);
diff -Naur gcc-4.4.2.orig/gcc/cgraphunit.c gcc-4.4.2/gcc/cgraphunit.c
--- gcc-4.4.2.orig/gcc/cgraphunit.c	2009-02-28 16:34:23.000000000 -0500
+++ gcc-4.4.2/gcc/cgraphunit.c	2009-10-19 08:15:27.233029000 -0400
@@ -1293,6 +1293,7 @@
   timevar_pop (TV_CGRAPHOPT);
 
   /* Output everything.  */
+  (*debug_hooks->assembly_start) ();
   if (!quiet_flag)
     fprintf (stderr, "Assembling functions:\n");
 #ifdef ENABLE_CHECKING
diff -Naur gcc-4.4.2.orig/gcc/combine.c gcc-4.4.2/gcc/combine.c
--- gcc-4.4.2.orig/gcc/combine.c	2009-04-01 16:47:37.000000000 -0400
+++ gcc-4.4.2/gcc/combine.c	2009-12-23 12:07:04.997054000 -0500
@@ -7039,15 +7039,14 @@
       tem = make_compound_operation (SUBREG_REG (x), in_code);
 
       {
-	rtx simplified;
-	simplified = simplify_subreg (GET_MODE (x), tem, GET_MODE (tem),
-				      SUBREG_BYTE (x));
+	rtx simplified = simplify_subreg (mode, tem, GET_MODE (SUBREG_REG (x)),
+					  SUBREG_BYTE (x));
 
 	if (simplified)
 	  tem = simplified;
 
 	if (GET_CODE (tem) != GET_CODE (SUBREG_REG (x))
-	    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (tem))
+	    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))
 	    && subreg_lowpart_p (x))
 	  {
 	    rtx newer = force_to_mode (tem, mode, ~(HOST_WIDE_INT) 0,
@@ -8512,6 +8511,12 @@
   enum rtx_code outer_code, inner_code;
   rtx decomposed, distributed, inner_op0, inner_op1, new_op0, new_op1, tmp;
 
+  /* Distributivity is not true for floating point as it can change the
+     value.  So we don't do it unless -funsafe-math-optimizations.  */
+  if (FLOAT_MODE_P (GET_MODE (x))
+      && ! flag_unsafe_math_optimizations)
+    return NULL_RTX;
+
   decomposed = XEXP (x, n);
   if (!ARITHMETIC_P (decomposed))
     return NULL_RTX;
diff -Naur gcc-4.4.2.orig/gcc/config/alpha/alpha.md gcc-4.4.2/gcc/config/alpha/alpha.md
--- gcc-4.4.2.orig/gcc/config/alpha/alpha.md	2009-09-30 14:03:17.000000000 -0400
+++ gcc-4.4.2/gcc/config/alpha/alpha.md	2009-11-23 16:14:32.129759000 -0500
@@ -4350,7 +4350,7 @@
 		 (match_dup 4)))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (DImode);
+    operands[5] = gen_reg_rtx (SImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
     operands[5] = operands[0];
 })
@@ -4376,9 +4376,9 @@
 				 (match_dup 4))))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (DImode);
+    operands[5] = gen_reg_rtx (SImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
-    operands[5] = operands[0];
+    operands[5] = gen_lowpart (SImode, operands[0]);
 })
 
 (define_insn_and_split "*cmp_ssub_di"
@@ -4426,7 +4426,7 @@
 		 (match_dup 4)))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (DImode);
+    operands[5] = gen_reg_rtx (SImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
     operands[5] = operands[0];
 })
@@ -4452,9 +4452,9 @@
 				  (match_dup 4))))]
 {
   if (can_create_pseudo_p ())
-    operands[5] = gen_reg_rtx (DImode);
+    operands[5] = gen_reg_rtx (SImode);
   else if (reg_overlap_mentioned_p (operands[5], operands[4]))
-    operands[5] = operands[0];
+    operands[5] = gen_lowpart (SImode, operands[0]);
 })
 
 ;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF
diff -Naur gcc-4.4.2.orig/gcc/config/arm/arm.c gcc-4.4.2/gcc/config/arm/arm.c
--- gcc-4.4.2.orig/gcc/config/arm/arm.c	2009-10-05 05:41:43.000000000 -0400
+++ gcc-4.4.2/gcc/config/arm/arm.c	2009-12-11 12:37:34.435592000 -0500
@@ -53,6 +53,7 @@
 #include "debug.h"
 #include "langhooks.h"
 #include "df.h"
+#include "libfuncs.h"
 
 /* Forward definitions of types.  */
 typedef struct minipool_node    Mnode;
@@ -922,6 +923,9 @@
   set_optab_libfunc (umod_optab, DImode, NULL);
   set_optab_libfunc (smod_optab, SImode, NULL);
   set_optab_libfunc (umod_optab, SImode, NULL);
+
+  if (TARGET_AAPCS_BASED)
+    synchronize_libfunc = init_one_libfunc ("__sync_synchronize");
 }
 
 /* On AAPCS systems, this is the "struct __va_list".  */
@@ -10975,7 +10979,7 @@
 	  {
 	    /* We're only using DImode here because it's a convenient size.  */
 	    ops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * i);
-	    ops[1] = adjust_address (mem, SImode, 8 * i);
+	    ops[1] = adjust_address (mem, DImode, 8 * i);
 	    if (reg_overlap_mentioned_p (ops[0], mem))
 	      {
 		gcc_assert (overlap == -1);
diff -Naur gcc-4.4.2.orig/gcc/config/arm/ieee754-df.S gcc-4.4.2/gcc/config/arm/ieee754-df.S
--- gcc-4.4.2.orig/gcc/config/arm/ieee754-df.S	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/gcc/config/arm/ieee754-df.S	2009-12-11 05:31:13.757629000 -0500
@@ -1117,7 +1117,7 @@
 ARM_FUNC_ALIAS eqdf2 cmpdf2
 	mov	ip, #1			@ how should we specify unordered here?
 
-1:	str	ip, [sp, #-4]
+1:	str	ip, [sp, #-4]!
 
 	@ Trap any INF/NAN first.
 	mov	ip, xh, lsl #1
@@ -1129,7 +1129,8 @@
 
 	@ Test for equality.
 	@ Note that 0.0 is equal to -0.0.
-2:	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
+2:	add	sp, sp, #4
+	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
 	do_it	eq, e
 	COND(orr,s,eq)	ip, yl, yh, lsl #1	@ and y == 0.0 or -0.0
 	teqne	xh, yh			@ or xh == yh
@@ -1168,7 +1169,7 @@
 	bne	2b
 	orrs	ip, yl, yh, lsl #12
 	beq	2b			@ y is not NAN
-5:	ldr	r0, [sp, #-4]		@ unordered return code
+5:	ldr	r0, [sp], #4		@ unordered return code
 	RET
 
 	FUNC_END gedf2
diff -Naur gcc-4.4.2.orig/gcc/config/arm/ieee754-sf.S gcc-4.4.2/gcc/config/arm/ieee754-sf.S
--- gcc-4.4.2.orig/gcc/config/arm/ieee754-sf.S	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/gcc/config/arm/ieee754-sf.S	2009-12-11 05:31:13.757629000 -0500
@@ -822,7 +822,7 @@
 ARM_FUNC_ALIAS eqsf2 cmpsf2
 	mov	ip, #1			@ how should we specify unordered here?
 
-1:	str	ip, [sp, #-4]
+1:	str	ip, [sp, #-4]!
 
 	@ Trap any INF/NAN first.
 	mov	r2, r0, lsl #1
@@ -834,7 +834,8 @@
 
 	@ Compare values.
 	@ Note that 0.0 is equal to -0.0.
-2:	orrs	ip, r2, r3, lsr #1	@ test if both are 0, clear C flag
+2:	add	sp, sp, #4
+	orrs	ip, r2, r3, lsr #1	@ test if both are 0, clear C flag
 	do_it	ne
 	teqne	r0, r1			@ if not 0 compare sign
 	do_it	pl
@@ -858,7 +859,7 @@
 	bne	2b
 	movs	ip, r1, lsl #9
 	beq	2b			@ r1 is not NAN
-5:	ldr	r0, [sp, #-4]		@ return unordered code.
+5:	ldr	r0, [sp], #4		@ return unordered code.
 	RET
 
 	FUNC_END gesf2
diff -Naur gcc-4.4.2.orig/gcc/config/arm/linux-atomic.c gcc-4.4.2/gcc/config/arm/linux-atomic.c
--- gcc-4.4.2.orig/gcc/config/arm/linux-atomic.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/gcc/config/arm/linux-atomic.c	2009-12-11 12:45:32.597608000 -0500
@@ -266,8 +266,10 @@
   void HIDDEN								\
   __sync_lock_release_##WIDTH (TYPE *ptr)				\
   {									\
-    *ptr = 0;								\
+    /* All writes before this point must be seen before we release	\
+       the lock itself.  */						\
     __kernel_dmb ();							\
+    *ptr = 0;								\
   }
 
 SYNC_LOCK_RELEASE (int,   4)
diff -Naur gcc-4.4.2.orig/gcc/config/arm/neon.md gcc-4.4.2/gcc/config/arm/neon.md
--- gcc-4.4.2.orig/gcc/config/arm/neon.md	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/config/arm/neon.md	2009-12-11 06:53:46.905784000 -0500
@@ -3611,7 +3611,8 @@
 			  UNSPEC_VSHLL_N))]
   "TARGET_NEON"
 {
-  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode));
+  /* The boundaries are: 0 < imm <= size.  */
+  neon_const_bounds (operands[2], 0, neon_element_bits (<MODE>mode) + 1);
   return "vshll.%T3%#<V_sz_elem>\t%q0, %P1, %2";
 }
   [(set_attr "neon_type" "neon_shift_1")]
diff -Naur gcc-4.4.2.orig/gcc/config/arm/thumb2.md gcc-4.4.2/gcc/config/arm/thumb2.md
--- gcc-4.4.2.orig/gcc/config/arm/thumb2.md	2008-11-20 18:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/config/arm/thumb2.md	2009-12-02 06:30:38.480228000 -0500
@@ -57,7 +57,7 @@
 			 [(match_operand:SI 2 "s_register_operand" "r")
 			  (match_operand:SI 3 "const_int_operand" "M")]))
 		(match_operand:SI 1 "s_register_operand" "r")))]
-  "TARGET_ARM"
+  "TARGET_THUMB2"
   "bic%?\\t%0, %1, %2%S4"
   [(set_attr "predicable" "yes")
    (set_attr "shift" "2")
diff -Naur gcc-4.4.2.orig/gcc/config/i386/cygming.h gcc-4.4.2/gcc/config/i386/cygming.h
--- gcc-4.4.2.orig/gcc/config/i386/cygming.h	2009-07-12 11:56:41.000000000 -0400
+++ gcc-4.4.2/gcc/config/i386/cygming.h	2009-11-11 15:21:14.372933000 -0500
@@ -49,8 +49,9 @@
    target, always use the svr4_dbx_register_map for DWARF .eh_frame
    even if we don't use DWARF .debug_frame. */
 #undef DWARF_FRAME_REGNUM
-#define DWARF_FRAME_REGNUM(n) TARGET_64BIT \
-	? dbx64_register_map[(n)] : svr4_dbx_register_map[(n)] 
+#define DWARF_FRAME_REGNUM(n)					\
+  (TARGET_64BIT ? dbx64_register_map[(n)]			\
+		: svr4_dbx_register_map[(n)])
 
 #ifdef HAVE_GAS_PE_SECREL32_RELOC
 /* Use section relative relocations for debugging offsets.  Unlike
@@ -126,8 +127,6 @@
 
 /* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */
 #define HANDLE_PRAGMA_PACK_PUSH_POP 1
-/* Enable push_macro & pop_macro */
-#define HANDLE_PRAGMA_PUSH_POP_MACRO 1
 
 union tree_node;
 #define TREE union tree_node *
diff -Naur gcc-4.4.2.orig/gcc/config/i386/cygwin.h gcc-4.4.2/gcc/config/i386/cygwin.h
--- gcc-4.4.2.orig/gcc/config/i386/cygwin.h	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/config/i386/cygwin.h	2009-12-18 04:22:39.405227000 -0500
@@ -94,7 +94,7 @@
   %{shared|mdll: -e \
     %{mno-cygwin:_DllMainCRTStartup@12} \
     %{!mno-cygwin:__cygwin_dll_entry@12}}\
-  %{!mno-cygwin:--dll-search-prefix=cyg}"
+  %{!mno-cygwin:--dll-search-prefix=cyg -tsaware}"
 
 /* Allocate space for all of the machine-spec-specific stuff.
    Allocate enough space for cygwin -> mingw32  munging plus
diff -Naur gcc-4.4.2.orig/gcc/config/i386/i386.c gcc-4.4.2/gcc/config/i386/i386.c
--- gcc-4.4.2.orig/gcc/config/i386/i386.c	2009-09-21 10:22:40.000000000 -0400
+++ gcc-4.4.2/gcc/config/i386/i386.c	2009-11-25 15:54:12.741557000 -0500
@@ -10379,7 +10379,7 @@
 static bool
 ix86_pic_register_p (rtx x)
 {
-  if (GET_CODE (x) == VALUE)
+  if (GET_CODE (x) == VALUE && CSELIB_VAL_PTR (x))
     return (pic_offset_table_rtx
 	    && rtx_equal_for_cselib_p (x, pic_offset_table_rtx));
   else
@@ -11313,13 +11313,14 @@
 	    case 2: size = "WORD"; break;
 	    case 4: size = "DWORD"; break;
 	    case 8: size = "QWORD"; break;
-	    case 12: size = "XWORD"; break;
+	    case 12: size = "TBYTE"; break;
 	    case 16:
 	      if (GET_MODE (x) == XFmode)
-		size = "XWORD";
+		size = "TBYTE";
               else
 		size = "XMMWORD";
               break;
+	    case 32: size = "YMMWORD"; break;
 	    default:
 	      gcc_unreachable ();
 	    }
diff -Naur gcc-4.4.2.orig/gcc/config/i386/i386.md gcc-4.4.2/gcc/config/i386/i386.md
--- gcc-4.4.2.orig/gcc/config/i386/i386.md	2009-10-12 09:40:17.000000000 -0400
+++ gcc-4.4.2/gcc/config/i386/i386.md	2009-12-07 09:44:18.156252000 -0500
@@ -6487,7 +6487,7 @@
   switch (get_attr_type (insn))
     {
     case TYPE_LEA:
-      operands[2] = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));
+      operands[2] = XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 0);
       return "lea{l}\t{%a2, %k0|%k0, %a2}";
 
     case TYPE_INCDEC:
@@ -9880,7 +9880,7 @@
 			   (const_int 8))))
    (clobber (reg:CC FLAGS_REG))]
   "(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))"
-  "ior{b}\t{%h2, %h0|%h0, %h2}"
+  "or{b}\t{%h2, %h0|%h0, %h2}"
   [(set_attr "type" "alu")
    (set_attr "length_immediate" "0")
    (set_attr "mode" "QI")])
@@ -14941,6 +14941,10 @@
 ;; checked for calls.  This is a bug in the generic code, but it isn't that
 ;; easy to fix.  Ignore it for now and be prepared to fix things up.
 
+;; P6 processors will jump to the address after the decrement when %esp
+;; is used as a call operand, so they will execute return address as a code.
+;; See Pentium Pro errata 70, Pentium 2 errata A33 and Pentium 3 errata E17.
+
 ;; Call subroutine returning no value.
 
 (define_expand "call_pop"
@@ -14970,11 +14974,11 @@
   [(set_attr "type" "call")])
 
 (define_insn "*call_pop_1"
-  [(call (mem:QI (match_operand:SI 0 "call_insn_operand" "rsm"))
+  [(call (mem:QI (match_operand:SI 0 "call_insn_operand" "lsm"))
 	 (match_operand:SI 1 "" ""))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 2 "immediate_operand" "i")))]
-  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[0], Pmode))
     return "call\t%P0";
@@ -14987,7 +14991,7 @@
 	 (match_operand:SI 1 "" ""))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 2 "immediate_operand" "i,i")))]
-  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P0
    jmp\t%A0"
@@ -15026,9 +15030,9 @@
   [(set_attr "type" "call")])
 
 (define_insn "*call_1"
-  [(call (mem:QI (match_operand:SI 0 "call_insn_operand" "rsm"))
+  [(call (mem:QI (match_operand:SI 0 "call_insn_operand" "lsm"))
 	 (match_operand 1 "" ""))]
-  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[0], Pmode))
     return "call\t%P0";
@@ -15039,7 +15043,7 @@
 (define_insn "*sibcall_1"
   [(call (mem:QI (match_operand:SI 0 "sibcall_insn_operand" "s,U"))
 	 (match_operand 1 "" ""))]
-  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P0
    jmp\t%A0"
@@ -15048,7 +15052,7 @@
 (define_insn "*call_1_rex64"
   [(call (mem:QI (match_operand:DI 0 "call_insn_operand" "rsm"))
 	 (match_operand 1 "" ""))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)
    && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC"
 {
   if (constant_call_address_operand (operands[0], Pmode))
@@ -15073,7 +15077,7 @@
    (clobber (reg:TI XMM15_REG))
    (clobber (reg:DI SI_REG))
    (clobber (reg:DI DI_REG))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[0], Pmode))
     return "call\t%P0";
@@ -15084,14 +15088,14 @@
 (define_insn "*call_1_rex64_large"
   [(call (mem:QI (match_operand:DI 0 "call_insn_operand" "rm"))
 	 (match_operand 1 "" ""))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)"
   "call\t%A0"
   [(set_attr "type" "call")])
 
 (define_insn "*sibcall_1_rex64"
   [(call (mem:QI (match_operand:DI 0 "sibcall_insn_operand" "s,U"))
 	 (match_operand 1 "" ""))]
-  "SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P0
    jmp\t%A0"
@@ -21469,11 +21473,11 @@
 
 (define_insn "*call_value_pop_1"
   [(set (match_operand 0 "" "")
-	(call (mem:QI (match_operand:SI 1 "call_insn_operand" "rsm"))
+	(call (mem:QI (match_operand:SI 1 "call_insn_operand" "lsm"))
 	      (match_operand:SI 2 "" "")))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 3 "immediate_operand" "i")))]
-  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[1], Pmode))
     return "call\t%P1";
@@ -21487,7 +21491,7 @@
 	      (match_operand:SI 2 "" "")))
    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 			    (match_operand:SI 3 "immediate_operand" "i,i")))]
-  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P1
    jmp\t%A1"
@@ -21536,7 +21540,7 @@
    (clobber (reg:TI XMM15_REG))
    (clobber (reg:DI SI_REG))
    (clobber (reg:DI DI_REG))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (SIBLING_CALL_P (insn))
     return "jmp\t%P1";
@@ -21547,9 +21551,9 @@
 
 (define_insn "*call_value_1"
   [(set (match_operand 0 "" "")
-	(call (mem:QI (match_operand:SI 1 "call_insn_operand" "rsm"))
+	(call (mem:QI (match_operand:SI 1 "call_insn_operand" "lsm"))
 	      (match_operand:SI 2 "" "")))]
-  "!SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && !SIBLING_CALL_P (insn)"
 {
   if (constant_call_address_operand (operands[1], Pmode))
     return "call\t%P1";
@@ -21561,7 +21565,7 @@
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:SI 1 "sibcall_insn_operand" "s,U"))
 	      (match_operand:SI 2 "" "")))]
-  "SIBLING_CALL_P (insn) && !TARGET_64BIT"
+  "!TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P1
    jmp\t%A1"
@@ -21571,7 +21575,7 @@
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:DI 1 "call_insn_operand" "rsm"))
 	      (match_operand:DI 2 "" "")))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)
    && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC"
 {
   if (constant_call_address_operand (operands[1], Pmode))
@@ -21609,7 +21613,7 @@
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:DI 1 "call_insn_operand" "rm"))
 	      (match_operand:DI 2 "" "")))]
-  "!SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && !SIBLING_CALL_P (insn)"
   "call\t%A1"
   [(set_attr "type" "callv")])
 
@@ -21617,7 +21621,7 @@
   [(set (match_operand 0 "" "")
 	(call (mem:QI (match_operand:DI 1 "sibcall_insn_operand" "s,U"))
 	      (match_operand:DI 2 "" "")))]
-  "SIBLING_CALL_P (insn) && TARGET_64BIT"
+  "TARGET_64BIT && SIBLING_CALL_P (insn)"
   "@
    jmp\t%P1
    jmp\t%A1"
@@ -21932,7 +21936,7 @@
   [(set_attr "type" "multi")])
 
 (define_mode_iterator CRC32MODE [QI HI SI])
-(define_mode_attr crc32modesuffix [(QI "b") (HI "w") (SI "l")])
+(define_mode_attr crc32modesuffix [(QI "{b}") (HI "{w}") (SI "{l}")])
 (define_mode_attr crc32modeconstraint [(QI "qm") (HI "rm") (SI "rm")])
 
 (define_insn "sse4_2_crc32<mode>"
@@ -21955,7 +21959,7 @@
 	   (match_operand:DI 2 "nonimmediate_operand" "rm")]
 	  UNSPEC_CRC32))]
   "TARGET_SSE4_2 && TARGET_64BIT"
-  "crc32q\t{%2, %0|%0, %2}"
+  "crc32{q}\t{%2, %0|%0, %2}"
   [(set_attr "type" "sselog1")
    (set_attr "prefix_rep" "1")
    (set_attr "prefix_extra" "1")
diff -Naur gcc-4.4.2.orig/gcc/config/i386/mmx.md gcc-4.4.2/gcc/config/i386/mmx.md
--- gcc-4.4.2.orig/gcc/config/i386/mmx.md	2009-03-02 15:58:39.000000000 -0500
+++ gcc-4.4.2/gcc/config/i386/mmx.md	2009-12-30 06:34:57.597575000 -0500
@@ -336,7 +336,7 @@
   "TARGET_3DNOW && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "@
    pfsub\t{%2, %0|%0, %2}
-   pfsubr\t{%2, %0|%0, %2}"
+   pfsubr\t{%1, %0|%0, %1}"
   [(set_attr "type" "mmxadd")
    (set_attr "mode" "V2SF")])
 
@@ -1202,7 +1202,10 @@
   "TARGET_SSE || TARGET_3DNOW_A"
 {
   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+  if (MEM_P (operands[2]))
+    return "pinsrw\t{%3, %2, %0|%0, %2, %3}";
+  else
+    return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
 }
   [(set_attr "type" "mmxcvt")
    (set_attr "mode" "DI")])
diff -Naur gcc-4.4.2.orig/gcc/config/i386/predicates.md gcc-4.4.2/gcc/config/i386/predicates.md
--- gcc-4.4.2.orig/gcc/config/i386/predicates.md	2009-03-12 16:45:39.000000000 -0400
+++ gcc-4.4.2/gcc/config/i386/predicates.md	2009-11-14 13:53:09.518880000 -0500
@@ -519,6 +519,22 @@
 			FIRST_PSEUDO_REGISTER, LAST_VIRTUAL_REGISTER));
 })
 
+;; P6 processors will jump to the address after the decrement when %esp
+;; is used as a call operand, so they will execute return address as a code.
+;; See Pentium Pro errata 70, Pentium 2 errata A33 and Pentium 3 errata E17.
+
+(define_predicate "call_register_no_elim_operand"
+  (match_operand 0 "register_operand")
+{
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+
+  if (!TARGET_64BIT && op == stack_pointer_rtx)
+    return 0;
+
+  return register_no_elim_operand (op, mode);
+})
+
 ;; Similarly, but include the stack pointer.  This is used to prevent esp
 ;; from being used as an index reg.
 (define_predicate "index_register_operand"
@@ -547,7 +563,7 @@
 ;; Test for a valid operand for a call instruction.
 (define_predicate "call_insn_operand"
   (ior (match_operand 0 "constant_call_address_operand")
-       (ior (match_operand 0 "register_no_elim_operand")
+       (ior (match_operand 0 "call_register_no_elim_operand")
 	    (match_operand 0 "memory_operand"))))
 
 ;; Similarly, but for tail calls, in which we cannot allow memory references.
diff -Naur gcc-4.4.2.orig/gcc/config/i386/sse.md gcc-4.4.2/gcc/config/i386/sse.md
--- gcc-4.4.2.orig/gcc/config/i386/sse.md	2009-08-16 15:34:49.000000000 -0400
+++ gcc-4.4.2/gcc/config/i386/sse.md	2009-11-25 15:54:12.741557000 -0500
@@ -2307,7 +2307,7 @@
 	     (parallel [(const_int 0)]))]
 	  UNSPEC_FIX_NOTRUNC))]
   "TARGET_SSE && TARGET_64BIT"
-  "%vcvtss2siq\t{%1, %0|%0, %1}"
+  "%vcvtss2si{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "double,vector")
    (set_attr "prefix_rep" "1")
@@ -2319,7 +2319,7 @@
 	(unspec:DI [(match_operand:SF 1 "nonimmediate_operand" "x,m")]
 		   UNSPEC_FIX_NOTRUNC))]
   "TARGET_SSE && TARGET_64BIT"
-  "%vcvtss2siq\t{%1, %0|%0, %1}"
+  "%vcvtss2si{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "double,vector")
    (set_attr "amdfam10_decode" "double,double")
@@ -2349,7 +2349,7 @@
 	    (match_operand:V4SF 1 "nonimmediate_operand" "x,m")
 	    (parallel [(const_int 0)]))))]
   "TARGET_SSE && TARGET_64BIT"
-  "%vcvttss2siq\t{%1, %0|%0, %1}"
+  "%vcvttss2si{q}\t{%1, %0|%0, %1}"
   [(set_attr "type" "sseicvt")
    (set_attr "athlon_decode" "double,vector")
    (set_attr "amdfam10_decode" "double,double")
@@ -6590,7 +6590,10 @@
   "TARGET_AVX"
 {
   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "vpinsr<avxmodesuffixs>\t{%3, %k2, %1, %0|%0, %1, %k2, %3}";
+  if (MEM_P (operands[2]))
+    return "vpinsr<avxmodesuffixs>\t{%3, %2, %1, %0|%0, %1, %2, %3}";
+  else
+    return "vpinsr<avxmodesuffixs>\t{%3, %k2, %1, %0|%0, %1, %k2, %3}";
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix" "vex")
@@ -6606,7 +6609,10 @@
   "TARGET_SSE4_1"
 {
   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "pinsrb\t{%3, %k2, %0|%0, %k2, %3}";
+  if (MEM_P (operands[2]))
+    return "pinsrb\t{%3, %2, %0|%0, %2, %3}";
+  else
+    return "pinsrb\t{%3, %k2, %0|%0, %k2, %3}";
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix_extra" "1")
@@ -6622,7 +6628,10 @@
   "TARGET_SSE2"
 {
   operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+  if (MEM_P (operands[2]))
+    return "pinsrw\t{%3, %2, %0|%0, %2, %3}";
+  else
+    return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
 }
   [(set_attr "type" "sselog")
    (set_attr "prefix_data16" "1")
diff -Naur gcc-4.4.2.orig/gcc/config/mips/mips.c gcc-4.4.2/gcc/config/mips/mips.c
--- gcc-4.4.2.orig/gcc/config/mips/mips.c	2009-09-21 15:33:38.000000000 -0400
+++ gcc-4.4.2/gcc/config/mips/mips.c	2009-11-10 17:35:18.687132000 -0500
@@ -2328,6 +2328,28 @@
 	  : emit_move_insn_1 (dest, src));
 }
 
+/* Emit an instruction of the form (set TARGET (CODE OP0)).  */
+
+static void
+mips_emit_unary (enum rtx_code code, rtx target, rtx op0)
+{
+  emit_insn (gen_rtx_SET (VOIDmode, target,
+			  gen_rtx_fmt_e (code, GET_MODE (op0), op0)));
+}
+
+/* Compute (CODE OP0) and store the result in a new register of mode MODE.
+   Return that new register.  */
+
+static rtx
+mips_force_unary (enum machine_mode mode, enum rtx_code code, rtx op0)
+{
+  rtx reg;
+
+  reg = gen_reg_rtx (mode);
+  mips_emit_unary (code, reg, op0);
+  return reg;
+}
+
 /* Emit an instruction of the form (set TARGET (CODE OP0 OP1)).  */
 
 static void
@@ -6399,7 +6421,14 @@
 void
 mips_expand_synci_loop (rtx begin, rtx end)
 {
-  rtx inc, label, cmp, cmp_result;
+  rtx inc, label, end_label, cmp_result, mask, length;
+
+  /* Create end_label.  */
+  end_label = gen_label_rtx ();
+
+  /* Check if begin equals end.  */
+  cmp_result = gen_rtx_EQ (VOIDmode, begin, end);
+  emit_jump_insn (gen_condjump (cmp_result, end_label));
 
   /* Load INC with the cache line size (rdhwr INC,$1).  */
   inc = gen_reg_rtx (Pmode);
@@ -6407,18 +6436,36 @@
 	     ? gen_rdhwr_synci_step_si (inc)
 	     : gen_rdhwr_synci_step_di (inc));
 
+  /* Check if inc is 0.  */
+  cmp_result = gen_rtx_EQ (VOIDmode, inc, const0_rtx);
+  emit_jump_insn (gen_condjump (cmp_result, end_label));
+
+  /* Calculate mask.  */
+  mask = mips_force_unary (Pmode, NEG, inc);
+
+  /* Mask out begin by mask.  */
+  begin = mips_force_binary (Pmode, AND, begin, mask);
+
+  /* Calculate length.  */
+  length = mips_force_binary (Pmode, MINUS, end, begin);
+
   /* Loop back to here.  */
   label = gen_label_rtx ();
   emit_label (label);
 
   emit_insn (gen_synci (begin));
 
-  cmp = mips_force_binary (Pmode, GTU, begin, end);
+  /* Update length.  */
+  mips_emit_binary (MINUS, length, length, inc);
 
+  /* Update begin.  */
   mips_emit_binary (PLUS, begin, begin, inc);
 
-  cmp_result = gen_rtx_EQ (VOIDmode, cmp, const0_rtx);
+  /* Check if length is greater than 0.  */
+  cmp_result = gen_rtx_GT (VOIDmode, length, const0_rtx);
   emit_jump_insn (gen_condjump (cmp_result, label));
+
+  emit_label (end_label);
 }
 
 /* Expand a QI or HI mode atomic memory operation.
diff -Naur gcc-4.4.2.orig/gcc/config/mips/mips-dsp.md gcc-4.4.2/gcc/config/mips/mips-dsp.md
--- gcc-4.4.2.orig/gcc/config/mips/mips-dsp.md	2008-12-21 16:43:51.000000000 -0500
+++ gcc-4.4.2/gcc/config/mips/mips-dsp.md	2009-12-02 18:26:42.127620000 -0500
@@ -1048,7 +1048,7 @@
 
 (define_insn "mips_lhx_<mode>"
   [(set (match_operand:SI 0 "register_operand" "=d")
-	(zero_extend:SI
+	(sign_extend:SI
 	  (mem:HI (plus:P (match_operand:P 1 "register_operand" "d")
 			  (match_operand:P 2 "register_operand" "d")))))]
   "ISA_HAS_DSP"
diff -Naur gcc-4.4.2.orig/gcc/config/pa/linux-atomic.c gcc-4.4.2/gcc/config/pa/linux-atomic.c
--- gcc-4.4.2.orig/gcc/config/pa/linux-atomic.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/gcc/config/pa/linux-atomic.c	2009-10-15 19:00:37.250864000 -0400
@@ -24,14 +24,9 @@
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
-/* FIXME: work around build failure for hppa64-linux-gnu target. */
-#ifndef _LP64
-#include <errno.h>
-#else 
 #define EFAULT  14 
 #define EBUSY   16
 #define ENOSYS 251 
-#endif 
 
 /* All PA-RISC implementations supported by linux have strongly
    ordered loads and stores.  Only cache flushes and purges can be
diff -Naur gcc-4.4.2.orig/gcc/config/pa/pa.c gcc-4.4.2/gcc/config/pa/pa.c
--- gcc-4.4.2.orig/gcc/config/pa/pa.c	2009-07-27 11:26:05.000000000 -0400
+++ gcc-4.4.2/gcc/config/pa/pa.c	2009-11-24 19:35:16.079489000 -0500
@@ -1620,7 +1620,7 @@
       /* D might not fit in 14 bits either; for such cases load D into
 	 scratch reg.  */
       if (GET_CODE (operand1) == MEM
-	  && !memory_address_p (Pmode, XEXP (operand1, 0)))
+	  && !memory_address_p (GET_MODE (operand0), XEXP (operand1, 0)))
 	{
 	  /* We are reloading the address into the scratch register, so we
 	     want to make sure the scratch register is a full register.  */
@@ -7437,7 +7437,7 @@
     {
       length += 20;
 
-      if (!TARGET_PA_20 && !TARGET_NO_SPACE_REGS && flag_pic)
+      if (!TARGET_PA_20 && !TARGET_NO_SPACE_REGS && (!local_call || flag_pic))
 	length += 8;
     }
 
@@ -7457,7 +7457,7 @@
 	  if (!sibcall)
 	    length += 8;
 
-	  if (!TARGET_NO_SPACE_REGS && flag_pic)
+	  if (!TARGET_NO_SPACE_REGS && (!local_call || flag_pic))
 	    length += 8;
 	}
     }
@@ -7654,7 +7654,7 @@
 		  if (!sibcall && !TARGET_PA_20)
 		    {
 		      output_asm_insn ("{bl|b,l} .+8,%%r2", xoperands);
-		      if (TARGET_NO_SPACE_REGS)
+		      if (TARGET_NO_SPACE_REGS || (local_call && !flag_pic))
 			output_asm_insn ("addi 8,%%r2,%%r2", xoperands);
 		      else
 			output_asm_insn ("addi 16,%%r2,%%r2", xoperands);
@@ -7679,20 +7679,20 @@
 		}
 	      else
 		{
-		  if (!TARGET_NO_SPACE_REGS && flag_pic)
+		  if (!TARGET_NO_SPACE_REGS && (!local_call || flag_pic))
 		    output_asm_insn ("ldsid (%%r1),%%r31\n\tmtsp %%r31,%%sr0",
 				     xoperands);
 
 		  if (sibcall)
 		    {
-		      if (TARGET_NO_SPACE_REGS || !flag_pic)
+		      if (TARGET_NO_SPACE_REGS || (local_call && !flag_pic))
 			output_asm_insn ("be 0(%%sr4,%%r1)", xoperands);
 		      else
 			output_asm_insn ("be 0(%%sr0,%%r1)", xoperands);
 		    }
 		  else
 		    {
-		      if (TARGET_NO_SPACE_REGS || !flag_pic)
+		      if (TARGET_NO_SPACE_REGS || (local_call && !flag_pic))
 			output_asm_insn ("ble 0(%%sr4,%%r1)", xoperands);
 		      else
 			output_asm_insn ("ble 0(%%sr0,%%r1)", xoperands);
diff -Naur gcc-4.4.2.orig/gcc/config/pa/pa.md gcc-4.4.2/gcc/config/pa/pa.md
--- gcc-4.4.2.orig/gcc/config/pa/pa.md	2008-10-11 11:54:27.000000000 -0400
+++ gcc-4.4.2/gcc/config/pa/pa.md	2009-10-23 16:13:15.832024000 -0400
@@ -3191,6 +3191,40 @@
     DONE;
 }")
 
+;; Handle HImode input reloads requiring a general register as a
+;; scratch register.
+(define_expand "reload_inhi"
+  [(set (match_operand:HI 0 "register_operand" "=Z")
+	(match_operand:HI 1 "non_hard_reg_operand" ""))
+   (clobber (match_operand:HI 2 "register_operand" "=&r"))]
+  ""
+  "
+{
+  if (emit_move_sequence (operands, HImode, operands[2]))
+    DONE;
+
+  /* We don't want the clobber emitted, so handle this ourselves.  */
+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));
+  DONE;
+}")
+
+;; Handle HImode output reloads requiring a general register as a
+;; scratch register.
+(define_expand "reload_outhi"
+  [(set (match_operand:HI 0 "non_hard_reg_operand" "")
+	(match_operand:HI 1  "register_operand" "Z"))
+   (clobber (match_operand:HI 2 "register_operand" "=&r"))]
+  ""
+  "
+{
+  if (emit_move_sequence (operands, HImode, operands[2]))
+    DONE;
+
+  /* We don't want the clobber emitted, so handle this ourselves.  */
+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));
+  DONE;
+}")
+
 (define_insn ""
   [(set (match_operand:HI 0 "move_dest_operand"
 	 		  "=r,r,r,r,r,Q,!*q,!r")
@@ -3315,6 +3349,40 @@
     DONE;
 }")
 
+;; Handle QImode input reloads requiring a general register as a
+;; scratch register.
+(define_expand "reload_inqi"
+  [(set (match_operand:QI 0 "register_operand" "=Z")
+	(match_operand:QI 1 "non_hard_reg_operand" ""))
+   (clobber (match_operand:QI 2 "register_operand" "=&r"))]
+  ""
+  "
+{
+  if (emit_move_sequence (operands, QImode, operands[2]))
+    DONE;
+
+  /* We don't want the clobber emitted, so handle this ourselves.  */
+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));
+  DONE;
+}")
+
+;; Handle QImode output reloads requiring a general register as a
+;; scratch register.
+(define_expand "reload_outqi"
+  [(set (match_operand:QI 0 "non_hard_reg_operand" "")
+	(match_operand:QI 1  "register_operand" "Z"))
+   (clobber (match_operand:QI 2 "register_operand" "=&r"))]
+  ""
+  "
+{
+  if (emit_move_sequence (operands, QImode, operands[2]))
+    DONE;
+
+  /* We don't want the clobber emitted, so handle this ourselves.  */
+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));
+  DONE;
+}")
+
 (define_insn ""
   [(set (match_operand:QI 0 "move_dest_operand"
 			  "=r,r,r,r,r,Q,!*q,!r")
@@ -7503,17 +7571,6 @@
       operands[0] = index;
     }
 
-  /* In 64bit mode we must make sure to wipe the upper bits of the register
-     just in case the addition overflowed or we had random bits in the
-     high part of the register.  */
-  if (TARGET_64BIT)
-    {
-      rtx index = gen_reg_rtx (DImode);
-
-      emit_insn (gen_extendsidi2 (index, operands[0]));
-      operands[0] = gen_rtx_SUBREG (SImode, index, 4);
-    }
-
   if (!INT_5_BITS (operands[2]))
     operands[2] = force_reg (SImode, operands[2]);
 
@@ -7530,6 +7587,17 @@
   emit_insn (gen_cmpsi (operands[0], operands[2]));
   emit_jump_insn (gen_bgtu (operands[4]));
 
+  /* In 64bit mode we must make sure to wipe the upper bits of the register
+     just in case the addition overflowed or we had random bits in the
+     high part of the register.  */
+  if (TARGET_64BIT)
+    {
+      rtx index = gen_reg_rtx (DImode);
+
+      emit_insn (gen_extendsidi2 (index, operands[0]));
+      operands[0] = index;
+    }
+
   if (TARGET_BIG_SWITCH)
     {
       if (TARGET_64BIT)
@@ -7590,8 +7658,7 @@
 ;;; 64-bit code, 32-bit relative branch table.
 (define_insn "casesi64p"
   [(set (pc) (mem:DI (plus:DI
-		       (mult:DI (sign_extend:DI
-				  (match_operand:SI 0 "register_operand" "r"))
+		       (mult:DI (match_operand:DI 0 "register_operand" "r")
 				(const_int 8))
 		       (label_ref (match_operand 1 "" "")))))
    (clobber (match_scratch:DI 2 "=&r"))
diff -Naur gcc-4.4.2.orig/gcc/config/pa/t-hpux-shlib gcc-4.4.2/gcc/config/pa/t-hpux-shlib
--- gcc-4.4.2.orig/gcc/config/pa/t-hpux-shlib	2006-05-18 20:12:01.000000000 -0400
+++ gcc-4.4.2/gcc/config/pa/t-hpux-shlib	2009-10-15 20:04:11.546149000 -0400
@@ -8,6 +8,7 @@
 SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
 
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared  -nodefaultlibs \
+	-Wl,+h -Wl,$(SHLIB_SONAME) \
 	-o $(SHLIB_DIR)/$(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) && \
         rm -f $(SHLIB_DIR)/$(SHLIB_SONAME) && \
 	if [ -f $(SHLIB_DIR)/$(SHLIB_NAME) ]; then \
diff -Naur gcc-4.4.2.orig/gcc/config/s390/2097.md gcc-4.4.2/gcc/config/s390/2097.md
--- gcc-4.4.2.orig/gcc/config/s390/2097.md	2009-09-04 06:05:45.000000000 -0400
+++ gcc-4.4.2/gcc/config/s390/2097.md	2009-11-24 03:10:27.862507000 -0500
@@ -57,7 +57,8 @@
                   z10_int_fr_A3"
                   "z10_other_super, z10_other_super_c_E1, z10_other_super_E1, \
                   z10_int_super, z10_int_super_E1, \
-                  z10_lr, z10_store_super")
+                  z10_lr, z10_store_super"
+                  " ! s390_agen_dep_p")
 
 
 ; Forwarding from z10_super to frz10_ and z10_rec.
@@ -68,7 +69,8 @@
                   z10_store_super"
                   "z10_int_fr, z10_int_fr_E1, z10_int_fr_A3, \
                   z10_other_fr, z10_other_fr_A3, z10_lr_fr, z10_lr_fr_E1, \
-                  z10_other_fr_E1, z10_store_rec")
+                  z10_other_fr_E1, z10_store_rec"
+                  " ! s390_agen_dep_p")
 
 
 ; Forwarding from z10_fwd and z10_fr to z10_rec and z10_fr.
@@ -84,7 +86,8 @@
                   z10_int_fr_A3"
                   "z10_int_fr, z10_int_fr_E1, z10_int_fr_A3, \
                   z10_other_fr, z10_other_fr_A3, z10_lr_fr, z10_lr_fr_E1, \
-                  z10_other_fr_E1, z10_store_rec")
+                  z10_other_fr_E1, z10_store_rec"
+                  " ! s390_agen_dep_p")
 
 
 ;
@@ -205,15 +208,12 @@
        (and (eq_attr "type" "lr")
             (eq_attr "z10prop" "z10_fr")))
   "z10_e1_ANY, z10_Gate_ANY")
-;  "z10_e1_ANY")
 
 (define_insn_reservation "z10_lr_fr_E1" 6
   (and (eq_attr "cpu" "z10")
        (and (eq_attr "type" "lr")
             (eq_attr "z10prop" "z10_fr_E1")))
   "z10_e1_ANY, z10_Gate_ANY")
-;  "z10_e1_ANY")
-
 
 (define_insn_reservation "z10_la" 6
   (and (eq_attr "cpu" "z10")
@@ -227,14 +227,12 @@
        (and (eq_attr "type" "la")
             (eq_attr "z10prop" "z10_fwd")))
   "z10_e1_ANY, z10_Gate_ANY")
-;  "z10_e1_ANY")
 
 (define_insn_reservation "z10_la_fwd_A1" 6
   (and (eq_attr "cpu" "z10")
        (and (eq_attr "type" "la")
             (eq_attr "z10prop" "z10_fwd_A1")))
   "z10_e1_ANY, z10_Gate_ANY")
-;  "z10_e1_ANY")
 
 
 ; larl-type instructions
@@ -666,13 +664,14 @@
 ; Address-related bypasses
 ;
 
-; Here is the cycle diagram for Address-related bypasses:
+; Here is the cycle diagram for address-related bypasses:
 ; ... G1 G2 G3 A0 A1 A2 A3 E1 P1 P2 P3 R0 ...
-;         ^  ^    ^     ^  ^
-;         |  |    |     |  E1-type bypasses provide the new addr AFTER this cycle
-;         |  |    |     A3-type bypasses provide the new addr AFTER this cycle
-;         |  |    A1-type bypasses provide the new addr AFTER this cycle
-;         |  AGI resolution, actual USE of address is DURING this cycle
+;         ^  ^    ^     ^  ^        ^
+;         |  |    |     |  |        without bypass, its available AFTER this cycle
+;         |  |    |     |  E1-type bypasses provide the new value AFTER this cycle
+;         |  |    |     A3-type bypasses provide the new value AFTER this cycle
+;         |  |    A1-type bypasses provide the new value AFTER this cycle
+;         |  AGI resolution, actual USE of new value is DURING this cycle
 ;         AGI detection
 
 (define_bypass 3 "z10_larl_A1, z10_la_fwd_A1, z10_other_fwd_A1, \
@@ -682,7 +681,6 @@
                   z10_cs, z10_stm, z10_other"
 	         "s390_agen_dep_p")
 
-
 (define_bypass 5 "z10_larl_fwd_A3, z10_load_fwd_A3, z10_other_fwd_A3, \
                   z10_other_fr_A3, z10_int_fwd_A3, z10_int_fr_A3"
                  "z10_agen, z10_la, z10_branch, z10_call, z10_load, \
@@ -699,6 +697,12 @@
                   z10_cs, z10_stm, z10_other"
  	         "s390_agen_dep_p")
 
+(define_bypass 9 "z10_int_super, z10_int_fwd, z10_int_fr"
+                 "z10_agen, z10_la, z10_branch, z10_call, z10_load, \
+                  z10_store, \
+                  z10_cs, z10_stm, z10_other"
+ 	         "s390_agen_dep_p")
+
 
 
 ;
diff -Naur gcc-4.4.2.orig/gcc/config/s390/s390.c gcc-4.4.2/gcc/config/s390/s390.c
--- gcc-4.4.2.orig/gcc/config/s390/s390.c	2009-10-13 12:11:50.000000000 -0400
+++ gcc-4.4.2/gcc/config/s390/s390.c	2009-11-27 08:13:59.569259000 -0500
@@ -224,6 +224,9 @@
 
 extern int reload_completed;
 
+/* Kept up to date using the SCHED_VARIABLE_ISSUE hook.  */
+static rtx last_scheduled_insn;
+
 /* Save information from a "cmpxx" operation until the branch or scc is
    emitted.  */
 rtx s390_compare_op0, s390_compare_op1;
@@ -9799,9 +9802,12 @@
   if (!REG_P (*op0) || !REG_P (*op1))
     return false;
 
+  if (GET_MODE_CLASS (GET_MODE (*op0)) != MODE_INT)
+    return false;
+
   /* Swap the COMPARE arguments and its mask if there is a
      conflicting access in the previous insn.  */
-  prev_insn = PREV_INSN (insn);
+  prev_insn = prev_active_insn (insn);
   if (prev_insn != NULL_RTX && INSN_P (prev_insn)
       && reg_referenced_p (*op1, PATTERN (prev_insn)))
     s390_swap_cmp (cond, op0, op1, insn);
@@ -9812,7 +9818,7 @@
      the operands, or if swapping them would cause a conflict
      with the previous insn, issue a NOP after the COMPARE in
      order to separate the two instuctions.  */
-  next_insn = NEXT_INSN (insn);
+  next_insn = next_active_insn (insn);
   if (next_insn != NULL_RTX && INSN_P (next_insn)
       && s390_non_addr_reg_read_p (*op1, next_insn))
     {
@@ -9970,6 +9976,119 @@
     }
 }
 
+/* Return true if INSN is a fp load insn writing register REGNO.  */
+static inline bool
+s390_fpload_toreg (rtx insn, unsigned int regno)
+{
+  rtx set;
+  enum attr_type flag = s390_safe_attr_type (insn);
+
+  if (flag != TYPE_FLOADSF && flag != TYPE_FLOADDF)
+    return false;
+
+  set = single_set (insn);
+
+  if (set == NULL_RTX)
+    return false;
+
+  if (!REG_P (SET_DEST (set)) || !MEM_P (SET_SRC (set)))
+    return false;
+
+  if (REGNO (SET_DEST (set)) != regno)
+    return false;
+
+  return true;
+}
+
+/* This value describes the distance to be avoided between an
+   aritmetic fp instruction and an fp load writing the same register.
+   Z10_EARLYLOAD_DISTANCE - 1 as well as Z10_EARLYLOAD_DISTANCE + 1 is
+   fine but the exact value has to be avoided. Otherwise the FP
+   pipeline will throw an exception causing a major penalty.  */
+#define Z10_EARLYLOAD_DISTANCE 7
+
+/* Rearrange the ready list in order to avoid the situation described
+   for Z10_EARLYLOAD_DISTANCE.  A problematic load instruction is
+   moved to the very end of the ready list.  */
+static void
+s390_z10_prevent_earlyload_conflicts (rtx *ready, int *nready_p)
+{
+  unsigned int regno;
+  int nready = *nready_p;
+  rtx tmp;
+  int i;
+  rtx insn;
+  rtx set;
+  enum attr_type flag;
+  int distance;
+
+  /* Skip DISTANCE - 1 active insns.  */
+  for (insn = last_scheduled_insn, distance = Z10_EARLYLOAD_DISTANCE - 1;
+       distance > 0 && insn != NULL_RTX;
+       distance--, insn = prev_active_insn (insn))
+    if (CALL_P (insn) || JUMP_P (insn))
+      return;
+
+  if (insn == NULL_RTX)
+    return;
+
+  set = single_set (insn);
+
+  if (set == NULL_RTX || !REG_P (SET_DEST (set))
+      || GET_MODE_CLASS (GET_MODE (SET_DEST (set))) != MODE_FLOAT)
+    return;
+
+  flag = s390_safe_attr_type (insn);
+
+  if (flag == TYPE_FLOADSF || flag == TYPE_FLOADDF)
+    return;
+
+  regno = REGNO (SET_DEST (set));
+  i = nready - 1;
+
+  while (!s390_fpload_toreg (ready[i], regno) && i > 0)
+    i--;
+
+  if (!i)
+    return;
+
+  tmp = ready[i];
+  memmove (&ready[1], &ready[0], sizeof (rtx) * i);
+  ready[0] = tmp;
+}
+
+/* This function is called via hook TARGET_SCHED_REORDER before
+   issueing one insn from list READY which contains *NREADYP entries.
+   For target z10 it reorders load instructions to avoid early load
+   conflicts in the floating point pipeline  */
+static int
+s390_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,
+		    rtx *ready, int *nreadyp, int clock ATTRIBUTE_UNUSED)
+{
+  if (s390_tune == PROCESSOR_2097_Z10)
+    if (reload_completed && *nreadyp > 1)
+      s390_z10_prevent_earlyload_conflicts (ready, nreadyp);
+
+  return s390_issue_rate ();
+}
+
+/* This function is called via hook TARGET_SCHED_VARIABLE_ISSUE after
+   the scheduler has issued INSN.  It stores the last issued insn into
+   last_scheduled_insn in order to make it available for
+   s390_sched_reorder.  */
+static int
+s390_sched_variable_issue (FILE *file ATTRIBUTE_UNUSED,
+                           int verbose ATTRIBUTE_UNUSED,
+                         rtx insn, int more)
+{
+  last_scheduled_insn = insn;
+
+  if (GET_CODE (PATTERN (insn)) != USE
+      && GET_CODE (PATTERN (insn)) != CLOBBER)
+    return more - 1;
+  else
+    return more;
+}
 
 /* Initialize GCC target structure.  */
 
@@ -10024,6 +10143,11 @@
 #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
 #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD s390_first_cycle_multipass_dfa_lookahead
 
+#undef TARGET_SCHED_VARIABLE_ISSUE
+#define TARGET_SCHED_VARIABLE_ISSUE s390_sched_variable_issue
+#undef TARGET_SCHED_REORDER
+#define TARGET_SCHED_REORDER s390_sched_reorder
+
 #undef TARGET_CANNOT_COPY_INSN_P
 #define TARGET_CANNOT_COPY_INSN_P s390_cannot_copy_insn_p
 #undef TARGET_RTX_COSTS
diff -Naur gcc-4.4.2.orig/gcc/config/s390/s390.md gcc-4.4.2/gcc/config/s390/s390.md
--- gcc-4.4.2.orig/gcc/config/s390/s390.md	2009-10-09 11:49:22.000000000 -0400
+++ gcc-4.4.2/gcc/config/s390/s390.md	2009-12-09 07:21:01.556720000 -0500
@@ -7049,21 +7049,6 @@
    (set_attr "type"     "fsimp<mode>")])
 
 ;;
-;;- Copy sign instructions
-;;
-
-; cpsdr
-(define_insn "copysign<mode>3"
-  [(set (match_operand:FP 0 "register_operand" "=f")
-	(unspec:FP [(match_operand:FP 1 "register_operand" "<fT0>")
-		    (match_operand:FP 2 "register_operand" "f")]
-		    UNSPEC_COPYSIGN))]
-  "TARGET_DFP"
-  "cpsdr\t%0,%2,%1"
-  [(set_attr "op_type"  "RRF")
-   (set_attr "type"     "fsimp<mode>")])
-
-;;
 ;;- Square root instructions.
 ;;
 
diff -Naur gcc-4.4.2.orig/gcc/config/spu/constraints.md gcc-4.4.2/gcc/config/spu/constraints.md
--- gcc-4.4.2.orig/gcc/config/spu/constraints.md	2007-08-02 06:49:31.000000000 -0400
+++ gcc-4.4.2/gcc/config/spu/constraints.md	2009-12-04 14:52:42.853505000 -0500
@@ -16,8 +16,14 @@
 ;; <http://www.gnu.org/licenses/>.
 
 
-;; GCC standard constraints:  g, i, m, n, o, p, r, s, E-H, I-P, V, X
-;; unused for SPU:  E-H, L, Q, d, e, h, q, t-z
+;;       ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
+;; GCC:      ffffiiiiiiii     x x        x x   xxxx xx
+;; SPU:  xxxx    xxx xxxx xxxx x xxx xx x   xxx         xx
+;; FREE:     ffff   i    a          a  a  a        a  aa  aaa
+;; x - used
+;; a - available
+;; i - available for integer immediates
+;; f - available for floating point immediates
 
 ;; For most immediate constraints we have 3 variations to deal with the
 ;; fact const_int has no mode.  One variation treats const_int as 32 bit,
@@ -159,4 +165,15 @@
 		    && INTVAL (XEXP (op, 0)) >= 0
 		    && INTVAL (XEXP (op, 0)) <= 0x3ffff")))
 
+
+;; Floating-point constant constraints.
+
+(define_constraint "v"
+  "Floating point power of 2 with exponent in [0..127]"
+  (and (match_code "const_double,const_vector")
+       (match_test "exp2_immediate_p (op, VOIDmode, 0, 127)")))
 
+(define_constraint "w"
+  "Floating point power of 2 with exponent in [-126..0]"
+  (and (match_code "const_double,const_vector")
+       (match_test "exp2_immediate_p (op, VOIDmode, -126, 0)")))
diff -Naur gcc-4.4.2.orig/gcc/config/spu/predicates.md gcc-4.4.2/gcc/config/spu/predicates.md
--- gcc-4.4.2.orig/gcc/config/spu/predicates.md	2007-08-02 06:49:31.000000000 -0400
+++ gcc-4.4.2/gcc/config/spu/predicates.md	2009-12-04 14:52:42.853505000 -0500
@@ -39,14 +39,14 @@
        (ior (not (match_code "subreg"))
             (match_test "valid_subreg (op)"))))
 
-(define_predicate "spu_mem_operand"
-  (and (match_operand 0 "memory_operand")
-       (match_test "reload_in_progress || reload_completed || aligned_mem_p (op)")))
-
 (define_predicate "spu_mov_operand"
-  (ior (match_operand 0 "spu_mem_operand")
+  (ior (match_operand 0 "memory_operand")
        (match_operand 0 "spu_nonmem_operand")))
 
+(define_predicate "spu_dest_operand"
+  (ior (match_operand 0 "memory_operand")
+       (match_operand 0 "spu_reg_operand")))
+
 (define_predicate "call_operand"
   (and (match_code "mem")
        (match_test "(!TARGET_LARGE_MEM && satisfies_constraint_S (op))
@@ -104,3 +104,19 @@
        (ior (match_test "GET_MODE (XEXP (op, 0)) == HImode")
 	    (match_test "GET_MODE (XEXP (op, 0)) == SImode"))))
 
+(define_predicate "spu_inv_exp2_operand"
+  (and (match_code "const_double,const_vector")
+       (and (match_operand 0 "immediate_operand")
+	    (match_test "exp2_immediate_p (op, mode, -126, 0)"))))
+
+(define_predicate "spu_exp2_operand"
+  (and (match_code "const_double,const_vector")
+       (and (match_operand 0 "immediate_operand")
+	    (match_test "exp2_immediate_p (op, mode, 0, 127)"))))
+
+(define_predicate "shiftrt_operator"
+  (match_code "lshiftrt,ashiftrt"))
+
+(define_predicate "extend_operator"
+  (match_code "sign_extend,zero_extend"))
+
diff -Naur gcc-4.4.2.orig/gcc/config/spu/spu-builtins.def gcc-4.4.2/gcc/config/spu/spu-builtins.def
--- gcc-4.4.2.orig/gcc/config/spu/spu-builtins.def	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/config/spu/spu-builtins.def	2009-12-04 14:52:42.853505000 -0500
@@ -235,8 +235,8 @@
 
 /* definitions to support generic builtin functions: */
 
-DEF_BUILTIN (SPU_CONVTS,     CODE_FOR_spu_cflts,      "spu_convts",     B_INSN,     _A3(SPU_BTI_V4SI,     SPU_BTI_V4SF,   SPU_BTI_U7))
-DEF_BUILTIN (SPU_CONVTU,     CODE_FOR_spu_cfltu,      "spu_convtu",     B_INSN,     _A3(SPU_BTI_UV4SI,    SPU_BTI_V4SF,   SPU_BTI_U7))
+DEF_BUILTIN (SPU_CONVTS,     CODE_FOR_spu_cflts,      "spu_convts",     B_INSN,     _A3(SPU_BTI_V4SI,     SPU_BTI_V4SF,   SPU_BTI_INTSI))
+DEF_BUILTIN (SPU_CONVTU,     CODE_FOR_spu_cfltu,      "spu_convtu",     B_INSN,     _A3(SPU_BTI_UV4SI,    SPU_BTI_V4SF,   SPU_BTI_INTSI))
 DEF_BUILTIN (SPU_ROUNDTF,    CODE_FOR_spu_frds,       "spu_roundtf",    B_INSN,     _A2(SPU_BTI_V4SF,     SPU_BTI_V2DF))
 DEF_BUILTIN (SPU_MULH,       CODE_FOR_spu_mpyh,       "spu_mulh",       B_INSN,     _A3(SPU_BTI_V4SI,     SPU_BTI_V8HI,   SPU_BTI_V8HI))
 DEF_BUILTIN (SPU_MULSR,      CODE_FOR_spu_mpys,       "spu_mulsr",      B_INSN,     _A3(SPU_BTI_V4SI,     SPU_BTI_V8HI,   SPU_BTI_V8HI))
@@ -257,8 +257,8 @@
 /* definitions to support overloaded generic builtin functions:  */
 
 DEF_BUILTIN (SPU_CONVTF,           CODE_FOR_nothing,       "spu_convtf",           B_OVERLOAD, _A1(SPU_BTI_VOID))
-DEF_BUILTIN (SPU_CONVTF_0,         CODE_FOR_spu_cuflt,     "spu_convtf_0",         B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_UV4SI,  SPU_BTI_U7))
-DEF_BUILTIN (SPU_CONVTF_1,         CODE_FOR_spu_csflt,     "spu_convtf_1",         B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_V4SI,   SPU_BTI_U7))
+DEF_BUILTIN (SPU_CONVTF_0,         CODE_FOR_spu_cuflt,     "spu_convtf_0",         B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_UV4SI,  SPU_BTI_UINTSI))
+DEF_BUILTIN (SPU_CONVTF_1,         CODE_FOR_spu_csflt,     "spu_convtf_1",         B_INTERNAL, _A3(SPU_BTI_V4SF,   SPU_BTI_V4SI,   SPU_BTI_UINTSI))
 DEF_BUILTIN (SPU_EXTEND,           CODE_FOR_nothing,       "spu_extend",           B_OVERLOAD, _A1(SPU_BTI_VOID))
 DEF_BUILTIN (SPU_EXTEND_0,         CODE_FOR_spu_xsbh,      "spu_extend_0",         B_INTERNAL, _A2(SPU_BTI_V8HI,   SPU_BTI_V16QI))
 DEF_BUILTIN (SPU_EXTEND_1,         CODE_FOR_spu_xshw,      "spu_extend_1",         B_INTERNAL, _A2(SPU_BTI_V4SI,   SPU_BTI_V8HI))
diff -Naur gcc-4.4.2.orig/gcc/config/spu/spu-builtins.md gcc-4.4.2/gcc/config/spu/spu-builtins.md
--- gcc-4.4.2.orig/gcc/config/spu/spu-builtins.md	2007-08-02 06:49:31.000000000 -0400
+++ gcc-4.4.2/gcc/config/spu/spu-builtins.md	2009-12-04 14:52:42.853505000 -0500
@@ -527,37 +527,119 @@
   [(set_attr "type" "br")])
 
 ;; float convert
-(define_insn "spu_csflt"
-  [(set (match_operand:V4SF 0 "spu_reg_operand" "=r")
-	(unspec:V4SF [(match_operand:V4SI 1 "spu_reg_operand" "r")
-		      (match_operand:SI 2 "immediate_operand" "K")] UNSPEC_CSFLT ))]
-  ""
-  "csflt\t%0,%1,%2"
-  [(set_attr "type" "fp7")])
-
-(define_insn "spu_cflts"
-  [(set (match_operand:V4SI 0 "spu_reg_operand" "=r")
-	(unspec:V4SI [(match_operand:V4SF 1 "spu_reg_operand" "r")
-                      (match_operand:SI 2 "immediate_operand" "J")] UNSPEC_CFLTS ))]
-  ""
-  "cflts\t%0,%1,%2"
-  [(set_attr "type" "fp7")])
+(define_expand "spu_csflt"
+  [(set (match_operand:V4SF 0 "spu_reg_operand")
+	(unspec:V4SF [(match_operand:V4SI 1 "spu_reg_operand")
+		      (match_operand:SI 2 "spu_nonmem_operand")] 0 ))]
+  ""
+{
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))
+    {
+      error ("spu_convtf expects an integer literal in the range [0, 127].");
+      operands[2] = force_reg (SImode, operands[2]);
+    }
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      rtx exp2;
+      rtx cnv = gen_reg_rtx (V4SFmode);
+      rtx scale = gen_reg_rtx (SImode);
+      rtx op2 = force_reg (SImode, operands[2]);
+      rtx m1 = spu_gen_exp2 (V4SFmode, GEN_INT (-1));
+      emit_insn (gen_subsi3 (scale, const1_rtx, op2));
+      exp2 = spu_gen_exp2 (V4SFmode, scale);
+      emit_insn (gen_floatv4siv4sf2_mul (cnv, operands[1], m1));
+      emit_insn (gen_mulv4sf3 (operands[0], cnv, exp2));
+    }
+  else
+    {
+      rtx exp2 = spu_gen_exp2 (V4SFmode, operands[2]);
+      emit_insn (gen_floatv4siv4sf2_div (operands[0], operands[1], exp2));
+    }
+  DONE;
+})
+
+(define_expand "spu_cflts"
+  [(set (match_operand:V4SI 0 "spu_reg_operand")
+	(unspec:V4SI [(match_operand:V4SF 1 "spu_reg_operand")
+                      (match_operand:SI 2 "spu_nonmem_operand")] 0 ))]
+  ""
+{
+  rtx exp2;
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))
+    {
+      error ("spu_convts expects an integer literal in the range [0, 127].");
+      operands[2] = force_reg (SImode, operands[2]);
+    }
+  exp2 = spu_gen_exp2 (V4SFmode, operands[2]);
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      rtx mul = gen_reg_rtx (V4SFmode);
+      emit_insn (gen_mulv4sf3 (mul, operands[1], exp2));
+      emit_insn (gen_fix_truncv4sfv4si2 (operands[0], mul));
+    }
+  else
+    emit_insn (gen_fix_truncv4sfv4si2_mul (operands[0], operands[1], exp2));
+  DONE;
+})
 
-(define_insn "spu_cuflt"
+(define_expand "spu_cuflt"
   [(set (match_operand:V4SF 0 "spu_reg_operand" "=r")
-	(unspec:V4SF [(match_operand:V4SI 1 "spu_reg_operand" "r")
-		      (match_operand:SI 2 "immediate_operand" "K")] UNSPEC_CUFLT ))]
-  ""
-  "cuflt\t%0,%1,%2"
-  [(set_attr "type" "fp7")])
-
-(define_insn "spu_cfltu"
-  [(set (match_operand:V4SI 0 "spu_reg_operand" "=r")
-	(unspec:V4SI [(match_operand:V4SF 1 "spu_reg_operand" "r")
-		      (match_operand:SI 2 "immediate_operand" "J")] UNSPEC_CFLTU ))]
+	(unspec:V4SF [(match_operand:V4SI 1 "spu_reg_operand")
+		      (match_operand:SI 2 "spu_nonmem_operand")] 0 ))]
   ""
-  "cfltu\t%0,%1,%2"
-  [(set_attr "type" "fp7")])
+{
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))
+    {
+      error ("spu_convtf expects an integer literal in the range [0, 127].");
+      operands[2] = force_reg (SImode, operands[2]);
+    }
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      rtx exp2;
+      rtx cnv = gen_reg_rtx (V4SFmode);
+      rtx scale = gen_reg_rtx (SImode);
+      rtx op2 = force_reg (SImode, operands[2]);
+      rtx m1 = spu_gen_exp2 (V4SFmode, GEN_INT (-1));
+      emit_insn (gen_subsi3 (scale, const1_rtx, op2));
+      exp2 = spu_gen_exp2 (V4SFmode, scale);
+      emit_insn (gen_floatunsv4siv4sf2_mul (cnv, operands[1], m1));
+      emit_insn (gen_mulv4sf3 (operands[0], cnv, exp2));
+    }
+  else
+    {
+      rtx exp2 = spu_gen_exp2 (V4SFmode, operands[2]);
+      emit_insn (gen_floatunsv4siv4sf2_div (operands[0], operands[1], exp2));
+    }
+  DONE;
+})
+
+(define_expand "spu_cfltu"
+  [(set (match_operand:V4SI 0 "spu_reg_operand")
+	(unspec:V4SI [(match_operand:V4SF 1 "spu_reg_operand")
+		      (match_operand:SI 2 "spu_nonmem_operand")] 0 ))]
+  ""
+{
+  rtx exp2;
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) > 127))
+    {
+      error ("spu_convtu expects an integer literal in the range [0, 127].");
+      operands[2] = force_reg (SImode, operands[2]);
+    }
+  exp2 = spu_gen_exp2 (V4SFmode, operands[2]);
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      rtx mul = gen_reg_rtx (V4SFmode);
+      emit_insn (gen_mulv4sf3 (mul, operands[1], exp2));
+      emit_insn (gen_fixuns_truncv4sfv4si2 (operands[0], mul));
+    }
+  else
+    emit_insn (gen_fixuns_truncv4sfv4si2_mul (operands[0], operands[1], exp2));
+  DONE;
+})
 
 (define_expand "spu_frds"
    [(set (match_operand:V4SF 0 "spu_reg_operand" "")
diff -Naur gcc-4.4.2.orig/gcc/config/spu/spu.c gcc-4.4.2/gcc/config/spu/spu.c
--- gcc-4.4.2.orig/gcc/config/spu/spu.c	2009-04-23 18:50:16.000000000 -0400
+++ gcc-4.4.2/gcc/config/spu/spu.c	2009-12-04 14:52:42.853505000 -0500
@@ -189,9 +189,9 @@
 static void spu_va_start (tree, rtx);
 static tree spu_gimplify_va_arg_expr (tree valist, tree type,
 				      gimple_seq * pre_p, gimple_seq * post_p);
-static int regno_aligned_for_load (int regno);
 static int store_with_one_insn_p (rtx mem);
 static int mem_is_padded_component_ref (rtx x);
+static int reg_aligned_for_addr (rtx x);
 static bool spu_assemble_integer (rtx x, unsigned int size, int aligned_p);
 static void spu_asm_globalize_label (FILE * file, const char *name);
 static unsigned char spu_rtx_costs (rtx x, int code, int outer_code,
@@ -210,6 +210,7 @@
 static int spu_sms_res_mii (struct ddg *g);
 static void asm_file_start (void);
 static unsigned int spu_section_type_flags (tree, const char *, int);
+static rtx spu_expand_load (rtx, rtx, rtx, int);
 
 extern const char *reg_names[];
 rtx spu_compare_op0, spu_compare_op1;
@@ -576,66 +577,85 @@
 void
 spu_expand_extv (rtx ops[], int unsignedp)
 {
+  rtx dst = ops[0], src = ops[1];
   HOST_WIDE_INT width = INTVAL (ops[2]);
   HOST_WIDE_INT start = INTVAL (ops[3]);
-  HOST_WIDE_INT src_size, dst_size;
-  enum machine_mode src_mode, dst_mode;
-  rtx dst = ops[0], src = ops[1];
-  rtx s;
+  HOST_WIDE_INT align_mask;
+  rtx s0, s1, mask, r0;
 
-  dst = adjust_operand (ops[0], 0);
-  dst_mode = GET_MODE (dst);
-  dst_size = GET_MODE_BITSIZE (GET_MODE (dst));
+  gcc_assert (REG_P (dst) && GET_MODE (dst) == TImode);
 
-  src = adjust_operand (src, &start);
-  src_mode = GET_MODE (src);
-  src_size = GET_MODE_BITSIZE (GET_MODE (src));
-
-  if (start > 0)
+  if (MEM_P (src))
     {
-      s = gen_reg_rtx (src_mode);
-      switch (src_mode)
+      /* First, determine if we need 1 TImode load or 2.  We need only 1
+         if the bits being extracted do not cross the alignment boundary
+         as determined by the MEM and its address. */
+
+      align_mask = -MEM_ALIGN (src);
+      if ((start & align_mask) == ((start + width - 1) & align_mask))
+	{
+	  /* Alignment is sufficient for 1 load. */
+	  s0 = gen_reg_rtx (TImode);
+	  r0 = spu_expand_load (s0, 0, src, start / 8);
+	  start &= 7;
+	  if (r0)
+	    emit_insn (gen_rotqby_ti (s0, s0, r0));
+	}
+      else
 	{
-	case SImode:
-	  emit_insn (gen_ashlsi3 (s, src, GEN_INT (start)));
-	  break;
-	case DImode:
-	  emit_insn (gen_ashldi3 (s, src, GEN_INT (start)));
-	  break;
-	case TImode:
-	  emit_insn (gen_ashlti3 (s, src, GEN_INT (start)));
-	  break;
-	default:
-	  abort ();
+	  /* Need 2 loads. */
+	  s0 = gen_reg_rtx (TImode);
+	  s1 = gen_reg_rtx (TImode);
+	  r0 = spu_expand_load (s0, s1, src, start / 8);
+	  start &= 7;
+
+	  gcc_assert (start + width <= 128);
+	  if (r0)
+	    {
+	      rtx r1 = gen_reg_rtx (SImode);
+	      mask = gen_reg_rtx (TImode);
+	      emit_move_insn (mask, GEN_INT (-1));
+	      emit_insn (gen_rotqby_ti (s0, s0, r0));
+	      emit_insn (gen_rotqby_ti (s1, s1, r0));
+	      if (GET_CODE (r0) == CONST_INT)
+		r1 = GEN_INT (INTVAL (r0) & 15);
+	      else
+		emit_insn (gen_andsi3 (r1, r0, GEN_INT (15)));
+	      emit_insn (gen_shlqby_ti (mask, mask, r1));
+	      emit_insn (gen_selb (s0, s1, s0, mask));
+	    }
 	}
-      src = s;
+
+    }
+  else if (GET_CODE (src) == SUBREG)
+    {
+      rtx r = SUBREG_REG (src);
+      gcc_assert (REG_P (r) && SCALAR_INT_MODE_P (GET_MODE (r)));
+      s0 = gen_reg_rtx (TImode);
+      if (GET_MODE_SIZE (GET_MODE (r)) < GET_MODE_SIZE (TImode))
+	emit_insn (gen_rtx_SET (VOIDmode, s0, gen_rtx_ZERO_EXTEND (TImode, r)));
+      else
+	emit_move_insn (s0, src);
     }
+  else
+    {
+      gcc_assert (REG_P (src) && GET_MODE (src) == TImode);
+      s0 = gen_reg_rtx (TImode);
+      emit_move_insn (s0, src);
+    }
+
+  /* Now s0 is TImode and contains the bits to extract at start. */
 
-  if (width < src_size)
+  if (start)
+    emit_insn (gen_rotlti3 (s0, s0, GEN_INT (start)));
+
+  if (128 - width)
     {
-      rtx pat;
-      int icode;
-      switch (src_mode)
-	{
-	case SImode:
-	  icode = unsignedp ? CODE_FOR_lshrsi3 : CODE_FOR_ashrsi3;
-	  break;
-	case DImode:
-	  icode = unsignedp ? CODE_FOR_lshrdi3 : CODE_FOR_ashrdi3;
-	  break;
-	case TImode:
-	  icode = unsignedp ? CODE_FOR_lshrti3 : CODE_FOR_ashrti3;
-	  break;
-	default:
-	  abort ();
-	}
-      s = gen_reg_rtx (src_mode);
-      pat = GEN_FCN (icode) (s, src, GEN_INT (src_size - width));
-      emit_insn (pat);
-      src = s;
+      tree c = build_int_cst (NULL_TREE, 128 - width);
+      s0 = expand_shift (RSHIFT_EXPR, TImode, s0, c, s0, unsignedp);
     }
 
-  convert_move (dst, src, unsignedp);
+  emit_move_insn (dst, s0);
 }
 
 void
@@ -728,38 +748,41 @@
     }
   if (GET_CODE (ops[0]) == MEM)
     {
-      rtx aligned = gen_reg_rtx (SImode);
       rtx low = gen_reg_rtx (SImode);
-      rtx addr = gen_reg_rtx (SImode);
       rtx rotl = gen_reg_rtx (SImode);
       rtx mask0 = gen_reg_rtx (TImode);
+      rtx addr;
+      rtx addr0;
+      rtx addr1;
       rtx mem;
 
-      emit_move_insn (addr, XEXP (ops[0], 0));
-      emit_insn (gen_andsi3 (aligned, addr, GEN_INT (-16)));
+      addr = force_reg (Pmode, XEXP (ops[0], 0));
+      addr0 = gen_rtx_AND (Pmode, addr, GEN_INT (-16));
       emit_insn (gen_andsi3 (low, addr, GEN_INT (15)));
       emit_insn (gen_negsi2 (rotl, low));
       emit_insn (gen_rotqby_ti (shift_reg, shift_reg, rotl));
       emit_insn (gen_rotqmby_ti (mask0, mask, rotl));
-      mem = change_address (ops[0], TImode, aligned);
+      mem = change_address (ops[0], TImode, addr0);
       set_mem_alias_set (mem, 0);
       emit_move_insn (dst, mem);
       emit_insn (gen_selb (dst, dst, shift_reg, mask0));
-      emit_move_insn (mem, dst);
       if (start + width > MEM_ALIGN (ops[0]))
 	{
 	  rtx shl = gen_reg_rtx (SImode);
 	  rtx mask1 = gen_reg_rtx (TImode);
 	  rtx dst1 = gen_reg_rtx (TImode);
 	  rtx mem1;
+	  addr1 = plus_constant (addr, 16);
+	  addr1 = gen_rtx_AND (Pmode, addr1, GEN_INT (-16));
 	  emit_insn (gen_subsi3 (shl, GEN_INT (16), low));
 	  emit_insn (gen_shlqby_ti (mask1, mask, shl));
-	  mem1 = adjust_address (mem, TImode, 16);
+	  mem1 = change_address (ops[0], TImode, addr1);
 	  set_mem_alias_set (mem1, 0);
 	  emit_move_insn (dst1, mem1);
 	  emit_insn (gen_selb (dst1, dst1, shift_reg, mask1));
 	  emit_move_insn (mem1, dst1);
 	}
+      emit_move_insn (mem, dst);
     }
   else
     emit_insn (gen_selb (dst, copy_rtx (dst), shift_reg, mask));
@@ -1585,6 +1608,13 @@
       output_addr_const (file, GEN_INT (val));
       return;
 
+    case 'v':
+    case 'w':
+      constant_to_array (mode, x, arr);
+      val = (((arr[0] << 1) + (arr[1] >> 7)) & 0xff) - 127;
+      output_addr_const (file, GEN_INT (code == 'w' ? -val : val));
+      return;
+
     case 0:
       if (xcode == REG)
 	fprintf (file, "%s", reg_names[REGNO (x)]);
@@ -1597,7 +1627,7 @@
       return;
 
       /* unused letters
-	              o qr  uvw yz
+	              o qr  u   yz
 	AB            OPQR  UVWXYZ */
     default:
       output_operand_lossage ("invalid %%xn code");
@@ -1618,6 +1648,8 @@
   rtx pic_reg = pic_offset_table_rtx;
   if (!reload_completed && !reload_in_progress)
     abort ();
+  if (current_function_is_leaf && !df_regs_ever_live_p (LAST_ARG_REGNUM))
+    pic_reg = gen_rtx_REG (SImode, LAST_ARG_REGNUM);
   return pic_reg;
 }
 
@@ -2765,6 +2797,25 @@
 
   pad_bb ();
 
+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+    if (NONJUMP_INSN_P (insn) && INSN_CODE (insn) == CODE_FOR_hbr)
+      {
+	/* Adjust the LABEL_REF in a hint when we have inserted a nop
+	   between its branch label and the branch .  We don't move the
+	   label because GCC expects it at the beginning of the block. */
+	rtx unspec = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));
+	rtx label_ref = XVECEXP (unspec, 0, 0);
+	rtx label = XEXP (label_ref, 0);
+	rtx branch;
+	int offset = 0;
+	for (branch = NEXT_INSN (label);
+	     !JUMP_P (branch) && !CALL_P (branch);
+	     branch = NEXT_INSN (branch))
+	  if (NONJUMP_INSN_P (branch))
+	    offset += get_attr_length (branch);
+	if (offset > 0)
+	  XVECEXP (unspec, 0, 0) = plus_constant (label_ref, offset);
+      }
 
   if (spu_flag_var_tracking)
     {
@@ -2972,7 +3023,7 @@
       insn = ready[i];
       if (INSN_CODE (insn) == -1
 	  || INSN_CODE (insn) == CODE_FOR_blockage
-	  || INSN_CODE (insn) == CODE_FOR__spu_convert)
+	  || (INSN_P (insn) && get_attr_length (insn) == 0))
 	{
 	  ready[i] = ready[nready - 1];
 	  ready[nready - 1] = insn;
@@ -3103,8 +3154,8 @@
       || INSN_CODE (dep_insn) == CODE_FOR_blockage)
     return 0;
 
-  if (INSN_CODE (insn) == CODE_FOR__spu_convert
-      || INSN_CODE (dep_insn) == CODE_FOR__spu_convert)
+  if ((INSN_P (insn) && get_attr_length (insn) == 0)
+      || (INSN_P (dep_insn) && get_attr_length (dep_insn) == 0))
     return 0;
 
   /* Make sure hbrps are spread out. */
@@ -3503,6 +3554,58 @@
   return val >= low && val <= high;
 }
 
+/* TRUE when op is an immediate and an exact power of 2, and given that
+   OP is 2^scale, scale >= LOW && scale <= HIGH.  When OP is a vector,
+   all entries must be the same. */
+bool
+exp2_immediate_p (rtx op, enum machine_mode mode, int low, int high)
+{
+  enum machine_mode int_mode;
+  HOST_WIDE_INT val;
+  unsigned char arr[16];
+  int bytes, i, j;
+
+  gcc_assert (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE
+	      || GET_CODE (op) == CONST_VECTOR);
+
+  if (GET_CODE (op) == CONST_VECTOR
+      && !const_vector_immediate_p (op))
+    return 0;
+
+  if (GET_MODE (op) != VOIDmode)
+    mode = GET_MODE (op);
+
+  constant_to_array (mode, op, arr);
+
+  if (VECTOR_MODE_P (mode))
+    mode = GET_MODE_INNER (mode);
+
+  bytes = GET_MODE_SIZE (mode);
+  int_mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);
+
+  /* Check that bytes are repeated. */
+  for (i = bytes; i < 16; i += bytes)
+    for (j = 0; j < bytes; j++)
+      if (arr[j] != arr[i + j])
+	return 0;
+
+  val = arr[0];
+  for (j = 1; j < bytes; j++)
+    val = (val << 8) | arr[j];
+
+  val = trunc_int_for_mode (val, int_mode);
+
+  /* Currently, we only handle SFmode */
+  gcc_assert (mode == SFmode);
+  if (mode == SFmode)
+    {
+      int exp = (val >> 23) - 127;
+      return val > 0 && (val & 0x007fffff) == 0
+	     &&  exp >= low && exp <= high;
+    }
+  return FALSE;
+}
+
 /* We accept:
    - any 32-bit constant (SImode, SFmode)
    - any constant that can be generated with fsmbi (any mode)
@@ -3533,44 +3636,36 @@
 /* Valid address are:
    - symbol_ref, label_ref, const
    - reg
-   - reg + const, where either reg or const is 16 byte aligned
+   - reg + const_int, where const_int is 16 byte aligned
    - reg + reg, alignment doesn't matter
   The alignment matters in the reg+const case because lqd and stqd
-  ignore the 4 least significant bits of the const.  (TODO: It might be
-  preferable to allow any alignment and fix it up when splitting.) */
+  ignore the 4 least significant bits of the const.  We only care about
+  16 byte modes because the expand phase will change all smaller MEM
+  references to TImode.  */
 int
 spu_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,
 			rtx x, int reg_ok_strict)
 {
-  if (mode == TImode && GET_CODE (x) == AND
+  int aligned = GET_MODE_SIZE (mode) >= 16;
+  if (aligned
+      && GET_CODE (x) == AND
       && GET_CODE (XEXP (x, 1)) == CONST_INT
-      && INTVAL (XEXP (x, 1)) == (HOST_WIDE_INT) -16)
+      && INTVAL (XEXP (x, 1)) == (HOST_WIDE_INT) - 16)
     x = XEXP (x, 0);
   switch (GET_CODE (x))
     {
-    case SYMBOL_REF:
     case LABEL_REF:
-      return !TARGET_LARGE_MEM;
-
+    case SYMBOL_REF:
     case CONST:
-      if (!TARGET_LARGE_MEM && GET_CODE (XEXP (x, 0)) == PLUS)
-	{
-	  rtx sym = XEXP (XEXP (x, 0), 0);
-	  rtx cst = XEXP (XEXP (x, 0), 1);
-
-	  /* Accept any symbol_ref + constant, assuming it does not
-	     wrap around the local store addressability limit.  */
-	  if (GET_CODE (sym) == SYMBOL_REF && GET_CODE (cst) == CONST_INT)
-	    return 1;
-	}
-      return 0;
+      return !TARGET_LARGE_MEM;
 
     case CONST_INT:
       return INTVAL (x) >= 0 && INTVAL (x) <= 0x3ffff;
 
     case SUBREG:
       x = XEXP (x, 0);
-      gcc_assert (GET_CODE (x) == REG);
+      if (REG_P (x))
+	return 0;
 
     case REG:
       return INT_REG_OK_FOR_BASE_P (x, reg_ok_strict);
@@ -3584,29 +3679,25 @@
 	  op0 = XEXP (op0, 0);
 	if (GET_CODE (op1) == SUBREG)
 	  op1 = XEXP (op1, 0);
-	/* We can't just accept any aligned register because CSE can
-	   change it to a register that is not marked aligned and then
-	   recog will fail.   So we only accept frame registers because
-	   they will only be changed to other frame registers. */
 	if (GET_CODE (op0) == REG
 	    && INT_REG_OK_FOR_BASE_P (op0, reg_ok_strict)
 	    && GET_CODE (op1) == CONST_INT
 	    && INTVAL (op1) >= -0x2000
 	    && INTVAL (op1) <= 0x1fff
-	    && (regno_aligned_for_load (REGNO (op0)) || (INTVAL (op1) & 15) == 0))
-	  return 1;
+	    && (!aligned || (INTVAL (op1) & 15) == 0))
+	  return TRUE;
 	if (GET_CODE (op0) == REG
 	    && INT_REG_OK_FOR_BASE_P (op0, reg_ok_strict)
 	    && GET_CODE (op1) == REG
 	    && INT_REG_OK_FOR_INDEX_P (op1, reg_ok_strict))
-	  return 1;
+	  return TRUE;
       }
       break;
 
     default:
       break;
     }
-  return 0;
+  return FALSE;
 }
 
 /* When the address is reg + const_int, force the const_int into a
@@ -4061,60 +4152,14 @@
     }
 }
 
-/* This is called to decide when we can simplify a load instruction.  We
-   must only return true for registers which we know will always be
-   aligned.  Taking into account that CSE might replace this reg with
-   another one that has not been marked aligned.  
-   So this is really only true for frame, stack and virtual registers,
-   which we know are always aligned and should not be adversely effected
-   by CSE.  */
+/* This is called any time we inspect the alignment of a register for
+   addresses.  */
 static int
-regno_aligned_for_load (int regno)
+reg_aligned_for_addr (rtx x)
 {
-  return regno == FRAME_POINTER_REGNUM
-    || (frame_pointer_needed && regno == HARD_FRAME_POINTER_REGNUM)
-    || regno == ARG_POINTER_REGNUM
-    || regno == STACK_POINTER_REGNUM
-    || (regno >= FIRST_VIRTUAL_REGISTER 
-	&& regno <= LAST_VIRTUAL_REGISTER);
-}
-
-/* Return TRUE when mem is known to be 16-byte aligned. */
-int
-aligned_mem_p (rtx mem)
-{
-  if (MEM_ALIGN (mem) >= 128)
-    return 1;
-  if (GET_MODE_SIZE (GET_MODE (mem)) >= 16)
-    return 1;
-  if (GET_CODE (XEXP (mem, 0)) == PLUS)
-    {
-      rtx p0 = XEXP (XEXP (mem, 0), 0);
-      rtx p1 = XEXP (XEXP (mem, 0), 1);
-      if (regno_aligned_for_load (REGNO (p0)))
-	{
-	  if (GET_CODE (p1) == REG && regno_aligned_for_load (REGNO (p1)))
-	    return 1;
-	  if (GET_CODE (p1) == CONST_INT && (INTVAL (p1) & 15) == 0)
-	    return 1;
-	}
-    }
-  else if (GET_CODE (XEXP (mem, 0)) == REG)
-    {
-      if (regno_aligned_for_load (REGNO (XEXP (mem, 0))))
-	return 1;
-    }
-  else if (ALIGNED_SYMBOL_REF_P (XEXP (mem, 0)))
-    return 1;
-  else if (GET_CODE (XEXP (mem, 0)) == CONST)
-    {
-      rtx p0 = XEXP (XEXP (XEXP (mem, 0), 0), 0);
-      rtx p1 = XEXP (XEXP (XEXP (mem, 0), 0), 1);
-      if (GET_CODE (p0) == SYMBOL_REF
-	  && GET_CODE (p1) == CONST_INT && (INTVAL (p1) & 15) == 0)
-	return 1;
-    }
-  return 0;
+  int regno =
+    REGNO (x) < FIRST_PSEUDO_REGISTER ? ORIGINAL_REGNO (x) : REGNO (x);
+  return REGNO_POINTER_ALIGN (regno) >= 128;
 }
 
 /* Encode symbol attributes (local vs. global, tls model) of a SYMBOL_REF
@@ -4143,9 +4188,12 @@
 static int
 store_with_one_insn_p (rtx mem)
 {
+  enum machine_mode mode = GET_MODE (mem);
   rtx addr = XEXP (mem, 0);
-  if (GET_MODE (mem) == BLKmode)
+  if (mode == BLKmode)
     return 0;
+  if (GET_MODE_SIZE (mode) >= 16)
+    return 1;
   /* Only static objects. */
   if (GET_CODE (addr) == SYMBOL_REF)
     {
@@ -4169,6 +4217,22 @@
   return 0;
 }
 
+/* Return 1 when the address is not valid for a simple load and store as
+   required by the '_mov*' patterns.   We could make this less strict
+   for loads, but we prefer mem's to look the same so they are more
+   likely to be merged.  */
+static int
+address_needs_split (rtx mem)
+{
+  if (GET_MODE_SIZE (GET_MODE (mem)) < 16
+      && (GET_MODE_SIZE (GET_MODE (mem)) < 4
+	  || !(store_with_one_insn_p (mem)
+	       || mem_is_padded_component_ref (mem))))
+    return 1;
+
+  return 0;
+}
+
 int
 spu_expand_mov (rtx * ops, enum machine_mode mode)
 {
@@ -4213,54 +4277,63 @@
 	return spu_split_immediate (ops);
       return 0;
     }
-  else
+
+  /* Catch the SImode immediates greater than 0x7fffffff, and sign
+     extend them. */
+  if (GET_CODE (ops[1]) == CONST_INT)
     {
-      if (GET_CODE (ops[0]) == MEM)
+      HOST_WIDE_INT val = trunc_int_for_mode (INTVAL (ops[1]), mode);
+      if (val != INTVAL (ops[1]))
 	{
-	  if (!spu_valid_move (ops))
-	    {
-	      emit_insn (gen_store (ops[0], ops[1], gen_reg_rtx (TImode),
-				    gen_reg_rtx (TImode)));
-	      return 1;
-	    }
-	}
-      else if (GET_CODE (ops[1]) == MEM)
-	{
-	  if (!spu_valid_move (ops))
-	    {
-	      emit_insn (gen_load
-			 (ops[0], ops[1], gen_reg_rtx (TImode),
-			  gen_reg_rtx (SImode)));
-	      return 1;
-	    }
-	}
-      /* Catch the SImode immediates greater than 0x7fffffff, and sign
-         extend them. */
-      if (GET_CODE (ops[1]) == CONST_INT)
-	{
-	  HOST_WIDE_INT val = trunc_int_for_mode (INTVAL (ops[1]), mode);
-	  if (val != INTVAL (ops[1]))
-	    {
-	      emit_move_insn (ops[0], GEN_INT (val));
-	      return 1;
-	    }
+	  emit_move_insn (ops[0], GEN_INT (val));
+	  return 1;
 	}
     }
+  if (MEM_P (ops[0]))
+    return spu_split_store (ops);
+  if (MEM_P (ops[1]))
+    return spu_split_load (ops);
+
   return 0;
 }
 
-void
-spu_split_load (rtx * ops)
+static void
+spu_convert_move (rtx dst, rtx src)
 {
-  enum machine_mode mode = GET_MODE (ops[0]);
-  rtx addr, load, rot, mem, p0, p1;
-  int rot_amt;
+  enum machine_mode mode = GET_MODE (dst);
+  enum machine_mode int_mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);
+  rtx reg;
+  gcc_assert (GET_MODE (src) == TImode);
+  reg = int_mode != mode ? gen_reg_rtx (int_mode) : dst;
+  emit_insn (gen_rtx_SET (VOIDmode, reg,
+	       gen_rtx_TRUNCATE (int_mode,
+		 gen_rtx_LSHIFTRT (TImode, src,
+		   GEN_INT (int_mode == DImode ? 64 : 96)))));
+  if (int_mode != mode)
+    {
+      reg = simplify_gen_subreg (mode, reg, int_mode, 0);
+      emit_move_insn (dst, reg);
+    }
+}
 
-  addr = XEXP (ops[1], 0);
+/* Load TImode values into DST0 and DST1 (when it is non-NULL) using
+   the address from SRC and SRC+16.  Return a REG or CONST_INT that
+   specifies how many bytes to rotate the loaded registers, plus any
+   extra from EXTRA_ROTQBY.  The address and rotate amounts are
+   normalized to improve merging of loads and rotate computations. */
+static rtx
+spu_expand_load (rtx dst0, rtx dst1, rtx src, int extra_rotby)
+{
+  rtx addr = XEXP (src, 0);
+  rtx p0, p1, rot, addr0, addr1;
+  int rot_amt;
 
   rot = 0;
   rot_amt = 0;
-  if (GET_CODE (addr) == PLUS)
+
+  if (MEM_ALIGN (src) >= 128)
+    /* Address is already aligned; simply perform a TImode load.  */ ;
+  else if (GET_CODE (addr) == PLUS)
     {
       /* 8 cases:
          aligned reg   + aligned reg     => lqx
@@ -4274,12 +4347,34 @@
        */
       p0 = XEXP (addr, 0);
       p1 = XEXP (addr, 1);
-      if (REG_P (p0) && !regno_aligned_for_load (REGNO (p0)))
+      if (!reg_aligned_for_addr (p0))
 	{
-	  if (REG_P (p1) && !regno_aligned_for_load (REGNO (p1)))
+	  if (REG_P (p1) && !reg_aligned_for_addr (p1))
+	    {
+	      rot = gen_reg_rtx (SImode);
+	      emit_insn (gen_addsi3 (rot, p0, p1));
+	    }
+	  else if (GET_CODE (p1) == CONST_INT && (INTVAL (p1) & 15))
 	    {
-	      emit_insn (gen_addsi3 (ops[3], p0, p1));
-	      rot = ops[3];
+	      if (INTVAL (p1) > 0
+		  && REG_POINTER (p0)
+		  && INTVAL (p1) * BITS_PER_UNIT
+		     < REGNO_POINTER_ALIGN (REGNO (p0)))
+		{
+		  rot = gen_reg_rtx (SImode);
+		  emit_insn (gen_addsi3 (rot, p0, p1));
+		  addr = p0;
+		}
+	      else
+		{
+		  rtx x = gen_reg_rtx (SImode);
+		  emit_move_insn (x, p1);
+		  if (!spu_arith_operand (p1, SImode))
+		    p1 = x;
+		  rot = gen_reg_rtx (SImode);
+		  emit_insn (gen_addsi3 (rot, p0, p1));
+		  addr = gen_rtx_PLUS (Pmode, p0, x);
+		}
 	    }
 	  else
 	    rot = p0;
@@ -4289,16 +4384,21 @@
 	  if (GET_CODE (p1) == CONST_INT && (INTVAL (p1) & 15))
 	    {
 	      rot_amt = INTVAL (p1) & 15;
-	      p1 = GEN_INT (INTVAL (p1) & -16);
-	      addr = gen_rtx_PLUS (SImode, p0, p1);
+	      if (INTVAL (p1) & -16)
+		{
+		  p1 = GEN_INT (INTVAL (p1) & -16);
+		  addr = gen_rtx_PLUS (SImode, p0, p1);
+		}
+	      else
+		addr = p0;
 	    }
-	  else if (REG_P (p1) && !regno_aligned_for_load (REGNO (p1)))
+	  else if (REG_P (p1) && !reg_aligned_for_addr (p1))
 	    rot = p1;
 	}
     }
-  else if (GET_CODE (addr) == REG)
+  else if (REG_P (addr))
     {
-      if (!regno_aligned_for_load (REGNO (addr)))
+      if (!reg_aligned_for_addr (addr))
 	rot = addr;
     }
   else if (GET_CODE (addr) == CONST)
@@ -4317,7 +4417,10 @@
 	    addr = XEXP (XEXP (addr, 0), 0);
 	}
       else
-	rot = addr;
+	{
+	  rot = gen_reg_rtx (Pmode);
+	  emit_move_insn (rot, addr);
+	}
     }
   else if (GET_CODE (addr) == CONST_INT)
     {
@@ -4325,49 +4428,96 @@
       addr = GEN_INT (rot_amt & -16);
     }
   else if (!ALIGNED_SYMBOL_REF_P (addr))
-    rot = addr;
+    {
+      rot = gen_reg_rtx (Pmode);
+      emit_move_insn (rot, addr);
+    }
 
-  if (GET_MODE_SIZE (mode) < 4)
-    rot_amt += GET_MODE_SIZE (mode) - 4;
+  rot_amt += extra_rotby;
 
   rot_amt &= 15;
 
   if (rot && rot_amt)
     {
-      emit_insn (gen_addsi3 (ops[3], rot, GEN_INT (rot_amt)));
-      rot = ops[3];
+      rtx x = gen_reg_rtx (SImode);
+      emit_insn (gen_addsi3 (x, rot, GEN_INT (rot_amt)));
+      rot = x;
       rot_amt = 0;
     }
+  if (!rot && rot_amt)
+    rot = GEN_INT (rot_amt);
+
+  addr0 = copy_rtx (addr);
+  addr0 = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));
+  emit_insn (gen__movti (dst0, change_address (src, TImode, addr0)));
+
+  if (dst1)
+    {
+      addr1 = plus_constant (copy_rtx (addr), 16);
+      addr1 = gen_rtx_AND (SImode, addr1, GEN_INT (-16));
+      emit_insn (gen__movti (dst1, change_address (src, TImode, addr1)));
+    }
+
+  return rot;
+}
+
+int
+spu_split_load (rtx * ops)
+{
+  enum machine_mode mode = GET_MODE (ops[0]);
+  rtx addr, load, rot;
+  int rot_amt;
+
+  if (GET_MODE_SIZE (mode) >= 16)
+    return 0;
+
+  addr = XEXP (ops[1], 0);
+  gcc_assert (GET_CODE (addr) != AND);
 
-  load = ops[2];
+  if (!address_needs_split (ops[1]))
+    {
+      ops[1] = change_address (ops[1], TImode, addr);
+      load = gen_reg_rtx (TImode);
+      emit_insn (gen__movti (load, ops[1]));
+      spu_convert_move (ops[0], load);
+      return 1;
+    }
 
-  addr = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));
-  mem = change_address (ops[1], TImode, addr);
+  rot_amt = GET_MODE_SIZE (mode) < 4 ? GET_MODE_SIZE (mode) - 4 : 0;
 
-  emit_insn (gen_movti (load, mem));
+  load = gen_reg_rtx (TImode);
+  rot = spu_expand_load (load, 0, ops[1], rot_amt);
 
   if (rot)
     emit_insn (gen_rotqby_ti (load, load, rot));
-  else if (rot_amt)
-    emit_insn (gen_rotlti3 (load, load, GEN_INT (rot_amt * 8)));
 
-  if (reload_completed)
-    emit_move_insn (ops[0], gen_rtx_REG (GET_MODE (ops[0]), REGNO (load)));
-  else
-    emit_insn (gen_spu_convert (ops[0], load));
+  spu_convert_move (ops[0], load);
+  return 1;
 }
 
-void
+int
 spu_split_store (rtx * ops)
 {
   enum machine_mode mode = GET_MODE (ops[0]);
-  rtx pat = ops[2];
-  rtx reg = ops[3];
+  rtx reg;
   rtx addr, p0, p1, p1_lo, smem;
   int aform;
   int scalar;
 
+  if (GET_MODE_SIZE (mode) >= 16)
+    return 0;
+
   addr = XEXP (ops[0], 0);
+  gcc_assert (GET_CODE (addr) != AND);
+
+  if (!address_needs_split (ops[0]))
+    {
+      reg = gen_reg_rtx (TImode);
+      emit_insn (gen_spu_convert (reg, ops[1]));
+      ops[0] = change_address (ops[0], TImode, addr);
+      emit_move_insn (ops[0], reg);
+      return 1;
+    }
 
   if (GET_CODE (addr) == PLUS)
     {
@@ -4379,19 +4529,31 @@
          unaligned reg + aligned reg     => lqx, c?x, shuf, stqx
          unaligned reg + unaligned reg   => lqx, c?x, shuf, stqx
          unaligned reg + aligned const   => lqd, c?d, shuf, stqx
-         unaligned reg + unaligned const -> not allowed by legitimate address
+         unaligned reg + unaligned const -> lqx, c?d, shuf, stqx
        */
       aform = 0;
       p0 = XEXP (addr, 0);
       p1 = p1_lo = XEXP (addr, 1);
-      if (GET_CODE (p0) == REG && GET_CODE (p1) == CONST_INT)
+      if (REG_P (p0) && GET_CODE (p1) == CONST_INT)
 	{
 	  p1_lo = GEN_INT (INTVAL (p1) & 15);
-	  p1 = GEN_INT (INTVAL (p1) & -16);
-	  addr = gen_rtx_PLUS (SImode, p0, p1);
+	  if (reg_aligned_for_addr (p0))
+	    {
+	      p1 = GEN_INT (INTVAL (p1) & -16);
+	      if (p1 == const0_rtx)
+		addr = p0;
+	      else
+		addr = gen_rtx_PLUS (SImode, p0, p1);
+	    }
+	  else
+	    {
+	      rtx x = gen_reg_rtx (SImode);
+	      emit_move_insn (x, p1);
+	      addr = gen_rtx_PLUS (SImode, p0, x);
+	    }
 	}
     }
-  else if (GET_CODE (addr) == REG)
+  else if (REG_P (addr))
     {
       aform = 0;
       p0 = addr;
@@ -4405,31 +4567,34 @@
       p1_lo = addr;
       if (ALIGNED_SYMBOL_REF_P (addr))
 	p1_lo = const0_rtx;
-      else if (GET_CODE (addr) == CONST)
+      else if (GET_CODE (addr) == CONST
+	       && GET_CODE (XEXP (addr, 0)) == PLUS
+	       && ALIGNED_SYMBOL_REF_P (XEXP (XEXP (addr, 0), 0))
+	       && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)
 	{
-	  if (GET_CODE (XEXP (addr, 0)) == PLUS
-	      && ALIGNED_SYMBOL_REF_P (XEXP (XEXP (addr, 0), 0))
-	      && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT)
-	    {
-	      HOST_WIDE_INT v = INTVAL (XEXP (XEXP (addr, 0), 1));
-	      if ((v & -16) != 0)
-		addr = gen_rtx_CONST (Pmode,
-				      gen_rtx_PLUS (Pmode,
-						    XEXP (XEXP (addr, 0), 0),
-						    GEN_INT (v & -16)));
-	      else
-		addr = XEXP (XEXP (addr, 0), 0);
-	      p1_lo = GEN_INT (v & 15);
-	    }
+	  HOST_WIDE_INT v = INTVAL (XEXP (XEXP (addr, 0), 1));
+	  if ((v & -16) != 0)
+	    addr = gen_rtx_CONST (Pmode,
+				  gen_rtx_PLUS (Pmode,
+						XEXP (XEXP (addr, 0), 0),
+						GEN_INT (v & -16)));
+	  else
+	    addr = XEXP (XEXP (addr, 0), 0);
+	  p1_lo = GEN_INT (v & 15);
 	}
       else if (GET_CODE (addr) == CONST_INT)
 	{
 	  p1_lo = GEN_INT (INTVAL (addr) & 15);
 	  addr = GEN_INT (INTVAL (addr) & -16);
 	}
+      else
+	{
+	  p1_lo = gen_reg_rtx (SImode);
+	  emit_move_insn (p1_lo, addr);
+	}
     }
 
-  addr = gen_rtx_AND (SImode, copy_rtx (addr), GEN_INT (-16));
+  reg = gen_reg_rtx (TImode);
 
   scalar = store_with_one_insn_p (ops[0]);
   if (!scalar)
@@ -4439,11 +4604,12 @@
          possible, and copying the flags will prevent that in certain
          cases, e.g. consider the volatile flag. */
 
+      rtx pat = gen_reg_rtx (TImode);
       rtx lmem = change_address (ops[0], TImode, copy_rtx (addr));
       set_mem_alias_set (lmem, 0);
       emit_insn (gen_movti (reg, lmem));
 
-      if (!p0 || regno_aligned_for_load (REGNO (p0)))
+      if (!p0 || reg_aligned_for_addr (p0))
 	p0 = stack_pointer_rtx;
       if (!p1_lo)
 	p1_lo = const0_rtx;
@@ -4451,17 +4617,6 @@
       emit_insn (gen_cpat (pat, p0, p1_lo, GEN_INT (GET_MODE_SIZE (mode))));
       emit_insn (gen_shufb (reg, ops[1], reg, pat));
     }
-  else if (reload_completed)
-    {
-      if (GET_CODE (ops[1]) == REG)
-	emit_move_insn (reg, gen_rtx_REG (GET_MODE (reg), REGNO (ops[1])));
-      else if (GET_CODE (ops[1]) == SUBREG)
-	emit_move_insn (reg,
-			gen_rtx_REG (GET_MODE (reg),
-				     REGNO (SUBREG_REG (ops[1]))));
-      else
-	abort ();
-    }
   else
     {
       if (GET_CODE (ops[1]) == REG)
@@ -4473,15 +4628,16 @@
     }
 
   if (GET_MODE_SIZE (mode) < 4 && scalar)
-    emit_insn (gen_shlqby_ti
-	       (reg, reg, GEN_INT (4 - GET_MODE_SIZE (mode))));
+    emit_insn (gen_ashlti3
+	       (reg, reg, GEN_INT (32 - GET_MODE_BITSIZE (mode))));
 
-  smem = change_address (ops[0], TImode, addr);
+  smem = change_address (ops[0], TImode, copy_rtx (addr));
   /* We can't use the previous alias set because the memory has changed
      size and can potentially overlap objects of other types.  */
   set_mem_alias_set (smem, 0);
 
   emit_insn (gen_movti (smem, reg));
+  return 1;
 }
 
 /* Return TRUE if X is MEM which is a struct member reference
@@ -4580,37 +4736,6 @@
     }
 }
 
-int
-spu_valid_move (rtx * ops)
-{
-  enum machine_mode mode = GET_MODE (ops[0]);
-  if (!register_operand (ops[0], mode) && !register_operand (ops[1], mode))
-    return 0;
-
-  /* init_expr_once tries to recog against load and store insns to set
-     the direct_load[] and direct_store[] arrays.  We always want to
-     consider those loads and stores valid.  init_expr_once is called in
-     the context of a dummy function which does not have a decl. */
-  if (cfun->decl == 0)
-    return 1;
-
-  /* Don't allows loads/stores which would require more than 1 insn.
-     During and after reload we assume loads and stores only take 1
-     insn. */
-  if (GET_MODE_SIZE (mode) < 16 && !reload_in_progress && !reload_completed)
-    {
-      if (GET_CODE (ops[0]) == MEM
-	  && (GET_MODE_SIZE (mode) < 4
-	      || !(store_with_one_insn_p (ops[0])
-		   || mem_is_padded_component_ref (ops[0]))))
-	return 0;
-      if (GET_CODE (ops[1]) == MEM
-	  && (GET_MODE_SIZE (mode) < 4 || !aligned_mem_p (ops[1])))
-	return 0;
-    }
-  return 1;
-}
-
 /* Return TRUE if x is a CONST_INT, CONST_DOUBLE or CONST_VECTOR that
    can be generated using the fsmbi instruction. */
 int
@@ -6324,12 +6449,25 @@
 
 void
 spu_init_expanders (void)
-{   
-  /* HARD_FRAME_REGISTER is only 128 bit aligned when
-   * frame_pointer_needed is true.  We don't know that until we're
-   * expanding the prologue. */
+{
   if (cfun)
-    REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = 8;
+    {
+      rtx r0, r1;
+      /* HARD_FRAME_REGISTER is only 128 bit aligned when
+         frame_pointer_needed is true.  We don't know that until we're
+         expanding the prologue. */
+      REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = 8;
+
+      /* A number of passes use LAST_VIRTUAL_REGISTER+1 and
+	 LAST_VIRTUAL_REGISTER+2 to test the back-end.  We want them
+	 to be treated as aligned, so generate them here. */
+      r0 = gen_reg_rtx (SImode);
+      r1 = gen_reg_rtx (SImode);
+      mark_reg_pointer (r0, 128);
+      mark_reg_pointer (r1, 128);
+      gcc_assert (REGNO (r0) == LAST_VIRTUAL_REGISTER + 1
+		  && REGNO (r1) == LAST_VIRTUAL_REGISTER + 2);
+    }
 }
 
 static enum machine_mode
@@ -6372,5 +6510,53 @@
   return default_section_type_flags (decl, name, reloc);
 }
 
+/* Generate a constant or register which contains 2^SCALE.  We assume
+   the result is valid for MODE.  Currently, MODE must be V4SFmode and
+   SCALE must be SImode. */
+rtx
+spu_gen_exp2 (enum machine_mode mode, rtx scale)
+{
+  gcc_assert (mode == V4SFmode);
+  gcc_assert (GET_MODE (scale) == SImode || GET_CODE (scale) == CONST_INT);
+  if (GET_CODE (scale) != CONST_INT)
+    {
+      /* unsigned int exp = (127 + scale) << 23;
+	__vector float m = (__vector float) spu_splats (exp); */
+      rtx reg = force_reg (SImode, scale);
+      rtx exp = gen_reg_rtx (SImode);
+      rtx mul = gen_reg_rtx (mode);
+      emit_insn (gen_addsi3 (exp, reg, GEN_INT (127)));
+      emit_insn (gen_ashlsi3 (exp, exp, GEN_INT (23)));
+      emit_insn (gen_spu_splats (mul, gen_rtx_SUBREG (GET_MODE_INNER (mode), exp, 0)));
+      return mul;
+    }
+  else
+    {
+      HOST_WIDE_INT exp = 127 + INTVAL (scale);
+      unsigned char arr[16];
+      arr[0] = arr[4] = arr[8] = arr[12] = exp >> 1;
+      arr[1] = arr[5] = arr[9] = arr[13] = exp << 7;
+      arr[2] = arr[6] = arr[10] = arr[14] = 0;
+      arr[3] = arr[7] = arr[11] = arr[15] = 0;
+      return array_to_constant (mode, arr);
+    }
+}
+
+/* After reload, just change the convert into a move instruction
+   or a dead instruction. */
+void
+spu_split_convert (rtx ops[])
+{
+  if (REGNO (ops[0]) == REGNO (ops[1]))
+    emit_note (NOTE_INSN_DELETED);
+  else
+    {
+      /* Use TImode always as this might help hard reg copyprop.  */
+      rtx op0 = gen_rtx_REG (TImode, REGNO (ops[0]));
+      rtx op1 = gen_rtx_REG (TImode, REGNO (ops[1]));
+      emit_insn (gen_move_insn (op0, op1));
+    }
+}
+
 #include "gt-spu.h"
 
diff -Naur gcc-4.4.2.orig/gcc/config/spu/spu.md gcc-4.4.2/gcc/config/spu/spu.md
--- gcc-4.4.2.orig/gcc/config/spu/spu.md	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/config/spu/spu.md	2009-12-04 14:52:42.853505000 -0500
@@ -136,10 +136,6 @@
  (UNSPEC_HEQ            31)
  (UNSPEC_HGT            32)
  (UNSPEC_HLGT           33)
- (UNSPEC_CSFLT          34)
- (UNSPEC_CFLTS          35)
- (UNSPEC_CUFLT          36)
- (UNSPEC_CFLTU          37)
  (UNSPEC_STOP           38)
  (UNSPEC_STOPD          39)
  (UNSPEC_SET_INTR       40)
@@ -182,6 +178,8 @@
                         SF V4SF
                         DF V2DF])
 
+(define_mode_iterator QHSI  [QI HI SI])
+(define_mode_iterator QHSDI  [QI HI SI DI])
 (define_mode_iterator DTI  [DI TI])
 
 (define_mode_iterator VINT [QI V16QI
@@ -231,6 +229,10 @@
                        (DF "di") (V2DF "v2di")])
 (define_mode_attr F2I [(SF "SI") (V4SF "V4SI")
                        (DF "DI") (V2DF "V2DI")])
+(define_mode_attr i2f [(SI "sf") (V4SI "v4sf")
+                       (DI "df") (V2DI "v2df")])
+(define_mode_attr I2F [(SI "SF") (V4SI "V4SF")
+                       (DI "DF") (V2DI "V2DF")])
 
 (define_mode_attr DF2I [(DF "SI") (V2DF "V2DI")])
 
@@ -316,9 +318,10 @@
 ;; move internal
 
 (define_insn "_mov<mode>"
-  [(set (match_operand:MOV 0 "spu_nonimm_operand" "=r,r,r,r,r,m")
+  [(set (match_operand:MOV 0 "spu_dest_operand" "=r,r,r,r,r,m")
 	(match_operand:MOV 1 "spu_mov_operand" "r,A,f,j,m,r"))]
-  "spu_valid_move (operands)"
+  "register_operand(operands[0], <MODE>mode)
+   || register_operand(operands[1], <MODE>mode)"
   "@
    ori\t%0,%1,0
    il%s1\t%0,%S1
@@ -336,9 +339,10 @@
   "iohl\t%0,%2@l")
 
 (define_insn "_movdi"
-  [(set (match_operand:DI 0 "spu_nonimm_operand" "=r,r,r,r,r,m")
+  [(set (match_operand:DI 0 "spu_dest_operand" "=r,r,r,r,r,m")
 	(match_operand:DI 1 "spu_mov_operand" "r,a,f,k,m,r"))]
-  "spu_valid_move (operands)"
+  "register_operand(operands[0], DImode)
+   || register_operand(operands[1], DImode)"
   "@
    ori\t%0,%1,0
    il%d1\t%0,%D1
@@ -349,9 +353,10 @@
   [(set_attr "type" "fx2,fx2,shuf,shuf,load,store")])
 
 (define_insn "_movti"
-  [(set (match_operand:TI 0 "spu_nonimm_operand" "=r,r,r,r,r,m")
+  [(set (match_operand:TI 0 "spu_dest_operand" "=r,r,r,r,r,m")
 	(match_operand:TI 1 "spu_mov_operand" "r,U,f,l,m,r"))]
-  "spu_valid_move (operands)"
+  "register_operand(operands[0], TImode)
+   || register_operand(operands[1], TImode)"
   "@
    ori\t%0,%1,0
    il%t1\t%0,%T1
@@ -361,30 +366,29 @@
    stq%p0\t%1,%0"
   [(set_attr "type" "fx2,fx2,shuf,shuf,load,store")])
 
-(define_insn_and_split "load"
-  [(set (match_operand 0 "spu_reg_operand" "=r")
-	(match_operand 1 "memory_operand" "m"))
-   (clobber (match_operand:TI 2 "spu_reg_operand" "=&r"))
-   (clobber (match_operand:SI 3 "spu_reg_operand" "=&r"))]
-  "GET_MODE(operands[0]) == GET_MODE(operands[1])"
-  "#"
-  ""
+(define_split
+  [(set (match_operand 0 "spu_reg_operand")
+	(match_operand 1 "memory_operand"))]
+  "GET_MODE_SIZE (GET_MODE (operands[0])) < 16
+   && GET_MODE(operands[0]) == GET_MODE(operands[1])
+   && !reload_in_progress && !reload_completed"
   [(set (match_dup 0)
 	(match_dup 1))]
-  { spu_split_load(operands); DONE; })
+  { if (spu_split_load(operands))
+      DONE;
+  })
 
-(define_insn_and_split "store"
-  [(set (match_operand 0 "memory_operand" "=m")
-	(match_operand 1 "spu_reg_operand" "r"))
-   (clobber (match_operand:TI 2 "spu_reg_operand" "=&r"))
-   (clobber (match_operand:TI 3 "spu_reg_operand" "=&r"))]
-  "GET_MODE(operands[0]) == GET_MODE(operands[1])"
-  "#"
-  ""
+(define_split
+  [(set (match_operand 0 "memory_operand")
+	(match_operand 1 "spu_reg_operand"))]
+  "GET_MODE_SIZE (GET_MODE (operands[0])) < 16
+   && GET_MODE(operands[0]) == GET_MODE(operands[1])
+   && !reload_in_progress && !reload_completed"
   [(set (match_dup 0)
 	(match_dup 1))]
-  { spu_split_store(operands); DONE; })
-
+  { if (spu_split_store(operands))
+      DONE;
+  })
 ;; Operand 3 is the number of bytes. 1:b 2:h 4:w 8:d
 
 (define_expand "cpat"
@@ -462,33 +466,20 @@
   ""
   "xswd\t%0,%1");
 
-(define_expand "extendqiti2"
+;; By splitting this late we don't allow much opportunity for sharing of
+;; constants.  That's ok because this should really be optimized away.
+(define_insn_and_split "extend<mode>ti2"
   [(set (match_operand:TI 0 "register_operand" "")
-	(sign_extend:TI (match_operand:QI 1 "register_operand" "")))]
+	(sign_extend:TI (match_operand:QHSDI 1 "register_operand" "")))]
   ""
-  "spu_expand_sign_extend(operands);
-   DONE;")
-
-(define_expand "extendhiti2"
-  [(set (match_operand:TI 0 "register_operand" "")
-	(sign_extend:TI (match_operand:HI 1 "register_operand" "")))]
-  ""
-  "spu_expand_sign_extend(operands);
-   DONE;")
-
-(define_expand "extendsiti2"
-  [(set (match_operand:TI 0 "register_operand" "")
-	(sign_extend:TI (match_operand:SI 1 "register_operand" "")))]
-  ""
-  "spu_expand_sign_extend(operands);
-   DONE;")
-
-(define_expand "extendditi2"
-  [(set (match_operand:TI 0 "register_operand" "")
-	(sign_extend:TI (match_operand:DI 1 "register_operand" "")))]
+  "#"
   ""
-  "spu_expand_sign_extend(operands);
-   DONE;")
+  [(set (match_dup:TI 0)
+	(sign_extend:TI (match_dup:QHSDI 1)))]
+  {
+    spu_expand_sign_extend(operands);
+    DONE;
+  })
 
 
 ;; zero_extend
@@ -525,6 +516,22 @@
   "rotqmbyi\t%0,%1,-4"
   [(set_attr "type" "shuf")])
 
+(define_insn "zero_extendqiti2"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r")
+	(zero_extend:TI (match_operand:QI 1 "spu_reg_operand" "r")))]
+  ""
+  "andi\t%0,%1,0x00ff\;rotqmbyi\t%0,%0,-12"
+  [(set_attr "type" "multi0")
+   (set_attr "length" "8")])
+
+(define_insn "zero_extendhiti2"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r")
+	(zero_extend:TI (match_operand:HI 1 "spu_reg_operand" "r")))]
+  ""
+  "shli\t%0,%1,16\;rotqmbyi\t%0,%0,-14"
+  [(set_attr "type" "multi1")
+   (set_attr "length" "8")])
+
 (define_insn "zero_extendsiti2"
   [(set (match_operand:TI 0 "spu_reg_operand" "=r")
 	(zero_extend:TI (match_operand:SI 1 "spu_reg_operand" "r")))]
@@ -594,60 +601,81 @@
 
 ;; float conversions
 
-(define_insn "floatsisf2"
-  [(set (match_operand:SF 0 "spu_reg_operand" "=r")
-	(float:SF (match_operand:SI 1 "spu_reg_operand" "r")))]
+(define_insn "float<mode><i2f>2"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r")))]
   ""
   "csflt\t%0,%1,0"
   [(set_attr "type" "fp7")])
 
-(define_insn "floatv4siv4sf2"
-  [(set (match_operand:V4SF 0 "spu_reg_operand" "=r")
-	(float:V4SF (match_operand:V4SI 1 "spu_reg_operand" "r")))]
+(define_insn "fix_trunc<mode><f2i>2"
+  [(set (match_operand:<F2I> 0 "spu_reg_operand" "=r")
+	(fix:<F2I> (match_operand:VSF 1 "spu_reg_operand" "r")))]
   ""
-  "csflt\t%0,%1,0"
+  "cflts\t%0,%1,0"
   [(set_attr "type" "fp7")])
 
-(define_insn "fix_truncsfsi2"
-  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
-	(fix:SI (match_operand:SF 1 "spu_reg_operand" "r")))]
+(define_insn "floatuns<mode><i2f>2"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(unsigned_float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r")))]
   ""
-  "cflts\t%0,%1,0"
+  "cuflt\t%0,%1,0"
   [(set_attr "type" "fp7")])
 
-(define_insn "fix_truncv4sfv4si2"
-  [(set (match_operand:V4SI 0 "spu_reg_operand" "=r")
-	(fix:V4SI (match_operand:V4SF 1 "spu_reg_operand" "r")))]
+(define_insn "fixuns_trunc<mode><f2i>2"
+  [(set (match_operand:<F2I> 0 "spu_reg_operand" "=r")
+	(unsigned_fix:<F2I> (match_operand:VSF 1 "spu_reg_operand" "r")))]
   ""
-  "cflts\t%0,%1,0"
+  "cfltu\t%0,%1,0"
   [(set_attr "type" "fp7")])
 
-(define_insn "floatunssisf2"
-  [(set (match_operand:SF 0 "spu_reg_operand" "=r")
-	(unsigned_float:SF (match_operand:SI 1 "spu_reg_operand" "r")))]
+(define_insn "float<mode><i2f>2_mul"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(mult:<I2F> (float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r"))
+		    (match_operand:<I2F> 2 "spu_inv_exp2_operand" "w")))]
   ""
-  "cuflt\t%0,%1,0"
+  "csflt\t%0,%1,%w2"
   [(set_attr "type" "fp7")])
 
-(define_insn "floatunsv4siv4sf2"
-  [(set (match_operand:V4SF 0 "spu_reg_operand" "=r")
-	(unsigned_float:V4SF (match_operand:V4SI 1 "spu_reg_operand" "r")))]
+(define_insn "float<mode><i2f>2_div"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(div:<I2F> (float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r"))
+		   (match_operand:<I2F> 2 "spu_exp2_operand" "v")))]
   ""
-  "cuflt\t%0,%1,0"
+  "csflt\t%0,%1,%v2"
   [(set_attr "type" "fp7")])
 
-(define_insn "fixuns_truncsfsi2"
-  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
-	(unsigned_fix:SI (match_operand:SF 1 "spu_reg_operand" "r")))]
+
+(define_insn "fix_trunc<mode><f2i>2_mul"
+  [(set (match_operand:<F2I> 0 "spu_reg_operand" "=r")
+	(fix:<F2I> (mult:VSF (match_operand:VSF 1 "spu_reg_operand" "r")
+			     (match_operand:VSF 2 "spu_exp2_operand" "v"))))]
   ""
-  "cfltu\t%0,%1,0"
+  "cflts\t%0,%1,%v2"
   [(set_attr "type" "fp7")])
 
-(define_insn "fixuns_truncv4sfv4si2"
-  [(set (match_operand:V4SI 0 "spu_reg_operand" "=r")
-	(unsigned_fix:V4SI (match_operand:V4SF 1 "spu_reg_operand" "r")))]
+(define_insn "floatuns<mode><i2f>2_mul"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(mult:<I2F> (unsigned_float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r"))
+		    (match_operand:<I2F> 2 "spu_inv_exp2_operand" "w")))]
   ""
-  "cfltu\t%0,%1,0"
+  "cuflt\t%0,%1,%w2"
+  [(set_attr "type" "fp7")])
+
+(define_insn "floatuns<mode><i2f>2_div"
+  [(set (match_operand:<I2F> 0 "spu_reg_operand" "=r")
+	(div:<I2F> (unsigned_float:<I2F> (match_operand:VSI 1 "spu_reg_operand" "r"))
+		   (match_operand:<I2F> 2 "spu_exp2_operand" "v")))]
+  ""
+  "cuflt\t%0,%1,%v2"
+  [(set_attr "type" "fp7")])
+
+(define_insn "fixuns_trunc<mode><f2i>2_mul"
+  [(set (match_operand:<F2I> 0 "spu_reg_operand" "=r")
+	(unsigned_fix:<F2I> (mult:VSF (match_operand:VSF 1 "spu_reg_operand" "r")
+				      (match_operand:VSF 2 "spu_exp2_operand" "v"))))]
+  ""
+  "cfltu\t%0,%1,%v2"
   [(set_attr "type" "fp7")])
 
 (define_insn "extendsfdf2"
@@ -2327,6 +2355,13 @@
   ""
   [(set_attr "type" "*,fx3")])
   
+(define_insn "<v>lshr<mode>3_imm"
+  [(set (match_operand:VHSI 0 "spu_reg_operand" "=r")
+	(lshiftrt:VHSI (match_operand:VHSI 1 "spu_reg_operand" "r")
+		       (match_operand:VHSI 2 "immediate_operand" "W")))]
+  ""
+  "rot<bh>mi\t%0,%1,-%<umask>2"
+  [(set_attr "type" "fx3")])
 
 (define_insn "rotm_<mode>"
   [(set (match_operand:VHSI 0 "spu_reg_operand" "=r,r")
@@ -2338,89 +2373,59 @@
    rot<bh>mi\t%0,%1,-%<nmask>2"
   [(set_attr "type" "fx3")])
  
-(define_expand "lshr<mode>3"
-  [(parallel [(set (match_operand:DTI 0 "spu_reg_operand" "")
-		   (lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "")
-			         (match_operand:SI 2 "spu_nonmem_operand" "")))
-	      (clobber (match_dup:DTI 3))
-	      (clobber (match_dup:SI 4))
-	      (clobber (match_dup:SI 5))])]
-  ""
-  "if (GET_CODE (operands[2]) == CONST_INT)
-    {
-      emit_insn (gen_lshr<mode>3_imm(operands[0], operands[1], operands[2]));
-      DONE;
-    }
-   operands[3] = gen_reg_rtx (<MODE>mode);
-   operands[4] = gen_reg_rtx (SImode);
-   operands[5] = gen_reg_rtx (SImode);")
-
-(define_insn_and_split "lshr<mode>3_imm"
-  [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
-	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r,r")
-		      (match_operand:SI 2 "immediate_operand" "O,P")))]
+(define_insn_and_split "lshr<mode>3"
+  [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r,r")
+	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r,r,r")
+		      (match_operand:SI 2 "spu_nonmem_operand" "r,O,P")))]
   ""
   "@
+   #
    rotqmbyi\t%0,%1,-%h2
    rotqmbii\t%0,%1,-%e2"
-  "!satisfies_constraint_O (operands[2]) && !satisfies_constraint_P (operands[2])"
-  [(set (match_dup:DTI 0)
+  "REG_P (operands[2]) || (!satisfies_constraint_O (operands[2]) && !satisfies_constraint_P (operands[2]))"
+  [(set (match_dup:DTI 3)
 	(lshiftrt:DTI (match_dup:DTI 1)
 		      (match_dup:SI 4)))
    (set (match_dup:DTI 0)
-	(lshiftrt:DTI (match_dup:DTI 0)
+	(lshiftrt:DTI (match_dup:DTI 3)
 		      (match_dup:SI 5)))]
   {
-    HOST_WIDE_INT val = INTVAL(operands[2]);
-    operands[4] = GEN_INT (val&7);
-    operands[5] = GEN_INT (val&-8);
+    operands[3] = gen_reg_rtx (<MODE>mode);
+    if (GET_CODE (operands[2]) == CONST_INT)
+      {
+	HOST_WIDE_INT val = INTVAL(operands[2]);
+	operands[4] = GEN_INT (val & 7);
+	operands[5] = GEN_INT (val & -8);
+      }
+    else
+      {
+        rtx t0 = gen_reg_rtx (SImode);
+        rtx t1 = gen_reg_rtx (SImode);
+	emit_insn (gen_subsi3(t0, GEN_INT(0), operands[2]));
+	emit_insn (gen_subsi3(t1, GEN_INT(7), operands[2]));
+        operands[4] = gen_rtx_AND (SImode, gen_rtx_NEG (SImode, t0), GEN_INT (7));
+        operands[5] = gen_rtx_AND (SImode, gen_rtx_NEG (SImode, gen_rtx_AND (SImode, t1, GEN_INT (-8))), GEN_INT (-8));
+      }
   }
-  [(set_attr "type" "shuf,shuf")])
-
-(define_insn_and_split "lshr<mode>3_reg"
-  [(set (match_operand:DTI 0 "spu_reg_operand" "=r")
-	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r")
-		      (match_operand:SI 2 "spu_reg_operand" "r")))
-   (clobber (match_operand:DTI 3 "spu_reg_operand" "=&r"))
-   (clobber (match_operand:SI 4 "spu_reg_operand" "=&r"))
-   (clobber (match_operand:SI 5 "spu_reg_operand" "=&r"))]
-  ""
-  "#"
-  ""
-  [(set (match_dup:DTI 3)
-	(lshiftrt:DTI (match_dup:DTI 1)
-		     (and:SI (neg:SI (match_dup:SI 4))
-			     (const_int 7))))
-   (set (match_dup:DTI 0)
-	(lshiftrt:DTI (match_dup:DTI 3)
-		     (and:SI (neg:SI (and:SI (match_dup:SI 5)
-					     (const_int -8)))
-			     (const_int -8))))]
-  {
-    emit_insn (gen_subsi3(operands[4], GEN_INT(0), operands[2]));
-    emit_insn (gen_subsi3(operands[5], GEN_INT(7), operands[2]));
-  })
+  [(set_attr "type" "*,shuf,shuf")])
 
-(define_insn_and_split "shrqbybi_<mode>"
+(define_expand "shrqbybi_<mode>"
   [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
 	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r,r")
-		      (and:SI (match_operand:SI 2 "spu_nonmem_operand" "r,I")
-			      (const_int -8))))
-   (clobber (match_scratch:SI 3 "=&r,X"))]
-  ""
-  "#"
-  "reload_completed"
-  [(set (match_dup:DTI 0)
-	(lshiftrt:DTI (match_dup:DTI 1)
-		      (and:SI (neg:SI (and:SI (match_dup:SI 3) (const_int -8)))
+		      (and:SI (neg:SI (and:SI (match_operand:SI 2 "spu_nonmem_operand" "r,I")
+					      (const_int -8)))
 			      (const_int -8))))]
+  ""
   {
     if (GET_CODE (operands[2]) == CONST_INT)
-      operands[3] = GEN_INT (7 - INTVAL (operands[2]));
+      operands[2] = GEN_INT (7 - INTVAL (operands[2]));
     else
-      emit_insn (gen_subsi3 (operands[3], GEN_INT (7), operands[2]));
-  }
-  [(set_attr "type" "shuf")])
+      {
+        rtx t0 = gen_reg_rtx (SImode);
+	emit_insn (gen_subsi3 (t0, GEN_INT (7), operands[2]));
+        operands[2] = t0;
+      }
+  })
 
 (define_insn "rotqmbybi_<mode>"
   [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
@@ -2465,25 +2470,22 @@
    rotqmbii\t%0,%1,-%E2"
   [(set_attr "type" "shuf")])
 
-(define_insn_and_split "shrqby_<mode>"
+(define_expand "shrqby_<mode>"
   [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
 	(lshiftrt:DTI (match_operand:DTI 1 "spu_reg_operand" "r,r")
-		      (mult:SI (match_operand:SI 2 "spu_nonmem_operand" "r,I")
-			       (const_int 8))))
-   (clobber (match_scratch:SI 3 "=&r,X"))]
+		      (mult:SI (neg:SI (match_operand:SI 2 "spu_nonmem_operand" "r,I"))
+			       (const_int 8))))]
   ""
-  "#"
-  "reload_completed"
-  [(set (match_dup:DTI 0)
-	(lshiftrt:DTI (match_dup:DTI 1)
-		      (mult:SI (neg:SI (match_dup:SI 3)) (const_int 8))))]
   {
     if (GET_CODE (operands[2]) == CONST_INT)
-      operands[3] = GEN_INT (-INTVAL (operands[2]));
+      operands[2] = GEN_INT (-INTVAL (operands[2]));
     else
-      emit_insn (gen_subsi3 (operands[3], GEN_INT (0), operands[2]));
-  }
-  [(set_attr "type" "shuf")])
+      {
+        rtx t0 = gen_reg_rtx (SImode);
+	emit_insn (gen_subsi3 (t0, GEN_INT (0), operands[2]));
+        operands[2] = t0;
+      }
+  })
 
 (define_insn "rotqmby_<mode>"
   [(set (match_operand:DTI 0 "spu_reg_operand" "=r,r")
@@ -2517,6 +2519,14 @@
   ""
   [(set_attr "type" "*,fx3")])
   
+(define_insn "<v>ashr<mode>3_imm"
+  [(set (match_operand:VHSI 0 "spu_reg_operand" "=r")
+	(ashiftrt:VHSI (match_operand:VHSI 1 "spu_reg_operand" "r")
+		       (match_operand:VHSI 2 "immediate_operand" "W")))]
+  ""
+  "rotma<bh>i\t%0,%1,-%<umask>2"
+  [(set_attr "type" "fx3")])
+
 
 (define_insn "rotma_<mode>"
   [(set (match_operand:VHSI 0 "spu_reg_operand" "=r,r")
@@ -2601,11 +2611,16 @@
   })
 
 
-(define_expand "ashrti3"
-  [(set (match_operand:TI 0 "spu_reg_operand" "")
-	(ashiftrt:TI (match_operand:TI 1 "spu_reg_operand" "")
-		     (match_operand:SI 2 "spu_nonmem_operand" "")))]
+(define_insn_and_split "ashrti3"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r,r")
+	(ashiftrt:TI (match_operand:TI 1 "spu_reg_operand" "r,r")
+		     (match_operand:SI 2 "spu_nonmem_operand" "r,i")))]
   ""
+  "#"
+  ""
+  [(set (match_dup:TI 0)
+	(ashiftrt:TI (match_dup:TI 1)
+		     (match_dup:SI 2)))]
   {
     rtx sign_shift = gen_reg_rtx (SImode);
     rtx sign_mask = gen_reg_rtx (TImode);
@@ -2690,33 +2705,133 @@
 
 
 ;; struct extract/insert
-;; We have to handle mem's because GCC will generate invalid SUBREG's
-;; if it handles them.  We generate better code anyway.
+;; We handle mem's because GCC will generate invalid SUBREG's
+;; and inefficient code.
 
 (define_expand "extv"
-  [(set (match_operand 0 "register_operand" "")
-	(sign_extract (match_operand 1 "register_operand" "")
-		      (match_operand:SI 2 "const_int_operand" "")
-		      (match_operand:SI 3 "const_int_operand" "")))]
+  [(set (match_operand:TI 0 "register_operand" "")
+	(sign_extract:TI (match_operand 1 "nonimmediate_operand" "")
+			 (match_operand:SI 2 "const_int_operand" "")
+			 (match_operand:SI 3 "const_int_operand" "")))]
   ""
-  { spu_expand_extv(operands, 0); DONE; })
+  {
+    spu_expand_extv (operands, 0);
+    DONE;
+  })
 
 (define_expand "extzv"
-  [(set (match_operand 0 "register_operand" "")
-	(zero_extract (match_operand 1 "register_operand" "")
+  [(set (match_operand:TI 0 "register_operand" "")
+	(zero_extract:TI (match_operand 1 "nonimmediate_operand" "")
 			 (match_operand:SI 2 "const_int_operand" "")
 			 (match_operand:SI 3 "const_int_operand" "")))]
   ""
-  { spu_expand_extv(operands, 1); DONE; })
+  {
+    spu_expand_extv (operands, 1);
+    DONE;
+  })
 
 (define_expand "insv"
-  [(set (zero_extract (match_operand 0 "register_operand" "")
+  [(set (zero_extract (match_operand 0 "nonimmediate_operand" "")
 		      (match_operand:SI 1 "const_int_operand" "")
 		      (match_operand:SI 2 "const_int_operand" ""))
 	(match_operand 3 "nonmemory_operand" ""))]
   ""
   { spu_expand_insv(operands); DONE; })
 
+;; Simplify a number of patterns that get generated by extv, extzv,
+;; insv, and loads.
+(define_insn_and_split "trunc_shr_ti<mode>"
+  [(set (match_operand:QHSI 0 "spu_reg_operand" "=r")
+        (truncate:QHSI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "0")
+								(const_int 96)])))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
+  [(set_attr "type" "convert")
+   (set_attr "length" "0")])
+
+(define_insn_and_split "trunc_shr_tidi"
+  [(set (match_operand:DI 0 "spu_reg_operand" "=r")
+        (truncate:DI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "0")
+							      (const_int 64)])))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
+  [(set_attr "type" "convert")
+   (set_attr "length" "0")])
+
+(define_insn_and_split "shl_ext_<mode>ti"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r")
+        (ashift:TI (match_operator:TI 2 "extend_operator" [(match_operand:QHSI 1 "spu_reg_operand" "0")])
+		   (const_int 96)))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
+  [(set_attr "type" "convert")
+   (set_attr "length" "0")])
+
+(define_insn_and_split "shl_ext_diti"
+  [(set (match_operand:TI 0 "spu_reg_operand" "=r")
+        (ashift:TI (match_operator:TI 2 "extend_operator" [(match_operand:DI 1 "spu_reg_operand" "0")])
+		   (const_int 64)))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
+  [(set_attr "type" "convert")
+   (set_attr "length" "0")])
+
+(define_insn "sext_trunc_lshr_tiqisi"
+  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
+        (sign_extend:SI (truncate:QI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "r")
+									      (const_int 120)]))))]
+  ""
+  "rotmai\t%0,%1,-24"
+  [(set_attr "type" "fx3")])
+
+(define_insn "zext_trunc_lshr_tiqisi"
+  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
+        (zero_extend:SI (truncate:QI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "r")
+									      (const_int 120)]))))]
+  ""
+  "rotmi\t%0,%1,-24"
+  [(set_attr "type" "fx3")])
+
+(define_insn "sext_trunc_lshr_tihisi"
+  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
+        (sign_extend:SI (truncate:HI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "r")
+									      (const_int 112)]))))]
+  ""
+  "rotmai\t%0,%1,-16"
+  [(set_attr "type" "fx3")])
+
+(define_insn "zext_trunc_lshr_tihisi"
+  [(set (match_operand:SI 0 "spu_reg_operand" "=r")
+        (zero_extend:SI (truncate:HI (match_operator:TI 2 "shiftrt_operator" [(match_operand:TI 1 "spu_reg_operand" "r")
+									      (const_int 112)]))))]
+  ""
+  "rotmi\t%0,%1,-16"
+  [(set_attr "type" "fx3")])
+
 
 ;; String/block move insn.
 ;; Argument 0 is the destination
@@ -4369,21 +4484,20 @@
     DONE;
   })
 
-(define_insn "_spu_convert"
+(define_insn_and_split "_spu_convert"
   [(set (match_operand 0 "spu_reg_operand" "=r")
 	(unspec [(match_operand 1 "spu_reg_operand" "0")] UNSPEC_CONVERT))]
-  "operands"
   ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  {
+    spu_split_convert (operands);
+    DONE;
+  }
   [(set_attr "type" "convert")
    (set_attr "length" "0")])
 
-(define_peephole2
-  [(set (match_operand 0 "spu_reg_operand")
-	(unspec [(match_operand 1 "spu_reg_operand")] UNSPEC_CONVERT))]
-  ""
-  [(use (const_int 0))]
-  "")
-
 
 ;;
 (include "spu-builtins.md")
@@ -5252,8 +5366,8 @@
 }")
 
 (define_insn "stack_protect_set"
-  [(set (match_operand:SI 0 "spu_mem_operand" "=m")
-        (unspec:SI [(match_operand:SI 1 "spu_mem_operand" "m")] UNSPEC_SP_SET))
+  [(set (match_operand:SI 0 "memory_operand" "=m")
+        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")] UNSPEC_SP_SET))
    (set (match_scratch:SI 2 "=&r") (const_int 0))]
   ""
   "lq%p1\t%2,%1\;stq%p0\t%2,%0\;xor\t%2,%2,%2"
@@ -5262,8 +5376,8 @@
 )
 
 (define_expand "stack_protect_test"
-  [(match_operand 0 "spu_mem_operand" "")
-   (match_operand 1 "spu_mem_operand" "")
+  [(match_operand 0 "memory_operand" "")
+   (match_operand 1 "memory_operand" "")
    (match_operand 2 "" "")]
   ""
 {
@@ -5289,8 +5403,8 @@
 
 (define_insn "stack_protect_test_si"
   [(set (match_operand:SI 0 "spu_reg_operand" "=&r")
-        (unspec:SI [(match_operand:SI 1 "spu_mem_operand" "m")
-                    (match_operand:SI 2 "spu_mem_operand" "m")]
+        (unspec:SI [(match_operand:SI 1 "memory_operand" "m")
+                    (match_operand:SI 2 "memory_operand" "m")]
                    UNSPEC_SP_TEST))
    (set (match_scratch:SI 3 "=&r") (const_int 0))]
   ""
diff -Naur gcc-4.4.2.orig/gcc/config/spu/spu-protos.h gcc-4.4.2/gcc/config/spu/spu-protos.h
--- gcc-4.4.2.orig/gcc/config/spu/spu-protos.h	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/config/spu/spu-protos.h	2009-12-04 14:52:42.853505000 -0500
@@ -51,6 +51,8 @@
 extern int iohl_immediate_p (rtx op, enum machine_mode mode);
 extern int arith_immediate_p (rtx op, enum machine_mode mode,
 			      HOST_WIDE_INT low, HOST_WIDE_INT high);
+extern bool exp2_immediate_p (rtx op, enum machine_mode mode, int low,
+			      int high);
 extern int spu_constant_address_p (rtx x);
 extern int spu_legitimate_constant_p (rtx x);
 extern int spu_legitimate_address (enum machine_mode mode, rtx x,
@@ -64,17 +66,16 @@
 					tree type, int *pretend_size,
 					int no_rtl);
 extern void spu_conditional_register_usage (void);
-extern int aligned_mem_p (rtx mem);
 extern int spu_expand_mov (rtx * ops, enum machine_mode mode);
-extern void spu_split_load (rtx * ops);
-extern void spu_split_store (rtx * ops);
-extern int spu_valid_move (rtx * ops);
+extern int spu_split_load (rtx * ops);
+extern int spu_split_store (rtx * ops);
 extern int fsmbi_const_p (rtx x);
 extern int cpat_const_p (rtx x, enum machine_mode mode);
 extern rtx gen_cpat_const (rtx * ops);
 extern void constant_to_array (enum machine_mode mode, rtx x,
 			       unsigned char *arr);
 extern rtx array_to_constant (enum machine_mode mode, unsigned char *arr);
+extern rtx spu_gen_exp2 (enum machine_mode mode, rtx x);
 extern void spu_allocate_stack (rtx op0, rtx op1);
 extern void spu_restore_stack_nonlocal (rtx op0, rtx op1);
 extern void spu_restore_stack_block (rtx op0, rtx op1);
@@ -88,6 +89,7 @@
 extern void spu_expand_sign_extend (rtx ops[]);
 extern void spu_expand_vector_init (rtx target, rtx vals);
 extern void spu_init_expanders (void);
+extern void spu_split_convert (rtx *);
 
 /* spu-c.c */
 extern tree spu_resolve_overloaded_builtin (tree fndecl, tree fnargs);
diff -Naur gcc-4.4.2.orig/gcc/config.gcc gcc-4.4.2/gcc/config.gcc
--- gcc-4.4.2.orig/gcc/config.gcc	2009-09-13 09:01:13.000000000 -0400
+++ gcc-4.4.2/gcc/config.gcc	2009-11-18 19:33:32.632714000 -0500
@@ -2675,7 +2675,7 @@
 
 		case "$with_fpu" in
 		"" \
-		| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | neon )
+		| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | vfpv3 | vfpv3-d16 | neon )
 			# OK
 			;;
 		*)
diff -Naur gcc-4.4.2.orig/gcc/config.in gcc-4.4.2/gcc/config.in
--- gcc-4.4.2.orig/gcc/config.in	2009-10-15 03:55:16.000000000 -0400
+++ gcc-4.4.2/gcc/config.in	2009-10-19 08:15:27.233029000 -0400
@@ -839,6 +839,12 @@
 #endif
 
 
+/* Define 0/1 if your assembler supports .cfi_sections. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_GAS_CFI_SECTIONS_DIRECTIVE
+#endif
+
+
 /* Define if your assembler uses the new HImode fild and fist notation. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_GAS_FILDS_FISTS
diff -Naur gcc-4.4.2.orig/gcc/configure gcc-4.4.2/gcc/configure
--- gcc-4.4.2.orig/gcc/configure	2009-03-24 13:46:03.000000000 -0400
+++ gcc-4.4.2/gcc/configure	2009-10-19 08:15:27.233029000 -0400
@@ -21680,6 +21680,42 @@
 _ACEOF
 
 
+echo "$as_me:$LINENO: checking assembler for cfi sections directive" >&5
+echo $ECHO_N "checking assembler for cfi sections directive... $ECHO_C" >&6
+if test "${gcc_cv_as_cfi_sections_directive+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  gcc_cv_as_cfi_sections_directive=no
+  if test x$gcc_cv_as != x; then
+    echo '	.text
+	.cfi_sections .debug_frame, .eh_frame
+	.cfi_startproc
+	.cfi_endproc' > conftest.s
+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }
+    then
+	gcc_cv_as_cfi_sections_directive=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+echo "$as_me:$LINENO: result: $gcc_cv_as_cfi_sections_directive" >&5
+echo "${ECHO_T}$gcc_cv_as_cfi_sections_directive" >&6
+
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_GAS_CFI_SECTIONS_DIRECTIVE `if test $gcc_cv_as_cfi_sections_directive = yes;
+    then echo 1; else echo 0; fi`
+_ACEOF
+
+
 # GAS versions up to and including 2.11.0 may mis-optimize
 # .eh_frame data.
 echo "$as_me:$LINENO: checking assembler for eh_frame optimization" >&5
diff -Naur gcc-4.4.2.orig/gcc/configure.ac gcc-4.4.2/gcc/configure.ac
--- gcc-4.4.2.orig/gcc/configure.ac	2009-03-24 13:46:03.000000000 -0400
+++ gcc-4.4.2/gcc/configure.ac	2009-10-19 08:15:27.233029000 -0400
@@ -2297,6 +2297,17 @@
     then echo 1; else echo 0; fi`],
   [Define 0/1 if your assembler supports .cfi_personality.])
 
+gcc_GAS_CHECK_FEATURE([cfi sections directive],
+  gcc_cv_as_cfi_sections_directive, ,,
+[	.text
+	.cfi_sections .debug_frame, .eh_frame
+	.cfi_startproc
+	.cfi_endproc])
+AC_DEFINE_UNQUOTED(HAVE_GAS_CFI_SECTIONS_DIRECTIVE,
+  [`if test $gcc_cv_as_cfi_sections_directive = yes;
+    then echo 1; else echo 0; fi`],
+  [Define 0/1 if your assembler supports .cfi_sections.])
+
 # GAS versions up to and including 2.11.0 may mis-optimize
 # .eh_frame data.
 gcc_GAS_CHECK_FEATURE(eh_frame optimization, gcc_cv_as_eh_frame,
diff -Naur gcc-4.4.2.orig/gcc/cp/call.c gcc-4.4.2/gcc/cp/call.c
--- gcc-4.4.2.orig/gcc/cp/call.c	2009-09-24 08:49:25.000000000 -0400
+++ gcc-4.4.2/gcc/cp/call.c	2009-11-17 02:26:52.028023000 -0500
@@ -887,10 +887,7 @@
 	  || cp_type_quals (fbase) != cp_type_quals (tbase))
 	return NULL;
 
-      from = cp_build_qualified_type (tbase, cp_type_quals (fbase));
-      from = build_method_type_directly (from,
-					 TREE_TYPE (fromfn),
-					 TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));
+      from = build_memfn_type (fromfn, tbase, cp_type_quals (tbase));
       from = build_ptrmemfunc_type (build_pointer_type (from));
       conv = build_conv (ck_pmem, from, conv);
       conv->base_p = true;
@@ -1221,6 +1218,8 @@
 	  && CONSTRUCTOR_NELTS (expr) == 1)
 	{
 	  expr = CONSTRUCTOR_ELT (expr, 0)->value;
+	  if (error_operand_p (expr))
+	    return NULL;
 	  from = TREE_TYPE (expr);
 	}
     }
@@ -6327,8 +6326,9 @@
       /* We couldn't make up our minds; try to figure it out below.  */
     }
 
-  if (ics1->ellipsis_p)
-    /* Both conversions are ellipsis conversions.  */
+  if (ics1->ellipsis_p || ics1->kind == ck_list)
+    /* Both conversions are ellipsis conversions or both are building a
+       std::initializer_list.  */
     return 0;
 
   /* User-defined  conversion sequence U1 is a better conversion sequence
diff -Naur gcc-4.4.2.orig/gcc/cp/cp-tree.h gcc-4.4.2/gcc/cp/cp-tree.h
--- gcc-4.4.2.orig/gcc/cp/cp-tree.h	2009-09-18 17:53:23.000000000 -0400
+++ gcc-4.4.2/gcc/cp/cp-tree.h	2009-12-15 10:14:59.331382000 -0500
@@ -883,7 +883,8 @@
    expression for `*this'.  */
 
 #define current_class_ptr \
-  (cfun ? cp_function_chain->x_current_class_ptr : NULL_TREE)
+  (cfun && cp_function_chain					\
+   ? cp_function_chain->x_current_class_ptr : NULL_TREE)
 #define current_class_ref \
   (cfun ? cp_function_chain->x_current_class_ref : NULL_TREE)
 
diff -Naur gcc-4.4.2.orig/gcc/cp/decl2.c gcc-4.4.2/gcc/cp/decl2.c
--- gcc-4.4.2.orig/gcc/cp/decl2.c	2009-06-09 14:20:29.000000000 -0400
+++ gcc-4.4.2/gcc/cp/decl2.c	2009-11-07 14:45:56.972036000 -0500
@@ -108,20 +108,27 @@
 build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals)
 {
   tree raises;
+  tree attrs;
   int type_quals;
 
   if (fntype == error_mark_node || ctype == error_mark_node)
     return error_mark_node;
 
+  gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE
+	      || TREE_CODE (fntype) == METHOD_TYPE);
+
   type_quals = quals & ~TYPE_QUAL_RESTRICT;
   ctype = cp_build_qualified_type (ctype, type_quals);
+  raises = TYPE_RAISES_EXCEPTIONS (fntype);
+  attrs = TYPE_ATTRIBUTES (fntype);
   fntype = build_method_type_directly (ctype, TREE_TYPE (fntype),
 				       (TREE_CODE (fntype) == METHOD_TYPE
 					? TREE_CHAIN (TYPE_ARG_TYPES (fntype))
 					: TYPE_ARG_TYPES (fntype)));
-  raises = TYPE_RAISES_EXCEPTIONS (fntype);
   if (raises)
     fntype = build_exception_variant (fntype, raises);
+  if (attrs)
+    fntype = cp_build_type_attribute_variant (fntype, attrs);
 
   return fntype;
 }
@@ -3278,6 +3285,7 @@
 	    mark_decl_referenced (vtbl);
 	}
       else if (DECL_CONTEXT (t)
+	       && flag_use_repository
 	       && TREE_CODE (DECL_CONTEXT (t)) == FUNCTION_DECL)
 	/* If we need a static variable in a function, then we
 	   need the containing function.  */
diff -Naur gcc-4.4.2.orig/gcc/cp/decl.c gcc-4.4.2/gcc/cp/decl.c
--- gcc-4.4.2.orig/gcc/cp/decl.c	2009-10-07 15:31:56.000000000 -0400
+++ gcc-4.4.2/gcc/cp/decl.c	2009-12-16 13:02:38.797910000 -0500
@@ -7133,16 +7133,9 @@
 {
   if (TREE_CODE (member_type) == METHOD_TYPE)
     {
-      tree arg_types;
-
-      arg_types = TYPE_ARG_TYPES (member_type);
-      class_type = (cp_build_qualified_type
-		    (class_type,
-		     cp_type_quals (TREE_TYPE (TREE_VALUE (arg_types)))));
-      member_type
-	= build_method_type_directly (class_type,
-				      TREE_TYPE (member_type),
-				      TREE_CHAIN (arg_types));
+      tree arg_types = TYPE_ARG_TYPES (member_type);
+      cp_cv_quals quals = cp_type_quals (TREE_TYPE (TREE_VALUE (arg_types)));
+      member_type = build_memfn_type (member_type, class_type, quals);
       return build_ptrmemfunc_type (build_pointer_type (member_type));
     }
   else
@@ -7225,11 +7218,8 @@
 	 structural equality checks.  */
       itype = build_index_type (build_min (MINUS_EXPR, sizetype,
 					   size, integer_one_node));
-      if (!TREE_SIDE_EFFECTS (size))
-	{
-	  TYPE_DEPENDENT_P (itype) = 1;
-	  TYPE_DEPENDENT_P_VALID (itype) = 1;
-	}
+      TYPE_DEPENDENT_P (itype) = 1;
+      TYPE_DEPENDENT_P_VALID (itype) = 1;
       SET_TYPE_STRUCTURAL_EQUALITY (itype);
       return itype;
     }
@@ -8898,7 +8888,9 @@
       tree decls = NULL_TREE;
       tree args;
 
-      for (args = TYPE_ARG_TYPES (type); args; args = TREE_CHAIN (args))
+      for (args = TYPE_ARG_TYPES (type);
+	   args && args != void_list_node;
+	   args = TREE_CHAIN (args))
 	{
 	  tree decl = cp_build_parm_decl (NULL_TREE, TREE_VALUE (args));
 
diff -Naur gcc-4.4.2.orig/gcc/cp/mangle.c gcc-4.4.2/gcc/cp/mangle.c
--- gcc-4.4.2.orig/gcc/cp/mangle.c	2009-04-02 14:37:57.000000000 -0400
+++ gcc-4.4.2/gcc/cp/mangle.c	2009-12-22 09:28:55.905766000 -0500
@@ -2071,21 +2071,22 @@
 /* Non-terminal <template-args>.  ARGS is a TREE_VEC of template
    arguments.
 
-     <template-args> ::= I <template-arg>+ E  */
+     <template-args> ::= I <template-arg>* E  */
 
 static void
 write_template_args (tree args)
 {
   int i;
-  int length = TREE_VEC_LENGTH (args);
+  int length = 0;
 
   MANGLE_TRACE_TREE ("template-args", args);
 
   write_char ('I');
 
-  gcc_assert (length > 0);
+  if (args)
+    length = TREE_VEC_LENGTH (args);
 
-  if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)
+  if (args && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)
     {
       /* We have nested template args.  We want the innermost template
 	 argument list.  */
@@ -2109,12 +2110,7 @@
   if (TREE_CODE (member) == IDENTIFIER_NODE)
     write_source_name (member);
   else if (DECL_P (member))
-    {
-      /* G++ 3.2 incorrectly put out both the "sr" code and
-	 the nested name of the qualified name.  */
-      G.need_abi_warning = 1;
-      write_unqualified_name (member);
-    }
+    write_unqualified_name (member);
   else if (TREE_CODE (member) == TEMPLATE_ID_EXPR)
     {
       tree name = TREE_OPERAND (member, 0);
@@ -2212,17 +2208,27 @@
       write_string ("at");
       write_type (TREE_OPERAND (expr, 0));
     }
-  else if (abi_version_at_least (2) && TREE_CODE (expr) == SCOPE_REF)
+  else if (TREE_CODE (expr) == SCOPE_REF)
     {
       tree scope = TREE_OPERAND (expr, 0);
       tree member = TREE_OPERAND (expr, 1);
 
+      if (!abi_version_at_least (2))
+	{
+	  write_string ("sr");
+	  write_type (scope);
+	  /* G++ 3.2 incorrectly put out both the "sr" code and
+	     the nested name of the qualified name.  */
+	  G.need_abi_warning = 1;
+	  write_encoding (member);
+	}
+
       /* If the MEMBER is a real declaration, then the qualifying
 	 scope was not dependent.  Ideally, we would not have a
 	 SCOPE_REF in those cases, but sometimes we do.  If the second
 	 argument is a DECL, then the name must not have been
 	 dependent.  */
-      if (DECL_P (member))
+      else if (DECL_P (member))
 	write_expression (member);
       else
 	{
@@ -2387,12 +2393,6 @@
 	  sorry ("mangling new-expression");
 	  break;
 
-	/* Handle pointers-to-members specially.  */
-	case SCOPE_REF:
-	  write_type (TREE_OPERAND (expr, 0));
-	  write_member_name (TREE_OPERAND (expr, 1));
-	  break;
-
 	default:
 	  for (i = 0; i < TREE_OPERAND_LENGTH (expr); ++i)
 	    {
@@ -2748,7 +2748,7 @@
   finish_mangling_internal (warn);
   /* Don't obstack_finish here, and the next start_mangling will
      remove the identifier.  */
-  return get_identifier ((const char *) name_base);
+  return get_identifier ((const char *) obstack_base (mangle_obstack));
 }
 
 /* Initialize data structures for mangling.  */
diff -Naur gcc-4.4.2.orig/gcc/cp/method.c gcc-4.4.2/gcc/cp/method.c
--- gcc-4.4.2.orig/gcc/cp/method.c	2009-03-17 16:18:21.000000000 -0400
+++ gcc-4.4.2/gcc/cp/method.c	2009-11-04 14:55:56.458671000 -0500
@@ -380,7 +380,7 @@
   DECL_VISIBILITY (thunk_fndecl) = DECL_VISIBILITY (function);
   DECL_VISIBILITY_SPECIFIED (thunk_fndecl)
     = DECL_VISIBILITY_SPECIFIED (function);
-  if (DECL_ONE_ONLY (function))
+  if (DECL_ONE_ONLY (function) || DECL_WEAK (function))
     make_decl_one_only (thunk_fndecl);
 
   if (flag_syntax_only)
diff -Naur gcc-4.4.2.orig/gcc/cp/name-lookup.c gcc-4.4.2/gcc/cp/name-lookup.c
--- gcc-4.4.2.orig/gcc/cp/name-lookup.c	2009-04-14 13:14:04.000000000 -0400
+++ gcc-4.4.2/gcc/cp/name-lookup.c	2009-11-03 16:33:55.537602000 -0500
@@ -3905,6 +3905,19 @@
   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);
 }
 
+/* Returns true iff VEC contains TARGET.  */
+
+static bool
+tree_vec_contains (VEC(tree,gc)* vec, tree target)
+{
+  unsigned int i;
+  tree elt;
+  for (i = 0; VEC_iterate(tree,vec,i,elt); ++i)
+    if (elt == target)
+      return true;
+  return false;
+}
+
 /* [namespace.qual]
    Accepts the NAME to lookup and its qualifying SCOPE.
    Returns the name/type pair found into the cxx_binding *RESULT,
@@ -3915,62 +3928,72 @@
 				  struct scope_binding *result, int flags)
 {
   /* Maintain a list of namespaces visited...  */
-  tree seen = NULL_TREE;
+  VEC(tree,gc) *seen = NULL;
+  VEC(tree,gc) *seen_inline = NULL;
   /* ... and a list of namespace yet to see.  */
-  tree todo = NULL_TREE;
-  tree todo_maybe = NULL_TREE;
+  VEC(tree,gc) *todo = NULL;
+  VEC(tree,gc) *todo_maybe = NULL;
+  VEC(tree,gc) *todo_inline = NULL;
   tree usings;
   timevar_push (TV_NAME_LOOKUP);
   /* Look through namespace aliases.  */
   scope = ORIGINAL_NAMESPACE (scope);
-  while (scope && result->value != error_mark_node)
-    {
-      cxx_binding *binding =
-	cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);
-      seen = tree_cons (scope, NULL_TREE, seen);
-      if (binding)
-	ambiguous_decl (result, binding, flags);
 
-      /* Consider strong using directives always, and non-strong ones
-	 if we haven't found a binding yet.  ??? Shouldn't we consider
-	 non-strong ones if the initial RESULT is non-NULL, but the
-	 binding in the given namespace is?  */
-      for (usings = DECL_NAMESPACE_USING (scope); usings;
-	   usings = TREE_CHAIN (usings))
-	/* If this was a real directive, and we have not seen it.  */
-	if (!TREE_INDIRECT_USING (usings))
-	  {
-	    /* Try to avoid queuing the same namespace more than once,
-	       the exception being when a namespace was already
-	       enqueued for todo_maybe and then a strong using is
-	       found for it.  We could try to remove it from
-	       todo_maybe, but it's probably not worth the effort.  */
-	    if (is_associated_namespace (scope, TREE_PURPOSE (usings))
-		&& !purpose_member (TREE_PURPOSE (usings), seen)
-		&& !purpose_member (TREE_PURPOSE (usings), todo))
-	      todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);
-	    else if ((!result->value && !result->type)
-		     && !purpose_member (TREE_PURPOSE (usings), seen)
-		     && !purpose_member (TREE_PURPOSE (usings), todo)
-		     && !purpose_member (TREE_PURPOSE (usings), todo_maybe))
-	      todo_maybe = tree_cons (TREE_PURPOSE (usings), NULL_TREE,
-				      todo_maybe);
-	  }
-      if (todo)
-	{
-	  scope = TREE_PURPOSE (todo);
-	  todo = TREE_CHAIN (todo);
-	}
-      else if (todo_maybe
-	       && (!result->value && !result->type))
+  /* Algorithm: Starting with SCOPE, walk through the the set of used
+     namespaces.  For each used namespace, look through its inline
+     namespace set for any bindings and usings.  If no bindings are found,
+     add any usings seen to the set of used namespaces.  */
+  VEC_safe_push (tree, gc, todo, scope);
+
+  while (VEC_length (tree, todo))
+    {
+      bool found_here;
+      scope = VEC_pop (tree, todo);
+      if (tree_vec_contains (seen, scope))
+	continue;
+      VEC_safe_push (tree, gc, seen, scope);
+      VEC_safe_push (tree, gc, todo_inline, scope);
+
+      found_here = false;
+      while (VEC_length (tree, todo_inline))
 	{
-	  scope = TREE_PURPOSE (todo_maybe);
-	  todo = TREE_CHAIN (todo_maybe);
-	  todo_maybe = NULL_TREE;
+	  cxx_binding *binding;
+
+	  scope = VEC_pop (tree, todo_inline);
+	  if (tree_vec_contains (seen_inline, scope))
+	    continue;
+	  VEC_safe_push (tree, gc, seen_inline, scope);
+
+	  binding =
+	    cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);
+	  if (binding)
+	    {
+	      found_here = true;
+	      ambiguous_decl (result, binding, flags);
+	    }
+
+	  for (usings = DECL_NAMESPACE_USING (scope); usings;
+	       usings = TREE_CHAIN (usings))
+	    if (!TREE_INDIRECT_USING (usings))
+	      {
+		if (is_associated_namespace (scope, TREE_PURPOSE (usings)))
+		  VEC_safe_push (tree, gc, todo_inline, TREE_PURPOSE (usings));
+		else
+		  VEC_safe_push (tree, gc, todo_maybe, TREE_PURPOSE (usings));
+	      }
 	}
+
+      if (found_here)
+	VEC_truncate (tree, todo_maybe, 0);
       else
-	scope = NULL_TREE; /* If there never was a todo list.  */
+	while (VEC_length (tree, todo_maybe))
+	  VEC_safe_push (tree, gc, todo, VEC_pop (tree, todo_maybe));
     }
+  VEC_free (tree,gc,todo);
+  VEC_free (tree,gc,todo_maybe);
+  VEC_free (tree,gc,todo_inline);
+  VEC_free (tree,gc,seen);
+  VEC_free (tree,gc,seen_inline);
   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);
 }
 
diff -Naur gcc-4.4.2.orig/gcc/cp/parser.c gcc-4.4.2/gcc/cp/parser.c
--- gcc-4.4.2.orig/gcc/cp/parser.c	2009-08-31 17:20:07.000000000 -0400
+++ gcc-4.4.2/gcc/cp/parser.c	2009-11-09 15:28:18.966614000 -0500
@@ -1198,8 +1198,12 @@
   /* The construct is optional.  If it is not present, then no error
      should be issued.  */
   CP_PARSER_FLAGS_OPTIONAL = 0x1,
-  /* When parsing a type-specifier, do not allow user-defined types.  */
-  CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES = 0x2
+  /* When parsing a type-specifier, treat user-defined type-names
+     as non-type identifiers.  */
+  CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES = 0x2,
+  /* When parsing a type-specifier, do not try to parse a class-specifier
+     or enum-specifier.  */
+  CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS = 0x4
 } cp_parser_flags;
 
 /* The different kinds of declarators we want to parse.  */
@@ -1735,10 +1739,11 @@
   (cp_parser *);
 static tree cp_parser_template_type_arg
   (cp_parser *);
+static tree cp_parser_trailing_type_id (cp_parser *);
 static tree cp_parser_type_id_1
-  (cp_parser *, bool);
+  (cp_parser *, bool, bool);
 static void cp_parser_type_specifier_seq
-  (cp_parser *, bool, cp_decl_specifier_seq *);
+  (cp_parser *, bool, bool, cp_decl_specifier_seq *);
 static tree cp_parser_parameter_declaration_clause
   (cp_parser *);
 static tree cp_parser_parameter_declaration_list
@@ -5740,6 +5745,7 @@
     = "types may not be defined in a new-type-id";
   /* Parse the type-specifier-seq.  */
   cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+				/*is_trailing_return=*/false,
 				&type_specifier_seq);
   /* Restore the old message.  */
   parser->type_definition_forbidden_message = saved_message;
@@ -7414,6 +7420,7 @@
     = "types may not be defined in conditions";
   /* Parse the type-specifier-seq.  */
   cp_parser_type_specifier_seq (parser, /*is_condition==*/true,
+				/*is_trailing_return=*/false,
 				&type_specifiers);
   /* Restore the saved message.  */
   parser->type_definition_forbidden_message = saved_message;
@@ -8918,12 +8925,25 @@
     cp_parser_parse_definitely (parser);
   else
     {
+      bool saved_greater_than_is_operator_p;
+
       /* Abort our attempt to parse an id-expression or member access
          expression.  */
       cp_parser_abort_tentative_parse (parser);
 
+      /* Within a parenthesized expression, a `>' token is always
+	 the greater-than operator.  */
+      saved_greater_than_is_operator_p
+	= parser->greater_than_is_operator_p;
+      parser->greater_than_is_operator_p = true;
+
       /* Parse a full expression.  */
       expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);
+
+      /* The `>' token might be the end of a template-id or
+	 template-parameter-list now.  */
+      parser->greater_than_is_operator_p
+	= saved_greater_than_is_operator_p;
     }
 
   /* Go back to evaluating expressions.  */
@@ -9032,6 +9052,7 @@
   attributes = cp_parser_attributes_opt (parser);
   /* Parse the type-specifiers.  */
   cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+				/*is_trailing_return=*/false,
 				&type_specifiers);
   /* If that didn't work, stop.  */
   if (type_specifiers.type == error_mark_node)
@@ -10679,18 +10700,26 @@
 	cp_parser_abort_tentative_parse (parser);
       else
 	{
+	  tree probe;
+
 	  if (TREE_CODE (argument) == INDIRECT_REF)
 	    {
 	      gcc_assert (REFERENCE_REF_P (argument));
 	      argument = TREE_OPERAND (argument, 0);
 	    }
 
-	  if (TREE_CODE (argument) == VAR_DECL)
+	  /* If we're in a template, we represent a qualified-id referring
+	     to a static data member as a SCOPE_REF even if the scope isn't
+	     dependent so that we can check access control later.  */
+	  probe = argument;
+	  if (TREE_CODE (probe) == SCOPE_REF)
+	    probe = TREE_OPERAND (probe, 1);
+	  if (TREE_CODE (probe) == VAR_DECL)
 	    {
 	      /* A variable without external linkage might still be a
 		 valid constant-expression, so no error is issued here
 		 if the external-linkage check fails.  */
-	      if (!address_p && !DECL_EXTERNAL_LINKAGE_P (argument))
+	      if (!address_p && !DECL_EXTERNAL_LINKAGE_P (probe))
 		cp_parser_simulate_error (parser);
 	    }
 	  else if (is_overloaded_fn (argument))
@@ -10994,6 +11023,9 @@
   switch (keyword)
     {
     case RID_ENUM:
+      if ((flags & CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS))
+	goto elaborated_type_specifier;
+
       /* Look for the enum-specifier.  */
       type_spec = cp_parser_enum_specifier (parser);
       /* If that worked, we're done.  */
@@ -11016,6 +11048,9 @@
     case RID_CLASS:
     case RID_STRUCT:
     case RID_UNION:
+      if ((flags & CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS))
+	goto elaborated_type_specifier;
+
       /* Parse tentatively so that we can back up if we don't find a
 	 class-specifier.  */
       cp_parser_parse_tentatively (parser);
@@ -11882,6 +11917,7 @@
 
       /* Parse the type-specifier-seq.  */
       cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+				    /*is_trailing_return=*/false,
                                     &type_specifiers);
 
       /* At this point this is surely not elaborated type specifier.  */
@@ -13713,7 +13749,7 @@
 /* Parse a late-specified return type, if any.  This is not a separate
    non-terminal, but part of a function declarator, which looks like
 
-   -> type-id
+   -> trailing-type-specifier-seq abstract-declarator(opt)
 
    Returns the type indicated by the type-id.  */
 
@@ -13731,7 +13767,7 @@
   /* Consume the ->.  */
   cp_lexer_consume_token (parser->lexer);
 
-  return cp_parser_type_id (parser);
+  return cp_parser_trailing_type_id (parser);
 }
 
 /* Parse a declarator-id.
@@ -13784,13 +13820,15 @@
    Returns the TYPE specified.  */
 
 static tree
-cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg)
+cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg,
+		     bool is_trailing_return)
 {
   cp_decl_specifier_seq type_specifier_seq;
   cp_declarator *abstract_declarator;
 
   /* Parse the type-specifier-seq.  */
   cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+				is_trailing_return,
 				&type_specifier_seq);
   if (type_specifier_seq.type == error_mark_node)
     return error_mark_node;
@@ -13828,12 +13866,17 @@
 
 static tree cp_parser_type_id (cp_parser *parser)
 {
-  return cp_parser_type_id_1 (parser, false);
+  return cp_parser_type_id_1 (parser, false, false);
 }
 
 static tree cp_parser_template_type_arg (cp_parser *parser)
 {
-  return cp_parser_type_id_1 (parser, true);
+  return cp_parser_type_id_1 (parser, true, false);
+}
+
+static tree cp_parser_trailing_type_id (cp_parser *parser)
+{
+  return cp_parser_type_id_1 (parser, false, true);
 }
 
 /* Parse a type-specifier-seq.
@@ -13849,11 +13892,15 @@
    If IS_CONDITION is true, we are at the start of a "condition",
    e.g., we've just seen "if (".
 
+   If IS_TRAILING_RETURN is true, we are in a trailing-return-type,
+   i.e. we've just seen "->".
+
    Sets *TYPE_SPECIFIER_SEQ to represent the sequence.  */
 
 static void
 cp_parser_type_specifier_seq (cp_parser* parser,
 			      bool is_condition,
+			      bool is_trailing_return,
 			      cp_decl_specifier_seq *type_specifier_seq)
 {
   bool seen_type_specifier = false;
@@ -13863,6 +13910,12 @@
   /* Clear the TYPE_SPECIFIER_SEQ.  */
   clear_decl_specs (type_specifier_seq);
 
+  /* In the context of a trailing return type, enum E { } is an
+     elaborated-type-specifier followed by a function-body, not an
+     enum-specifier.  */
+  if (is_trailing_return)
+    flags |= CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS;
+
   /* Parse the type-specifiers and attributes.  */
   while (true)
     {
@@ -16565,7 +16618,8 @@
     = "types may not be defined in exception-declarations";
 
   /* Parse the type-specifier-seq.  */
-  cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+  cp_parser_type_specifier_seq (parser, /*is_declaration=*/true,
+				/*is_trailing_return=*/false,
 				&type_specifiers);
   /* If it's a `)', then there is no declarator.  */
   if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))
@@ -21249,7 +21303,8 @@
 	     cp_parser_condition, from whence the bulk of this is copied.  */
 
 	  cp_parser_parse_tentatively (parser);
-	  cp_parser_type_specifier_seq (parser, /*is_condition=*/false,
+	  cp_parser_type_specifier_seq (parser, /*is_declaration=*/true,
+					/*is_trailing_return=*/false,
 					&type_specifiers);
 	  if (cp_parser_parse_definitely (parser))
 	    {
@@ -21567,7 +21622,8 @@
 	    }
 	  collapse_err = true;
 	  cp_parser_statement_seq_opt (parser, NULL);
-	  cp_parser_require (parser, CPP_CLOSE_BRACE, "%<}%>");
+	  if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))
+	    break;
 	}
     }
 
diff -Naur gcc-4.4.2.orig/gcc/cp/pt.c gcc-4.4.2/gcc/cp/pt.c
--- gcc-4.4.2.orig/gcc/cp/pt.c	2009-10-07 15:31:56.000000000 -0400
+++ gcc-4.4.2/gcc/cp/pt.c	2009-12-11 00:26:51.646319000 -0500
@@ -2780,6 +2780,8 @@
   for (in_arg = 0; in_arg < nargs; ++in_arg)
     {
       tree arg = TREE_VEC_ELT (args, in_arg);
+      if (arg == NULL_TREE)
+	return args;
       if (ARGUMENT_PACK_P (arg))
         {
           int num_packed = TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg));
@@ -3670,7 +3672,8 @@
   else if (is_friend_decl)
     msg = "default template arguments may not be used in function template friend declarations";
   else if (TREE_CODE (decl) == FUNCTION_DECL && (cxx_dialect == cxx98))
-    msg = "default template arguments may not be used in function templates";
+    msg = ("default template arguments may not be used in function templates "
+	   "without -std=c++0x or -std=gnu++0x");
   else if (is_partial)
     msg = "default template arguments may not be used in partial specializations";
   else
@@ -4321,6 +4324,22 @@
   return fn;
 }
 
+/* Subroutine of convert_nontype_argument.
+   Check if EXPR of type TYPE is a valid pointer-to-member constant.
+   Emit an error otherwise.  */
+
+static bool
+check_valid_ptrmem_cst_expr (tree type, tree expr)
+{
+  STRIP_NOPS (expr);
+  if (expr && (null_ptr_cst_p (expr) || TREE_CODE (expr) == PTRMEM_CST))
+    return true;
+  error ("%qE is not a valid template argument for type %qT",
+	 expr, type);
+  error ("it must be a pointer-to-member of the form `&X::Y'");
+  return false;
+}
+
 /* Attempt to convert the non-type template parameter EXPR to the
    indicated TYPE.  If the conversion is successful, return the
    converted value.  If the conversion is unsuccessful, return
@@ -4620,6 +4639,11 @@
       if (expr == error_mark_node)
 	return error_mark_node;
 
+      /* [temp.arg.nontype] bullet 1 says the pointer to member
+         expression must be a pointer-to-member constant.  */
+      if (!check_valid_ptrmem_cst_expr (type, expr))
+	return error_mark_node;
+
       /* There is no way to disable standard conversions in
 	 resolve_address_of_overloaded_function (called by
 	 instantiate_type). It is possible that the call succeeded by
@@ -4646,6 +4670,11 @@
      qualification conversions (_conv.qual_) are applied.  */
   else if (TYPE_PTRMEM_P (type))
     {
+      /* [temp.arg.nontype] bullet 1 says the pointer to member
+         expression must be a pointer-to-member constant.  */
+      if (!check_valid_ptrmem_cst_expr (type, expr))
+	return error_mark_node;
+
       expr = perform_qualification_conversions (type, expr);
       if (expr == error_mark_node)
 	return expr;
@@ -5061,7 +5090,7 @@
 		      error ("type/value mismatch at argument %d in "
 			     "template parameter list for %qD",
 			     i + 1, in_decl);
-		      error ("  expected a template of type %qD, got %qD",
+		      error ("  expected a template of type %qD, got %qT",
 			     parm, orig_arg);
 		    }
 
@@ -9575,13 +9604,8 @@
 	  {
 	    /* The type of the implicit object parameter gets its
 	       cv-qualifiers from the FUNCTION_TYPE. */
-	    tree method_type;
-	    tree this_type = cp_build_qualified_type (TYPE_MAIN_VARIANT (r),
-						      cp_type_quals (type));
 	    tree memptr;
-	    method_type = build_method_type_directly (this_type,
-						      TREE_TYPE (type),
-						      TYPE_ARG_TYPES (type));
+	    tree method_type = build_memfn_type (type, r, cp_type_quals (type));
 	    memptr = build_ptrmemfunc_type (build_pointer_type (method_type));
 	    return cp_build_qualified_type_real (memptr, cp_type_quals (t),
 						 complain);
@@ -9866,7 +9890,7 @@
     qualifying_scope = tsubst (qualifying_scope, args,
 			       complain, in_decl);
     fns = BASELINK_FUNCTIONS (baselink);
-    optype = BASELINK_OPTYPE (baselink);
+    optype = tsubst (BASELINK_OPTYPE (baselink), args, complain, in_decl);
     if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)
       {
 	template_id_p = true;
@@ -9877,6 +9901,8 @@
 						complain, in_decl);
       }
     name = DECL_NAME (get_first_fn (fns));
+    if (IDENTIFIER_TYPENAME_P (name))
+      name = mangle_conv_op_name_for_type (optype);
     baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);
 
     /* If lookup found a single function, mark it as used at this
@@ -9895,8 +9921,7 @@
 		    BASELINK_FUNCTIONS (baselink),
 		    template_args);
     /* Update the conversion operator type.  */
-    BASELINK_OPTYPE (baselink) 
-      = tsubst (optype, args, complain, in_decl);
+    BASELINK_OPTYPE (baselink) = optype;
 
     if (!object_type)
       object_type = current_class_type;
@@ -12657,9 +12682,11 @@
 	     to explicitly check cxx_dialect here.  */
           if (TREE_PURPOSE (TREE_VEC_ELT (tparms, i)))
             {
-              tree arg = tsubst_template_arg
-				(TREE_PURPOSE (TREE_VEC_ELT (tparms, i)),
-				 targs, tf_none, NULL_TREE);
+	      tree parm = TREE_VALUE (TREE_VEC_ELT (tparms, i));
+	      tree arg = TREE_PURPOSE (TREE_VEC_ELT (tparms, i));
+              arg = tsubst_template_arg (arg, targs, tf_none, NULL_TREE);
+	      arg = convert_template_argument (parm, arg, targs, tf_none,
+					       i, NULL_TREE);
               if (arg == error_mark_node)
                 return 1;
               else
diff -Naur gcc-4.4.2.orig/gcc/cp/semantics.c gcc-4.4.2/gcc/cp/semantics.c
--- gcc-4.4.2.orig/gcc/cp/semantics.c	2009-07-14 14:35:13.000000000 -0400
+++ gcc-4.4.2/gcc/cp/semantics.c	2009-11-13 13:03:31.906492000 -0500
@@ -1467,6 +1467,14 @@
 
       return build_min (COMPONENT_REF, type, object, decl, NULL_TREE);
     }
+  /* If PROCESSING_TEMPLATE_DECL is nonzero here, then
+     QUALIFYING_SCOPE is also non-null.  Wrap this in a SCOPE_REF
+     for now.  */
+  else if (processing_template_decl)
+    return build_qualified_name (TREE_TYPE (decl),
+				 qualifying_scope,
+				 DECL_NAME (decl),
+				 /*template_p=*/false);
   else
     {
       tree access_type = TREE_TYPE (object);
@@ -1486,15 +1494,6 @@
 	    }
 	}
 
-      /* If PROCESSING_TEMPLATE_DECL is nonzero here, then
-	 QUALIFYING_SCOPE is also non-null.  Wrap this in a SCOPE_REF
-	 for now.  */
-      if (processing_template_decl)
-	return build_qualified_name (TREE_TYPE (decl),
-				     qualifying_scope,
-				     DECL_NAME (decl),
-				     /*template_p=*/false);
-
       perform_or_defer_access_check (TYPE_BINFO (access_type), decl,
 				     decl);
 
diff -Naur gcc-4.4.2.orig/gcc/cp/tree.c gcc-4.4.2/gcc/cp/tree.c
--- gcc-4.4.2.orig/gcc/cp/tree.c	2009-10-07 15:31:56.000000000 -0400
+++ gcc-4.4.2/gcc/cp/tree.c	2009-11-07 14:45:56.972036000 -0500
@@ -922,10 +922,14 @@
 tree
 canonical_type_variant (tree t)
 {
+  tree r;
+
   if (t == error_mark_node)
     return error_mark_node;
 
-  return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), cp_type_quals (t));
+  r = cp_build_type_attribute_variant (TYPE_MAIN_VARIANT (t),
+				       TYPE_ATTRIBUTES (t));
+  return cp_build_qualified_type (r, cp_type_quals (t));
 }
 
 /* Makes a copy of BINFO and TYPE, which is to be inherited into a
@@ -1909,6 +1913,8 @@
     case TEMPLATE_PARM_INDEX:
       return (TEMPLATE_PARM_IDX (t1) == TEMPLATE_PARM_IDX (t2)
 	      && TEMPLATE_PARM_LEVEL (t1) == TEMPLATE_PARM_LEVEL (t2)
+	      && (TEMPLATE_PARM_PARAMETER_PACK (t1)
+		  == TEMPLATE_PARM_PARAMETER_PACK (t2))
 	      && same_type_p (TREE_TYPE (TEMPLATE_PARM_DECL (t1)),
 			      TREE_TYPE (TEMPLATE_PARM_DECL (t2))));
 
diff -Naur gcc-4.4.2.orig/gcc/cp/typeck.c gcc-4.4.2/gcc/cp/typeck.c
--- gcc-4.4.2.orig/gcc/cp/typeck.c	2009-07-13 02:06:27.000000000 -0400
+++ gcc-4.4.2/gcc/cp/typeck.c	2009-12-26 11:24:53.468272000 -0500
@@ -5463,12 +5463,17 @@
 		 intype, type);
 
       expr = cp_build_unary_op (ADDR_EXPR, expr, 0, complain);
+
+      if (warn_strict_aliasing > 2)
+	strict_aliasing_warning (TREE_TYPE (expr), type, expr);
+
       if (expr != error_mark_node)
 	expr = build_reinterpret_cast_1
 	  (build_pointer_type (TREE_TYPE (type)), expr, c_cast_p,
 	   valid_p, complain);
       if (expr != error_mark_node)
-	expr = cp_build_indirect_ref (expr, 0, complain);
+	/* cp_build_indirect_ref isn't right for rvalue refs.  */
+	expr = convert_from_reference (fold_convert (type, expr));
       return expr;
     }
 
@@ -6091,11 +6096,15 @@
     {
       int from_array;
 
-      if (BRACE_ENCLOSED_INITIALIZER_P (rhs))
-	rhs = digest_init (lhstype, rhs);
+      if (BRACE_ENCLOSED_INITIALIZER_P (newrhs))
+	{
+	  if (check_array_initializer (lhs, lhstype, newrhs))
+	    return error_mark_node;
+	  newrhs = digest_init (lhstype, newrhs);
+	}
 
       else if (!same_or_base_type_p (TYPE_MAIN_VARIANT (lhstype),
-				     TYPE_MAIN_VARIANT (TREE_TYPE (rhs))))
+				     TYPE_MAIN_VARIANT (TREE_TYPE (newrhs))))
 	{
 	  if (complain & tf_error)
 	    error ("incompatible types in assignment of %qT to %qT",
diff -Naur gcc-4.4.2.orig/gcc/c-pragma.c gcc-4.4.2/gcc/c-pragma.c
--- gcc-4.4.2.orig/gcc/c-pragma.c	2008-08-30 19:50:40.000000000 -0400
+++ gcc-4.4.2/gcc/c-pragma.c	2009-11-11 15:21:14.372933000 -0500
@@ -244,146 +244,6 @@
 }
 #endif  /* HANDLE_PRAGMA_PACK */
 
-struct def_pragma_macro_value GTY(())
-{
-  struct def_pragma_macro_value *prev;
-  cpp_macro *value;
-};
-
-struct def_pragma_macro GTY(())
-{
-  hashval_t hash;
-  const char *name;
-  struct def_pragma_macro_value value;
-};
-
-static GTY((param_is (struct def_pragma_macro))) htab_t pushed_macro_table;
-
-#ifdef HANDLE_PRAGMA_PUSH_POP_MACRO
-/* Hash table control functions for pushed_macro_table.  */
-static hashval_t
-dpm_hash (const void *p)
-{
-  return ((const struct def_pragma_macro *)p)->hash;
-}
-
-static int
-dpm_eq (const void *pa, const void *pb)
-{
-  const struct def_pragma_macro *const a = (const struct def_pragma_macro *) pa,
-    *const b = (const struct def_pragma_macro *) pb;
-  return a->hash == b->hash && strcmp (a->name, b->name) == 0;
-}
-
-/* #pragma push_macro("MACRO_NAME")
-   #pragma pop_macro("MACRO_NAME") */
-
-static void
-handle_pragma_push_macro (cpp_reader *reader)
-{
-  tree x, id = 0;
-  enum cpp_ttype token;
-  struct def_pragma_macro dummy, *c;
-  const char *macroname;
-  void **slot;
-
-  if (pragma_lex (&x) != CPP_OPEN_PAREN)
-    GCC_BAD ("missing %<(%> after %<#pragma push_macro%> - ignored");
-
-  token = pragma_lex (&id);
-
-  /* Silently ignore */
-  if (token == CPP_CLOSE_PAREN)
-    return;
-  if (token != CPP_STRING)
-    GCC_BAD ("invalid constant in %<#pragma push_macro%> - ignored");
-
-  if (pragma_lex (&x) != CPP_CLOSE_PAREN)
-    GCC_BAD ("missing %<)%> after %<#pragma push_macro%> - ignored");
-
-  if (pragma_lex (&x) != CPP_EOF)
-    warning (OPT_Wpragmas, "junk at end of %<#pragma push_macro%>");
-
-  /* Check for empty string, and silently ignore.  */
-  if (TREE_STRING_LENGTH (id) < 1)
-    return;
-  macroname = TREE_STRING_POINTER (id);
-
-  if (pushed_macro_table == NULL)
-    pushed_macro_table = htab_create_ggc (15, dpm_hash, dpm_eq, 0);
-
-  dummy.hash = htab_hash_string (macroname);
-  dummy.name = macroname;
-  slot = htab_find_slot_with_hash (pushed_macro_table, &dummy,
-				   dummy.hash, INSERT);
-  c = (struct def_pragma_macro *) *slot;
-  if (c == NULL)
-    {
-      *slot = c = GGC_NEW (struct def_pragma_macro);
-      c->hash = dummy.hash;
-      c->name = ggc_alloc_string (macroname, TREE_STRING_LENGTH (id) - 1);
-      c->value.prev = NULL;
-    }
-  else
-    {
-      struct def_pragma_macro_value *v;
-      v = GGC_NEW (struct def_pragma_macro_value);
-      *v = c->value;
-      c->value.prev = v;
-    }
-
-  c->value.value = cpp_push_definition (reader, macroname);
-}
-
-static void
-handle_pragma_pop_macro (cpp_reader *reader)
-{
-  tree x, id = 0;
-  enum cpp_ttype token;
-  struct def_pragma_macro dummy, *c;
-  const char *macroname;
-  void **slot = NULL;
-
-  if (pragma_lex (&x) != CPP_OPEN_PAREN)
-    GCC_BAD ("missing %<(%> after %<#pragma pop_macro%> - ignored");
-
-  token = pragma_lex (&id);
-
-  /* Silently ignore */
-  if (token == CPP_CLOSE_PAREN)
-    return;
-  if (token != CPP_STRING)
-    GCC_BAD ("invalid constant in %<#pragma pop_macro%> - ignored");
-
-  if (pragma_lex (&x) != CPP_CLOSE_PAREN)
-    GCC_BAD ("missing %<)%> after %<#pragma pop_macro%> - ignored");
-
-  if (pragma_lex (&x) != CPP_EOF)
-    warning (OPT_Wpragmas, "junk at end of %<#pragma pop_macro%>");
-
-  /* Check for empty string, and silently ignore.  */
-  if (TREE_STRING_LENGTH (id) < 1)
-    return;
-  macroname = TREE_STRING_POINTER (id);
-
-  dummy.hash = htab_hash_string (macroname);
-  dummy.name = macroname;
-  if (pushed_macro_table)
-    slot = htab_find_slot_with_hash (pushed_macro_table, &dummy,
-				     dummy.hash, NO_INSERT);
-  if (slot == NULL)
-    return;
-  c = (struct def_pragma_macro *) *slot;
-
-  cpp_pop_definition (reader, c->name, c->value.value);
-
-  if (c->value.prev)
-    c->value = *c->value.prev;
-  else
-    htab_clear_slot (pushed_macro_table, slot);
-}
-#endif /* HANDLE_PRAGMA_PUSH_POP_MACRO */
-
 static GTY(()) tree pending_weaks;
 
 #ifdef HANDLE_PRAGMA_WEAK
@@ -1316,10 +1176,6 @@
   c_register_pragma (0, "pack", handle_pragma_pack);
 #endif
 #endif
-#ifdef HANDLE_PRAGMA_PUSH_POP_MACRO
-  c_register_pragma (0 ,"push_macro", handle_pragma_push_macro);
-  c_register_pragma (0 ,"pop_macro", handle_pragma_pop_macro);
-#endif
 #ifdef HANDLE_PRAGMA_WEAK
   c_register_pragma (0, "weak", handle_pragma_weak);
 #endif
diff -Naur gcc-4.4.2.orig/gcc/c-typeck.c gcc-4.4.2/gcc/c-typeck.c
--- gcc-4.4.2.orig/gcc/c-typeck.c	2009-09-23 05:37:25.000000000 -0400
+++ gcc-4.4.2/gcc/c-typeck.c	2009-10-27 12:05:36.071308000 -0400
@@ -2527,6 +2527,7 @@
 {
   tree typetail, valtail;
   int parmnum;
+  bool error_args = false;
   const bool type_generic = fundecl
     && lookup_attribute ("type generic", TYPE_ATTRIBUTES(TREE_TYPE (fundecl)));
   tree selector;
@@ -2737,6 +2738,9 @@
 	/* Convert `short' and `char' to full-size `int'.  */
 	argarray[parmnum] = default_conversion (val);
 
+      if (argarray[parmnum] == error_mark_node)
+	error_args = true;
+
       if (typetail)
 	typetail = TREE_CHAIN (typetail);
     }
@@ -2749,7 +2753,7 @@
       return -1;
     }
 
-  return parmnum;
+  return error_args ? -1 : parmnum;
 }
 
 /* This is the entry point used by the parser to build unary operators
diff -Naur gcc-4.4.2.orig/gcc/DATESTAMP gcc-4.4.2/gcc/DATESTAMP
--- gcc-4.4.2.orig/gcc/DATESTAMP	2009-10-14 20:16:51.000000000 -0400
+++ gcc-4.4.2/gcc/DATESTAMP	2009-12-31 19:16:43.456223000 -0500
@@ -1 +1 @@
-20091015
+20100101
diff -Naur gcc-4.4.2.orig/gcc/dbxout.c gcc-4.4.2/gcc/dbxout.c
--- gcc-4.4.2.orig/gcc/dbxout.c	2009-07-07 16:46:41.000000000 -0400
+++ gcc-4.4.2/gcc/dbxout.c	2009-10-19 08:15:27.233029000 -0400
@@ -349,6 +349,7 @@
 {
   dbxout_init,
   dbxout_finish,
+  debug_nothing_void,
   debug_nothing_int_charstar,
   debug_nothing_int_charstar,
   dbxout_start_source_file,
@@ -385,6 +386,7 @@
 {
   dbxout_init,
   dbxout_finish,
+  debug_nothing_void,
   debug_nothing_int_charstar,
   debug_nothing_int_charstar,
   dbxout_start_source_file,
diff -Naur gcc-4.4.2.orig/gcc/debug.c gcc-4.4.2/gcc/debug.c
--- gcc-4.4.2.orig/gcc/debug.c	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/debug.c	2009-10-19 08:15:27.233029000 -0400
@@ -27,6 +27,7 @@
 {
   debug_nothing_charstar,
   debug_nothing_charstar,
+  debug_nothing_void,
   debug_nothing_int_charstar,
   debug_nothing_int_charstar,
   debug_nothing_int_charstar,
diff -Naur gcc-4.4.2.orig/gcc/debug.h gcc-4.4.2/gcc/debug.h
--- gcc-4.4.2.orig/gcc/debug.h	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/debug.h	2009-10-19 08:15:27.233029000 -0400
@@ -31,6 +31,10 @@
   /* Output debug symbols.  */
   void (* finish) (const char *main_filename);
 
+  /* Called from cgraph_optimize before starting to assemble
+     functions/variables/toplevel asms.  */
+  void (* assembly_start) (void);
+
   /* Macro defined on line LINE with name and expansion TEXT.  */
   void (* define) (unsigned int line, const char *text);
 
diff -Naur gcc-4.4.2.orig/gcc/doc/invoke.texi gcc-4.4.2/gcc/doc/invoke.texi
--- gcc-4.4.2.orig/gcc/doc/invoke.texi	2009-09-18 17:53:23.000000000 -0400
+++ gcc-4.4.2/gcc/doc/invoke.texi	2009-10-21 11:44:23.891960000 -0400
@@ -7817,6 +7817,7 @@
 compilation.
 
 @table @gcctabopt
+@item -Wp,@var{option}
 @opindex Wp
 You can use @option{-Wp,@var{option}} to bypass the compiler driver
 and pass @var{option} directly through to the preprocessor.  If
@@ -7829,7 +7830,7 @@
 options instead.
 
 @item -Xpreprocessor @var{option}
-@opindex preprocessor
+@opindex Xpreprocessor
 Pass @var{option} as an option to the preprocessor.  You can use this to
 supply system-specific preprocessor options which GCC does not know how to
 recognize.
diff -Naur gcc-4.4.2.orig/gcc/doc/tm.texi gcc-4.4.2/gcc/doc/tm.texi
--- gcc-4.4.2.orig/gcc/doc/tm.texi	2009-07-11 15:06:26.000000000 -0400
+++ gcc-4.4.2/gcc/doc/tm.texi	2009-11-11 15:21:14.372933000 -0500
@@ -10149,18 +10149,6 @@
 @samp{#pragma pack()} (that is, a small power of two).
 @end defmac
 
-@findex #pragma
-@findex pragma
-@defmac HANDLE_PRAGMA_PUSH_POP_MACRO
-Define this macro if you want to support the Win32 style pragmas
-@samp{#pragma push_macro(macro-name-as-string)} and @samp{#pragma
-pop_macro(macro-name-as-string)}.  The @samp{#pragma push_macro(
-macro-name-as-string)} pragma saves the named macro and via
-@samp{#pragma pop_macro(macro-name-as-string)} it will return to the
-previous value.
-@end defmac
-
-
 @defmac DOLLARS_IN_IDENTIFIERS
 Define this macro to control use of the character @samp{$} in
 identifier names for the C family of languages.  0 means @samp{$} is
diff -Naur gcc-4.4.2.orig/gcc/dwarf2out.c gcc-4.4.2/gcc/dwarf2out.c
--- gcc-4.4.2.orig/gcc/dwarf2out.c	2009-09-23 10:58:58.000000000 -0400
+++ gcc-4.4.2/gcc/dwarf2out.c	2009-10-19 08:15:27.233029000 -0400
@@ -145,7 +145,18 @@
 #endif
   if (!flag_dwarf2_cfi_asm || !dwarf2out_do_frame ())
     return false;
-  if (saved_do_cfi_asm || !eh_personality_libfunc)
+  if (saved_do_cfi_asm)
+    return true;
+  if (!HAVE_GAS_CFI_SECTIONS_DIRECTIVE)
+    {
+#ifdef TARGET_UNWIND_INFO
+      return false;
+#else
+      if (USING_SJLJ_EXCEPTIONS || (!flag_unwind_tables && !flag_exceptions))
+	return false;
+#endif
+    }
+  if (!eh_personality_libfunc)
     return true;
   if (!HAVE_GAS_CFI_PERSONALITY_DIRECTIVE)
     return false;
@@ -4583,6 +4594,7 @@
 
 static void dwarf2out_init (const char *);
 static void dwarf2out_finish (const char *);
+static void dwarf2out_assembly_start (void);
 static void dwarf2out_define (unsigned int, const char *);
 static void dwarf2out_undef (unsigned int, const char *);
 static void dwarf2out_start_source_file (unsigned, const char *);
@@ -4605,6 +4617,7 @@
 {
   dwarf2out_init,
   dwarf2out_finish,
+  dwarf2out_assembly_start,
   dwarf2out_define,
   dwarf2out_undef,
   dwarf2out_start_source_file,
@@ -16187,6 +16200,22 @@
       switch_to_section (cold_text_section);
       ASM_OUTPUT_LABEL (asm_out_file, cold_text_section_label);
     }
+
+}
+
+/* Called before cgraph_optimize starts outputtting functions, variables
+   and toplevel asms into assembly.  */
+
+static void
+dwarf2out_assembly_start (void)
+{
+  if (HAVE_GAS_CFI_SECTIONS_DIRECTIVE && dwarf2out_do_cfi_asm ())
+    {
+#ifndef TARGET_UNWIND_INFO
+      if (USING_SJLJ_EXCEPTIONS || (!flag_unwind_tables && !flag_exceptions))
+#endif
+	fprintf (asm_out_file, "\t.cfi_sections\t.debug_frame\n");
+    }
 }
 
 /* A helper function for dwarf2out_finish called through
diff -Naur gcc-4.4.2.orig/gcc/expmed.c gcc-4.4.2/gcc/expmed.c
--- gcc-4.4.2.orig/gcc/expmed.c	2009-01-16 13:56:47.000000000 -0500
+++ gcc-4.4.2/gcc/expmed.c	2009-12-30 14:42:03.647808000 -0500
@@ -4121,7 +4121,8 @@
 		else if (d == -1)
 		  quotient = expand_unop (compute_mode, neg_optab, op0,
 					  tquotient, 0);
-		else if (abs_d == (unsigned HOST_WIDE_INT) 1 << (size - 1))
+		else if (HOST_BITS_PER_WIDE_INT >= size
+			 && abs_d == (unsigned HOST_WIDE_INT) 1 << (size - 1))
 		  {
 		    /* This case is not handled correctly below.  */
 		    quotient = emit_store_flag (tquotient, EQ, op0, op1,
diff -Naur gcc-4.4.2.orig/gcc/fortran/check.c gcc-4.4.2/gcc/fortran/check.c
--- gcc-4.4.2.orig/gcc/fortran/check.c	2009-07-23 20:28:43.000000000 -0400
+++ gcc-4.4.2/gcc/fortran/check.c	2009-10-30 11:18:09.930941000 -0400
@@ -596,10 +596,8 @@
 
   where = &pointer->where;
 
-  if (pointer->expr_type == EXPR_VARIABLE)
-    attr1 = gfc_variable_attr (pointer, NULL);
-  else if (pointer->expr_type == EXPR_FUNCTION)
-    attr1 = pointer->symtree->n.sym->attr;
+  if (pointer->expr_type == EXPR_VARIABLE || pointer->expr_type == EXPR_FUNCTION)
+    attr1 = gfc_expr_attr (pointer);
   else if (pointer->expr_type == EXPR_NULL)
     goto null_arg;
   else
@@ -621,10 +619,8 @@
   if (target->expr_type == EXPR_NULL)
     goto null_arg;
 
-  if (target->expr_type == EXPR_VARIABLE)
-    attr2 = gfc_variable_attr (target, NULL);
-  else if (target->expr_type == EXPR_FUNCTION)
-    attr2 = target->symtree->n.sym->attr;
+  if (target->expr_type == EXPR_VARIABLE || target->expr_type == EXPR_FUNCTION)
+    attr2 = gfc_expr_attr (target);
   else
     {
       gfc_error ("'%s' argument of '%s' intrinsic at %L must be a pointer "
diff -Naur gcc-4.4.2.orig/gcc/fortran/match.c gcc-4.4.2/gcc/fortran/match.c
--- gcc-4.4.2.orig/gcc/fortran/match.c	2008-09-25 11:01:16.000000000 -0400
+++ gcc-4.4.2/gcc/fortran/match.c	2009-10-19 15:18:12.387277000 -0400
@@ -3269,7 +3269,10 @@
       if (gfc_match_eos () == MATCH_YES)
 	break;
       if (gfc_match_char (',') != MATCH_YES)
-	goto syntax;
+	{
+	  gfc_error ("Expecting a comma in EQUIVALENCE at %C");
+	  goto cleanup;
+	}
     }
 
   return MATCH_YES;
diff -Naur gcc-4.4.2.orig/gcc/fortran/resolve.c gcc-4.4.2/gcc/fortran/resolve.c
--- gcc-4.4.2.orig/gcc/fortran/resolve.c	2009-07-29 05:35:15.000000000 -0400
+++ gcc-4.4.2/gcc/fortran/resolve.c	2009-11-26 16:57:32.218782000 -0500
@@ -1100,6 +1100,9 @@
   gfc_symbol* proc_sym;
   gfc_symbol* context_proc;
 
+  if (sym->attr.flavor == FL_PROGRAM)
+    return false;
+
   gcc_assert (sym->attr.flavor == FL_PROCEDURE);
 
   /* If we've got an ENTRY, find real procedure.  */
@@ -9444,10 +9447,6 @@
 {
   while (mpz_cmp_ui (values.left, 0) == 0)
     {
-      if (!gfc_is_constant_expr (values.vnode->expr))
-	gfc_error ("non-constant DATA value at %L",
-		   &values.vnode->expr->where);
-
       if (values.vnode->next == NULL)
 	return FAILURE;
 
diff -Naur gcc-4.4.2.orig/gcc/fortran/symbol.c gcc-4.4.2/gcc/fortran/symbol.c
--- gcc-4.4.2.orig/gcc/fortran/symbol.c	2009-01-09 18:47:55.000000000 -0500
+++ gcc-4.4.2/gcc/fortran/symbol.c	2009-10-19 15:18:12.387277000 -0400
@@ -2693,7 +2693,7 @@
       if (p->gfc_new)
 	{
 	  /* Symbol was new.  */
-	  if (p->attr.in_common && p->common_block->head)
+	  if (p->attr.in_common && p->common_block && p->common_block->head)
 	    {
 	      /* If the symbol was added to any common block, it
 		 needs to be removed to stop the resolver looking
diff -Naur gcc-4.4.2.orig/gcc/fortran/trans-array.c gcc-4.4.2/gcc/fortran/trans-array.c
--- gcc-4.4.2.orig/gcc/fortran/trans-array.c	2009-07-05 15:06:05.000000000 -0400
+++ gcc-4.4.2/gcc/fortran/trans-array.c	2009-11-30 23:36:30.952024000 -0500
@@ -788,7 +788,6 @@
   src_info = &src_ss->data.info;
   dest_info = &dest_ss->data.info;
   gcc_assert (dest_info->dimen == 2);
-  gcc_assert (src_info->dimen == 2);
 
   /* Get a descriptor for EXPR.  */
   gfc_init_se (&src_se, NULL);
diff -Naur gcc-4.4.2.orig/gcc/fortran/trans-const.c gcc-4.4.2/gcc/fortran/trans-const.c
--- gcc-4.4.2.orig/gcc/fortran/trans-const.c	2008-11-12 12:01:51.000000000 -0500
+++ gcc-4.4.2/gcc/fortran/trans-const.c	2009-11-26 16:57:32.218782000 -0500
@@ -336,7 +336,7 @@
 gfc_conv_constant (gfc_se * se, gfc_expr * expr)
 {
   /* We may be receiving an expression for C_NULL_PTR or C_NULL_FUNPTR.  If
-     so, they expr_type will not yet be an EXPR_CONSTANT.  We need to make
+     so, the expr_type will not yet be an EXPR_CONSTANT.  We need to make
      it so here.  */
   if (expr->ts.type == BT_DERIVED && expr->ts.derived
       && expr->ts.derived->attr.is_iso_c)
@@ -349,7 +349,12 @@
         }
     }
 
-  gcc_assert (expr->expr_type == EXPR_CONSTANT);
+  if (expr->expr_type != EXPR_CONSTANT)
+    {
+      gfc_error ("non-constant initialization expression at %L", &expr->where);
+      se->expr = gfc_conv_constant_to_tree (gfc_int_expr (0));
+      return;
+    }
 
   if (se->ss != NULL)
     {
diff -Naur gcc-4.4.2.orig/gcc/fortran/trans-expr.c gcc-4.4.2/gcc/fortran/trans-expr.c
--- gcc-4.4.2.orig/gcc/fortran/trans-expr.c	2009-07-09 15:28:20.000000000 -0400
+++ gcc-4.4.2/gcc/fortran/trans-expr.c	2009-11-01 09:35:40.418315000 -0500
@@ -2620,8 +2620,11 @@
 		   through arg->name.  */
 		conv_arglist_function (&parmse, arg->expr, arg->name);
 	      else if ((e->expr_type == EXPR_FUNCTION)
-			  && e->symtree->n.sym->attr.pointer
-			  && fsym && fsym->attr.target)
+			&& ((e->value.function.esym
+			     && e->value.function.esym->result->attr.pointer)
+			    || (!e->value.function.esym
+				&& e->symtree->n.sym->attr.pointer))
+			&& fsym && fsym->attr.target)
 		{
 		  gfc_conv_expr (&parmse, e);
 		  parmse.expr = build_fold_addr_expr (parmse.expr);
@@ -2668,16 +2671,21 @@
 	        gfc_conv_array_parameter (&parmse, e, argss, f, fsym,
 					  sym->name);
 
-              /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is 
-                 allocated on entry, it must be deallocated.  */
-              if (fsym && fsym->attr.allocatable
-                  && fsym->attr.intent == INTENT_OUT)
-                {
-                  tmp = build_fold_indirect_ref (parmse.expr);
-                  tmp = gfc_trans_dealloc_allocated (tmp);
-                  gfc_add_expr_to_block (&se->pre, tmp);
-                }
-
+	      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is 
+		 allocated on entry, it must be deallocated.  */
+	      if (fsym && fsym->attr.allocatable
+		  && fsym->attr.intent == INTENT_OUT)
+		{
+		  tmp = build_fold_indirect_ref (parmse.expr);
+		  tmp = gfc_trans_dealloc_allocated (tmp);
+		  if (fsym->attr.optional
+		      && e->expr_type == EXPR_VARIABLE
+		      && e->symtree->n.sym->attr.optional)
+		    tmp = fold_build3 (COND_EXPR, void_type_node,
+				     gfc_conv_expr_present (e->symtree->n.sym),
+				       tmp, build_empty_stmt ());
+		  gfc_add_expr_to_block (&se->pre, tmp);
+		}
 	    } 
 	}
 
@@ -3948,8 +3956,12 @@
     }
 
   if (expr->expr_type == EXPR_FUNCTION
-	&& expr->symtree->n.sym->attr.pointer
-	&& !expr->symtree->n.sym->attr.dimension)
+      && ((expr->value.function.esym
+	   && expr->value.function.esym->result->attr.pointer
+	   && !expr->value.function.esym->result->attr.dimension)
+	  || (!expr->value.function.esym
+	      && expr->symtree->n.sym->attr.pointer
+	      && !expr->symtree->n.sym->attr.dimension)))
     {
       se->want_pointer = 1;
       gfc_conv_expr (se, expr);
diff -Naur gcc-4.4.2.orig/gcc/fortran/trans-intrinsic.c gcc-4.4.2/gcc/fortran/trans-intrinsic.c
--- gcc-4.4.2.orig/gcc/fortran/trans-intrinsic.c	2009-07-04 13:22:46.000000000 -0400
+++ gcc-4.4.2/gcc/fortran/trans-intrinsic.c	2009-11-02 11:30:48.203315000 -0500
@@ -3903,6 +3903,8 @@
 scalar_transfer:
   extent = fold_build2 (MIN_EXPR, gfc_array_index_type,
 			dest_word_len, source_bytes);
+  extent = fold_build2 (MAX_EXPR, gfc_array_index_type,
+			extent, gfc_index_zero_node);
 
   if (expr->ts.type == BT_CHARACTER)
     {
diff -Naur gcc-4.4.2.orig/gcc/fortran/trans-openmp.c gcc-4.4.2/gcc/fortran/trans-openmp.c
--- gcc-4.4.2.orig/gcc/fortran/trans-openmp.c	2008-09-18 08:02:50.000000000 -0400
+++ gcc-4.4.2/gcc/fortran/trans-openmp.c	2009-11-25 16:01:47.763505000 -0500
@@ -1155,6 +1155,7 @@
     {
       int simple = 0;
       int dovar_found = 0;
+      tree dovar_decl;
 
       if (clauses)
 	{
@@ -1195,12 +1196,19 @@
       gfc_conv_expr_val (&se, code->ext.iterator->step);
       gfc_add_block_to_block (pblock, &se.pre);
       step = gfc_evaluate_now (se.expr, pblock);
+      dovar_decl = dovar;
 
       /* Special case simple loops.  */
-      if (integer_onep (step))
-	simple = 1;
-      else if (tree_int_cst_equal (step, integer_minus_one_node))
-	simple = -1;
+      if (TREE_CODE (dovar) == VAR_DECL)
+	{
+	  if (integer_onep (step))
+	    simple = 1;
+	  else if (tree_int_cst_equal (step, integer_minus_one_node))
+	    simple = -1;
+	}
+      else
+	dovar_decl
+	  = gfc_trans_omp_variable (code->ext.iterator->var->symtree->n.sym);
 
       /* Loop body.  */
       if (simple)
@@ -1244,7 +1252,7 @@
       if (!dovar_found)
 	{
 	  tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);
-	  OMP_CLAUSE_DECL (tmp) = dovar;
+	  OMP_CLAUSE_DECL (tmp) = dovar_decl;
 	  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);
 	}
       else if (dovar_found == 2)
@@ -1264,7 +1272,7 @@
 	      tmp = fold_build2 (MODIFY_EXPR, type, dovar, tmp);
 	      for (c = omp_clauses; c ; c = OMP_CLAUSE_CHAIN (c))
 		if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE
-		    && OMP_CLAUSE_DECL (c) == dovar)
+		    && OMP_CLAUSE_DECL (c) == dovar_decl)
 		  {
 		    OMP_CLAUSE_LASTPRIVATE_STMT (c) = tmp;
 		    break;
@@ -1274,10 +1282,10 @@
 	    {
 	      for (c = par_clauses; c ; c = OMP_CLAUSE_CHAIN (c))
 		if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE
-		    && OMP_CLAUSE_DECL (c) == dovar)
+		    && OMP_CLAUSE_DECL (c) == dovar_decl)
 		  {
 		    tree l = build_omp_clause (OMP_CLAUSE_LASTPRIVATE);
-		    OMP_CLAUSE_DECL (l) = dovar;
+		    OMP_CLAUSE_DECL (l) = dovar_decl;
 		    OMP_CLAUSE_CHAIN (l) = omp_clauses;
 		    OMP_CLAUSE_LASTPRIVATE_STMT (l) = tmp;
 		    omp_clauses = l;
diff -Naur gcc-4.4.2.orig/gcc/function.c gcc-4.4.2/gcc/function.c
--- gcc-4.4.2.orig/gcc/function.c	2009-09-23 10:58:58.000000000 -0400
+++ gcc-4.4.2/gcc/function.c	2009-11-13 14:57:51.346514000 -0500
@@ -4274,12 +4274,8 @@
   tree guard_decl = targetm.stack_protect_guard ();
   rtx x, y;
 
-  /* Avoid expand_expr here, because we don't want guard_decl pulled
-     into registers unless absolutely necessary.  And we know that
-     crtl->stack_protect_guard is a local stack slot, so this skips
-     all the fluff.  */
-  x = validize_mem (DECL_RTL (crtl->stack_protect_guard));
-  y = validize_mem (DECL_RTL (guard_decl));
+  x = expand_normal (crtl->stack_protect_guard);
+  y = expand_normal (guard_decl);
 
   /* Allow the target to copy from Y to X without leaking Y into a
      register.  */
@@ -4312,12 +4308,8 @@
   rtx label = gen_label_rtx ();
   rtx x, y, tmp;
 
-  /* Avoid expand_expr here, because we don't want guard_decl pulled
-     into registers unless absolutely necessary.  And we know that
-     crtl->stack_protect_guard is a local stack slot, so this skips
-     all the fluff.  */
-  x = validize_mem (DECL_RTL (crtl->stack_protect_guard));
-  y = validize_mem (DECL_RTL (guard_decl));
+  x = expand_normal (crtl->stack_protect_guard);
+  y = expand_normal (guard_decl);
 
   /* Allow the target to compare Y with X without leaking either into
      a register.  */
diff -Naur gcc-4.4.2.orig/gcc/gimplify.c gcc-4.4.2/gcc/gimplify.c
--- gcc-4.4.2.orig/gcc/gimplify.c	2009-07-17 06:45:40.000000000 -0400
+++ gcc-4.4.2/gcc/gimplify.c	2009-11-13 13:42:32.696477000 -0500
@@ -6134,6 +6134,8 @@
   tree tmp_load;
 
    tmp_load = create_tmp_var (type, NULL);
+   if (TREE_CODE (type) == COMPLEX_TYPE || TREE_CODE (type) == VECTOR_TYPE)
+     DECL_GIMPLE_REG_P (tmp_load) = 1;
    if (goa_stabilize_expr (&rhs, pre_p, addr, tmp_load) < 0)
      return GS_ERROR;
 
diff -Naur gcc-4.4.2.orig/gcc/ipa-cp.c gcc-4.4.2/gcc/ipa-cp.c
--- gcc-4.4.2.orig/gcc/ipa-cp.c	2009-07-01 08:14:33.000000000 -0400
+++ gcc-4.4.2/gcc/ipa-cp.c	2009-12-27 17:39:58.929776000 -0500
@@ -191,10 +191,32 @@
 static void
 ipcp_update_cloned_node (struct cgraph_node *new_node)
 {
+  basic_block bb;
+  gimple_stmt_iterator gsi;
+
   /* We might've introduced new direct calls.  */
   push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));
   current_function_decl = new_node->decl;
-  rebuild_cgraph_edges ();
+
+  FOR_EACH_BB (bb)
+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+      {
+	gimple stmt = gsi_stmt (gsi);
+	tree decl;
+
+	if (is_gimple_call (stmt)
+	    && (decl = gimple_call_fndecl (stmt))
+	    && !cgraph_edge (new_node, stmt))
+	  {
+	    struct cgraph_edge *new_edge;
+
+	    new_edge = cgraph_create_edge (new_node, cgraph_node (decl), stmt,
+					   bb->count,
+					   compute_call_stmt_bb_frequency (bb),
+					   bb->loop_depth);
+	    new_edge->indirect_call = 1;
+	  }
+      }
 
   /* Indirect inlinng rely on fact that we've already analyzed
      the body..  */
@@ -960,7 +982,9 @@
 	for (cs = node->callers; cs; cs = next)
 	  {
 	    next = cs->next_caller;
-	    if (ipcp_node_is_clone (cs->caller) || !ipcp_need_redirect_p (cs))
+	    if (!cs->indirect_call
+		&& (ipcp_node_is_clone (cs->caller)
+		    || !ipcp_need_redirect_p (cs)))
 	      {
 		gimple new_stmt;
 		gimple_stmt_iterator gsi;
diff -Naur gcc-4.4.2.orig/gcc/ira-lives.c gcc-4.4.2/gcc/ira-lives.c
--- gcc-4.4.2.orig/gcc/ira-lives.c	2009-04-22 16:16:13.000000000 -0400
+++ gcc-4.4.2/gcc/ira-lives.c	2009-10-15 14:03:20.498493000 -0400
@@ -500,7 +500,7 @@
   for (use = 0; use < recog_data.n_operands; use++)
     {
       if (use == def || recog_data.operand_type[use] == OP_OUT)
-	return;
+	continue;
       
       if (recog_op_alt[use][alt].anything_ok)
 	use_cl = ALL_REGS;
@@ -513,7 +513,7 @@
       if ((use_match = recog_op_alt[use][alt].matches) >= 0)
 	{
 	  if (use_match == def)
-	    return;
+	    continue;
 	  
 	  if (recog_op_alt[use_match][alt].anything_ok)
 	    use_cl = ALL_REGS;
diff -Naur gcc-4.4.2.orig/gcc/omp-low.c gcc-4.4.2/gcc/omp-low.c
--- gcc-4.4.2.orig/gcc/omp-low.c	2009-04-08 16:13:26.000000000 -0400
+++ gcc-4.4.2/gcc/omp-low.c	2009-12-28 11:46:11.798627000 -0500
@@ -6790,6 +6790,27 @@
       wi->info = context;
       break;
 
+    case GIMPLE_COND:
+	{
+	  tree lab = gimple_cond_true_label (stmt);
+	  if (lab)
+	    {
+	      n = splay_tree_lookup (all_labels,
+				     (splay_tree_key) lab);
+	      diagnose_sb_0 (gsi_p, context,
+			     n ? (gimple) n->value : NULL);
+	    }
+	  lab = gimple_cond_false_label (stmt);
+	  if (lab)
+	    {
+	      n = splay_tree_lookup (all_labels,
+				     (splay_tree_key) lab);
+	      diagnose_sb_0 (gsi_p, context,
+			     n ? (gimple) n->value : NULL);
+	    }
+	}
+      break;
+
     case GIMPLE_GOTO:
       {
 	tree lab = gimple_goto_dest (stmt);
diff -Naur gcc-4.4.2.orig/gcc/opts.c gcc-4.4.2/gcc/opts.c
--- gcc-4.4.2.orig/gcc/opts.c	2009-03-28 13:28:45.000000000 -0400
+++ gcc-4.4.2/gcc/opts.c	2009-11-27 06:34:32.674500000 -0500
@@ -837,6 +837,8 @@
 	      if (optimize_val != -1)
 		{
 		  optimize = optimize_val;
+		  if ((unsigned int) optimize > 255)
+		    optimize = 255;
 		  optimize_size = 0;
 		}
 	    }
diff -Naur gcc-4.4.2.orig/gcc/reload.c gcc-4.4.2/gcc/reload.c
--- gcc-4.4.2.orig/gcc/reload.c	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/reload.c	2009-12-21 11:34:26.489264000 -0500
@@ -6096,6 +6096,9 @@
 	      PUT_MODE (tem, GET_MODE (x));
 	      if (MEM_OFFSET (tem))
 		set_mem_offset (tem, plus_constant (MEM_OFFSET (tem), offset));
+	      if (MEM_SIZE (tem)
+		  && INTVAL (MEM_SIZE (tem)) != (HOST_WIDE_INT) outer_size)
+		set_mem_size (tem, GEN_INT (outer_size));
 
 	      /* If this was a paradoxical subreg that we replaced, the
 		 resulting memory must be sufficiently aligned to allow
diff -Naur gcc-4.4.2.orig/gcc/rtlanal.c gcc-4.4.2/gcc/rtlanal.c
--- gcc-4.4.2.orig/gcc/rtlanal.c	2009-03-14 04:10:55.000000000 -0400
+++ gcc-4.4.2/gcc/rtlanal.c	2009-11-03 17:40:08.846737000 -0500
@@ -4508,8 +4508,16 @@
 					   known_x, known_mode, known_ret);
 
     case UMOD:
-      /* The result must be <= the second operand.  */
-      return cached_num_sign_bit_copies (XEXP (x, 1), mode,
+      /* The result must be <= the second operand.  If the second operand
+	 has (or just might have) the high bit set, we know nothing about
+	 the number of sign bit copies.  */
+      if (bitwidth > HOST_BITS_PER_WIDE_INT)
+	return 1;
+      else if ((nonzero_bits (XEXP (x, 1), mode)
+		& ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)
+	return 1;
+      else
+	return cached_num_sign_bit_copies (XEXP (x, 1), mode,
 					   known_x, known_mode, known_ret);
 
     case DIV:
diff -Naur gcc-4.4.2.orig/gcc/sdbout.c gcc-4.4.2/gcc/sdbout.c
--- gcc-4.4.2.orig/gcc/sdbout.c	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/sdbout.c	2009-10-19 08:15:27.233029000 -0400
@@ -307,6 +307,7 @@
 {
   sdbout_init,			         /* init */
   sdbout_finish,		         /* finish */
+  debug_nothing_void,			 /* assembly_start */
   debug_nothing_int_charstar,	         /* define */
   debug_nothing_int_charstar,	         /* undef */
   sdbout_start_source_file,	         /* start_source_file */
diff -Naur gcc-4.4.2.orig/gcc/testsuite/c-c++-common/builtin-offsetof.c gcc-4.4.2/gcc/testsuite/c-c++-common/builtin-offsetof.c
--- gcc-4.4.2.orig/gcc/testsuite/c-c++-common/builtin-offsetof.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/c-c++-common/builtin-offsetof.c	2009-11-05 09:57:57.733685000 -0500
@@ -0,0 +1,28 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/38699
+// { dg-options "-Warray-bounds" }
+// { dg-do compile }
+
+struct A
+{
+  const char *p;
+};
+
+struct B
+{
+    char p[10];
+    struct A a;
+};
+
+void
+f0 ()
+{
+  __builtin_offsetof(struct A, p); // OK
+  __builtin_offsetof(struct A, p[0]); // { dg-error "non constant address" }
+  __builtin_offsetof(struct B, p[0]); // OK
+  __builtin_offsetof(struct B, p[9]); // OK
+  __builtin_offsetof(struct B, p[10]); // OK
+  __builtin_offsetof(struct B, a.p); // OK
+  __builtin_offsetof(struct B, p[0]); // OK
+  __builtin_offsetof(struct B, a.p[0]); // { dg-error "non constant address" }
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr11832.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr11832.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr11832.c	2008-12-01 10:19:40.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr11832.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-/* { dg-do compile } */
-/* Currently ICEs for Alpha, IA64, HPPA, MIPS, CRIS, Xtensa, PowerPC, SH and SPARC; see PR33642.  */
-/* { dg-xfail-if "PR33642" { alpha*-*-* hppa*-*-* mips*-*-* powerpc*-*-* cris-*-* crisv32-*-* ia64-*-* xtensa*-*-* sh*-*-* sparc*-*-* s390*-*-* } { "*" } { "" } } */
-/* Currently ICEs for (x86 && ilp32 && pic).  */
-/* { dg-xfail-if "PR33642/36240" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { "*" } { "" } } */
-/* { dg-prune-output ".*internal compiler error.*" }
-/* { dg-options "-frtl-abstract-sequences" } */
-
-int a, b, e;
-unsigned char *c;
-void foo()
-{
-  int d = 13;
-  b = -1;   
-  switch (e) {
-    case 1:
-      b++; c[b] = (unsigned char)d;
-      break;
-    case 2:
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      break;
-    case 3:
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      break;
-    default:
-      a = 1;
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-      b++; c[b] = (unsigned char)d;
-  }
-}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr33009.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr33009.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr33009.c	2008-12-01 10:19:40.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr33009.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,41 +0,0 @@
-/* { dg-do compile } */
-/* Currently ICEs for Alpha, IA64, HPPA, MIPS, CRIS, Xtensa, PowerPC, SH and SPARC; see PR33642.  */
-/* { dg-xfail-if "PR33642" { alpha*-*-* hppa*-*-* mips*-*-* powerpc*-*-* cris-*-* crisv32-*-* ia64-*-* xtensa*-*-* sh*-*-* sparc*-*-* s390*-*-* } { "*" } { "" } } */
-/* Currently ICEs for (x86 && ilp32 && pic).  */
-/* { dg-xfail-if "PR33642/36240" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { "*" } { "" } } */
-/* { dg-prune-output ".*internal compiler error.*" }
-/* { dg-options "-frtl-abstract-sequences" } */
-
-char *progName;
-int bar0 (char *, ...);
-void bar1 (char *);
-void exit (int);
-
-
-#define SAME \
- bar0 ("%s: Bad flag `%s'\n", argv[i], argv[i] );\
- bar1 ( progName ); \
- exit ( 1 );
-
-
-int foo ( int argc, char *argv[] )
-{
-    int i;
-    for (i = 0; i < argc; i++) {
-	switch (argv[i][0]) {
-	case 'c':
-	    break;
-	default: 
-	
-	    SAME
-	    
-	    break;
-	}
-    }
-    for (i = 0; i < argc; i++) {
-    
-	SAME
-	
-    }
-    return 0;
-}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr41182-1.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr41182-1.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr41182-1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr41182-1.c	2009-10-15 17:17:36.914324000 -0400
@@ -0,0 +1,6 @@
+typedef long unsigned int size_t;
+int _lae_process_opts(char *pr, char *pe)
+{ 
+  return (strlen ("on") < ((size_t) ((pe-&pr[2])>(strlen("on"))                
+                                     ? (pe-&pr[2]) : (strlen("on")))));
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr41634.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr41634.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr41634.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr41634.c	2009-10-15 17:17:36.914324000 -0400
@@ -0,0 +1,19 @@
+extern int _xgetw();
+extern int foo(char*);
+
+void test_readmode( int ascii_mode )
+{
+  static const char outbuffer[]
+    = "0,1,2,3,4,5,6,7,8,9\r\n\r\nA,B,C,D,E\r\nX,Y,Z";
+  char buffer[2*512 +256];
+  int i, j, ao;
+  unsigned int fp;
+
+  foo(buffer);
+
+  for (i=0, j=0; i<6; i++) {
+      if (ao==0 || outbuffer[fp-3+i] != '\r')
+	buffer[j++] = outbuffer[fp-3+i];
+  }
+  _xgetw();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr41661.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr41661.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr41661.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr41661.c	2009-10-15 17:17:36.914324000 -0400
@@ -0,0 +1,20 @@
+/* PR tree-optimization/41661 */
+/* { dg-do compile } */
+/* { dg-options "-fno-early-inlining" } */
+
+int g;
+
+void foo (int x)
+{
+  g = x;
+}
+
+void bar (double d)
+{
+  foo (d == 1);
+}
+
+void baz (int a)
+{
+  bar (1);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr41728.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr41728.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr41728.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr41728.c	2009-10-21 12:05:31.012105000 -0400
@@ -0,0 +1,12 @@
+int a[8];
+int s244(void)
+{
+  int lrc, j;
+  lrc = 0;
+  for (j=0; j<7; j++)
+    if(a[j] != a[j+1])
+      lrc = 1;
+  if (lrc != 0)
+    return 0;
+  return 1;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42025-1.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42025-1.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42025-1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42025-1.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,24 @@
+typedef void* Ptr;
+
+struct A
+{
+  int i;
+  union
+  {
+    Ptr p;
+    char *q;
+  } u;
+};
+
+static void foo(struct A *p, char *q)
+{
+  if (p->i)
+    p->u.p = 0;
+  else
+    p->u.q = q;
+}
+
+void bar(struct A *p, char *q)
+{
+  foo(p, q);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42025-2.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42025-2.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42025-2.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42025-2.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,32 @@
+typedef struct
+{
+  void *p;
+} Ptr;
+
+struct A
+{
+  int i;
+  union
+  {
+    Ptr p;
+    char *q;
+  } u;
+};
+
+extern Ptr get_stuff (void);
+extern void use_stuff (char *);
+
+static void foo(struct A p, char *q)
+{
+  if (p.i)
+    p.u.p = get_stuff ();
+  else
+    p.u.q = q;
+
+  use_stuff (p.u.q);
+}
+
+void bar(struct A *p, char *q)
+{
+  foo(*p, q);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42049.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42049.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42049.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42049.c	2009-12-03 10:33:18.053138000 -0500
@@ -0,0 +1,27 @@
+/* PR middle-end/42049 */
+
+extern char *strcpy (char *s1, const char *s2);
+struct S { char s[4]; };
+
+int
+foo (int x, char **y)
+{
+  char const *a;
+  char const *b;
+  struct S s[9];
+  long i;
+  if (x > 1)
+    a = y[1];
+  else
+    a = "abc";
+  if (x > 2)
+    b = y[2];
+  else
+    b = "def";
+  strcpy (s[0].s, a);
+  strcpy (s[1].s, b);
+  for (i = 2; i < x - 2 && i < 8; i++)
+    strcpy (s[i].s, y[i + 1]);
+  s[i].s[0] = '\0';
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42164.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42164.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42164.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42164.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,25 @@
+typedef struct
+{
+  unsigned long long pte;
+} pte_t;
+pte_t mk_swap_pte (unsigned long offset)
+{
+  pte_t pte;
+  pte.pte = (offset << 40);
+  return pte;
+}
+int pte_file (pte_t pte)
+{
+  return pte.pte & (1 << 4);
+}
+typedef struct
+{
+  unsigned long val;
+} swp_entry_t;
+pte_t swp_entry_to_pte (swp_entry_t entry)
+{
+  swp_entry_t arch_entry;
+  arch_entry = (swp_entry_t){mk_swap_pte (swp_offset (entry)).pte};
+  __BUG_ON ((unsigned long) pte_file ((pte_t) {arch_entry.val}));
+  return (pte_t) {arch_entry.val};
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42196-1.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42196-1.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42196-1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42196-1.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,28 @@
+union U
+{
+  double d;
+  __complex__ int c;
+};
+
+double gd;
+extern double bar (union U);
+
+double foo (int b, double d, int c1, int c2)
+{
+  union U u;
+  double r;
+
+  if (b)
+    {
+      u.d = d;
+      r = u.d;
+    }
+  else
+    {
+      __real__ u.c = c1;
+      __imag__ u.c = c2;
+      r = bar (u);
+    }
+
+  return r;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42196-2.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42196-2.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42196-2.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42196-2.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,28 @@
+union U
+{
+  __complex__ int ci;
+  __complex__ float cf;
+};
+
+float gd;
+extern float bar (union U);
+
+float foo (int b, double f1, double f2, int c1, int c2)
+{
+  union U u;
+  double r;
+
+  if (b)
+    {
+      __real__ u.cf = f1;
+      __imag__ u.cf = f2;
+    }
+  else
+    {
+      __real__ u.ci = c1;
+      __imag__ u.ci = c2;
+    }
+
+  r = bar (u);
+  return r;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42196-3.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42196-3.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42196-3.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42196-3.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,27 @@
+union U
+{
+  __complex__ int ci;
+  __complex__ float cf;
+};
+
+float gd;
+extern float bar (float, float);
+
+float foo (int b, union U u)
+{
+  float f1, f2, r;
+
+  if (b)
+    {
+      f1 = __real__ u.cf;
+      f1 = __imag__ u.cf;
+    }
+  else
+    {
+      f1 = __real__ u.ci;
+      f1 = __imag__ u.ci;
+    }
+
+  r = bar (f1, f2);
+  return r;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42234.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42234.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42234.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42234.c	2009-12-11 20:45:12.901900000 -0500
@@ -0,0 +1,14 @@
+/* { dg-options "-g" } */
+
+void
+foo (int x)
+{
+  struct S { int s; } d = { 1 };
+  unsigned int e = 1;
+  if (x)
+    e = x && d.s;
+  else
+    for (e = 0; e <= 3; e--)
+      ;
+  e++;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42237.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42237.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42237.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42237.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,32 @@
+struct A
+{
+  int p;
+};
+
+struct B
+{
+  struct A n;
+  struct A m;
+  int x;
+  int y;
+  int z;
+};
+
+extern int g1, g2;
+
+static void __attribute__((noinline)) foo (struct B *b)
+{
+  int t;
+
+  t = b->n.p;
+  g1 = t;
+  b->n.p = t+1;
+  g2 = b->m.p;
+
+  b->m = b->n;
+}
+
+void bar (struct B *b)
+{
+  foo (b);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42299.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42299.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/compile/pr42299.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/compile/pr42299.c	2009-12-11 20:45:12.901900000 -0500
@@ -0,0 +1,23 @@
+/* { dg-options "-g" } */
+
+static int
+foo (int x, int y)
+{
+  if (y)
+    goto lab;
+  if (x)
+    y = 0;
+  if (y)
+    goto lab;
+  y = 0;
+lab:
+  return y;
+}
+
+void
+baz (int x, int y)
+{
+  y = foo (x, y);
+  if (y != 0)
+    bar ();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/20091229-1.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/20091229-1.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/20091229-1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/20091229-1.c	2009-12-30 14:42:03.647808000 -0500
@@ -0,0 +1,2 @@
+long long foo(long long v) { return v / -0x080000000LL; }
+void main() { if (foo(0x080000000LL) != -1) abort(); exit (0); }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41317.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41317.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41317.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41317.c	2009-11-09 14:38:29.547277000 -0500
@@ -0,0 +1,28 @@
+extern void abort (void);
+
+struct A
+{
+  int i;
+};
+struct B
+{
+  struct A a;
+  int j;
+};
+
+static void
+foo (struct B *p)
+{
+  ((struct A *)p)->i = 1;
+}
+
+int main()
+{
+  struct A a;
+  a.i = 0;
+  foo ((struct B *)&a);
+  if (a.i != 1)
+    abort ();
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41750.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41750.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41750.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41750.c	2009-11-20 09:49:22.042156000 -0500
@@ -0,0 +1,68 @@
+/* PR 41750 - IPA-SRA used to pass hash->sgot by value rather than by
+   reference.  */
+
+struct bfd_link_hash_table
+{
+  int hash;
+};
+
+struct foo_link_hash_table
+{
+  struct bfd_link_hash_table root;
+  int *dynobj;
+  int *sgot;
+};
+
+struct foo_link_info
+{
+  struct foo_link_hash_table *hash;
+};
+
+extern void abort (void);
+
+int __attribute__((noinline))
+foo_create_got_section (int *abfd, struct foo_link_info *info)
+{
+  info->hash->sgot = abfd;
+  return 1;
+}
+
+static int *
+get_got (int *abfd, struct foo_link_info *info,
+	 struct foo_link_hash_table *hash)
+{
+  int *got;
+  int *dynobj;
+
+  got = hash->sgot;
+  if (!got)
+    {
+      dynobj = hash->dynobj;
+      if (!dynobj)
+	hash->dynobj = dynobj = abfd;
+      if (!foo_create_got_section (dynobj, info))
+	return 0;
+      got = hash->sgot;
+    }
+  return got;
+}
+
+int * __attribute__((noinline,noclone))
+elf64_ia64_check_relocs (int *abfd, struct foo_link_info *info)
+{
+  return get_got (abfd, info, info->hash);
+}
+
+struct foo_link_info link_info;
+struct foo_link_hash_table hash;
+int abfd;
+
+int
+main ()
+{
+  link_info.hash = &hash;
+  if (elf64_ia64_check_relocs (&abfd, &link_info) != &abfd)
+    abort ();
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41917.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41917.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41917.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41917.c	2009-11-03 17:40:08.846737000 -0500
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/41917 */
+
+extern void abort (void);
+unsigned int a = 1;
+
+int
+main (void)
+{
+  unsigned int b, c, d;
+
+  if (sizeof (int) != 4 || (int) 0xc7d24b5e > 0)
+    return 0;
+
+  c = 0xc7d24b5e;
+  d = a | -2;
+  b = (d == 0) ? c : (c % d);
+  if (b != c)
+    abort ();
+
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41919.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41919.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41919.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41919.c	2009-11-20 09:49:22.042156000 -0500
@@ -0,0 +1,39 @@
+extern void abort (void);
+
+#define assert(x) if(!(x)) abort()
+
+struct S1
+{
+  signed char f0;
+};
+
+int g_23 = 0;
+
+static struct S1
+foo (void)
+{
+  int *l_100 = &g_23;
+  int **l_110 = &l_100;
+  struct S1 l_128 = { 1 };
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  assert (l_100 == &g_23);
+  return l_128;
+}
+
+static signed char bar(signed char si1, signed char si2)
+{
+  return (si1 <= 0) ? si1 : (si2 * 2);
+}
+int main (void)
+{
+  struct S1 s = foo();
+  if (bar(0x99 ^ (s.f0 && 1), 1) != -104)
+    abort ();
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41935.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41935.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr41935.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr41935.c	2009-11-20 09:49:22.042156000 -0500
@@ -0,0 +1,25 @@
+/* PR middle-end/41935 */
+
+extern void abort (void);
+
+long int
+foo (int n, int i, int j)
+{
+  typedef int T[n];
+  struct S { int a; T b[n]; };
+  return __builtin_offsetof (struct S, b[i][j]);
+}
+
+int
+main (void)
+{
+  typedef int T[5];
+  struct S { int a; T b[5]; };
+  if (foo (5, 2, 3)
+      != __builtin_offsetof (struct S, b) + (5 * 2 + 3) * sizeof (int))
+    abort ();
+  if (foo (5, 5, 5)
+      != __builtin_offsetof (struct S, b) + (5 * 5 + 5) * sizeof (int))
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42006.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42006.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42006.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42006.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,33 @@
+extern void abort (void);
+
+static unsigned int
+my_add(unsigned int si1, unsigned int si2)
+{
+  return (si1 > (50-si2)) ? si1 : (si1 + si2);
+}
+
+static unsigned int
+my_shift(unsigned int left, unsigned int right)
+{
+  return  (right > 100) ? left : (left >> right);
+}
+
+static int func_4(unsigned int p_6)
+{
+  int count = 0;
+  for (p_6 = 1; p_6 < 3; p_6 = my_add(p_6, 1))
+    {
+      if (count++ > 1)
+	abort ();
+
+      if (my_shift(p_6, p_6))
+	return 0;
+    }
+  return 0;
+}
+
+int main(void)
+{
+  func_4(0);
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42142.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42142.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42142.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42142.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,26 @@
+int __attribute__((noinline,noclone))
+sort(int L)
+{
+  int end[2] = { 10, 10, }, i=0, R;
+  while (i<2)
+    {
+      R = end[i];
+      if (L<R)
+        {
+          end[i+1] = 1;
+          end[i] = 10;
+          ++i;
+        }
+      else
+        break;
+    }
+  return i;
+}
+extern void abort (void);
+int main()
+{
+  if (sort (5) != 1)
+    abort ();
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42154.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42154.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42154.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42154.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,18 @@
+struct A { char x[1]; };
+extern void abort (void);
+void __attribute__((noinline,noclone))
+foo (struct A a)
+{
+  if (a.x[0] != 'a')
+    abort ();
+}
+int main ()
+{
+  struct A a;
+  int i;
+  for (i = 0; i < 1; ++i)
+    a.x[i] = 'a';
+  foo (a);
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42231.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42231.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42231.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42231.c	2009-12-27 17:39:58.929776000 -0500
@@ -0,0 +1,35 @@
+extern void abort (void);
+
+static max;
+
+static void __attribute__((noinline)) storemax (int i)
+{
+  if (i > max)
+    max = i;
+}
+
+static int CallFunctionRec(int (*fun)(int depth), int depth) {
+  if (!fun(depth)) {
+    return 0;
+  }
+  if (depth < 10) {
+    CallFunctionRec(fun, depth + 1);
+  }
+  return 1;
+}
+
+static int CallFunction(int (*fun)(int depth)) {
+  return CallFunctionRec(fun, 1) && !fun(0);
+}
+
+static int callback(int depth) {
+  storemax (depth);
+  return depth != 0;
+}
+
+int main() {
+  CallFunction(callback);
+  if (max != 10)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42269-2.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42269-2.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pr42269-2.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pr42269-2.c	2009-12-11 20:45:12.901900000 -0500
@@ -0,0 +1,15 @@
+/* Make sure that language + abi extensions in passing S interoperate.  */
+
+static long long __attribute__((noinline))
+foo (unsigned short s)
+{
+  return (short) s;
+}
+
+unsigned short s = 0xFFFF;
+
+int
+main (void)
+{
+  return foo (s) + 1 != 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.c-torture/execute/pushpop_macro.c	2009-11-11 15:21:14.372933000 -0500
@@ -0,0 +1,15 @@
+extern void abort ();
+
+#define _ 2
+#pragma push_macro("_")
+#undef _
+#define _ 1
+#pragma pop_macro("_")
+
+int main ()
+{
+  if (_ != 2)
+    abort ();
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/cleanup-13.c gcc-4.4.2/gcc/testsuite/gcc.dg/cleanup-13.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/cleanup-13.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/cleanup-13.c	2009-10-19 15:56:57.500694000 -0400
@@ -0,0 +1,319 @@
+/* HP-UX libunwind.so doesn't provide _UA_END_OF_STACK */
+/* { dg-do run } */
+/* { dg-options "-fexceptions" } */
+/* { dg-skip-if "" { "ia64-*-hpux11.*" }  { "*" } { "" } } */
+/* Verify DW_OP_* handling in the unwinder.  */
+
+#include <unwind.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* #define OP_addr(x) 0x06, ... */
+#define OP_deref 0x06,
+#define SLEB128(x) (x)&0x7f	/* Assume here the value is -0x40 ... 0x3f.  */
+#define ULEB128(x) (x)&0x7f	/* Assume here the value is 0 ... 0x7f.  */
+#define VAL1(x) (x)&0xff
+#if defined (__BIG_ENDIAN__)
+#define VAL2(x) ((x)>>8)&0xff,(x)&0xff
+#define VAL4(x) ((x)>>24)&0xff,((x)>>16)&0xff,((x)>>8)&0xff,(x)&0xff
+#define VAL8(x) ((x)>>56)&0xff,((x)>>48)&0xff,((x)>>40)&0xff,((x)>>32)&0xff,((x)>>24)&0xff,((x)>>16)&0xff,((x)>>8)&0xff,(x)&0xff
+#elif defined(__LITTLE_ENDIAN__) || defined(__x86_64__) || defined(__i386__)
+#define VAL2(x) (x)&0xff,((x)>>8)&0xff
+#define VAL4(x) (x)&0xff,((x)>>8)&0xff,((x)>>16)&0xff,((x)>>24)&0xff
+#define VAL8(x) (x)&0xff,((x)>>8)&0xff,((x)>>16)&0xff,((x)>>24)&0xff,((x)>>32)&0xff,((x)>>40)&0xff,((x)>>48)&0xff,((x)>>56)&0xff
+#endif
+#define OP_const1u(x) 0x08,VAL1(x),
+#define OP_const1s(x) 0x09,VAL1(x),
+#define OP_const2u(x) 0x0a,VAL2(x),
+#define OP_const2s(x) 0x0b,VAL2(x),
+#define OP_const4u(x) 0x0c,VAL4(x),
+#define OP_const4s(x) 0x0d,VAL4(x),
+#define OP_const8u(x) 0x0e,VAL8(x),
+#define OP_const8s(x) 0x0f,VAL8(x),
+#define OP_constu(x) 0x10,ULEB128(x),
+#define OP_consts(x) 0x11,SLEB128(x),
+#define OP_dup 0x12,
+#define OP_drop 0x13,
+#define OP_over 0x14,
+#define OP_pick(x) 0x15,VAL1(x),
+#define OP_swap 0x16,
+#define OP_rot 0x17,
+#define OP_xderef 0x18,
+#define OP_abs 0x19,
+#define OP_and 0x1a,
+#define OP_div 0x1b,
+#define OP_minus 0x1c,
+#define OP_mod 0x1d,
+#define OP_mul 0x1e,
+#define OP_neg 0x1f,
+#define OP_not 0x20,
+#define OP_or 0x21,
+#define OP_plus 0x22,
+#define OP_plus_uconst(x) 0x23,ULEB128(x),
+#define OP_shl 0x24,
+#define OP_shr 0x25,
+#define OP_shra 0x26,
+#define OP_xor 0x27,
+#define OP_bra(x) 0x28,VAL2(x),
+#define OP_eq 0x29,
+#define OP_ge 0x2a,
+#define OP_gt 0x2b,
+#define OP_le 0x2c,
+#define OP_lt 0x2d,
+#define OP_ne 0x2e,
+#define OP_skip(x) 0x2f,VAL2(x),
+#define OP_lit0 0x30,
+#define OP_lit1 0x31,
+#define OP_lit2 0x32,
+#define OP_lit3 0x33,
+#define OP_lit4 0x34,
+#define OP_lit5 0x35,
+#define OP_lit6 0x36,
+#define OP_lit7 0x37,
+#define OP_lit8 0x38,
+#define OP_lit9 0x39,
+#define OP_lit10 0x3a,
+#define OP_lit11 0x3b,
+#define OP_lit12 0x3c,
+#define OP_lit13 0x3d,
+#define OP_lit14 0x3e,
+#define OP_lit15 0x3f,
+#define OP_lit16 0x40,
+#define OP_lit17 0x41,
+#define OP_lit18 0x42,
+#define OP_lit19 0x43,
+#define OP_lit20 0x44,
+#define OP_lit21 0x45,
+#define OP_lit22 0x46,
+#define OP_lit23 0x47,
+#define OP_lit24 0x48,
+#define OP_lit25 0x49,
+#define OP_lit26 0x4a,
+#define OP_lit27 0x4b,
+#define OP_lit28 0x4c,
+#define OP_lit29 0x4d,
+#define OP_lit30 0x4e,
+#define OP_lit31 0x4f,
+#define OP_reg0 0x50,
+#define OP_reg1 0x51,
+#define OP_reg2 0x52,
+#define OP_reg3 0x53,
+#define OP_reg4 0x54,
+#define OP_reg5 0x55,
+#define OP_reg6 0x56,
+#define OP_reg7 0x57,
+#define OP_reg8 0x58,
+#define OP_reg9 0x59,
+#define OP_reg10 0x5a,
+#define OP_reg11 0x5b,
+#define OP_reg12 0x5c,
+#define OP_reg13 0x5d,
+#define OP_reg14 0x5e,
+#define OP_reg15 0x5f,
+#define OP_reg16 0x60,
+#define OP_reg17 0x61,
+#define OP_reg18 0x62,
+#define OP_reg19 0x63,
+#define OP_reg20 0x64,
+#define OP_reg21 0x65,
+#define OP_reg22 0x66,
+#define OP_reg23 0x67,
+#define OP_reg24 0x68,
+#define OP_reg25 0x69,
+#define OP_reg26 0x6a,
+#define OP_reg27 0x6b,
+#define OP_reg28 0x6c,
+#define OP_reg29 0x6d,
+#define OP_reg30 0x6e,
+#define OP_reg31 0x6f,
+#define OP_breg0(x) 0x70,SLEB128(x),
+#define OP_breg1(x) 0x71,SLEB128(x),
+#define OP_breg2(x) 0x72,SLEB128(x),
+#define OP_breg3(x) 0x73,SLEB128(x),
+#define OP_breg4(x) 0x74,SLEB128(x),
+#define OP_breg5(x) 0x75,SLEB128(x),
+#define OP_breg6(x) 0x76,SLEB128(x),
+#define OP_breg7(x) 0x77,SLEB128(x),
+#define OP_breg8(x) 0x78,SLEB128(x),
+#define OP_breg9(x) 0x79,SLEB128(x),
+#define OP_breg10(x) 0x7a,SLEB128(x),
+#define OP_breg11(x) 0x7b,SLEB128(x),
+#define OP_breg12(x) 0x7c,SLEB128(x),
+#define OP_breg13(x) 0x7d,SLEB128(x),
+#define OP_breg14(x) 0x7e,SLEB128(x),
+#define OP_breg15(x) 0x7f,SLEB128(x),
+#define OP_breg16(x) 0x80,SLEB128(x),
+#define OP_breg17(x) 0x81,SLEB128(x),
+#define OP_breg18(x) 0x82,SLEB128(x),
+#define OP_breg19(x) 0x83,SLEB128(x),
+#define OP_breg20(x) 0x84,SLEB128(x),
+#define OP_breg21(x) 0x85,SLEB128(x),
+#define OP_breg22(x) 0x86,SLEB128(x),
+#define OP_breg23(x) 0x87,SLEB128(x),
+#define OP_breg24(x) 0x88,SLEB128(x),
+#define OP_breg25(x) 0x89,SLEB128(x),
+#define OP_breg26(x) 0x8a,SLEB128(x),
+#define OP_breg27(x) 0x8b,SLEB128(x),
+#define OP_breg28(x) 0x8c,SLEB128(x),
+#define OP_breg29(x) 0x8d,SLEB128(x),
+#define OP_breg30(x) 0x8e,SLEB128(x),
+#define OP_breg31(x) 0x8f,SLEB128(x),
+#define OP_regx(x) 0x90,SLEB128(x),
+#define OP_fbreg(x) 0x91,SLEB128(x),
+#define OP_bregx(x,y) 0x92,ULEB128(x),SLEB128(y),
+#define OP_piece(x) 0x93,ULEB128(x),
+#define OP_deref_size(x) 0x94,VAL1(x),
+#define OP_xderef_size(x) 0x95,VAL1(x),
+#define OP_nop 0x96,
+#define OP_nop_termination 0x96
+#define OP_push_object_address 0x97,
+#define OP_call2(x) 0x98,VAL2(x),
+#define OP_call4(x) 0x99,VAL4(x),
+/* #define OP_call_ref(x) 0x9a,... */
+#define OP_form_tls_address(x) 0x9b,
+#define OP_call_frame_cfa 0x9c,
+#define OP_bit_piece(x) 0x9d,ULEB128(x),
+/* #define OP_implicit_value(x...) 0x9e,... */
+#define OP_stack_value 0x9f,
+#define OP_GNU_push_tls_address 0xe0,
+/* #define OP_GNU_encoded_addr(x...) 0xf1, */
+
+#define ASSERT_TOS_NON0 OP_bra(3) OP_skip(-3)
+#define ASSERT_TOS_0 OP_lit0 OP_eq ASSERT_TOS_NON0
+
+/* Initially there is CFA value on the stack, we want to
+   keep it there at the end.  */
+#define CFI_PROGRAM \
+OP_lit0 OP_nop ASSERT_TOS_0						\
+OP_lit1 ASSERT_TOS_NON0							\
+OP_lit1 OP_const1u(1) OP_eq ASSERT_TOS_NON0				\
+OP_lit16 OP_const2u(16) OP_eq ASSERT_TOS_NON0				\
+OP_lit31 OP_const4u(31) OP_ne ASSERT_TOS_0				\
+OP_lit1 OP_neg OP_const1s(-1) OP_eq ASSERT_TOS_NON0			\
+OP_lit16 OP_neg OP_const2s(-16) OP_ne ASSERT_TOS_0			\
+OP_lit31 OP_const4s(-31) OP_neg OP_ne ASSERT_TOS_0			\
+OP_lit7 OP_dup OP_plus_uconst(2) OP_lit9 OP_eq ASSERT_TOS_NON0		\
+  OP_lit7 OP_eq ASSERT_TOS_NON0						\
+OP_lit20 OP_lit1 OP_drop OP_lit20 OP_eq ASSERT_TOS_NON0			\
+OP_lit17 OP_lit19 OP_over OP_lit17 OP_eq ASSERT_TOS_NON0		\
+  OP_lit19 OP_eq ASSERT_TOS_NON0 OP_lit17 OP_eq ASSERT_TOS_NON0		\
+OP_lit1 OP_lit2 OP_lit3 OP_lit4 OP_pick(2) OP_lit2 OP_eq ASSERT_TOS_NON0\
+  OP_lit4 OP_eq ASSERT_TOS_NON0 OP_lit3 OP_eq ASSERT_TOS_NON0		\
+  OP_pick(0) OP_lit2 OP_eq ASSERT_TOS_NON0				\
+  OP_lit2 OP_eq ASSERT_TOS_NON0 OP_lit1 OP_eq ASSERT_TOS_NON0		\
+OP_lit6 OP_lit12 OP_swap OP_lit6 OP_eq ASSERT_TOS_NON0			\
+  OP_lit12 OP_eq ASSERT_TOS_NON0					\
+OP_lit7 OP_lit8 OP_lit9 OP_rot OP_lit8 OP_eq ASSERT_TOS_NON0		\
+  OP_lit7 OP_eq ASSERT_TOS_NON0 OP_lit9 OP_eq ASSERT_TOS_NON0		\
+OP_lit7 OP_abs OP_lit7 OP_eq ASSERT_TOS_NON0				\
+OP_const1s(-123) OP_abs OP_const1u(123) OP_eq ASSERT_TOS_NON0		\
+OP_lit3 OP_lit6 OP_and OP_lit2 OP_eq ASSERT_TOS_NON0			\
+OP_lit3 OP_lit6 OP_or OP_lit7 OP_eq ASSERT_TOS_NON0			\
+OP_lit17 OP_lit2 OP_minus OP_lit15 OP_eq ASSERT_TOS_NON0		\
+OP_const1s(-6) OP_const1s(-2) OP_div OP_lit3 OP_eq ASSERT_TOS_NON0	\
+OP_const1s(-6) OP_const1s(-4) OP_mod OP_const1s(-2)			\
+  OP_eq ASSERT_TOS_NON0							\
+OP_lit16 OP_lit31 OP_plus_uconst(1) OP_mul OP_const2u(512)		\
+  OP_eq ASSERT_TOS_NON0							\
+OP_lit5 OP_not OP_lit31 OP_and OP_lit26 OP_eq ASSERT_TOS_NON0		\
+OP_lit12 OP_lit31 OP_plus OP_const1u(43) OP_eq ASSERT_TOS_NON0		\
+OP_const1s(-6) OP_lit2 OP_plus OP_const1s(-4) OP_eq ASSERT_TOS_NON0	\
+OP_const1s(-6) OP_plus_uconst(3) OP_const1s(-3) OP_eq ASSERT_TOS_NON0	\
+OP_lit16 OP_lit4 OP_shl OP_const2u(256) OP_eq ASSERT_TOS_NON0		\
+OP_lit16 OP_lit3 OP_shr OP_lit2 OP_eq ASSERT_TOS_NON0			\
+OP_const1s(-16) OP_lit3 OP_shra OP_const1s(-2) OP_eq ASSERT_TOS_NON0	\
+OP_lit3 OP_lit6 OP_xor OP_lit5 OP_eq ASSERT_TOS_NON0			\
+OP_lit3 OP_lit6 OP_le ASSERT_TOS_NON0					\
+OP_lit3 OP_lit3 OP_le ASSERT_TOS_NON0					\
+OP_lit6 OP_lit3 OP_le ASSERT_TOS_0					\
+OP_lit3 OP_lit6 OP_lt ASSERT_TOS_NON0					\
+OP_lit3 OP_lit3 OP_lt ASSERT_TOS_0					\
+OP_lit6 OP_lit3 OP_lt ASSERT_TOS_0					\
+OP_lit3 OP_lit6 OP_ge ASSERT_TOS_0					\
+OP_lit3 OP_lit3 OP_ge ASSERT_TOS_NON0					\
+OP_lit6 OP_lit3 OP_ge ASSERT_TOS_NON0					\
+OP_lit3 OP_lit6 OP_gt ASSERT_TOS_0					\
+OP_lit3 OP_lit3 OP_gt ASSERT_TOS_0					\
+OP_lit6 OP_lit3 OP_gt ASSERT_TOS_NON0					\
+OP_const1s(-6) OP_lit1 OP_shr OP_lit0 OP_gt ASSERT_TOS_NON0		\
+OP_const1s(-6) OP_lit1 OP_shra OP_lit0 OP_lt ASSERT_TOS_NON0
+
+#define CFI_ESCAPE_VAL_2(VALUES...) #VALUES
+#define CFI_ESCAPE_VAL_1(VALUES...) CFI_ESCAPE_VAL_2(VALUES)
+#define CFI_ESCAPE_VAL(VALUES...) CFI_ESCAPE_VAL_1(VALUES)
+#define CFI_ESCAPE do { } while (0)
+#define CFI_ARCH_PROGRAM OP_nop_termination
+#ifdef __GCC_HAVE_DWARF2_CFI_ASM
+#if defined (__x86_64__)
+#undef CFI_ESCAPE
+#undef CFI_ARCH_PROGRAM
+#define CFI_ARCH_PROGRAM CFI_PROGRAM OP_lit8 OP_minus OP_nop_termination
+unsigned char cfi_arch_program[] = { CFI_ARCH_PROGRAM };
+extern char verify_it[sizeof (cfi_arch_program) - 0x80 < 0x3f80 ? 1 : -1];
+/* DW_CFA_expression %rip, uleb128(l2-l1), l1: program DW_OP_lit8 DW_OP_minus DW_OP_nop l2: */
+#define CFI_ESCAPE \
+  asm volatile (".cfi_escape 0x10, 0x10, (%P0&0x7f)+0x80, %P0>>7, " \
+		CFI_ESCAPE_VAL (CFI_ARCH_PROGRAM) \
+		: : "i" (sizeof (cfi_arch_program)))
+#elif defined (__i386__)
+#undef CFI_ESCAPE
+#undef CFI_ARCH_PROGRAM
+#define CFI_ARCH_PROGRAM CFI_PROGRAM OP_lit4 OP_minus OP_nop_termination
+unsigned char cfi_arch_program[] = { CFI_ARCH_PROGRAM };
+extern char verify_it[sizeof (cfi_arch_program) - 0x80 < 0x3f80 ? 1 : -1];
+/* DW_CFA_expression %eip, uleb128(l2-l1), l1: program DW_OP_lit4 DW_OP_minus DW_OP_nop l2: */
+#define CFI_ESCAPE \
+  asm volatile (".cfi_escape 0x10, 8, (%P0&0x7f)+0x80, %P0>>7, " \
+		CFI_ESCAPE_VAL (CFI_ARCH_PROGRAM) \
+		: : "i" (sizeof (cfi_arch_program)))
+#endif
+#endif
+static _Unwind_Reason_Code
+force_unwind_stop (int version, _Unwind_Action actions,
+		   _Unwind_Exception_Class exc_class,
+		   struct _Unwind_Exception *exc_obj,
+		   struct _Unwind_Context *context,
+		   void *stop_parameter)
+{
+  if (actions & _UA_END_OF_STACK)
+    abort ();
+  return _URC_NO_REASON;
+}
+
+static void force_unwind ()
+{
+  struct _Unwind_Exception *exc = malloc (sizeof (*exc));
+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));
+  exc->exception_cleanup = 0;
+
+#ifndef __USING_SJLJ_EXCEPTIONS__
+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);
+#else
+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);
+#endif
+
+  abort ();
+}
+
+static void handler (void *p __attribute__((unused)))
+{
+  exit (0);
+}
+
+__attribute__((noinline)) static void callme ()
+{
+  CFI_ESCAPE;
+  force_unwind ();
+}
+
+__attribute__((noinline)) static void doit ()
+{
+  char dummy __attribute__((cleanup (handler)));
+  callme ();
+}
+
+int main()
+{ 
+  doit ();
+  abort ();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/cpp/pragma-pop_macro-1.c gcc-4.4.2/gcc/testsuite/gcc.dg/cpp/pragma-pop_macro-1.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/cpp/pragma-pop_macro-1.c	2008-02-15 09:17:41.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/cpp/pragma-pop_macro-1.c	2009-11-11 15:21:14.372933000 -0500
@@ -1,7 +1,7 @@
 /* PR preprocessor/35061 */
 /* Do nothing if there is nothing on the macro stack to pop.  */
 
-/* { dg-do preprocess { target *-*-mingw* *-*-cygwin* } } */
+/* { dg-do preprocess } */
 
 #define X  1
 /* # pragma push_macro("X") */
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/debug/pr41717.c gcc-4.4.2/gcc/testsuite/gcc.dg/debug/pr41717.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/debug/pr41717.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/debug/pr41717.c	2009-10-21 12:05:31.012105000 -0400
@@ -0,0 +1,10 @@
+/* PR debug/41717 */
+/* { dg-do compile } */
+
+void
+foo (void)
+{
+  _Complex float v[1], w;
+  v[1] = 0.0f + 0.8fi;
+  w = __builtin_conjf (v[1] * v[1]);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/debug/pr42244.c gcc-4.4.2/gcc/testsuite/gcc.dg/debug/pr42244.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/debug/pr42244.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/debug/pr42244.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,13 @@
+/* PR debug/42444 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -g -fmodulo-sched -ffloat-store" } */
+
+extern int a, b;
+
+double
+foo (double x)
+{
+  for (; a > b; a--)
+    x *= (double) a;
+  return x;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/dfp/dfp.exp gcc-4.4.2/gcc/testsuite/gcc.dg/dfp/dfp.exp
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/dfp/dfp.exp	2007-08-01 12:25:11.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/dfp/dfp.exp	2009-11-03 12:59:43.654521000 -0500
@@ -46,10 +46,14 @@
 # Initialize `dg'.
 dg-init
 
-# Main loop.
+# Main loop; run the C-only tests.
 dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] \
         "" $DEFAULT_CFLAGS
 
+# Run the tests that are shared with C++ testing.
+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/dfp/*c]] \
+        "" $DEFAULT_CFLAGS
+
 # All done.
 dg-finish
 
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/dg.exp gcc-4.4.2/gcc/testsuite/gcc.dg/dg.exp
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/dg.exp	2007-08-01 12:25:11.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/dg.exp	2009-11-03 12:59:43.654521000 -0500
@@ -32,5 +32,9 @@
 dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cSi\]]] \
 	"" $DEFAULT_CFLAGS
 
+# C/C++ common tests.
+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/*.\[cSi\]]] \
+	" -Wc++-compat " ""
+
 # All done.
 dg-finish
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/noncompile/pr40033-1.c gcc-4.4.2/gcc/testsuite/gcc.dg/noncompile/pr40033-1.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/noncompile/pr40033-1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/noncompile/pr40033-1.c	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,7 @@
+/* ICE from error_mark_node being wrapped in a C_MAYBE_CONST_EXPR.  PR
+   40033.  */
+
+void foo()
+{
+  ({ 0,; }); /* { dg-error "expected" } */
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/O16384.c gcc-4.4.2/gcc/testsuite/gcc.dg/O16384.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/O16384.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/O16384.c	2009-11-27 06:34:32.674500000 -0500
@@ -0,0 +1,15 @@
+/* Test insane -O argument.  */
+/* { dg-do compile } */
+/* { dg-options "-O16384" } */
+
+__attribute__((__optimize__(16396), __noinline__)) void
+foo (void)
+{
+}
+
+int
+main (void)
+{
+  foo ();
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pch/pushpop-1.c gcc-4.4.2/gcc/testsuite/gcc.dg/pch/pushpop-1.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pch/pushpop-1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pch/pushpop-1.c	2009-11-11 15:21:14.372933000 -0500
@@ -0,0 +1,11 @@
+#include "pushpop-1.hs"
+
+#if FOO != 2
+#error FOO != 2
+#endif
+#pragma pop_macro("FOO")
+
+#if FOO != 1
+#error FOR != 1
+#endif
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pch/pushpop-1.hs gcc-4.4.2/gcc/testsuite/gcc.dg/pch/pushpop-1.hs
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pch/pushpop-1.hs	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pch/pushpop-1.hs	2009-11-11 15:21:14.372933000 -0500
@@ -0,0 +1,5 @@
+#define FOO 1
+#pragma push_macro ("FOO")
+#undef FOO
+#define FOO 2
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr40946.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr40946.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr40946.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr40946.c	2009-11-09 14:38:29.547277000 -0500
@@ -0,0 +1,33 @@
+/* PR middle-end/40946 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall" } */
+
+struct A
+{
+  unsigned char a1[8];
+  unsigned short a2, a3, a4, a5, a6, a7;
+};
+
+int bar (void *, const char *, int);
+char *foo (void *, int);
+
+char *
+baz (const char *x, const char *y)
+{
+  int a = sizeof (struct A) + 2 * (__builtin_strlen (y)
+				   + __builtin_strlen (x) + 24) + 16;
+  struct A *b = __builtin_malloc (a);
+  char *c;
+  int d;
+
+  b->a4 = sizeof (struct A);
+  c = ((char *) b) + b->a4;
+  d = ((char *) b) + a - c;
+  b->a2 = b->a3 = (unsigned short) bar (c, y, d); /* { dg-bogus "array subscript is above array bounds" } */
+  c += b->a2;
+  d = ((char *) b) + a - c;
+  b->a7 = b->a4 + b->a2;
+  b->a5 = b->a6 = (unsigned short) bar (c, x, d);
+  c = foo (b, a);
+  return c;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41573.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr41573.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41573.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr41573.c	2009-10-15 17:17:36.914324000 -0400
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+__inline __attribute__ ((__always_inline__)) char *
+strcpy (char *__dest, __const char *__src)
+{
+  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
+}
+
+const char* get_attr(unsigned attr)
+{
+    static char tmp[256];
+
+    strcpy(tmp, "");
+    return tmp;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41574.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr41574.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41574.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr41574.c	2009-12-11 06:21:33.484901000 -0500
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv7-a -mfloat-abi=softfp -mfpu=neon -fno-unsafe-math-optimizations -fdump-rtl-combine" { target { arm*-*-* } } } */
+/* { dg-options "-O2 -fno-unsafe-math-optimizations -fdump-rtl-combine" { target { ! arm*-*-* } } } */
+
+
+static const double one=1.0;
+
+double
+f(double x)
+{
+  return x*(one+x);
+}
+
+/* { dg-final { scan-rtl-dump-not "\\(plus:DF \\(mult:DF" "combine" } } */
+/* { dg-final { cleanup-rtl-dump "combine*" } } */
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41643.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr41643.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41643.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr41643.c	2009-11-07 12:39:48.507096000 -0500
@@ -0,0 +1,15 @@
+/* PR tree-optimization/41643 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-tree-dce" } */
+
+struct S { int a; };
+
+int
+f (struct S *x)
+{
+  int a = x->a;
+  if (a)
+    return f (x) + a;
+  else
+    return f (x);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41762.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr41762.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41762.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr41762.c	2009-10-28 10:41:24.850560000 -0400
@@ -0,0 +1,31 @@
+/* PR target/41762 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftracer -fsched2-use-superblocks" } */
+/* { dg-options "-O2 -ftracer -fsched2-use-superblocks -fpic" { target fpic } } */
+
+extern __SIZE_TYPE__ strlen (const char *);
+extern int f1 (void *);
+extern char *f2 (void);
+extern void f3 (int, int);
+static char *a;
+char *b, *c, *d, *e;
+
+void
+foo (void)
+{
+  int f, g, h;
+  f = (a ? strlen (a) : strlen ("abcde"));
+  f += (b ? strlen (b) : 0);
+  f += (c ? strlen (c) : 0);
+  f += (d ? strlen (d) : 0);
+  f += (e ? strlen (e) : 0);
+  h = f1 (strlen);
+  g = strlen (a);
+  f3 (g, f);
+}
+
+void
+bar (void)
+{
+  a = f2 ();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41841.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr41841.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41841.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr41841.c	2009-11-20 09:49:22.042156000 -0500
@@ -0,0 +1,22 @@
+/* PR tree-optimization/41841 */
+/* { dg-do compile } */
+/* { dg-options "-O -fipa-struct-reorg -fwhole-program -fipa-cp" } */
+
+typedef struct S *T;
+typedef struct { } *U;
+extern int f1 (void);
+
+static void
+f3 (U x, int y)
+{
+  T a = (T) x;
+  y && f1 ();
+}
+
+static void
+f2 (T x)
+{
+  f3 ((U) x, 1);
+}
+
+void *volatile a __attribute__((used)) = f2;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41842.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr41842.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41842.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr41842.c	2009-10-27 12:05:36.071308000 -0400
@@ -0,0 +1,8 @@
+/* PR c/41842 */
+/* { dg-do compile } */
+
+void
+f ()
+{
+  char x[g (h)];	/* { dg-error "undeclared|for each function" } */
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41935.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr41935.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr41935.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr41935.c	2009-11-20 09:49:22.042156000 -0500
@@ -0,0 +1,25 @@
+/* PR middle-end/41935 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+struct A { int a; int b[10]; };
+
+int
+foo (struct A *p)
+{
+  return __builtin_offsetof (struct A, b[p->a]);
+}
+
+int
+main ()
+{
+  struct A a;
+  a.a = 7;
+  if (foo (&a) != 7 * sizeof (int) + __builtin_offsetof (struct A, b))
+    abort ();
+  a.a = 2;
+  if (foo (&a) != 2 * sizeof (int) + __builtin_offsetof (struct A, b))
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr42078.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr42078.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr42078.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr42078.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,22 @@
+/* PR tree-optimization/42078 */
+/* { dg-do compile } */
+/* { dg-options "-g -O -ffast-math" } */
+
+double sqrt (double x);
+
+float
+foo (float x)
+{
+  float y = sqrt (x);
+  return x / y;
+}
+
+inline float
+bar (float x)
+{
+  float y = sqrt (x);
+  float a = y;
+  float b = y;
+  float c = y;
+  return x / y;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr42084.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr42084.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr42084.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr42084.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -fno-delete-null-pointer-checks" } */
+extern void abort (void);
+int g = 0;
+static int __attribute__((noinline)) f (long long a, long long b)
+{
+  int cmp;
+  cmp = a > b;
+  if (&g == 0)
+    cmp-=2;
+  else
+    cmp++;
+  return cmp;
+}
+
+int main (void)
+{
+  int ret = f (2, 1);
+  if (ret != 2)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr42215.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr42215.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr42215.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr42215.c	2009-12-11 20:45:12.901900000 -0500
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-loop-distribution" } */
+
+extern int A[];
+extern int B[];
+
+void f(int i)
+{
+   while (i-- > 0) {
+     A[i] = 0;
+     B[i] = 0;
+   }
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr42475.c gcc-4.4.2/gcc/testsuite/gcc.dg/pr42475.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/pr42475.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/pr42475.c	2009-12-23 12:07:04.997054000 -0500
@@ -0,0 +1,28 @@
+/* PR rtl-optimization/42475 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef struct { float x, y; } B;
+typedef struct { float z; } C;
+typedef struct { B b; C c; } D;
+
+B
+foo (float x, float y)
+{
+  B b = { .x = x, .y = y };
+  return b;
+}
+
+B
+bar (B b, B y)
+{
+  return foo (y.x + b.x, b.y);
+}
+
+B
+baz (D p)
+{
+  D d = { };
+  B y = bar (foo (0, (p.c.z) / 2), d.b);
+  return y;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/torture/pr41555.c gcc-4.4.2/gcc/testsuite/gcc.dg/torture/pr41555.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/torture/pr41555.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/torture/pr41555.c	2009-10-15 17:17:36.914324000 -0400
@@ -0,0 +1,119 @@
+/* { dg-do run } */
+/* { dg-options "-std=c99" } */
+
+#include <stdint.h>
+#include <limits.h>
+
+extern void abort (void);
+
+static uint64_t safe_div_func_uint64_t_u_u (uint64_t _ui1, uint64_t _ui2)
+{
+  if (_ui2==0) return _ui1;
+  return _ui1 / _ui2;
+}
+
+static int64_t safe_div_func_int64_t_s_s (int64_t _si1, int64_t _si2)
+{
+  if (_si2==0 || (_si1==INT64_MIN && _si2==-1)) return _si1;
+  return _si1 / _si2;
+}
+
+#define safe_add_macro_int8_t_s_s(si1,si2) \
+                ((((((int8_t)(si1))>((int8_t)0)) && (((int8_t)(si2))>((int8_t)0)) && (((int8_t)(si1)) > ((INT8_MAX)-((int8_t)(si2))))) \
+                  || ((((int8_t)(si1))<((int8_t)0)) && (((int8_t)(si2))<((int8_t)0)) && (((int8_t)(si1)) < ((INT8_MIN)-((int8_t)(si2)))))) \
+                 ? ((int8_t)(si1)) \
+                 : (((int8_t)(si1)) + ((int8_t)(si2))) \
+                 ) 
+
+static int8_t
+safe_add_func_int8_t_s_s(int8_t _si1, int8_t _si2)
+{
+  return safe_add_macro_int8_t_s_s(_si1,_si2);
+}
+
+#define safe_rshift_macro_uint64_t_u_s(left,right) \
+        (((((int)(right)) < ((uint64_t)0)) \
+                         || (((int)(right)) >= sizeof(uint64_t)*CHAR_BIT)) \
+                        ? ((uint64_t)(left)) \
+                        : (((uint64_t)(left)) >> ((int)(right))))
+
+static uint64_t
+safe_rshift_func_uint64_t_u_s(uint64_t _left, int _right)
+{
+  return safe_rshift_macro_uint64_t_u_s(_left,_right);
+}
+
+#define safe_mul_macro_int32_t_s_s(si1,si2) \
+  ((((((int32_t)(si1)) > ((int32_t)0)) && (((int32_t)(si2)) > ((int32_t)0)) && (((int32_t)(si1)) > ((INT32_MAX) / ((int32_t)(si2))))) || \
+  ((((int32_t)(si1)) > ((int32_t)0)) && (((int32_t)(si2)) <= ((int32_t)0)) && (((int32_t)(si2)) < ((INT32_MIN) / ((int32_t)(si1))))) || \
+  ((((int32_t)(si1)) <= ((int32_t)0)) && (((int32_t)(si2)) > ((int32_t)0)) && (((int32_t)(si1)) < ((INT32_MIN) / ((int32_t)(si2))))) || \
+  ((((int32_t)(si1)) <= ((int32_t)0)) && (((int32_t)(si2)) <= ((int32_t)0)) && (((int32_t)(si1)) != ((int32_t)0)) && (((int32_t)(si2)) < ((INT32_MAX) / ((int32_t)(si1)))))) \
+  ? ((int32_t)(si1)) \
+  : ((int32_t)(si1)) * ((int32_t)(si2)))
+
+static int32_t
+safe_mul_func_int32_t_s_s (int32_t _si1, int32_t _si2)
+{
+  return safe_mul_macro_int32_t_s_s(_si1,_si2);
+}
+
+static int8_t g_39;
+static volatile uint8_t g_46;
+static uint8_t g_47;
+static uint8_t *g_62;
+static uint8_t g_79;
+static int8_t g_101 = -1L;
+static uint8_t *g_114;
+static uint8_t *g_126;
+static uint8_t g_133;
+
+static uint16_t func_35 (int32_t * p_36, uint64_t p_37, uint32_t p_38);
+static uint16_t func_35 (int32_t * p_36, uint64_t p_37, uint32_t p_38)
+{
+  if (g_62 != 0)
+    abort ();
+  for (g_39 = 1; g_39 < 0; g_39 = 1)
+    {
+    }
+  return 1;
+}
+
+static int32_t func_19 (int32_t p_20);
+static int32_t func_19 (int32_t p_20)
+{
+  if (1 !=
+      safe_div_func_uint64_t_u_u ((safe_div_func_int64_t_s_s (p_20, 1)),
+                                  g_101))
+    {
+      func_35 (0, 1 <= (safe_add_func_int8_t_s_s (g_47, g_46)) > p_20 < 1, 1);
+      g_133 = 1;
+      if (g_114 != 0)
+	abort ();
+      if (g_126 != 0)
+	abort ();
+    }
+  return 1;
+}
+
+static uint8_t func_2 (int32_t p_6);
+static uint8_t func_2 (int32_t p_6)
+{
+  for (1; p_6 > 1; 1)
+    return 0;
+  func_19 (g_79);
+  if (safe_mul_func_int32_t_s_s
+      ((0, 1 < (safe_rshift_func_uint64_t_u_s (1 ^ p_6, 1))),
+       (func_35 (&p_6, 1, 1) < 1)))
+    {
+    }
+  return 1;
+}
+
+int main (void)
+{
+  func_2 (1);
+  if (g_133 != 1)
+    abort ();
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/tree-ssa/pr41497.c gcc-4.4.2/gcc/testsuite/gcc.dg/tree-ssa/pr41497.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/tree-ssa/pr41497.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/tree-ssa/pr41497.c	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-options "-Os" } */
+
+extern void abort (void);
+
+unsigned int a;
+int b, c;
+
+void
+foo (void)
+{
+  b = 0;
+  do {
+    for (a = -13; a == 0; a = (unsigned short)a)
+      c = 1;
+    b++;
+  } while (b == 0);
+}
+
+int
+main ()
+{
+  foo ();
+  if (a != -13)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/pr42193.c gcc-4.4.2/gcc/testsuite/gcc.dg/vect/pr42193.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/pr42193.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/vect/pr42193.c	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target vect_long } */
+
+#include <stdarg.h>
+
+unsigned long in[6], out[6];
+
+void foo ()
+{
+  unsigned long a, b, c, d, e, f;
+
+  a = in[0];
+  b = in[1];
+  c = in[2];
+  d = in[3];
+  e = in[4];
+  f = in[5];
+
+  out[0] = 2 * a + 7 * b + 8  * c + 31 * d + 10 * e + 21 * f;
+  out[1] = 3 * a + 6 * b + 12 * c + 13 * d + 15 * e + 28 * f;
+  out[2] = 4 * a + 5 * b + 72  * c + 23 * d + 14 * e + 24 * f;
+  out[3] = 8 * a + 71 * b + 18  * c + 33 * d + 13 * e + 25 * f;
+  out[4] = 12 * a + 16 * b + 19 * c + 41 * d + 22 * e + 26 * f;
+  out[5] = 17 * a + 15 * b + 13  * c + 14 * d + 11 * e + 9 * f;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c gcc-4.4.2/gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c	2008-08-19 04:31:41.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c	2009-11-10 13:01:37.116927000 -0500
@@ -88,7 +88,7 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
-/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } } } } */
+/* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "vect" { xfail { sparc*-*-* && ilp32 } }} } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
   
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/vect-debug-pr41926.c gcc-4.4.2/gcc/testsuite/gcc.dg/vect/vect-debug-pr41926.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/vect-debug-pr41926.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/vect/vect-debug-pr41926.c	2009-11-20 09:49:22.042156000 -0500
@@ -0,0 +1,20 @@
+/* PR debug/41926 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -g -ffast-math -funroll-loops -ftree-vectorize -msse2" { target { i?86-*-* x86_64-*-* } } } */
+
+void
+foo (double (*__restrict p)[4], double (*__restrict q)[4],
+     double *__restrict prim, double scale, double pp, double pq)
+{
+  int md, mc, mb, ma, p_index = 0;
+
+  for (md = 0; md < 1; md++)
+    for (mc = 0; mc < 1; mc++)
+      for (mb = 0; mb < 1; mb++)
+	for (ma = 0; ma < 4; ma++)
+	  {
+	    double tmp = scale * prim[p_index++];
+	    p[md][ma] = p[md][ma] - tmp * pp;
+	    q[mc][ma] = q[mc][ma] - tmp * pq;
+	  }
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c gcc-4.4.2/gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c	2008-08-12 02:31:57.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/vect/vect-multitypes-12.c	2009-11-10 13:01:37.116927000 -0500
@@ -39,6 +39,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { target vect_unpack } } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! vect_unpack } } } } */
+/* { dg-final { if [ istarget sparc*-*-* ] { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail ilp32 } } else { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! vect_unpack } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c gcc-4.4.2/gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c	2008-08-19 05:06:54.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/vect/vect-multitypes-5.c	2009-11-10 13:01:37.116927000 -0500
@@ -48,6 +48,6 @@
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c gcc-4.4.2/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c	2007-09-04 09:05:19.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c	2009-11-10 13:01:37.116927000 -0500
@@ -59,7 +59,7 @@
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } }} } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-vla-1.c gcc-4.4.2/gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-vla-1.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-vla-1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-vla-1.c	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,10 @@
+/* PR 41673: bogus -Wstrict-aliasing warning from VLA dereference.  */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99 -O2 -Wall" } */
+
+int main(int argc, char *argv[])
+{
+    float x[argc];
+    float y[argc];
+    return 0 == __builtin_memcpy(y, x, argc * sizeof(*x));
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/alpha/pr42113.c gcc-4.4.2/gcc/testsuite/gcc.target/alpha/pr42113.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/alpha/pr42113.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/alpha/pr42113.c	2009-11-23 16:14:32.129759000 -0500
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int foo (int a, int b)
+{
+  int bar = a * sizeof (int);
+
+  if (b)
+    bar += sizeof (int);
+
+  return bar;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/arm/neon-thumb2-move.c gcc-4.4.2/gcc/testsuite/gcc.target/arm/neon-thumb2-move.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/arm/neon-thumb2-move.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/arm/neon-thumb2-move.c	2009-10-20 10:41:01.874331000 -0400
@@ -0,0 +1,98 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2 -mthumb -march=armv7-a -mfloat-abi=softfp -mfpu=neon" } */
+
+#include <arm_neon.h>
+#include <stddef.h>
+
+void *
+memset (DST, C, LENGTH)
+     void *DST;
+     int C;
+     size_t LENGTH;
+{
+  void* DST0 = DST;
+  unsigned char C_BYTE = C;
+
+
+  if (__builtin_expect(LENGTH < 4, 1)) {
+    size_t i = 0;
+    while (i < LENGTH) {
+      ((char*)DST)[i] = C_BYTE;
+      i++;
+    }
+    return DST;
+  }
+
+  const char* DST_end = (char*)DST + LENGTH;
+
+
+  while ((uintptr_t)DST % 4 != 0) {
+    *(char*) (DST++) = C_BYTE;
+  }
+
+
+  uint32_t C_SHORTWORD = (uint32_t)(unsigned char)(C_BYTE) * 0x01010101;
+
+
+  if (__builtin_expect(DST_end - (char*)DST >= 16, 0)) {
+    while ((uintptr_t)DST % 16 != 0) {
+      *((uint32_t*)((char*)(DST) + (0))) = C_SHORTWORD;
+      DST += 4;
+    }
+
+
+    uint8x16_t C_WORD = vdupq_n_u8(C_BYTE);
+
+
+
+
+
+    size_t i = 0;
+    LENGTH = DST_end - (char*)DST;
+    while (i + 16 * 16 <= LENGTH) {
+      *((uint8x16_t*)((char*)(DST) + (i))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 1))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 2))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 3))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 4))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 5))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 6))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 7))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 8))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 9))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 10))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 11))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 12))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 13))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 14))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 15))) = C_WORD;
+      i += 16 * 16;
+    }
+    while (i + 16 * 4 <= LENGTH) {
+      *((uint8x16_t*)((char*)(DST) + (i))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 1))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 2))) = C_WORD;
+      *((uint8x16_t*)((char*)(DST) + (i + 16 * 3))) = C_WORD;
+      i += 16 * 4;
+    }
+    while (i + 16 <= LENGTH) {
+      *((uint8x16_t*)((char*)(DST) + (i))) = C_WORD;
+      i += 16;
+    }
+    DST += i;
+  }
+
+  while (4 <= DST_end - (char*)DST) {
+    *((uint32_t*)((char*)(DST) + (0))) = C_SHORTWORD;
+    DST += 4;
+  }
+
+
+  while ((char*)DST < DST_end) {
+    *((char*)DST) = C_BYTE;
+    DST++;
+  }
+
+  return DST0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/arm/synchronize.c gcc-4.4.2/gcc/testsuite/gcc.target/arm/synchronize.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/arm/synchronize.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/arm/synchronize.c	2009-12-11 21:46:22.410183000 -0500
@@ -0,0 +1,6 @@
+/* { dg-final { scan-assembler "__sync_synchronize" { target arm*-*-linux-*eabi } } } */
+
+void *foo (void)
+{
+  __sync_synchronize();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/i386/mmx-3dnow-check.h gcc-4.4.2/gcc/testsuite/gcc.target/i386/mmx-3dnow-check.h
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/i386/mmx-3dnow-check.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/i386/mmx-3dnow-check.h	2009-12-30 06:34:57.597575000 -0500
@@ -0,0 +1,21 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "cpuid.h"
+
+static void mmx_3dnow_test (void);
+
+int
+main ()
+{
+  unsigned int eax, ebx, ecx, edx;
+ 
+  if (!__get_cpuid (0x80000001, &eax, &ebx, &ecx, &edx))
+    return 0;
+
+  /* Run 3DNow! test only if host has 3DNow! support.  */
+  if (edx & bit_3DNOW)
+    mmx_3dnow_test ();
+
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/i386/pr41900.c gcc-4.4.2/gcc/testsuite/gcc.target/i386/pr41900.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/i386/pr41900.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/i386/pr41900.c	2009-11-04 09:14:49.725614000 -0500
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O2 -fomit-frame-pointer -mpreferred-stack-boundary=2" } */
+
+int main ()
+{
+  volatile unsigned code = 0xc3;
+
+  ((void (*)(void)) &code) ();
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "call\[ \\t\]+\\*%esp" } } */
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/i386/pr41963.c gcc-4.4.2/gcc/testsuite/gcc.target/i386/pr41963.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/i386/pr41963.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/i386/pr41963.c	2009-11-08 13:10:10.344107000 -0500
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ffast-math -mrecip" } */
+#include <math.h>
+
+extern float sqrtf(float);
+
+static __attribute__((noinline)) void f (float *dst, float *src)
+{
+  int i, j;
+  for (i = 0; i < 2; i++)
+    {
+      float len;
+      dst[0] = src[0];
+      dst[1] = src[1];
+      len = sqrtf (dst[0] * dst[0] + dst[1] * dst[1]);
+      if (len > 0.5f)
+	{
+	  len = 1.0f / len;
+	  dst[0] *= len;
+	  dst[1] *= len;
+	}
+    }
+}
+
+extern void abort (void);
+
+int main()
+{
+  float dst[2], src[2];
+  src[0] = 2.0f;
+  src[1] = 5.0f;
+  f (dst, src);
+  if (fabsf (dst[0] * dst[0] + dst[1] * dst[1] - 1.0f) > 0.01f)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/i386/pr42549.c gcc-4.4.2/gcc/testsuite/gcc.target/i386/pr42549.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/i386/pr42549.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/i386/pr42549.c	2009-12-30 06:34:57.597575000 -0500
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -m3dnow" } */
+
+#include "mmx-3dnow-check.h"
+
+#include <mm3dnow.h>
+
+typedef union {
+  float f[2];
+  __m64 v;
+} vec_t;
+
+void __attribute__ ((noinline))
+Butterfly_3 (__m64 * D, __m64 SC)
+{
+  __m64 T, T1;
+
+  T = _m_pfmul (D[1], SC);
+  T1 = D[0];
+  D[0] = _m_pfadd (T1, T);
+  D[1] = _m_pfsub (T1, T);
+}
+
+static void
+mmx_3dnow_test (void)
+{
+  vec_t D[2] = { { .f = { 2.0f, 3.0f } },
+		 { .f = { 4.0f, 5.0f } } };
+
+  const vec_t SC = { .f = { 1.0f, 1.0f } };
+
+  Butterfly_3 (&D[0].v, SC.v);
+  _m_femms ();
+
+  if (D[1].f[0] != -2.0f || D[1].f[1] != -2.0f)
+    abort ();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/mips/dsp-lhx.c gcc-4.4.2/gcc/testsuite/gcc.target/mips/dsp-lhx.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/mips/dsp-lhx.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/mips/dsp-lhx.c	2009-12-02 18:32:22.205197000 -0500
@@ -0,0 +1,10 @@
+/* Test MIPS32 DSP LHX instruction */
+/* { dg-do compile } */
+/* { dg-options "-mgp32 -mdsp -O2" } */
+
+/* { dg-final { scan-assembler "\tlhx\t" } } */
+
+NOMIPS16 signed short test (signed short *a, int index)
+{
+  return a[index];
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/mips/dsp-no-lhx.c gcc-4.4.2/gcc/testsuite/gcc.target/mips/dsp-no-lhx.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/mips/dsp-no-lhx.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/mips/dsp-no-lhx.c	2009-12-02 18:32:22.205197000 -0500
@@ -0,0 +1,10 @@
+/* Test MIPS32 DSP LHX instruction */
+/* { dg-do compile } */
+/* { dg-options "-mgp32 -mdsp -O2" } */
+
+/* { dg-final { scan-assembler-not "\tlhx\t" } } */
+
+NOMIPS16 unsigned short test (unsigned short *a, int index)
+{
+  return a[index];
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gcc.target/spu/intrinsics-3.c gcc-4.4.2/gcc/testsuite/gcc.target/spu/intrinsics-3.c
--- gcc-4.4.2.orig/gcc/testsuite/gcc.target/spu/intrinsics-3.c	2008-02-08 07:46:33.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gcc.target/spu/intrinsics-3.c	2009-12-04 14:52:42.853505000 -0500
@@ -19,3 +19,24 @@
 {
   vec_uint4 out = spu_convtu (in[0], 128); /* { dg-error "expects an integer literal in the range" "0, 127"  }*/
 }
+
+/* Test that these intrinsics accept non-literal arguments */
+void f4 (vec_uint4 *in, int n)
+{
+  vec_float4 out = spu_convtf (in[0], n);
+}
+
+void f5 (vec_int4 *in, int n)
+{
+  vec_float4 out = spu_convtf (in[0], n);
+}
+
+void f6 (vec_float4 *in, int n)
+{
+  vec_int4 out = spu_convts (in[0], n);
+}
+
+void f7 (vec_float4 *in, int n)
+{
+  vec_uint4 out = spu_convtu (in[0], n);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/guard2.C gcc-4.4.2/gcc/testsuite/g++.dg/abi/guard2.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/guard2.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/abi/guard2.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,16 @@
+// PR c++/41611
+// Test that the guard gets its own COMDAT group.
+// { dg-final { scan-assembler "_ZGVZN1A1fEvE1i,comdat" { target *-*-linux* } } }
+
+struct A {
+  static int f()
+  {
+    static int &i = *new int();
+    return i;
+  }
+};
+
+int main()
+{
+  return A::f();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/mangle14.C gcc-4.4.2/gcc/testsuite/g++.dg/abi/mangle14.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/mangle14.C	2003-12-23 11:53:53.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/abi/mangle14.C	2009-12-22 09:28:55.905766000 -0500
@@ -1,5 +1,6 @@
 // { dg-do compile }
 // { dg-options "-Wabi -fabi-version=1" }
+// { dg-final { scan-assembler "_Z1g1SIXadsr1ANS0_1fIiEEivEE" } }
 
 struct A {
   template <typename T> int f ();
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/mangle33.C gcc-4.4.2/gcc/testsuite/g++.dg/abi/mangle33.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/mangle33.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/abi/mangle33.C	2009-10-21 11:17:12.414829000 -0400
@@ -0,0 +1,19 @@
+// Testcase for mangling very long names.
+
+#define N \
+abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm
+
+namespace N {
+  int i;
+}
+
+#undef N
+#define N \
+abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk
+
+namespace N {
+  int j;
+}
+
+// { dg-final { scan-assembler "_ZN4043abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm1iE" } }
+// { dg-final { scan-assembler "_ZN4041abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk1jE" } }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/mangle34.C gcc-4.4.2/gcc/testsuite/g++.dg/abi/mangle34.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/mangle34.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/abi/mangle34.C	2009-10-23 17:32:35.147891000 -0400
@@ -0,0 +1,42 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/40808
+// { dg-do compile }
+// This tests the mangling of empty template argument list in a template
+// id.
+// { dg-final {scan-assembler "_ZNK5DummyclI3GenEENT_3SigIE10ResultTypeERKS2_" } }
+
+
+struct Void {};
+
+template <class R> struct FunType {
+  typedef R ResultType;
+};
+
+struct WrongNumberOfSigArgs {};
+
+template <typename R> struct CFunType {
+  template <class Dummy1=Void, class Dummy2=Void> struct Sig : public
+FunType<WrongNumberOfSigArgs> {};
+  template <class Dummy> struct Sig<Void,Dummy> : public FunType<R> {};
+};
+
+struct Dummy {
+  template <typename F> typename F::template Sig<>::ResultType operator()(F
+const& f) const {
+    return typename F::template Sig<>::ResultType(0);
+  }
+};
+
+struct Gen: public CFunType<int> {
+  int operator()() const {return 0;}
+  Gen() {}
+};
+
+int myfunction() {
+  return Dummy()(Gen());
+}
+
+int main() {
+  myfunction();
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/regparm1.C gcc-4.4.2/gcc/testsuite/g++.dg/abi/regparm1.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/regparm1.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/abi/regparm1.C	2009-11-09 15:28:04.295002000 -0500
@@ -0,0 +1,51 @@
+// PR c++/29911 (9381)
+// { dg-options -std=c++0x }
+// { dg-do run { target i?86-*-* x86_64-*-* } }
+
+extern "C" int printf(const char *, ...);
+
+void *save_this;
+int *save_addr1, *save_addr2;
+
+int fail;
+
+struct Base
+{
+  __attribute((regparm(3))) void
+  set(int *addr1, int *addr2)
+  {
+    if (this != save_this)
+      {
+	++fail;
+	printf("error! this == %p, should be %p\n", this, save_this);
+      }
+    if (addr1 != save_addr1)
+      {
+	++fail;
+	printf("error! addr1 == %p, should be %p\n", addr1, save_addr1);
+      }
+    if (addr2 != save_addr2)
+      {
+	++fail;
+	printf("error! addr2 == %p, should be %p\n", addr2, save_addr1);
+      }
+  }
+};
+
+int main()
+{
+  void (__attribute((regparm(3))) Base::* pfm)(int *, int *) = &Base::set;
+  __typeof (&Base::set) pfm2 = &Base::set;
+  decltype (&Base::set) pfm3 = &Base::set;
+  auto pfm4 = &Base::set;
+
+  Base obj; save_this = &obj;
+  int x, y; save_addr1 = &x; save_addr2 = &y;
+
+  (obj.* pfm) (&x, &y);
+  (obj.* pfm2) (&x, &y);
+  (obj.* pfm3) (&x, &y);
+  (obj.* pfm4) (&x, &y);
+
+  return fail;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/thunk5.C gcc-4.4.2/gcc/testsuite/g++.dg/abi/thunk5.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/abi/thunk5.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/abi/thunk5.C	2009-11-04 14:55:56.458671000 -0500
@@ -0,0 +1,13 @@
+// PR c++/35067
+// The thunks should be weak even on targets without one-only support.
+// { dg-require-weak "" }
+// { dg-final { scan-assembler "weak.*ZTv" } }
+
+struct A
+{
+  virtual ~A() { }
+};
+
+struct B: virtual A { };
+
+B b;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/auto12.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/auto12.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/auto12.C	2009-04-02 14:37:57.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/auto12.C	1969-12-31 19:00:00.000000000 -0500
@@ -1,63 +0,0 @@
-// More auto/decltype mangling tests.
-// { dg-options "-std=c++0x" }
-
-template <class T>
-struct B
-{
-  static int i;
-};
-
-int&& x();
-
-template <class T>
-struct A
-{
-  static int i;
-  static int &ir;
-  static int &&irr;
-  template <class U>
-  auto f(U u) -> decltype (u + i);
-  template <class U>
-  auto fr(U u) -> decltype (u + ir);
-  template <class U>
-  auto frr(U u) -> decltype (u + irr);
-  template <class U>
-  auto g(U u) -> decltype (u + sizeof (i));
-  template <class U>
-  auto h(U u) -> decltype (u + B<U>::i);
-  template <class U>
-  auto j(U u) -> decltype (u + x());
-};
-
-template<class T> template<class U>
-auto A<T>::f(U u) -> decltype (u + i)
-{
-  return u + i;
-}
-
-template <class... Args>
-int f (Args... args);
-
-template <class... Args>
-auto g (Args... args) -> decltype (f ((args+1)...))
-{
-  return (f ((args+1)...));
-}
-
-int main()
-{
-  // { dg-final { scan-assembler  "_ZN1AIiE1fIiEEDTplfp_L_ZNS0_1iEEET_" } }
-  A<int>().f(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE2frIiEEDTplfp_L_ZNS0_2irEEET_" } }
-  A<int>().fr(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE3frrIiEEDTplfp_L_ZNS0_3irrEEET_" } }
-  A<int>().frr(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE1gIiEEDTplfp_szL_ZNS0_1iEEET_" } }
-  A<int>().g(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE1hIiEEDTplfp_sr1BIT_E1iES3_" } }
-  A<int>().h(1);
-  // { dg-final { scan-assembler  "_ZN1AIiE1jIiEEDTplfp_clL_Z1xvEEET_" } }
-  A<int>().j(1);
-  // { dg-final { scan-assembler  "_Z1gIIidEEDTcl1fspplfp_Li1EEEDpT_" } }  
-  g(42, 1.0);
-}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/auto13.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/auto13.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/auto13.C	2008-12-21 16:01:48.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/auto13.C	1969-12-31 19:00:00.000000000 -0500
@@ -1,11 +0,0 @@
-// PR c++/38597
-// { dg-options "-std=c++0x" }
-
-template<class T, class U>
-auto f(T,U) -> decltype(T() + U())
-{ return T() + U(); }
-
-template<class T> void g(T){}
-
-int main() { g(f); }		// { dg-error "no matching function" }
-
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/auto6.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/auto6.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/auto6.C	2009-04-02 14:37:57.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/auto6.C	1969-12-31 19:00:00.000000000 -0500
@@ -1,118 +0,0 @@
-// Tests for late-specified return type.
-// { dg-options "-std=c++0x" }
-
-auto f() -> int
-{
-  return 0;
-}
-
-template<class T, class U>
-auto add(T t, U u) -> decltype (t+u)
-{
-  return t+u;
-}
-
-template<class T, class U>
-decltype(T()+U()) add2(T t, U u)
-{
-  return t+u;
-}
-
-template <class T, class U>
-U ag (T, U)
-{
-  return U();
-}
-
-template<class T, class U>
-auto add3(T t, U u) -> decltype (ag(t,u))
-{
-  return ag(t,u);
-}
-
-template<class T, class U>
-decltype(*(T*)0+*(U*)0) add4(T t, U u)
-{
-  return t+u;
-}
-
-template <class T>
-struct A
-{
-  T f() {}
-  template <class U>
-  T g() {}
-  template <class V>
-  struct B
-  {
-    int MEM;
-  };
-};
-
-template <class T>
-auto f(T* t) -> decltype (t->f())
-{
-  return t->f();
-}
-
-template <class T>
-auto g(T t) -> decltype (t.f())
-{
-  return t.f();
-}
-
-template <class T, class U>
-auto h(T t, U u) -> decltype (t.template g<U>())
-{
-  return t.template g<U>();
-}
-
-struct D { };
-struct C: public A<int>::B<D>
-{
-};
-
-template <class T, class U, class V>
-auto k(T t, U u, V v) -> decltype (t.U::template B<V>::MEM)
-{
-  return t.U::template B<V>::MEM;
-}
-
-// For these two examples we can elide the 'decltype' and just mangle the type.
-template <class T>
-auto l(T t) -> decltype (t)
-{
-  return t;
-}
-
-template <class T, T u>
-auto m(T t) -> decltype (u)
-{
-  return t;
-}
-
-A<int> a, *p;
-
-int main()
-{
-  // { dg-final { scan-assembler  "_Z3addIidEDTplfp_fp0_ET_T0_" } }
-  auto i = add(1, 2.0);
-  // { dg-final { scan-assembler "_Z4add4IidEDTpldecvPT_Li0EdecvPT0_Li0EES0_S2_" } }
-  auto i4 = add4(1, 2.0);
-  // { dg-final { scan-assembler "_Z4add2IidEDTplcvT__EcvT0__EES0_S1_" } }
-  auto i2 = add2(1, 2.0);
-  // { dg-final { scan-assembler "_Z4add3IidEDTcl2agfp_fp0_EET_T0_" } }
-  auto i3 = add3(1, 2.0);
-  // { dg-final { scan-assembler "_Z1fI1AIiEEDTclptfp_1fEEPT_" } }
-  f(p);
-  // { dg-final { scan-assembler "_Z1gI1AIiEEDTcldtfp_1fEET_" } }
-  g(a);
-  // { dg-final { scan-assembler "_Z1hI1AIiEdEDTcldtfp_1gIT0_EEET_S2_" } }
-  h(a,1.0);
-  // { dg-final { scan-assembler "_Z1kI1C1AIiE1DEDtdtfp_srNT0_1BIT1_EE3MEMET_S4_S6_" } }
-  k( C(), A<int>(), D() );
-  // { dg-final { scan-assembler "_Z1lIiET_S0_" } }
-  l(1);
-  // { dg-final { scan-assembler "_Z1mIiLi1EET_S0_" } }
-  m<int,1>(1);
-}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/auto8.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/auto8.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/auto8.C	2008-11-18 13:11:32.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/auto8.C	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-// PR c++/37967
-// Negative test for auto
-// { dg-options "-std=c++0x" }
-
-auto f1 () -> int;
-auto f2 ();		// { dg-error "without late return type" }
-int f3 () -> int;	// { dg-error "late return type" }
-auto *f4 () -> int;	// { dg-error "late return type" }
-
-struct A
-{
-  auto f5 () const -> int;
-  auto f6 ();		// { dg-error "without late return type" }
-  int f7 () -> int;	// { dg-error "late return type" }
-  auto *f8 () -> int;	// { dg-error "late return type" }
-};
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/decltype18.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/decltype18.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/decltype18.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/decltype18.C	2009-10-18 01:13:05.713806000 -0400
@@ -0,0 +1,5 @@
+// PR c++/37875
+// { dg-options "-std=c++0x" }
+
+template <typename> struct X {};
+X<decltype(1 > 2)> x;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg1.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg1.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg1.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg1.C	2009-10-18 01:13:05.713806000 -0400
@@ -0,0 +1,7 @@
+// PR c++/37766
+// { dg-options -std=c++0x }
+
+int a = 1;
+template<int& b = a> void f() {
+  f<>();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/initlist25.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/initlist25.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/initlist25.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/initlist25.C	2009-11-01 01:27:04.705718000 -0400
@@ -0,0 +1,17 @@
+// PR c++/41754
+// { dg-options -std=c++0x }
+// { dg-do run }
+
+#include <map>
+#include <string>
+#include <iostream>
+
+using namespace std;
+
+int main()
+{
+        map<string, string> m;
+        m.insert({{"t", "t"}, {"y", "y"}});
+
+        return 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/initlist26.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/initlist26.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/initlist26.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/initlist26.C	2009-11-17 02:21:43.524362000 -0500
@@ -0,0 +1,10 @@
+// PR c++/42059
+// { dg-do compile }
+// { dg-options "-std=gnu++0x" }
+
+void
+foo (int i)
+{
+  int a[i];
+  a = { }; // { dg-error "may not be initialized" }
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/initlist27.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/initlist27.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/initlist27.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/initlist27.C	2009-11-17 02:26:52.028023000 -0500
@@ -0,0 +1,5 @@
+// PR c++/42061
+// { dg-do compile }
+// { dg-options "-std=c++0x" }
+
+int& i = { j };	// { dg-error "invalid initialization|was not declared" }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/initlist29.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/initlist29.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/initlist29.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/initlist29.C	2009-12-26 11:24:53.468272000 -0500
@@ -0,0 +1,14 @@
+// PR c++/42331
+// { dg-options "-std=c++0x" }
+
+class Mesh
+{
+public:
+  Mesh(const char*)
+  { typele={0}; }		// { dg-error "" }
+
+private:
+  int typele[7][2];
+};
+
+Mesh m(0);
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/inline-ns3.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/inline-ns3.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/inline-ns3.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/inline-ns3.C	2009-11-03 16:33:55.537602000 -0500
@@ -0,0 +1,24 @@
+namespace C
+{
+  void f();
+}
+
+namespace B
+{
+  using namespace C;
+
+  inline namespace B1
+  {
+    void f();
+  }
+}
+
+namespace A
+{
+  using namespace B;
+}
+
+int main()
+{
+  A::f();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/rv-reinterpret.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/rv-reinterpret.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/rv-reinterpret.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/rv-reinterpret.C	2009-10-19 03:39:13.188828000 -0400
@@ -0,0 +1,11 @@
+// { dg-options -std=c++0x }
+// { dg-do compile }
+
+void f(int &);
+void f(int &&ir) { ir = 42; }
+int main()
+{
+  int x;
+  f(reinterpret_cast<int&&>(x));
+  return (x != 42);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing1.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing1.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing1.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing1.C	2009-10-18 01:13:05.713806000 -0400
@@ -0,0 +1,118 @@
+// Tests for late-specified return type.
+// { dg-options "-std=c++0x" }
+
+auto f() -> int
+{
+  return 0;
+}
+
+template<class T, class U>
+auto add(T t, U u) -> decltype (t+u)
+{
+  return t+u;
+}
+
+template<class T, class U>
+decltype(T()+U()) add2(T t, U u)
+{
+  return t+u;
+}
+
+template <class T, class U>
+U ag (T, U)
+{
+  return U();
+}
+
+template<class T, class U>
+auto add3(T t, U u) -> decltype (ag(t,u))
+{
+  return ag(t,u);
+}
+
+template<class T, class U>
+decltype(*(T*)0+*(U*)0) add4(T t, U u)
+{
+  return t+u;
+}
+
+template <class T>
+struct A
+{
+  T f() {}
+  template <class U>
+  T g() {}
+  template <class V>
+  struct B
+  {
+    int MEM;
+  };
+};
+
+template <class T>
+auto f(T* t) -> decltype (t->f())
+{
+  return t->f();
+}
+
+template <class T>
+auto g(T t) -> decltype (t.f())
+{
+  return t.f();
+}
+
+template <class T, class U>
+auto h(T t, U u) -> decltype (t.template g<U>())
+{
+  return t.template g<U>();
+}
+
+struct D { };
+struct C: public A<int>::B<D>
+{
+};
+
+template <class T, class U, class V>
+auto k(T t, U u, V v) -> decltype (t.U::template B<V>::MEM)
+{
+  return t.U::template B<V>::MEM;
+}
+
+// For these two examples we can elide the 'decltype' and just mangle the type.
+template <class T>
+auto l(T t) -> decltype (t)
+{
+  return t;
+}
+
+template <class T, T u>
+auto m(T t) -> decltype (u)
+{
+  return t;
+}
+
+A<int> a, *p;
+
+int main()
+{
+  // { dg-final { scan-assembler  "_Z3addIidEDTplfp_fp0_ET_T0_" } }
+  auto i = add(1, 2.0);
+  // { dg-final { scan-assembler "_Z4add4IidEDTpldecvPT_Li0EdecvPT0_Li0EES0_S2_" } }
+  auto i4 = add4(1, 2.0);
+  // { dg-final { scan-assembler "_Z4add2IidEDTplcvT__EcvT0__EES0_S1_" } }
+  auto i2 = add2(1, 2.0);
+  // { dg-final { scan-assembler "_Z4add3IidEDTcl2agfp_fp0_EET_T0_" } }
+  auto i3 = add3(1, 2.0);
+  // { dg-final { scan-assembler "_Z1fI1AIiEEDTclptfp_1fEEPT_" } }
+  f(p);
+  // { dg-final { scan-assembler "_Z1gI1AIiEEDTcldtfp_1fEET_" } }
+  g(a);
+  // { dg-final { scan-assembler "_Z1hI1AIiEdEDTcldtfp_1gIT0_EEET_S2_" } }
+  h(a,1.0);
+  // { dg-final { scan-assembler "_Z1kI1C1AIiE1DEDtdtfp_srNT0_1BIT1_EE3MEMET_S4_S6_" } }
+  k( C(), A<int>(), D() );
+  // { dg-final { scan-assembler "_Z1lIiET_S0_" } }
+  l(1);
+  // { dg-final { scan-assembler "_Z1mIiLi1EET_S0_" } }
+  m<int,1>(1);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing2.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing2.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing2.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing2.C	2009-10-18 01:13:05.713806000 -0400
@@ -0,0 +1,16 @@
+// PR c++/37967
+// Negative test for auto
+// { dg-options "-std=c++0x" }
+
+auto f1 () -> int;
+auto f2 ();		// { dg-error "without late return type" }
+int f3 () -> int;	// { dg-error "late return type" }
+auto *f4 () -> int;	// { dg-error "late return type" }
+
+struct A
+{
+  auto f5 () const -> int;
+  auto f6 ();		// { dg-error "without late return type" }
+  int f7 () -> int;	// { dg-error "late return type" }
+  auto *f8 () -> int;	// { dg-error "late return type" }
+};
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing3.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing3.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing3.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing3.C	2009-10-18 01:13:05.713806000 -0400
@@ -0,0 +1,63 @@
+// More auto/decltype mangling tests.
+// { dg-options "-std=c++0x" }
+
+template <class T>
+struct B
+{
+  static int i;
+};
+
+int&& x();
+
+template <class T>
+struct A
+{
+  static int i;
+  static int &ir;
+  static int &&irr;
+  template <class U>
+  auto f(U u) -> decltype (u + i);
+  template <class U>
+  auto fr(U u) -> decltype (u + ir);
+  template <class U>
+  auto frr(U u) -> decltype (u + irr);
+  template <class U>
+  auto g(U u) -> decltype (u + sizeof (i));
+  template <class U>
+  auto h(U u) -> decltype (u + B<U>::i);
+  template <class U>
+  auto j(U u) -> decltype (u + x());
+};
+
+template<class T> template<class U>
+auto A<T>::f(U u) -> decltype (u + i)
+{
+  return u + i;
+}
+
+template <class... Args>
+int f (Args... args);
+
+template <class... Args>
+auto g (Args... args) -> decltype (f ((args+1)...))
+{
+  return (f ((args+1)...));
+}
+
+int main()
+{
+  // { dg-final { scan-assembler  "_ZN1AIiE1fIiEEDTplfp_L_ZNS0_1iEEET_" } }
+  A<int>().f(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE2frIiEEDTplfp_L_ZNS0_2irEEET_" } }
+  A<int>().fr(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE3frrIiEEDTplfp_L_ZNS0_3irrEEET_" } }
+  A<int>().frr(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE1gIiEEDTplfp_szL_ZNS0_1iEEET_" } }
+  A<int>().g(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE1hIiEEDTplfp_sr1BIT_E1iES3_" } }
+  A<int>().h(1);
+  // { dg-final { scan-assembler  "_ZN1AIiE1jIiEEDTplfp_clL_Z1xvEEET_" } }
+  A<int>().j(1);
+  // { dg-final { scan-assembler  "_Z1gIIidEEDTcl1fspplfp_Li1EEEDpT_" } }  
+  g(42, 1.0);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing4.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing4.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing4.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing4.C	2009-10-18 01:13:05.713806000 -0400
@@ -0,0 +1,11 @@
+// PR c++/38597
+// { dg-options "-std=c++0x" }
+
+template<class T, class U>
+auto f(T,U) -> decltype(T() + U())
+{ return T() + U(); }
+
+template<class T> void g(T){}
+
+int main() { g(f); }		// { dg-error "no matching function" }
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing5.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing5.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/trailing5.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/trailing5.C	2009-10-18 01:13:05.713806000 -0400
@@ -0,0 +1,10 @@
+// PR c++/38798, DR 770
+// { dg-options -std=c++0x }
+
+struct A {};
+auto foo() -> struct A {}
+
+enum B {};
+auto bar() -> enum B {}
+
+auto baz() -> struct C {} {}	// { dg-error "" }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/variadic96.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/variadic96.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/variadic96.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/variadic96.C	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,26 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/41785
+// { dg-options -std=c++0x }
+
+struct a {};
+
+template < typename T, typename ENCLOSING >
+struct base;
+
+template < typename... T >
+struct derived
+  : public base< T, derived< T... > >...
+{};
+
+template < typename... T>
+struct base< a, derived< T... > >
+{
+  typedef derived< T... >
+          Derived;
+};
+
+int main()
+{
+  derived< a > instance;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/variadic98.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/variadic98.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/variadic98.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/variadic98.C	2009-12-22 13:17:53.777443000 -0500
@@ -0,0 +1,411 @@
+// PR c++/42358
+// { dg-do assemble }
+// { dg-options -std=c++0x }
+
+typedef __PTRDIFF_TYPE__ ptrdiff_t;
+typedef __SIZE_TYPE__ size_t;
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    using ::size_t;
+}
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    struct __sfinae_types   {
+	typedef char __one;
+	typedef struct {
+	} __two;
+    };
+    template<typename _Tp, _Tp __v>     struct integral_constant     {
+	static const _Tp value = __v;
+	typedef _Tp value_type;
+	typedef integral_constant<_Tp, __v> type;
+    };
+    typedef integral_constant<bool, false> false_type;
+    template<typename>     struct remove_cv;
+    template<typename>     struct __is_void_helper     : public false_type {
+    };
+    template<typename _Tp>     struct is_void     : public integral_constant<bool, (__is_void_helper<typename           remove_cv<_Tp>::type>::value)>     {
+    };
+    template<typename>     struct is_array     : public false_type {
+    };
+    template<typename>     struct is_function     : public false_type {
+    };
+    template<typename, unsigned _Uint = 0>     struct extent     : public integral_constant<std::size_t, 0> {
+    };
+    template<typename _Tp>     struct remove_const     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     struct remove_volatile     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     struct remove_cv     {
+	typedef typename       remove_const<typename remove_volatile<_Tp>::type>::type type;
+    };
+    template<typename>     struct is_lvalue_reference     : public false_type {
+    };
+    template<typename>     struct is_rvalue_reference     : public false_type {
+    };
+    template<typename _Tp>     struct is_reference     : public integral_constant<bool, (is_lvalue_reference<_Tp>::value           || is_rvalue_reference<_Tp>::value)>     {
+    };
+    template<typename _Tp>     struct remove_reference     {
+	typedef _Tp type;
+    };
+    template<typename _Tp,     bool = !is_reference<_Tp>::value && !is_void<_Tp>::value>     struct __add_rvalue_reference_helper     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     struct add_rvalue_reference     : public __add_rvalue_reference_helper<_Tp>     {
+    };
+    template<typename _Tp>     typename add_rvalue_reference<_Tp>::type declval();
+    template<typename _From, typename _To,     bool = (is_void<_From>::value || is_void<_To>::value      || is_function<_To>::value || is_array<_To>::value)>     struct __is_convertible_helper     {
+    };
+    template<typename _From, typename _To>     struct __is_convertible_helper<_From, _To, false>     : public __sfinae_types     {
+	static __one __test(_To);
+	static __two __test(...);
+	static const bool __value = sizeof(__test(declval<_From>())) == 1;
+    };
+    template<typename _From, typename _To>     struct is_convertible     : public integral_constant<bool,           __is_convertible_helper<_From, _To>::__value>     {
+    };
+    template<bool, typename _Tp = void>     struct enable_if     {
+    };
+    template<typename _Tp>     struct enable_if<true, _Tp>     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     struct identity     {
+	typedef _Tp type;
+    };
+    template<typename _Tp>     inline typename enable_if<!is_lvalue_reference<_Tp>::value, _Tp&&>::type     forward(typename std::identity<_Tp>::type& __t)     {
+    }
+    template<typename _Tp>     inline typename enable_if<is_lvalue_reference<_Tp>::value, _Tp>::type     forward(typename std::identity<_Tp>::type __t)     {
+    }
+    template<typename _Tp>     inline typename std::remove_reference<_Tp>::type&&     move(_Tp&& __t)     {
+    }
+    template<class _T1, class _T2>     struct pair     {
+	typedef _T1 first_type;
+	typedef _T2 second_type;
+	_T1 first;
+	_T2 second;
+	template<class _U1, class = typename         std::enable_if<std::is_convertible<_U1, _T1>::value>::type>         pair(_U1&& __x, const _T2& __y)  : first(std::forward<_U1>(__x)),    second(__y) {
+	}
+	template<class _U2, class = typename         std::enable_if<std::is_convertible<_U2, _T2>::value>::type>         pair(const _T1& __x, _U2&& __y)  : first(__x),    second(std::forward<_U2>(__y)) {
+	}
+	template<class _U1, class _U2, class = typename         std::enable_if<std::is_convertible<_U1, _T1>::value          && std::is_convertible<_U2, _T2>::value>::type>         pair(_U1&& __x, _U2&& __y)  : first(std::forward<_U1>(__x)),    second(std::forward<_U2>(__y)) {
+	}
+	template<class _U1, class _U2>         pair(pair<_U1, _U2>&& __p)  : first(std::move(__p.first)),    second(std::move(__p.second)) {
+	}
+	template<class _U1, class _U2>         pair&         operator=(pair<_U1, _U2>&& __p)  {
+	}
+    };
+    struct input_iterator_tag {
+    };
+    struct output_iterator_tag {
+    };
+    struct forward_iterator_tag : public input_iterator_tag {
+    };
+    struct bidirectional_iterator_tag : public forward_iterator_tag {
+    };
+    template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,            typename _Pointer = _Tp*, typename _Reference = _Tp&>     struct iterator     {
+	typedef _Category iterator_category;
+	typedef _Tp value_type;
+	typedef _Distance difference_type;
+	typedef _Pointer pointer;
+	typedef _Reference reference;
+    };
+    template<typename _Iterator>     struct iterator_traits     {
+	typedef typename _Iterator::iterator_category iterator_category;
+	typedef typename _Iterator::value_type value_type;
+	typedef typename _Iterator::difference_type difference_type;
+	typedef typename _Iterator::pointer pointer;
+	typedef typename _Iterator::reference reference;
+    };
+    template<typename _Iter>     inline typename iterator_traits<_Iter>::iterator_category     __iterator_category(const _Iter&)     {
+    }
+    template<typename _InputIterator>     inline typename iterator_traits<_InputIterator>::difference_type     __distance(_InputIterator __first, _InputIterator __last,                input_iterator_tag)     {
+    }
+    template<typename _InputIterator>     inline typename iterator_traits<_InputIterator>::difference_type     distance(_InputIterator __first, _InputIterator __last)     {
+	return std::__distance(__first, __last,         std::__iterator_category(__first));
+    }
+    template<typename _Iterator>     class reverse_iterator     : public iterator<typename iterator_traits<_Iterator>::iterator_category,         typename iterator_traits<_Iterator>::value_type,         typename iterator_traits<_Iterator>::difference_type,         typename iterator_traits<_Iterator>::pointer,                       typename iterator_traits<_Iterator>::reference>     {
+    };
+    template<typename _Container>     class back_insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {
+    };
+}
+namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
+    template<typename _Tp>     class new_allocator     {
+    public:
+	typedef size_t size_type;
+	typedef ptrdiff_t difference_type;
+	typedef _Tp* pointer;
+	typedef const _Tp* const_pointer;
+	typedef _Tp& reference;
+	typedef const _Tp& const_reference;
+	typedef _Tp value_type;
+	new_allocator() throw() {
+	}
+	new_allocator(const new_allocator&) throw() {
+	}
+	template<typename _Tp1>         new_allocator(const new_allocator<_Tp1>&) throw() {
+	}
+	template<typename... _Args>         void         construct(pointer __p, _Args&&... __args)  {
+	}
+    };
+}
+namespace std __attribute__ ((__visibility__ ("default"))) {
+    template<typename _Tp>     class allocator: public __gnu_cxx::new_allocator<_Tp>     {
+    public:
+	typedef size_t size_type;
+	typedef ptrdiff_t difference_type;
+	typedef _Tp* pointer;
+	typedef const _Tp* const_pointer;
+	typedef _Tp& reference;
+	typedef const _Tp& const_reference;
+	typedef _Tp value_type;
+	template<typename _Tp1>         struct rebind         {
+	    typedef allocator<_Tp1> other;
+	};
+	allocator() throw() {
+	}
+	template<typename _Tp1>         allocator(const allocator<_Tp1>&) throw() {
+	}
+    };
+    extern template class allocator<char>;
+    extern template class allocator<wchar_t>;
+    template<typename _Arg, typename _Result>     struct unary_function     {
+	typedef _Arg argument_type;
+	typedef _Result result_type;
+    };
+    template<typename _Arg1, typename _Arg2, typename _Result>     struct binary_function     {
+	typedef _Arg1 first_argument_type;
+	typedef _Arg2 second_argument_type;
+	typedef _Result result_type;
+    };
+    template<typename _Tp>     struct less : public binary_function<_Tp, _Tp, bool>     {
+	bool       operator()(const _Tp& __x, const _Tp& __y) const       {
+	}
+    };
+    template<typename _Pair>     struct _Select1st : public unary_function<_Pair,            typename _Pair::first_type>     {
+	const typename _Pair::first_type&       operator()(const _Pair& __x) const       {
+	}
+    };
+    struct _Rb_tree_node_base   {
+	typedef _Rb_tree_node_base* _Base_ptr;
+	typedef const _Rb_tree_node_base* _Const_Base_ptr;
+    };
+    template<typename _Val>     struct _Rb_tree_node : public _Rb_tree_node_base     {
+	typedef _Rb_tree_node<_Val>* _Link_type;
+	_Val _M_value_field;
+	template<typename... _Args>         _Rb_tree_node(_Args&&... __args)  : _Rb_tree_node_base(),    _M_value_field(std::forward<_Args>(__args)...) {
+	}
+    };
+    template<typename _Tp>     struct _Rb_tree_iterator     {
+	typedef _Tp value_type;
+	typedef _Tp& reference;
+	typedef _Tp* pointer;
+	typedef bidirectional_iterator_tag iterator_category;
+	typedef ptrdiff_t difference_type;
+	typedef _Rb_tree_iterator<_Tp> _Self;
+	typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
+	typedef _Rb_tree_node<_Tp>* _Link_type;
+	_Base_ptr _M_node;
+    };
+    template<typename _Tp>     struct _Rb_tree_const_iterator     {
+	typedef _Tp value_type;
+	typedef const _Tp& reference;
+	typedef const _Tp* pointer;
+	typedef _Rb_tree_iterator<_Tp> iterator;
+	typedef bidirectional_iterator_tag iterator_category;
+	typedef ptrdiff_t difference_type;
+	typedef _Rb_tree_const_iterator<_Tp> _Self;
+	typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
+	typedef const _Rb_tree_node<_Tp>* _Link_type;
+	explicit       _Rb_tree_const_iterator(_Link_type __x)       : _M_node(__x) {
+	}
+	_Rb_tree_const_iterator(const iterator& __it)       : _M_node(__it._M_node) {
+	}
+	_Base_ptr _M_node;
+    };
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc = allocator<_Val> >     class _Rb_tree     {
+	typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other               _Node_allocator;
+	typedef _Rb_tree_node_base* _Base_ptr;
+	typedef const _Rb_tree_node_base* _Const_Base_ptr;
+    public:
+	typedef _Key key_type;
+	typedef _Val value_type;
+	typedef value_type* pointer;
+	typedef const value_type* const_pointer;
+	typedef value_type& reference;
+	typedef const value_type& const_reference;
+	typedef _Rb_tree_node<_Val>* _Link_type;
+	typedef const _Rb_tree_node<_Val>* _Const_Link_type;
+	typedef size_t size_type;
+	typedef ptrdiff_t difference_type;
+	typedef _Alloc allocator_type;
+	_Node_allocator&       _M_get_Node_allocator()       {
+	}
+	_Link_type       _M_get_node()       {
+	}
+	template<typename... _Args>         _Link_type         _M_create_node(_Args&&... __args)  {
+	    _Link_type __tmp = _M_get_node();
+	    try      {
+		_M_get_Node_allocator().construct(__tmp,           std::forward<_Args>(__args)...);
+	    }
+	    catch(...)      {
+	    }
+	}
+	template<typename _Key_compare,         bool _Is_pod_comparator = __is_pod(_Key_compare)>         struct _Rb_tree_impl : public _Node_allocator         {
+	    _Key_compare _M_key_compare;
+	    _Rb_tree_node_base _M_header;
+	    size_type _M_node_count;
+	    _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)    : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),      _M_node_count(0)    {
+	    }
+	    void    _M_initialize()    {
+	    }
+	};
+	_Rb_tree_impl<_Compare> _M_impl;
+	_Base_ptr&       _M_rightmost()       {
+	}
+	_Link_type       _M_begin()       {
+	}
+	_Link_type       _M_end()       {
+	}
+	_Const_Link_type       _M_end() const       {
+	}
+	static _Link_type       _S_right(_Base_ptr __x)       {
+	}
+	static const_reference       _S_value(_Const_Base_ptr __x)       {
+	}
+	static const _Key&       _S_key(_Const_Base_ptr __x)       {
+	    return _KeyOfValue()(_S_value(__x));
+	}
+	typedef _Rb_tree_iterator<value_type> iterator;
+	typedef _Rb_tree_const_iterator<value_type> const_iterator;
+	typedef std::reverse_iterator<iterator> reverse_iterator;
+	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+	iterator       _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,    const value_type& __v);
+	iterator       _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);
+	iterator       _M_insert_equal_lower(const value_type& __x);
+	iterator       _M_lower_bound(_Link_type __x, _Link_type __y,        const _Key& __k);
+	iterator       _M_upper_bound(_Link_type __x, _Link_type __y,        const _Key& __k);
+	_Rb_tree(const _Compare& __comp,         const allocator_type& __a = allocator_type())       : _M_impl(__comp, __a) {
+	}
+	iterator       end()       {
+	}
+	iterator       _M_insert_equal_(const_iterator __position, const value_type& __x);
+	template<typename _InputIterator>         void         _M_insert_unique(_InputIterator __first, _InputIterator __last);
+	template<typename _InputIterator>         void         _M_insert_equal(_InputIterator __first, _InputIterator __last);
+	size_type       count(const key_type& __k) const;
+	pair<iterator, iterator>       equal_range(const key_type& __k);
+	pair<const_iterator, const_iterator>       equal_range(const key_type& __k) const;
+    };
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)     {
+	_Link_type __z = _M_create_node(__v);
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)     {
+	_Link_type __z = _M_create_node(__v);
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_equal_lower(const _Val& __v)     {
+	_Link_type __x = _M_begin();
+	_Link_type __y = _M_end();
+	return _M_insert_lower(__x, __y, __v);
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::iterator,   typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::iterator>     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     equal_range(const _Key& __k)     {
+	_Link_type __x = _M_begin();
+	_Link_type __y = _M_end();
+	while (__x != 0)  {
+	    if (_M_impl._M_key_compare(_S_key(__x), __k))      __x = _S_right(__x);
+	    else      {
+		_Link_type __xu(__x), __yu(__y);
+		return pair<iterator,             iterator>(_M_lower_bound(__x, __y, __k),         _M_upper_bound(__xu, __yu, __k));
+	    }
+	}
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::const_iterator,   typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::const_iterator>     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     equal_range(const _Key& __k) const     {
+	_Const_Link_type __y = _M_end();
+	return pair<const_iterator, const_iterator>(const_iterator(__y),         const_iterator(__y));
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_equal_(const_iterator __position, const _Val& __v)     {
+	if (__position._M_node == _M_end())  {
+	    if (__position._M_node == _M_rightmost())      return _M_insert_(0, _M_rightmost(), __v);
+	    else      return _M_insert_equal_lower(__v);
+	}
+    }
+    template<typename _Key, typename _Val, typename _KoV,            typename _Cmp, typename _Alloc>     template<class _II>       void       _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::       _M_insert_equal(_II __first, _II __last)       {
+	for (;
+	     __first != __last;
+	     ++__first)    _M_insert_equal_(end(), *__first);
+    }
+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     count(const _Key& __k) const     {
+	pair<const_iterator, const_iterator> __p = equal_range(__k);
+	const size_type __n = std::distance(__p.first, __p.second);
+    }
+    template<class _E>     class initializer_list     {
+    public:
+	typedef _E value_type;
+	typedef const _E& reference;
+	typedef const _E& const_reference;
+	typedef size_t size_type;
+	typedef const _E* iterator;
+	typedef const _E* const_iterator;
+	iterator _M_array;
+	size_type _M_len;
+	initializer_list(const_iterator __a, size_type __l)       : _M_array(__a), _M_len(__l) {
+	}
+	const_iterator       begin() const {
+	}
+	const_iterator       end() const {
+	}
+    };
+    template <typename _Key, typename _Tp,      typename _Compare = std::less<_Key>,      typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >     class multimap     {
+	typedef _Key key_type;
+	typedef _Tp mapped_type;
+	typedef std::pair<const _Key, _Tp> value_type;
+	typedef _Compare key_compare;
+	typedef _Alloc allocator_type;
+	typedef typename _Alloc::value_type _Alloc_value_type;
+	typedef typename _Alloc::template rebind<value_type>::other         _Pair_alloc_type;
+	typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,          key_compare, _Pair_alloc_type> _Rep_type;
+	_Rep_type _M_t;
+    public:
+	typedef typename _Pair_alloc_type::pointer pointer;
+	typedef typename _Pair_alloc_type::const_pointer const_pointer;
+	typedef typename _Pair_alloc_type::reference reference;
+	typedef typename _Pair_alloc_type::const_reference const_reference;
+	typedef typename _Rep_type::iterator iterator;
+	typedef typename _Rep_type::const_iterator const_iterator;
+	typedef typename _Rep_type::size_type size_type;
+	typedef typename _Rep_type::difference_type difference_type;
+	typedef typename _Rep_type::reverse_iterator reverse_iterator;
+	typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
+	multimap(initializer_list<value_type> __l,         const _Compare& __comp = _Compare(),         const allocator_type& __a = allocator_type())       : _M_t(__comp, __a)       {
+	    _M_t._M_insert_equal(__l.begin(), __l.end());
+	}
+	template<typename _InputIterator>         multimap(_InputIterator __first, _InputIterator __last)  : _M_t()         {
+	}
+	template<typename _InputIterator>         multimap(_InputIterator __first, _InputIterator __last,    const _Compare& __comp,    const allocator_type& __a = allocator_type())         : _M_t(__comp, __a)         {
+	}
+	template<typename _InputIterator>         void         insert(_InputIterator __first, _InputIterator __last)         {
+	}
+	size_type       count(const key_type& __x) const       {
+	    return _M_t.count(__x);
+	}
+	std::pair<iterator, iterator>       equal_range(const key_type& __x)       {
+	    return _M_t.equal_range(__x);
+	}
+	template<typename _K1, typename _T1, typename _C1, typename _A1>         friend bool         operator==(const multimap<_K1, _T1, _C1, _A1>&,      const multimap<_K1, _T1, _C1, _A1>&);
+	template<typename _K1, typename _T1, typename _C1, typename _A1>         friend bool         operator<(const multimap<_K1, _T1, _C1, _A1>&,     const multimap<_K1, _T1, _C1, _A1>&);
+    };
+}
+extern "C" {
+    extern void __assert_fail (__const char *__assertion, __const char *__file,       unsigned int __line, __const char *__function)      throw () __attribute__ ((__noreturn__));
+}
+using namespace std;
+int test01() {
+    typedef multimap<int,double> Container;
+    typedef Container::iterator iterator;
+    typedef pair<iterator,iterator> itpair;
+    Container m({
+		{
+		1, 1.0 }
+		}
+	       );
+    itpair ip = m.equal_range(1);
+    ((distance(ip.first, ip.second) == 3) ? static_cast<void> (0) : __assert_fail ("distance(ip.first, ip.second) == 3", "/home/richard/src/trunk/libstdc++-v3/testsuite/23_containers/multimap/init-list.cc", 36, __PRETTY_FUNCTION__));
+    ((m.count(7) == 2) ? static_cast<void> (0) : __assert_fail ("m.count(7) == 2", "/home/richard/src/trunk/libstdc++-v3/testsuite/23_containers/multimap/init-list.cc", 54, __PRETTY_FUNCTION__));
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/vt-40092.C gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/vt-40092.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/cpp0x/vt-40092.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/cpp0x/vt-40092.C	2009-10-18 01:13:05.713806000 -0400
@@ -0,0 +1,21 @@
+// { dg-do "compile" }
+// { dg-options "-std=c++0x" }
+
+template <typename... Types> struct package {};
+
+template <int ArgGen> struct wrapper_gen {};
+
+template <int ArgNest> struct wrapper_nest
+{
+  typedef wrapper_gen<ArgNest> type_nest;
+};
+
+template <int... ArgPack>
+struct wrapper_pack
+{
+  typedef package<wrapper_gen <ArgPack>...> type_pack;
+  // incorrect error: expansion pattern 'wrapper_gen<ArgNest>'
+  //    contains no argument packs
+};
+
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/dg.exp gcc-4.4.2/gcc/testsuite/g++.dg/dg.exp
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/dg.exp	2009-03-18 17:44:04.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/g++.dg/dg.exp	2009-11-03 12:59:43.654521000 -0500
@@ -48,5 +48,9 @@
 # Main loop.
 dg-runtest $tests "" $DEFAULT_CXXFLAGS
 
+# C/C++ common tests.
+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/*.\[cSi\]]] \
+       "" ""
+
 # All done.
 dg-finish
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/ext/sync-3.C gcc-4.4.2/gcc/testsuite/g++.dg/ext/sync-3.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/ext/sync-3.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/ext/sync-3.C	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,21 @@
+// PR debug/41801
+// { dg-do compile }
+// { dg-options "-O2 -g" }
+
+struct T
+{
+  void
+  foo () volatile
+  {
+    __sync_lock_release (&t);
+    __sync_synchronize ();
+  }
+  bool t;
+};
+
+int
+main ()
+{
+  T t = { false };
+  t.foo ();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/ext/vla8.C gcc-4.4.2/gcc/testsuite/g++.dg/ext/vla8.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/ext/vla8.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/ext/vla8.C	2009-12-16 13:02:38.797910000 -0500
@@ -0,0 +1,15 @@
+// PR c++/42387
+// { dg-options "" }
+
+template<class PF>
+struct AvlTreeIter
+{
+  int Num();
+
+  AvlTreeIter()
+  {
+    new (void* [Num()]);
+  }
+};
+
+AvlTreeIter<int> a;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/gomp/pr41967.C gcc-4.4.2/gcc/testsuite/g++.dg/gomp/pr41967.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/gomp/pr41967.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/gomp/pr41967.C	2009-11-06 12:55:08.123600000 -0500
@@ -0,0 +1,17 @@
+// PR c++/41967
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+int
+foo ()
+{
+  int sum = 0;
+#pragma omp for collapse(2)
+  for (int i = 0; i < 5; ++i)
+    {
+      for (int j = 0; j < 5; ++j)
+	++sum;
+      ++sum;	// { dg-error "collapsed loops not perfectly nested" }
+    }
+  return sum;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/gomp/pr42234.C gcc-4.4.2/gcc/testsuite/g++.dg/gomp/pr42234.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/gomp/pr42234.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/gomp/pr42234.C	2009-12-01 14:44:34.768702000 -0500
@@ -0,0 +1,19 @@
+// PR c++/42234
+// { dg-do compile }
+// { dg-options "-fopenmp" }
+
+extern int foo (void);
+
+void
+bar (int x)
+{
+  #pragma omp critical
+    {
+      int j;
+      for (j = 0; j < foo (); j++)
+	;
+      if (0)
+        if (x >= 4)
+	  ;
+    }
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/inherit/thunk11-aux.cc gcc-4.4.2/gcc/testsuite/g++.dg/inherit/thunk11-aux.cc
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/inherit/thunk11-aux.cc	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/inherit/thunk11-aux.cc	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,4 @@
+// { dg-do compile }
+// { dg-options "-O2" }
+
+#include "thunk11.h"
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/inherit/thunk11.C gcc-4.4.2/gcc/testsuite/g++.dg/inherit/thunk11.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/inherit/thunk11.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/inherit/thunk11.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,11 @@
+// PR c++/42256
+// { dg-do link }
+// { dg-additional-sources "thunk11-aux.cc" }
+// { dg-options "-O2" }
+
+#include "thunk11.h"
+
+int
+main ()
+{
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/inherit/thunk11.h gcc-4.4.2/gcc/testsuite/g++.dg/inherit/thunk11.h
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/inherit/thunk11.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/inherit/thunk11.h	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,16 @@
+struct A
+{
+  A () {}
+  virtual ~A () {}
+};
+struct B
+{
+  B () {}
+  virtual ~B () {}
+};
+struct C : public A, public B
+{
+  virtual void foo ();
+  virtual ~C () {};
+};
+inline void C::foo () {}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/init/static-init2.C gcc-4.4.2/gcc/testsuite/g++.dg/init/static-init2.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/init/static-init2.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/init/static-init2.C	2009-11-05 09:47:24.466978000 -0500
@@ -0,0 +1,3 @@
+// PR c++/36912
+// { dg-options -frounding-math }
+const double c = .1, d = c+1;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/extern-c-redecl2.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/extern-c-redecl2.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/extern-c-redecl2.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/extern-c-redecl2.C	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,21 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/41020
+// { dg-do compile }
+
+extern "C"
+{
+  int fork (void);
+}
+
+class frok
+{
+  int this_errno;
+  friend int fork (void);
+};
+
+extern "C" int
+fork (void)
+{
+  frok grouped;
+  return grouped.this_errno;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/extern-c-redecl3.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/extern-c-redecl3.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/extern-c-redecl3.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/extern-c-redecl3.C	2009-11-03 08:46:46.863772000 -0500
@@ -0,0 +1,23 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/41020
+// { dg-options "" }
+// { dg-do compile }
+// { dg-final { scan-assembler-not "call\[\t \]+\[^\$\]*?_Z4forkv" { target i?86-*-* x86_64-*-* } } }
+// { dg-final { scan-assembler "call\[\t \]+_?fork" { target i?86-*-* x86_64-*-* } } }
+
+extern "C" int fork (void);
+
+void
+foo ()
+{
+  extern int fork (void);
+  fork ();
+}
+
+extern "C"
+int
+fork (void)
+{
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/extern-c-redecl4.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/extern-c-redecl4.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/extern-c-redecl4.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/extern-c-redecl4.C	2009-11-03 08:46:46.863772000 -0500
@@ -0,0 +1,18 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/41020
+
+// { dg-options "" }
+// { dg-do compile }
+// { dg-final { scan-assembler "call\[\t \]+\[^\$\]*?_Z4forkv" { target i?86-*-* x86_64-*-* } } }
+
+class frok
+{
+  int this_errno;
+  friend int fork (void);
+};
+
+void
+foo ()
+{
+  fork ();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/extern-c-redecl5.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/extern-c-redecl5.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/extern-c-redecl5.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/extern-c-redecl5.C	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,18 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/41020
+// { dg-do compile }
+
+
+class frok
+{
+  int this_errno;
+  friend int fork (void); // { dg-error "previous declaration .*?C\\+\\+. linkage" }
+};
+
+extern "C" int
+fork (void) // { dg-error "conflicts with new declaration .*?C. linkage" }}
+{
+  frok grouped;
+  return grouped.this_errno;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/koenig10.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/koenig10.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/koenig10.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/koenig10.C	2009-12-28 12:18:22.932708000 -0500
@@ -0,0 +1,12 @@
+// Test for proper handling of class-scope enums.
+
+struct A
+{
+  enum E { e };
+  friend void f (E);
+};
+
+int main()
+{
+  f(A::e);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/koenig11.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/koenig11.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/koenig11.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/koenig11.C	2009-12-28 12:18:22.932708000 -0500
@@ -0,0 +1,12 @@
+// Test that we treat unions like other classes in arg-dep lookup.
+
+union U
+{
+  friend void f (U);
+};
+
+int main()
+{
+  U u;
+  f(u);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/koenig12.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/koenig12.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/koenig12.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/koenig12.C	2009-12-28 12:18:22.932708000 -0500
@@ -0,0 +1,18 @@
+// PR c++/41305
+// We got into infinite recursion instantiating the B<U> series.
+
+template <class T> struct A { };
+template <class T, class U = A<T> > struct B;
+template <class T> struct C { };
+
+template <class T, class U> struct B: C<B<U> >
+{
+  friend void f(B) { }
+};
+
+B<int> b;
+
+int main()
+{
+  f(b);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/scoped8.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/scoped8.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/scoped8.C	2003-10-26 06:04:36.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/scoped8.C	2009-11-13 13:03:31.906492000 -0500
@@ -14,3 +14,5 @@
 {
     int foo() { return A::i; }	// { dg-error "this location" }
 };
+
+template struct B<0>;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/using16.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/using16.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/using16.C	2007-07-02 13:28:53.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/using16.C	2009-11-03 16:33:55.537602000 -0500
@@ -3,7 +3,7 @@
 // { dg-do compile }
 
 namespace M {
-  struct S {}; // { dg-error "candidates are: struct M::S" "candidate 1" }
+  struct S {}; // { dg-error "struct M::S" "candidate 1" }
 }
 
 namespace N {
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/using22.C gcc-4.4.2/gcc/testsuite/g++.dg/lookup/using22.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/lookup/using22.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/lookup/using22.C	2009-11-03 16:33:55.537602000 -0500
@@ -0,0 +1,17 @@
+// PR c++/39786
+
+namespace A {
+    char (*f(char *p))[13] { return 0; }
+}
+
+namespace B {
+    namespace C {
+        char (*f(int p))[42] { return 0; }
+    }
+    using namespace C;
+}
+
+using namespace B;
+using namespace A;
+
+char x[sizeof *::f(0) == 42 ? 1 : -1];
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/dtor2-aux.cc gcc-4.4.2/gcc/testsuite/g++.dg/opt/dtor2-aux.cc
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/dtor2-aux.cc	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/opt/dtor2-aux.cc	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,16 @@
+// { dg-do compile }
+// { dg-options "" }
+
+#include "dtor2.h"
+
+A::A () {}
+A::~A () {}
+
+void B::mb () {}
+B::B (int) {}
+B::~B () {}
+
+void C::mc () {}
+C::C (int x) : B (x) {}
+
+D::~D () {}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/dtor2.C gcc-4.4.2/gcc/testsuite/g++.dg/opt/dtor2.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/dtor2.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/opt/dtor2.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,13 @@
+// PR c++/42317
+// { dg-do link }
+// { dg-options "-O0" }
+// { dg-additional-sources "dtor2-aux.cc" }
+
+#include "dtor2.h"
+
+D::D (int x) : C (x) {}
+
+int
+main ()
+{
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/dtor2.h gcc-4.4.2/gcc/testsuite/g++.dg/opt/dtor2.h
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/dtor2.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/opt/dtor2.h	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,29 @@
+struct A
+{
+  A ();
+  ~A ();
+};
+
+struct B
+{
+  A b;
+  virtual void mb ();
+  B (int);
+  virtual ~B ();
+};
+
+struct C : public B
+{
+  virtual void mc ();
+  C (int);
+  ~C ();
+};
+
+inline C::~C () {}
+
+struct D : public C
+{
+  A d;
+  D (int);
+  ~D ();
+};
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/dtor3.C gcc-4.4.2/gcc/testsuite/g++.dg/opt/dtor3.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/dtor3.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/opt/dtor3.C	2009-12-22 13:17:53.777443000 -0500
@@ -0,0 +1,11 @@
+// PR c++/42386
+// { dg-do compile }
+// { dg-options "-O2" }
+# 1 "A.h" 1
+#pragma interface
+struct D { virtual bool d () const; };
+struct E { virtual ~E (); virtual void *e () const = 0; };
+struct A : public D, public E { ~A () {} };
+# 5 "dtor3.C" 1
+struct F : public A { void *f () const; void *e () const; };
+void *F::e () const { return __null; }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/inline16.C gcc-4.4.2/gcc/testsuite/g++.dg/opt/inline16.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/opt/inline16.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/opt/inline16.C	2009-11-03 18:49:07.505919000 -0500
@@ -0,0 +1,19 @@
+// PR c++/36959
+// We shouldn't have to emit fromSlotB just because we need shuf_BZZZ.
+// { dg-options -O }
+// { dg-final { scan-assembler-not "_ZL9fromSlotBv" } }
+
+static inline int *fromSlotB(void)
+{
+  static int shuf_BZZZ = 1;
+  return &shuf_BZZZ;
+}
+
+int *p;
+
+int main(void)
+{
+  p = fromSlotB();
+  return (*p != 1);
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/other/bitfield4.C gcc-4.4.2/gcc/testsuite/g++.dg/other/bitfield4.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/other/bitfield4.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/other/bitfield4.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,10 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42217
+// { dg-do compile }
+
+struct A
+{
+ int : 0;
+};
+A a = A();
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/other/offsetof6.C gcc-4.4.2/gcc/testsuite/g++.dg/other/offsetof6.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/other/offsetof6.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/other/offsetof6.C	2009-11-03 05:46:00.552027000 -0500
@@ -0,0 +1,26 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/38699
+// { dg-do compile }
+
+template<class T>
+struct A
+{
+  const T *p;
+};
+
+struct B
+{
+  A<int> a;
+};
+
+template class A<char>;
+
+void
+f0 ()
+{
+  __builtin_offsetof(A<char>, p); // OK
+  __builtin_offsetof(A<char>, p[1]); // { dg-error "non constant address" }
+  __builtin_offsetof(B, a.p); // OK
+  __builtin_offsetof(B, a.p[1]); // { dg-error "non constant address" }
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/other/ptrmem10.C gcc-4.4.2/gcc/testsuite/g++.dg/other/ptrmem10.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/other/ptrmem10.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/other/ptrmem10.C	2009-11-02 14:58:57.020560000 -0500
@@ -0,0 +1,29 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/37093
+
+template <class C, void (C::*M) ()>
+static
+void foo(void *obj)
+{
+  C *p = static_cast<C*>(obj);
+  (p->*M)();
+}
+
+template <class C>
+static void
+bar(C *c, void (C::*m) ())
+{
+  foo<C,m>((void *)c);// { dg-error "(not a valid template arg|pointer-to-member|no matching fun)" }
+}
+
+struct S
+{
+  void baz () {}
+};
+
+int
+main ()
+{
+  S a;
+  bar(&a, &S::baz);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/other/ptrmem11.C gcc-4.4.2/gcc/testsuite/g++.dg/other/ptrmem11.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/other/ptrmem11.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/other/ptrmem11.C	2009-11-02 14:58:57.020560000 -0500
@@ -0,0 +1,21 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/37093
+
+struct A {};
+
+template <int A::* p>
+int
+foo(A* q)
+{
+  return q->*p;
+}
+
+template <typename T>
+int
+bar(int T::* p)
+{
+  return foo<p>(0);// { dg-error "(not a valid template arg|no matching func|pointer-to-member)" }
+}
+
+int i = bar<A>(0);
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/parse/crash54.C gcc-4.4.2/gcc/testsuite/g++.dg/parse/crash54.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/parse/crash54.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/parse/crash54.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,15 @@
+// PR c++/42057
+
+struct A; // { dg-error "forward declaration" }
+
+struct B
+{
+  virtual B* foo(A);
+};
+
+struct C : virtual B
+{
+  virtual C* foo(A) { return 0; } // { dg-error "incomplete type" }
+};
+
+C c;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/parse/eh-decl.C gcc-4.4.2/gcc/testsuite/g++.dg/parse/eh-decl.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/parse/eh-decl.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/parse/eh-decl.C	2009-11-03 16:33:55.537602000 -0500
@@ -0,0 +1,8 @@
+// PR c++/41876
+
+struct A;
+
+void foo()
+{
+  try {} catch(int A) {}
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/arg7.C gcc-4.4.2/gcc/testsuite/g++.dg/template/arg7.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/arg7.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/arg7.C	2009-12-11 00:26:51.646319000 -0500
@@ -0,0 +1,11 @@
+// PR c++/27425, 34274
+
+template<typename T> struct A
+{
+  template<template<T> class> struct B {}; // { dg-error "void|mismatch|expected" }
+  // { dg-bogus "not supported" "" { target *-*-* } 5 }
+  template<T> struct C;			   // { dg-error "void" }
+  B<C> b;
+};
+
+A<void> a;			// { dg-message "instantiated" }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/const3.C gcc-4.4.2/gcc/testsuite/g++.dg/template/const3.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/const3.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/const3.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,20 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42251
+// { dg-do "compile" }
+
+struct foo
+{
+    static const bool b = false;
+};
+
+template<bool x>
+struct S1
+{
+};
+
+template<bool x>
+struct S2
+    : S1<foo::b>
+{
+};
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/conv10.C gcc-4.4.2/gcc/testsuite/g++.dg/template/conv10.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/conv10.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/conv10.C	2009-11-09 15:28:11.535343000 -0500
@@ -0,0 +1,9 @@
+// PR c++/41994
+
+template<typename T> struct A
+{
+  operator T();
+  A() { T (A::*f)() = &A::operator T; }
+};
+
+A<int> a;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/inherit4.C gcc-4.4.2/gcc/testsuite/g++.dg/template/inherit4.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/inherit4.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/inherit4.C	2009-11-13 13:03:31.906492000 -0500
@@ -0,0 +1,14 @@
+// PR c++/21008, DR 515
+
+struct A {
+  int foo_;
+};
+template <typename T> struct B: public A { };
+template <typename T> struct C: B<T> {
+  int foo() {
+    return A::foo_;  // #1
+  }
+};
+int f(C<int>* p) {
+  return p->foo();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/ref4.C gcc-4.4.2/gcc/testsuite/g++.dg/template/ref4.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/ref4.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/ref4.C	2009-11-09 15:28:18.966614000 -0500
@@ -0,0 +1,12 @@
+// PR c++/41972
+
+struct X {
+  static const double  x;
+};
+template <const double& _test_>
+  class Foo { };
+template <typename _ignore_>
+struct Y {
+  typedef Foo<X::x> type;
+};
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/sizeof12.C gcc-4.4.2/gcc/testsuite/g++.dg/template/sizeof12.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/sizeof12.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/sizeof12.C	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,19 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/41863
+
+template<int X>
+struct Bar
+{
+};
+
+template<typename T>
+class Foo
+{
+  T m_foo;
+
+  void
+  crash()
+  {
+    Bar<sizeof(m_foo)> bar;
+  }
+};
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef21.C gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef21.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef21.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef21.C	2009-11-12 18:21:55.860799000 -0500
@@ -0,0 +1,11 @@
+// PR c++/37037
+
+typedef void F(void);
+template <typename T> struct S 
+{
+    static F f;
+};
+template class S<int>;
+template <class T> void S<T>::f(void)
+{}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef23.C gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef23.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef23.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef23.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,25 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42069
+// { dg-do compile }
+
+struct A
+{
+  static const int N = 0;
+};
+
+template<int> struct B {};
+
+template<typename T, int>
+struct C
+{
+  typedef T U;
+  B<U::N> b;
+};
+
+template<typename T>
+struct C<T*, 0>
+{
+  B<T::N> b;
+};
+
+C<A*, 0> c;
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef24.C gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef24.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef24.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef24.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,33 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42225
+// { dg-do compile }
+
+template<class T>
+struct A
+{
+    typedef T I;
+};
+
+template<class T, int>
+struct B
+{
+    typedef T TT;
+    typedef typename TT::I TT_I;
+    typedef A<TT_I> TA;
+};
+
+template<class T>
+void
+foo()
+{
+    typedef T TT;
+    typedef typename TT::I TT_I;
+    typedef A<TT_I> TA;
+}
+
+int
+main()
+{
+    foo<A<int> >();
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef25.C gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef25.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef25.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef25.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,43 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/42225
+// { dg-options "-std=c++0x" }
+// { dg-do compile }
+
+template<class T>
+struct A
+{
+    typedef T I;
+    static const char *i;
+};
+
+template<class T, int>
+struct B
+{
+    typedef T TT;
+    typedef decltype(TT::i)  TT_I0;
+    typedef decltype(&TT::i) TT_I1;
+    typedef decltype(*TT::i) TT_I2;
+    typedef A<TT_I0> TA0;
+    typedef A<TT_I1> TA1;
+    typedef A<TT_I2> TA2;
+};
+
+template<class T>
+void
+foo()
+{
+    typedef T TT;
+    typedef decltype(TT::i)  TT_I0;
+    typedef decltype(&TT::i) TT_I1;
+    typedef decltype(*TT::i) TT_I2;
+    typedef A<TT_I0> TA0;
+    typedef A<TT_I1> TA1;
+    typedef A<TT_I2> TA2;
+}
+
+int
+main()
+{
+    foo<A<int> >();
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef26.C gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef26.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/template/typedef26.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/template/typedef26.C	2009-12-22 13:17:53.777443000 -0500
@@ -0,0 +1,40 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/42225
+// { dg-do compile }
+
+struct A
+{
+    typedef int TI;
+};
+
+template<class T0>
+struct S0
+{
+    int i;
+};
+
+template<class _T, int>
+struct S1
+{
+    typedef _T T;
+    typedef typename T::TI TTI;
+    typedef S0<TTI> TT0;
+    typedef S0<typename T::TI> TT1;
+};
+
+template<class T>
+void
+foo(const T&)
+{
+    typedef typename T::TI TTI;
+    typedef S0<TTI> TT1;
+    typedef S0<typename T::TI> TT2;
+}
+
+int
+main()
+{
+    A a;
+    foo (a);
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr41183.C gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr41183.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr41183.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr41183.C	2009-12-15 10:14:59.331382000 -0500
@@ -0,0 +1,30 @@
+// PR c++/41183
+// { dg-do compile }
+
+void foo (const char *);
+
+template <int *>
+struct A
+{
+  template <typename T> A (const int &, T);
+  int i;
+};
+
+template <int *X>
+template <typename T>
+A<X>::A (const int &j, T) : i(j)
+{
+  foo (0);
+  foo (0);
+  foo (__PRETTY_FUNCTION__);
+}
+
+int N;
+
+struct B
+{
+  B ();
+  A<&N> a;
+};
+
+B::B() : a(N, 0) {}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr41775.C gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr41775.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr41775.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr41775.C	2009-10-30 12:04:41.277692000 -0400
@@ -0,0 +1,284 @@
+/* { dg-do compile } */
+/* { dg-require-visibility "" } */
+
+typedef unsigned int size_t;
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template < typename _Iterator > struct iterator_traits
+  {
+  };
+  template < typename _Tp > struct iterator_traits <_Tp * >
+  {
+    typedef _Tp & reference;
+  };
+}
+
+namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
+{
+  using std::iterator_traits;
+  template < typename _Iterator, typename _Container > class __normal_iterator
+  {
+  public:typedef _Iterator iterator_type;
+    typedef typename iterator_traits < _Iterator >::reference reference;
+    reference operator* () const
+    {
+    }
+    __normal_iterator operator++ (int)
+    {
+    }
+  };
+  template < typename _IteratorL, typename _IteratorR,
+    typename _Container > inline bool operator!= (const __normal_iterator <
+						  _IteratorL,
+						  _Container > &__lhs,
+						  const __normal_iterator <
+						  _IteratorR,
+						  _Container > &__rhs)
+  {
+  }
+}
+
+extern "C"
+{
+  extern "C"
+  {
+    __extension__ typedef __SIZE_TYPE__ __intptr_t;
+  }
+}
+namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
+{
+  template < typename _Tp > class new_allocator
+  {
+  public:typedef size_t size_type;
+    typedef _Tp *pointer;
+    template < typename _Tp1 > struct rebind
+    {
+      typedef new_allocator < _Tp1 > other;
+    };
+  };
+}
+
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+template < typename _Tp > class allocator:public __gnu_cxx::new_allocator <
+    _Tp >
+  {
+  };
+}
+
+extern "C"
+{
+  typedef __intptr_t intptr_t;
+}
+namespace llvm
+{
+  template < typename NodeTy > class ilist_half_node
+  {
+  };
+template < typename NodeTy > class ilist_node:private ilist_half_node <
+    NodeTy >
+  {
+  };
+  class MachineBasicBlock;
+  class MachineOperand
+  {
+  public:enum MachineOperandType
+    {
+    }
+    Contents;
+    unsigned getReg () const
+    {
+    }
+  };
+  class TargetRegisterInfo;
+}
+
+namespace std __attribute__ ((__visibility__ ("default")))
+{
+  template < typename _Tp, typename _Alloc > struct _Vector_base
+  {
+    typedef typename _Alloc::template rebind < _Tp >::other _Tp_alloc_type;
+  };
+template < typename _Tp, typename _Alloc = std::allocator < _Tp > >class vector:protected _Vector_base < _Tp,
+    _Alloc
+    >
+  {
+    typedef _Vector_base < _Tp, _Alloc > _Base;
+    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
+  public:typedef _Tp value_type;
+    typedef typename _Tp_alloc_type::pointer pointer;
+    typedef __gnu_cxx::__normal_iterator < pointer, vector > iterator;
+    iterator begin ()
+    {
+    }
+    iterator end ()
+    {
+    }
+  };
+}
+
+namespace llvm
+{
+  class MachineFunction;
+  class MachineInstr:public ilist_node < MachineInstr >
+  {
+  public:const MachineBasicBlock *getParent () const
+    {
+    }
+    const MachineOperand & getOperand (unsigned i) const
+    {
+    }
+    bool registerDefIsDead (unsigned Reg, const TargetRegisterInfo * TRI =
+			    __null) const
+    {
+    }
+  };
+  class AnalysisResolver;
+  class Pass
+  {
+    AnalysisResolver *Resolver;
+    intptr_t PassID;
+  public:  explicit Pass (intptr_t pid):Resolver (0), PassID (pid)
+    {
+    }
+    explicit Pass (const void *pid):Resolver (0), PassID ((intptr_t) pid)
+    {
+    }
+    template < typename AnalysisType > AnalysisType & getAnalysis () const;
+  };
+  class FunctionPass:public Pass
+  {
+  public:explicit FunctionPass (intptr_t pid):Pass (pid)
+    {
+    }
+    explicit FunctionPass (const void *pid):Pass (pid)
+    {
+    }
+  };
+  class PassInfo
+  {
+  public:typedef Pass *(*NormalCtor_t) ();
+  private:const char *const PassName;
+    const char *const PassArgument;
+    const intptr_t PassID;
+    const bool IsCFGOnlyPass;
+    const bool IsAnalysis;
+    const bool IsAnalysisGroup;
+    NormalCtor_t NormalCtor;
+  public:   PassInfo (const char *name, const char *arg, intptr_t pi, NormalCtor_t normal = 0, bool isCFGOnly = false, bool is_analysis = false):PassName (name), PassArgument (arg), PassID (pi),
+      IsCFGOnlyPass (isCFGOnly), IsAnalysis (is_analysis),
+      IsAnalysisGroup (false), NormalCtor (normal)
+    {
+    }
+  };
+  template < typename PassName > Pass * callDefaultCtor ()
+  {
+    return new PassName ();
+  }
+  template < typename passName > struct RegisterPass:public PassInfo
+  {
+  RegisterPass (const char *PassArg, const char *Name, bool CFGOnly = false, bool is_analysis = false):PassInfo (Name, PassArg, intptr_t (&passName::ID),
+	      PassInfo::NormalCtor_t (callDefaultCtor < passName >), CFGOnly,
+	      is_analysis)
+    {
+    }
+  };
+  template < typename T > class SmallVectorImpl
+  {
+  };
+  template < typename T,
+    unsigned N > class SmallVector:public SmallVectorImpl < T >
+  {
+  };
+  class MachineFunctionPass:public FunctionPass
+  {
+  protected:explicit MachineFunctionPass (intptr_t ID):FunctionPass (ID)
+    {
+    }
+    explicit MachineFunctionPass (void *ID):FunctionPass (ID)
+    {
+    }
+    virtual bool runOnMachineFunction (MachineFunction & MF) = 0;
+  };
+  class LiveIndex
+  {
+  private:unsigned index;
+  };
+  class VNInfo
+  {
+  };
+  struct LiveRange
+  {
+    LiveIndex start;
+    LiveIndex end;
+    VNInfo *valno;
+  };
+  class LiveInterval
+  {
+  public:typedef SmallVector < LiveRange, 4 > Ranges;
+    bool containsOneValue () const
+    {
+    }
+    LiveRange *getLiveRangeContaining (LiveIndex Idx)
+    {
+    }
+    void removeRange (LiveIndex Start, LiveIndex End, bool RemoveDeadValNo =
+		      false);
+    void removeRange (LiveRange LR, bool RemoveDeadValNo = false)
+    {
+      removeRange (LR.start, LR.end, RemoveDeadValNo);
+    }
+  };
+  class LiveIntervals:public MachineFunctionPass
+  {
+  public:static char ID;
+    LiveIndex getDefIndex (LiveIndex index)
+    {
+    }
+    LiveInterval & getInterval (unsigned reg)
+    {
+    }
+    LiveIndex getInstructionIndex (const MachineInstr * instr) const
+    {
+    }
+  };
+}
+
+using namespace llvm;
+namespace
+{
+struct __attribute__ ((visibility ("hidden"))) StrongPHIElimination:public
+    MachineFunctionPass
+  {
+    static char ID;
+  StrongPHIElimination ():MachineFunctionPass (&ID)
+    {
+    }
+    bool runOnMachineFunction (MachineFunction & Fn);
+  };
+}
+
+static RegisterPass < StrongPHIElimination > X ("strong-phi-node-elimination",
+						"Eliminate PHI nodes for register allocation, intelligently");
+bool
+StrongPHIElimination::runOnMachineFunction (MachineFunction & Fn)
+{
+  LiveIntervals & LI = getAnalysis < LiveIntervals > ();
+  std::vector < MachineInstr * >phis;
+  for (std::vector < MachineInstr * >::iterator I = phis.begin (), E =
+       phis.end (); I != E;)
+    {
+      MachineInstr *PInstr = *(I++);
+      unsigned DestReg = PInstr->getOperand (0).getReg ();
+      LiveInterval & PI = LI.getInterval (DestReg);
+      if (PInstr->registerDefIsDead (DestReg))
+	{
+	  if (PI.containsOneValue ())
+	    {
+	      LiveIndex idx =
+		LI.getDefIndex (LI.getInstructionIndex (PInstr));
+	      PI.removeRange (*PI.getLiveRangeContaining (idx), true);
+	    }
+	}
+    }
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr42110.C gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr42110.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr42110.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr42110.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+bool foo();
+
+struct A
+{
+  A* fooA() { if (foo()) foo(); return this; }
+
+  virtual void barA(char);
+};
+
+template<int> struct B
+{
+  A *p, *q;
+
+  void fooB(char c) { p->fooA()->barA(c); }
+};
+
+template<int N> inline void bar(B<N> b) { b.fooB(0); }
+
+extern template void bar(B<0>);
+
+void (*f)(B<0>) = bar;
+
+void baz()
+{
+  B<0>().fooB(0);
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr42183.C gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr42183.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr42183.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr42183.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,51 @@
+// { dg-do compile }
+
+class IntSize {
+public:
+    IntSize(int width, int height) : m_width(width), m_height(height) { }
+    int m_width, m_height;
+};
+class IntPoint {
+public:
+    IntPoint(int x, int y) : m_x(x), m_y(y) { }
+    int m_x, m_y;
+};
+class IntRect {
+public:
+    IntRect(int x, int y, int width, int height)
+        : m_location(IntPoint(x, y)), m_size(IntSize(width, height)) { }
+    void intersect(const IntRect&);
+    IntPoint m_location;
+    IntSize m_size;
+};
+inline IntRect intersection(const IntRect& a, const IntRect& b) {
+    IntRect c = a;
+    c.intersect(b);
+    return c;
+}
+class RenderObject  {
+public:
+    int contentWidth() const { }
+    int contentHeight() const { }
+    virtual int xPos() const { }
+    virtual int yPos() const { }
+    virtual int paddingTop() const;
+    virtual int paddingLeft() const;
+    virtual int borderTop() const { }
+    virtual int borderLeft() const { }
+};
+class RenderMenuList : public RenderObject {
+    virtual IntRect controlClipRect(int tx, int ty) const;
+    RenderObject* m_innerBlock;
+};
+IntRect RenderMenuList::controlClipRect(int tx, int ty) const {
+    IntRect outerBox(tx + borderLeft() + paddingLeft(),
+                     ty + borderTop() + paddingTop(),
+                     contentWidth(), contentHeight());
+    IntRect innerBox(tx + m_innerBlock->xPos() + m_innerBlock->paddingLeft(),
+                     ty + m_innerBlock->yPos() + m_innerBlock->paddingTop(),
+                     m_innerBlock->contentWidth(),
+                     m_innerBlock->contentHeight());
+    return intersection(outerBox, innerBox);
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr42357.C gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr42357.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pr42357.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/torture/pr42357.C	2009-12-22 13:17:53.777443000 -0500
@@ -0,0 +1,30 @@
+// { dg-do compile }
+typedef unsigned char uint8;
+typedef unsigned int uint32;
+class PixelARGB {
+public:
+    ~PixelARGB() throw() { }
+    PixelARGB (const uint32 argb_) throw() : argb (argb_)     { }
+    inline __attribute__((always_inline)) uint8 getRed() const throw() {
+	return components.r;
+    }
+    union     {
+	uint32 argb;
+	struct         {
+	    uint8 b, g, r, a;
+	} components;
+    };
+};
+class Colour {
+public:
+    Colour() throw() : argb (0) {};
+    uint8 getRed() const throw() {
+	return argb.getRed();
+    }
+    PixelARGB argb;
+};
+uint8 writeImage (void) {
+    Colour pixel;
+    pixel = Colour ();
+    return pixel.getRed();
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pushpop_macro.C gcc-4.4.2/gcc/testsuite/g++.dg/torture/pushpop_macro.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/torture/pushpop_macro.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/torture/pushpop_macro.C	2009-11-11 15:21:14.372933000 -0500
@@ -0,0 +1,19 @@
+/* Do the preprocessor push_macro/pop_macro test.  */
+
+/* { dg-do run } */
+
+extern "C" void abort ();
+
+#define _ 2
+#pragma push_macro("_")
+#undef _
+#define _ 1
+#pragma pop_macro("_")
+
+int main ()
+{
+  if (_ != 2)
+    abort ();
+  return 0;
+}
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/tree-ssa/pr41905.C gcc-4.4.2/gcc/testsuite/g++.dg/tree-ssa/pr41905.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/tree-ssa/pr41905.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/tree-ssa/pr41905.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+int foo() __attribute__((noreturn));
+int bar() { return foo(); }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/tree-ssa/pr41906.C gcc-4.4.2/gcc/testsuite/g++.dg/tree-ssa/pr41906.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/tree-ssa/pr41906.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/tree-ssa/pr41906.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-fpermissive -w" } */
+/* We aren't interested in the warning, but in the ICE.  */
+void foo();
+extern void abort (void);
+
+void bar()
+{
+  try { foo(); }
+  catch (...) {}
+  catch (int) {abort ();}
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/g++.dg/tree-ssa/pr41961.C gcc-4.4.2/gcc/testsuite/g++.dg/tree-ssa/pr41961.C
--- gcc-4.4.2.orig/gcc/testsuite/g++.dg/tree-ssa/pr41961.C	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/g++.dg/tree-ssa/pr41961.C	2009-12-11 18:36:24.279999000 -0500
@@ -0,0 +1,15 @@
+// { dg-do compile }
+// { dg-require-effective-target pthread }
+// { dg-options "-O3 -ftree-parallelize-loops=2" }
+
+struct A
+{
+    char c[17];
+      void foo();
+};
+
+void A::foo()
+{
+    for (int i = 0; i < 17; ++i)
+          c[i] = 0;
+}
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/array_constructor_32.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/array_constructor_32.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/array_constructor_32.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/array_constructor_32.f90	2009-11-26 17:18:36.080511000 -0500
@@ -0,0 +1,28 @@
+! { dg-do run }
+! PR41807  data statement with nested type constructors
+! Test case provided by Steve Kargl
+  implicit none
+
+  type :: a
+     real :: x(3)
+  end type a
+
+  integer, parameter :: n = 3
+
+  type(a) :: b(n)
+
+  real, parameter :: d1(3) = (/1., 2., 3./)
+  real, parameter :: d2(3) = (/4., 5., 6./)
+  real, parameter :: d3(3) = (/7., 8., 9./)
+
+  integer :: i, z(n)
+ 
+  data (b(i), i = 1, n) /a(d1), a(d2), a(d3)/
+  data (z(i), i = 1, n) / 1, 2, 3/
+
+  if (any(z.ne.[1, 2, 3])) call abort
+  if (any(b(1)%x.ne.[1, 2, 3]) .or. &
+      any(b(2)%x.ne.[4, 5, 6]) .or. &
+      any(b(3)%x.ne.[7, 8, 9])) call abort
+end
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/array_function_5.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/array_function_5.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/array_function_5.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/array_function_5.f90	2009-11-30 23:40:14.616698000 -0500
@@ -0,0 +1,16 @@
+! {  dg-do run )
+! PR41278 internal compiler error related to matmul and transpose
+! Test case prepared by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+program bug
+  implicit none
+  real, dimension(3,3) :: matA,matB,matC
+
+  matA(1,:)=(/1., 2., 3./)
+  matA(2,:)=(/4., 5., 6./)
+  matA(3,:)=(/7., 8., 9./)
+
+  matB=matmul(transpose(0.5*matA),matA)
+  matC = transpose(0.5*matA)
+  matC = matmul(matC, matA)
+  if (any(matB.ne.matC)) call abort()
+end program bug
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/associated_target_3.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/associated_target_3.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/associated_target_3.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/associated_target_3.f90	2009-10-30 11:18:09.930941000 -0400
@@ -0,0 +1,35 @@
+! { dg-do run }
+!
+! PR fortran/41777
+!
+module m
+type t2
+ integer :: i
+end type t2
+interface f
+ module procedure f2
+end interface f
+contains
+function f2(a)
+  type(t2), pointer :: f2,a
+  f2 => a
+end function f2
+end module m
+
+use m
+implicit none
+type(t2), pointer :: a
+allocate(a)
+if (.not. associated(a,f(a))) call abort()
+call cmpPtr(a,f2(a))
+call cmpPtr(a,f(a))
+deallocate(a)
+contains
+  subroutine cmpPtr(a,b)
+    type(t2), pointer :: a,b
+!    print *, associated(a,b)
+    if (.not. associated (a, b)) call abort()
+  end subroutine cmpPtr
+end
+
+! { dg-final { cleanup-modules "m" } }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/data_value_1.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/data_value_1.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/data_value_1.f90	2009-06-19 18:10:45.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/data_value_1.f90	2009-11-26 17:18:36.080511000 -0500
@@ -3,12 +3,14 @@
 ! is not a constant and so the DATA statement did not have
 ! a constant value expression.
 !
+! Modified dg-error for PR41807
+!
 ! Contributed by Philippe Marguinaud <philippe.marguinaud@meteo.fr>
 !
       TYPE POINT
         REAL :: X 
       ENDTYPE
       TYPE(POINT) :: P
-      DATA P / POINT(1.+X) / ! { dg-error "non-constant DATA value" }
+      DATA P / POINT(1.+X) / ! { dg-error "non-constant initialization" }
       print *, p
       END
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/direct_io_11.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/direct_io_11.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/direct_io_11.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/direct_io_11.f90	2009-11-19 23:02:33.888023000 -0500
@@ -0,0 +1,55 @@
+! { dg-do run }
+! PR42090 Problems reading partial records in formatted direct access files
+! Test case from PR, prepared by Jerry DeLisle <jvdelisle@gcc.gnu.org>
+program da_good_now
+  implicit none
+  real :: a, b
+
+  a = 1.111111111
+  b = 2.222222222
+
+  open( 10, file = 't.dat', form = 'formatted', access = 'direct', recl = 12 )
+  write( 10, rec = 1, fmt = '( f6.4, /, f6.4 )' ) a, b
+  close( 10 )
+
+  a = -1.0
+  b = -1.0
+
+  open( 10, file = 't.dat', form = 'formatted', access = 'direct', recl = 12 )
+
+  read( 10, rec = 1, fmt = '( f6.4, /, f6.4 )' ) a, b
+  !write( *, '( "partial record 1", t25, 2( f6.4, 1x ) )' ) a, b
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f6.4 )' ) a, b
+  !write( *, '( "partial record 2", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f12.4, /, f12.4 )' ) a, b
+  !write( *, '( "full record 1", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f12.4 )' ) a, b
+  !write( *, '( "full record 2", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f6.4, 6x, /, f6.4, 6x )' ) a, b
+  !write( *, '( "full record with 6x", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+  a = -1.0
+  b = -1.0
+
+  read( 10, rec = 1, fmt = '( f6.4 )' ) a
+  read( 10, rec = 2, fmt = '( f6.4 )' ) b
+  !write( *, '( "record at a time", t25, 2( f6.4, 1x ) )' ) a, b
+  if (a /= 1.1111 .and. b /= 2.2222) call abort()
+
+  close( 10, status="delete")
+end program da_good_now
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/equiv_8.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/equiv_8.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/equiv_8.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/equiv_8.f90	2009-10-19 15:18:12.387277000 -0400
@@ -0,0 +1,7 @@
+! { dg-do compile }
+!
+! PR fortran/41755
+!
+      common /uno/ aa
+      equivalence (aa,aaaaa)   (bb,cc) ! { dg-error "Expecting a comma in EQUIVALENCE" }
+      end
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/gomp/pr41344.f gcc-4.4.2/gcc/testsuite/gfortran.dg/gomp/pr41344.f
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/gomp/pr41344.f	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/gomp/pr41344.f	2009-12-28 11:46:11.798627000 -0500
@@ -0,0 +1,16 @@
+      subroutine xrotate(nerr)
+
+      common /dfm/ndfl
+
+*$omp parallel private(ix)
+      ix = 0
+*$omp do
+      do i=1,ndfl
+         ix = ix + 1
+	 if (ix.gt.5) go to 9000 ! { dg-error "invalid (exit|branch)" }
+      enddo
+*$omp end do
+*$omp end parallel
+
+9000  continue
+      end
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/intent_out_6.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/intent_out_6.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/intent_out_6.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/intent_out_6.f90	2009-11-01 09:35:40.418315000 -0500
@@ -0,0 +1,39 @@
+! { dg-do run }
+!
+! PR fortran/41850
+!
+module test_module
+  implicit none
+contains
+  subroutine sub2(a)
+    implicit none
+    real,allocatable,intent(out),optional :: a(:)
+    if(present(a)) then
+      if(allocated(a)) call abort()
+      allocate(a(1))
+      a(1) = 5
+    end if
+  end subroutine sub2
+  subroutine sub1(a)
+    implicit none
+    real,allocatable,intent(out),optional :: a(:)
+!    print *,'in sub1'
+    call sub2(a)
+    if(present(a)) then
+      if(a(1) /= 5) call abort()
+    end if
+  end subroutine sub1
+end module test_module
+
+program test
+  use test_module
+  implicit none
+  real, allocatable :: x(:)
+  allocate(x(1))
+  call sub1()
+  x = 8
+  call sub1(x)
+  if(x(1) /= 5) call abort()
+end program
+
+! { dg-final { cleanup-modules "test_module" } }
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/intrinsic_pack_5.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/intrinsic_pack_5.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/intrinsic_pack_5.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/intrinsic_pack_5.f90	2009-12-10 15:28:57.262616000 -0500
@@ -0,0 +1,16 @@
+! { dg-do run }
+!
+! PR 41478: Corrupted memory using PACK for derived-types with allocated components
+! PR 42268: [4.4/4.5 Regression] derived type segfault with pack
+!
+! Original test case by Juergen Reuter <reuter@physik.uni-freiburg.de>
+! Modified by Janus Weil <janus@gcc.gnu.org>
+
+type :: container_t
+  integer:: entry = -1
+end type container_t
+type(container_t), dimension(1) :: a1, a2
+a2(1)%entry = 1
+a1 = pack (a2, mask = [.true.])
+if (a1(1)%entry/=1) call abort()
+end
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/list_read_10.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/list_read_10.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/list_read_10.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/list_read_10.f90	2009-12-21 18:14:06.796123000 -0500
@@ -0,0 +1,14 @@
+! { dg-do run }
+! PR 42422 - read with a repeat specifyer following a separator
+program main
+  integer, dimension(10) :: i1, i2
+
+  i1 = 0
+  i2 = (/ 1, 2, 3, 5, 5, 5, 5, 0, 0, 0 /)
+  open (10,file="pr42422.dat")
+  write (10,'(A)') ' 1 2 3 4*5 /'
+  rewind 10
+  read (10,*) i1
+  if (any(i1 /= i2)) call abort
+  close (10,status="delete")
+end program main
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/pr41928.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/pr41928.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/pr41928.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/pr41928.f90	2009-11-20 09:49:22.042156000 -0500
@@ -0,0 +1,263 @@
+! { dg-do compile }
+! { dg-options "-O -fbounds-check -w" }
+MODULE kinds
+  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND ( 14, 200 )
+  INTEGER, DIMENSION(:), ALLOCATABLE     :: nco,ncoset,nso,nsoset
+  INTEGER, DIMENSION(:,:,:), ALLOCATABLE :: co,coset
+END MODULE kinds
+MODULE ai_moments
+  USE kinds
+CONTAINS
+  SUBROUTINE cossin(la_max,npgfa,zeta,rpgfa,la_min,&
+                    lb_max,npgfb,zetb,rpgfb,lb_min,&
+                    rac,rbc,kvec,cosab,sinab)
+    REAL(KIND=dp), DIMENSION(ncoset(la_max),&
+      ncoset(lb_max))                        :: sc, ss
+    DO ipgf=1,npgfa
+      DO jpgf=1,npgfb
+        IF (la_max > 0) THEN
+          DO la=2,la_max
+            DO ax=2,la
+              DO ay=0,la-ax
+                sc(coset(ax,ay,az),1) = rap(1)*sc(coset(ax-1,ay,az),1) +&
+                              f2 *          kvec(1)*ss(coset(ax-1,ay,az),1)
+                ss(coset(ax,ay,az),1) = rap(1)*ss(coset(ax-1,ay,az),1) +&
+                              f2 *          kvec(1)*sc(coset(ax-1,ay,az),1)
+              END DO
+            END DO
+          END DO
+          IF (lb_max > 0) THEN
+            DO lb=2,lb_max
+              ss(1,coset(0,0,lb)) = rbp(3)*ss(1,coset(0,0,lb-1)) +&
+                           f2 *         kvec(3)*sc(1,coset(0,0,lb-1))
+              DO bx=2,lb
+                DO by=0,lb-bx
+                  ss(1,coset(bx,by,bz)) = rbp(1)*ss(1,coset(bx-1,by,bz)) +&
+                               f2 *           kvec(1)*sc(1,coset(bx-1,by,bz))
+                END DO
+              END DO
+            END DO
+          END IF
+        END IF
+       DO j=ncoset(lb_min-1)+1,ncoset(lb_max)
+        END DO
+      END DO
+    END DO
+  END SUBROUTINE cossin
+  SUBROUTINE moment(la_max,npgfa,zeta,rpgfa,la_min,&
+                    lb_max,npgfb,zetb,rpgfb,&
+                    lc_max,rac,rbc,mab)
+    REAL(KIND=dp), DIMENSION(:), INTENT(IN)  :: zeta, rpgfa
+    REAL(KIND=dp), DIMENSION(:), INTENT(IN)  :: zetb, rpgfb
+    REAL(KIND=dp), DIMENSION(:, :, :), &
+      INTENT(INOUT)                          :: mab
+    REAL(KIND=dp), DIMENSION(3)              :: rab, rap, rbp, rpc
+    REAL(KIND=dp), DIMENSION(ncoset(la_max),&
+      ncoset(lb_max), ncoset(lc_max))        :: s
+    DO ipgf=1,npgfa
+      DO jpgf=1,npgfb
+        IF (rpgfa(ipgf) + rpgfb(jpgf) < dab) THEN
+          DO k=1, ncoset(lc_max)-1
+            DO j=nb+1,nb+ncoset(lb_max)
+              DO i=na+1,na+ncoset(la_max)
+                mab(i,j,k) = 0.0_dp
+              END DO
+            END DO
+          END DO
+        END IF
+        rpc = zetp*(zeta(ipgf)*rac+zetb(jpgf)*rbc)
+        DO l=2, ncoset(lc_max)
+          lx = indco(1,l)
+          l2 = 0
+          IF ( lz > 0 ) THEN
+            IF ( lz > 1 ) l2 = coset(lx,ly,lz-2)
+          ELSE IF ( ly > 0 ) THEN
+            IF ( ly > 1 ) l2 = coset(lx,ly-2,lz)
+            IF ( lx > 1 ) l2 = coset(lx-2,ly,lz)
+          END IF
+          s(1,1,l) = rpc(i)*s(1,1,l1)
+          IF ( l2 > 0 ) s(1,1,l) = s(1,1,l) + f2*REAL(ni,dp)*s(1,1,l2)
+        END DO
+        DO l = 1, ncoset(lc_max)
+          IF ( lx > 0 ) THEN 
+            lx1 = coset(lx-1,ly,lz)
+          END IF
+          IF ( ly > 0 ) THEN 
+            ly1 = coset(lx,ly-1,lz)
+          END IF
+          IF (la_max > 0) THEN
+            DO la=2,la_max
+              IF ( lz1 > 0 ) s(coset(0,0,la),1,l) = s(coset(0,0,la),1,l) + &
+                             f2z*s(coset(0,0,la-1),1,lz1)
+              IF ( ly1 > 0 ) s(coset(0,1,az),1,l) = s(coset(0,1,az),1,l) + &
+                             f2y*s(coset(0,0,az),1,ly1)
+              DO ay=2,la
+                s(coset(0,ay,az),1,l) = rap(2)*s(coset(0,ay-1,az),1,l) +&
+                                       f2*REAL(ay-1,dp)*s(coset(0,ay-2,az),1,l)
+                IF ( ly1 > 0 ) s(coset(0,ay,az),1,l) = s(coset(0,ay,az),1,l) + &
+                             f2y*s(coset(0,ay-1,az),1,ly1)
+              END DO
+              DO ay=0,la-1
+                IF ( lx1 > 0 ) s(coset(1,ay,az),1,l) = s(coset(1,ay,az),1,l) + &
+                             f2x*s(coset(0,ay,az),1,lx1)
+              END DO
+              DO ax=2,la
+                DO ay=0,la-ax
+                  s(coset(ax,ay,az),1,l) = rap(1)*s(coset(ax-1,ay,az),1,l) +&
+                                          f3*s(coset(ax-2,ay,az),1,l) 
+                  IF ( lx1 > 0 ) s(coset(ax,ay,az),1,l) = s(coset(ax,ay,az),1,l) + &
+                                 f2x*s(coset(ax-1,ay,az),1,lx1)
+                END DO
+              END DO
+            END DO
+            IF (lb_max > 0) THEN
+              DO j=2,ncoset(lb_max)
+                DO i=1,ncoset(la_max)
+                  s(i,j,l) = 0.0_dp
+                END DO
+              END DO
+              DO la=la_start,la_max-1
+                DO ax=0,la
+                  DO ay=0,la-ax
+                    s(coset(ax,ay,az),2,l) = s(coset(ax+1,ay,az),1,l) -&
+                                           rab(1)*s(coset(ax,ay,az),1,l)
+                    s(coset(ax,ay,az),4,l) = s(coset(ax,ay,az+1),1,l) -&
+                                           rab(3)*s(coset(ax,ay,az),1,l)
+                  END DO
+                END DO
+              END DO
+              DO ax=0,la_max
+                DO ay=0,la_max-ax
+                  IF (ax == 0) THEN
+                    s(coset(ax,ay,az),2,l) = rbp(1)*s(coset(ax,ay,az),1,l)
+                  ELSE
+                    s(coset(ax,ay,az),2,l) = rbp(1)*s(coset(ax,ay,az),1,l) +&
+                                            fx*s(coset(ax-1,ay,az),1,l)
+                  END IF
+                  IF (lx1 > 0) s(coset(ax,ay,az),2,l) = s(coset(ax,ay,az),2,l) +&
+                        f2x*s(coset(ax,ay,az),1,lx1)
+                  IF (ay == 0) THEN
+                    s(coset(ax,ay,az),3,l) = rbp(2)*s(coset(ax,ay,az),1,l)
+                  ELSE
+                    s(coset(ax,ay,az),3,l) = rbp(2)*s(coset(ax,ay,az),1,l) +&
+                                            fy*s(coset(ax,ay-1,az),1,l)
+                  END IF
+                  IF (ly1 > 0) s(coset(ax,ay,az),3,l) = s(coset(ax,ay,az),3,l) +&
+                        f2y*s(coset(ax,ay,az),1,ly1)
+                  IF (az == 0) THEN
+                    s(coset(ax,ay,az),4,l) = rbp(3)*s(coset(ax,ay,az),1,l)
+                  ELSE
+                    s(coset(ax,ay,az),4,l) = rbp(3)*s(coset(ax,ay,az),1,l) +&
+                                            fz*s(coset(ax,ay,az-1),1,l)
+                  END IF
+                  IF (lz1 > 0) s(coset(ax,ay,az),4,l) = s(coset(ax,ay,az),4,l) +&
+                        f2z*s(coset(ax,ay,az),1,lz1)
+                END DO
+              END DO
+              DO lb=2,lb_max
+                DO la=la_start,la_max-1
+                  DO ax=0,la
+                    DO ay=0,la-ax
+                      s(coset(ax,ay,az),coset(0,0,lb),l) =&
+                        rab(3)*s(coset(ax,ay,az),coset(0,0,lb-1),l)
+                      DO bx=1,lb
+                        DO by=0,lb-bx
+                          s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                            rab(1)*s(coset(ax,ay,az),coset(bx-1,by,bz),l)
+                        END DO
+                      END DO
+                    END DO
+                  END DO
+                END DO
+                DO ax=0,la_max
+                  DO ay=0,la_max-ax
+                    IF (az == 0) THEN
+                      s(coset(ax,ay,az),coset(0,0,lb),l) =&
+                        rbp(3)*s(coset(ax,ay,az),coset(0,0,lb-1),l) +&
+                        f3*s(coset(ax,ay,az),coset(0,0,lb-2),l)
+                    END IF
+                    IF (lz1 > 0) s(coset(ax,ay,az),coset(0,0,lb),l) =&
+                                 f2z*s(coset(ax,ay,az),coset(0,0,lb-1),lz1)
+                    IF (ay == 0) THEN
+                      IF (ly1 > 0) s(coset(ax,ay,az),coset(0,1,bz),l) =&
+                                 f2y*s(coset(ax,ay,az),coset(0,0,bz),ly1)
+                      DO by=2,lb
+                        s(coset(ax,ay,az),coset(0,by,bz),l) =&
+                          f3*s(coset(ax,ay,az),coset(0,by-2,bz),l)
+                        IF (ly1 > 0) s(coset(ax,ay,az),coset(0,by,bz),l) =&
+                                 f2y*s(coset(ax,ay,az),coset(0,by-1,bz),ly1)
+                      END DO
+                      s(coset(ax,ay,az),coset(0,1,bz),l) =&
+                        fy*s(coset(ax,ay-1,az),coset(0,0,bz),l)
+                    END IF
+                    IF (ax == 0) THEN
+                      DO by=0,lb-1
+                        IF (lx1 > 0) s(coset(ax,ay,az),coset(1,by,bz),l) =&
+                                 f2x*s(coset(ax,ay,az),coset(0,by,bz),lx1)
+                      END DO
+                      DO bx=2,lb
+                        DO by=0,lb-bx
+                          s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                            f3*s(coset(ax,ay,az),coset(bx-2,by,bz),l)
+                          IF (lx1 > 0) s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                                 f2x*s(coset(ax,ay,az),coset(bx-1,by,bz),lx1)
+                        END DO
+                      END DO
+                      DO by=0,lb-1
+                        IF (lx1 > 0) s(coset(ax,ay,az),coset(1,by,bz),l) =&
+                                 f2x*s(coset(ax,ay,az),coset(0,by,bz),lx1)
+                      END DO
+                      DO bx=2,lb
+                        DO by=0,lb-bx
+                          s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                            f3*s(coset(ax,ay,az),coset(bx-2,by,bz),l)
+                          IF (lx1 > 0) s(coset(ax,ay,az),coset(bx,by,bz),l) =&
+                                 f2x*s(coset(ax,ay,az),coset(bx-1,by,bz),lx1)
+                        END DO
+                      END DO
+                    END IF
+                  END DO
+                END DO
+              END DO
+            END IF
+            IF (lb_max > 0) THEN
+              DO lb=2,lb_max
+                IF (lz1 > 0) s(1,coset(0,0,lb),l) = s(1,coset(0,0,lb),l) +&
+                             f2z*s(1,coset(0,0,lb-1),lz1)
+                IF (ly1 > 0) s(1,coset(0,1,bz),l) = s(1,coset(0,1,bz),l) +&
+                             f2y*s(1,coset(0,0,bz),ly1)
+              DO by=2,lb
+                s(1,coset(0,by,bz),l) = rbp(2)*s(1,coset(0,by-1,bz),l) +&
+                                       f2*REAL(by-1,dp)*s(1,coset(0,by-2,bz),l)
+                IF (lx1 > 0) s(1,coset(1,by,bz),l) = s(1,coset(1,by,bz),l) +&
+                             f2x*s(1,coset(0,by,bz),lx1)
+              END DO
+              DO bx=2,lb
+                DO by=0,lb-bx
+                  IF (lx1 > 0) s(1,coset(bx,by,bz),l) = s(1,coset(bx,by,bz),l) +&
+                               f2x*s(1,coset(bx-1,by,bz),lx1)
+                END DO
+              END DO
+            END DO
+          END IF
+        END IF
+        END DO
+        DO k=2,ncoset(lc_max)
+          DO j=1,ncoset(lb_max)
+          END DO
+        END DO
+      END DO
+    END DO
+  END SUBROUTINE moment
+  SUBROUTINE diff_momop(la_max,npgfa,zeta,rpgfa,la_min,&
+                    order,rac,rbc,difmab,mab_ext)
+    REAL(KIND=dp), DIMENSION(:, :, :), &
+      OPTIONAL, POINTER                      :: mab_ext
+    REAL(KIND=dp), ALLOCATABLE, &
+      DIMENSION(:, :, :)                     :: difmab_tmp
+    DO imom = 1,ncoset(order)-1
+      CALL adbdr(la_max,npgfa,rpgfa,la_min,&
+                 difmab_tmp(:,:,2), difmab_tmp(:,:,3))
+    END DO
+  END SUBROUTINE diff_momop
+END MODULE ai_moments
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/pr42166.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/pr42166.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/pr42166.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/pr42166.f90	2009-12-11 20:45:12.901900000 -0500
@@ -0,0 +1,20 @@
+! { dg-options "-O2 -g" }
+
+MODULE powell
+  INTEGER, PARAMETER :: dp=8
+CONTAINS
+  SUBROUTINE newuob (n,  bmat,  ndim,  d,  vlag,  w, npt)
+    REAL(dp), DIMENSION(ndim, *), INTENT(inout) :: bmat
+    REAL(dp), DIMENSION(*), INTENT(inout)    :: d, vlag, w
+    REAL(dp) :: sum
+    INTEGER, INTENT(in) :: npt
+    DO j=1,n
+       jp=npt+j
+       DO k=1,n
+          sum=sum+bmat(jp,k)*d(k)
+       END DO
+       vlag(jp)=sum
+    END DO
+  END SUBROUTINE newuob
+END MODULE powell
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/recursive_check_15.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/recursive_check_15.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/recursive_check_15.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/recursive_check_15.f90	2009-11-06 23:33:06.698724000 -0500
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR41909 ICE with "call foo" in "program foo"
+program test ! { dg-error "Global name" }
+  implicit none
+  call test()  ! { dg-error "" }
+contains
+  subroutine one(a)
+    real, dimension(:,:), intent(inout), optional :: a
+    call two(a)
+  end subroutine one
+end program test
+
diff -Naur gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/transfer_intrinsic_3.f90 gcc-4.4.2/gcc/testsuite/gfortran.dg/transfer_intrinsic_3.f90
--- gcc-4.4.2.orig/gcc/testsuite/gfortran.dg/transfer_intrinsic_3.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/gcc/testsuite/gfortran.dg/transfer_intrinsic_3.f90	2009-11-02 11:30:48.203315000 -0500
@@ -0,0 +1,38 @@
+! { dg-do run }
+! Tests the fix for PR41772 in which the empty array reference
+! 'qname(1:n-1)' was not handled correctly in TRANSFER.
+!
+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>
+!
+module m
+  implicit none
+contains
+  pure function str_vs(vs) result(s)
+    character, dimension(:), intent(in) :: vs
+    character(len=size(vs)) :: s
+    s = transfer(vs, s)
+  end function str_vs
+  subroutine has_key_ns(uri, localname, n)
+    character(len=*), intent(in) :: uri, localname
+    integer, intent(in) :: n
+    if ((n .lt. 2) .and. (len (uri) .ne. 0)) then
+      call abort
+    else IF ((n .ge. 2) .and. (len (uri) .ne. n - 1)) then 
+      call abort
+    end if
+  end subroutine
+end module m
+
+  use m
+  implicit none
+  character, dimension(:), pointer :: QName
+  integer :: n
+  allocate(qname(6))
+  qname = (/ 'a','b','c','d','e','f' /)
+
+  do n = 0, 3
+    call has_key_ns(str_vs(qname(1:n-1)),"", n)
+  end do
+  deallocate(qname)
+end
+! { dg-final { cleanup-modules "m" } }
\ No newline at end of file
diff -Naur gcc-4.4.2.orig/gcc/testsuite/lib/target-supports.exp gcc-4.4.2/gcc/testsuite/lib/target-supports.exp
--- gcc-4.4.2.orig/gcc/testsuite/lib/target-supports.exp	2009-08-28 05:57:51.000000000 -0400
+++ gcc-4.4.2/gcc/testsuite/lib/target-supports.exp	2009-11-03 12:59:43.654521000 -0500
@@ -2894,3 +2894,24 @@
 	#endif
     }]
 }
+
+# Return 1 if the language for the compiler under test is C.
+
+proc check_effective_target_c { } {
+ global tool
+    if [string match $tool "gcc"] {
+   return 1
+    }
+ return 0
+}
+
+# Return 1 if the language for the compiler under test is C++.
+
+proc check_effective_target_c++ { } {
+ global tool
+    if [string match $tool "g++"] {
+   return 1
+    }
+ return 0
+}
+
diff -Naur gcc-4.4.2.orig/gcc/tree-cfgcleanup.c gcc-4.4.2/gcc/tree-cfgcleanup.c
--- gcc-4.4.2.orig/gcc/tree-cfgcleanup.c	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/tree-cfgcleanup.c	2009-12-01 14:44:34.768702000 -0500
@@ -1,5 +1,5 @@
 /* CFG cleanup for trees.
-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -517,7 +517,7 @@
   control_bb = single_pred (bb);
   stmt = last_stmt (control_bb);
 
-  if (gimple_code (stmt) != GIMPLE_OMP_SECTIONS_SWITCH)
+  if (stmt == NULL || gimple_code (stmt) != GIMPLE_OMP_SECTIONS_SWITCH)
     return false;
 
   /* The block with the control statement normally has two entry edges -- one
diff -Naur gcc-4.4.2.orig/gcc/tree-ssa-ccp.c gcc-4.4.2/gcc/tree-ssa-ccp.c
--- gcc-4.4.2.orig/gcc/tree-ssa-ccp.c	2009-04-22 15:55:24.000000000 -0400
+++ gcc-4.4.2/gcc/tree-ssa-ccp.c	2009-11-09 14:38:29.547277000 -0500
@@ -1727,7 +1727,7 @@
 
 static tree
 maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,
-				    tree orig_type, bool base_is_ptr)
+				    tree orig_type)
 {
   tree f, t, field_type, tail_array_field, field_offset;
   tree ret;
@@ -1779,8 +1779,6 @@
       if (cmp == 0
 	  && useless_type_conversion_p (orig_type, field_type))
 	{
-	  if (base_is_ptr)
-	    base = build1 (INDIRECT_REF, record_type, base);
 	  t = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);
 	  return t;
 	}
@@ -1805,11 +1803,7 @@
 
       /* If we matched, then set offset to the displacement into
 	 this field.  */
-      if (base_is_ptr)
-	new_base = build1 (INDIRECT_REF, record_type, base);
-      else
-	new_base = base;
-      new_base = build3 (COMPONENT_REF, field_type, new_base, f, NULL_TREE);
+      new_base = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);
 
       /* Recurse to possibly find the match.  */
       ret = maybe_fold_offset_to_array_ref (new_base, t, orig_type,
@@ -1817,7 +1811,7 @@
       if (ret)
 	return ret;
       ret = maybe_fold_offset_to_component_ref (field_type, new_base, t,
-						orig_type, false);
+						orig_type);
       if (ret)
 	return ret;
     }
@@ -1831,8 +1825,6 @@
 
   /* If we get here, we've got an aggregate field, and a possibly 
      nonzero offset into them.  Recurse and hope for a valid match.  */
-  if (base_is_ptr)
-    base = build1 (INDIRECT_REF, record_type, base);
   base = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);
 
   t = maybe_fold_offset_to_array_ref (base, offset, orig_type,
@@ -1840,7 +1832,7 @@
   if (t)
     return t;
   return maybe_fold_offset_to_component_ref (field_type, base, offset,
-					     orig_type, false);
+					     orig_type);
 }
 
 /* Attempt to express (ORIG_TYPE)BASE+OFFSET as BASE->field_of_orig_type
@@ -1854,57 +1846,44 @@
 {
   tree ret;
   tree type;
-  bool base_is_ptr = true;
 
   STRIP_NOPS (base);
-  if (TREE_CODE (base) == ADDR_EXPR)
-    {
-      base_is_ptr = false;
+  if (TREE_CODE (base) != ADDR_EXPR)
+    return NULL_TREE;
 
-      base = TREE_OPERAND (base, 0);
+  base = TREE_OPERAND (base, 0);
 
-      /* Handle case where existing COMPONENT_REF pick e.g. wrong field of union,
-	 so it needs to be removed and new COMPONENT_REF constructed.
-	 The wrong COMPONENT_REF are often constructed by folding the
-	 (type *)&object within the expression (type *)&object+offset  */
-      if (handled_component_p (base))
+  /* Handle case where existing COMPONENT_REF pick e.g. wrong field of union,
+     so it needs to be removed and new COMPONENT_REF constructed.
+     The wrong COMPONENT_REF are often constructed by folding the
+     (type *)&object within the expression (type *)&object+offset  */
+  if (handled_component_p (base))
+    {
+      HOST_WIDE_INT sub_offset, size, maxsize;
+      tree newbase;
+      newbase = get_ref_base_and_extent (base, &sub_offset,
+					 &size, &maxsize);
+      gcc_assert (newbase);
+      if (size == maxsize
+	  && size != -1
+	  && !(sub_offset & (BITS_PER_UNIT - 1)))
 	{
-          HOST_WIDE_INT sub_offset, size, maxsize;
-	  tree newbase;
-	  newbase = get_ref_base_and_extent (base, &sub_offset,
-					     &size, &maxsize);
-	  gcc_assert (newbase);
-	  if (size == maxsize
-	      && size != -1
-	      && !(sub_offset & (BITS_PER_UNIT - 1)))
-	    {
-	      base = newbase;
-	      if (sub_offset)
-		offset = int_const_binop (PLUS_EXPR, offset,
-					  build_int_cst (TREE_TYPE (offset),
-					  sub_offset / BITS_PER_UNIT), 1);
-	    }
+	  base = newbase;
+	  if (sub_offset)
+	    offset = int_const_binop (PLUS_EXPR, offset,
+				      build_int_cst (TREE_TYPE (offset),
+					     sub_offset / BITS_PER_UNIT), 1);
 	}
-      if (useless_type_conversion_p (orig_type, TREE_TYPE (base))
-	  && integer_zerop (offset))
-	return base;
-      type = TREE_TYPE (base);
     }
-  else
-    {
-      base_is_ptr = true;
-      if (!POINTER_TYPE_P (TREE_TYPE (base)))
-	return NULL_TREE;
-      type = TREE_TYPE (TREE_TYPE (base));
-    }
-  ret = maybe_fold_offset_to_component_ref (type, base, offset,
-					    orig_type, base_is_ptr);
+  if (useless_type_conversion_p (orig_type, TREE_TYPE (base))
+      && integer_zerop (offset))
+    return base;
+  type = TREE_TYPE (base);
+
+  ret = maybe_fold_offset_to_component_ref (type, base, offset, orig_type);
   if (!ret)
-    {
-      if (base_is_ptr)
-	base = build1 (INDIRECT_REF, type, base);
-      ret = maybe_fold_offset_to_array_ref (base, offset, orig_type, true);
-    }
+    ret = maybe_fold_offset_to_array_ref (base, offset, orig_type, true);
+
   return ret;
 }
 
@@ -2143,7 +2122,7 @@
   t = maybe_fold_offset_to_array_ref (op0, op1, ptd_type, true);
   if (!t)
     t = maybe_fold_offset_to_component_ref (TREE_TYPE (op0), op0, op1,
-					    ptd_type, false);
+					    ptd_type);
   if (t)
     t = build1 (ADDR_EXPR, res_type, t);
 
diff -Naur gcc-4.4.2.orig/gcc/tree-ssa-dom.c gcc-4.4.2/gcc/tree-ssa-dom.c
--- gcc-4.4.2.orig/gcc/tree-ssa-dom.c	2008-12-30 16:20:08.000000000 -0500
+++ gcc-4.4.2/gcc/tree-ssa-dom.c	2009-12-06 19:52:55.907953000 -0500
@@ -2491,6 +2491,8 @@
 
       if (arg == lhs)
 	continue;
+      else if (!arg)
+	break;
       else if (!val)
 	val = arg;
       else if (!operand_equal_p (arg, val, 0))
diff -Naur gcc-4.4.2.orig/gcc/tree-ssa-math-opts.c gcc-4.4.2/gcc/tree-ssa-math-opts.c
--- gcc-4.4.2.orig/gcc/tree-ssa-math-opts.c	2009-02-20 10:20:38.000000000 -0500
+++ gcc-4.4.2/gcc/tree-ssa-math-opts.c	2009-11-08 13:10:10.344107000 -0500
@@ -528,7 +528,9 @@
 		      || DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD))
 		{
 		  enum built_in_function code;
-		  bool md_code;
+		  bool md_code, fail;
+		  imm_use_iterator ui;
+		  use_operand_p use_p;
 
 		  code = DECL_FUNCTION_CODE (fndecl);
 		  md_code = DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD;
@@ -537,12 +539,34 @@
 		  if (!fndecl)
 		    continue;
 
+		  /* Check that all uses of the SSA name are divisions,
+		     otherwise replacing the defining statement will do
+		     the wrong thing.  */
+		  fail = false;
+		  FOR_EACH_IMM_USE_FAST (use_p, ui, arg1)
+		    {
+		      gimple stmt2 = USE_STMT (use_p);
+		      if (!is_gimple_assign (stmt2)
+			  || gimple_assign_rhs_code (stmt2) != RDIV_EXPR
+			  || gimple_assign_rhs1 (stmt2) == arg1
+			  || gimple_assign_rhs2 (stmt2) != arg1)
+			{
+			  fail = true;
+			  break;
+			}
+		    }
+		  if (fail)
+		    continue;
+
 		  gimple_call_set_fndecl (stmt1, fndecl);
 		  update_stmt (stmt1);
 
-		  gimple_assign_set_rhs_code (stmt, MULT_EXPR);
-		  fold_stmt_inplace (stmt);
-		  update_stmt (stmt);
+		  FOR_EACH_IMM_USE_STMT (stmt, ui, arg1)
+		    {
+		      gimple_assign_set_rhs_code (stmt, MULT_EXPR);
+		      fold_stmt_inplace (stmt);
+		      update_stmt (stmt);
+		    }
 		}
 	    }
 	}
diff -Naur gcc-4.4.2.orig/gcc/tree-tailcall.c gcc-4.4.2/gcc/tree-tailcall.c
--- gcc-4.4.2.orig/gcc/tree-tailcall.c	2009-07-07 10:07:19.000000000 -0400
+++ gcc-4.4.2/gcc/tree-tailcall.c	2009-11-07 12:39:48.507096000 -0500
@@ -920,8 +920,10 @@
 
       if (!phis_constructed)
 	{
-	  /* Ensure that there is only one predecessor of the block.  */
-	  if (!single_pred_p (first))
+	  /* Ensure that there is only one predecessor of the block
+	     or if there are existing degenerate PHI nodes.  */
+	  if (!single_pred_p (first)
+	      || !gimple_seq_empty_p (phi_nodes (first)))
 	    first = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));
 
 	  /* Copy the args if needed.  */
diff -Naur gcc-4.4.2.orig/gcc/unwind-dw2.c gcc-4.4.2/gcc/unwind-dw2.c
--- gcc-4.4.2.orig/gcc/unwind-dw2.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/gcc/unwind-dw2.c	2009-10-19 15:56:57.500694000 -0400
@@ -789,22 +789,22 @@
 		result = second ^ first;
 		break;
 	      case DW_OP_le:
-		result = (_Unwind_Sword) first <= (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second <= (_Unwind_Sword) first;
 		break;
 	      case DW_OP_ge:
-		result = (_Unwind_Sword) first >= (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second >= (_Unwind_Sword) first;
 		break;
 	      case DW_OP_eq:
-		result = (_Unwind_Sword) first == (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second == (_Unwind_Sword) first;
 		break;
 	      case DW_OP_lt:
-		result = (_Unwind_Sword) first < (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second < (_Unwind_Sword) first;
 		break;
 	      case DW_OP_gt:
-		result = (_Unwind_Sword) first > (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second > (_Unwind_Sword) first;
 		break;
 	      case DW_OP_ne:
-		result = (_Unwind_Sword) first != (_Unwind_Sword) second;
+		result = (_Unwind_Sword) second != (_Unwind_Sword) first;
 		break;
 
 	      default:
diff -Naur gcc-4.4.2.orig/gcc/varasm.c gcc-4.4.2/gcc/varasm.c
--- gcc-4.4.2.orig/gcc/varasm.c	2009-03-17 16:18:21.000000000 -0400
+++ gcc-4.4.2/gcc/varasm.c	2009-11-05 09:47:24.466978000 -0500
@@ -4302,6 +4302,10 @@
 
     case POINTER_PLUS_EXPR:
     case PLUS_EXPR:
+      /* Any valid floating-point constants will have been folded by now;
+	 with -frounding-math we hit this with addition of two constants.  */
+      if (TREE_CODE (endtype) == REAL_TYPE)
+	return NULL_TREE;
       if (! INTEGRAL_TYPE_P (endtype)
 	  || TYPE_PRECISION (endtype) >= POINTER_SIZE)
 	{
@@ -4324,6 +4328,8 @@
       break;
 
     case MINUS_EXPR:
+      if (TREE_CODE (endtype) == REAL_TYPE)
+	return NULL_TREE;
       if (! INTEGRAL_TYPE_P (endtype)
 	  || TYPE_PRECISION (endtype) >= POINTER_SIZE)
 	{
@@ -4485,8 +4491,8 @@
     case REAL_TYPE:
       if (TREE_CODE (exp) != REAL_CST)
 	error ("initializer for floating value is not a floating constant");
-
-      assemble_real (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)), align);
+      else
+	assemble_real (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)), align);
       break;
 
     case COMPLEX_TYPE:
diff -Naur gcc-4.4.2.orig/gcc/version.c gcc-4.4.2/gcc/version.c
--- gcc-4.4.2.orig/gcc/version.c	2007-08-21 11:35:30.000000000 -0400
+++ gcc-4.4.2/gcc/version.c	2010-01-01 15:38:12.632445080 -0500
@@ -14,4 +14,4 @@
    Makefile.  */
 
 const char version_string[] = BASEVER DATESTAMP DEVPHASE REVISION;
-const char pkgversion_string[] = PKGVERSION;
+const char pkgversion_string[] = "(GCC for Cross-LFS 4.4.2.20100101) ";
diff -Naur gcc-4.4.2.orig/gcc/vmsdbgout.c gcc-4.4.2/gcc/vmsdbgout.c
--- gcc-4.4.2.orig/gcc/vmsdbgout.c	2008-08-29 14:41:19.000000000 -0400
+++ gcc-4.4.2/gcc/vmsdbgout.c	2009-10-19 08:15:27.233029000 -0400
@@ -166,6 +166,7 @@
 
 static void vmsdbgout_init (const char *);
 static void vmsdbgout_finish (const char *);
+static void vmsdbgout_assembly_start (void);
 static void vmsdbgout_define (unsigned int, const char *);
 static void vmsdbgout_undef (unsigned int, const char *);
 static void vmsdbgout_start_source_file (unsigned int, const char *);
@@ -188,6 +189,7 @@
 const struct gcc_debug_hooks vmsdbg_debug_hooks
 = {vmsdbgout_init,
    vmsdbgout_finish,
+   vmsdbgout_assembly_start,
    vmsdbgout_define,
    vmsdbgout_undef,
    vmsdbgout_start_source_file,
@@ -1636,6 +1638,15 @@
 /* Not implemented in VMS Debug.  */
 
 static void
+vmsdbgout_assembly_start (void)
+{
+  if (write_symbols == VMS_AND_DWARF2_DEBUG)
+    (*dwarf2_debug_hooks.assembly_start) ();
+}
+
+/* Not implemented in VMS Debug.  */
+
+static void
 vmsdbgout_define (unsigned int lineno, const char *buffer)
 {
   if (write_symbols == VMS_AND_DWARF2_DEBUG)
diff -Naur gcc-4.4.2.orig/libada/configure gcc-4.4.2/libada/configure
--- gcc-4.4.2.orig/libada/configure	2009-07-13 16:04:43.000000000 -0400
+++ gcc-4.4.2/libada/configure	2009-10-24 06:58:53.054307000 -0400
@@ -272,7 +272,7 @@
 PACKAGE_BUGREPORT=
 
 ac_unique_file="Makefile.in"
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir MAINT multi_basedir toolexecdir toolexeclibdir CC ac_ct_CC EXEEXT OBJEXT CFLAGS enable_shared LN_S default_gnatlib_target LDFLAGS CPPFLAGS warn_cflags LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir MAINT multi_basedir toolexecdir toolexeclibdir CC ac_ct_CC EXEEXT OBJEXT CFLAGS enable_shared LN_S default_gnatlib_target have_getipinfo LDFLAGS CPPFLAGS warn_cflags LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -815,6 +815,7 @@
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-build-libsubdir=DIR  Directory where to find libraries for build system
+  --with-system-libunwind use installed libunwind
 
 Some influential environment variables:
   CC          C compiler command
@@ -2527,6 +2528,51 @@
 fi
 
 
+# Check for _Unwind_GetIPInfo
+
+
+# Check whether --with-system-libunwind or --without-system-libunwind was given.
+if test "${with_system_libunwind+set}" = set; then
+  withval="$with_system_libunwind"
+
+fi;
+  # If system-libunwind was not specifically set, pick a default setting.
+  if test x$with_system_libunwind = x; then
+    case ${target} in
+      ia64-*-hpux*) with_system_libunwind=yes ;;
+      *) with_system_libunwind=no ;;
+    esac
+  fi
+  # Based on system-libunwind and target, do we have ipinfo?
+  if  test x$with_system_libunwind = xyes; then
+    case ${target} in
+      ia64-*-*) have_unwind_getipinfo=no ;;
+      *) have_unwind_getipinfo=yes ;;
+    esac
+  else
+    # Darwin before version 9 does not have _Unwind_GetIPInfo.
+
+    case ${target} in
+      *-*-darwin[3-8]|*-*-darwin[3-8].*) have_unwind_getipinfo=no ;;
+      *) have_unwind_getipinfo=yes ;;
+    esac
+
+  fi
+
+  if test x$have_unwind_getipinfo = xyes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETIPINFO 1
+_ACEOF
+
+  fi
+
+have_getipinfo=
+if test x$have_unwind_getipinfo = xyes; then
+  have_getipinfo=-DHAVE_GETIPINFO
+fi
+
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -3953,6 +3999,7 @@
 s,@enable_shared@,$enable_shared,;t t
 s,@LN_S@,$LN_S,;t t
 s,@default_gnatlib_target@,$default_gnatlib_target,;t t
+s,@have_getipinfo@,$have_getipinfo,;t t
 s,@LDFLAGS@,$LDFLAGS,;t t
 s,@CPPFLAGS@,$CPPFLAGS,;t t
 s,@warn_cflags@,$warn_cflags,;t t
diff -Naur gcc-4.4.2.orig/libada/configure.ac gcc-4.4.2/libada/configure.ac
--- gcc-4.4.2.orig/libada/configure.ac	2009-07-13 16:04:43.000000000 -0400
+++ gcc-4.4.2/libada/configure.ac	2009-10-24 06:58:53.054307000 -0400
@@ -18,6 +18,7 @@
 sinclude(../config/acx.m4)
 sinclude(../config/multi.m4)
 sinclude(../config/override.m4)
+sinclude(../config/unwind_ipinfo.m4)
 
 AC_INIT
 AC_PREREQ([2.59])
@@ -130,6 +131,14 @@
 fi
 AC_SUBST([default_gnatlib_target])
 
+# Check for _Unwind_GetIPInfo
+GCC_CHECK_UNWIND_GETIPINFO
+have_getipinfo=
+if test x$have_unwind_getipinfo = xyes; then
+  have_getipinfo=-DHAVE_GETIPINFO
+fi
+AC_SUBST(have_getipinfo)
+
 AC_PROG_CC
 warn_cflags=
 if test "x$GCC" = "xyes"; then
diff -Naur gcc-4.4.2.orig/libada/Makefile.in gcc-4.4.2/libada/Makefile.in
--- gcc-4.4.2.orig/libada/Makefile.in	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libada/Makefile.in	2009-10-24 06:58:53.054307000 -0400
@@ -56,6 +56,8 @@
 
 TARGET_LIBGCC2_CFLAGS=
 GNATLIBCFLAGS= -g -O2
+GNATLIBCFLAGS_FOR_C = $(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) -fexceptions \
+	-DIN_RTS @have_getipinfo@
 
 # Get target-specific overrides for TARGET_LIBGCC2_CFLAGS.
 host_subdir = @host_subdir@
@@ -78,6 +80,7 @@
         "SHELL=$(SHELL)" \
         "GNATLIBFLAGS=$(GNATLIBFLAGS) $(MULTIFLAGS)" \
         "GNATLIBCFLAGS=$(GNATLIBCFLAGS) $(MULTIFLAGS)" \
+        "GNATLIBCFLAGS_FOR_C=$(GNATLIBCFLAGS_FOR_C) $(MULTIFLAGS)" \
         "TARGET_LIBGCC2_CFLAGS=$(TARGET_LIBGCC2_CFLAGS)" \
         "THREAD_KIND=$(THREAD_KIND)" \
         "TRACE=$(TRACE)" \
diff -Naur gcc-4.4.2.orig/libcpp/directives.c gcc-4.4.2/libcpp/directives.c
--- gcc-4.4.2.orig/libcpp/directives.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libcpp/directives.c	2009-11-11 15:21:14.372933000 -0500
@@ -125,6 +125,8 @@
 static cpp_hashnode *parse_assertion (cpp_reader *, struct answer **, int);
 static struct answer ** find_answer (cpp_hashnode *, const struct answer *);
 static void handle_assertion (cpp_reader *, const char *, int);
+static void do_pragma_push_macro (cpp_reader *);
+static void do_pragma_pop_macro (cpp_reader *);
 
 /* This is the table of directive handlers.  It is ordered by
    frequency of occurrence; the numbers at the end are directive
@@ -1226,6 +1228,8 @@
 {
   /* Pragmas in the global namespace.  */
   register_pragma_internal (pfile, 0, "once", do_pragma_once);
+  register_pragma_internal (pfile, 0, "push_macro", do_pragma_push_macro);
+  register_pragma_internal (pfile, 0, "pop_macro", do_pragma_pop_macro);
 
   /* New GCC-specific pragmas should be put in the GCC namespace.  */
   register_pragma_internal (pfile, "GCC", "poison", do_pragma_poison);
@@ -1405,6 +1409,96 @@
   _cpp_mark_file_once_only (pfile, pfile->buffer->file);
 }
 
+/* Handle #pragma push_macro(STRING).  */
+static void
+do_pragma_push_macro (cpp_reader *pfile)
+{
+  char *macroname, *dest;
+  const char *limit, *src;
+  const cpp_token *txt;
+  struct def_pragma_macro *c;
+
+  txt = get__Pragma_string (pfile);
+  if (!txt)
+    {
+      source_location src_loc = pfile->cur_token[-1].src_loc;
+      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,
+		 "invalid #pragma push_macro directive");
+      check_eol (pfile);
+      skip_rest_of_line (pfile);
+      return;
+    }
+  dest = macroname = (char *) alloca (txt->val.str.len + 2);
+  src = (const char *) (txt->val.str.text + 1 + (txt->val.str.text[0] == 'L'));
+  limit = (const char *) (txt->val.str.text + txt->val.str.len - 1);
+  while (src < limit)
+    {
+      /* We know there is a character following the backslash.  */
+      if (*src == '\\' && (src[1] == '\\' || src[1] == '"'))
+	src++;
+      *dest++ = *src++;
+    }
+  *dest = 0;
+  check_eol (pfile);
+  skip_rest_of_line (pfile);
+  c = XNEW (struct def_pragma_macro);
+  c->name = XNEWVAR (char, strlen (macroname) + 1);
+  strcpy (c->name, macroname);
+  c->next = pfile->pushed_macros;
+  c->value = cpp_push_definition (pfile, c->name);
+  pfile->pushed_macros = c;
+}
+
+/* Handle #pragma pop_macro(STRING).  */
+static void
+do_pragma_pop_macro (cpp_reader *pfile)
+{
+  char *macroname, *dest;
+  const char *limit, *src;
+  const cpp_token *txt;
+  struct def_pragma_macro *l = NULL, *c = pfile->pushed_macros;
+  txt = get__Pragma_string (pfile);
+  if (!txt)
+    {
+      source_location src_loc = pfile->cur_token[-1].src_loc;
+      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,
+		 "invalid #pragma pop_macro directive");
+      check_eol (pfile);
+      skip_rest_of_line (pfile);
+      return;
+    }
+  dest = macroname = (char *) alloca (txt->val.str.len + 2);
+  src = (const char *) (txt->val.str.text + 1 + (txt->val.str.text[0] == 'L'));
+  limit = (const char *) (txt->val.str.text + txt->val.str.len - 1);
+  while (src < limit)
+    {
+      /* We know there is a character following the backslash.  */
+      if (*src == '\\' && (src[1] == '\\' || src[1] == '"'))
+	src++;
+      *dest++ = *src++;
+    }
+  *dest = 0;
+  check_eol (pfile);
+  skip_rest_of_line (pfile);
+
+  while (c != NULL)
+    {
+      if (!strcmp (c->name, macroname))
+	{
+	  if (!l)
+	    pfile->pushed_macros = c->next;
+	  else
+	    l->next = c->next;
+	  cpp_pop_definition (pfile, c->name, c->value);
+	  free (c->name);
+	  free (c);
+	  break;
+	}
+      l = c;
+      c = c->next;
+    }
+}
+
 /* Handle #pragma GCC poison, to poison one or more identifiers so
    that the lexer produces a hard error for each subsequent usage.  */
 static void
@@ -2200,28 +2294,11 @@
   run_directive (pfile, T_UNDEF, buf, len);
 }
 
-/* Like lex_macro_node, but read the input from STR.  */
-static cpp_hashnode *
-lex_macro_node_from_str (cpp_reader *pfile, const char *str)
-{
-  size_t len = strlen (str);
-  uchar *buf = (uchar *) alloca (len + 1);
-  cpp_hashnode *node;
-
-  memcpy (buf, str, len);
-  buf[len] = '\n';
-  cpp_push_buffer (pfile, buf, len, true);
-  node = lex_macro_node (pfile, true);
-  _cpp_pop_buffer (pfile);
-
-  return node;
-}
-
 /* If STR is a defined macro, return its definition node, else return NULL.  */
 cpp_macro *
 cpp_push_definition (cpp_reader *pfile, const char *str)
 {
-  cpp_hashnode *node = lex_macro_node_from_str (pfile, str);
+  cpp_hashnode *node = _cpp_lex_identifier (pfile, str);
   if (node && node->type == NT_MACRO)
     return node->value.macro;
   else
@@ -2233,7 +2310,7 @@
 void
 cpp_pop_definition (cpp_reader *pfile, const char *str, cpp_macro *dfn)
 {
-  cpp_hashnode *node = lex_macro_node_from_str (pfile, str);
+  cpp_hashnode *node = _cpp_lex_identifier (pfile, str);
   if (node == NULL)
     return;
 
diff -Naur gcc-4.4.2.orig/libcpp/init.c gcc-4.4.2/libcpp/init.c
--- gcc-4.4.2.orig/libcpp/init.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libcpp/init.c	2009-11-11 15:21:14.372933000 -0500
@@ -216,6 +216,9 @@
   pfile->a_buff = _cpp_get_buff (pfile, 0);
   pfile->u_buff = _cpp_get_buff (pfile, 0);
 
+  /* Initialize table for push_macro/pop_macro.  */
+  pfile->pushed_macros = 0;
+
   /* The expression parser stack.  */
   _cpp_expand_op_stack (pfile);
 
@@ -245,6 +248,7 @@
 cpp_destroy (cpp_reader *pfile)
 {
   cpp_context *context, *contextn;
+  struct def_pragma_macro *pmacro;
   tokenrun *run, *runn;
   int i;
 
@@ -296,6 +300,17 @@
 
       free (pfile->comments.entries);
     }
+  if (pfile->pushed_macros)
+    {
+      do
+	{
+	  pmacro = pfile->pushed_macros;
+	  pfile->pushed_macros = pmacro->next;
+	  free (pmacro->name);
+	  free (pmacro);
+	}
+      while (pfile->pushed_macros);
+    }
 
   free (pfile);
 }
diff -Naur gcc-4.4.2.orig/libcpp/internal.h gcc-4.4.2/libcpp/internal.h
--- gcc-4.4.2.orig/libcpp/internal.h	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libcpp/internal.h	2009-11-11 15:21:14.372933000 -0500
@@ -305,6 +305,16 @@
   struct cset_converter input_cset_desc;
 };
 
+/* The list of saved macros by push_macro pragma.  */
+struct def_pragma_macro {
+  /* Chain element to previous saved macro.  */
+  struct def_pragma_macro *next;
+  /* Name of the macro.  */
+  char *name;
+  /* The stored macro content.  */
+  cpp_macro *value;
+};
+
 /* A cpp_reader encapsulates the "state" of a pre-processor run.
    Applying cpp_get_token repeatedly yields a stream of pre-processor
    tokens.  Usually, there is only one cpp_reader object active.  */
@@ -474,6 +484,9 @@
 
   /* Table of comments, when state.save_comments is true.  */
   cpp_comment_table comments;
+
+  /* List of saved macros by push_macro.  */
+  struct def_pragma_macro *pushed_macros;
 };
 
 /* Character classes.  Based on the more primitive macros in safe-ctype.h.
@@ -574,6 +587,7 @@
 extern cpp_token *_cpp_lex_direct (cpp_reader *);
 extern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);
 extern void _cpp_init_tokenrun (tokenrun *, unsigned int);
+extern cpp_hashnode *_cpp_lex_identifier (cpp_reader *, const char *);
 
 /* In init.c.  */
 extern void _cpp_maybe_push_include_file (cpp_reader *);
diff -Naur gcc-4.4.2.orig/libcpp/lex.c gcc-4.4.2/libcpp/lex.c
--- gcc-4.4.2.orig/libcpp/lex.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libcpp/lex.c	2009-11-11 15:21:14.372933000 -0500
@@ -504,6 +504,57 @@
   return false;
 }
 
+/* Helper function to get the cpp_hashnode of the identifier BASE.  */
+static cpp_hashnode *
+lex_identifier_intern (cpp_reader *pfile, const uchar *base)
+{
+  cpp_hashnode *result;
+  const uchar *cur;
+  unsigned int len;
+  unsigned int hash = HT_HASHSTEP (0, *base);
+
+  cur = base + 1;
+  while (ISIDNUM (*cur))
+    {
+      hash = HT_HASHSTEP (hash, *cur);
+      cur++;
+    }
+  len = cur - base;
+  hash = HT_HASHFINISH (hash, len);
+  result = CPP_HASHNODE (ht_lookup_with_hash (pfile->hash_table,
+					      base, len, hash, HT_ALLOC));
+
+  /* Rarely, identifiers require diagnostics when lexed.  */
+  if (__builtin_expect ((result->flags & NODE_DIAGNOSTIC)
+			&& !pfile->state.skipping, 0))
+    {
+      /* It is allowed to poison the same identifier twice.  */
+      if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)
+	cpp_error (pfile, CPP_DL_ERROR, "attempt to use poisoned \"%s\"",
+		   NODE_NAME (result));
+
+      /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the
+	 replacement list of a variadic macro.  */
+      if (result == pfile->spec_nodes.n__VA_ARGS__
+	  && !pfile->state.va_args_ok)
+	cpp_error (pfile, CPP_DL_PEDWARN,
+		   "__VA_ARGS__ can only appear in the expansion"
+		   " of a C99 variadic macro");
+    }
+
+  return result;
+}
+
+/* Get the cpp_hashnode of an identifier specified by NAME in
+   the current cpp_reader object.  If none is found, NULL is returned.  */
+cpp_hashnode *
+_cpp_lex_identifier (cpp_reader *pfile, const char *name)
+{
+  cpp_hashnode *result;
+  result = lex_identifier_intern (pfile, (uchar *) name);
+  return result;
+}
+
 /* Lex an identifier starting at BUFFER->CUR - 1.  */
 static cpp_hashnode *
 lex_identifier (cpp_reader *pfile, const uchar *base, bool starts_ucn,
diff -Naur gcc-4.4.2.orig/libcpp/pch.c gcc-4.4.2/libcpp/pch.c
--- gcc-4.4.2.orig/libcpp/pch.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libcpp/pch.c	2009-11-11 15:21:14.372933000 -0500
@@ -33,6 +33,8 @@
 static int collect_ht_nodes (cpp_reader *, cpp_hashnode *, void *);
 static int write_defs (cpp_reader *, cpp_hashnode *, void *);
 static int save_macros (cpp_reader *, cpp_hashnode *, void *);
+static int _cpp_save_pushed_macros (cpp_reader *, FILE *);
+static int _cpp_restore_pushed_macros (cpp_reader *, FILE *);
 
 /* This structure represents a macro definition on disk.  */
 struct macrodef_struct
@@ -378,9 +380,140 @@
       return -1;
     }
 
+  /* Write saved macros.  */
+  if (! _cpp_save_pushed_macros (r, f))
+    {
+      cpp_errno (r, CPP_DL_ERROR, "while writing precompiled header");
+      return -1;
+    }
+
   return 0;
 }
 
+static int
+_cpp_restore_pushed_macros (cpp_reader *r, FILE *f)
+{
+  size_t count_saved = 0;
+  size_t i;
+  struct def_pragma_macro *p;
+  size_t nlen;
+  cpp_hashnode *h = NULL;
+  cpp_macro *m;
+  uchar *defn;
+  size_t defnlen;
+
+  if (fread (&count_saved, sizeof (count_saved), 1, f) != 1)
+    return 0;
+  if (! count_saved)
+    return 1;
+  for (i = 0; i < count_saved; i++)
+    {
+      if (fread (&nlen, sizeof (nlen), 1, f) != 1)
+	return 0;
+      p = XNEW (struct def_pragma_macro);
+      p->name = XNEWVAR (char, nlen + 1);
+      p->name[nlen] = 0;
+      if (fread (p->name, nlen, 1, f) != 1)
+	return 0;
+      /* Save old state.  */
+      m = cpp_push_definition (r, p->name);
+      if (fread (&defnlen, sizeof (defnlen), 1, f) != 1)
+	return 0;
+      defn = XNEWVAR (uchar, defnlen + 2);
+      defn[defnlen] = '\n';
+      defn[defnlen + 1] = 0;
+
+      if (fread (defn, defnlen, 1, f) != 1)
+	return 0;
+      cpp_pop_definition (r, p->name, NULL);
+      {
+	size_t namelen;
+	uchar *dn;
+
+	namelen = ustrcspn (defn, "( \n");
+	h = cpp_lookup (r, defn, namelen);
+	dn = defn + namelen;
+
+	h->type = NT_VOID;
+	h->flags &= ~(NODE_POISONED|NODE_BUILTIN|NODE_DISABLED|NODE_USED);
+	if (cpp_push_buffer (r, dn, ustrchr (dn, '\n') - dn, true)
+	    != NULL)
+	  {
+	    _cpp_clean_line (r);
+	    if (!_cpp_create_definition (r, h))
+	      abort ();
+	    _cpp_pop_buffer (r);
+	  }
+	else
+	  abort ();
+      }
+      p->value = cpp_push_definition (r, p->name);
+
+      free (defn);
+      p->next = r->pushed_macros;
+      r->pushed_macros = p;
+      /* Restore current state.  */
+      cpp_pop_definition (r, p->name, m);
+    }
+  return 1;
+}
+
+static int
+_cpp_save_pushed_macros (cpp_reader *r, FILE *f)
+{
+  size_t count_saved = 0;
+  size_t i;
+  struct def_pragma_macro *p,**pp;
+  cpp_hashnode *node;
+  cpp_macro *m;
+  size_t defnlen;
+  const uchar *defn;
+
+  /* Get count. */
+  p = r->pushed_macros;
+  while (p != NULL)
+    {
+      count_saved++;
+      p = p->next;
+    }
+  if (fwrite (&count_saved, sizeof (count_saved), 1, f) != 1)
+    return 0;
+  if (!count_saved)
+    return 1;
+
+  pp = (struct def_pragma_macro **) alloca (sizeof (struct def_pragma_macro *)
+					    * count_saved);
+  /* Store them in reverse order.  */
+  p = r->pushed_macros;
+  i = count_saved;
+  while (p != NULL)
+    {
+      --i;
+      pp[i] = p;
+      p = p->next;
+    }
+  for (i = 0; i < count_saved; i++)
+    {
+      /* Save old state.  */
+      m = cpp_push_definition (r, pp[i]->name);
+      /* Set temporary macro name to saved state.  */
+      cpp_pop_definition (r, pp[i]->name, pp[i]->value);
+      node = _cpp_lex_identifier (r, pp[i]->name);
+      defnlen = strlen (pp[i]->name);
+      if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1
+	  || fwrite (pp[i]->name, defnlen, 1, f) != 1)
+	return 0;
+      defn = cpp_macro_definition (r, node);
+      defnlen = ustrlen (defn);
+      if (fwrite (&defnlen, sizeof (size_t), 1, f) != 1
+	  || fwrite (defn, defnlen, 1, f) != 1)
+	return 0;
+      /* Restore current state.  */
+      cpp_pop_definition (r, pp[i]->name, m);
+    }
+  return 1;
+}
+
 
 /* Data structure to transform hash table nodes into a sorted list */
 
@@ -752,6 +885,9 @@
   if (!r->counter)
     r->counter = counter;
 
+  /* Read pushed macros. */
+  if (! _cpp_restore_pushed_macros (r, f))
+    goto error;
   return 0;
 
  error:
diff -Naur gcc-4.4.2.orig/libgfortran/intrinsics/pack_generic.c gcc-4.4.2/libgfortran/intrinsics/pack_generic.c
--- gcc-4.4.2.orig/libgfortran/intrinsics/pack_generic.c	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libgfortran/intrinsics/pack_generic.c	2009-12-10 15:28:57.262616000 -0500
@@ -403,7 +403,7 @@
 
     case GFC_DTYPE_DERIVED_2:
       if (GFC_UNALIGNED_2(ret->data) || GFC_UNALIGNED_2(array->data)
-	  || GFC_UNALIGNED_2(vector->data))
+	  || (vector && GFC_UNALIGNED_2(vector->data)))
 	break;
       else
 	{
@@ -414,7 +414,7 @@
 
     case GFC_DTYPE_DERIVED_4:
       if (GFC_UNALIGNED_4(ret->data) || GFC_UNALIGNED_4(array->data)
-	  || GFC_UNALIGNED_4(vector->data))
+	  || (vector && GFC_UNALIGNED_4(vector->data)))
 	break;
       else
 	{
@@ -425,7 +425,7 @@
 
     case GFC_DTYPE_DERIVED_8:
       if (GFC_UNALIGNED_8(ret->data) || GFC_UNALIGNED_8(array->data)
-	  || GFC_UNALIGNED_8(vector->data))
+	  || (vector && GFC_UNALIGNED_8(vector->data)))
 	break;
       else
 	{
@@ -436,7 +436,7 @@
 #ifdef HAVE_GFC_INTEGER_16
     case GFC_DTYPE_DERIVED_16:
       if (GFC_UNALIGNED_16(ret->data) || GFC_UNALIGNED_16(array->data)
-	  || GFC_UNALIGNED_16(vector->data))
+	  || (vector && GFC_UNALIGNED_16(vector->data)))
 	break;
       else
 	{
diff -Naur gcc-4.4.2.orig/libgfortran/io/transfer.c gcc-4.4.2/libgfortran/io/transfer.c
--- gcc-4.4.2.orig/libgfortran/io/transfer.c	2009-09-19 13:21:20.000000000 -0400
+++ gcc-4.4.2/libgfortran/io/transfer.c	2009-11-19 23:00:03.926316000 -0500
@@ -2579,6 +2579,8 @@
       if (sseek (dtp->u.p.current_unit->s, 
 		 dtp->u.p.current_unit->bytes_left_subrecord, SEEK_CUR) < 0)
 	generate_error (&dtp->common, LIBERROR_OS, NULL);
+
+      dtp->u.p.current_unit->bytes_left_subrecord = 0;
     }
   else
     {			/* Seek by reading data.  */
@@ -2659,7 +2661,7 @@
 
     case FORMATTED_DIRECT:
     case UNFORMATTED_DIRECT:
-      skip_record (dtp, 0);
+      skip_record (dtp, dtp->u.p.current_unit->bytes_left);
       break;
 
     case FORMATTED_STREAM:
diff -Naur gcc-4.4.2.orig/libgomp/testsuite/libgomp.c/pr42029.c gcc-4.4.2/libgomp/testsuite/libgomp.c/pr42029.c
--- gcc-4.4.2.orig/libgomp/testsuite/libgomp.c/pr42029.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/libgomp/testsuite/libgomp.c/pr42029.c	2009-11-13 13:42:32.696477000 -0500
@@ -0,0 +1,19 @@
+/* PR middle-end/42029 */
+/* { dg-do run } */
+
+extern void abort (void);
+
+int
+main ()
+{
+  int i;
+  _Complex int c = 0;
+
+#pragma omp parallel for private(i) reduction(+:c)
+  for (i = 0; i < 8; ++i)
+    c += 1;
+
+  if (c != 8)
+    abort ();
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/libgomp/testsuite/libgomp.fortran/pr42162.f90 gcc-4.4.2/libgomp/testsuite/libgomp.fortran/pr42162.f90
--- gcc-4.4.2.orig/libgomp/testsuite/libgomp.fortran/pr42162.f90	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/libgomp/testsuite/libgomp.fortran/pr42162.f90	2009-11-25 16:01:47.763505000 -0500
@@ -0,0 +1,53 @@
+! PR fortran/42162
+! { dg-do run }
+
+subroutine sub1(k, a)
+  implicit none
+  integer :: k, a(3)
+  !$omp do
+    do k=1,3
+      a(k) = a(k) + 1
+    enddo
+  !$omp end do
+end subroutine sub1
+
+subroutine sub2(k, a)
+  implicit none
+  integer :: k, a(3)
+  !$omp do private (k)
+    do k=1,3
+      a(k) = a(k) + 1
+    enddo
+  !$omp end do
+end subroutine sub2
+
+subroutine sub3(k, a)
+  implicit none
+  integer :: k, a(3)
+  !$omp do lastprivate (k)
+    do k=1,3
+      a(k) = a(k) + 1
+    enddo
+  !$omp end do
+end subroutine sub3
+
+program pr42162
+  implicit none
+  integer :: k, a(3), b(3), c(3)
+  a = 1
+  b = 2
+  c = 3
+  k = 3
+  !$omp parallel num_threads(3)
+  call sub1 (k, a)
+  !$omp end parallel
+  k = 4
+  !$omp parallel num_threads(3)
+  call sub2 (k, b)
+  !$omp end parallel
+  k = 10
+  !$omp parallel num_threads(3)
+  call sub3 (k, c)
+  !$omp end parallel
+  if (k.ne.4.or.any(a.ne.2).or.any(b.ne.3).or.any(c.ne.4)) call abort
+end
diff -Naur gcc-4.4.2.orig/libjava/classpath/tools/classes/gnu/classpath/tools/jar/Creator.class gcc-4.4.2/libjava/classpath/tools/classes/gnu/classpath/tools/jar/Creator.class
--- gcc-4.4.2.orig/libjava/classpath/tools/classes/gnu/classpath/tools/jar/Creator.class	2008-10-22 14:19:29.000000000 -0400
+++ gcc-4.4.2/libjava/classpath/tools/classes/gnu/classpath/tools/jar/Creator.class	2009-10-22 11:50:46.239232000 -0400
@@ -1,82 +1,77 @@
-   1y  gnu/classpath/tools/jar/Creator  gnu/classpath/tools/jar/Action outputStream Ljava/util/jar/JarOutputStream; writtenItems Ljava/util/HashSet; 	Signature 'Ljava/util/HashSet<Ljava/lang/String;>; manifest Ljava/util/jar/Manifest; <init> ()V Code
+   1T  gnu/classpath/tools/jar/Creator  gnu/classpath/tools/jar/Action outputStream Ljava/util/jar/JarOutputStream; writtenItems Ljava/util/HashSet; 	Signature 'Ljava/util/HashSet<Ljava/lang/String;>; manifest Ljava/util/jar/Manifest; <init> ()V Code
       java/util/HashSet
-  	     LineNumberTable LocalVariableTable this !Lgnu/classpath/tools/jar/Creator; copyFile C(Ljava/util/zip/CRC32;Ljava/io/InputStream;Ljava/io/OutputStream;)J 
-Exceptions  java/io/IOException
- ! # " java/io/InputStream $ % read ([B)I
- ' ) ( java/io/OutputStream * + write ([BII)V
- - / . java/util/zip/CRC32 0 + update
- ' 2 3  close crc Ljava/util/zip/CRC32; is Ljava/io/InputStream; output Ljava/io/OutputStream; buffer [B size J len I 	writeFile ,(ZLjava/io/InputStream;Ljava/lang/String;Z)V
-  C D E contains (Ljava/lang/Object;)Z G Creator.Ignoring
- I K J  gnu/classpath/tools/jar/Messages L M 	getString &(Ljava/lang/String;)Ljava/lang/String; O java/lang/Object
- Q S R java/text/MessageFormat T U format 9(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;	 W Y X java/lang/System Z [ err Ljava/io/PrintStream;
- ] _ ^ java/io/PrintStream ` a println (Ljava/lang/String;)V c java/io/ByteArrayOutputStream
- b 
- - 
-  g   i java/util/zip/ZipEntry
- h k  a
- - m n o getValue ()J
- h q r s setCrc (J)V
- h u v s setSize	  x  
- z | { java/util/jar/JarOutputStream } ~ putNextEntry (Ljava/util/zip/ZipEntry;)V
- b    writeTo (Ljava/io/OutputStream;)V
- z    
+  	     LineNumberTable copyFile C(Ljava/util/zip/CRC32;Ljava/io/InputStream;Ljava/io/OutputStream;)J 
+Exceptions  java/io/IOException
+     java/io/InputStream ! " read ([B)I
+ $ & % java/io/OutputStream ' ( write ([BII)V
+ * , + java/util/zip/CRC32 - ( update
+ $ / 0  close 	writeFile ,(ZLjava/io/InputStream;Ljava/lang/String;Z)V
+  4 5 6 contains (Ljava/lang/Object;)Z 8 Creator.Ignoring
+ : < ;  gnu/classpath/tools/jar/Messages = > 	getString &(Ljava/lang/String;)Ljava/lang/String; @ java/lang/Object
+ B D C java/text/MessageFormat E F format 9(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;	 H J I java/lang/System K L err Ljava/io/PrintStream;
+ N P O java/io/PrintStream Q R println (Ljava/lang/String;)V T java/io/ByteArrayOutputStream
+ S 
+ * 
+  X   Z java/util/zip/ZipEntry
+ Y \  R
+ * ^ _ ` getValue ()J
+ Y b c d setCrc (J)V
+ Y f g d setSize	  i  
+ k m l java/util/jar/JarOutputStream n o putNextEntry (Ljava/util/zip/ZipEntry;)V
+ S q r s writeTo (Ljava/io/OutputStream;)V
+ k u v  
 closeEntry
-    E add
- h   o getCompressedSize       d  Creator.Adding
-    java/lang/Long   valueOf (J)Ljava/lang/Long;
- h   o getSize isDirectory Z 	inputFile filename Ljava/lang/String; verbose msg out Ljava/io/ByteArrayOutputStream; entry Ljava/util/zip/ZipEntry; csize perc $(Ljava/io/File;Ljava/lang/String;Z)V
-    java/io/File   ()Z
-    java/lang/String   length ()I
-     charAt (I)C  java/lang/StringBuilder
-     &(Ljava/lang/Object;)Ljava/lang/String;
-  k
-     append (C)Ljava/lang/StringBuilder;
-     toString ()Ljava/lang/String;
-   @ A  java/io/FileInputStream
-     (Ljava/io/File;)V
- ! 2 file Ljava/io/File; inputStream 
-addEntries 7(Ljava/util/ArrayList;Lgnu/classpath/tools/jar/Entry;)V X(Ljava/util/ArrayList<Lgnu/classpath/tools/jar/Entry;>;Lgnu/classpath/tools/jar/Entry;)V	    gnu/classpath/tools/jar/Entry  	     name
-     #(Ljava/io/File;Ljava/lang/String;)V
-    java/util/ArrayList
-     list ()[Ljava/lang/String;
-  
-     -(Ljava/lang/String;)Ljava/lang/StringBuilder;
-     result Ljava/util/ArrayList; Lgnu/classpath/tools/jar/Entry; files [Ljava/lang/String; i LocalVariableTypeTable 6Ljava/util/ArrayList<Lgnu/classpath/tools/jar/Entry;>; getAllEntries 5(Lgnu/classpath/tools/jar/Main;)Ljava/util/ArrayList; V(Lgnu/classpath/tools/jar/Main;)Ljava/util/ArrayList<Lgnu/classpath/tools/jar/Entry;>;
-  	    gnu/classpath/tools/jar/Main   entries
-     iterator ()Ljava/util/Iterator;   java/util/Iterator next ()Ljava/lang/Object;   hasNext 
-parameters Lgnu/classpath/tools/jar/Main; 
-allEntries writeCommandLineEntries !(Lgnu/classpath/tools/jar/Main;)V 	META-INF/ META-INF/MANIFEST.MF
-   	   
-  @  createManifest 8(Lgnu/classpath/tools/jar/Main;)Ljava/util/jar/Manifest;	   wantManifest	   manifestFile java/util/jar/Manifest
-! " (Ljava/io/InputStream;)V
-  contents 7(Lgnu/classpath/tools/jar/Main;Ljava/io/OutputStream;)V
- '	 )  
-+,- getMainAttributes ()Ljava/util/jar/Attributes;	/10 java/util/jar/Attributes$Name23 MANIFEST_VERSION Ljava/util/jar/Attributes$Name;
-576 java/util/jar/Attributes n8 3(Ljava/util/jar/Attributes$Name;)Ljava/lang/String;
-/ ; 1.0
-5=>? putValue 8(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;A 
-Created-ByC java.version
- WEF M getPropertyH  (J java.vendorL )
- zN O 1(Ljava/io/OutputStream;Ljava/util/jar/Manifest;)V	 QR ? storageMode
- zTUV 	setMethod (I)V
- X
- os attr Ljava/util/jar/Attributes;
- z]^  finish
- z 2 run	 bc  archiveFilee -
- gh E equals	 Wj  [
- l
-%n java/io/BufferedOutputStreamp java/io/FileOutputStream
-o 
-ms  
-  2 
+  x y 6 add
+ Y { | ` getCompressedSize       d  Creator.Adding
+    java/lang/Long   valueOf (J)Ljava/lang/Long;
+ Y   ` getSize $(Ljava/io/File;Ljava/lang/String;Z)V
+    java/io/File   isDirectory ()Z
+    java/lang/String   length ()I
+     charAt (I)C  java/lang/StringBuilder
+     &(Ljava/lang/Object;)Ljava/lang/String;
+  \
+     append (C)Ljava/lang/StringBuilder;
+     toString ()Ljava/lang/String;
+   1 2  java/io/FileInputStream
+     (Ljava/io/File;)V
+  / 
+addEntries 7(Ljava/util/ArrayList;Lgnu/classpath/tools/jar/Entry;)V X(Ljava/util/ArrayList<Lgnu/classpath/tools/jar/Entry;>;Lgnu/classpath/tools/jar/Entry;)V	    gnu/classpath/tools/jar/Entry   file Ljava/io/File;	     name Ljava/lang/String;
+     #(Ljava/io/File;Ljava/lang/String;)V
+  x  java/util/ArrayList
+     list ()[Ljava/lang/String;
+  
+     -(Ljava/lang/String;)Ljava/lang/StringBuilder;
+     getAllEntries 5(Lgnu/classpath/tools/jar/Main;)Ljava/util/ArrayList; V(Lgnu/classpath/tools/jar/Main;)Ljava/util/ArrayList<Lgnu/classpath/tools/jar/Entry;>;
+  	    gnu/classpath/tools/jar/Main   entries Ljava/util/ArrayList;
+     iterator ()Ljava/util/Iterator;    java/util/Iterator   next ()Ljava/lang/Object;     hasNext writeCommandLineEntries !(Lgnu/classpath/tools/jar/Main;)V  	META-INF/  META-INF/MANIFEST.MF
+    	     verbose Z
+   1  createManifest 8(Lgnu/classpath/tools/jar/Main;)Ljava/util/jar/Manifest;	     wantManifest	     manifestFile  java/util/jar/Manifest
+     (Ljava/io/InputStream;)V
+   7(Lgnu/classpath/tools/jar/Main;Ljava/io/OutputStream;)V
+   	   
+ 	 getMainAttributes ()Ljava/util/jar/Attributes;	 java/util/jar/Attributes$Name MANIFEST_VERSION Ljava/util/jar/Attributes$Name;
+ java/util/jar/Attributes _ 3(Ljava/util/jar/Attributes$Name;)Ljava/lang/String;
+  1.0
+ putValue 8(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 
+Created-By java.version
+ H!" > getProperty$  (& java.vendor( )
+ k* + 1(Ljava/io/OutputStream;Ljava/util/jar/Manifest;)V	 -./ storageMode I
+ k123 	setMethod (I)V
+ 5  
+ k78  finish
+ k / run	 <=  archiveFile? -
+ AB 6 equals	 HDE L out
+ G I java/io/BufferedOutputStreamK java/io/FileOutputStream
+J 
+HN  s
+  / 
 SourceFile Creator.java InnerClasses Name !                 	    
-               B     * * Y             ;  ?  ;                               ? :	7,  6   a7- &+ ,- 1       .    F  G 
- J  K  L  M # N , O 5 H 8 Q < R    H    ?       ? 4 5    ? 6 7    ? 8 9   8 : ;  
- 5 < =   # > ?   @ A          #     * - B # F H NY-S P: V \ bY d: -Y e: 		7 *, f7 hY- j:		 l p	 t* w	 y* w * w * - W [	 7
-	 		7   
-ime7 H NY-SY SY	  SY S P: V \        !   Y  [  ]  ^  ] " _ * a + d 4 e = g A i G m R p \ q f r m t v u  v  w  y  {  }  ~                                           7              "     4     =  4 5  D  < =  R  < =  \    	  Q  = 
-    =   5  =        @                 T+ 6 2,, d /  Y,  /  M*,   Y+ :*,         & 	          .  :  D  N  S     >    T       T      T      T     N    D   7      	       @ 	    ,   , N-- d / $ Y-  /  N Y, - M+, W,  :6 ;*+ Y Y, 2  Y,   2     	+, W       :     
-      2  ?  E  N  T  j             >                          N I    Q C  ?                 	             1 Y M+  :    N*,-  ,                %  /     *    1       1   )	              )	   
-                K*  W*  W*+M, :    N*- - +                   0  @  J     *    K       K   /	   0           /	                   -+ +  Y+ MY, Y#              	      %          -       -   	$ 7  
-%                z**+&(*(*N-.4 -.9:<W-@ YBD  G ID K  <W* zY,*(M w* w+PS*+W       .     	      )  =  U  Y  i  t  y     *    z       z    zY 9   iZ[   3            A     * w\* w_                            `                =+a +adf *+ik mYoY+aqrM*+,k*t                1  2  8  <          =       =  2 Y 9  u   vw   
- /5x 	
\ No newline at end of file
+               0     * * Y             ;  ?  ;                   ? :	7, 6   a7- #+ )- .       .    F  G 
+ J  K  L  M # N , O 5 H 8 Q < R  1 2               * - 3 # 7 9 ?Y-S A: G M SY U: *Y V: 		7 *, W7 YY- [:		 ] a	 e* h	 j* h p* h t* - wW [	 z7
+	 		7  } }
+ime7 9 ?Y-SY SY	  SY S A: G M        !   Y  [  ]  ^  ] " _ * a + d 4 e = g A i G m R p \ q f r m t v u  v  w  y  {  }  ~                      1                 T+ 6 2,, d /  Y,  /  M*,   Y+ :*,         & 	          .  :  D  N  S      	         	    ,   , N-- d / $ Y-  /  N Y, - M+, W,  :6 ;*+ Y Y, 2  Y,   2     	+, W       :     
+      2  ?  E  N  T  j              	        Y     1 Y M+  :    N*,-   ,                %  /               y     I*  wW*  wW*+ M, :    N*- - +                
+      .  >  H               Y     -+  +   Y+  M Y,  Y               	      %                   **++  S*N-
+ -
+W- Y   # %  '  W* kY,*) h* h+,0*+4       2     	      "  0  D  \  `  p  {     0            /     * h6* h9                :            m     =+; +;>@ *+CF HYJY+;LMM*+,F*O                1  2  8  <  P   QR   
+ S 	
\ No newline at end of file
diff -Naur gcc-4.4.2.orig/libjava/classpath/tools/gnu/classpath/tools/jar/Creator.java gcc-4.4.2/libjava/classpath/tools/gnu/classpath/tools/jar/Creator.java
--- gcc-4.4.2.orig/libjava/classpath/tools/gnu/classpath/tools/jar/Creator.java	2008-10-22 14:19:29.000000000 -0400
+++ gcc-4.4.2/libjava/classpath/tools/gnu/classpath/tools/jar/Creator.java	2009-10-22 11:50:46.239232000 -0400
@@ -216,11 +216,14 @@
     manifest = createManifest(parameters);
     /* If no version is specified, provide the same manifest version default
      * as Sun's jar tool */
-    Attributes attr = manifest.getMainAttributes();
-    if (attr.getValue(Attributes.Name.MANIFEST_VERSION) == null)
-      attr.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
-    attr.putValue("Created-By", System.getProperty("java.version") +
+    if (parameters.wantManifest)
+      {
+	  Attributes attr = manifest.getMainAttributes();
+	  if (attr.getValue(Attributes.Name.MANIFEST_VERSION) == null)
+	      attr.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
+	  attr.putValue("Created-By", System.getProperty("java.version") +
 		  " (" + System.getProperty("java.vendor") + ")");
+      }
     outputStream = new JarOutputStream(os, manifest);
     // FIXME: this sets the method too late for the manifest file.
     outputStream.setMethod(parameters.storageMode);
diff -Naur gcc-4.4.2.orig/libjava/configure gcc-4.4.2/libjava/configure
--- gcc-4.4.2.orig/libjava/configure	2009-10-15 03:55:16.000000000 -0400
+++ gcc-4.4.2/libjava/configure	2009-12-09 13:46:11.298588000 -0500
@@ -459,7 +459,7 @@
 #endif"
 
 ac_subdirs_all="$ac_subdirs_all classpath libltdl"
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os build_libsubdir build_subdir host_subdir target_subdir multi_basedir host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical LN_S mkinstalldirs ANTLR_JAR CREATE_GJDOC_TRUE CREATE_GJDOC_FALSE JAVA_MAINTAINER_MODE_TRUE JAVA_MAINTAINER_MODE_FALSE CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LDFLAGS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE AS ac_ct_AS LD ac_ct_LD AR ac_ct_AR RANLIB ac_ct_RANLIB JAR ZIP UNZIP MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBGCJ_CFLAGS LIBGCJ_CXXFLAGS LIBGCJ_JAVAFLAGS LIBGCJ_LD_SYMBOLIC LIBGCJ_LD_SYMBOLIC_FUNCTIONS LIBGCJDEBUG TOOLKIT XLIB_AWT_TRUE XLIB_AWT_FALSE X_AWT_TRUE X_AWT_FALSE GCJ_FOR_ECJX GCJH host_exeext INCLTDL LIBLTDL DIRLTDL LIBTOOL SED EGREP FGREP GREP DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CPP CPPFLAGS CXXCPP GCJ GCJFLAGS GCJDEPMODE am__fastdepGCJ_TRUE am__fastdepGCJ_FALSE subdirs TESTSUBDIR_TRUE TESTSUBDIR_FALSE ECJ_BUILD_JAR ECJ_JAR BUILD_ECJ1_TRUE BUILD_ECJ1_FALSE INSTALL_ECJ_JAR_TRUE INSTALL_ECJ_JAR_FALSE JAVA_HOME_SET_TRUE JAVA_HOME_SET_FALSE JAVA_HOME SUPPRESS_LIBGCJ_BC_TRUE SUPPRESS_LIBGCJ_BC_FALSE BUILD_LIBGCJ_REDUCED_REFLECTION_TRUE BUILD_LIBGCJ_REDUCED_REFLECTION_FALSE INTERPRETER INTERPRETER_TRUE INTERPRETER_FALSE LIBFFI LIBFFIINCS PLATFORM USING_WIN32_PLATFORM_TRUE USING_WIN32_PLATFORM_FALSE USING_POSIX_PLATFORM_TRUE USING_POSIX_PLATFORM_FALSE USING_DARWIN_CRT_TRUE USING_DARWIN_CRT_FALSE SYSTEMSPEC ZLIBSPEC ZLIBTESTSPEC X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS extra_ldflags_libjava extra_gij_ldflags extra_ldflags LIBSTDCXXSPEC LIBGCJTESTSPEC GCLIBS GCINCS GCDEPS GCSPEC JC1GCSPEC GCTESTSPEC USING_BOEHMGC_TRUE USING_BOEHMGC_FALSE USING_NOGC_TRUE USING_NOGC_FALSE THREADLIBS THREADINCS THREADDEPS THREADSPEC THREADSTARTFILESPEC THREADLDFLAGS THREADCXXFLAGS USING_POSIX_THREADS_TRUE USING_POSIX_THREADS_FALSE USING_WIN32_THREADS_TRUE USING_WIN32_THREADS_FALSE USING_NO_THREADS_TRUE USING_NO_THREADS_FALSE USE_LIBGCJ_BC_TRUE USE_LIBGCJ_BC_FALSE LIBGCJ_SPEC HASH_SYNC_SPEC USING_GCC_TRUE USING_GCC_FALSE LIBICONV LTLIBICONV PKG_CONFIG GTK_CFLAGS GTK_LIBS GLIB_CFLAGS GLIB_LIBS LIBART_CFLAGS LIBART_LIBS CLASSPATH_SEPARATOR ZLIBS SYS_ZLIBS ZINCS DIVIDESPEC CHECKREFSPEC EXCEPTIONSPEC BACKTRACESPEC IEEESPEC NATIVE_TRUE NATIVE_FALSE ENABLE_SHARED_TRUE ENABLE_SHARED_FALSE NEEDS_DATA_START_TRUE NEEDS_DATA_START_FALSE INSTALL_BINARIES_TRUE INSTALL_BINARIES_FALSE GCC_UNWIND_INCLUDE toolexecdir toolexecmainlibdir toolexeclibdir GCJVERSION dbexecdir gcjsubdir gxx_include_dir libstdcxx_incdir PERL SYSDEP_SOURCES ANONVERSCRIPT_TRUE ANONVERSCRIPT_FALSE LD_START_STATIC_SPEC LD_FINISH_STATIC_SPEC here python_mod_dir python_mod_dir_expanded MAKE INSTALL_AOT_RPM_TRUE INSTALL_AOT_RPM_FALSE CREATE_JAVA_HOME_TRUE CREATE_JAVA_HOME_FALSE gcc_suffix JAVA_VERSION BUILD_VERSION JVM_ROOT_DIR JVM_JAR_ROOT_DIR JVM_JAR_DIR JRE_DIR JRE_LNK SDK_LNK SDK_BIN_DIR SDK_LIB_DIR SDK_INCLUDE_DIR JRE_BIN_DIR JRE_LIB_DIR GCJ_BIN_DIR CPU OS LIBDIR LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os build_libsubdir build_subdir host_subdir target_subdir multi_basedir host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical LN_S mkinstalldirs ANTLR_JAR CREATE_GJDOC_TRUE CREATE_GJDOC_FALSE JAVA_MAINTAINER_MODE_TRUE JAVA_MAINTAINER_MODE_FALSE CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LDFLAGS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE AS ac_ct_AS LD ac_ct_LD AR ac_ct_AR RANLIB ac_ct_RANLIB JAR ZIP UNZIP MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBGCJ_CFLAGS LIBGCJ_CXXFLAGS LIBGCJ_JAVAFLAGS LIBGCJ_LD_SYMBOLIC LIBGCJ_LD_SYMBOLIC_FUNCTIONS LIBGCJDEBUG TOOLKIT XLIB_AWT_TRUE XLIB_AWT_FALSE X_AWT_TRUE X_AWT_FALSE GCJ_FOR_ECJX GCJH host_exeext INCLTDL LIBLTDL DIRLTDL LIBTOOL SED EGREP FGREP GREP DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CPP CPPFLAGS CXXCPP GCJ GCJFLAGS GCJDEPMODE am__fastdepGCJ_TRUE am__fastdepGCJ_FALSE subdirs TESTSUBDIR_TRUE TESTSUBDIR_FALSE ECJ_BUILD_JAR ECJ_JAR BUILD_ECJ1_TRUE BUILD_ECJ1_FALSE INSTALL_ECJ_JAR_TRUE INSTALL_ECJ_JAR_FALSE JAVA_HOME_SET_TRUE JAVA_HOME_SET_FALSE JAVA_HOME SUPPRESS_LIBGCJ_BC_TRUE SUPPRESS_LIBGCJ_BC_FALSE BUILD_LIBGCJ_REDUCED_REFLECTION_TRUE BUILD_LIBGCJ_REDUCED_REFLECTION_FALSE INTERPRETER INTERPRETER_TRUE INTERPRETER_FALSE LIBFFI LIBFFIINCS PLATFORM USING_WIN32_PLATFORM_TRUE USING_WIN32_PLATFORM_FALSE USING_POSIX_PLATFORM_TRUE USING_POSIX_PLATFORM_FALSE USING_DARWIN_CRT_TRUE USING_DARWIN_CRT_FALSE SYSTEMSPEC ZLIBSPEC ZLIBTESTSPEC X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS extra_ldflags_libjava extra_ldflags LIBSTDCXXSPEC LIBGCJTESTSPEC GCLIBS GCINCS GCDEPS GCSPEC JC1GCSPEC GCTESTSPEC USING_BOEHMGC_TRUE USING_BOEHMGC_FALSE USING_NOGC_TRUE USING_NOGC_FALSE THREADLIBS THREADINCS THREADDEPS THREADSPEC THREADSTARTFILESPEC THREADLDFLAGS THREADCXXFLAGS USING_POSIX_THREADS_TRUE USING_POSIX_THREADS_FALSE USING_WIN32_THREADS_TRUE USING_WIN32_THREADS_FALSE USING_NO_THREADS_TRUE USING_NO_THREADS_FALSE USE_LIBGCJ_BC_TRUE USE_LIBGCJ_BC_FALSE LIBGCJ_SPEC HASH_SYNC_SPEC USING_GCC_TRUE USING_GCC_FALSE LIBICONV LTLIBICONV PKG_CONFIG GTK_CFLAGS GTK_LIBS GLIB_CFLAGS GLIB_LIBS LIBART_CFLAGS LIBART_LIBS CLASSPATH_SEPARATOR ZLIBS SYS_ZLIBS ZINCS DIVIDESPEC CHECKREFSPEC EXCEPTIONSPEC BACKTRACESPEC IEEESPEC NATIVE_TRUE NATIVE_FALSE ENABLE_SHARED_TRUE ENABLE_SHARED_FALSE NEEDS_DATA_START_TRUE NEEDS_DATA_START_FALSE INSTALL_BINARIES_TRUE INSTALL_BINARIES_FALSE GCC_UNWIND_INCLUDE toolexecdir toolexecmainlibdir toolexeclibdir GCJVERSION dbexecdir gcjsubdir gxx_include_dir libstdcxx_incdir PERL SYSDEP_SOURCES ANONVERSCRIPT_TRUE ANONVERSCRIPT_FALSE LD_START_STATIC_SPEC LD_FINISH_STATIC_SPEC here python_mod_dir python_mod_dir_expanded MAKE INSTALL_AOT_RPM_TRUE INSTALL_AOT_RPM_FALSE CREATE_JAVA_HOME_TRUE CREATE_JAVA_HOME_FALSE gcc_suffix JAVA_VERSION BUILD_VERSION JVM_ROOT_DIR JVM_JAR_ROOT_DIR JVM_JAR_DIR JRE_DIR JRE_LNK SDK_LNK SDK_BIN_DIR SDK_LIB_DIR SDK_INCLUDE_DIR JRE_BIN_DIR JRE_LIB_DIR GCJ_BIN_DIR CPU OS LIBDIR LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -19154,6 +19154,9 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
+    *-*-darwin[912]*)
+      SYSTEMSPEC="-allow_stack_execute"
+    ;;
     *)
       SYSTEMSPEC=
     ;;
@@ -20654,9 +20657,6 @@
     # on Darwin -single_module speeds up loading of the dynamic libraries.
     extra_ldflags_libjava=-Wl,-single_module
     ;;
-*-*-darwin[912]*)
-    extra_gij_ldflags=-Wl,-allow_stack_execute
-    ;;
 arm*linux*eabi)
     # Some of the ARM unwinder code is actually in libstdc++.  We
     # could in principle replicate it in libgcj, but it's better to
@@ -20672,7 +20672,6 @@
 
 
 
-
 # Allow the GC to be disabled.  Can be useful when debugging.
 echo "$as_me:$LINENO: checking for garbage collector to use" >&5
 echo $ECHO_N "checking for garbage collector to use... $ECHO_C" >&6
@@ -29838,7 +29837,6 @@
 s,@X_LIBS@,$X_LIBS,;t t
 s,@X_EXTRA_LIBS@,$X_EXTRA_LIBS,;t t
 s,@extra_ldflags_libjava@,$extra_ldflags_libjava,;t t
-s,@extra_gij_ldflags@,$extra_gij_ldflags,;t t
 s,@extra_ldflags@,$extra_ldflags,;t t
 s,@LIBSTDCXXSPEC@,$LIBSTDCXXSPEC,;t t
 s,@LIBGCJTESTSPEC@,$LIBGCJTESTSPEC,;t t
diff -Naur gcc-4.4.2.orig/libjava/configure.ac gcc-4.4.2/libjava/configure.ac
--- gcc-4.4.2.orig/libjava/configure.ac	2009-04-26 10:24:38.000000000 -0400
+++ gcc-4.4.2/libjava/configure.ac	2009-12-09 13:46:11.298588000 -0500
@@ -846,6 +846,9 @@
         SYSTEMSPEC="-lunicows $SYSTEMSPEC"
       fi
     ;;
+    *-*-darwin[[912]]*)
+      SYSTEMSPEC="-allow_stack_execute"
+    ;;
     *)
       SYSTEMSPEC=
     ;;
@@ -876,9 +879,6 @@
     # on Darwin -single_module speeds up loading of the dynamic libraries.
     extra_ldflags_libjava=-Wl,-single_module
     ;;
-*-*-darwin[[912]]*)
-    extra_gij_ldflags=-Wl,-allow_stack_execute
-    ;;
 arm*linux*eabi)
     # Some of the ARM unwinder code is actually in libstdc++.  We
     # could in principle replicate it in libgcj, but it's better to
@@ -889,7 +889,6 @@
     ;;
 esac
 AC_SUBST(extra_ldflags_libjava)
-AC_SUBST(extra_gij_ldflags)
 AC_SUBST(extra_ldflags)
 AC_SUBST(LIBSTDCXXSPEC)
 
diff -Naur gcc-4.4.2.orig/libjava/gcj/Makefile.in gcc-4.4.2/libjava/gcj/Makefile.in
--- gcc-4.4.2.orig/libjava/gcj/Makefile.in	2009-03-03 12:03:51.000000000 -0500
+++ gcc-4.4.2/libjava/gcj/Makefile.in	2009-12-09 13:46:11.298588000 -0500
@@ -334,7 +334,6 @@
 datadir = @datadir@
 dbexecdir = @dbexecdir@
 exec_prefix = @exec_prefix@
-extra_gij_ldflags = @extra_gij_ldflags@
 extra_ldflags = @extra_ldflags@
 extra_ldflags_libjava = @extra_ldflags_libjava@
 gcc_suffix = @gcc_suffix@
diff -Naur gcc-4.4.2.orig/libjava/include/Makefile.in gcc-4.4.2/libjava/include/Makefile.in
--- gcc-4.4.2.orig/libjava/include/Makefile.in	2009-03-03 12:03:51.000000000 -0500
+++ gcc-4.4.2/libjava/include/Makefile.in	2009-12-09 13:46:11.298588000 -0500
@@ -333,7 +333,6 @@
 datadir = @datadir@
 dbexecdir = @dbexecdir@
 exec_prefix = @exec_prefix@
-extra_gij_ldflags = @extra_gij_ldflags@
 extra_ldflags = @extra_ldflags@
 extra_ldflags_libjava = @extra_ldflags_libjava@
 gcc_suffix = @gcc_suffix@
diff -Naur gcc-4.4.2.orig/libjava/include/posix-threads.h gcc-4.4.2/libjava/include/posix-threads.h
--- gcc-4.4.2.orig/libjava/include/posix-threads.h	2007-05-12 13:37:55.000000000 -0400
+++ gcc-4.4.2/libjava/include/posix-threads.h	2009-11-18 09:10:07.228920000 -0500
@@ -375,13 +375,6 @@
 };
 
 inline void
-ParkHelper::init ()
-{
-  pthread_mutex_init (&mutex, NULL);
-  pthread_cond_init (&cond, NULL);
-}
-
-inline void
 ParkHelper::destroy ()
 {
   pthread_mutex_destroy (&mutex);
diff -Naur gcc-4.4.2.orig/libjava/libltdl/acinclude.m4 gcc-4.4.2/libjava/libltdl/acinclude.m4
--- gcc-4.4.2.orig/libjava/libltdl/acinclude.m4	2006-04-06 15:22:45.000000000 -0400
+++ gcc-4.4.2/libjava/libltdl/acinclude.m4	2009-12-03 18:25:50.085227000 -0500
@@ -1527,7 +1527,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
diff -Naur gcc-4.4.2.orig/libjava/libltdl/configure gcc-4.4.2/libjava/libltdl/configure
--- gcc-4.4.2.orig/libjava/libltdl/configure	2008-06-17 19:13:35.000000000 -0400
+++ gcc-4.4.2/libjava/libltdl/configure	2009-12-03 18:25:50.085227000 -0500
@@ -8628,7 +8628,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
@@ -12426,7 +12426,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
@@ -15707,7 +15707,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
@@ -18193,7 +18193,7 @@
 
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
diff -Naur gcc-4.4.2.orig/libjava/libltdl/ltdl.c gcc-4.4.2/libjava/libltdl/ltdl.c
--- gcc-4.4.2.orig/libjava/libltdl/ltdl.c	2006-03-28 14:02:25.000000000 -0500
+++ gcc-4.4.2/libjava/libltdl/ltdl.c	2009-12-03 18:25:50.085227000 -0500
@@ -2175,7 +2175,8 @@
 static	int	try_dlopen	      LT_PARAMS((lt_dlhandle *handle,
 						 const char *filename));
 static	int	tryall_dlopen	      LT_PARAMS((lt_dlhandle *handle,
-						 const char *filename));
+						 const char *filename,
+						 const char * useloader));
 static	int	unload_deplibs	      LT_PARAMS((lt_dlhandle handle));
 static	int	lt_argz_insert	      LT_PARAMS((char **pargz,
 						 size_t *pargz_len,
@@ -2361,9 +2362,10 @@
 }
 
 static int
-tryall_dlopen (handle, filename)
+tryall_dlopen (handle, filename, useloader)
      lt_dlhandle *handle;
      const char *filename;
+     const char *useloader;
 {
   lt_dlhandle	 cur;
   lt_dlloader   *loader;
@@ -2430,6 +2432,11 @@
 
   while (loader)
     {
+      if (useloader && strcmp(loader->loader_name, useloader))
+	{
+	  loader = loader->next;
+	  continue;
+	}
       lt_user_data data = loader->dlloader_data;
 
       cur->module = loader->module_open (data, filename);
@@ -2499,7 +2506,7 @@
       error += tryall_dlopen_module (handle,
 				     (const char *) 0, prefix, filename);
     }
-  else if (tryall_dlopen (handle, filename) != 0)
+  else if (tryall_dlopen (handle, filename, NULL) != 0)
     {
       ++error;
     }
@@ -2520,7 +2527,7 @@
   /* Try to open the old library first; if it was dlpreopened,
      we want the preopened version of it, even if a dlopenable
      module is available.  */
-  if (old_name && tryall_dlopen (handle, old_name) == 0)
+  if (old_name && tryall_dlopen (handle, old_name, "dlpreload") == 0)
     {
       return 0;
     }
@@ -2784,7 +2791,7 @@
 
   /* Try to dlopen the file, but do not continue searching in any
      case.  */
-  if (tryall_dlopen (handle, filename) != 0)
+  if (tryall_dlopen (handle, filename,NULL) != 0)
     *handle = 0;
 
   return 1;
@@ -3072,7 +3079,7 @@
       /* lt_dlclose()ing yourself is very bad!  Disallow it.  */
       LT_DLSET_FLAG (*phandle, LT_DLRESIDENT_FLAG);
 
-      if (tryall_dlopen (&newhandle, 0) != 0)
+      if (tryall_dlopen (&newhandle, 0, NULL) != 0)
 	{
 	  LT_DLFREE (*phandle);
 	  return 1;
@@ -3194,7 +3201,7 @@
 	    }
 #endif
 	}
-      if (!file)
+      else
 	{
 	  file = fopen (filename, LT_READTEXT_MODE);
 	}
@@ -3378,7 +3385,7 @@
 #endif
 		   )))
 	{
-          if (tryall_dlopen (&newhandle, filename) != 0)
+          if (tryall_dlopen (&newhandle, filename, NULL) != 0)
             {
               newhandle = NULL;
             }
diff -Naur gcc-4.4.2.orig/libjava/Makefile.am gcc-4.4.2/libjava/Makefile.am
--- gcc-4.4.2.orig/libjava/Makefile.am	2009-05-11 04:21:39.000000000 -0400
+++ gcc-4.4.2/libjava/Makefile.am	2009-12-09 13:46:11.298588000 -0500
@@ -865,8 +865,7 @@
 ## need this because we are explicitly using libtool to link using the
 ## `.la' file.
 gij_LDFLAGS = -rpath $(dbexecdir) -rpath $(toolexeclibdir) \
-	-shared-libgcc $(THREADLDFLAGS) $(extra_ldflags) \
-	$(extra_gij_ldflags) 
+	-shared-libgcc $(THREADLDFLAGS) $(extra_ldflags)
 gij_LINK = $(GCJLINK)
 ## See jv_convert_LDADD.
 gij_LDADD = -L$(here)/.libs libgij.la
diff -Naur gcc-4.4.2.orig/libjava/Makefile.in gcc-4.4.2/libjava/Makefile.in
--- gcc-4.4.2.orig/libjava/Makefile.in	2009-10-15 03:55:16.000000000 -0400
+++ gcc-4.4.2/libjava/Makefile.in	2009-12-09 13:46:11.298588000 -0500
@@ -838,7 +838,6 @@
 datadir = @datadir@
 dbexecdir = @dbexecdir@
 exec_prefix = @exec_prefix@
-extra_gij_ldflags = @extra_gij_ldflags@
 extra_ldflags = @extra_ldflags@
 extra_ldflags_libjava = @extra_ldflags_libjava@ $(am__append_8)
 gcc_suffix = @gcc_suffix@
@@ -8354,8 +8353,7 @@
 gc_analyze_DEPENDENCIES = libgcj-tools.la libgcj.la libgcj.spec
 gij_SOURCES = 
 gij_LDFLAGS = -rpath $(dbexecdir) -rpath $(toolexeclibdir) \
-	-shared-libgcc $(THREADLDFLAGS) $(extra_ldflags) \
-	$(extra_gij_ldflags) 
+	-shared-libgcc $(THREADLDFLAGS) $(extra_ldflags)
 
 gij_LINK = $(GCJLINK)
 gij_LDADD = -L$(here)/.libs libgij.la
diff -Naur gcc-4.4.2.orig/libjava/posix-threads.cc gcc-4.4.2/libjava/posix-threads.cc
--- gcc-4.4.2.orig/libjava/posix-threads.cc	2007-05-12 13:37:55.000000000 -0400
+++ gcc-4.4.2/libjava/posix-threads.cc	2009-11-18 09:10:07.228920000 -0500
@@ -359,15 +359,16 @@
   if (compare_and_swap 
       (ptr, Thread::THREAD_PARK_RUNNING, Thread::THREAD_PARK_PERMIT))
     return;
-  
+
   /* If this thread is parked, put it into state RUNNING and send it a
      signal.  */
-  if (compare_and_swap 
+  if (compare_and_swap
       (ptr, Thread::THREAD_PARK_PARKED, Thread::THREAD_PARK_RUNNING))
     {
       pthread_mutex_lock (&mutex);
-      pthread_cond_signal (&cond);
+      int result = pthread_cond_signal (&cond);
       pthread_mutex_unlock (&mutex);
+      JvAssert (result == 0);
     }
 }
 
@@ -380,6 +381,14 @@
   permit = ::java::lang::Thread::THREAD_PARK_DEAD;
 }
 
+void
+ParkHelper::init ()
+{
+  pthread_mutex_init (&mutex, NULL);
+  pthread_cond_init (&cond, NULL);
+  permit = ::java::lang::Thread::THREAD_PARK_RUNNING;
+}
+
 /**
  * Blocks the thread until a matching _Jv_ThreadUnpark() occurs, the
  * thread is interrupted or the optional timeout expires.  If an
@@ -407,32 +416,44 @@
     return;
 
   struct timespec ts;
-  jlong millis = 0, nanos = 0;
 
   if (time)
     {
+      unsigned long long seconds;
+      unsigned long usec;
+
       if (isAbsolute)
 	{
-	  millis = time;
-	  nanos = 0;
+	  ts.tv_sec = time / 1000;
+	  ts.tv_nsec = (time % 1000) * 1000 * 1000;
 	}
       else
 	{
-	  millis = java::lang::System::currentTimeMillis();
-	  nanos = time;
-	}
-
-      if (millis > 0 || nanos > 0)
-	{
 	  // Calculate the abstime corresponding to the timeout.
-	  // Everything is in milliseconds.
-	  //
-	  // We use `unsigned long long' rather than jlong because our
-	  // caller may pass up to Long.MAX_VALUE millis.  This would
-	  // overflow the range of a timespec.
+	  jlong nanos = time;
+	  jlong millis = 0;
 
-	  unsigned long long m = (unsigned long long)millis;
-	  unsigned long long seconds = m / 1000; 
+	  // For better accuracy, should use pthread_condattr_setclock
+	  // and clock_gettime.
+#ifdef HAVE_GETTIMEOFDAY
+	  timeval tv;
+	  gettimeofday (&tv, NULL);
+	  usec = tv.tv_usec;
+	  seconds = tv.tv_sec;
+#else
+	  unsigned long long startTime
+	    = java::lang::System::currentTimeMillis();
+	  seconds = startTime / 1000;
+	  /* Assume we're about half-way through this millisecond.  */
+	  usec = (startTime % 1000) * 1000 + 500;
+#endif
+	  /* These next two statements cannot overflow.  */
+	  usec += nanos / 1000;
+	  usec += (millis % 1000) * 1000;
+	  /* These two statements could overflow only if tv.tv_sec was
+	     insanely large.  */
+	  seconds += millis / 1000;
+	  seconds += usec / 1000000;
 
 	  ts.tv_sec = seconds;
 	  if (ts.tv_sec < 0 || (unsigned long long)ts.tv_sec != seconds)
@@ -442,29 +463,30 @@
 	      millis = nanos = 0;
 	    }
 	  else
-	    {
-	      m %= 1000;
-	      ts.tv_nsec = m * 1000000 + (unsigned long long)nanos;
-	    }
+	    /* This next statement also cannot overflow.  */
+	    ts.tv_nsec = (usec % 1000000) * 1000 + (nanos % 1000);
 	}
     }
-      
+
+  pthread_mutex_lock (&mutex);
   if (compare_and_swap 
       (ptr, Thread::THREAD_PARK_RUNNING, Thread::THREAD_PARK_PARKED))
     {
-      pthread_mutex_lock (&mutex);
-      if (millis == 0 && nanos == 0)
-	pthread_cond_wait (&cond, &mutex);
+      int result = 0;
+
+      if (! time)
+	result = pthread_cond_wait (&cond, &mutex);
       else
-	pthread_cond_timedwait (&cond, &mutex, &ts);
-      pthread_mutex_unlock (&mutex);
-      
+	result = pthread_cond_timedwait (&cond, &mutex, &ts);
+
+      JvAssert (result == 0 || result == ETIMEDOUT);
+
       /* If we were unparked by some other thread, this will already
-	 be in state THREAD_PARK_RUNNING.  If we timed out, we have to
-	 do it ourself.  */
-      compare_and_swap 
-	(ptr, Thread::THREAD_PARK_PARKED, Thread::THREAD_PARK_RUNNING);
+	 be in state THREAD_PARK_RUNNING.  If we timed out or were
+	 interrupted, we have to do it ourself.  */
+      permit = Thread::THREAD_PARK_RUNNING;
     }
+  pthread_mutex_unlock (&mutex);
 }
 
 static void
diff -Naur gcc-4.4.2.orig/libjava/testsuite/Makefile.in gcc-4.4.2/libjava/testsuite/Makefile.in
--- gcc-4.4.2.orig/libjava/testsuite/Makefile.in	2009-03-03 12:03:51.000000000 -0500
+++ gcc-4.4.2/libjava/testsuite/Makefile.in	2009-12-09 13:46:11.298588000 -0500
@@ -322,7 +322,6 @@
 datadir = @datadir@
 dbexecdir = @dbexecdir@
 exec_prefix = @exec_prefix@
-extra_gij_ldflags = @extra_gij_ldflags@
 extra_ldflags = @extra_ldflags@
 extra_ldflags_libjava = @extra_ldflags_libjava@
 gcc_suffix = @gcc_suffix@
diff -Naur gcc-4.4.2.orig/libstdc++-v3/include/bits/atomic_0.h gcc-4.4.2/libstdc++-v3/include/bits/atomic_0.h
--- gcc-4.4.2.orig/libstdc++-v3/include/bits/atomic_0.h	2009-06-24 03:07:49.000000000 -0400
+++ gcc-4.4.2/libstdc++-v3/include/bits/atomic_0.h	2009-10-17 23:30:03.751305000 -0400
@@ -82,14 +82,15 @@
     __r; })
 
   /// atomic_flag
-  struct atomic_flag : private __atomic_flag_base
+  struct atomic_flag : public __atomic_flag_base
   {
     atomic_flag() = default;
     ~atomic_flag() = default;
     atomic_flag(const atomic_flag&) = delete;
     atomic_flag& operator=(const atomic_flag&) = delete;
 
-    atomic_flag(bool __i) { _M_i = __i; } // XXX deleted copy ctor != agg
+    // Conversion to ATOMIC_FLAG_INIT.
+    atomic_flag(bool __i): __atomic_flag_base({ __i }) { }
 
     bool
     test_and_set(memory_order __m = memory_order_seq_cst) volatile;
diff -Naur gcc-4.4.2.orig/libstdc++-v3/include/bits/atomic_2.h gcc-4.4.2/libstdc++-v3/include/bits/atomic_2.h
--- gcc-4.4.2.orig/libstdc++-v3/include/bits/atomic_2.h	2009-06-24 03:07:49.000000000 -0400
+++ gcc-4.4.2/libstdc++-v3/include/bits/atomic_2.h	2009-12-09 17:38:57.322178000 -0500
@@ -44,14 +44,15 @@
 namespace __atomic2
 {
   /// atomic_flag
-  struct atomic_flag : private __atomic_flag_base
+  struct atomic_flag : public __atomic_flag_base
   {
     atomic_flag() = default;
     ~atomic_flag() = default;
     atomic_flag(const atomic_flag&) = delete;
     atomic_flag& operator=(const atomic_flag&) = delete;
 
-    atomic_flag(bool __i) { _M_i = __i; } // XXX deleted copy ctor != agg
+    // Conversion to ATOMIC_FLAG_INIT.
+    atomic_flag(bool __i): __atomic_flag_base({ __i }) { }
 
     bool
     test_and_set(memory_order __m = memory_order_seq_cst) volatile
@@ -107,7 +108,7 @@
 	{
 	  // write_mem_barrier();
 	  _M_i = __v;
-	  if (__m = memory_order_seq_cst)
+	  if (__m == memory_order_seq_cst)
 	    __sync_synchronize();
 	}
     }
@@ -298,7 +299,7 @@
 	  {
 	    // write_mem_barrier();
 	    _M_i = __i;
-	    if (__m = memory_order_seq_cst)
+	    if (__m == memory_order_seq_cst)
 	      __sync_synchronize();
 	  }
       }
diff -Naur gcc-4.4.2.orig/libstdc++-v3/include/c_compatibility/stdatomic.h gcc-4.4.2/libstdc++-v3/include/c_compatibility/stdatomic.h
--- gcc-4.4.2.orig/libstdc++-v3/include/c_compatibility/stdatomic.h	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libstdc++-v3/include/c_compatibility/stdatomic.h	2009-10-17 23:30:03.751305000 -0400
@@ -186,8 +186,11 @@
 _GLIBCXX_END_EXTERN_C
 _GLIBCXX_END_NAMESPACE
 
-// Inject into global namespace. XXX
-#if defined(__cplusplus) && !defined(_GLIBCXX_STDATOMIC)
+// Inject into global namespace.
+#ifdef __cplusplus
+
+#include <cstdatomic>
+
 using std::memory_order;
 using std::memory_order_relaxed;
 using std::memory_order_consume;
diff -Naur gcc-4.4.2.orig/libstdc++-v3/include/parallel/multiseq_selection.h gcc-4.4.2/libstdc++-v3/include/parallel/multiseq_selection.h
--- gcc-4.4.2.orig/libstdc++-v3/include/parallel/multiseq_selection.h	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libstdc++-v3/include/parallel/multiseq_selection.h	2009-10-28 06:04:35.010946000 -0400
@@ -183,9 +183,6 @@
       // equality iff nmax = 2^k - 1.
       l = (1ULL << r) - 1;
 
-      // From now on, including padding.
-      N = l * m;
-
       for (int i = 0; i < m; i++)
 	{
 	  a[i] = 0;
@@ -210,7 +207,7 @@
 	if (n >= ns[i])	//sequence too short, conceptual infinity
 	  sample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));
 
-      difference_type localrank = rank * m / N ;
+      difference_type localrank = rank / l;
 
       int j;
       for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); ++j)
@@ -258,15 +255,11 @@
 		b[i] -= n + 1;
 	    }
 
-	  difference_type leftsize = 0, total = 0;
+	  difference_type leftsize = 0;
 	  for (int i = 0; i < m; i++)
-	    {
 	      leftsize += a[i] / (n + 1);
-	      total += l / (n + 1);
-	    }
 	  
-	  difference_type skew = static_cast<difference_type>
-	    (static_cast<uint64>(total) * rank / N - leftsize);
+	  difference_type skew = rank / (n + 1) - leftsize;
 
 	  if (skew > 0)
 	    {
@@ -429,9 +422,6 @@
       // equality iff nmax = 2^k - 1
       l = pow2(r) - 1;
 
-      // From now on, including padding.
-      N = l * m;
-
       for (int i = 0; i < m; ++i)
 	{
 	  a[i] = 0;
@@ -458,7 +448,7 @@
 	if (n >= ns[i])
 	  sample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));
 
-      difference_type localrank = rank * m / N ;
+      difference_type localrank = rank / l;
 
       int j;
       for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); ++j)
@@ -496,15 +486,11 @@
 		b[i] -= n + 1;
 	    }
 
-	  difference_type leftsize = 0, total = 0;
+	  difference_type leftsize = 0;
 	  for (int i = 0; i < m; ++i)
-	    {
 	      leftsize += a[i] / (n + 1);
-	      total += l / (n + 1);
-	    }
 
-	  difference_type skew = ((unsigned long long)total * rank / N
-				  - leftsize);
+	  difference_type skew = rank / (n + 1) - leftsize;
 
 	  if (skew > 0)
 	    {
diff -Naur gcc-4.4.2.orig/libstdc++-v3/include/parallel/partition.h gcc-4.4.2/libstdc++-v3/include/parallel/partition.h
--- gcc-4.4.2.orig/libstdc++-v3/include/parallel/partition.h	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libstdc++-v3/include/parallel/partition.h	2009-11-19 11:44:33.146114000 -0500
@@ -72,7 +72,7 @@
 
     bool* reserved_left = NULL, * reserved_right = NULL;
 
-    difference_type chunk_size;
+    difference_type chunk_size = __s.partition_chunk_size;
 
     omp_lock_t result_lock;
     omp_init_lock(&result_lock);
@@ -339,15 +339,16 @@
     RandomAccessIterator split;
     random_number rng;
 
-    difference_type minimum_length =
-      std::max<difference_type>(2, _Settings::get().partition_minimal_n);
+    const _Settings& __s = _Settings::get();
+    difference_type minimum_length = std::max<difference_type>(2,
+        std::max(__s.nth_element_minimal_n, __s.partition_minimal_n));
 
     // Break if input range to small.
     while (static_cast<sequence_index_t>(end - begin) >= minimum_length)
       {
         difference_type n = end - begin;
 
-        RandomAccessIterator pivot_pos = begin +  rng(n);
+        RandomAccessIterator pivot_pos = begin + rng(n);
 
         // Swap pivot_pos value to end.
         if (pivot_pos != (end - 1))
@@ -404,7 +405,7 @@
       }
 
     // Only at most _Settings::partition_minimal_n elements left.
-    __gnu_sequential::sort(begin, end, comp);
+    __gnu_sequential::nth_element(begin, nth, end, comp);
   }
 
 /** @brief Parallel implementation of std::partial_sort().
diff -Naur gcc-4.4.2.orig/libstdc++-v3/src/atomic.cc gcc-4.4.2/libstdc++-v3/src/atomic.cc
--- gcc-4.4.2.orig/libstdc++-v3/src/atomic.cc	2009-04-09 19:23:07.000000000 -0400
+++ gcc-4.4.2/libstdc++-v3/src/atomic.cc	2009-10-17 23:30:03.751305000 -0400
@@ -80,16 +80,16 @@
     atomic_flag_test_and_set_explicit(volatile __atomic_flag_base* __a,
 				      memory_order __m)
     {
-      volatile atomic_flag d(__a->_M_i);
-      return d.test_and_set(__m);
+      volatile atomic_flag* d = static_cast<volatile atomic_flag*>(__a);
+      return d->test_and_set(__m);
     }
 
     void
     atomic_flag_clear_explicit(volatile __atomic_flag_base* __a,
 			       memory_order __m)
     {
-      volatile atomic_flag d(__a->_M_i);
-      return d.clear(__m);
+      volatile atomic_flag* d = static_cast<volatile atomic_flag*>(__a);
+      return d->clear(__m);
     }
 
     void
diff -Naur gcc-4.4.2.orig/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.c gcc-4.4.2/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.c
--- gcc-4.4.2.orig/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.c	2009-10-17 23:30:03.751305000 -0400
@@ -0,0 +1,34 @@
+// { dg-options "-x c -shared-libgcc -lstdc++" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <cassert>
+#include <stdatomic.h>
+
+// libstdc++/40826
+// libstdc++/40654
+int main()
+{
+  atomic_flag f = ATOMIC_FLAG_INIT;
+
+  atomic_flag_clear(&f); // set to false
+  assert( false == atomic_flag_test_and_set(&f) ); // return previous false, set to true
+  assert( true == atomic_flag_test_and_set(&f) ); // return true
+
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc gcc-4.4.2/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc
--- gcc-4.4.2.orig/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/libstdc++-v3/testsuite/29_atomics/atomic_flag/clear/1.cc	2009-10-17 23:30:03.751305000 -0400
@@ -0,0 +1,33 @@
+// { dg-options "-std=gnu++0x" }
+
+// Copyright (C) 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <cstdatomic>
+#include <testsuite_hooks.h>
+
+int main()
+{
+  bool test __attribute__((unused)) = true;
+  std::atomic_flag f = ATOMIC_FLAG_INIT;
+
+  f.clear(); // set to false
+  VERIFY( false == f.test_and_set() ); // return previous false, set to true
+  VERIFY( true == f.test_and_set() ); // return true
+
+  return 0;
+}
diff -Naur gcc-4.4.2.orig/libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/1.cc gcc-4.4.2/libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/1.cc
--- gcc-4.4.2.orig/libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/1.cc	1969-12-31 19:00:00.000000000 -0500
+++ gcc-4.4.2/libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/1.cc	2009-10-17 23:30:03.751305000 -0400
@@ -0,0 +1,27 @@
+// { dg-options "-std=gnu++0x" }
+// { dg-do compile }
+
+// Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <stdatomic.h>
+
+void test01()
+{
+  using namespace std;
+  atomic_flag af = ATOMIC_FLAG_INIT;
+}
