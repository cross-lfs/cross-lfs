Submitted By: William Harrington (kb0iic at cross-lfs dot org)
Date: 2014-10-10
Initial Package Version: 7.4
Origin: Upstream
Upstream Status: Applied
Description: Contains all upstream patches up to 7.4.473.

diff -Naur vim74.orig/.hg_archival.txt vim74/.hg_archival.txt
--- vim74.orig/.hg_archival.txt	1970-01-01 00:00:00.000000000 +0000
+++ vim74/.hg_archival.txt	2014-10-10 14:53:39.498726059 +0000
@@ -0,0 +1,5 @@
+repo: 770908d1cb47c04be0aef5c173b17ab8be6b6476
+node: 48540909aba2d69507c751138ff234087ee62d9e
+branch: default
+latesttag: v7-4-473
+latesttagdistance: 1
diff -Naur vim74.orig/.hgignore vim74/.hgignore
--- vim74.orig/.hgignore	1970-01-01 00:00:00.000000000 +0000
+++ vim74/.hgignore	2014-10-10 14:53:39.532059309 +0000
@@ -0,0 +1,75 @@
+syntax: glob
+
+# Unixen: object and executable files.
+*.o
+src/vim
+src/xxd/xxd
+src/auto/if_perl.c
+src/tags
+
+# We do need src/auto/configure.
+src/auto/config.aap
+src/auto/config.cache
+src/auto/config.h
+src/auto/config.log
+src/auto/config.mk
+src/auto/config.status
+src/auto/configure.aap
+src/auto/osdef.h
+src/auto/link.log
+src/auto/link.sed
+src/auto/pathdef.c
+
+# Windows
+*.exe
+*.idb
+*.manifest
+*.exp
+*.obj
+*.pdb
+*.ilk
+*.sln
+*.suo
+*.res
+*.RES
+src/if_perl.c
+src/pathdef.c
+src/Obj*/pathdef.c
+gvimext.dll
+gvimext.lib
+
+# Borland C++
+bcc.cfg
+*.ilc
+*.ild
+*.ilf
+*.ils
+*.map
+*.tds
+
+# NetBeans
+nbproject/*
+
+# Mac OSX
+src/xxd/xxd.dSYM
+
+# All platforms
+*.rej
+*.orig
+*.mo
+*.swp
+*~
+*.pyc
+*.log
+src/po/vim.pot
+
+# Generated by "make test"
+src/po/*.ck
+src/testdir/mbyte.vim
+src/testdir/mzscheme.vim
+src/testdir/lua.vim
+src/testdir/small.vim
+src/testdir/tiny.vim
+src/testdir/test*.out
+src/testdir/test.log
+src/memfile_test
diff -Naur vim74.orig/.hgtags vim74/.hgtags
--- vim74.orig/.hgtags	1970-01-01 00:00:00.000000000 +0000
+++ vim74/.hgtags	2014-10-10 14:53:39.545392609 +0000
@@ -0,0 +1,3198 @@
+004eb98eb3c30714cb6a24ec3e810275080a8413 v7-1-117
+006e9c8a6a8ad354a5cb6adcce6ebfceddeb20ee v7-0079
+010397e1770eec8ff399cfc3bbd79f853849ffc1 v7-0160
+0137e7c3d31b09f1c1e494405f3f99f6423b74cd v7-0196
+0139403c8eb088d58773f7e76dc2a025719a8e8c v7-3-135
+01583c79d5f4d3f29d4c33dd10dd29efd349cad0 v7-0d03
+01762f635babb0fecb3a9f04549a54e86f67cf8b v7-1-047
+01a0da54773eb2af0215762629db5c6eed01ba06 v7-1-138
+021f9d0f60a1700989e2deeab78da32837c1041b v7-2-079
+028158b1362b55a23cc6d8d086976c4dfd6e094a v7-0090
+033e7b49356c11b2d9cc45dec6dc3d695d7ef95a v7-3-083
+0358abf2b5d4ab5981a5a1dd651ecf63d40ffbfb v7-1-315
+03714c67a82b8557cb8ee0789cbced75d804d949 v7-2-134
+039ce9407934bd97142aab06c5d1869d8e2ba3c7 v7-0-032
+03b3684919e3299ff560609c0c5f577822f64614 v7-0084
+03c191181749e422b375fbb8cd0763dede7d9beb v7-2-313
+03c4ceec6bec956646c07390aa09052cf5f0468f v7-0-054
+03d49a7c83196a406cbd12f4898fc988731af927 v7-3-010
+03ec0f2b9a403b1cbc494eac6c038076ece0b37c v7-1-242
+04265ffbda1f9b14729bc5d85069ff0711ce3744 v7-1-210
+044d5e9b1292f694e73ae929eeceaa9685fa0580 v7-2-194
+04613e770ec0bd536f04c0fb6d80b76e1af1d6e4 v7-2-189
+048f26eb43a348e49fc4f9deaca03779c2de595e v7-1-082
+04943f31135747da59cbed2b39fb109dd2796426 v7-0-165
+04fc2a0e98ed7af6ee11a2025d6a0c877114c039 v7-2-057
+057029bf347002408541ec73da1373ae64002a3f v7-2-338
+05952d133506353938f50f0b22b0097b6cdf0afd v7-2-095
+05b48b16b627b63ee0f6dda7d7f07704c3d2fe64 v7-1-198
+05c8ff7f128406d2d6052abbf5b92635d3cb0284 v7-2-162
+05dc93b9c61f63c1691849fe7407c9472a7f6288 v7-0208
+0606065af0a02f79b43b4a89383b04c21e2f0be3 v7-3-111
+062104a823df0f5a225b327b00a3766e41e4610f v7-2-201
+06234af3a8b7df68bfaf0efa87edfed2d743f6c7 v7-0106
+06317850ad3acd03765fc0f8002f17417773d906 v7-2-045
+066778e39c2ae6bbf23708d98e1a7a7e53a9a6d0 v7-1-232
+0670d0df210a891f82d38c38f1b3b256dd1a5f8d v7-2-017
+0691866e6cc92996f4fbc881e134248571ae7c82 v7-1-180
+06959e7212e521904f3b7d75bac5005b9f44bde3 v7-0-077
+06aa43dde5610dff598940ccde1dd25a617a1a52 v7-3-006
+06bc859d1a32de8763e310669d0c008b3945af1c v7-0049
+06e0f7482cef3412ecb4b0b62b65b1e7c4ed92b2 v7-1-052
+071166147fc55311bb86bc9367aca005c4a1447c v7-2-299
+0713c530729ba6d2bdc9fdb4fd400f46b16c37be v7-1-169
+073f98f45a447a137c2e2d74f936a9e26179ce1b v7-0-035
+077c15286de8e37250ed1337a448c740c86ee740 v7-2-293
+07d199fe02ed46fff935b2daa4efc979eacaab4c v7-0209
+07de57cbcb25d63bf515b67de654dd89004888fa v7-2-327
+08012a1ff8d4b4f5736a47440a907ec6e5e1610d v7-0137
+0836531167ab2f1cd48382b093c3080c3bc47786 v7-2-059
+0868e4e53fb2e9f9bd469fae0323a1df43be476b v7-1-029
+0887e8a13e5f33db2f832a52654a0d1fa82f322f v7-3-109
+09cc86b6665358a20d9faf54ce8eec45ca4fc5de v7-2-387
+09d0e83c29b805f127c6756231bb4adfb1b2974c v7-0-130
+09f00d57222b6d8de104660ea3f9c6bb42b9d31a v7-2-172
+09fcdfde9afca8990c086e60fe5e122cb258cadc v7-0-046
+0a1d45e2d8e30fc0aef25d5fd7505840d1e0e836 v7-2-258
+0a60be12e47e322c4dbae7b083321c60f599c0b8 v7-0125
+0a80dc6d78048478d4e7f0f99f573c947d5d95c0 v7-1-131
+0a908b65de1dbebbde1aacfd50aa41ef09e6865e v7-2b-012
+0a9371c70540d0d42c79a1d76e590fa2ccb978b3 v7-0220
+0b056c1350dd2ff28249130194d9a2be7b606a86 v7-0-193
+0b1b7560c456a32ad921e3985b90008ef1f82a91 v7-0174
+0b211ebefd4e6ee52ae81a75938b4ee61ca15770 v7-0-071
+0b42546f036bb3ff8023b6015a5acf032a2ae1f1 v7-2-076
+0b4a515b125474db496caa0be22a28e8bd99c88e v7-3-132
+0b796e045c429253e9ce8825ad05aad2474553bd v7-2b-000
+0c0a2b25d10aaaf556344d7404d12aba81632cf4 v7-0-015
+0c381fb7846cda92fbdb327bbfe4ab1f73a86d8d v7-0214
+0c39ff7a90a81c62f2718f71bf0a4d636a8ac69c v7-3-127
+0c4a465bd7419d51017354b70ead01c18b589e9d v7-2b-029
+0c61c201ba76d7235913010395e065991ac059b9 v7-1-196
+0c6c64edcbe0481659fdd91f6312296e7c1bb303 v7-2-052
+0c7d6d01e0582b54f34ab66852116d559c39550c v7-3-101
+0d0bf7598dcb63fdb5be9300f407e043102ab895 v7-1-256
+0d31f8a78ab35b256359b6ae53c80cecce59d44c v7-0-143
+0d6554dfc71e5e58866ef0118ed05007a4c59672 v7-0061
+0dbc46d14443418020e3868a08877a365ced11e1 v7-2b-028
+0de47f0d731e32af52784171986734b735ac626f v7-3-051
+0e3bd80a3f74a99241a4857685912dc8efeb9bdf v7-1-286
+0e3e208b4b901f22beecc85c5781170f3c4e5351 v7-0-104
+0e3e601e66cf233986924652f7801dc8d2568a84 v7-1-288
+0e45a0c50acaa31dd4052c57053bb86afd4e711e v7-2-154
+0e4631bf94411717193870a5ad7d62945d06cadc v7-2-377
+0e4c64dfc61141a68b83b5204a160b5c01986279 v7-2-125
+0e4fa55d20e025a70e3e6b82abc58333902c45db v7-2-040
+0e57be57fa49a0d2c0b7f17b7cb137b4260b79d6 v7-0-207
+0e5eb96dc18ce7986eadf32bb700e503da52ae47 v7-1-142
+0e6b369b9760459289b84a9c2e07478c063cd386 v7-1-126
+0e902b8f511f0442ee2b28314d6e085e3e00798e v7-0051
+0eef0f62181190700a01129a88f693503ae94947 v7-2a-006
+0ef5b70c3eaf694c9e9b85aed3f80af53e6fd9cf v7-0045
+0ef9cebc4f5d1c00554543918fea2a0b7539b922 v7-0031
+0f109c56b521834af0d9492b21d0ef1ead5b01ef v7-2-014
+0f3f3090491faea043fa144780d1287e011390ac v7-1-205
+0f552ca271c27681ed126261ce49e52ef144175e v7-2-393
+0f9f4761ad9cafbf1e72de338aa3fc59f1dd693d v7-0216
+1002128c68dbe2f69466b1b2cb354b00eec2980b v7-1-109
+103dea6545430092db1851d1b712a742af1a74f2 v7-3-017
+10a1b67c0885aabdac7c76a96169cd9e36414428 v7-1-068
+10ce04af8c5b26e55cd2157408883d9ed79b9a3d v7-3-021
+10d7ebdbe8a3a9787360b21a9836c6bae6a6a7a2 v7-0-169
+11155435487064d64efb296f7c2966baae8d27e3 v7-2-402
+111e109dad1301c7699d18e5689f1842f4b67e6c v7-0b01
+11472bbcdb6e2effe1c248d09b4d7089fa7a26d2 v7-2-183
+11a74d2cab9dbe41af2ed5d08b18fbdac14f6e43 v7-2-147
+11c004cc1a4df89b9246a96106db6c6f0260b7d8 v7-0-241
+11c6bda3b53abb2c98ed9221ba89880eeef7514f v7-2-268
+125e80798a85dbead9a91815cabd1d0aed63f455 v7-0021
+1287e2bbeb405c10201d4caa6b2dab284f84efbf v7-2-207
+12aba62fa7c6812ec46eb3be6759d82a4a651a93 v7-2-422
+12f9cd68b9c3aaf3659d9219551a5822cf798857 v7-1-257
+131dbd3d2a4bba5d1514c2842952ca7b77b6902e v7-2a-019
+1324b7b755f3b5570ce9aa7fb27c075c89a1d2df v7-1-322
+134c7695af324bd4118f52b9235aeff7e374a425 v7-2-121
+1378bc45ebe5754c0d3ec64d37810eaad3a544f3 v7-2-348
+144ad7f25f6741815c8297fe77965f93ee359c2a v7-0-118
+15130d4dfea14898029686b72536f54197a73062 v7-2-117
+15146eaa0e9c6dd6802cf70a2da3b220992eda1e v7-0-001
+15154710ed57eab29f7e4b848eafe63ea2dfdf85 v7-1-140
+151a805b2ddc219d4a968154a43daefbb2e41fe1 v7-1-081
+152883db0edf63f35e8459dcc5862ef3f4b48c9e v7-1-321
+152e526245217fedd07f0480e08ea59b0075a8b0 v7-1-001
+15674e198164c10b08e138f4c18b58e76306d9be v7-2-389
+158a68529622f90d0b0f1f5596f55cc5ce06c9ee v7-2-060
+159d87361e4b0d99c3863b3c82b7121a474cdf1f v7-1-168
+15e847397be75c6b0590505a9e201c793d070eee v7-2-205
+165c628aa9fc3cca34ccf63dc8ab953745d4e228 v7-0108
+169533a9699fa7d3fd67b57ad99d04076d060831 v7-0g02
+17526daaf79dbf2004c78311abdad05e6e3070dc v7-2b-021
+1780e6046802498a3c4d0ddc7b99f1bd9ac75f31 v7-0-157
+17a83c0532e83e9f4cd89f03dcbf206662d25b1f v7-1-062
+17b9587ff6d5beef34d98043ca5f3111e5d29e4d v7-0-202
+17b96d8dcc5c8356e10135f5735d6de2fa5da3e8 v7-2-038
+17c88d44ace9bc9e76485811ffa459b5c15a6bb7 v7-1-234
+18061514324fefb37ea7a7e7783985004ea0874d v7-3-084
+183c3187b20dbc6ecc74958e9ba141f0d4f72d23 v7-0-205
+184a6091124e80e1c9f66ed0908deab552ca369c v7-1-220
+184d2020d8f12823a2f2cb96335a68ac1bda3270 v7-1a-001
+18ee39301b822de39caf5fa023107ddf508b42e0 v7-2a
+18f024844150562a9e56522edcad3fc1d5c257e4 v7-0086
+19106f131c872dc79bb409ffe8b5e35ebe885c1b v7-0188
+196d564759eb256f62e7fb7ec4561c1e2d533726 v7-2-072
+198a695ca8e7273641991bcf346085bbce70d740 v7-1b-001
+198ea7a9c633089ef2638513d05611a9d1b6e39c v7-1-182
+19ed3bfbe488a730858d0d26b433029b85e231cd v7-0-159
+19ef2bbf569cba64ae5125d5b1f3f205efc25e89 v7-1-263
+1a00e831244b1e509286ea35a586c6c43dcdaaaa v7-2-202
+1a040c25c44485c85e838a7530051f6d4f9793a2 v7-2-123
+1a0d346695fa3525a08a27174fbdf016afdbb9a9 v7-3-085
+1a44839049aefb0722d43a87d7ed1708c9c94b18 v7-0229
+1a511b7b69ebdf866088b9e765dc42543cd76d0a v7-0-212
+1a85f952cdfe4716be162e308fbccb0117489915 v7-0195
+1a8b518bb993e00f546c4cef8bae9b51f91fe0d7 v7-2-198
+1aba098d6abc680214b3b31c954abd53ddc772ef v7-0-039
+1b55bbf5c58077e54b83307bbe715e131c57b750 v7-1-219
+1b7cac059babfb3365c0a44c0537c7aa9b286a71 v7-0172
+1baac9d06c83400c474e6484dc20229187d27a64 v7-3-024
+1bb06e6512a2fc961eaf9a8e7a749247c408e7f6 v7-2-358
+1bc46149d9195d9134d526ef524242ede65c2457 v7-1-167
+1bdb13b8e947b85e612afec3a1b5e09c29c30551 v7-2-039
+1c00ea3641a8a1e58e70cd51ab831003bdb41d50 v7-3-005
+1c1cbdc42f75d8fa0ca5a799b5e843e9aa2c098c v7-0077
+1c4ec9ed71caf24dbec13f6d3d4adbb48bce9436 v7-3-056
+1c586ee8dd452d305bebf633d5b8c78ba1ab170d v7-0183
+1c597397f0061fd2c750c65c961a31f70dd6747f v7-1-269
+1c64bf25bbcd49a83cc08dd60a6c3e5785266790 v7-2-247
+1c7a66d820e4dc9b0a9f696ed6e7a59cd9a20e19 v7-2-360
+1c85355293f92cd8bb41eaf6ce8a8be1d77302f1 v7-2-062
+1ccc1ace9e5b6c1223ba191ce20729a49f13970e v7-3-050
+1cdd2661f34c2aa93ae2f0317194d29d3a43f5be v7-0d01
+1d0ef79659afec337c26655216a1debbd1c74497 v7-0-002
+1d12208efb3732d6f520b05a47283208f12e3856 v7-0-209
+1d4c67f8470981d280aaf1d2a25877a00ec5d240 v7-1-084
+1d6d99daf4dcba733e5517045f70e53c185aa895 v7-1-165
+1d7f46148bf4ec36a42e959cece1f9f6199a87a7 v7-2b-006
+1da25369227bead09cf603ebfa93ebe1d206c871 v7-2-345
+1dd4e0ccd822156b87516f9cd5a6a004d0d85a11 v7-1-278
+1ddec6983d9ebdb4f7a748cc171199cc8ad3d1e0 v7-2-036
+1de53700b1d9f26a420a319d9c44ba0c43950035 v7-0-127
+1df41c98fc2e9a230ab9d05be84f4c91e4078619 v7-0-239
+1dfe9032bd92ef7ab7bf0baf0f0c1f61da68bce6 v7-0-131
+1e25b58fbf7babbbe054e118617a49790f532fd4 v7-2-024
+1e52efdc900cab1dd64f6a987bbe5117fa1f9748 v7-2-270
+1ee00a062acbd04360de8b754e834f7ef6025328 v7-2-246
+1f099ff4f6fb2b0731bb38e279d0c692ee05df8d v7-1-129
+1f3902f3eb5c20e7872c42cdee9c91e2b25d3f47 v7-0038
+1f3b1021f002ac9703c1de0e80703b8067546a41 v7-0e05
+1f53050b38688e127c4ea67251ab2730002541bd v7-2-294
+1f90fab89ce32126849aa28d2918bae96603f3bd v7-2-069
+1f929f3ca8066b3170c7a58c414837d47bef707e v7-0c03
+1f93fbcb4e0cf1dcd8682242f40aa5f2906c42ac v7-1-201
+1f9e2c8e642a29d93b9c32062c785f4c38883e0c v7-1-034
+1fbbe04a950f9ed82b53ddf67d8e034224fc98ad v7-2-286
+1fc8d918d9fc076304ef0dbaad897e8e5b6ba4ab v7-2-093
+200b706675a56daad05f8b0d60991825c45b6e2d v7-1-183
+20308f30826db09e99d531214eaaf03ea8b13d15 v7-0-162
+205a26fab11655d086ce185525193d16f37d60b5 v7-1-203
+20b2e52ca96255a8d99ed9504e90a960266c4d21 v7-2-009
+20b4b6a2a212584f182a2d69a37512bf9094d85e v7-1-279
+20b52d44daafbd65b01db735c4d5597ccb9e386d v7-1-130
+20c18291deb21dcc69b6ceb3c11c309a92396fb4 v7-2-302
+20d9fc2f13a4132d6344fb6457040b02720774cf v7-2-403
+215d6b2a1816a5eaf5f5d2cb7cb1b22d24adbdab v7-1-159
+217c9aa4c3ba6ea559ec5675871d6d89313363e8 v7-2-114
+21b11491a33fee3cd77dcfcc2448382f060543f2 v7-1-156
+21c3634c211345ea79e90c4927513e7dc1381617 v7-0134
+21ce954cbdcac9dea2aa826ff40adc2fb2184600 v7-0-201
+220a9309067dfc6e7e8301b392c3499054666396 v7-1-266
+2244be18d9e9ce602a12e7529614c25ca8cef1ee v7-0162
+22886f3d882d231a528dcc012c23e54180c8248c v7-1-040
+232a4740aa0ed615c52b289a111b51171e74a78f v7-0-005
+2392a6da4aa430f896451d97da8c49ed3fcdb9cb v7-0186
+23aeaff961412f06544babde36a80a6c22be0fd9 v7-1-307
+23d23246742e7d301d09f0cb03533226b64043b4 v7-0-219
+23d366df193868572eacd04e1a32bc2283a30e56 v7-2-335
+23f82b5d2814be7ca4dee000226bd67dc6cd02cf v7-0c10
+24100651daa9d7140d33f298c987c9d42bd919bf v7-2-411
+2430fc9a18d1270a5ad7b5f7acac3e19aa8908fb v7-1-306
+2448f4c8afc65a91130fa0237c253e6698481c64 v7-0-055
+24b7b3cc4eec4387713a615519489fa5a34b253d v7-1-251
+24eb7921b8f004c8c462297cf53afad8f5578243 v7-2-367
+251307ebe1dbacd972e35e923f7360d12733f2b7 v7-1-049
+25154b22dc967b158645be9cb87017f548ee5446 v7-0-198
+2548cf0a5f625110a5cd42ee5566c2709c2c34f0 v7-0-011
+25bc02d83cf438d5794ce106edad2959e2f89454 v7-1-292
+25dd5036f2b0b5e68492c49f15eaa228aa957f69 v7-0092
+2651e7d07cd631af64818f5d3cf5dbb199fa6f64 v7-0-140
+266f9d9f5109421afcbc8169896b484ff7a19a8d v7-3-061
+26876d0f15e9294aa4fcbfc43260a5f2a703e313 v7-2-256
+26b0b2f606d2953068951dca673d963b7c5cccb7 v7-1-122
+26cbd39f22513d82cc43d2b1badefcea8db1c546 v7-1-103
+26d879bcab3aa016ccaf77cfd3a9aa5085d4776e v7-1-284
+26fb122355d4d6b04850f7608f1d82da8dbc51c7 v7-3-107
+26ff011aec2dbc96736396430403d572d4f111d5 v7-0-172
+27060fe297d0ce872dfa3bc20416f7189b9fbc59 v7-2-273
+2750661e93d556868d97f49fae32a1f470bca107 v7-1-253
+27621abffed24f1e2849ea616f91f0a99747608f v7-3-099
+276244befa5b2a34893ba581818df14cd7e4504e v7-1-189
+2775dcd056031e0a7314da9a9e0b2cebbb089525 v7-2-426
+27782797c331b8800c12ad17c5d05adab5e92edb v7-1-107
+2787b8483e6498f536e66ac134a073246ab6f5e4 v7-0-125
+279380a812add1307a2a20c444f2334b7a45106d v7-2-412
+27d8fe1c096407ddca428c52f62d002dfed7879f v7-2-090
+2832243e801ec537589809059f65efb3b8a57f93 v7-2-399
+28398206597f975583c9f8f212d336fc9f67953f v7-3-089
+28558ab31051fc1870ac690c0b576ca9365021f5 v7-1-202
+28641f0ed9deb579934416e6161260d4d218f394 v7-2-211
+288fb648badba86a0bdce6dbcecb55eb386263ab v7-2-128
+289b19a6f2edb5b46df57195d5fae41dfe963290 v7-0103
+28d0c20ad8a09dd63fa34768eac4be3cf96ed239 v7-2-051
+28e9eb0f2d849e7e32d70b4e1f06dad812288578 v7-2-077
+2928a6b338c3f434723520a12fa378895d4b24cf v7-2-187
+2930fd8e7d9f1514448261365b787501dbd9a0b7 v7-0171
+293621502c4daa122ae601398d854857bb732a83 v7-0010
+2951f28a9bd3b08c5be9bc9b3745f062b95635b8 v7-1-192
+2981ad79c362bff0c21d3ff0d68be57213bca837 v7-0-025
+29bf49bad20d3b1ad35af5cf21d91c4aa486d4a5 v7-0-068
+29c09fa57168acd665a85ed5a210b48b60d0b5e2 v7-1-211
+2a11407a5a8f4efccc04dfde8a61e40ec5eb9fc5 v7-2-066
+2a256978a64649b75d424eec6e703f99f7f28636 v7-1-003
+2a8bf2ba504f422d53dac30da8b58d76e54b4428 v7-3-003
+2a9d26c95a2a9b2f1a279e04de22ee4c7298552c v7-3-077
+2ab007070fc86d20596dfbded70d0f986c084304 v7-1-113
+2ae2dd2591fae798e4212e9b2c47281eca0c8483 v7-1-055
+2b273c71a14b7d0e64b6ae9bdcf60ef7e4d45aa8 v7-2-415
+2b475ed86e6491b20046d5c34fec8ea86988dade v7-3-074
+2b4debdc8d2c73d1fc37b750010e3a4098b035af v7-0035
+2b913f7eb9d2b411f9ef2c0fa44f313b7382bd89 v7-0039
+2bd29808d1f640f027ab7a4a4f2b5b6a0e6c8e38 v7-2-429
+2bd96108392ec08b6c384893939968d94bab4dbb v7-2-351
+2bebfa810a66caed9562541776d92f73a71de7f1 v7-0-091
+2bfc2b7033147de9689cf2d651bd8ef36fdac68b v7-0078
+2c1ffe8953ee85cf04d4db5c03ab711c1c6c015a v7-0080
+2c4ca49319a689ad9caa4429cd90bceda4e210a3 v7-1-271
+2c5e70e2858fa46c7b80b022f217103b8c90e9e9 v7-3-016
+2c885fab04e31a34d91e4375d2d0397cadb818ce v7-0e06
+2cdbc91795ca0d15343fe954ae2af71f830f9656 v7-3-007
+2cdccc96d730501ce4e509e7efe4f8fd3f2b2e29 v7-1-150
+2ced59eaf1e5c67060fe124902407a8bf77a1a78 v7-0-233
+2d0f22897a4d1f71600540e64a5cbf80a178e46a v7-0-173
+2d9eebf2c48f0bd3b51e8ba085b97da871cd4184 v7-3-126
+2df7e2d753061b54b9120ae4b34d4bf050cf17f5 v7-1-246
+2e1e9b708941e1cfc2c0540196719f78e1ab18f5 v7-0-023
+2e42153b37f171ed28293fa12e4f538070bf8619 v7-2-021
+2e915ea7110f0dc0507a733e4330ec6cc91e53ff v7-2-266
+2f016b638c0ca912d89f352f6b9b83231cf9e83b v7-1-312
+2f57d93bdbf64461c4eaeaacdba26548a2abb9cf v7-3-030
+2f6e519726f19c2f6cb58e9cd75e827eaafa0ab3 v7-2-346
+2f70b8f1f1e32dca34db07fedf9cbb56ff97007f v7-1-076
+2f9308b31181f36bf605ee060fa763a28deacb03 v7-2b-030
+2fa8cb05b861d49dec0501a2531eec39e1d0a688 v7-0218
+2fb204616c9b4e4df95f1560899d02e5bb739678 v7-0-079
+2fcd444c4bd37f916da718bf5bbe9535d2667331 v7-0057
+300fac7c5a2bafb002ee97d52da19bae8a344d51 v7-0059
+302a6aa7aca2ee9cf24958c2277a90fcfc01c939 v7-1-061
+30534c76776ab088a4142f9e15faa23d86efe020 v7-2-078
+306fc545fe2cd5d77953811fccec0d5c4bf7744e v7-0-066
+3112fcc8923830fd9060c76d1ec9c75c59487d59 v7-2-371
+31208ed42de95ba5738675cb78bd0f66c34ed785 v7-0-065
+313ec58cdc49a69c4386a4aa18fb9bcd01155feb v7-0-206
+316dad0565b8943c978c8c58b212f3c4469b1cf7 v7-0-103
+31757405c0c5408f9c83dba9d83ea74b2bd680d5 v7-3-134
+31bff9be0a7730f36e7de4792fec0688f2fc7076 v7-0g04
+31df87b80e562b6a83b97e2610f539afc94bc440 v7-2-278
+32c1b275ba6419fc014ffba3d2e55eca1ef06d4c v7-0-196
+32e19278c1ad1be6f92fc6cbcefb7e23ddf928cb v7-0-105
+32f48534fa0fa9b8e6833850fcbd77cd002ce8e0 v7-1-187
+3328b87305efcc6a8db6923c31cbf78a05983eff v7-1-077
+3372616fe1f1def653875bedaa8c059c399197ac v7-1-144
+3376d79d40f2d2c8e09cf8a3c07e15fc2424ecb3 v7-0-148
+33792c36e3aadc7f313785705f39d7ea6e214319 v7-1-018
+339999b511a0d529f09219a5d61b810fc75261ef v7-0148
+33a2652c13268ca53bb9ce0cfb7232655864c373 v7-0-231
+33d28f1c4d1dad3d4ce7f768c57820a8203c3e51 v7-2-006
+342cf2a9f5cce4f70e6a974253b20c8e309de7ef v7-1-145
+342d2b3a072a6cbc3cff898a663c4889317b32a9 v7-0-208
+3479f9aacaf57d583abb468cfe393eead386f15a v7-2b-008
+34f62bcce014d9c0b275002a1001cd1582ffa121 v7-3-123
+351bf13db8071317d7add1e55a50ae284ff53a4f v7-2-334
+354ea37841d13e0d9bb5ae995a09fb28beaa0d13 v7-0-022
+35abb70264158760c724bd0290c6c441afec4fa0 v7-2-033
+35cef95a6b7646d045b97bd4a54bb90000b5a753 v7-0168
+35edf814f2230c2bfdf403073fdcf89094c8216a v7-3-100
+35effbd07a25d1df122e795165d26ceb65510c3a v7-2-421
+35f3b20de2dd2c821675c61a11f4b227d31e9cdd v7-1-102
+36071a92cb764412276e067fed099164b0170436 v7-0167
+36275e20d997b91a357433debf8fbac0885768a0 v7-1-051
+3686831cf3da094c66ca4d2ab2c671d3d2e2d497 v7-0166
+3709cf52b9b56befb1c7a98e5f58cf39d16cf953 v7-0119
+371201c6b4c1538b593b5dc72f36c79a1f2644de v7-1-327
+378e33d47ab09cbb564a2aa6e975659a7f742a67 v7-2-250
+3796d11fde3c141d30cc3446038c20bf280c4b5f v7-1-267
+37d62d968182826522e378b31b76cf0a8c7a3cb7 v7-3-058
+389c8abd59258ba5ebc164dc7158a025bfa893a2 v7-0048
+38d7bf77e55068a5157faac7d871f2f3a66cbfad v7-0226
+38de872507e1c6440c9252a7bad077ae8c1bd488 v7-1-280
+396a9b65abe6a8fd08a6c232b443d541717cad0e v7-1-121
+39aaf0cc59e83148991c7482fa82d2bc29129d3a v7-0-150
+39d115408c71e1bf72439d5a92d98c8e551a5750 v7-0-186
+39ebe9e88854b766c569529a96dac3b67aba0e65 v7-0165
+3a6ba07b3b9fa89e94e002d44f57f5378eb59f08 v7-1-302
+3a779b47f235a62d799147b25445b01866f7c0dd v7-0223
+3acbcd0d3fd3d81ce94a40af4510fcc2e7870a82 v7-1-317
+3adc6dd2d122c76a211d88769227e447e4f8f821 v7-3-136
+3ae106044109e65b5bce1ea8938e0658729349ed v7-1-008
+3af28ecf9e56315a8617b2c58da078b6df989f2c v7-2-122
+3af484dca921e30a0bb1e4975a4fb214c3911f94 v7-2-150
+3b1d692e5a2c3053fa066d202ffc0b51779d2c71 v7-0040
+3b226f4693dc8dd1fb8886221335c39a64bb1fa9 v7-1-207
+3b241fd8d7c09d7a93694a0abcdc283dcd6b4675 v7-2-441
+3b48421dbde112f3a6dae67a651a9f114d85c874 v7-1-301
+3b705e71c7b07ba1309d08a8b370ae8ad3fc17cd v7-0124
+3ba373b54370d830e3fda93eee83e3f0b1ea2a0b v7-0008
+3bfd2e1e2609c8470c5b4f75184b66e5a4d8faef v7-1-053
+3c17132458a1538d3f1d6ab00544df8069bd983d v7-1-208
+3c17f4d2196f2f280de13a417652529c417548ff v7-0-028
+3c251a30c8cc44946e5871a7073d88ce195874cd v7-1-325
+3c6417b7e6efed4cb13673383489efb47399a902 v7-2b-027
+3c838658fc357dc48e457bdbc1f5a63ae5a73d19 v7-2-257
+3cd88bdcd97d7d0a3e2f5a00a6627f00970ce5b9 v7-0-045
+3cdf2a653e005387c4deeceb7281d62fffd34687 v7-2-391
+3d698caa5dfc7b11c8a6ada5f57e75c7a6a117dc v7-1-064
+3d842a9e2baefc023d9e4f163ea138b9e29931e8 v7-0-051
+3dc6072e0a25f24ad5d888af77d858036a9185f1 v7-0-083
+3dd986bfef63bd08894294a0828a1bca737320e1 v7-2-181
+3dfff6a80088c921b391d493c6c1231e4e64a656 v7-2-217
+3e0f9984e98e8f020260ff015cc994ccc34059a9 v7-1-111
+3e7d17e425b0f58513002797b3310e722757893f v7-0044
+3ea3dcbf2cd6e5ddb9d827c60ce999b2e4a5e755 v7-3-108
+3eb34a777f49f7f656b32c8db829fd0b153abe23 v7-2-220
+3ee6db0a746e990164e288fed6344e519a5bd1d2 v7-0083
+3ee896333e3eebba8a5e10e04649f1bd20e98770 v7-1-290
+3f1b2e6496debe5ee3068d1916ea15926d5a0f99 v7-2-252
+3f44e9abe4ec65f797cbd12f1d46bd08eb48c2ef v7-0015
+3f661e42f262e7839e2f04c50a447c53f6c4214c v7-2-228
+3f8cf4c668c30ec99289b5683f4fd36a1df602fa v7-0-115
+3fc0f57ecb91686b33630dcac973ab9d7db31c6e v7-0001
+3ffdc64af1e53617586ad0cf14e039cb6f1cad34 v7-0120
+404aac550f357223e7bab3656343827f641d9f74 v7-0017
+40a0699b6c62f93e58ae233fcdfd395bbc1bc80f v7-0046
+40a8e388692b53d36104e9c9b6ed351c01707308 v7-2-241
+40aa7ae37901ce256da18bcc84dc5ee21f83829a v7-1-149
+40f2a904bffbbe8fb600089d1b04f1115a2a4a71 v7-1-115
+4102fb4ea78127b1a95b2df3274a55d9bfba68c2 v7-0002
+410fa1a31baff929c7876be744142723c1573c75 v7-0023
+417c04135ca2ec03b6357404b62761ca9453cdba v7-3-137
+417c4d78a09c07162879dfb79e25e672e6e9218d v7-1-043
+41ab6b381572fcef699480ffb759d3c4543f0dd0 v7-0-128
+41d8447a84570ca22fe07277a2f8e9db694f66f0 v7-2-236
+41f9fd58cf132788bde73ab1954cb987521e3bd2 v7-0019
+421a77b136c2bec5d2056a799e2fa8021178beda v7-2-002
+4238b697bfff46433c49d60cc20b43761ab3c128 v7-1-097
+4256f76f72668271d9d986cc3736eb188b4400a4 v7-0-080
+4269a0673478b966f8d0e08b5681ea0cf2acd68d v7-2-432
+42ac369bd824634488b569ec5516fc435b700be8 v7-2-070
+42cafbf4b6e81160c26fc99148eb333aab5d2f96 v7-3-110
+430793c2a2315e1d0ed2de460071eb83a4f9c97f v7-2-319
+430f555d7d152cfa5b7dc43b8b8b0dfa0d520520 v7-2-195
+431ebc9412a816440aaed887a3d318deb08c6407 v7-2-418
+43243f7ce351aecf1f41932a9d02d6723fe49e34 v7-3-128
+4353593fc2c07753d40f71998688985cf96689d3 v7-1-244
+437fb19625c9e24e2157563cf0a55aeb432b2990 v7-1-275
+439f44b874a731461a187dc720edc0c663ab47b2 v7-2-291
+43a60ac87145f10d827e08b02c8241b359697740 v7-2-263
+43bf0bcf2110ffd8d42f0ea9b1469b1024def86c v7-0115
+43d337097e4ceffd268685809aa1e8e0f2a2dbec v7-2-223
+441f938ea9e90e07a05e55fef17ab22d2607f5f3 v7-0192
+4483ee552619492639c69f4345d6554b7bcbef2b v7-2-355
+44c01fae1181944162c94bfba919ac9867ceec40 v7-2-160
+44fe912b5a1b3961c7bdfbd2a8277d38eeed1e77 v7-2-145
+451bed7e9572b45d2bc98bb5c6680e7bdf4a3fc3 v7-2-321
+4541e06d4fb9dd8b69a7ab43653c72022f95151f v7-1-323
+4549e0e7fbb661089184c7b0ba1888cb6564ef2c v7-3-076
+454d71a434176e2d1ce0c2a7d47bfe2583a5069c v7-1-037
+456ae41254c975189c55a6ad28b1255936c847fb v7-2-159
+4577899b8ff1548f3f03e6516715087c9aa15e6e v7-2c-003
+45898756e0598f357776ae5aa05d717a7017e0cc v7-1-105
+4589d1792c036e15d1f9e72c0252fb243aa6d5e4 v7-2-094
+45ba31f9ba0cad526601d1d15d4e05180967133f v7-1-127
+45bae37de0373ed58d6f4ed8721d594ae322782d v7-1-031
+45d9e2f80fe18c663346a2e88409bf2476e874cd v7-2-061
+45fe7cf4a89e3963ed9c0d6a34600dcff8de3f9f v7-0-176
+463e25d28b334622df784faea456a98ddbc0b5ce v7-1
+464da5b48d277d1052e3c211000717947fa13da6 v7-3-130
+469c42f90fda78344dd4b33e7c0dd0860b777939 v7-1-030
+46d39f2eff86c940486c2da466283d7526b98c9e v7-0027
+476336a5ae9588c4a13721b5ec1cd792fa44ea2c v7-2-404
+4772a5e3f9fa652baa1cb6d5295d60daeef6ef0b v7-0138
+47a0dcad7216bfe602a2ee241df60bfc41c04979 v7-3-120
+4842e7421b5207294cc90f7e2d2d18c24e65753c v7-2b-024
+4845822f6a6c21860e0a1b4627996d745d455da2 v7-1-213
+484987f8e04c44e19e1ef2f3f6864b4c6fe61f1c v7-2-118
+4869457735a9133c39202f797a6694301c41abc5 v7-2-290
+48775ea99f249b75872e9f0268c5bda8cb8af8da v7-0-007
+48b22e2eb1ed7782c4dfb90051b64d6614fc6d3b v7-1-185
+48c9c2bf59afb140dfae3f4b7182ca410e72cb25 v7-0060
+49b5a7f186aae9fdd9b633037e8da484c61c55bf v7-1-002
+4a317df1696281eaee0e54b5c1636186290863a3 v7-1-298
+4a4287c09953fff6a65f7324c5f223f7359c46f2 v7-2-390
+4a4b16c67c62174b3b66848a32f4e5554b9cf6c0 v7-0-183
+4a6554fb0483f5cab10876ff0d9a0e92a9787119 v7-0-161
+4a7320e53f32e1f6d60c498d870e6c4b8c7acc35 v7-0126
+4a79d6d376f0897e3a899ccb104a324a94bb846c v7-0c02
+4aa4510d548c9fff9d8317977e3801a68fe2aaba v7-2-341
+4ac0c84d1c5038d0f6171c68d9c58ef0fefd4226 v7-3-079
+4ac1dce8dd5e8d8e97e3e7b921f3ada9db2fe2de v7-0012
+4b8583e82cb8875d14ff928db281aea8145d0b0d v7-0201
+4b9fef49d7ff02cf781d26d5b85a0a03c8784fd8 v7-0095
+4bac29d27e2f4c2779ecb72a5e78cd4a65cb455e v7-0
+4bac7ed34007ad41b7870888c739c1b4a129cfc3 v7-2-368
+4bc81d4dc6be1c45e41f1b083ad7fc07c58d840c v7-0-142
+4be6da0fa3d9978434273d3abc021d7e68455864 v7-2-400
+4c02214d1465ac2b014a9a1096927ad04eb710e8 v7-2-200
+4c41f0da2a2e35b42334d091130440d1b1479e7b v7-2-324
+4c70a10ce2bb6d83a4cbf3e3baab19d1752f2230 v7-1-042
+4c7cf05f60b5885e1a5caadb787cc6e290d7ee34 v7-2-110
+4c8008ab94d8da38529991004a56e65547faed15 v7-2-431
+4c8b90b7a94a123db784dea518f3c9a3bdfe85c4 v7-0-221
+4ca6669af2cdc06f39d77bfef82663e5bbdedd56 v7-2-046
+4ce0a7e4c6b3a305419590c746d2a11040fb2b92 v7-1-036
+4d53c2a2af94cf7a657d85e27f891b2d53b698c3 v7-0054
+4dccbe792a5e00c40a6e5b4f9e74d20b5aed2c50 v7-1-057
+4dd75cfd946f31e81eaa4b03ec81ef141c562137 v7-1-071
+4e22214f84640bdfbad591ec2da5eef9bc328dc5 v7-2-409
+4e581f1b08dac0b7f9345bd51b03a5fdbdd49ddc v7-1-281
+4ec11bb387a559fb6168fdae70e7d0ad78e15c3a v7-2-372
+4ec4c53046b5be6700810b9b92996a0cfb4ed52a v7-0-021
+4ee809acd1ab9c2fadee72e0fae32de57040447b v7-1-124
+4f1130893a1c135b1200f6857bd0ebfb143350e1 v7-1-320
+4f1b94b51e99370161ceb5a923573772ca068582 v7-0b02
+4f3857aa17853ab6c36005520ae723af92f50b9e v7-2-264
+4fb859cd9ba955957ad712ea390e87cffec6a540 v7-0-072
+4fe8e1a7758ea8170eaa4b1abf11cc9682437cbe v7-0102
+501b107b335af7ffcffea060c38f4b34dafe4101 v7-2-012
+5027d3220e2adb2f2f54e85f469a7b4302a010da v7-1-308
+5044d9d784ed2958022fd3446910567a4b84dacc v7-0-154
+509230ed2036945be2d9db7e1ecded3c59518c2d v7-0g05
+5098908178cdede4656e3f96f2df2847573e6ed9 v7-2-050
+50a93218720458be104f03ce1be00bcc8b898eb9 v7-0-228
+50e0337c25cae29dd3e63b333d4bfb68cc9b3740 v7-1-239
+50f5ac5b90dedfc7f88a67d7a435014e07c298ca v7-1-094
+5117153003bdb002aa3e68d3b90a98a973d38078 v7-0e
+513866ffe6af0bcc09e7275c0e9130170de66acb v7-0200
+513d037fad505a5169add3116ae459bd1adac381 v7-0154
+5232b9862f238a2a109f15527825e5cac1668a04 v7-2-000
+5232b9862f238a2a109f15527825e5cac1668a04 v7-2-080
+529c6a431ff5d5612bfba4424c023dcf073c2cc1 v7-0-056
+52c87a746f4ab8397933a53388389aba6a16bdd3 v7-0181
+52d17d53b555c45b0b9f4ddaf3551bc8ad5623ce v7-0d05
+52e76e2b5b65eae81c4ea93d290194763d7edcd7 v7-0140
+53175322ef40dd7f50dc4153e6e6fb530a4b2b29 v7-0070
+5332dd13733cd57e814b7e21cb577f6ad0c15408 v7-0094
+537cb92935b690665a72f2b31dead8d9b322dcb1 v7-0-223
+538cd3220874d9a98abc7219e7be6666e49f853b v7-3-011
+539d9b8f418aeeeac3d0da1932e1cdbe709456a1 v7-1-265
+53b2bedccfdf5ab8cbff6c3fb1f6f83ac7112b85 v7-1-091
+53b47a10825a20cd7684046146393a641d89972f v7-2-163
+53d475dff0e363bfeb31d6d171337cb19c309098 v7-2-374
+53fd0a213cff86b7185c5391cef34c1265f8b8f5 v7-0-237
+54a6b47d473e64d7ae5212f00b8b125c721d2c41 v7-1-160
+54d5eb36689f1a409d13cd6ff9b06d68a30b0d48 v7-2-092
+553c97222cc0d0adb7beecd6f73be1c512f2f37c v7-2b-005
+55e117ed68724567167ed25bfb5a320585f1bb5c v7-1-075
+563bd9a63fdcb08d55b6f6087cc8ededd31b891d v7-2-010
+56609cdae088c4d5b38ac94a95a07f1520b56fcc v7-0-059
+56695f1182f01d75843d0433484c94c1eade71de v7-0-238
+56b638f2029e728f1fb20382a7184a8e4ebdce9f v7-3-018
+56ecdb792c3353d9fc587a515fa4991e69363dd5 v7-3-036
+56fb4ab9f62f19b9812d483aa76f8b53104db26e v7-1-225
+575dacb554d8b134356fae0135383d5e2231113f v7-0096
+58059676e24a6fbbc686faf84c612cfa8c25485d v7-0-134
+5858c00d0f2c47b395e3c63cc809ee667f8c02a4 v7-0-122
+5898cc36322e7f1dc371e89dfb5e2ffc3c6c6e3e v7-1-309
+58a14bafc1f08b9712732a26a44c2a93e34e6ae2 v7-1-209
+58cad056e60844274b103ff3fdb56d7a6749b121 v7-2a-00
+58f47e17ba1565ec9c538c7f216cb9ea66e58a63 v7-3-122
+594f25e4a8065bcb865784556adf556004bddb24 v7-0144
+5950b03fc906f434d5a1b899bcee8ff839b05a34 v7-2-020
+59edc8429da0ca92da8913823f56b219e3a99051 v7-2-065
+59fd8376545beba122700d5a481793f29ff0a69e v7-0058
+5a1d8468d1fad7189c8c781149f034dbb4208b39 v7-0-224
+5a1d8468d1fad7189c8c781149f034dbb4208b39 v7-0-225
+5a1fe35a6eafb1c994955a34d8152996d53838e3 v7-3-092
+5a7384b9ca6691ee880dd4e01dddcba5dcac4f6d v7-2-031
+5a7843c57316c63d1118b6a5c2f42d330e57183b v7-0e02
+5a84b6388a5589d6f3b53a1aa6f8fcc369989a0e v7-2-369
+5a97d0c03b593699d6e0bb2ea49073dca03153f8 v7-2-397
+5abd3e3c0085de46b37ac9bcee90be8160dccafe v7-2-363
+5b101ff9d4c43c566e7adfb0a7c0978d2150d741 v7-0203
+5b154df6fcd89b4d24d34da63626cc01d9b5c0c2 v7-3-033
+5b43a3a9454ad69432d5cc82b70d59ec6c92a45a v7-2-003
+5ba8e25f7fc159a684a965ea9e6626f62b76997c v7-1-188
+5bbc2d6658adb0dd3c67dd80c59f3a7ade3ba3d6 v7-2a-013
+5bedef935ce38062e866c72aec633d38d95dfbf2 v7-2-357
+5c3844ad7d5677953eac88ec4ee317b298812bce v7-2a-017
+5c4b2fc4f067cd04bed4fd0a13bdec7d26036d26 v7-3-049
+5c6a3e894d43ed024662462cf5c6f77feb743132 v7-2-288
+5c6fa259c9236cfacc66dfeade89414479b5aa58 v7-2-328
+5d1ca05fa8ffd87bf59d26121e6cff5f91e9afd4 v7-2-199
+5d25cdc3c3f31d4893f646d5e7b94435ef59aa5e v7-2b-003
+5d2f6d04c82f900b01c18a7bcf2287a42cf09ffb v7-2-253
+5d5a41a95347bf4a1382babc697a1f940a83e43c v7-0-227
+5d5cad78a8380735abb8ca0e7d3ffb11e9eb98e6 v7-2-300
+5d84650b569c7800de8012d91660441bda95e5c0 v7-2-108
+5df74a812b7b20bd7e33634453c645be0eb8a2c4 v7-3-012
+5e0c164fc1c25fdfcef07fc03c6634216e6ac066 v7-2-277
+5e168526af25c0a59c55dd009e10a63d2f156114 v7-0-033
+5e225f973b5d22208869bfbf151c5fd03b5a3451 v7-2-089
+5e75d07bfe75fc81e0dac043b6bc0ba417736b17 v7-1-293
+5ea1f7516c2cb92422abed07129357a0d5a6a787 v7-2-165
+5eb1ac6f92ad40da9bbb585f5ff8fe003e85122c v7-1b
+5ed9395c1864269b18ffad462291eb37c92792f0 v7-2-235
+5ef53a1677ee9c831d7a18ee44d1041f182a82b2 v7-1-099
+5f0c7aae4da272c73cfc625f35dc050897b6afe7 v7-1-330
+5f33b64a6694dbc2c167b86c56488ddeeb7f46c5 v7-0107
+5fafc42c22d246e4dcef5c09d70b757e0d374b2c v7-2-053
+5fbc411a611de301397bf4f8edf494fe07bcf6f8 v7-3-042
+5fd44cf99b6ddccdadcf70ff8351999e4bf5dc38 v7-2-398
+605f5c2f77bace46037afea6841f7876af85a4b4 v7-2-182
+607cff4bc0cbd7ddf84007a20bf3e6bb01e70694 v7-0088
+60d21d224d251c448ef76b1b9df087497c06adf4 v7-1-038
+613517f0b72a1600d58abeb8c44df9b3de1ac997 v7-2-284
+61709607f5e26dc1d4cf420a25292ccc857d3575 v7-1-228
+619b90abfdc95e3b1d0981a8995b942c6a7c3c29 v7-2-032
+61b50044616bc626b27630b3c9f03322db0ec609 v7-1-090
+61d080cb268e21cc2275da3a0ff2b2081d97ff51 v7-2-086
+61e5d40135d0d90f5d1689c469958bb7a37e074f v7-0-139
+62716fd61fe94fb9e7f39294dfa9dba4aa06fbf8 v7-1-204
+630eca9496e07d9a778fe87d087832816a01a850 v7-2a-010
+631143ac4a01c32e465380ba2ab7f82949f20d75 v7-0007
+63157185aea525b39b1238df3ffbf4ec0fea10b1 v7-2-442
+63369d73b551cb0b72202c29dfdf59aa6049a333 v7-2-161
+63613d8d7e4dff96ba2f34be50fa4b002f56cff6 v7-2-354
+63bf37c1e7a2c323b368df6e926b026139ec3144 v7-2-401
+6412b0befebc17db58a1e8acbef86d3a3e4f742c v7-2a-007
+649d340f34d3ccb1c96efa9522a65803575d901c v7-2-067
+64be6e0b070a5f5f58eddedc8b57dc0356642cd5 v7-0-004
+64dd70f176c92013bc7efd0f3c50083fe4ca0972 v7-1-021
+64e2b75e16158d89c4a600bb97a62a4616632884 v7-0-141
+64ed4359d9570e345dc109b51138c36ac8769614 v7-1-221
+6510d834609f78327cf78465d6849601bfe39108 v7-2-380
+652d074e0264f453cbf76df0ce041b5032504085 v7-0-048
+656853d9c014add434086291b7af40ad828f126a v7-0-111
+656b4c052203990d56ca731d2e3ca39ebd9bd775 v7-2-029
+656ca7102064d711eed5cc678b4a5cf03b5d9c05 v7-2-026
+656e652c6579a812d9f48a0e5e4d8ee47ebc1a35 v7-3-068
+65c332f15dbf3376ed5aeea423e8f1584a65ff29 v7-2-083
+65e0c2e3a3521c9782728f307ced58a5740d87ac v7-0-166
+65fa3b16f040f5320bad34c324f230099bfd8f0c v7-0222
+6605dca2960f5c597f981c60cd3009e98b173883 v7-2-178
+66080ac5dab745208cfd8f385faea24ed68be68c v7-0130
+66263e241ce35e11faf9b33ef6e2d509e1ada4eb v7-0176
+6632670ff6fc2bd4dbe01001086874b9f75b0929 v7-0-053
+66475621f0bfacb601f38c15625c15c2a478e672 v7-0147
+6675076019ae7e7444c526b342c91ae2ef6cfaac v7-0d
+66b1822ba176a2f7d7e2878b2907af6d86e5b5c8 v7-2-326
+66ddf49935fb8979def275bcf7c56acdfac7ef6d v7-1-015
+66e40876590bca973973b6aae208a14cb428c266 v7-1-007
+680834cb19eb2dfdc88aded4bfb36518ca4caa60 v7-2-022
+684ea86baabb6ead7b673d20de6f4b5b27a3335d v7-2-101
+68f00510705229a9b8653612b806dbbcccd5aebf v7-2a-001
+694e8715dce6af134be79c99e97f90786088078f v7-1-316
+6974b167d75eabdf70005f666e3dd0e82e47be4e v7-1-056
+697dec8ec5e723ae32e12229d3ca111fe7f4ba92 v7-0-037
+69bcc0c891d706d3383f013e9e5f8876b6c76d4f v7-1-158
+69e8006af73433fa27ecf32b695919bd665be1c6 v7-0212
+6a2e4860134bf0e4b5edf382627809dc6cec309c v7-3-091
+6a80537ac7aa6d4c9011edf4db84a6aea85d2911 v7-3-041
+6a85219723b98ddd686d1a80c481a545bcb535d8 v7-3-027
+6aea606c9e911f768a5e6c9626581721f460f756 v7-2-068
+6b5d641bcdd45e53c24e0b4e0b6085a696e336a8 v7-2-395
+6b89fd4ffcc698278ecc582280c79916a425498b v7-0-008
+6ba0265d1f1b70b8a4a2b3337b18ded763f58f09 v7-2-295
+6bb1fa855dc91259d295a1beeb4144aa51b3cab6 v7-0e03
+6c05b5e5c1be4ee9b8f96334b7fba7afa832524e v7-3-032
+6c3c2e464a9628bcbfe21317b8fd90ae27076735 v7-2-392
+6c4da3e24371945408401d6330a930d44cb5d716 v7-0-232
+6c62b9b939bd8f3df4ec59b2c2d72bbbecc723d8 v7-0093
+6c7719f94811d10db3f86578e5286e5da2fd8514 v7-2-170
+6cc8a093e4a9b14df444effaef7274d2318d00d1 v7-3-115
+6d421b3c485b2da5a04529c6b71041031d41b80c v7-1-046
+6d80dbca8501a4152908713778ce03e0f45b93f3 v7-3-118
+6d95d8976b00540c053d11fff36e20556d125152 v7-1-200
+6ddd55ac6ce50b94713303278888da04d21f489f v7-2-249
+6df4e719ce4eb637d6db90febd0d1eb48bf8e96a v7-1-112
+6e03ee418b50de776b583358fe2ba20bbaf043ad v7-0-137
+6e9c10c63e25ce9212c5d629c9fdb60b67e6658a v7-2-216
+6ed4a82fcfc6f1c354906dfaa5e13a192b3246a9 v7-2-175
+6edf4a4f6cac62dd123f7d1017a7624c9f48e71c v7-0110
+6ee9d7fa5df6d00c892f7e93a63435de5c50e083 v7-3-057
+6f12c4eae4f69d1379427e8b0cee82769f75c35d v7-2-153
+6f4740f72d3d2018bfb19d4c8d8064e3682fd883 v7-3-090
+6f8b578776ab0204bf16f669383aefb0661610f0 v7-0131
+6fdbaf2bba0459270702479d6c4cd04f4f6bc034 v7-1-098
+7002404b17b15ea37887cb1dd5b5b95883cdd27f v7-3-054
+7015ddf8105575fcf48eac35b14c61a24fc38d7f v7-2b-018
+7033303ea0c065c16d5fc31d485c949f7949c10b v7-0089
+70661384379a0dd305576f64554608a396b0821f v7-2-056
+70a5e723eea2c648aa82f7c8f28a2a5dd5429132 v7-2-213
+70c67b1bb1f1aeddc1dea55438e11ae6f9ca3d14 v7-2-329
+710b52d02c4a0649d5b20c38e3394a2e248be9f5 v7-1-237
+710da9abc3c1191eec6633477eea663fada04939 v7-2-317
+71219f47ccd9551fc7d090e73afb83cc395232d8 v7-3-025
+717e759932cb94af9ee8dc9e93f33b67f292e8c1 v7-1-217
+71bd485d8fa572ac15207c5c1059b2ad0ae685fc v7-1-166
+71db8539b8c487eef0df17f2069d96fea1911cf1 v7-1-268
+71eaeb69efe49baf0f63c6e9cebde1aade638ccf v7-2-007
+7209e03df1005fc037c029799b068f545b60433d v7-2-075
+720a59d79bcd3d606bb9837492295d0c52835500 v7-2-168
+721ebb602db0fd2a5a9cded8e0830800d734469a v7-0-135
+727ab557c58a3257743a8b7589d91e21975b54ea v7-0-102
+7281a86ae640e65e5eff6d6b565be20032f736b3 v7-1-016
+72ef7987368de4715599707a85f74a8e6d029c9c v7-2-139
+730697e82c43a8bc8b5975bea39fd180fb62a4be v7-2-091
+7317e0e2775877fa0b817e20d29de9eba1a4f95d v7-2-254
+732c7ae5743ec2d22423a8bb631e2d3c5fb8e549 v7-0180
+73354c21f1e40dc792e5829152992e76f7a607ee v7-0066
+734d5bdae499eb2fa3f818e843efd9727e7f69f3 v7-2-041
+7387540b6e52e3faad6c78182de9d1354ac9e6b4 v7-1-297
+73995e7c06e668b3eafc366b3c959d32f6bc00e7 v7-1-174
+73c0eeeee0b789738812c1cf821de3f86e1fee53 v7-0-174
+73c5752b957d49da8312ef87383a7368c78df74c v7-1-295
+73d947c20291fd857fba24ddf4725b9b831188eb v7-3-038
+73dd10c18ec4eb2cc0857417fb8cc20f63dd42e1 v7-3-060
+73f10d8124f48510e0ad1468ee9e29c010009621 v7-0136
+7472c565592a373abca2ea571e229b4bcbfd7b15 v7-0117
+74e9d19831c2357d7b998f484ebc609dbc08c5e4 v7-0081
+7557b6ea0fb14ba4e97f5a8a04438db30cf902bb v7-0030
+758822790b43d2fc184878c3a50a12d71dda794e v7-3-031
+75a69023117c516ca184ed479727f105af12cc39 v7-2-221
+75a89c7c204e0f478f480598cc3f2a8c45dee8b3 v7-3-059
+75ab683fdb50e83cb9037454f5dd8d602e08e4c1 v7-1-233
+75b3f9cc19da44ef65c962deb7a6049c305f49d4 v7-2-283
+75c88515e0db5fd6f88a05634d9abd22795aacbd v7-1-214
+75dbeedddaa9b0e0784c4d23d71de713a533c5b4 v7-2b-016
+75f5889a5d8e8272fd17a104ef148776f9133aa8 v7-1-260
+763272b18e4ffe717ebb58827315badc09824e86 v7-3-098
+76406c9cbbaa1ab6a8f6ca7f079c3ba8cf06e2ca v7-1-176
+7644c80ca87b75a7dd85a7b4089e74bf5c503f3c v7-0-089
+766918de9e3a76816ebdee3b90cdb1f9f76bca6a v7-3-004
+76985a406456362dbdb4e7e4bef67656b84de965 v7-1-240
+76a42a81f68505f7b99af53a919e3cc7895096b6 v7-1-087
+76c2b2dd25c9c6945489a1c636f7e375ef1f40d0 v7-1-033
+77310929a1f94745e3d49f0cf1a6908785d3cfb0 v7-1-151
+777d5460622d4a9aac084695524d0c85b39f4174 v7-0-164
+7781fcd2b74f26a37da0d1186a1c44d904a8f11f v7-2-011
+77f3dd990b12aa963aa0a63f0db50f6443f3f41d v7-3-119
+77f8a648d2e6c765329ee6544bd8716835bda3bb v7-0-062
+78b9d5dce950b348235ee667f8573c6592920088 v7-2-420
+78e032bb32605c1437e30f7ec3215ad4c0772dd5 v7-2-303
+799c1db62b42a7c9d504c45ed313910c2e3d169b v7-1-164
+79a23c19108a8b1eb9d1b97d5844fabee6525e23 v7-1-079
+79b395ba0ea5e2bc7d27ace528d84d47aa1f5a66 v7-2-311
+79b8d69a4588b93516410e519bb9459242f46d81 v7-2-340
+79bba9e6af2b6588349ac2b3e9fb722d6ecbdc85 v7-1-224
+79d111ea8ef64e7bab0a5e27b7d5903f10e45a43 v7-2-425
+7a4ad3fb109d42f37f82664390f128dc9b7e44bd v7-2-188
+7aee5e68548a7cd13c74e67439f8c3b8ae6327be v7-2-417
+7b0e89b77216baf928145ce14741650806004c31 v7-2-365
+7b258a166daa98eb01237988ec954895a2e6ff0e v7-2-018
+7b44c70ee8ab87d5265ebec758a6f5ea9d5cfa75 v7-3-104
+7b875bfb39b871d5d40525d579e30358bab6be1a v7-2-434
+7bc38b35f1e87c1749f157ef91b6cab86bfd9561 v7-0-026
+7bcd81b96e2abb28ffb000145c917bd05e88e5c5 v7-2-267
+7c28790fa8b4054bdde6d358a9132581de76df62 v7-0-009
+7c2e6ba1d702579761d7ddc4020797bbc97805e3 v7-3-008
+7c3302e07dd7cf0d746776234ed4e9cb376d3611 v7-2-023
+7c46737918cb0adc9a51849b75b1c03da7bd77f3 v7-3-117
+7caa503b63a9b193f3b9e016a0a466ff8065f2f0 v7-2-225
+7d121c69f540272878af6fafdf658443360a698b v7-2-383
+7d127d580b6d2d86853fc0a322323cdee2eca343 v7-1-318
+7d2641e6af75b3cfb4dc29e7c88812dee6c003ae v7-2-261
+7d29124f77f5e794008c746c69a0f79da0cd966a v7-0-133
+7df2d171ef1c1284e10a4c53fb079d02e6d7b028 v7-0-163
+7e0c8a18c915a4c7dccf01be813488e27d03fdc5 v7-2-275
+7e5284f58094dd557b1502e1536c78846a59049c v7-1-134
+7e6d264ec0a270beb9692df71fedb210c1896640 v7-0141
+7e7da11555d27f62984297f3e1debc8242baf995 v7-1-080
+7f01e52cc97aca6eff92948b67876e800eb67fc3 v7-0-171
+7f2d3b3c15a2ffbd259c2ee99966124c2c2087ee v7-0122
+7f788cd2741586586a34b41627a1c978fa465666 v7-0020
+7fd70926e2e1c299ecd9dff6ddfb51ef71f7f08b v7-0055
+7fe13e0f5dce15cd16dd61c898e63899a9aff561 v7-0175
+7ff9f75f9c59f7b600ada6ac4b3234398df5f38f v7-2-245
+801d5544828215bf644cbc6ababfc66beec6cb2d v7-1-195
+802898d3afd12da41c305c495b121e41ed880659 v7-2-214
+80b9076e9e177bbcb455eef9928283077ed1c861 v7-1-310
+80e5b1da667656a146cad7a749ac9fd2afb659bb v7-2-231
+81059e8b657d911c9876f557975f34624988624f v7-2b-015
+811f29447aea27adaf1f54879ddf0fbd05a1e094 v7-1-270
+813a407a63af8773c585b0baae4d22296503ac03 v7-2-271
+8173ec1e9f1f746657dd598b6e876b11c99e1049 v7-0034
+819d952a0a5cc810c52b34e8df400f83eb3353ce v7-2-142
+81cf1b6e0a2d59192534f884135108f788a20b91 v7-0-147
+81fe2ccc1207699c377b42f1d8ca426a70177afd v7-0179
+823e9ddf23f77858f1b866fadf3e4ec5ae5d55b8 v7-2-141
+826f00fef9e338c7afebef68658716bb0aab62f4 v7-1-096
+8272535dee77ded630f57073b428e89673f1ee45 v7-2-035
+82885ffcad10aaf6d11170dc45d2721ee222c37c v7-2-310
+82add1e7c154fbbd5926df49fd4afe768e6007db v7-1-013
+82b2594be40863fef91c163200db2f56b2e4e52b v7-0-155
+82ca8ff21fd7181e16dcc58863d0d251b9228374 v7-0-175
+82f866f19e91a19ae44e7dbe5eb8747e98acfd85 v7-2-269
+8389197c91f3ecaaf28b776e69b9336eb08828d3 v7-2-133
+83a006f81bac04bf9b975347bf8d6bddc7996eb6 v7-0199
+83a126db2895ba22f2fff13b488f028ff83bec28 v7-2-027
+83eda510dbc07b4fe4db5b5f324680f60c307fff v7-0-222
+843bfffb04c739ec456e5c5f612c6d025f2a6188 v7-1-058
+8464d084fa7475830cdc53529cd20f7334c81232 v7-3-095
+8531f7ee366297c58506f9a3130f45c350ce1fe5 v7-0-218
+8562c6804861cd26020e1a004edb1c1b218af9f2 v7-2-388
+85a99ba3eb5ab45127c996c4e7b4dea2e7a76c54 v7-2-233
+85ad197907065fd92f29bf3dcc190779a20aba46 v7-2-396
+85da0376313011aa957a9132df2686c9aba079d0 v7-2-333
+86079b930b3e8735933c9349e44184761bbf56b0 v7-1-010
+862863033fddf5f0bb2f18988b79bbe0d289ba45 v7-0158
+86289e90a4bbb818e9cf8bae6e57f7b91b9671cc v7-0-123
+862d920800b1a8a5ebca3e7db5dbe431982f7d0d v7-3-103
+8647018a15f3e4e89c706b6290ab0151565f394a v7-0-178
+869c92bcfb697875d5580fdf3a13eacd5648c5f3 v7-0085
+86ce35c9750f60054f48c1bfb80507345b862d8f v7-0231
+86d71ae0c85a546d4a00b53481b540a4ade2c9bd v7-0042
+871231399cf547112a50a9f93497d40d01b66d51 v7-1-118
+87401adbf5fcbc6fb8edf329290c445528266bc5 v7-1-067
+87a777aea8993a49e61394e7a84847e91b014090 v7-1-005
+87ac4be389523f44914899c37180d22b60757ffa v7-0128
+87b6a6a065ab60f6ca4ed094c2afafe16e0b590e v7-2-171
+87b9f21264a79be4ecfd14f69da0577f9d41f260 v7-1-247
+88095f75d63b5a486f603cf28801df0118ed1218 v7-3-015
+880ece6b24762edd52b414aa1f005478707a3179 v7-1-101
+882b2fa49a2a888a8231f3cf2428b91439decb93 v7-0-014
+888c0645d64f3a844b22525387981f17317d8502 v7-1-069
+88c0c6c9eadab09b029312433f246f65e216a1f0 v7-1-184
+88c68e59d39cee12c580f1df72a5759e58574978 v7-1-088
+89189f7aaad9c28435aa5cbd4db359ae54d0769e v7-2-312
+89300f5e013c7d217d5f891113a57705cdeb017c v7-2-414
+8978513bb5e31d3f20c941e5141d228ca95a6f58 v7-2-100
+89d1e8ed6c1d6d9a672880fc73df97486b2d5966 v7-2-227
+89dc68c0ab6fd676ade26cca39e16b81896a5069 v7-2-386
+8a0a8f10b43e02d44ff26d608cd80fb61ce4773d v7-2-356
+8a2092b558c2fc11605dded24c4c5a817ca92ac9 v7-2-443
+8a22a90c964a168cf3d93f5ff8d5c531a4327ea6 v7-1-229
+8a5a95f7ef2a7dfeb585d0392489fb57ea4c5af9 v7-0185
+8a6982d59d8ef4afa5c178d772bd2943665f0146 v7-0224
+8a6c67218fccfc536fdf829075e99549fb8247dd v7-1-173
+8aa3cd045aefc5d324d820f2239ca1f533e9632f v7-2-379
+8aa94f8080bdeb8908de30bbcf62945dabba1aa3 v7-3-022
+8abc0abf8cbd09abaab555fbbaedbbc231d42b41 v7-1-248
+8ac6392acb0a87a779340f949e280bafcc49f55b v7-1-136
+8ae24f338cab86cb35fd495ddc3cbe2101ae1558 v7-0217
+8ae4de2d02af315b1c0abc2230c3ccd5a31f1013 v7-2-384
+8b2e9257cc116bf30b755aeb37a742ac83f5da42 v7-1-152
+8b84fe17e147219e6ff181f6bd7e809e5116588c v7-0159
+8bebcabccc2c430f05c5d85f8532adccb18a6136 v7-0e01
+8c229eb52e347be77c76c1c2c96f717cbfdba4c5 v7-0099
+8c25f10d49e7186c9785a0f01612166f20a29298 v7-0028
+8c60f65311fa6358488f671adc226950c18a993d v7-0052
+8c8d07318d8d0b1bcfbd395ae7aeec6813725b33 v7-0-086
+8c9396275bfaf3ba6c759c26fef07c0b687a8abb v7-1-277
+8ca3c9ad0bee0c265345decd180d971197e36194 v7-2-366
+8cd72985156286e77ac5d271a13cfb569b29ed76 v7-0g
+8d09c1eed8a57bb2df53fb1f1747137e5a3489f5 v7-1-074
+8d1db3e3ac5f3f33dcf5f68ea132502082e787db v7-2-262
+8d2b705a5a51d2a6756f16dee861dae4ea97101a v7-0113
+8d34af900baedf0db9a3e57bbf48eeee75068e06 v7-0072
+8d74df00f7daa4e79bf7fc56164369781408e1be v7-1-262
+8d8dc7e07999acbfd89d0b646d72fab69e06bef0 v7-1-230
+8dc36a64ae8b36d124bc0767ccadba3daea943ec v7-1-294
+8dd456c1e283bf8c85e9ff38994fdfc6dd009ff5 v7-0c13
+8e2d14a3e7d2860527d39f0b662beade84db9d23 v7-2-352
+8e42199f51218e2a14a946ee50c1e8d8ef38205c v7-1-054
+8e5830943bff21c0a2aa18399d18c8269ed9d3f7 v7-0e04
+8eec9649b7a2ea1a441723ce7a4e8637c294ffbb v7-0064
+8ef9da918a98e7f8fecb4d88914e4691a8da88b8 v7-2-413
+8f72e3512b437d2390860bf9fb6605b778cb0346 v7-2-381
+8fa8d7964cf116fa98895d029808a0d5e1cf201b v7-0073
+8fafff87aedbcc1a7c71e29a9369056e5c08e84e v7-0-075
+8fd2e00c44ae10bd9e8a8f5c12db47378314457a v7-0-112
+8fdc1210333357780019fa8dbabc34f07d545775 v7-3-035
+8ff7fd162d3cf15129e377401e49f8210d62aee6 v7-0016
+903088c7a7c61b7f30d35c8a184d90b7af4a44e6 v7-0193
+9032e466829601e6c56046813d0a9a00946a1d10 v7-0189
+903fcd726d9058a0b0c14a85cadf31aae3ad27a2 v7-2-359
+906b37d2f9c3a85fc9c67a29005ad1538e60efcc v7-0056
+907cf09fbb32d7b189d3372f3c4f1220f198a9d1 v7-2-385
+9090f866cd57a7febdb2e0679bf0a5e86951e314 v7-0197
+90ee46d7f4927c095141dd4afa92400f2fe4c697 v7-0164
+912b18745defca4b03d5738fc7ae6c76d701f2f7 v7-1-143
+91e7d4a7b3b0e20b6f5bf9468ad17625e745d640 v7-0178
+91fff9db214e21eeaacd20da86b22629ba6d92cf v7-2-297
+920a993902e8332e3fd539a54997278364fdbcf3 v7-0062
+92168cfd558c53f1fb0d8014559f16be0a795171 v7-2-167fix
+9230c45fdde65ac15a42c39d851c68b248fd6836 v7-2-226
+92809ecb9a476994296e51001486b3934561fc87 v7-2-292
+92f3089a7b10dc9e8f5f3c69ab1e490d52ad2f0a v7-0-082
+932fe018ad166a9f8e4b6b0ae91d562cab7c37db v7-0-168
+932ff0c0f57bb90d48470b70cc728058e0c56e3e v7-2-173
+932ff0c0f57bb90d48470b70cc728058e0c56e3e v7-2-176
+9364d114ed8d089f3a42c910442957d33e5480cc v7-0204
+9368159253f847f95c6c1f39a894e26fa3c954e8 v7-2b-007
+93ffa40b532038ad22824047b15c6edec3b6af5a v7-1-155
+94164a5b0626984b565ae6421c64bfd6d993e162 v7-0-043
+94694351f592a56f8a379510eb6992ed0dbee821 v7-3-029
+946f0cbdd535d6fb8915ccc87b837edb15287663 v7-0074
+94f44da44d2e0874a562918005789418793bb507 v7-2-339
+951641b8784de5175cadf9fdbc361db2b6b45060 v7-3-102
+954947a70580c6c5d94bd110f974bdf103dd6fd0 v7-2-166
+95723058b8ff365843508cfa47a3bc2ecb1b0cf8 v7-0-229
+9577a28005e10fab0a0cada6c41b96c9a3e1bfe9 v7-2-446
+95b507e6c9e75d5b4c114a63a98b4bc36c643eea v7-0-145
+95b659982b7c17ff93304a37f43be8dc508e20dd v7-2-375
+95dac6af3b3a8f50af24432b7e355ea44ec69f95 v7-0232
+95dd473d2d28a088822c73309c3dee597c96facd v7-2-044
+96276cc11d8e68ee320e0f61e20406dcb7a0b995 v7-2-240
+96445585f1d9d1abbc74d9c24efbf0408b2cbb12 v7-2-151
+9656552c468d29773423dcd62a323aceee0b6c55 v7-1-072
+96580558098272cca6f93085d79aa7164c7abf41 v7-0-215
+966289a3dd7ea565980bb03abc9b52d88378f96c v7-2-316
+97a73b6f28925dea4310c00225cc6210af00468a v7-2-113
+98a2a6e6b966668c810986b6ddd4820bc09db426 v7-2-353
+98a88a884610aa911950623d7cce8d067feda66c v7-0230
+98cc757f7e3dbff20ade108b82582d7a7d88ed33 v7-2-376
+98cdf5c477ec3c3ce8851a517ca3021aeda6573a v7-2-298
+98d1c149be76b44332bdb72e986bfc8b0f9f21d3 v7-0-160
+98ef5b0fe07610170bd68aac5ba6e739410c913c v7-0-029
+9913ff5706164031d5f847bc0980cc61eeed3974 v7-2-119
+992d5c69d5e917b03abcee24d2fbed8348e21c23 v7-0-132
+9947133ce85b86df83b86f476c09c0454c47a310 v7-1-078
+994ea4e6f0238f12a5516eb75f7a6d7ce86362e6 v7-0-094
+995536cad50e5c08be60c2d82c7b32a63db1e434 v7-1-218
+99a9e42e5688aeecaeaa4642d17be0ca54ab5945 v7-1-095
+99b225e0dbc1989ecae75200aaf0e5329e6bedac v7-2-430
+99ccc8932b6c450cbcdcf86de05dbd5129a370fe v7-0-180
+9a10e4d195b342292cb8ce0d368afafac146abf9 v7-0076
+9a3b65713280ebf8750989758b4b2d42f757ca9b v7-0-216
+9ab23f1e137fd5b0e35c1604ffb95979713f83e4 v7-0c12
+9adbd26f7fee884be78276fb400ee77d333cf335 v7-0-116
+9aec644c45dcc33b3f3571ba0035e7f85430eef6 v7-0-121
+9b78bb3794ba4dba44ab3eab9ab2984797e839d6 v7-2-350
+9b7d8fd5dc68074119d5a609210fc1ba924e9d7a v7-1-148
+9bc164a2c8143f6019d0b13a2aee4be89da3a9fe v7-2-204
+9be44c669f4c67406132ede84d1d2951eac7d63c v7-1-172
+9be87deaeb527ef18daf09d6c75b21d1d7a65d78 v7-0009
+9c510840e896fc3776ec7694fe90e18808036fad v7-2-439
+9c5a9e4356f8ef42ea2c177568b63bfbb1779bb0 v7-2a-003
+9c970d8681f46de0b13ff16d67c2327a19f33626 v7-1-226
+9cbe94fd5c8f1ca388ccd2be94f17caa33ef093d v7-2-314
+9d6a886aceb23fcaf8f64f9cf1ebf3f83d14b2da v7-2-242
+9d74e2f433c0370cb458c83d12b05f72226df489 v7-2c-001
+9dbb57025f2542dad344102c571c06da6b840b34 v7-1-139
+9dc77520c6d3ee0c3e689bc3e6d635cde80909ff v7-0-013
+9dd62cb57ed5845c9c2294b6002a29702ef043fb v7-1-319
+9e0174515abb6667a9e74e6fefc74ad50d7821d2 v7-1-291
+9e084588b706867fae28f93f67d163635a79ae51 v7-0-188
+9e1cefec84dde22d62c1bd2dd0ceb4e072470981 v7-2c-002
+9e265d9089fd4afcc03a4ac7c1ccbd754c8ef6f5 v7-2-436
+9e359e5759f628fd0ff90172d533636440b464e6 v7-0177
+9e554211caf55e33249908747d9259ac77f10b72 v7-2-301
+9edb5759494281d90ae0f312b2ac32c30f51ca50 v7-2-260
+9edc96495747bd354e68dfd76b6ca525d39e715c v7-2-206
+9f184758f277b816c95fd946cd2d63578d296578 v7-0-010
+9f279ebda75194c26ba5c917f68a7102348215b6 v7-0f01
+9f345c48220b7a503fde0367df20e576fd46b04a v7-0c
+9f8fd6a14cfc84953deae7d00287a1949c0f0eff v7-2-004
+9fb5bb1ea79b5ba402e51051d79a3476ffce3c35 v7-1-044
+9fbb40a1228a4d8a5f26d1dff8e2ab4e3bd870fe v7-1-282
+a03f7551baccc60bedef5ef6a9f92ccdfe69a9a3 v7-3-081
+a041f68d05909431f0a525eace55307214c33d43 v7-3-114
+a0451524244d6387ea49cfda296f6550a2a9aebd v7-0082
+a07007166d518f51749cc9e145afeb023638a415 v7-0-044
+a0a98a0f12816722b1792141edb3625dd72eb5bb v7-1-326
+a0b03b7e9168b7f7fd61b1563ffdd6d09ca54260 v7-3-028
+a0c01df852e1d183c879ee114b35b2b5b0d06746 v7-1-300
+a0c70314350fde9e0948e598fe57dddc6192468e v7-2a-012
+a1059cda45f226497278c53752d5c07d21cda09d v7-0142
+a112fdce9ebd6d538c70602550e94f29a2fc60fc v7-0-200
+a11e2070c964de1cfb9fdf3ce339ec75b7a983cd v7-0-203
+a135270b75498b76b5bacbd1e381059283c5e383 v7-1-206
+a13e4b242735dd0b3285b7f36fccda195ba1d5f5 v7-0-243
+a14db0b78c590d4bb8e1a190b80fbf3dfff89560 v7-3-121
+a157c4786b79ae94758574d5ecb4a8f4959de5e6 v7-0-073
+a16af0072ea82b2dcd265d050b349850cf8f28b6 v7-2-410
+a1c1f001b99dd591d9082db95de70e2bf8f9e8de v7-0-129
+a1c5a6cb26756450d2b7065999de140c2fb6ca74 v7-0112
+a209672376fd537735f6ab55ce926cb80fa56ca0 v7-0f
+a2271decbce54d46f62e7cc9a0c4e3ea3ae9080d v7-3-065
+a27c581d2618b9bab1c7105fba966af40e23d57a v7-2-016
+a285f0cd8a462ff5cb17053fd457646f9d33573d v7-2b-022
+a2b128f7d705ef08ae91a8616cbaf40883827cdc v7-0c11
+a33e606ceea66c946219da3899de9566fb0cad35 v7-1-024
+a3552c04f4e193d981013fa4c077e49d729abb6f v7-2-251
+a36d21d4a87596abd8775c322fced6a539385ab3 v7-0-204
+a3a4be6bdcdd0f43aea2aa09288e8f515a2c2f05 v7-2-308
+a420bba0d851093bb949070895a9dcf4c25e6c4f v7-0184
+a4365075d05c40606c2ace3340e9484a6b045f32 v7-1-093
+a509e3ba61f6e541dc8772a0f9de0c38999fd610 v7-0100
+a53e7d3fd741c68a30085fd9b22d260aec93396b v7-3-086
+a565175274f6efd9d4f725dcdee1b6e049258d3c v7-0-184
+a58806285f2086c1591272962d0b5709a63a74fd v7-2-152
+a5b3a7fb6a5a0f1857b8d0eec380aa7a0f780729 v7-1-154
+a5beb9fb4da85dfc21dbb68af0fd6aec616dd1dc v7-0-024
+a5e1d6526ac7c92fcad2ae100b1d43ae238067b0 v7-2-103
+a5fcf36ef5129596fc281d76369077ad01323b3f v7-0127
+a5fd859f69f1b5c70de7d0439150f2c681d0d915 v7-1-020
+a66a49322b6bc2a82c6cc3e8092db7d502f64c4b v7-1-073
+a66c405786754105eaa63f3264c94ce134bd275f v7-2-105
+a6776e2c9f014491c7476c3a12b2b7f108e1b6f2 v7-1-222
+a686fd6c8beb2c41110e0a65f6a403f0ccaef83d v7-0065
+a711f7a6852db37b1687044ce8a96b6f48e9855b v7-0067
+a73a117542b8b5ec22eb3c61e45ad888d3d76b51 v7-1-171
+a75120dc3e2691218f3144bbc24369283d74eb53 v7-2-190
+a7c4842a0be340d06de659940f9396f969bdae77 v7-2-212
+a81bc802c17ce7002b08d2e327136e3ac4d11d5a v7-0011
+a83f48a17efb871266ffbcb3b6c9cd5a62408410 v7-1-274
+a8752f2805d69f51f1f6370eee8c7e2c89c57db4 v7-2-037
+a881e15f44d8b5888733fc98c39984c2fe6316ef v7-2b-011
+a8aae2e1d2ae6c22551400d451e4ecaccceffcd9 v7-2-049
+a8bcc7553263bb7a12eec8813270ed34242dcdfd v7-0-190
+a8caf7dd853dd5f5ea2bbc671467ab2f78989f44 v7-0205
+a954a30e407394f51218ead2a7d832e022fd2378 v7-2-115
+a9e353f7fcc48a2b603ead42451ea8e89ee7b9d0 v7-1-285
+a9e90b3356b62da552b62eb62b8dff78438f2dc8 v7-0036
+a9f561ffbc53a7097873cce7e8a8e1615ac0c38a v7-2-243
+a9f814054152b658c1b90aadf0f75428e1130cd3 v7-2-074
+a9ffa7c7db7757ae7c1ba0e7d3b990bafaefb558 v7-0-097
+aa6caa23a4b834360b82d3d078d1d17f33d673b7 v7-0152
+aa7c51f81f46cc5379386ac622a5ba44aae1c4dc v7-1-227
+aab202d244b6bb286a62508a432222d26d5d215e v7-2-394
+abff2f6a3ad7790f86e055519dcb851a06fe78c0 v7-0-036
+ac0458d9b9dde727d1bf11e9e9221edc20b623a3 v7-3-026
+ac04f392ba48436bc1b90d3d8b8d384fef4f8135 v7-3-073
+ac33b7c03fac7bf435346233114939fec2e187e6 v7-0018
+ac6d15d91466b34e4ff31765d1d1e1733f02ffc9 v7-2a-014
+acc572c5660c90020f42c9f31c1d2c776c5dce47 v7-2-097
+acfe86afd651f1abcfb6eb38ad0101e61a27c65f v7-0135
+ad8f5bdc727441118cf45678b031d04d1a77aae0 v7-2-001
+ada3271481ceab448c69588c5cf837c2dbc91987 v7-2-289
+adf6a9dcadeda32a2a339069336ebed7fe6d53da v7-0-038
+ae2251be41f935706f7e634a832ff5ff8a91d023 v7-2-185
+ae22c450546cfc001c90ca17999318e053838c30 v7-2-433
+ae7e29b64923da886325215a1a5b20bd60e4cbc0 v7-1-194
+aeac63ad9430d81a0dfdc21080f1f05cdc633baf v7-2-048
+af7afd2bb4c235544fc9da6b34898ea93d477d77 v7-0-078
+af98ef7f5a39aadfe18dd44df9afeedbb0665778 v7-0-003
+afad99b3612ca54f3668c232e8d3ef235d74c9a2 v7-1-028
+afb64d9f5b8ee1eb6e787e1d34ef8b80f15d4749 v7-2-013
+afb740b5dfabffdc759d3428254c944bd4badeab v7-2-191
+afbe4a4c884ceacc349264075afe26e93bc75f07 v7-2-208
+afc60a6339a68f659addfbbb849e249964c9107c v7-0104
+afcf9db31561c7fe2b62b346aca751bf7bb31bc3 v7-2-336
+b00bc2bf23eb62a1883318c6565d3fe0d1b4e30e v7-1-119
+b00d5f429a4b2f0a23710200cdf2a672ed9d5501 v7-0-108
+b04bb35fcd4b7edeeb8e175955a2909a86dad118 v7-0-240
+b0605f2f9786c14e943a0ab440c16b444f2a9cac v7-3-113
+b090b216a832197c70f60ead52026a53ecb0cdd8 v7-1-009
+b0dabd584b8f89ac32af9758c221e948016e2b0e v7-1-175
+b0f8f28a67c23c9e9b6b8087b373d6fb2add726a v7-1-197
+b1706a94f9f9638cc0ecb624dd7519cc9beb6ca1 v7-2-405
+b1b09b68d7069755425a2c1849f517f3f9e760d9 v7-2-279
+b1e87b7f5db64eb40fafb0e9bcbb0c39fa2bac63 v7-0133
+b209c3f94ab7ca3ff559d255c395fa013fee31a3 v7-2-073
+b254cfdd740542f5778d787845134db3c7584335 v7-3-071
+b2789846ed3978ec3dd9a91b6e1ef2f4d054431b v7-3-069
+b2a7d143abe2f572e713acda4a67ebce76511bc8 v7-3-072
+b2cfe84c96ccbf87a7c765442f0e32c62fa112a9 v7-3-044
+b2dcb84570675cbdb4fea2d017bcd093b3f34be3 v7-0-070
+b2e037ed7e33b48a1feb69174850acc393254864 v7-2b-020
+b2f4319efde1edbabcd900a63db8998bfc117152 v7-2-084
+b31702c473ae10db32dcedae94af25228d6c920c v7-0-049
+b34d985598f68b97fe1bdf1d34bf689ea1b8355d v7-2-130
+b4791bb4fbff451efa3ffdabd4e26a668eda2283 v7-1-108
+b4b1b5324380cad36827cc211a2f92fb165d9777 v7-1-026
+b4d11ddb7303ebc28f6a40fea28f003287e77352 v7-0-187
+b4d92472f168c90d60359f6a592d6461686c2db9 v7-1-085
+b515624f6d7dc7597b0b01c5cb03076e4daf3347 v7-0-234
+b54d2f702d41f4fbb8bb3d33e52faf94568b2170 v7-2-127
+b57babddb32b2df9f04b636154a26c51f78d73a2 v7-2-281
+b57f2617965fd682c6284a706a999b58f00bdc3c v7-3-014
+b5ad00887b816469ab8f7733643380a690c1322f v7-2-111
+b5c1cb6f8d565b4fa5b714660e8a0d7f8d8f7a5e v7-2-174
+b60a569eb708bc6563cc1104335cf56bb38ea901 v7-2b-010
+b61422c4dc7a81d340e33e0ddb8ce8cf0f94aec4 v7-2-025
+b62965091b8d258aaa26871ccf80ff9b4037168e v7-1-254
+b63792dadc23ed5ff4e0e9e8c7acc24d9c61e779 v7-1-120
+b63fe7400eb30f9c7b98199a21ed0bdc583aef62 v7-1-135
+b6627f01c67dd0bcdc2f24d56d0a9342cb5dacda v7-0-151
+b6632d553df3c8d25e419d62cbbbd1d8aa5d2489 v7-0182
+b686fb4898d1fd8579e5bf61f36c2a08fee85a20 v7-1-025
+b6ffc2045211c67d42d806af38dae64626aba605 v7-2b-026
+b76637e5ace1cd75c1894c44e132ea1e4fdc1a9f v7-1-289
+b77f790d53f6b57604b1ad5113da4ab08b4ca918 v7-0-236
+b7c22e34316251f32fa1034d11a3eba1829c2b92 v7-2-043
+b7c89e3e19f703c0ebccecc10ee044367a65ea20 v7-2a-011
+b803b277688037509ad1b6d30466721396d8967f v7-3-062
+b8744d1982d1fe26fc41d62b6e84fd315dd6c941 v7-2-407
+b88f0420148e5e65c2f71f47ed2324fd83b3bd2b v7-2-155
+b8ab4ba6b11018e468362bbadf077654f9cb4be3 v7-2-304
+b8c880d61acb8d5e08ae0cb558ece76d96d12341 v7-0-185
+b8ebbfa519b990d6b892dcf943576761e714c2c3 v7-1-050
+b8ed23ef6ff15604ead321f758ecc624a9d35c2c v7-0-042
+b9202c4cf847ac1898b4af225494197671111785 v7-2-124
+b93a3fc3897b3e16e96b80e35dbd72aabf9cf37d v7-3-078
+b9897545378516c8afe3140b7172d838f33e5b29 v7-2b-009
+b99303b1483f26763f0c4b6c9d244763ad32d476 v7-2-309
+b9975513fe244047a60acc818edd8de94935cc28 v7-0169
+ba2ac6b5bfb9679edffd08edef9cd0db1237ea12 v7-2-259
+ba32a005373a78e0b07972880704e2183f578f86 v7-0-136
+ba51f75bd4b514d5c4d48e57c6018c955434b936 v7-0221
+ba9375e24d4937d863ab87d28e6b7c1ed42b3960 v7-0-050
+baa5f81197c865fd8847f6af95fb1d48cea6aa65 v7-3-043
+babbc735b80efd1ef23f35dcc77c5f5cc9e68fea start
+bac7c3fce15019af25562f5c19b099c55487a6e7 v7-1-133
+bacdeee78827acbae22a7626a93318ee1919c883 v7-1-014
+bae8347a9ae1131d95a7af1d751fa47df5d3baec v7-2a-015
+bb3661a2eccc165bd5d2a87a8d4696f89431a459 v7-3-116
+bb4797166e4c610516eaa16865682ab14411ecb5 v7-2-064
+bb7a0b90100aae1f77748f6f38aec95520825c3e v7-1-023
+bbf0ba46e51d5a4e58b872b840c5dc3e1ca44234 v7-2-116
+bc3f88ca060d25cad633a20548ca38cc529fa0ca v7-3-045
+bc68103ea3f6a13d26598bfc1958a57eae377a92 v7-0-040
+bc7ec0f1f7f35c3b58b3e32bd2ba1b87501b17d9 v7-0170
+bc95c6c4bac13d4a0f8a4bd6ec10f495d3fa5eea v7-0191
+bca50c9e1374c176a63f9baf0ed7fcb34ea16967 v7-1-147
+bce687811199a7866c7728b09f00406ac1294745 v7-2-287
+bce7c73fd56da29730fff999a1fa4b0edea3285c v7-1-157
+bd7e26d05a3fc8e010566ad8f8aea9c31ddf55c8 v7-0-034
+bd94e22dd3db36f07fd31b2e282f25ccc7335f58 v7-1-163
+bdbaeab157e6f88d82056df6b927acb5b342ae01 v7-1-272
+bdbdec22a225553f5d78db019e13cdfe92b9cb5b v7-0161
+bdcfe793d49fa832470953794583b4bb74ab9fb6 v7-1-104
+bddda5d8caa1c6bf174c5e202d3b08a51dbd54a7 v7-2-210
+bde3b38593f9d07da76cdf37ea574fc9d80aa43e v7-0-052
+bdfbf8ef447a4fabef09ee9d28eedcf0e6b99e57 v7-1-249
+be0f21f63d2c9651429a6ec9e97b8e6e9d0d102a v7-0091
+be1d64f82db26bf7892605332aea6126d6343e47 v7-2-325
+be8e2719caa6c7194ce4713206da6f1f8db694ca v7-0-138
+be9fbf8b0cdb6a42c07a8be94e9fba866cff00c8 v7-0-146
+bec979a53f47ff6866d390eff6c4ddd4d5ce8a8b v7-2-307
+bf5ba8a0cdee590c0841391f9a8b65c456ed06bb v7-0129
+bf63a31b77017d78197bc0155c0ec59e31559df3 v7-0-210
+bf7803d0f5b9d0a9cb16636b9490d723623c57e8 v7-0-019
+bf9579ab26e59cda4bdebcd934c43b6fbded60ce v7-3-019
+bfade53bcafb7b6d297f23ce3ba9e6a72dcb7949 v7-3-087
+bfd69bfb41491b83ac7a4b948c649eaec251c54d v7-3-046
+bfd8935d62009b625c37dc373404b67d0019d7f1 v7-0087
+bffbbb566d6b1004cfe26df89e102c465bed4312 v7-0-192
+c00efaa0af249c086557487d172edd6a1cfc0706 v7-3-053
+c050d5bbe79b6a0bd83fb5dc0c13c350492c7c4a v7-2-063
+c06c658691e20f22ae95d4cf117057c7d0736308 v7-0-087
+c0bb3c1dd44695b4eda074afd1a7394d2b7e4552 v7-1-132
+c11845a465ae63ea7f9942484988dd4e441c891f v7-2-370
+c12f39141bbc7c031b51352896a78324ad27398c v7-0053
+c1709e3f8536100dc87defb9f788f895b4e73578 v7-2-140
+c17a42da3920c34a75c17fe8696d2f04bf683f24 v7-2-428
+c17ba3fb433e7cddfdbf2244b777550970493b0a v7-1-106
+c19f6b8d0393dd28a2673da19e8acef59d371f65 v7-1-304
+c1b61096e3d0e4383db1ef01a5dc2f3ebd5eb0fc v7-0-074
+c1f67ce5740adaa7e1e164d706f204252711d5df v7-2-382
+c21975c58b4497d08a2fa30601723537ab1f03ec v7-0123
+c22ded254d0591df640c3ee0ea3dd0a490fa2396 v7-2-071
+c2cae213194d26214a9132c1ec7cddbdafd18175 v7-0e07
+c3242ae88ef1d4cb6eea51fdf96670cae48fc64a v7-2-081
+c3242ae88ef1d4cb6eea51fdf96670cae48fc64a v7-2-082
+c37ed44f014fdcb211ba3decf81d1f3ec94a210b v7-0-153
+c38cdd201cec8e9a774b7256a5eadf2d7194aa0e v7-1-059
+c3b5d3fe94046702944964c32eea7522ecf92c4c v7-3-020
+c3ba2dcc4cf4b96ddd1e3df9beacd1e11abe7868 v7-0-214
+c3bd0a84e11ad1caf53402dbebc39ea8b01fc832 v7-0-167
+c3e225bc213a1a91a278fdcb3c5fc003ae886f02 v7-2a-009
+c3f63ed316b621743f44a5ab6b9a5438b88feded v7-0227
+c44058ba78bc108e98fc15a14756716c3d3241fb v7-1-141
+c474f5691c0c6461414e65601a97e817e976099a v7-2-164
+c4d200412ae9b66732f2c9be98273802a0acdb95 v7-0121
+c4d5f3d8ad71c4d30397ca0101a89925f1666df8 v7-2-099
+c50c82c5e230a9ef1cb570be0a57d3dc9e295993 v7-0069
+c50ed526966abc52d825a36d5114bebc21f850b2 v7-0-220
+c51a4f9936751df0e9bbdc454727bced532da3c5 v7-2-255
+c524f99c79251a7b614776a5d064ba40c8d4d5cc v7-0022
+c544a3507e839f3ad4db6e1d7dd7474ed0167b96 v7-1-066
+c5871806d7e6c121c80030dde025a96c0ddec820 v7-0-057
+c58b9479e304ff055b0404d9d73a51da4e9bf7e5 v7-2-315
+c5a806b29372c033c3b616083c86159a8719635c v7-2-306
+c5b05f6de1adf8bf800da0bcdfa04a262e0e8329 v7-0047
+c5cafb21c45b5e1e16c006056dd5b8f5ad91145d v7-0-096
+c5d5e0f3403f65e77307d1bcb5d71acc73cbc90a v7-0-120
+c5e1b4b9016ff900a005057fd1a055c70b812414 v7-2-047
+c60d231453cfd59c8b313a894027cecc0a4315ec v7-2-424
+c6296b0ad9eae4122e31dd3b4f363e073f388a38 v7-0151
+c649cc22da98e2eee72352917030fc6068883317 v7-1-060
+c669f3280f595ba6133a94d8ceb3ed3ef6c2a4ad v7-1-324
+c6b06a4a8f928b1868a3d48d95293730262a041e v7-2b-023
+c6fe65c000d27b9ddb0cbdffe43cf188b7a51f2e v7-3-037
+c7537662746d8bae8bcdf8502a23a573a54d3855 v7-2-186
+c7654c4db8fd57c397bdfd3b3142632a4e761f32 v7-1-153
+c773cb978acfd216004c871e883d2b31cd4cc0bf v7-0116
+c78d973dce9e0456b96725f55b853ecbe4ebda96 v7-0211
+c7905d03c72e74540d91b1ebf3fc9cfffc2ba699 v7-1-273
+c7c53db66b5521d2deed3b889fbfb13030868942 v7-2b-019
+c82bb7ade452d18a121a6b0b8ff654dfad30532a v7-1-137
+c845dcf7fafa91d8cb370f690c16748758b20332 v7-1-110
+c8568bc2db390972c94374a031bbd195c4403ffd v7-1-311
+c87ce0b2ee2a14d3daf3902bdd4163a002ec7a22 v7-1-190
+c87f38b71d27d9e420e5947d4e99eba9e3eb2e19 v7-1-070
+c89903e16772bebee28ec935f7459c8c83bdf05e v7-1-223
+c8b6b7e1005daebc2d72c578d70b455f42b5bd16 v7-0150
+c8b87fa14d277702b7ca6b9ba18470c3d64ad83f v7-2-179
+c8c47cc9dab1eb6976b9c214c58e65beb3a45e97 v7-2b-025
+c8cae82dee305d003f809d91025ed21582785597 v7-0-061
+c8f343a465a271cec752fce3efdf5fa8476d3c96 v7-2-180
+c94bbf85eb160aa9eabe33b13b267c1446019eaa v7-0-213
+c9b7b1e711d194070184c9c198fbe8126701d1ee v7-0-235
+c9ddc2338f41c43a30044dbdca1775b919f80707 v7-0-058
+ca4883686f934bb338dfe3a2fd7d6d3995c3e0e2 v7-0-088
+ca501ab2fdb3a4477a6b8e469c1a4d8f1859d92a v7-1-170
+ca5b52e99385825f0083c4b122ebfb50c2653039 v7-1-255
+ca82de29ac1903bb1295c04da5624cf295b6447c v7-0g01
+caa550fe445725dea9531b9fe9f0d0f88961baf7 v7-0-191
+cab25717c6a69a7d9ebd010153fd9be9529fb49a v7-1b-002
+cb49fa8c71963b7b69529dfc2abd00b791119fd6 v7-0-126
+cb6487d683f2260fc0b47b5e95f78a297360b1fa v7-1-216
+cb7043482eca744ad9ba1eb11f08cc2906b6bd3c v7-0-149
+cb94c42c0e1a1e00f643be8a96939e42c3afff81 v7-2-445
+cba9c4003cb554f909fdb6426b8870bef24b3edf v7-2-085
+cbc9c335ddb17f9b0e9d281e1c5d97a20ed4fd94 v7-0-119
+cbe70f2e756d80015f6f0057e13a882ee7567276 v7-1-259
+cc03a79fdbb9315956fc22887483a15b414278ea v7-0-197
+cc4fe241baa3596ae9cd27ce65ad25077bfb2e71 v7-1-236
+ccbd8177e1f439fc23ef56be942ab0253d5dcc26 v7-2-132
+ccc9eda1cfcf918fbd1933bca9db01e246d5ef12 v7-2-138
+cd3689efd90a5934dcf2e4e232d97939737414c3 v7-0173
+cd3f52531f6c8f16e89e97f335f974fa25f4b498 v7-3-124
+cd6175cc27d9c8b4d4f4dadc7c38f6c490f3fa62 v7-1-235
+cd7eb2a18060734504ff974065d6a7adfc903b34 v7-1-041
+cd9471bd8e9eb1d2c59d00a7d18dc07dd97fcea6 v7-0-047
+cda8f3aceb85c72c94498120fa171939b83cc8a3 v7-2-120
+cdd82acd75b449784a574058387449096667e56f v7-1-125
+cdf37c8f46163497e0d7fabf9655be37b692fd1a v7-2-008
+cdfc3897c8950aa84c84c1a05158afd32ba71d06 v7-2-222
+ce2181d14aa08a59250267dbec36bba362eeb908 v7-0139
+ce6bc4bf2b87f2303bf47fe64ebdd470711973d0 v7-2-244
+ceaf71b15d813665b3b02036a619bc967db90d8f v7-1-177
+cec8b867838bc2a5b5f5bb0146010060639fea90 v7-0-114
+cf080795d202ac2ef02d282f4aec111b2ec126b7 v7-2-135
+cf0979c30cafc4fbe239ebb9de3c427a265207a3 v7-2-144
+cf4d73a8924e715fb5fc7db94af9a7e67d7643dc v7-0-095
+cf83dacfa25fb1fd8d4929ff2abe871c72ad94a8 v7-0105
+cf8f86128f4c428af72c116cc53d92ad7c1e40e9 v7-2-435
+cfcc1421f5e431d3984c3e9ef3f360ceafaef76f v7-2-146
+cfccbe492612c69ee77d6cca4adb690794e5feac v7-2-126
+d065616e083680035f38a54409e857ebc2202db3 v7-1-146
+d06a461924a3f92575d81c2d1c0c3a74cd0a2929 v7-2-322
+d0cf8c843186301d546870c2661cfa3e8526b3e4 v7-1-100
+d166fe2bfe7438b1539cdedf1810dc91a1cae01e v7-2a-005
+d20d37ef86c8844da2c9c45b2d9fc8b6a2dc3f78 v7-3-129
+d225695aa7945c27e1eed207e3e683b16824ea87 v7-2-282
+d23a400b718419e039eaf4f8ce23517144d41faa v7-2-019
+d2612392202f9b87c122b7233b0bbc67c9edc004 v7-1-004
+d2796c60ca6f11e05cbe080114a3cfc6006488c7 v7-0032
+d2a4f08396fe8c01ebca988db5eb95b7c3f9db8b v7-0f05
+d3571ca62cd6a9138b0aaa4673b09dec78e540e1 v7-2-323
+d38420e2fafe99d58b915213b73f8d1b8c7848d5 v7-1a
+d3bbb5dd3913b6425ffebd18b232fcc2d1907046 v7-0f02
+d3cff90680f3f985c21e34e03607a5808ed4dcbe v7-0-144
+d433f43849ba1dd0006dbc4d794cda3502fc24af v7-2-332
+d4b1aca2e3a97415460ba21ec81eba2218cc0be1 v7-1-128
+d4bc24e6a28144ebb16f143efb72ffdd98bbe0fc v7-0-156
+d4ea645c77489da3d5f0f0f48a14bb63793e1505 v7-0041
+d4f3db33d782da9d33b2715fbd14f5acac280ce0 v7-0037
+d51bf80e8fc9b1048c93bd26e308af7c250ef629 v7-1-045
+d5681bd2661b3e75b506a7d6ffe8bd053e04608b v7-3-013
+d5867fd6b2b72d8095795f4db9aea88035e49e5c v7-2-330
+d5892839ed90bb1a8f9f1b3ce88bcc205e7617cc v7-0156
+d5ec1b42ceb06062f03d828acca852a4ccfbc7a4 v7-0111
+d607b48414b79e7cacccb66391683b23cf1b2cbb v7-0-099
+d608343d25e6ce4b1e6435720c48762501b0fc7e v7-2-197
+d66394147eea6cd5b304fd2b78e5dde46fbb1b02 v7-2-136
+d6a69271cb9a787af6b3a05b01275c9694a144c0 v7-0194
+d6d6ca94371317962df5d92c9b879f7602d3e234 v7-0098
+d6f0d3db1c641e451f9cb0d0697f1b18939d6cf7 v7-2-087
+d75027183cf4b44b2a92333e57b9bc3fe2b2f5dd v7-0-230
+d763e7d7e938d8dd3887b7279b44e3a857285d38 v7-0-189
+d766b2ba2fc6d5b6211cd10d90236dfa8479d617 v7-2b-002
+d7860ee7eb7ef5c27d45c4569107376d3cbdbdef v7-0207
+d7ce3adb8dda9d7acf8aef39cda0b936ce3f3d15 v7-2-362
+d7e33248b9c80fb5c1af5880d6c6a4eb507de990 v7-0206
+d87865573d809129e6d25071cffe8ab451ea2db2 v7-0-041
+d88bdbabfbc6539ce6cb149a3e8b025740a7f351 v7-2-109
+d8983769c9ddbffc13ab427a5e44693070d7788a v7-2-361
+d8af28dbfb80aa6c6248000b011bc9df6f8f337a v7-0-152
+d8b9701a3b7bb58e3f7f2c72145a0dfa33501f31 v7-2-193
+d8dbf7d55c5e9ac3e345eb1b2b86986be3582fdd v7-0-018
+d8e7b6762aaaa48f6bb72b1c51d535119e79c379 v7-2-096
+d8f905020502b0f35d810f27b4d5d28689bb7764 v7-0b
+d9030055c432b20797f883c956f094416e00c622 v7-0033
+d92358c7d6216ff56093067384eb7d96ae47696d v7-2-238
+d92ac5a199fe88f1630678f81e0b47d5f3f1a921 v7-2-196
+d92bab35a16720d2b4e3a2b836fd68df0ee00aca v7-2-234
+d94c322508140c4cc0d36364d994f475aa84f8d0 v7-3-075
+d95676480093879730aed5ba678e3e8305977a4e v7-0-067
+d97518d6b3257b4ab48aace82f9197bd099ff758 v7-0063
+d976f4da2a4d56ed9b59c61f6971ec0cb18c84db v7-1-264
+d982226b7aaaff40647eaa5ad05e01538e90065b v7-3-023
+d9cc61139d12c315d790d79890402ef957be00ff v7-0146
+da0991871b02a5ba7bce7d3c1180d01d50d7646e v7-1-017
+da1d62fe5379f77a2a165e40bf4bcad0466c60cb v7-1-063
+da9142bd190a5ee0e45536ae4c2913be5bdb02b6 v7-0149
+daa1e34570ff649af9d7b64a447cc6d2c0b60e38 v7-0-093
+dabcabce3f9d67ee2cd22246ea16769513982910 v7-2-419
+dac5006b4443f99681d2068d0af065bec10d7a99 v7-1-162
+dae4cd29a0b7d899201c2e6a10f0441e7173bcfd v7-2-347
+db3ca1048f7f800fec81696d29ff8a7a3027a64d v7-2-320
+db44f7b81373a02990aa6030b85024478b7d82bf v7-0f03
+db83098657947521e0e797662c135516a4a300ea v7-1-123
+dbd226be80b18c494f4438045d34b65530dcc198 v7-1-027
+dbef8434a2ea19482b3ba72b428c57dafaad29a4 v7-1-329
+dbf53ece2e23fd6e8652c531ce7976f54ae85635 v7-0029
+dc8197342755fda6ca4d6619dac228406867a7ce v7-0d04
+dc81a4fc63185c72c940e8ade45b5e1534523351 v7-2-143
+dc8a5699253b833ec796460f9ac877d02ab7b165 v7-2-406
+dc8ee74574f80c7eabc90ff7a3973f882993cab5 v7-2-444
+dc948c8dfd1550972011e38d59b9a8ade5a000c4 v7-1-019
+dd9db57ee7ce46bdc86cd787fb58907f20c0a973 v7-0118
+ddafd2ba3a863054041f2f71248f0ea91fc3b1d2 v7-0-117
+dde812fb22478c1fbd34d935ec466b2cd9869da4 v7-2-437
+ddfb6f3f3b2be6e5397db2601f392c45f4a05b84 v7-0-012
+de0e7ca61893d31a4a5ad8e129691650e31477c9 v7-2-427
+de8224965034eaf748c4205cc2a61e097b4aef90 v7-0-063
+decce137e7beaa2edbfb4783d1cac714c7d84d14 v7-0-098
+df6967461cef05aa96ff708863d380e9d15f3bb7 v7-1-065
+df6b12c84b2359415cd987c016f5de135c680100 v7-3-047
+df7ceb64b0c65cc5ea525f7df25ecdbba80b0208 v7-2-137
+dfcff6590aba6d93a69b414759b164c255fda08f v7-1-238
+dfd5dcc73daa3934ff1f47d6d53207de2f9034ed v7-3-067
+dfdaac31aa5df021b444bc2ba64307709d863c63 v7-2-230
+dfdaac31aa5df021b444bc2ba64307709d863c63 v7-2-232
+e038754d419a3ab5ec25d014513bf8773cb9459c v7-2-408
+e03cb9499b83f972c2bdef503b1faa15481da81e v7-2-015
+e06e177de52ae555685a6126213dff168048fcc6 v7-1-305
+e0e0d1ae601197ad22eaad3b721407a2d0cd6294 v7-2-318
+e1070b3b03e9b1490157dce8db81b026460aea35 v7-0-081
+e10d3c07344929c21377722bd3c66d3c54ef582e v7-2-423
+e12f574898a9b21e39af38cd57e50ca87ccdea81 v7-2-272
+e1336150cfcf7e64f66563629accb1cc84fea036 v7-1-089
+e14d0a530351fe26450893977197e81e9e9ae5f2 v7-0-177
+e180933b876a74ded043348c0cff4fb209d4d92c v7-0219
+e19ecdb13f34ca1ccb3dd3c382a08423c385e847 v7-3-080
+e1c7d0ea5dacf4184cf49c3d05d6ce77d944a367 v7-2a-002
+e1d77e652cb7f9e84072f16b3ac6dcbb73a1fd81 v7-2a-018
+e1efa991c2b6992bf361cb432895749fc6b1109e v7-0-106
+e212d1a40ca9638a4b306013d54417dfcbe9d8ab v7-1-243
+e2680bc6a18024d68ce8100e21d4d307dd647aec v7-1-011
+e2d7622d70894e506f9c722bc8ce145521d098b7 v7-2-106
+e2f5c1597829256cfd784681163c232bf907f1c9 v7-1-092
+e319a4fe6e32e0297f1be2c1a8c763f7f7b26cd7 v7-2-378
+e351146e7974acd49f2e9aab749f31670b2c6044 v7-1-116
+e44523d45bf5e276817b7f1f8987f2a8ed3132b7 v7-3-125
+e44efb3af0d58fc58a392e58c604bee91bc52e2e v7-0-060
+e4fa26ce87694c7d810796d41d0f03981e500d1d v7-0187
+e5145ff9c9b0dd7b29154c2ffd220988737c99f7 v7-2-285
+e5602d92da8ccb4822917b2df3e6099344bb4ed4 v7-2-177
+e625dad74346d76132cbcf6ddf98b95d2c8fbfe5 v7-0-113
+e6372ac3ebe536aee65848e52e58fc817697b98e v7-3-063
+e641c7a27c470de82019d313a158a9894e0befc1 v7-1-181
+e649c78407e600ab28819574efd7d2d67f066171 v7-0202
+e65e50609469f1c5d98ab7396803fb697a78bc17 v7-2-219
+e68d8541494dc36b5778d9eda2814014201b0335 v7-0228
+e697bd3c3876c27addb414ae170d741aa1eb1917 v7-0075
+e6a8d55a1626baa2e38837b0e7a4a6bc65783623 v7-1-178
+e6aed39f12648124b0b4e23c669cab6ceda2ea1e v7-0-158
+e6bd96f2d7b81a8963c9c8dcfd9e2b3f08a9f0e4 v7-0-017
+e6d25347de2cc7f7632cb0cbe5adef45d9712aca v7-0-182
+e70aad5761b59933a1f69a8756457fdb3a9aad40 v7-0-069
+e70c0d863e0cb2b26f16acd17ead7ed267faef53 v7-1-022
+e72e30c69d582a55cf3c4836aa274a006a457fe3 v7-1-261
+e73f2978bd4061868337a25ff09c3c84b54dd2da v7-0f04
+e753954c86e2ce32648d9b12c3c135c22748f75f v7-2-237
+e7633eb32cfd9cd631a73f4d412272506261b427 v7-2-098
+e76a088056dd38e02a99daec0741aad6f32a24f8 v7-0-242
+e77e3c11f5076d6eae8a67bd2f531f72d33eed7e v7-2-331
+e7904492cb75b7a69964c331945b261cd4232a7f v7-0071
+e7f6ca5594cf9c6a3902458e0635bec7a7c40d87 v7-2-149
+e8450dbf6f031f2727798a7d955e83dda7ba0288 v7-1-086
+e856f9cc2aee46628ecb83351489d4f41d66c6c6 v7-3-064
+e88950f0d4f699846875e45dd3887cbdf92bc3b9 v7-0-084
+e905716f6a3aaba3c0ba1d18093d4f4f09550524 v7-0-090
+e943e5502fc9cc439294de385dc564226b7311a1 v7-0050
+e9624acb93a750d835c361c08bf3e78f587f6510 v7-2-028
+e965cf54d887eb9bc20b6668d83541992cc4e8a7 v7-2-157
+e97a97d6a0eb98b21bd068283f192e0a2f2b1a89 v7-2a-004
+e980e93d2ac2c7838acfd45fbf2de06939c929bf v7-1-186
+e9c9f37be3066d64d7d87d1b314b2913d0d751f6 v7-2-416
+e9d018b58830d50906a81e1b1ddbb3e2bdd9126a v7-2-107
+e9ddb2181f063b67b3075844b4aa7359db5750be v7-0155
+e9e3355861ba8785dba619e2358a239a9443a580 v7-2-342
+ea15087a42cd21520e628faa3c53385246c04743 v7-0-085
+ea1a2950ed16f441f66ba319615d47f1ac67402c v7-1-191
+ea399ac2c1b963b068beed88bfaff7620d345333 v7-3-138
+ea9f418ed072f45fc1cb04e455379e3db1c0f182 v7-1-215
+eac2556d46208785a173d44b4efff339a7e2fab8 v7-2-215
+eaecfa88c2469471804768932f823f5b264dd0b9 v7-2-148
+eb0504d00480ca6a7758bfa35d64a09b3d389fca v7-1-250
+eb1ce51c1cb0dc7825570f7cf30b0e2c3e9749c1 v7-2-129
+eb27e3e2df706466ccf9bd00e407d2d3419a81e7 v7-2-265
+eb4ee2010aae8f4361054eb367a7b13dcfd738c2 v7-0-107
+eb531146be0ec6cce1187568cc841718df44a296 v7-0114
+eb57516376d4b43889fe43594048f183af15c31e v7-1-032
+eb6fc577c96c2b5e322ca3760fa4e9c043ba5a8c v7-2a-008
+eb800128bd894e9b2c661627d2a302344162987c v7-0-092
+eb9cbad50fa34fad2b422758d6d814059aa89f94 v7-1-313
+ebe059f69b9e46ada2c6e02b3979e31d1b11c906 v7-1-296
+ec5ed41eea2f1d83df5a2507ab2f469fadbbfbfa v7-2b-001
+ec7a570696ac0e50147e2419d8b269ccfb75f25e v7-0-199
+ecc637a844592d48cec38bd795a17ecf6e0253ec v7-1-114
+ecee28dd16d25024fe584cfb8cd0923f1184398f v7-0213
+ed44c1c436d3d61a94062c7a781b77dabeb8ebbe v7-0-100
+ed7fefbef738386c39248b501556bdea80d0f8b4 v7-1-276
+edb3bc186e97a3392b3aac634526a4f4f84f4011 v7-0-020
+ee41e031dfe14ebe50c289158213f05eca869bb1 v7-1-179
+ee50cd1a303271c6be6cf6121f50c0abb8772dbb v7-3-088
+ee9d2d24ea9bd0a7d500f1c37cbea802d8d1d88c v7-1-231
+eef96cfdbbbebe5aa61b420d3eea31c3c5b6d719 v7-1-314
+ef0fe6201b843f699b3ed7483e52eb3348ae5b11 v7-0-006
+ef2890033e88391e92eba7d1ade8a43e9e200abc v7-2-337
+ef3a3ec8940cb0c55d35d2e5fe924a09d6815f2c v7-3-070
+ef6b11bee7d06a843474888d0bbd67d14dd2065d v7-0-181
+ef7fdb3c6927725abb07731a46ab78404ad4c7e8 v7-3-105
+ef886129f0c0be912c7b6c21e695bd9980d31210 v7-2-088
+efd0ce477ae789445312ebb08a0f78b835dd6f5b v7-0-194
+f012c4ed8c38499ed2901d139f4409e2edfe51da v7-0132
+f016c3708ae32436ab545762a1bfb8ebd31af975 v7-3-106
+f018c759e4ed5e1a851c1353c118883efab6a155 v7-2-274
+f04e890524be4a82ade7526f62a967390d3f1cf1 v7-0153
+f08390485cd365abce88ade8987e56bd267cf3e4 v7-0210
+f099adbff8871627d897979b432d74ad1623369e v7-0-031
+f0b3b9ac2147350b1d1fd762cfda0b3073b0bca3 v7-1-161
+f0c598082dff6f0332c9af602b5b4996bce01ff7 v7-2-104
+f0cfff4dcc2f7cad78ce86aae0f4cbd3371ce46d v7-1-283
+f0d6b2bb1093eb12925cea635cd58de0594c422a v7-1-245
+f10fe14748e260eb0d8bfe375cadbbaa0e5ceeca v7-2-055
+f12d38ee49de595d11efb50674bccfe0417c7063 v7-1-006
+f138491673309c018ffede08cd4858c3bf318dba v7-2-169
+f13a0227fb8844e591b6526e4393c8f93dadda29 v7-2-305
+f14cbd913415ac4d6a9968dce20a20291f8c0d05 v7-0097
+f14f7aab518707c29a8ffb75a4e8217de58dda91 v7-1-212
+f1d1214744679d401e17e9ba97ecbb6255696ed0 v7-1-287
+f1d2a58883b96144abcd5b44dbdd190a67b3eb79 v7-0024
+f1d46f94824128251d1212cfaef0b1bfea4dc71b v7-0163
+f234c87ac7e9807004cdc559cf68aa5e04850f5e v7-2-248
+f26d0c74a329cceeed80a7985f5efb5662064283 v7-1-039
+f2927225367a3ac3fbe86d6d03ebb7a526072ed9 v7-3-039
+f299f0bf32d76986d5596d279bc0733cebe1942b v7-0-211
+f2d46e4a859d0f12f12fbf332c40a717dd07df14 v7-0068
+f30c8ac7741c82503bf897fcebc68f199e5b0998 v7-0225
+f339305875fa7cd21cb4d42619f5b9789a027eb2 v7-2-229
+f3669fbc9a31512a0b81fe7f647b935243a76520 v7-0-109
+f38283ce871c19cb82b1c4d364fbc3a242c057bd v7-3-131
+f38b7359dafd1f168a15698412d266c17a16520e v7-2-102
+f398e0cc5b7a032f327aa2f33b71c3bb6a22d46b v7-2-349
+f3abb6aec8c83ada21d56b8be4ffc6be55ce39ba v7-1-048
+f3d3545d6bf6405662476b40e019044b880d8f81 v7-2-058
+f3d7fa7dcf634b669a7d7859bcc39796300346e0 v7-1-035
+f40f1a8520ffaa57ae73a720c179780025aacd64 v7-0c01
+f41b6108e46b7cb3794b2a3680f2ce91b402fb21 v7-2a-016
+f41fa84cd738b945ab34271a92f44e0d1445dda2 v7-0g03
+f455396f3c3fb524ff1082cfe2cd7731f67877b0 v7-0043
+f49d72bf9c5c425dfb8bb94c6bac975716e3023c v7-0-124
+f4a775df722b13250c2b9e6f1154c31ffd9b211f v7-0145
+f4c7b5da017adf78554a240587384823e58ba80c v7-1-012
+f4f8014d516e9b9620311aa2bb7a5a2d5749f451 v7-2c-000
+f529edb9bab3de35ca7451e4d45cc90e9f7aaf81 v7-0025
+f54dab7cebabe6aa275dd6a379b42a15c365af0a v7-2-280
+f55897d6921d622ac2649e4c94ddb38d121c2832 v7-0026
+f5bd6753cdc40733c903090cef1cff033942dcf7 v7-2-440
+f607f15ab091b6a51b0546db6a6d42adfa599c3d v7-0143
+f628d19361d9812a1266baec9f76d60c798f92d5 v7-0-195
+f637471a3607a43bab09a2b61913201a5100e636 v7-2-192
+f66abfa335bb76d20f2a375f148fb7705bfde287 v7-0-170
+f6c72dd1962a46aec26c7caac6f1c3789321e91f v7-0-030
+f713fc55bf7b9a5cbb9ae3628547a78f4e44bcc9 v7-0109
+f765f9c139de3555cd181bd4fa8de50d4aaf41c8 v7-2-158
+f798c90439866d3d29eb0fa460d51e4de26f27d8 v7-2-224
+f79bb032002565143e3392cca0540216e7f93e28 v7-1-241
+f815aad6c05549bfa36f193dc57b1f03d646bb79 v7-2-343
+f84061aa57e4498f15155a4a30da40ea07be84e0 v7-2-030
+f85fe1a05c2ae4c03994c9ea2eb87da590bb3214 v7-3-133
+f88008797313e07112b8c4e549dc2217747fed98 v7-0-101
+f892bda292a89e7592ccee5fc0e296659066d7c5 v7-0198
+f896a7dfd47d15f11ac663f132fa2c5aba91c829 v7-3-052
+f8f35d8208e6c242026dcedd8300b82f415fc59b v7-0-179
+f921368d43c3f0b9b32f52f881e7e58242489bb4 v7-3-093
+f927ca2cedb40441abcd9cf5e18cbde2863761b4 v7-0-226
+f92bb184582321910573561c941167ca46b9850f v7-0101
+f9366d458bd09b73aa46cb202c7c6329e608bf0e v7-0-217
+f959cda54600f8d014cf3a3c69285c598985d828 v7-0-027
+f987220caa57c4d13b64fcfd24cb4bc6a156bb00 v7-3-094
+f9bd6784f393aa771d497611b75a8623c20a8269 v7-3-009
+f9c55e12835e88f072c46b20ac9dac25a46ca839 v7-2-218
+f9eaf0a9872df3ef8610d3fae404231447954d5e v7-0157
+f9f6e35c9f00ee6ee518069ff2bf0f93b635b8af v7-2-005
+fa07532e69c6eec9a6860ef1362f1d8187b8244a v7-1-193
+fa5dee44df3fd23f96090d225dc11dbc4de7bf20 v7-3-034
+fa7e62dd58d779149c96570bc8943f1a1b035e3b v7-2-364
+fa9ee618000f51e5da6c951f24c9bab78f2bb428 v7-0-110
+fae6fb779a6be78f2609dac4fddb8da508735dc9 v7-3-048
+faf4b09c396e8572e84eab84eeb60ea0f3785529 v7-3-097
+fb1222c880fc037f9b76580423c5a57c74acba28 v7-2-344
+fb60c9f35517660092b161abc1e4aa17a7d0ac05 v7-3-040
+fbecb12e37f5b1523aa8e6ecc07ea6c07ed65270 v7-2-131
+fc0c566b91075643f259863d171bb253703698bf v7-0-064
+fc2ee817dc9861774c31bbe768cddcaca4690e4e v7-1-328
+fc42d9cc7ad054a21ac8bab2584732ebb191e5a6 v7-1-258
+fc89a4f98a8b2e51dcdd380a7eede9dbc5cd1282 v7-2-184
+fc8bf5d4051a1c13085db00c902092215ac9852b v7-2b-017
+fcb916bed51a5ae096a9f5f5f697a909b2062040 v7-3-055
+fcea35e2a41fdc928cb92784a4405b4fd220f560 v7-3-112
+fcf44bf1218f63d94e1807c05f470a4eb87e61a3 v7-2-209
+fd1b3406fd1cbe1e7250c95f7b30604d7e46b2d1 v7-0d02
+fd24e02210c9c05b4035ebc717f25ad64d20470a v7-2-276
+fd3346e3ccc02a11f0c2fa9c2c7351b3cead3941 v7-3-082
+fd68db1a72b5f05cc5e586ffe89a10ec6930005d v7-1-199
+fd8864aeb52aa72333573d62f0a9913b0d3e8c8d v7-2-373
+fddea6c03deefda18c971466e0688d196a62fd6c v7-2b-004
+fde086181841aa124af8a38b5c0bba132de3ea94 v7-3-002
+fe26299d6f7015c324bef3829e9ecdf7d08526df v7-2-239
+fe3ec5ea62f76a623c95a2a4bcc0d396c83488bf v7-1-303
+fe4ebbec775a55ba5d9bec6070d8d87dc28138f9 v7-2b-014
+fe52f9888eaaafda72e6f37610327206383ff6a6 v7-2-034
+fe7db192c7cc7ef3d8cdc6bbd8680833338fd7fe v7-1-299
+fea3207b800d97b802892d8edabd1d688817249a v7-3-096
+feb9b421585385b226b4adb98e10f33972068846 v7-2-042
+febddd8d11b0f8f48e3d3297628fcbfd9f427b19 v7-2-112
+fef4bd7afb263aa411f12ff13dd1d12c88ad992e v7-2-438
+ff3a304b4ac2f672e8cc3c60795f0c79c5b191b1 v7-3-066
+ff5a4a71a761f859af81821d340ac609d9309083 v7-2-156
+ff77f541d69df4e538f7db4879eb194378c04458 v7-1-252
+ff9ecf14efe3e2373f2b28fc3e32db4fe19e5ee1 v7-2-203
+ffa17de19445569ea573550eef332323d83e70bd v7-0-016
+fff7028d50c8a44a6285ab23b451d975764b8bd5 v7-2-296
+62e8d93241cd15962f895da4788f21b514238b14 v7-3-142
+632f43801ddb568f872599499fdcfd9522f8c13f v7-3-143
+322a5c8d392bd47ceebd24cd21dacf70409fcc91 v7-3-144
+329a9676040c3182f78e2014322125f8839b5cb6 v7-3-145
+2bd574a2ef1c0ad487a0673a5867b09cd332d176 v7-3-146
+55fe8407514f5387ad872a338d77f64a2ad4b5f5 v7-3-147
+d67916de812ad684718c02e3ff93455ce577be81 v7-3-148
+7f937a04cdbafd7d179b200f75e988408f8caf3c v7-3-149
+6146c9859f6558d618e950fe702c11e41ca21105 v7-3-150
+f169a51f7eadf9a07ed95161143e6209387a4f34 v7-3-151
+0f7f66682a5563c76ab47e9976fd590d9423a013 v7-3-152
+d0cae598360945a425859bf8acf22923c29501f4 v7-3-153
+d72d709f0e18c309069e42d3d7865d68db9e89d7 v7-3-154
+5747cd65d62b613d5060254849ed4bc1e1e5d714 v7-3-155
+7fb8cdb9cb25e1409abe45bba959f5f27608d713 v7-3-156
+9a98d8562637d4c90439125a14224a3403d8bee3 v7-3-157
+b5f774f159274af375455f32d628881c027417d1 v7-3-158
+415c55534d901aa4617bf584462faf0c7198e07e v7-3-159
+c5e47b752f07a95534bbfa83f031a58af67054cb v7-3-160
+25672ad7f377341ff1de9a0773d8cfcad1d37883 v7-3-161
+18ad854f5dcd0ba1700c73b03677dbc88b9844c3 v7-3-162
+e8f012b00187c5a957def85bb3c6f0430f20fed5 v7-3-163
+cdefcbb70e8cdc1f7185f1023d3a4660d30a074b v7-3-164
+e92a4b9b4484d1c07d930719ab1370fcaf94d3c5 v7-3-165
+5ddb68c2a845ad7941d1ae7533a81c12b106dffc v7-3-166
+0a0d7961b4fe83151b03d98ee904ea7038f64123 v7-3-167
+930b171ce3fc9dbca3f9da6bf883faa725593c67 v7-3-168
+5f45bacf31efef21f9b60543504d1832ded3e098 v7-3-169
+64c3402df964791a7b8c925905423f83af83e930 v7-3-170
+1bd8af13fb434e4c99bb756052556f4d56cde200 v7-3-171
+ee48b3da9d53a487f3636df34cace6400d13f32c v7-3-172
+133d089f247eb7156a6e8c49e0526f41cc082c3c v7-3-173
+820f12659c50890dbda80e7280086ae1176d1378 v7-3-174
+537e0102c0f9cc2c0656c298ed1534ef30176eb8 v7-3-175
+94f42ae4e4e66483fb6cc7305c61820b004c6182 v7-3-176
+66f2d62271fe77d4acdda5808bd0d3a45be3149c v7-3-177
+ac639ca9f58f7c71551c19090473395d81a021b6 v7-3-178
+11e62fb6f8154537f92be5f278c31e737247f781 v7-3-179
+ed47d18b39c6a672ad4f0caa2f2c3ee897e784a7 v7-3-180
+5381eb5b1eb9c39797c435ad904bfcb71f1efb01 v7-3-181
+21346361ce6c7e9afca2e475ceb62f6244197919 v7-3-182
+e4403440e192d082af7dc8fe3e1a12d24f0e259c v7-3-183
+b941cc96926a26b62d59f759a021ddb5b51823ed v7-3-184
+9c8dffc62a41a143230f76376f9a3abf46ff3536 v7-3-185
+3d1a3aa0240c7a9acdf3feb77b664798e3703463 v7-3-186
+8bd38abda3149cce7043da86e6093dbebecf63df v7-3-187
+f2e1c3a90a3bda6ce8977187b365745efd4e5c35 v7-3-188
+71e1da07e1414740d1d0eed47a346cb3292a9e2e v7-3-189
+30b7cde2194064040cb7d7e6485a5712b2fc9b40 v7-3-190
+107b03fdf1ad831e2697c22a04bd3eeaca08c291 v7-3-191
+8470ac4679c17b69aefb06989c6e8a267761988a v7-3-192
+e1c5f69de95b99112fae28c23ce6427ca251e50f v7-3-193
+664c1adcb909aca654c4fe9200364cc741068803 v7-3-194
+8dbea5adc937ecddf8ca336856cd487e1b118b1a v7-3-195
+d641f141f9376b3ecf2146e5d68c38bf0227c970 v7-3-196
+45c536fe48db330c4ee8f1056befe702d9d19cfe v7-3-197
+b0190e93e601f9061a797689a1eb95a86805f769 v7-3-198
+c76efe33a3c1db5767cfa4f4bb433466cba6e351 v7-3-199
+41b17dd070295783af37698b1229a7052ab0549c v7-3-200
+78859ef2982bbc75dcfbc551e3d8a0ec5c9126eb v7-3-201
+f80e67bd627114cf7f16098ec4ed7d878816a46b v7-3-202
+ce1dce2af2a34aec196b7fbe29cf8c653b6ec6de v7-3-203
+e6ce47f06836721108394f0b921af076606cf715 v7-3-204
+8d8bd6307b1aa51fe2f592ce45d32abf0f6666d8 v7-3-205
+46544d3ae7ecb245a2646ae5005a3d67ca380f88 v7-3-206
+d1445b72ddb7d8b4a44393756b00d21c81212db1 v7-3-207
+205adc87d579512482c27f309c73d5fe8f612ff3 v7-3-208
+82cd9f1e8d6b21ef4d59f27b39f041d5cddec19d v7-3-209
+eeb1ac4f66d1d69c0c75f1028655a81890cf65c2 v7-3-210
+c7d942260772003e21039f9891775b479311b40e v7-3-211
+6bbdb9c7a425b0bd90d5823eba9475b850a409fd v7-3-212
+493897f8bf9057aa0fee4c18d269558d32053cc7 v7-3-213
+d84a564f28c9e64c3c2a1689af0e0851bc7e5027 v7-3-214
+b7523ef31e23f1a40cc3950b6ec75b39ad7f762d v7-3-215
+eb6c704607025d89a0a5d3fd2769a694ac47e0af v7-3-216
+15705b520c298738588a9a3b8d724c6d86d4cb8c v7-3-217
+cf89a1d3a0ddd21fe6b734fd72346468b808836f v7-3-218
+acda456c788ae1b0b45b8c67a93edcccde594819 v7-3-219
+fe9c7da98b5e2f92e4212e948e98f2d44bf06320 v7-3-220
+fd4224d9ee09801ed1ad9341a72c4683e291bb76 v7-3-221
+c3b4b1c89d8ed62a2624bf9404fc79f60223bd81 v7-3-222
+4e21fd3cfc3084db66f65aef132cb6c5e076cb96 v7-3-223
+69e0783ed0ef40f72ebeba41f8c98c9992f368c7 v7-3-224
+c249d9aa60f759286f54781829c1e3da8680c4a7 v7-3-225
+8477b2cc2b81603408b3fb1a84cd65afb2aadc65 v7-3-226
+b65a26a2aa095c739e90edb7b980154476529d35 v7-3-227
+c6df8554b39d009ed146baa48c0cfb351aa8379a v7-3-228
+07647a0545c9f0fad4e1e84062e0572a07d94659 v7-3-229
+70c8f54e7efbd7b59bbe6764d0fbfa1f1602273f v7-3-230
+455a4c85d04d04c732367f915d82c5b3c9a65b50 v7-3-231
+b67d3a44262a97e7b3ae212fcffb36926b5f53f4 v7-3-232
+69b90e43b728ec28939b0a536de32f818b7ee756 v7-3-233
+7653420fdc454be197d59e420a1672909fac7b82 v7-3-234
+441d364773dc53264b5f26042f8fc6f8b77c8044 v7-3-235
+c1733ef5b6e87dde521d0d85a1e5e62259854ac1 v7-3-236
+e3bb93df6c34da672244bce5695c1426da139614 v7-3-237
+f2c108f44f415c7cfe92862e791a01cc542ac378 v7-3-238
+0bef86c5c985218a9448fa16d935b913e67af8d5 v7-3-239
+bf283e37792b4b557a2b9081e4fdb0e10acb9655 v7-3-240
+0a650db0265381b540df8ca6bd716c4b2d47dfc9 v7-3-241
+3d96ddbeb3b0003de29b736f63b76675909f133c v7-3-242
+512ddd87f1a817749c8362bd043682a7bbd87014 v7-3-243
+be6b6509636242cd7e6fab9a4b8772e97fc9a0db v7-3-244
+52512eddb876f64399e98d12643233a87c9f2823 v7-3-245
+3f1a4ed36d1b520a1ad5aa6cbf50d68bc8b9c7a5 v7-3-246
+7fe2c092913e84e6717782da1f1a220069eebbe7 v7-3-247
+57a7998e0fa8854a7a8c3946df1d4c9b1ee220e5 v7-3-248
+9f71f5a526aff4f1e0eefe1068d9534aee427afa v7-3-249
+f909f4f0f38c71594266b3595d31ce04d4ebe3ec v7-3-250
+fe6ad3fd85322b394824a5c495a78061a747b074 v7-3-251
+0b4289bcf8364854dd5f94c42d0252504103e5b9 v7-3-252
+c21429d7768cd4b834a086dd47881d01bca74e8c v7-3-253
+1eb805225de7750c03af7b0f7ac2f5dd18d032be v7-3-254
+aa998de9f9592426c17396b60c5db9170a234024 v7-3-255
+c296c225736e4489706c62c95752a0c4788be1d3 v7-3-256
+1fad9c73d77a0030586704cccab1b1a7aba8b58b v7-3-257
+bdc3335bd72eea207b28fcf8af90a73c855c8847 v7-3-258
+59130cd78dfc73bd04f22d201b8f7c0772d98e79 v7-3-259
+cb4682b959098e486977eb4b5969c9eb07d2798e v7-3-260
+410d42e3d4da09284394456186143d595e9b2efc v7-3-261
+847733973bfdd716bfafc364a4102e76f88e7fe8 v7-3-262
+a56259157c935b4e78e9f5f4dfb1436e3461eefb v7-3-263
+aa40bddeea9a44c6c6b4ffa32c1ef373df437a16 v7-3-264
+eff686fb8de66a26367f5e6430d34729f1a0e336 v7-3-265
+25be7c9dda549e4cfa1eb57937dc2b38b3d1e997 v7-3-266
+ad404f2a4bfa5374e97f29335f41b7ef34cd6bfa v7-3-267
+ee17ee712512451a54046d6bcd3ddb9f70cb5cdf v7-3-268
+7f4f5ca70dbde4e31c2de494b982bfb9bd71ed75 v7-3-269
+b9182da84c7eeda221e5219ef4361cca201b3b41 v7-3-270
+32a52f06f33b9e2d4817330099b410c1fcf64db2 v7-3-271
+02f5abca10aee570d5a9cf00928ffaa663daba66 v7-3-272
+7d4e5e31d8c10c767cdf774a2b13aedd2f95f096 v7-3-273
+1bb6776fa8c445e0b3f9dd2ed14fdf2a56f5873e v7-3-274
+125c7bf52271461dfbf46cc33317eadc67aaf742 v7-3-275
+37a54a85413eae68932233e64a0ab88c99c9d811 v7-3-276
+e5b17a5f651696ad4c523a21822692115d371250 v7-3-277
+6622f28b7e87a93de6f1520945d1c5d2a1fc0dab v7-3-278
+342b176089678e86cde3e1afac4aaaa1e5153f99 v7-3-279
+58bba69b3371d9ff02b27fe24f044e229c8aa99a v7-3-280
+45ead8a0bedeade57c320d72e9f710a703e61cf0 v7-3-281
+92167bb91c95410a0550ff8c94370307bb7d9d80 v7-3-282
+47b6d37b60122f45eb147106b8da1322c1cdbc60 v7-3-283
+27d43855b72312500e6fc2122e167a579a1f35f2 v7-3-284
+6018c815e1205e7db9328fe6ed91b26b514465f3 v7-3-285
+3f822e54765c54a1112a953e3c37bb60185fd51c v7-3-286
+07bc2ccfe5559035e785f22851365b3a31dec67e v7-3-287
+e4f3fa1a474e677dce486ea07ee31270f92b2b4a v7-3-288
+44ffd0a8abcdba441216514cb711649eb1169876 v7-3-289
+df33dba4e553f8fa27ba467042f16315c613a00d v7-3-290
+e8ee4b4ebf41abb199ea9a9e9cc38f9b0c2f7192 v7-3-291
+b6af1c5dd22f08db2b9e52ae763f193ba82965ad v7-3-292
+6cd0d6413a2e03687aca8138b2843f1f2aac5b84 v7-3-293
+dbd73fe939cf772a8b07c19230e5ee60aa0cfcc7 v7-3-294
+0d8494c051131b6470fe8af67646e235bc63fcf7 v7-3-295
+c19c15a9e9bf2914b25748c0544936e84a5c77c0 v7-3-296
+22550986c713ce5f37f069f0c8f99a54dc4a421b v7-3-297
+43b1d031e3028248abcbd5099841d3aafda7f68d v7-3-298
+eb4972982bfea006ead5b461f319744d5ecd58f5 v7-3-299
+2665b456ee59652c7b590dff0fa522ce337e0f16 v7-3-300
+4a70971530899e32058207cae683a69e7b8f85dc v7-3-301
+61b2f26623104f75850b1568bf61663597fe7fb0 v7-3-302
+d832d642f520d426f111b35102450617922547d3 v7-3-303
+b3a523ced6bd1173e4c17611559c173094830d43 v7-3-304
+0e06c025f66ffdfea20c8b73a995d23448b8dbfb v7-3-305
+0787bb5f387b79842d5c9353ae3541a992d1b9f1 v7-3-306
+880b7dd69331d1fefaf2d8735b118b39d546280c v7-3-307
+61c5e1527bd857e724f8396c89d0687126390675 v7-3-308
+6eae1b42c6684f3fcdb4d6cdbfb7dc1942d9b364 v7-3-309
+51ce22ba89d11505e18aa585fbd7dcbb22097f9a v7-3-310
+2cbde6bcc6238f41506f87bf31ff7d90f632345a v7-3-311
+0ed06069aaf32dbb2aa3827b23280b0028954ce7 v7-3-312
+dc60200a16b21c3e4157708bb825ea61b9e5bdc1 v7-3-313
+6ab1b45cc95ed56105b2130dc9938bb8344ff903 v7-3-314
+3ecf9e91d88acdb5eaaf93cc15a18914b60e0eb3 v7-3-315
+33c140e4664d102c34ec3ec5a17318f75cf475d7 v7-3-316
+92a181a1cec3fec52cde1b3d71f628a3a2dc53c6 v7-3-317
+d68f20a86a3ec75d927955be5d31983b6c37eb1d v7-3-318
+dc7f2f9759208aa07bf136deca661fd080a1ee68 v7-3-319
+738ea87c196431c452bd499c5a9849597ac938de v7-3-320
+fc0804089b2945bfe683f9bc9ee0238b8c64a46e v7-3-321
+38a7fd9043474dfb464c338ffd7f393361f5a6c1 v7-3-322
+3bdb646fc8a46ee5a5fe474dccdce098680d24d6 v7-3-323
+f04619f1fc1663f4ab05798c410e4fa35a9dd863 v7-3-324
+8aca621c00910556d4f52bd650d6841d6059d6ec v7-3-325
+d3758064ff9946d23aeccc9d2340686766647b84 v7-3-326
+9028c70adafd109ab294102f74dfb5005a20bbfb v7-3-327
+5b53cea62e5d1be2a1a36ce685c15f99bb8a41ba v7-3-328
+ec901ddc84d5c66c5d0c1dcca093584598487f9f v7-3-329
+abb03be99d661455fd3790cd25355459448fa432 v7-3-330
+4b8c614c1c914ce5d712368a75dbfea9b7e44e17 v7-3-331
+0ecfe54a273f6bc440684aca4ebe5926a2dfc6e2 v7-3-332
+992b24149a9ee0d6f417e40a7462891a9f62ec6a v7-3-333
+fdc72363229865cc6fd2da9db66f1d6e683b87c0 v7-3-334
+dc3f90a73fb375092ea9d870ae48ff31b31a56ab v7-3-335
+52526aec4afb220a1271e9a645194c42d3b2a538 v7-3-336
+176bfa951339a0a36366cbc8def41ae75f5034e0 v7-3-337
+7919a3d7333b99cece7d1a2657c89c18de78bf82 v7-3-338
+b5a2b4c0c1cac1758990ea449bc1c552522f39a9 v7-3-339
+49b08c9b9f5b72d930a1c02f00aa4128dc58532d v7-3-340
+6963603ec6dc2b47da9a7e951b2d0b3e024535eb v7-3-341
+314d9368069ec0458631ca150c202e7f724ad6d3 v7-3-342
+98a05814f1b466c87611b810eeafe8e7d9c581b6 v7-3-343
+7ba2f171cdaca18571b5e73dece426411c4f124a v7-3-344
+35f098371af699aa7e614a6397a068119b54cabf v7-3-345
+af76a61a7f79ccd3bcf64e15c73f2a3ea0eb77da v7-3-346
+72528c5eb87ea315a7c1a48f7734d1717c28820f v7-3-347
+4d4a328f199e4020457b4bf8f077622966bb3563 v7-3-348
+075acc2dccaa621998ccb1d671a987090367d485 v7-3-349
+07956eab189c0c776b79bc42235833d234480559 v7-3-350
+ff69efc4bc55d83b5f2bb68aeede1d921e8f1036 v7-3-351
+ca65249eb34bc62e82d54f74e14271be7f7f8a44 v7-3-352
+12bb368fef2c8c5478f0f8905aac381a56a75fe0 v7-3-353
+6672b1645306ceab4348caaffec40990dc319b98 v7-3-354
+d2f70593afeb432611cdb0ea2a0600c2869a20e0 v7-3-355
+c349a670716ab5e5f01b8121f3b7f07560ce0b8a v7-3-356
+e618700297e83c0d51efbb77a849ce5f0b19b507 v7-3-357
+97a52300ef2b496b6c8e2487973f134d9e0afba8 v7-3-358
+b7f0f23bf90603f83854fd1aece09fcc64876a29 v7-3-359
+28480c9006e6e6936aae05de1f3ca3eaf4d2f267 v7-3-360
+e42252611e74c1df2063955d6086f59fb3e3247d v7-3-361
+074ddc768feadcb3164973c7f7be8bf78dbdd56e v7-3-362
+c025592d7b1dd658955b9a6d2d159c04e83c31e0 v7-3-363
+b0bbaf1020f08fa6dbeb059e251127e27fab9ecc v7-3-364
+54ef99c39139cad53db24bcdc18470394d76b40f v7-3-365
+436b42f3cba1896b65ad32e791d131a7c3978738 v7-3-366
+972bd3fca5562b8752ae18313e8cb3e6fac207c5 v7-3-367
+4e9c5338f44c24d511a989b5ea50850a2b9110b6 v7-3-368
+0df9718c45b68c0aaa40934bb54b3217b0c24495 v7-3-369
+3801e4811b0ecd56667fe89172ed37a84047307d v7-3-370
+e757e1127d210632cc920d9a0d2d2a3b89be7ffe v7-3-371
+6ff80dd02b51e9bd6d3c1b0167b81e295b0b4881 v7-3-372
+a1d2f741d45c8731450db862e89eb4a650796fe9 v7-3-373
+0a9d7cf90f94945578b83883e2ade369ecfbfc6d v7-3-374
+767bb493e7d31273edc45f4cb6602784f639f516 v7-3-375
+1d7434010de186b02fd6a5c8eef3e28108a4a251 v7-3-376
+cd145cc2f2c918b9fd77dc177f69805c77e31e41 v7-3-377
+a7517e84d9b8191092ff849e520558d61be01f71 v7-3-378
+0f193ef0f4298ed632b5e9dc88c7efefe093728b v7-3-379
+534b3ef1cf1440a9e22c2efc7f2673017024f124 v7-3-380
+6cc788692b2e8e043a3d7fff4e1efa2601ad39c7 v7-3-381
+2260435283f2ba0ac8d0b35e216b297605ef81db v7-3-382
+f8d2ef4512f8d78c00a7aff24fb8f99aced6f2d6 v7-3-383
+e958eeffa0a7d0ed2021f2f4b61ed9e5daf3d9a5 v7-3-384
+910eb66c97684b3c0511789e7655dce2c7ba254a v7-3-385
+1cedbee50ca65fc96eca2d360ddf886b3e7ad74f v7-3-386
+ac16c62282ac0e961afa44b556fe850dd6c8e1aa v7-3-387
+683fab13904c115b4e1f8b9ecb902d192501245d v7-3-388
+c97c3272d7a67a2980ddc291f12f09c36568c54c v7-3-389
+48252b5fd17042ae95c6736073ba3c5b12820f2c v7-3-390
+819322e0e93e50c04fa79163f9b88085cbe7db8d v7-3-391
+c4898d6d73a2ffa55fc91f79f8e110260eda29cb v7-3-392
+e0248b732a5cf0c4e6d61253564f3f855d11a755 v7-3-393
+927c7377cf49bbbf87d12863c2a2d462c9cf97a7 v7-3-394
+80c529a5650f1d70342f18c681b69d7897495006 v7-3-395
+2f075595590f498f1a9cfc42dfce24cd0d980e96 v7-3-396
+75217982ea460e7bdfdd2517d8d4e4f0d0ebaef4 v7-3-397
+9eb7fdfb5e63ad98f6feb81b03566fbdc5ebd895 v7-3-398
+ce6afdc00290520fb2d9677b44a0cbb70bc401e6 v7-3-399
+320cc46d0eb022bfb24d1b636050becc83ac0014 v7-3-400
+1251e1ce94610b265d3c1f636d379a0504cf2ae5 v7-3-401
+4eda43e1fce06ef32d0a79721fa0a6850a72b4dc v7-3-402
+5850b58276918de8edf19ece0bd258e179967af8 v7-3-403
+8b928bc814a8d502f25a06ddfa66b0474b89a73f v7-3-404
+c75a8d2404bd4f1297aafbb10ab1ae68ba678249 v7-3-405
+fbb23bd517f8614f512cd81b253519cbf4548863 v7-3-406
+55cebc7e5de078ef323a94ad79319c0ab33b09ef v7-3-407
+1fec3c62f6e8065c2f7ea7422213e78b50032de6 v7-3-408
+7b59c2c032ca8a15425afb1b519c809abfd572f0 v7-3-409
+5cf2a671d8ebdf46590b8fe349ad2b6f84eed868 v7-3-410
+8066fb7e356481b52019a52696072594d2590d4f v7-3-411
+aaee6093302281b70798ae4dc599145b95891908 v7-3-412
+821c8be2e9d604282481f50f7c5a1a210b9b1696 v7-3-413
+c7861dd3b593a2011ae46dbe43d78f44cdf2d99f v7-3-414
+e7e4dbac7ded5e048e289c7fd92c40e29f775758 v7-3-415
+5c5ca538693fbfd3a574998693094b48f19ec12e v7-3-416
+5c5ca538693fbfd3a574998693094b48f19ec12e v7-3-416
+22a626604672b37914ae929b0d5e11e3efb0d79f v7-3-416
+63d3541d07339c65d602bac2bbc72d755b416ad8 v7-3-417
+4500a0ad2e0a24f54e5c4b4a3266456cd5ccb2eb v7-3-418
+f4574729f6df749668df181a9dc09030f37de2ad v7-3-419
+ded8f5add04c9477c47098a66991f971324787f2 v7-3-420
+076003f52582c2ec0b4851df539edf512945778c v7-3-421
+60f6df978a413952e37d03b85a50ca858456b53b v7-3-422
+b7811ab264bf31e0049e7a9b689a399ead6cbda6 v7-3-423
+2e4539dc2de7da0aed83286304d1afeb0a4cdb3d v7-3-424
+7b17a38eb223b4b56327f019267c1156121f5c0f v7-3-425
+c70c005f61fb08ca032b4eab533908cfc6e6f40a v7-3-426
+45467d77047df9134a7694367bf97344441b1b3c v7-3-427
+d473f39aeadf6d022e520968db17257b42b52b61 v7-3-428
+c9366ca36f6feb95bd8e01dbed9973a404f5391e v7-3-429
+a9f8dd20a49f9b8296a6ef6d9e17e3446c0974eb v7-3-430
+a27fac494e709a3cb78399f5dbc5d807a1dc7a46 v7-3-431
+81201fb337a58a58cbac43c2b89025c681361df7 v7-3-432
+8a731d7f0664b13176afb640ed0325949836962d v7-3-433
+636c2b1cdc8b6cc5279ac7d5986da1085484b98a v7-3-434
+afbf45d854965f9e557497ab9d4d9aca87e220fd v7-3-435
+2a6eb75275d94b864eba6d6135de650a903a4a7e v7-3-436
+539613ce999d3a938c602a6b6eb230fd0d77a1d1 v7-3-437
+bb67cd961fc3011d367357c215a0603dcc46ea40 v7-3-438
+dec4338a7da22b02e7c7cc65668d35db264d3400 v7-3-439
+e3cbb11f3555d5dbb1cbd3daac4a958a9e1f01ea v7-3-440
+af4ed13ca541f034e3241f2eda1abdb3b45d1770 v7-3-441
+198ec1fff71a44a35aa7a59b4952583a82a296fa v7-3-442
+de050fcc24cfb56a7dc07dd283cc1132d774e7b7 v7-3-443
+72146e7f47fa647f19fe419f4c8602897880eed5 v7-3-444
+397e7e49bb0b831f7260d3ad70f6b07175c44a0c v7-3-445
+20ca2e05ae20ece942490182691ed45746f64cb6 v7-3-446
+6a03b0ea2e12d748c1e4199e3f428ee080760939 v7-3-447
+756d712b3118b896b57ddb4f4c071135bc031607 v7-3-448
+9ccdc4a69d8ff7aab8abf89f9a3cc9dad12249dd v7-3-449
+3479ac596f6c4b38849d2e5235ad590378605eb8 v7-3-450
+045fdc5b6056a18579f28b40a4914f4a7cb8d4a3 v7-3-451
+f1cde9cf023e15cd1bc26ae720d6380fa5ceac7d v7-3-452
+791baa7b35e1b6244cdecd4a2feed933f78fd84f v7-3-453
+1632640a24b42a9193eeb8f6e8150afaeee5ee35 v7-3-454
+e6392f2aed4c13170664b4ec13dd2d8b3ce968aa v7-3-455
+07fd030f89be62aa11c4ea1a188ee2d8f4348677 v7-3-456
+4a2744311b3f3c8207189dee4ef405959a2e2446 v7-3-457
+da670fb71d30a1eefb07b19256f8c0d677807550 v7-3-458
+cb2ae92ce106de532c53f8a16a82bc2bf6edacd2 v7-3-459
+981c7ad9dd48cac1b4030b97c2f0dc0b8fe82337 v7-3-460
+de60f6fa3d8d77442a39ec13efef89f6ca76af03 v7-3-461
+70eff6af1158f9dc99118ba73e81f456015c3ebd v7-3-462
+8e0fe5a723adfb45c44978083db7aeac11e6d72b v7-3-463
+43259e4542c76e950fecc86114c43065064d1b34 v7-3-464
+d1096a4e96bdd5bfc0ce2f1aaddcbff1475c69ad v7-3-465
+df9c7798b5e2c022310cd12e199c9de8d866aa39 v7-3-466
+276d58e9265cfee76c04bc5450681090900a16f4 v7-3-467
+38a1357304234dcea96f96019abf0f3e5ae290ab v7-3-468
+e61c3b09ae86a8a448ad2d028df6fa6b9778666b v7-3-469
+636e4db6e2075bd22640cfc8229af62059f8ffe0 v7-3-470
+3465a9e7758850684d18a9bb11ac033efdcd1755 v7-3-471
+8332129d9ae8f11f8ecb9f016e5292c6582bbb4e v7-3-472
+7f1bce9c9b79d4ebbf798d6122612934d55d70d9 v7-3-473
+7613c9ab083f3e9262be5a21fe086921b757da4c v7-3-474
+36160830a5e8d0e3b4174aa7d98363623468b77c v7-3-475
+fb2c5a51dac7f1dbce6a0f35808927ac206c7f47 v7-3-476
+62dc0d69ab11d5b5a67c6139a0dd3e2618d2c2a1 v7-3-477
+754db405921292fc57dbdaa85e62af333dce5912 v7-3-478
+3db4282d5e6bb74a5c1094f35a81472d5a98f313 v7-3-479
+b35844f3eb49bb84101fdb276e3e69b0b8f7813f v7-3-480
+8e21ac7f2d6e9f269b057939dda58d3a31beb894 v7-3-481
+3229335d0c4e6cd7e91e6e61d791d7dff7d3082d v7-3-482
+19040069b8bf1818db44396a150acb54f47c3a96 v7-3-483
+00fa605e7d7ba7d522c627a93de6e2f5017d2884 v7-3-484
+94374e0b6267d8983a73a22166888c2282ee793d v7-3-485
+08a37c57af479b54fa327bedc0ef31c42dd96f63 v7-3-486
+21219ffc97903684349f1fcc843eb61838877874 v7-3-487
+8691bdcdbf66733c7ec1ef8161da1d4ef49dce66 v7-3-488
+c1a6e1745cb521f863e63670e6c22c1c682ab4b1 v7-3-489
+b067b8b81be9c2839df75824da2e88da24b07b54 v7-3-490
+e070b34fe35e6e8c40ec31a08196dd81353db4e5 v7-3-491
+214c7ec1c8f995664d5684da8cbeaaa86850468f v7-3-492
+bf5960ec253293b7240f59a7682f2e862dacd205 v7-3-493
+5240610f277823478983e3f04abfbed4e85141cf v7-3-494
+27f6a22ff88eea07f24163fe470b7335f3c1b32b v7-3-495
+3daba355b0c15ef66a9d2810ae7c7cc534dccf62 v7-3-496
+e34c620007be9fd805556c43fe848de521f3b64c v7-3-497
+b1a42d2522fb4ff627a0c381e994e2a598f7bbbb v7-3-498
+4a2cb025b6417b00f2ced076eb79739e03acd7d4 v7-3-499
+b36640b2f671c006fe26b573fd42347227efbfa8 v7-3-500
+d7b335626ddc7a61667cb3e23ecadfe399b676fb v7-3-501
+1d1cce57421c78884cff2d3234d3759bc858d6fb v7-3-502
+65d036fd449e488303e78d2c6679a736551c39a6 v7-3-503
+17bfcb054cb770ac685acaa349165f210bdd36ca v7-3-504
+fe7bf24804e195209bef4cd008f0bac7eec7fc60 v7-3-505
+982f84487daf102f1203977a09f2c6c76d1ed3d5 v7-3-506
+f9a865d97614940f817b76642282d966781296e5 v7-3-507
+2722f11ddc998ac7c578c68c0248b58468179418 v7-3-508
+8101253704f6504bed3f0209e9a6fcae3966c6e7 v7-3-509
+53786601213cd9f86db8714f7b0e077b05e2704f v7-3-510
+b782e2f9e6892116ae5d068249b5198bbe0042c6 v7-3-511
+454646820185cbe13e1f2e4f7533b984d3b07b18 v7-3-512
+75037f9bc97ad76bca58dbbc0ddac69cc7f5d9ac v7-3-513
+7e4428115d2cea86fcfa980097c98c11380ae196 v7-3-514
+6c318419e3310fb9658ee6ead6b4ea33def8cb6d v7-3-515
+02440d1fcc9aa953ebb7c0719405ccf2525f2777 v7-3-516
+9a1dba1f969ac4cb2477626cd79a7a6b0bea1894 v7-3-517
+ec4ab9d832b0f5308c861423d99253fa496b3a3b v7-3-518
+ebec52bc2800b8e51e522425fdca5c252e6d4f8e v7-3-519
+7bafe52b6245761a242321352daca224e6b9df78 v7-3-520
+b14842cf382bd3f99ca090c985609c6dead5f9e0 v7-3-521
+e4899d2ff5d8e552ace52b7eafe02b2c5dcdb409 v7-3-522
+d8ce4a2eb44e3e3d56db5e26d9982aeb48d7814b v7-3-523
+ae1641c4fbcc8c25d27802d6048cb0767c4021d1 v7-3-524
+ac2e00f917df566b81b9e33891b102cba5b390e0 v7-3-525
+257c2878e0fcabd5504dcfed910287374405440a v7-3-526
+a17918b76ca1296f63db0e81dea0e37b8b880150 v7-3-527
+fa17c8646feb4719639150f1c301ce6c1557afb7 v7-3-528
+d83218a156dd8258a5f2f3ae019c56f3e8851d48 v7-3-529
+81d5f3a3e27fff9188ae34c41b939fc88c9837de v7-3-530
+c44f0f7424b98d321d90994198374628911623ce v7-3-531
+9755d151c7492a5f1d0e77a2d3c9e414f20f3b4e v7-3-532
+74d51b51f3e69df7d3295255ee10391b3409055b v7-3-533
+65f905eb14cd373e205ff4c8a53027514e96d819 v7-3-534
+f52d2ea0f81c20e6f026d74cec66b135d5470d2d v7-3-535
+a8897fd5d074d7baaba692013521304b13beb784 v7-3-536
+96715c3a905faa1bbdc50b16b0f57671b4758e0c v7-3-537
+bbf1fbbe4ab45442f8876790004805503e25f563 v7-3-538
+7a710cf51d73cb3c3c76fcea34ee706443800c54 v7-3-539
+af083cb521bcb69aae315654a3873c488dc58c43 v7-3-540
+5c1aaf9b4b1bc2d14d627fe22d414f3a2525c50b v7-3-541
+8d1b63e6d3173625324f4adfe733efc8091f9422 v7-3-542
+ce7bd50bafa74f4da979f27c4e5fa9a47e69d739 v7-3-543
+09d0bda69df0c5eb505a02e37a978e92fbc89332 v7-3-544
+e7ff3251dfa157284a48c5322783499d079e3eb0 v7-3-545
+0a364618c0e59fa777f526c99bee608bb5cf55ce v7-3-546
+4f4db5d661c4fae42f2d917c09549d58a2f4d05f v7-3-547
+8625e38066dbf6a4d5e2563fbe191c3910681d2e v7-3-548
+c0c935956ac3b7c706043e5c7c0ba840636fb10f v7-3-549
+297771eff080ed3bcfb2ade57c2dcab34bac5de8 v7-3-550
+e83c5dcea112a44f9a7b06042b52798e32d96541 v7-3-551
+443c50cd3e8811b58a4ca131ab21abd18aea9489 v7-3-552
+583e46e4a56c40fa1a7336be85eaec93f6800edf v7-3-553
+a967a979c37f458bd4d164afb8a6192a5b4a6fde v7-3-554
+8fb7bd9dfb2b26b43725c90e042d2089762466a6 v7-3-555
+b8924014a03991b79947d735a894e2c2e8f94980 v7-3-556
+a220dd97b5c7218558eaea27d301af2ed4f9ec2d v7-3-557
+34724dc5172bb81a9e670c5bd23edbe6a124fd28 v7-3-558
+74adc9f7e15b8c088abd04de35615cad6c83a811 v7-3-559
+0abd38ba64557c4a6d62575aaa3fc7ab6482d747 v7-3-560
+a1de7928a7aba45240c85a2bc8d70adadc49e4dc v7-3-561
+b2763055bdf26e1f11bf8cfb0601fefbefb34e0d v7-3-562
+02c86cdcf9a23f092400c7631e5906cb9053703b v7-3-563
+683de93060968ed4e9dfb7992910c75f479471ec v7-3-564
+5f811338b1186e1aef683d03fa05a8026d30e9f1 v7-3-565
+18c6b1752d0baab043792d3f6267ec393f7a11e1 v7-3-566
+f90bb88c261582fef85c16009f19168b38debd74 v7-3-567
+3b5f541269e2d9e57b82ea1ec89c6747e2003434 v7-3-568
+c052f3b79b9948e7072580e7db42f90c92eb40af v7-3-569
+4f1c511e71f851c4f1c14e950f95ebd6967c6ed1 v7-3-570
+43fd3896fab7be5ad01deed2960d37d91ba65691 v7-3-571
+3ae387af405f46e200fdf9bc204d0a251864abb9 v7-3-572
+802b1a1b275f5c8f95724d50d53642f221621d79 v7-3-573
+3ac005f02cf015b3aa246482c6331bd61c08d91a v7-3-574
+79ae10bd056520fb6367247804af22e52d2de8b8 v7-3-575
+7e3fedfc3d08d020e3ce047ec1a1cfd195af9ed7 v7-3-576
+286ba0251c0aff1a664a481846c1f4107fae0c11 v7-3-577
+0e9b2622c94a8edf906d6c44831c1cded7184d13 v7-3-578
+80ed6aa7b9eb18058a0b105af2ecd7b213891be2 v7-3-579
+f02b6ad168ae82ead0286b64627762ab2343ee96 v7-3-580
+96249a1803e28e6173faed53f8687334aa63360c v7-3-581
+d383bc2ba8112103389a44c2c747eaa1016da935 v7-3-582
+a69b1d711ff9d8b227acff694c53310cf237933f v7-3-583
+2d107086903af80afee524549e57d3ba016b3f12 v7-3-584
+d258a0c5c38a6a604b983b6499a0f02bc061c816 v7-3-585
+8393a16069fb5f7b22ab766167b698e4dc129911 v7-3-586
+a34fb0a077c9c26946727a25222e0a99dc08db0d v7-3-587
+e92cc285632dc29d932061970e43b53cdbb3460d v7-3-588
+e82937b753a8ca6705bf55dbf258f077746ec428 v7-3-589
+bdf7f3e4c763f2a038c397af8eb6b8950e58db6b v7-3-590
+e5b925ae56e36e86eb2ff059aa28d6a2dd332845 v7-3-591
+0e06193d4bd7be03924dd9c6251a64c6c6adf78d v7-3-592
+46896c29edd74418c665af7c1ed685aa52a41e1a v7-3-593
+5e7b500dbb7e9e964457d300b536aeba9771af6c v7-3-594
+928e7cef8836d13d4f2a17234e127b928ee63ff4 v7-3-595
+5aad2c444a00a2309e6e373b6bcb5441669ba126 v7-3-596
+b9aa7fb4a9281b87a651251f799e049409634757 v7-3-597
+f0747581607924c30530687fa88ebaa57602eb5f v7-3-598
+b06578f1390fea339a2d9d18e12758ec1dbcc279 v7-3-599
+8f98038a0bf34310a8224a569eacd539b7b8b649 v7-3-600
+c1780b4cb9955fc113c3c993c18c139e06425ef5 v7-3-601
+5cacdf56c94b6fa1992f7e9c07c95bfe52bcccec v7-3-602
+085f14642fe828b1cbae5706ca87f2932cebeb75 v7-3-603
+acd91c9741a6d0185b7c63db412888de4f904118 v7-3-604
+4873d9c4ad3b7214d3ea8af9712a87ff69948380 v7-3-605
+c612d154bcdd642e4097ae88526a81ed7868c184 v7-3-606
+002f2c5de317aaedb93bd2e506a295efe2d552ce v7-3-607
+d47e6222d1cde1caf08fa63104375f5750c25d90 v7-3-608
+d29aa05b7e311bc05491521f4059ca2b625c5550 v7-3-609
+9f48a54329975434d73ddfc19e33c343653d5c73 v7-3-610
+e13f2f3568e1e21fbd223a1c0627605e2b670c53 v7-3-611
+2b4b6185054ff05fb6ee3ab1bcde47409bf2ebe0 v7-3-612
+c03b6363492b26c02b4f8a725a91849a1a5cf548 v7-3-613
+2bb51730ef4bb0824658f7507edad165e194dd45 v7-3-614
+169ccc471a8a947c046b7ff41023b9045beb3496 v7-3-615
+baba6286c91e63dd42039206e3e0990fb0ac346f v7-3-616
+73db39ca1877a07008310a2ec98a2220e50c52f1 v7-3-617
+0b1cb3f839c48daaccbb3abcbd5f1c394c57cb10 v7-3-618
+27ecf0c87bd20140d9e85d4fd581332e0916191e v7-3-619
+a6ebae140d89f35876628cde44f0e7ee5a0ae1d2 v7-3-620
+ac13ea2b098d98e62408ec2d88026f690f68f940 v7-3-621
+52247eb615118965bb6a949307e9abfd378cd088 v7-3-622
+a46a101bfddd4fcf30759f3847fa1e18546907f4 v7-3-623
+06749e351b1c030acf50cf8c469f8973aff4a96a v7-3-624
+f43ffd820a46bf47b3e55b56d3e5334302383757 v7-3-625
+956b1ed19282518e0287891d4e7b2b8a3f850402 v7-3-626
+dc65e6429d2c1b79719455d7303f3f95c5897965 v7-3-627
+1ed93878d6e224d46a7c125a82e52338b9bf0f6b v7-3-628
+7de7ef01288db1abc944293a28aac13ddd87879e v7-3-629
+3416ac23d0758528919aaffbe02cecc6420b8aac v7-3-630
+99f076ca8d846d553aefd7e626ca938bcf93f259 v7-3-631
+44038a9777aaf0e6502e0eb57b8f7ccf31798ec4 v7-3-632
+ad5fbf3596e0a8ad15c260c5b529efc5ac689e13 v7-3-633
+b7eea24095073d55ac3c59664466b78a0525bebc v7-3-634
+f7f68f83fc335379bc9e3371c5118b8f81c8d5bc v7-3-635
+616bc1ad4f12be0ef37fe67d2f6ed7535f20e515 v7-3-636
+3b62d8f36cdf709d4e0575d63486ebe57ce7150c v7-3-637
+c0256c4bd91ed7b806aab002e4a45e440dd00343 v7-3-638
+1ec385a8faf4002fa300caf370ef2ac380d9702a v7-3-639
+c2c3577021ed4e354853d330e5fc60691d8750c5 v7-3-640
+c068389057c9a89fa351678b5f5776278971dabe v7-3-641
+79ac6744237ce5076a6d2e2b21198dfddc2cc9dd v7-3-642
+fdac34e3afa5f0dea26dba5e96932e3b9a0be50a v7-3-643
+fb7c028dcac7555fee78096813e3846d157cc91b v7-3-644
+1810ee914648ef3e16a8cf866299a32c4a9a00cb v7-3-645
+e70485d3f81df4d72cb40d6fa4ad4218cf1e8392 v7-3-646
+29fe4e5c1db17a62b16a95fdda84f08cd05c27b5 v7-3-647
+76c099d45772a233982c39a29510d89eaa4d5a1c v7-3-648
+063765c3cebbd6040dc091b8c1ba28739fef9118 v7-3-649
+a638ae0f1b0cc41d8d753d79503238f11215f3ea v7-3-650
+ece544e85821a6118da55dad1538ea4c3625bd1c v7-3-651
+5edf3c51aa93110e57fcd0428c30e5bed149df34 v7-3-652
+fd0c7452fa51118d8f6557b34b4cc96e830ef6c7 v7-3-653
+73557eda70271b49015265b7147562b63a7a094d v7-3-654
+0d3238b54963c4b1358a1f33221f75e067c1613f v7-3-655
+a2f61b2b8e770bb8d233ce50c8c7508508578a8b v7-3-656
+3958b0e672d676a310d756bff1b9c629a7b0142f v7-3-657
+15cdcb8ddcfb848c929cc37e239d5da8fe48a8d9 v7-3-658
+e75da4a3225d48e59ee321411134cf9999348b7d v7-3-659
+8fdadfccd184b7de73811a3a18dc8815b7eb3434 v7-3-660
+5e909c379a1e87491bfa95ba1a37b39d0725933b v7-3-661
+87afa95a2992a31b1937def0e1db4a193b0ab32f v7-3-662
+2a200527131fac8f50487790ec201badbccdaf0e v7-3-663
+f86619764a1e0338ef9e14c653a5909847304b8b v7-3-664
+35939e1e25ff5a3862b83248f8039971c81936d0 v7-3-665
+1e22adc6176ec07f52102f383a9c3c414d43f9c2 v7-3-666
+cd36c0fed43e63a94d6e87b5c5c0b4d95628da27 v7-3-667
+dde6d0216a08a5554f3c351e519134c386d14232 v7-3-668
+2b3b7b48370848149c8b831b2b7aee9b7f4f88bb v7-3-669
+2bf8c00741f7f07d9b58596764236a92eaeca862 v7-3-670
+530f5a9030315f984e096794938c61f9d3562e22 v7-3-671
+fd6ef931aa77239804860b74ed2362b29c1a6d4a v7-3-672
+ca1c025079b11c98363e11576d903af756a593fc v7-3-673
+4da6003f0f0eee0f3908f8627af6d13a94c10cc6 v7-3-674
+9963f7a9b41b555a0660288dd94df44b6dee7c2e v7-3-675
+5309996ddcedd7e2dcc8c46624348405290b8940 v7-3-676
+8115f449a574bc146f75449161f1757aaa5bbb66 v7-3-677
+de253f606048a2862a338190b071e5e3c7de7a41 v7-3-678
+dd0f25ede9a8322b5b638961835cc4743cd479a2 v7-3-679
+52acec46b75ecf24d044982d4cc067ef7890e7d6 v7-3-680
+a2fe24ec6a0d06d0af286b9fee9e307c33f27cca v7-3-681
+8eb5b61161b4c56b378ec829e360204102d22db4 v7-3-682
+0f5ee262963528ddccfa1f54b83696f939d21b53 v7-3-683
+1cc37b8cfaa1c670e442e2f9444feeb1820228bc v7-3-684
+34aa94a421b7a03a71013ddbb92937dbaf83b1aa v7-3-685
+ba9c9d0c4ff4cf56c3c5d2dec2da71decbbe9f6a v7-3-686
+0545dab1517f8ce2b8319c02572e4bb357567034 v7-3-687
+2696da84d37093da0dea419878e4241385eb515b v7-3-688
+3c072c1cb87372f3ebd345463abbc451e80143e2 v7-3-689
+caa0ca9ad06cb515b7e6d2e4410e03802b58e167 v7-3-690
+7f10daa706bb6ed0c39f1d2905cd78368a98d19f v7-3-691
+337a4368fd2b68b9822b94e595d77b4d6773bfa4 v7-3-692
+fd96b3cc88ed71d4c4d24c6ac67c9d3a68ae6e6b v7-3-693
+8235ccf121bb241f8105d0ba6e1c92e9f8b04555 v7-3-694
+cd6c420e31d6843fa1231e1cf7a3d9eff0ad4e07 v7-3-695
+447c688b82eb4a5eb7cd0e16521094b77160fd0f v7-3-696
+7c72b5f7ada1f4a028315aa50f8739e0e83c2e74 v7-3-697
+b5b892472ecb1a10cce1709e41700b264b6485d2 v7-3-698
+4ffb6f9b58e0b51923fe6a71e6af158b6e3f7864 v7-3-699
+c656847932d33b5d68394ae1ea3153dbdba4d3ff v7-3-700
+48af8656094539f8f71dc51e0a6aa14d48ddffd0 v7-3-701
+916b5c11a13e9978c85f9742546e70d614116883 v7-3-702
+f69321485951a3c9bd0e9e7484a1901b94cae726 v7-3-703
+be8ad9c9b973a4d87b9bcfee2b6a8de1f6d3e071 v7-3-704
+0aa74f2f50a8333fd5544f5d4b383132be41704c v7-3-705
+d0ae72c2f5f94e2483ab0979eec652b1289679a8 v7-3-706
+d24d309c365fc5c6a9324a6183d7b927d9f5132f v7-3-707
+64427849c1582299f2af389c6225eead529f0329 v7-3-708
+fb7dec372910b61478abdd7f79871724153ebfdd v7-3-709
+906eb5c0ef129b6876fa9c6c5a13e44807f7a503 v7-3-710
+2a7b2943be22c27edb3c0334423c1b17275f18fb v7-3-711
+557ef119999ea687ccb84eddca295755c24989da v7-3-712
+f15769bce0b811fc840fd455035270288e8d744d v7-3-713
+9ea14f097855e0929f86c86d405725717efb044d v7-3-714
+4f0ddf4137eeb08753f2593a32b42a1dcb1e6f4c v7-3-715
+eb268db98f321b93f5e7552920b6389f9dddfd3f v7-3-716
+6a76846b84eb0fe1220f8cfa19b1161145932d4d v7-3-717
+18e95db59826aa9379e6e3ada5d3540cbae1e596 v7-3-718
+e6d8b44065bc05741effbc0635c21506032d97b4 v7-3-719
+9e119e0ade5d804f174a3b67ad5e0d0e7449739f v7-3-720
+b23f583e132e88ec98f2b449b7216642ba64a8a8 v7-3-721
+de6968039340db04ec65164a3450a40773488e00 v7-3-722
+ee138f29259e02f62fe8181073e7a063523e50b8 v7-3-723
+6e5acfdf7a5a2b3fa27a529881af77c1e1b1c0f7 v7-3-724
+f4aa43d952f5bacc752951c80495fd20c72ba90c v7-3-725
+5049eacbff0e9688af99eb67a408cae5919ff52c v7-3-726
+d3c291efdb0b9f5cd286013b789eb1c91ae868ca v7-3-727
+233666f859339f425684af70dd008354776259af v7-3-728
+d08f05285dd102d8f071ee42869416d25dd4e72d v7-3-729
+37a4cacd20511ead4cf1a8ecb235276bc448fddf v7-3-730
+778ff2e87806133faa8fcfefbd41cad2b601bdb6 v7-3-731
+fa8bf69d3866eaf31e6c8fed74862feea11a40b0 v7-3-732
+509e55bd4a3feeb651ea173cefcbd933f723d8b6 v7-3-733
+fc8b4a06af9db05af800b1304599afd3e1229980 v7-3-734
+d3158bf4dee9270477defcde85949ce58fa350e5 v7-3-735
+b1536bbbda104edb11b0f5772e433d2b5388905e v7-3-736
+1773d5aa6437b0f88029a192cdde2c510faf517d v7-3-737
+eccae034465b9a44aa2389039ba06b25dc6ae7dc v7-3-738
+e2d36f345a7f1131e085336e7b471f718fad6c9d v7-3-739
+2c12cd5c1381dd9691af5e7d3e1fe1f54c929ee1 v7-3-740
+6e1fe64cf4404d899232a880552cf52998934656 v7-3-741
+4d1753f3e85c7fb6d9cde1a8aa9ded8d11cdcd01 v7-3-742
+67e3b2753a6ef97a94084b85f87873c309fea3d6 v7-3-743
+26c8b3b49f743ca163a63463da08cc3822322bc2 v7-3-744
+aab4b29520e79134e33f2c641f1d960de2dcdc1e v7-3-745
+4934eb2e22dc0bc03fd5d4f95706a69a1ddffb94 v7-3-746
+cd59ba19985a3b3bd66dffdcf59b00427f844818 v7-3-747
+56bb88c68f985365b0545a0370be59fcd97a4178 v7-3-748
+3e22fe67fa6935d1156738a34e50bffdf62006c9 v7-3-749
+5c36fe9f19a529fb6064b37b8e47e82cdeeb7ca8 v7-3-750
+d149f18b289fdf19363214e7805a0637307bd264 v7-3-751
+ed936effb1f374004db15f092b8c8ab87631fdd4 v7-3-752
+c83cd3d01128204d6926550cbe1064daaf8dee8c v7-3-753
+beceb0a18c79b5b1bda4822b34cb2d62b2967d27 v7-3-754
+d9b4cf53be2edbb872cc489aea32a4441b39eaf9 v7-3-755
+706c87d16d40ecdf9c6fba45bc47b911d8e140cc v7-3-756
+65ef7c96d65fb2fbf660797608809f0ac5d0c4b7 v7-3-757
+9eb0d30510f7b02aa5f55f400bfab08d847ab447 v7-3-758
+25ea15fdfa5c7d5894a06814fe9411b75050ebff v7-3-759
+8e54a32bcd56226647cfd3d8c5e142e3a98c0ca7 v7-3-760
+6834d6aeae099d6bfdff5151aa2174cafc22647f v7-3-761
+699f8d8f096d4627f97e8d3bcf64b8634a484c26 v7-3-762
+b6148e4a9c397b5dd1716cdac2f96730bd0f353d v7-3-763
+b29e55d0ef01c506ec48c0c5782e669bb1d80f14 v7-3-764
+915fb3d2dd8ffc322a5cc9e294d9bb7dfa8c5a83 v7-3-765
+b5103b7d9e1284ef9ffbc7d1170d9105c0769c4d v7-3-766
+be1cffa1e477c4a96bb54a3097d3369b23f32825 v7-3-767
+9ea81cd9b1f50054629547ce2eccfac1fa00d096 v7-3-768
+d179a8eff9d7b0adc561f4a4dcfb0b7612c1f301 v7-3-769
+da7a7ba36ed2a51f28e4d3f7e1fd550303e3ece8 v7-3-770
+3bd2c055319e086665af5e449498a4d5bf40f25e v7-3-771
+d828cab6964f4249db54bff6df0fe02d0f290387 v7-3-772
+3db9aee957f7eea6729e5bfd294e3a24d41c79e4 v7-3-773
+a8f5876e498125f4916c5f7168823885c27dad8c v7-3-774
+a6e60677aea727622dde15d1306c61588b805500 v7-3-775
+80b041b994d156360992666110964e74f7473d3e v7-3-776
+9a1a4c486e6bb367c639c29c6120d5fb1fadcc38 v7-3-777
+562bbee33aa4f9896cb23ed6de8fbf60cac323e0 v7-3-778
+2067ed78d37c331685ef8f293d6a23c372ca4b78 v7-3-779
+42edc5dac33c92876d93f00f8ab8c1f6bb25d3fc v7-3-780
+29f29e86602e4a7f83d4572d2fe75b9b0de2752f v7-3-781
+0de969850c0687d2018e025f31e5cef9e9ce1444 v7-3-782
+a80af62d5e3b3614ff9e058f42647c99bffe7481 v7-3-783
+fbadf0f6987790d98c3b3fd935fea0494743830a v7-3-784
+be4baed0c933e1f1543ea175e2e36551ff6caa18 v7-3-785
+8b3e88bab70215a18768fca5a90c6f07ac1aa5eb v7-3-786
+e1b98967a985f4d1ad889c8e69b822d9126411ab v7-3-787
+386fc822dd002958fdade4329845013cbfaa3dab v7-3-788
+43c15135926fb95fa82b01424677a9c37f4d0e46 v7-3-789
+8819ea6dcb72dcf61fd0d20f8ea1904a7546917f v7-3-790
+16e8a09e8ab08d2226dc84b12b7e434bda6b4fa9 v7-3-791
+7061704c2014e4563efa032672264a47b4b7b0d9 v7-3-792
+fdbded463fdcc861630b3ea61b9654374847231a v7-3-793
+9867f92c9b9fb082ee6daca816f859b53ed8e58b v7-3-794
+17a312ba38a0b606cfd64d82ed2ebc844828085f v7-3-795
+2c12c4e2fae8db60fbdf58b34c8b73eacdc32665 v7-3-796
+0cbea05f19c73c01dbd0f04378a65ab7de6719e7 v7-3-797
+cdaa688e3dddc442c1d39780b6ac0b5ac98c253e v7-3-798
+5e9730de25e9b4fc2abe14b8d6b0968a9e59983a v7-3-799
+c0cc0e0620dd935956a472e5b23369d1d78f5fb9 v7-3-800
+48b54c590dc83b705f2e19f9aea1e9a69fe09720 v7-3-801
+cd5145d2408bb52217417af654f5664af269e19e v7-3-802
+77fa4dee43fcd1c0bacad9dc85b3deb39e0ba487 v7-3-803
+2eb4b9ed2d42312eff32e845336aab748f7fe311 v7-3-804
+dc30c01f995623e65ee6651a46b12ff062df8860 v7-3-805
+f7e3f87ac9928df0079741258a3c6034ecc48806 v7-3-806
+1efc30385c417bb413f5199253edca2795f9da0e v7-3-807
+3b2a771abb39f670269b0ee9c4041bf02c2d5b84 v7-3-808
+918d7df425afb77261428968ae646efb95b15224 v7-3-809
+8904ccd5ee85ff326a05530c02cc90e1260f768a v7-3-810
+ad21448af931b3923d9b76e4efdcf0e966c9d199 v7-3-811
+4584e59860b8db6fc5870f0b8f0425f540ea90a7 v7-3-812
+4e6e012af15028dde0f55bd9bc676bbb14e481ff v7-3-813
+d5b1d6177b374bbecfbd5c75fbce28e148eeecea v7-3-814
+448a6e7cf32e14a4adcbc4066743e2f058f7e1c0 v7-3-815
+2b340e5c5baaf66015f3367208d9bf22ce1dfc8e v7-3-816
+01fa9313d4b560997234b94b2408e6bf64808afc v7-3-817
+ad7b6062a7f4041b736d45c5f045671d60eb782f v7-3-818
+36fd800b8c6c527c75bfe285d0ed0c3bc1cf45f7 v7-3-819
+688da4d486a019afa3565ffc553af6ee1a4e67d8 v7-3-820
+4936ee89b4bcfaa33f74114bd07f20af382af14d v7-3-821
+2f7883063b19039840a4a73fa227f6f42b9e3281 v7-3-822
+db401e5e4c5d868b7848486c84521f047dc04b01 v7-3-823
+f5ef9b9c18cd9345eca783fb0c6d4ed50e215cb8 v7-3-824
+6b1f3fc893cdb6d0a4fff5997cc8ff083940e727 v7-3-825
+646cb6b6ff2372c26cb9dc9ef1a0f8d562204950 v7-3-826
+5e17a12a3b1438a7ce044db02d9916ef36e404a9 v7-3-827
+13170a796134824375a42e77af4ff012ceed2b5a v7-3-828
+7728d626ae038dedbf3347508238ef3ab4216a9e v7-3-829
+454d35a4339251adf125de78a8a98d99105533eb v7-3-830
+cb185366f5c84852a7221ed6d9b274a7239ad06d v7-3-831
+670e576a58d19c2033877d26b4338873d8a7db12 v7-3-832
+b971097606032c6fceb961fd559121d5bd74a260 v7-3-833
+3ac9d7d8274e669d10178c4d95eac55080ee0ea5 v7-3-834
+d356b5ce84ceac41b036136807ebe887208fb6f0 v7-3-835
+ff193256398a81a520b44c67d661eee36c64ee95 v7-3-836
+14698f63de8db5b034939aa66b7076ab76bcd529 v7-3-837
+1c819b05529cbbc39982513271499e0217382124 v7-3-838
+2030aca407edf6c865114f459bf2d5d79adea390 v7-3-839
+1778d51fcbc37e819c305b860f98c949915d35eb v7-3-840
+b40e6a47ee53789e91b57c04d9ee7328fa9237d5 v7-3-841
+78321dcaa8e263cdf408f7880530b7aea7401a49 v7-3-842
+f4960ddda07ce46a098d9106ac1b22fd0f6d0f0a v7-3-843
+eccc0e8a82fb632efdfa600db3f65f4ed3dff01b v7-3-844
+171234e02b1e74a2482003d56e7110d37fb4a62b v7-3-845
+b06bb07d906be3be689f90399effd2b3b2ac2ee3 v7-3-846
+4dd43d6b3df705a513be75db8a1b50a83f72088d v7-3-847
+e49b80f267dc3cde78de78026368dec3a20520f2 v7-3-848
+dc77c2a14a05810bda7e53373d76b7f41341f44d v7-3-849
+07fef68eb0188adb3d750b92b78059cf41fc8c7c v7-3-850
+dd669f296568a7525e02ab54b615bde20d37c466 v7-3-851
+3fd805ca2a6a6ef231f111c6a7b3cd512abaf537 v7-3-852
+eea32254940fb4cd61339650e10a808f4e702e62 v7-3-853
+14cdb6e4d5b88aaaf7e33eaee87efec5b1c1ebf5 v7-3-854
+6604853dd8227c7983dc1b10f804f6aa4b28578f v7-3-855
+fb533fb6c015f40a3b1301c0c876c35665b0d6ef v7-3-856
+4905e038b1057e133d0e72c48cf88580cdedf26b v7-3-857
+0a3fab86f34d6bab27e0be69db4f39ffb664557a v7-3-858
+ecf21be84def6033137d168e0a66500c29aeffec v7-3-859
+6ce32844727d8d04e8dc91310d0a4118d81aa161 v7-3-860
+6fe728bf165e9b6974ef47e86d98b0eb14ce21f3 v7-3-861
+dd4f3ceb5d86f8367d4cfd6fdc898e493c6d0aad v7-3-862
+5c0652f455c9f2ae72790a782fe5b5fd1a0e857c v7-3-863
+a82ef37d38c09523bab204253b52e177dbbc0581 v7-3-864
+94342b0605fb9111b7fd4a45a8bbc72992c4c255 v7-3-865
+90d72df431e54d677f03171cbe558434029c027e v7-3-866
+0fcb050fd79d84ed190452e6387e42d320678fec v7-3-867
+b31989e2b05832d432557a32ed8901dce237dec2 v7-3-868
+23ce9a61bdc2a35892ec4e4fa22e8964d60dc6cd v7-3-869
+26e59a39fdd965ffe83bd654b705540551c8e0c8 v7-3-870
+d52c45b35fb0c3b77bbace6cec3deda8100fbb7a v7-3-871
+edd0bc1f26bd019cfd328a0dc2c9a854607e4a41 v7-3-872
+7faeece39228fde0ac5c26a362a223d0dbe9bba5 v7-3-873
+4d0b39bcec207130e483ffa66b6f51f999d8e95b v7-3-874
+beab15a2ef147b880bf7b5add269142b9af58317 v7-3-875
+787df0fc6539ff7886e9fabc85ea403096577440 v7-3-876
+96f478b812b14fb1a5710450a1174baa55c73409 v7-3-877
+97a5ce76cb7d5f635876bbddf35b421c0c76690c v7-3-878
+79176b78969cf5d182b378ffb8e341e22f18775b v7-3-879
+9945fe0536a32496fe4842524199b5c24bb8b0d0 v7-3-880
+d8acfc49d94e485f839d8e2534d302b91a98bf9d v7-3-881
+8653c39b85ea93e052bb0cbda571e7298451eebe v7-3-882
+76aa34cef80f5d22bbbcf60278c833fdadd70131 v7-3-883
+22adc26aaa9f701267bd1ee4636592859ee2dc70 v7-3-884
+c5eab656ec51dc2d40ef6e39194c74af868a4b5e v7-3-885
+902d6ab377ee2f011279b3aaebeb05d0f5c2bf80 v7-3-886
+015e53d9978721bbb9283a999c668c98ad2554a9 v7-3-887
+b0b253898cf9ff8f5fbacf69de76b5640b1b6a55 v7-3-888
+cb0c694517a08f1f8f548f0771e874537a390dd4 v7-3-889
+89bdd6d575101291c66f9e701c456ee71085d147 v7-3-890
+1dc160bf2488fb1332250edaefcc9f1e320c8e57 v7-3-891
+6c2e8074ea2588f710adc669e7a15041f6e80adc v7-3-892
+dc3efb6d5a0821c79f939db8e3b77a714292195c v7-3-893
+52e946d654e0fe978609e0a23dde3c8998f2ce24 v7-3-894
+11007e80829ca9d72813a9c60a2eded80a0c1855 v7-3-895
+af3a3680fc75f090e896d902f0b4c7a710c41d41 v7-3-896
+5aa74a2f8f9de4a6c10bdebbef910d6750f2a980 v7-3-897
+aca1886102bdf19f755dc5eb1ac379f1f0680f6d v7-3-898
+bb3cfdb626077d9236447f40ee725b9a5d78216b v7-3-899
+b53fa3b431934de82d3bee329643bbe0856f651b v7-3-900
+790238e5a46c70f45232c0a54d0c73a6ca1d37dd v7-3-901
+b01e3cff92530f6c317e0cf2c0ba0fb4f97df883 v7-3-902
+166b3df562ead7b4f85a494fb8a6eef40affdf85 v7-3-903
+bdab73bf24a8b361a42ffcf429c0aa705d4594e0 v7-3-904
+8e1d1da398b378cf03c0910979cf475ddb2df7e3 v7-3-905
+ff1f3e42df08b2ebc39e3b1f2c80f4751bf16dbc v7-3-906
+9f3da1dea7c0944837e8d5a080eb59a24f6c9dd7 v7-3-907
+4281875776fb2c3127d08a03c3600b58353c9796 v7-3-908
+b79f3c3a584c701e93acd1881a934c931634c39f v7-3-909
+d8d9c591c50fec51b64c12bd2f42d3550bd31d7d v7-3-910
+f1eab4f77a6fe4b77508d86a68a6681195806607 v7-3-911
+62eadd7de409641de83ce61e1eb311e9116e06fa v7-3-912
+0d3573091d42d4797f10cff1c4139557d384f899 v7-3-913
+9f642ac84df9303d34d0214da2ade28f78ecfb6c v7-3-914
+d8053e6bf72a555ed34201c6edb55a23b4fc9965 v7-3-915
+f39af34195702c5587eff88dec51b40e327f418d v7-3-916
+3887b02953cec045611021e0adcd512b3d127692 v7-3-917
+6a8ffaf0585660badbb817f6a2f1cb583c9f1447 v7-3-918
+12636b8248163628e7c8df68210dc17932440157 v7-3-919
+923277a9cce4316d6b4cb3c6571dab538a6b0108 v7-3-920
+97474f967eec7f24f09d20dbac65ec9bb660bb2e v7-3-921
+1d56e5dfa08e68c9ef0645cabf076e401799e3bd v7-3-922
+6ecb80dc6521837e28bc58d27539767d6947037d v7-3-923
+7eaccdaa530431c15fb0e0803e5495074e883bb9 v7-3-924
+04736b4030ecfa2c9e8d6046ea533718dc5d8ff0 v7-3-925
+c80838526eebf3374fc42febcf40cd911cc1523c v7-3-926
+d67e292af6f9d259d0893c8062f3896a8aac000f v7-3-927
+6d45e6f974159e816a4300877296e9a0760ad113 v7-3-928
+94aa0d30a3ea6291daf7e6207810ec5282cc97a4 v7-3-929
+d85196defe0da017ff6d547e36bcf40aecba9661 v7-3-930
+fe0c7437ae8b0e05b57990549e1ddc71e456f18e v7-3-931
+b7f2d97ae2b7442c46c48ef36d9e33c3ddd34db7 v7-3-932
+c9820396afb971035e722ddce2058d5db2f0fc64 v7-3-933
+000bb500208d54e17de26bd5cc5a18fae8d1729c v7-3-934
+c42e130ebf36515e574d89efbe98fe380ec7c694 v7-3-935
+e7361b2d8136f6468daedf1bec7390d77c5c5bb1 v7-3-936
+8ec7323f417d998685afc26bbb4e466eb0204352 v7-3-937
+a2f03b41dca7024da5e702d016ae52fe7f51594c v7-3-938
+48a22f36ff45659594ca865f502fe95691b2e332 v7-3-939
+e2db42528a5bf380bc7e92e41afc807b27f01c12 v7-3-940
+da71e66dc1d4300cd792f0da77a5afd99d634c6c v7-3-941
+358c10968c7fcb2599356b419473a3fd46edcb69 v7-3-942
+736b8e18a3bced7e498a6b81e7189d78cf4671e0 v7-3-943
+71fa86c8fd4a1af0a27a880ea15e3a7b97334453 v7-3-944
+80eea7a9d6b9c2e7e8ceb18d6a090387f7e1e9f5 v7-3-945
+11376842075637114ee3714ccbc2e0e8a432a4ac v7-3-946
+a84f21892563be88839b4026bafba77f9e9a1fec v7-3-947
+a6f0544df95e5f783861d3c67d84bc5a28a315da v7-3-948
+cfd76908da252e03f46ea15cde44a3664e895fb0 v7-3-949
+d4816e7c33289b9c8aec739850133484c5c3e8fa v7-3-950
+907b1f035ee7cc61fec1463db85a9eaba4717120 v7-3-951
+2a166caf8709876053f9b32f4f88590a4fbc6899 v7-3-952
+7b789d337820088f09f6a8fb488efd418f702133 v7-3-953
+1afdb7d21c14e15a1239d406205563dd702d7d24 v7-3-954
+fa90ebf2c8f36d98ef27b2668ac1e1c11db75bbe v7-3-955
+0bbacb6a83bd678266a0a864e47f4e03927103fd v7-3-956
+c16602758d847665ed50138a562f1513ca5dedc8 v7-3-957
+58b74ab7f29df09e54bf76ac84697f04b9f4c163 v7-3-958
+ef6b11bb183da058edf52c86ce705726ccf72600 v7-3-959
+e67522c4f56646bd6ef91ad63b152bcec96b2e05 v7-3-960
+d5177d5ece0c539680390448c8ce8d05a6d61201 v7-3-961
+0a94ac379769762200c427995551fa4325ec8f28 v7-3-962
+7eafa576528e6921f337da5c1e3e2d0a9617993a v7-3-963
+7d81f4e967285d14c9e9901328d2c66911a9a2f2 v7-3-964
+8a3ca4adb5d8046f87aabcf30a2b7aefb8b9d46c v7-3-965
+9b800f0a757fcbedc2c6a1851353c3e5044d39b2 v7-3-966
+20e30e31bd86390590e288516670b81caec6188c v7-3-967
+dfbe53a54c790d63f8788c13a6a2d18198825605 v7-3-968
+137f9d41f50894cd25e5b47764af817dd84037cd v7-3-969
+ccecb03e5e8ba41db171a5535047f9a30b5d391d v7-3-970
+8d6bb2338a583af5eb85589949065cfe46c42bd4 v7-3-971
+ba53304245f033b6cf2f6088c09f45dc0d98c47c v7-3-972
+09e1e574a52d38522a35af8741b3f8ce92336398 v7-3-973
+92fec4b83be56a65ed81f25885717f6db7639854 v7-3-974
+44b89b025cdfb6a7371a036ef1b2dd93670b2a15 v7-3-975
+015a8fabf90072ae0eadee5c013f7db00f83977c v7-3-976
+21e13403140aec6f32a8f9b49dac02c37945ab11 v7-3-977
+fe8a0a6a1c2a2ca51c92275a9010999106505ed8 v7-3-978
+a63361b9097952faa9c9eba2caebef09b9f8b62b v7-3-979
+c83656c9745a005df1aa7d6985787048a1884734 v7-3-980
+4ff8fa416a0dd64046e0471933d09f7f19a4ea0f v7-3-981
+dde1cf311be6edf32243f03fd8436bdf9798de93 v7-3-982
+ab5154170c3dfc0dd769243e1da53a865e1f69d7 v7-3-983
+94c5441984cc47971ac49435d184c13cd6d3014b v7-3-984
+0c940b6f282836186f428d201760c6f6b9b52fc6 v7-3-985
+3cc2dca142a0aed29befbe6d2944ed580d728545 v7-3-986
+032c9f916f257ed59f7c55a6c8113791d3def365 v7-3-987
+035fb0d5e7ce67eaff19a6cadb37b57c0c25a36b v7-3-988
+cd005ab15ef3fce8f551c81ea10c93889f42d09d v7-3-989
+9a1d78f828261181232734378f73d648148a42bc v7-3-990
+8fe768bc1234fc817db3cda61ae9e9dabf4ae958 v7-3-991
+89ea7593fc0cb9ec66cc04619217447715289a78 v7-3-992
+dff1542e64f95a3fe10ea24f4007206d53880087 v7-3-993
+f74611bfb1b77eb2ad42b6d74b3e3657cf3f0725 v7-3-994
+6d517f6e5f0b031cdb386878d8d428f7f2cfc2a1 v7-3-995
+ebd94eabfd8013a605d8efc7df64a970531fd5a8 v7-3-996
+ef02f32d8e53a7b3d7327ac79359a18070e4a101 v7-3-997
+47e6dec5ce3cbc8e833480b8300132d4bf5f035e v7-3-998
+e6e60d9da892296ad770b26a22f98bb72c4e1b7d v7-3-999
+d037b9cbdaaa0af2b383c93acd0fd87e8eb2b8f1 v7-3-1000
+9dbbddb2ed10936c20048ad28a2dcb9fdb6cdd79 v7-3-1001
+b498224f5b417bc436c9b967978628703191c0d9 v7-3-1002
+ce94a870b59bbaad92399eb782edc33a855e0b93 v7-3-1003
+cadb57fbb78165c81fe4718a355b5f73c641bb62 v7-3-1004
+90e9917d4114461c5f7258c04e61de1dff2e1a74 v7-3-1005
+9a2183bd829502597d52f22a1c27fec8399298fd v7-3-1006
+fba9c0f86f77942d47a5505b065e01a733e7f111 v7-3-1007
+8cb14f59a3275cb183f031e2aa1e29e230635d6f v7-3-1008
+57393dc4b811a1283a77c759a09bc52ba78acb8d v7-3-1009
+36ddcf4cecbc96b9854af6956f371dea205a6890 v7-3-1010
+55bcaa1d2749f9dc22187bea848b002220cfe960 v7-3-1011
+432a6b8c7d933dee8faf25a342e857fa0a538eea v7-3-1012
+1be43c095affe8e945751a5cb4e21210f31c02ab v7-3-1013
+6a2005efa02b4ae30fa4867db1463fd4a3689843 v7-3-1014
+45f97c34953728cfe859cfe5212c241fab1da20f v7-3-1015
+5cc98a5898cf9ff0841c78acfe1056ae075a217a v7-3-1016
+532c2e850256cced37b8864ee7042ef8240f135a v7-3-1017
+80170d61a85cc03d66228c16c80cd8a4898a971e v7-3-1018
+08ac4698095359c3a888b34074548435e9775973 v7-3-1019
+f7944ce459ac77416617e0b2f8a91a9c8cb385b6 v7-3-1020
+fc997f05cbc7b566df765c79452a541afaadccb8 v7-3-1021
+849180347ac359fd52b92d70b545800126178eab v7-3-1022
+f0c37f5cf4eabb04044ccab4031cc4056c5a47a2 v7-3-1023
+7b835b2969af137f979b633977d59e13cc0960df v7-3-1024
+b2946c06d1b6d4e9d38fad1d4281e2d4db3523f3 v7-3-1025
+888c12c899e552deb33b2e1e8ea3c8141352c3ce v7-3-1026
+04086e29756318d7a7cfe3d35fd38ccf550ac366 v7-3-1027
+4d81fdda8f35cf764744161118aeaec948b9fc90 v7-3-1028
+e7016af0cbf92a5562c01e95f2cec306b6465783 v7-3-1029
+d1f3c77159f9b69f229ee0f70fd98464b2546920 v7-3-1030
+96c1a785009768720fcb16add8b9daf1290ce56d v7-3-1031
+f262fb02889d46743226a78363250e2e1ed7426b v7-3-1032
+b2a8e3a66f8cc73c3942ef5cb9c0519df86203cd v7-3-1033
+37e444aeb33b2adf359f8736807f18ff5dc11019 v7-3-1034
+626e9ccb7c48b3fa7ff6d2ca5efe91bff39135dc v7-3-1035
+b22bff1a6af81dd78f8e9ff0bcded471ab858245 v7-3-1036
+7a2be4a39423e4763ca164dc77fcfd4b27f91a8e v7-3-1037
+6a73ac422c67d7ad4642ae9194cf9d4c832021d2 v7-3-1038
+321cfbef943199e8e967f6354877ca8fc07e4551 v7-3-1039
+b9f87487d93597f69f09ecab8cdca11bef6c09d0 v7-3-1040
+63c9b681c3dba1cfcd2df48085de2453c43855af v7-3-1041
+fa39483a1363d533f9c7897d476bf0ebd1b8f44b v7-3-1042
+1e8952a5a726ddc1458ff40270cd5da16be3f272 v7-3-1043
+0cf552b325b55d417079ad28dff4e27afec5a2ca v7-3-1044
+29b2be2bba0d369fef85af7aa3196f8b84cce35c v7-3-1045
+00eecb2f8e3e9664ff00682d278a2b1e19cc4b09 v7-3-1046
+89bec74fd7936cc425b42f9e882f1f3864b1c95d v7-3-1047
+19d406a8509d9755b05af7d5ea521925b01f0d76 v7-3-1048
+074491a83571596acb6aac6d371140e8f99fbc24 v7-3-1049
+38276cfe40b2069f94b159cc14b4ade47257c836 v7-3-1050
+70600448f9e7f3bff3b8b0c2f2733662bac08ea8 v7-3-1051
+12421d8a45d5597828b8343c31faa79f77d9c512 v7-3-1052
+49f0fcd9762ce5057e4ac22417105b3ce43a35f3 v7-3-1053
+219b2fcad60d27febcaf7251a91be331484b2c98 v7-3-1054
+5679b8ddd8cc0eb004cbb61babb336c3af398c92 v7-3-1055
+21a99611149b0f1c200e001ec26b8b07c6e28c45 v7-3-1056
+90beab957ba9ebeac150bc5a56cf6ad90f53336d v7-3-1057
+66e615ce7f61948a2a4a8615d703a42d56763490 v7-3-1058
+548b889fe3cfbf06ab50de373df5e65f52cb249c v7-3-1059
+cb5c1e37ad4d4811e5fe178f14c523b178da81ec v7-3-1060
+18ba89e06fab93e8cdf7ca8dfbb34b66ff9d61d1 v7-3-1061
+e4e48d4ee0409509d56f7d654b77a35133283bc7 v7-3-1062
+4157fef7b95074cac55977127964adfa883ec030 v7-3-1063
+3857d399ab41ee8af64c5307c27da64b01e0a233 v7-3-1064
+07c534fe9b6cdbfecfd100b7e01f894d6708de1b v7-3-1065
+4c46e1487c634997f4701d8e68ba9ab019f85227 v7-3-1066
+52a4f66ae1f5695426de21877b2954d11ad8a4f4 v7-3-1067
+59e6c2bd68e38244d2133fc8d76bfc9c7b082d9f v7-3-1068
+6ec3dada4ad3c7e2551191e598cfb6d37bedac36 v7-3-1069
+c316a30a889217be4158fba900c85d9d44ad3a1b v7-3-1070
+857f6c53f1172ed836d44f105f6832973369bef5 v7-3-1071
+9f502d8d5165a79b361ad6048e84c278e1397f88 v7-3-1072
+f10f63aaec5c08e6f3b1b3abdef6ce3eef1cff6f v7-3-1073
+b943fd24c351141113dba360bd1d1f02b38813f5 v7-3-1074
+779ca415f8e142ab5ca74f95c8f732d1f00fb7dc v7-3-1075
+93b7ed814bec8a9a0b43138be7500b948d48eb92 v7-3-1076
+80b0081824fa3084d0e12f0b21f6e504b4e5e076 v7-3-1077
+0dce3d812e7acc74c39b3d87d8bb5b3a4dbee878 v7-3-1078
+bce2051173f01564805158ff669255359953fcad v7-3-1079
+7a35419393c36edcb710602edba31d5096d357d0 v7-3-1080
+9e7ef781d494694a36e056631dbd2c4357ab1090 v7-3-1081
+2d15582e132f62aa37e5eea5e837b3824f148dd2 v7-3-1082
+b3c59716e7001ab5127c259c9fd3552de0d36d53 v7-3-1083
+05d57d7c2d5578f1d794151be9cbb5aef89d821e v7-3-1084
+811a4c9b51d808cbd54dd0bab606d7cc1cc2e412 v7-3-1085
+c1622ff9ed8d984604a47ad0805d3fc528452bde v7-3-1086
+4d92b873acefb69e112fd73b642bfdf7979f1355 v7-3-1087
+2f51ee8825dbeb31713e635fd8d77ef77742ad64 v7-3-1088
+79522bb1712556183073b148e085d302967d7260 v7-3-1089
+8db697ae406a8ceb05f9fb8b45a70980904f230a v7-3-1090
+371cc0c44097772ac13e0e3cb59350c6be52257a v7-3-1091
+9d97a0c045ef5c86652c7fae4d4cd5752bcb42d6 v7-3-1092
+08fbb1ce1bc56e3884c5d35106df31a9cae1f954 v7-3-1093
+efc4fb311d5d45f6320b9d17ed47d24748335bcb v7-3-1094
+ed4e689bbea1c45a8aeb808b526dfd052470ef20 v7-3-1095
+2db0050523719e39f17f4bd855310bf5688155f5 v7-3-1096
+0c25fa1dfd97721cd4c92f4e7a9a524a24f3f43e v7-3-1097
+26f2dbea7443f719c854c7a1fc35dbacdd129307 v7-3-1098
+542af01979be709a4763eb8b9cc1cbcfaf584838 v7-3-1099
+bf917ee1fad22f643d7ef1a919b233f07fc1fb3c v7-3-1100
+761e42cc79c2560af55ebec0ec1060f547e64577 v7-3-1101
+1c5da99d1b708b7af2928e7bc0d9d57935872958 v7-3-1102
+832bf8136d86dd17489d962cd2d7316d7edf5087 v7-3-1103
+fc4d7f02ea3ac731a9717438c72aba098b117e8e v7-3-1104
+a804309e7327f0ece015aace3c855e7987f0ac3d v7-3-1105
+ec72bb4a0fc2e7f0d517cb12f784770cea9cc19c v7-3-1106
+bd6bef0bd0fbeb79b440e429f5e077169388198c v7-3-1107
+3534e9b4fa42b392399d66d08a1dcdd230accba5 v7-3-1108
+450e13fe16211217f32bc57c3827f439540398bf v7-3-1109
+3849c811cc0bccbe09a559e2be5fec7e810510cc v7-3-1110
+43de4ebbe7ad009199987337b864240ba19bfec6 v7-3-1111
+749e2b2755d59eedd6fd28e7d9ec47523b722be7 v7-3-1112
+0798b096bab3efde994f0b50d6776ac72ca0f41c v7-3-1113
+532c31f9e92fd44526d02d26c503a15c1c1c78c2 v7-3-1114
+3f2319a953b3c2fc8cbe9ae9225080a5b30a638a v7-3-1115
+66a9e8fa6f45ddd8dec5b98c193abc576330e4d4 v7-3-1116
+97560c16ca99a1341f31d88ed9f508d777647b5c v7-3-1117
+6a706ca7a889d27ecd6b671e31dbe28ab6b66f28 v7-3-1118
+a62695305e031260557ff0cde6eca1db5ab9e3e9 v7-3-1119
+d1376091d18b5a742ada87bf825d20e99ccbef19 v7-3-1120
+4b9503f0c7d3d75d772c2c0dbe19616da2480749 v7-3-1121
+7793e737ec8723a18d4c5468b33a895249ba4f02 v7-3-1122
+77ecab3bb2078fe525602172b35c2031c819ade3 v7-3-1123
+be1e4acb30cab46ab439e45b9b6871a7aff23800 v7-3-1124
+96f3348f9f119a996ae8826ef4d5a06c3f7e677f v7-3-1125
+b25a1b2e3175902e49a69e8d9ccc5c1cc43fbe3f v7-3-1126
+532a9855bd30d28cc14848ce5136658a273bc999 v7-3-1127
+47906f888725760ac704668b71057629e266e486 v7-3-1128
+f824cb97eb922975cdc1025f3c2c62f1bdbcfdd6 v7-3-1129
+ec24ff78a79c1851d8003780035d6c55f98dcceb v7-3-1130
+82e6588762e4aee5b0f0cd51d5c124ebfec6424d v7-3-1131
+b20dbf3a5370543ffaa1d6fc337df1969843477e v7-3-1132
+03375ccf28a27ed72f6cf347383aaacbd1a51e4d v7-3-1133
+531e598651fc6a7c28bc808d82c09ddc1759bf4f v7-3-1134
+e4bc21965079eb6948d8e22ad96d145659852707 v7-3-1135
+343d09006056ff408f08850317b8e8caf056f5fe v7-3-1136
+c02c7df9bdc91ae08ef626d4a8262fed47285c41 v7-3-1137
+47222d8b1e94c962f9daf6c2ff3f6c6ddcb71613 v7-3-1138
+3b5a023a45434e825b8dbeed551cf7f4578243f6 v7-3-1139
+7fde662e1db24077abbe26e6d78c286928f5c9b6 v7-3-1140
+10673b3531ebcc18467d04bb806036cbee1b8e2b v7-3-1141
+65cef998f860b3745880622cba74135bfa249ae2 v7-3-1142
+66e849c4558aca6c522026882159b41994d0c0c1 v7-3-1143
+8360a59aa04b8668e377a66d1fc46e9e52b35110 v7-3-1144
+a30e3762957d61966152040315d160f860433576 v7-3-1145
+e3f9e33fb28c367aac7b2270b6fd304fd755b6d4 v7-3-1146
+3cd3cc1e91193a0b45e6aff1373cd4802e595a16 v7-3-1147
+220bdea4f57919c290d92b1f6c83a7252cd660b6 v7-3-1148
+66803af09906a828b9f41d7ae0f7a379137eaf99 v7-3-1149
+3dbd251777de232c168d87650acda5fec408146c v7-3-1150
+4d7e3df04256790855f7a6dc289f32ffc04da133 v7-3-1151
+9909e44879b9f80679fd05af19a423b2673b2301 v7-3-1152
+bc3f4804cf470cec5773d8842743efb760f69102 v7-3-1153
+6419ee8098c80f0418081c73b790b09c61f13c3a v7-3-1154
+bf1e6326df1104cabc04b8490f9456dbda901fd2 v7-3-1155
+8c4324e6f4779ee316361511ff783f6344750be9 v7-3-1156
+2f1ee97f5f23a5f9e1c572ed4afb50fb79ce7a35 v7-3-1157
+46077370bc605815f5e41cbfc925120a913acbaa v7-3-1158
+208a6c04e6b8221c1f5187391d86c5b57e61445b v7-3-1159
+60301d4d16827a961019d72a78e811f41326c680 v7-3-1160
+ff393592644960783e9a1c7c7959a8cbb0954673 v7-3-1161
+b8eabb6a96871321bec8526fa04ba1ff1a96780e v7-3-1162
+70b1178dec7919120632cdeee6056e38108356a7 v7-3-1163
+4db0bf9f1b44d1f0d42a1863732dfaef73c9971d v7-3-1164
+05b8436873d48055cbd24f043548092755d77be7 v7-3-1165
+d59ff2114733a526847ea38d093897f496f73ffc v7-3-1166
+81dedcd648216d6b3fc6b967368fef23d8ee1154 v7-3-1167
+ed47632fd1498d50e31ab5b30aac403de3db2496 v7-3-1168
+a83fb2bd8c8ea8865f460f7d82d8ebff8202cced v7-3-1169
+14c2e63caec65cca0d315e82f90b5e1d84430487 v7-3-1170
+fc7f985df53745d157182585b01ee5dadb722a62 v7-3-1171
+96e154e825a7441274a615e7d7fdbe68e5534ee9 v7-3-1172
+b584d361e7461c79728585f16f408984b0234fdd v7-3-1173
+52850ef928f85755f005267c1f02fe9e9f898c99 v7-3-1174
+84a8d1ba81c393dcc3a45eb3b20fb6ac5f18df7b v7-3-1175
+e48cabe984537b06cfa945926844c4af96799331 v7-3-1176
+e79a20f07daa91051435208887cc31b245555046 v7-3-1177
+c4d4f0fc12b9b8665d6859680155797be960c36f v7-3-1178
+d84833983de7708de27774e3f01e7ffc8c03eec6 v7-3-1179
+04b8912a9c85e72728a2cd6a4f8e6aee82525b31 v7-3-1180
+b7bb20390111b75616eb66558aa9517901eb0144 v7-3-1181
+fa98c2b030ed5ac8d8c8139405d20ad6c611c065 v7-3-1182
+044d23a64c177549b4b5e3183642f3a5b286d14f v7-3-1183
+9e36c6b1ebf4554a24bd879965f348b81ad5ca6a v7-3-1184
+6d935f45c489b346f06aef5b1bdd87cb98b8400b v7-3-1185
+7b8991e084f9bea2dde9ceef7a245254d656b6f9 v7-3-1186
+fefd8d33a7ea43f86d6e5a2ab30440140ada14f6 v7-3-1187
+6f7ed9b799a3db282f0fc076d8232752716a4e00 v7-3-1188
+dc78a26f6f64bb1330b9027559ce0c8fe54ba1de v7-3-1189
+25d64a4edc0b0f3f17330a7b12f3c1ca141ccfb3 v7-3-1190
+4c42efb4c0982d305ec9ee99bb3bddfaeec2cf87 v7-3-1191
+07b9c48a30e973833ee70d38633934f6fc2177d8 v7-3-1192
+8b46c37c4b843039e5a543be98978e79ff6f3d31 v7-3-1193
+91136a41f83f3716e7ccb4f2402216ea215a4acf v7-3-1194
+4837fd61be52d420c69fcde0621cd5ecc298d2b6 v7-3-1195
+56fbf60e94766a202ee71749eea19a862695c92f v7-3-1196
+2fc1f3346bfb3229f35455101a5944e6785a02af v7-3-1197
+517fa1a34c7cf1c8fb04d43976ad6c381f48cebd v7-3-1198
+be2973afe77045bd749c63c46ea02f61efa55862 v7-3-1199
+2945fe016b936c9e3a89db48692495c83f1843a1 v7-3-1200
+d8f65e6238fa2bac706f1a4868e8d38ad71ded64 v7-3-1201
+1707ddb6f5aed99b69fff8a66dc3eb8ab40d7f46 v7-3-1202
+ba328b4a990ee460cc907ec59aabee8d872b7768 v7-3-1203
+0792cc5133ce1f37ad9e1d49804100b28d0a391b v7-3-1204
+d02448031708fca0df590f46f850e33acc9f9651 v7-3-1205
+8dd2769ab75c07d88feb49d1dd489a1282854217 v7-3-1206
+6ae32a64e153d7275058d965e0c1c12d106bc7de v7-3-1207
+784e342ddcaeb260ffaab5f0dd30ec5db832842e v7-3-1208
+afb00cc8caacb8969705ffae0316bb9c01156e7f v7-3-1209
+7155782d94fb88e47e252b159dd677c31a3f14e8 v7-3-1210
+1cf02fbe6281c8efe63f866470b6c44d5835125c v7-3-1211
+81e623ff2e554695c372b7b06bd826c6298bb8b5 v7-3-1212
+ae05437a744a3b6f87d6f3304a19e5256849bb1c v7-3-1213
+bcb84438bb5bf27101b25ffb2c2267ab6ff0e946 v7-3-1214
+8bbd0ff486b3cfa711e0a7f305b4a0241bd5dd52 v7-3-1215
+b89aa3374b7fe64968421f4e20cf22cd3e95713b v7-3-1216
+613651492c1905f62cbbcbfc616d7935234badab v7-3-1217
+d10ede931224a9818a98a58bd9382f77728ced1b v7-3-1218
+eb5c3508cd7da14f8d3337ca4dfabe4122ded20c v7-3-1219
+ba7db05e1482457a36b19ed608f820275fafb9f7 v7-3-1220
+9f7b92f232d31450fd04ecec3e89b027c0f28b02 v7-3-1221
+07831d280e90a87ab9f42a9c96775ef2bc0cdedf v7-3-1222
+5cd32322154c1c5970194eb5300eec2ddb8ccc30 v7-3-1223
+0a379dea13c97df4ec2ba1487dd50c1e8ba0c912 v7-3-1224
+27b008d5b7ac5fab02c6934b87f258bc4715aed6 v7-3-1225
+b34d719b13cd9dd44485600e5cd939814b9b065f v7-3-1226
+5cee875f30961cf1adadf386b7e2764ea8aeeb64 v7-3-1227
+620d9b59d4ed9deaac614c707c71257907b1dd21 v7-3-1228
+b6e693e1f9461e5020e4cafa1c6e1de24776e11b v7-3-1229
+f5c822e5a0eba6f490d0be9f6892de929295be87 v7-3-1230
+537bbfff0c5c0bc2307a85133f59f07b00c55e41 v7-3-1231
+a594ce86b5eade96cb84415b3b027abe611c2238 v7-3-1232
+4ed713442c51625160cd0bca612d9a3417e4ba14 v7-3-1233
+f4969f8f66e974584e8e7815d0a262c5dca79638 v7-3-1234
+9ae0fe46777674504e0f372e68cfb8e0be81b2ee v7-3-1235
+39980afcf54aafdb9255424adf5808af45ab2242 v7-3-1236
+5b2c8f3b390632e1e57a3839f040146f6798a969 v7-3-1237
+048c69ebe8eecb218320030d9ea41fe4f6290848 v7-3-1238
+e130cc3d17af412971143b8420d6e7b1cbd13ff2 v7-3-1239
+bc9125136c69a4feecb4b68912fa04380f42b77f v7-3-1240
+c8747604696795a300f6ff05091813d691f9a488 v7-3-1241
+b4a2eaf28b51327b4e56b4eacf4b5d72a52560f6 v7-3-1242
+8a7d3a73adabaad5e9fe079acf6431982145c7d1 v7-3-1243
+b4a71dbdb78790ca423103ad5deb71b1df9b5b04 v7-3-1244
+43329b2b5b79ed2e1017869ee2e0b1caeaf2f0f6 v7-3-1245
+a1b41dabc682ed8f8770a12c2d3a227eb348885b v7-3-1246
+f451d60ab8ec56d02a7b5f2d5c16187566279886 v7-3-1247
+3717d569027d8ec8b62e42e33f91333ac22ce6ba v7-3-1248
+b614332f7df2f6f471bb4bd93767becd7844b90c v7-3-1249
+6aecf486bb347ac6885afe36d62ddbbf2457f898 v7-3-1250
+788f4802967766b7f3d6dce83cc027baef422f4a v7-3-1251
+875a0aeb301c3fb2be8a79f2d82e324d80caf4f3 v7-3-1252
+d6a7dea44a8667d834e463b8658cf85ea938112d v7-3-1253
+5eff37e92f03771aee77a3688d79a73e5b6107e9 v7-3-1254
+f8d307ebd74a4097f7083ea8117be0433f00c7ce v7-3-1255
+322441058afca6a8aa52d34eda9fa307608354d3 v7-3-1256
+5751284311f37399cb7a66d99fe317de4ae86ea9 v7-3-1257
+c9e2ccc53f2e119e247da7fc9111b6b9c9385d93 v7-3-1258
+7ab94cb688bebd694109442be4dd6edb6ebe3c85 v7-3-1259
+7aa4e0822dec0840770d9f41052a772a887cd213 v7-3-1260
+1cf89d38aa7628b55f1a45a5325adc83abe85dc2 v7-3-1261
+5e0b6a9282df8b9435da372cad77482f1f5b20aa v7-3-1262
+a02575cd564ade1019ea89db07c1c1d0c4b5418c v7-3-1263
+558c815e1a38d7ac2fc61c4155aabf8e81a14034 v7-3-1264
+53c1b30632df47993bc00947078dd31a226c9a97 v7-3-1265
+bbe4bd64c68c64afaa6636e8c3e9a9a6241e91cb v7-3-1266
+cabdcfe72dc398fd67bbbe02cff5e11e4dc2506e v7-3-1267
+72fcf674e545eb87bb4ea996df56e4eb7c04f6cc v7-3-1268
+350239b0e9eb063d9f84dfa4bc7a2b47d78e9afb v7-3-1269
+35b6fc57a2868b235284d914820da0815e62d54b v7-3-1270
+034abed357a1a2fabe624ed59ea49ebdec09d790 v7-3-1271
+a00cd1839ac4f3467e1e51e619b4c65ce4e0ee81 v7-3-1272
+30910831e5b0f0eb28a8eea7412f5ec9f3533ab2 v7-3-1273
+761cef8f5d1d42e315fb85765ee90857981fec06 v7-3-1274
+8875401008da99a39878478a293f833f68481ffc v7-3-1275
+d2f9f67924e77ec3d90164dd6ff2e50c5107faf0 v7-3-1276
+6a7ae677d6a1f116b685fa0f892052e20003eaad v7-3-1277
+cf52d2a8c05cd037c049abef0f58fd918146f3bb v7-3-1278
+cca600e6092839efeb3795db863916959921bb0e v7-3-1279
+1cacf785299e771ca463c493c8c870e395c09cd0 v7-3-1280
+19ed30f7cef76224ef39ceadefb64387eb986342 v7-3-1281
+22ac43fb6d30ad1097d0c7e8937b28efcb162137 v7-3-1282
+d6ceddc0be86e46a5a9a696e36c54b9d133f2203 v7-3-1283
+7b20dc8041645778eeb2f7823a4c1c647f735d24 v7-3-1284
+14e7a115d54d2c095f31ccda2d04fbcf775dacde v7-3-1285
+6ddc1785c4ff3779c18f5c313da591a052388b2d v7-3-1286
+34c629c3b4bab5fc755e83869d929f8cb322bfcd v7-3-1287
+8b7baf39a345aecf00a6116b5da211b51c6e3457 v7-3-1288
+1ed945570d47e9a60694ed1ef3a5b208243657e9 v7-3-1289
+08d4c11cdaed2c5d95e2c0be3b0df91d01f52b84 v7-3-1290
+a6ddcab6a240d22f965c4961bb93ddfea6a74c73 v7-3-1291
+cad8d29b0bc0356a49a455296e5e79eb6f38139d v7-3-1292
+18b43970fb7a796ab740e65baa4ff2ba46f929a8 v7-3-1293
+11d0c6df1d7bdc399b34a8cc70f354d6ee908661 v7-3-1294
+93cccad6a26b439728bf3c155ed5532001a2f2ab v7-3-1295
+c3a82208e143e4cd4a3b9d9b1716eb9d876bf462 v7-3-1296
+cb0a5c9c0f9bcc6c5a18ed97762206309d3e334c v7-3-1297
+dafd77a15d44cced4e405a9fcfe67fc48a02004a v7-3-1298
+f063be86b6323f396e6d3a7be73e860e636eb51d v7-3-1299
+56bc3698f8c6ac275a9a05b64ae056de619d226b v7-3-1300
+6cabac58f26fe9d8b608542d9fdbfed3fc437c90 v7-3-1301
+5569d11ef585033ef40e4402cd6a52453e4d13d9 v7-3-1302
+6e611380b4cf586f210de94d92a4f158b6900a5f v7-3-1303
+46d6318d5b965b77278ea252b25209468214dd2d v7-3-1304
+6f24376028af97c93b426cdbd46379795be7cdfd v7-3-1305
+71859e71b1f902c28b8842bc7092dd155b8c7f88 v7-3-1306
+3dafc80e781b8d5ed12d6107a2c804067aeafd90 v7-3-1307
+71e066e10a4789eeb9553aa08f9ca8e7eec96532 v7-3-1308
+a686295448918b7066bc52e3fd9748e6702c2219 v7-3-1309
+b49784c49d537fabe083cc3f8cc460629bb6957f v7-3-1310
+28e6f5f889683fe161b7bc260bd02b742157fc5b v7-3-1311
+80bab8b1a30db72b7eda880b0442ab0b0f4a1611 v7-3-1312
+afbc9dd67cea81e73d64f7ecce47dfcd35d48865 v7-3-1313
+29e57603bf6f3a2e3c178a63d332ed4d2eccfa82 v7-3-1314
+6ec6b7ff2d43842d04a8d653356d0ff3850707c0 v7-4a
+0ddba00c204d855c0b3da30cb338d9bdb0ded847 v7-4a-001
+d0288faf3086e6ccd5046edc91f1baf21bf1babf v7-4a-002
+b5abda4e7c4b8b04cb823c160c47097448823ba8 v7-4a-003
+f72d49c406c48293e30d774303493e4c8d120bfb v7-4a-004
+7a6ce0c426fec6051523bb00e050b826fa664beb v7-4a-005
+6b6e1786c7dfb2d1190373dfddc3cd33e5346e18 v7-4a-006
+c624928fbc49408ab932e5c79f5f79e53327d700 v7-4a-007
+b3bd43ef012d975cafb7b2a4c41fb78486ee4cc0 v7-4a-008
+467efeee8f9e2060891bc718e6aeffaf79eab43b v7-4a-009
+a4e08386a6aa29c5e58302f1650fa2ad3f03b76b v7-4a-010
+ce587b26b8d6bec140af41712bb99c4c73c3bf99 v7-4a-011
+fca6ba0d2d66d38da8ae023e73944a69662c0d66 v7-4a-012
+42d592dbbec3706429e3f3f75c9c394db6b9c1bd v7-4a-013
+08eb573821869727e5951e6586207dfbe5fd982c v7-4a-014
+7a1b782ec64ac55052755ed72ff023093b246d96 v7-4a-015
+4104bed69ea561a105c3db590aa6c75be2a24836 v7-4a-016
+4cbff53717d4920cb64d417c7a603b45519138f1 v7-4a-017
+c6dd0c545e5ca25e0b45fc1dbd7d1cb20642830e v7-4a-018
+bea5eb942011c09a6a8805e6b21079375462a710 v7-4a-019
+fa76be660fa914de79e3856caea8261cc7ab6c5b v7-4a-020
+fc6f4a653265f9e6b3dfa82faf067329dd5044a2 v7-4a-021
+c28202427d71b4460122754884bb548f084c3d7a v7-4a-022
+45b2278e6f461689d068f138428e9f3fdb01615c v7-4a-023
+ba9a11fe25637103e1a77fefbbaed4ac2ff182f9 v7-4a-024
+1b89e3f916c59fbdfdbd31e4d8af8b22274275b2 v7-4a-025
+b3ff17862b4c9d06411bd3c854cfceb77d5b97b6 v7-4a-026
+8edba3805d787f50b51d7fd59899c5361c09a348 v7-4a-027
+7aca84c0cd37ab4eceab8897e0297e2e318b8fff v7-4a-028
+2b58913e19a5a40d169f2aa1ef9530a78c375d2e v7-4a-029
+bc4fb031746594e4e84b36e64389e78454617a86 v7-4a-030
+839ebe7c1b2fb8150714fc48ec597d2e1f1c7557 v7-4a-031
+2741b46e96bfe6c06a5e9704bcad649655f7b50f v7-4a-032
+fa024ce48542356206bf86bdc9286ecf0510ad49 v7-4a-033
+947edb6335d1e196c27e2e7e0e0a5ed8f6b78498 v7-4a-034
+4ceacc1b00548c0b21c0dc2628608515899df721 v7-4a-035
+9982ec574beb1866536f0e8a0ace3073faa3bb97 v7-4a-036
+91d478da863e0779c482c790cc96b14188f3ecaf v7-4a-037
+8f983df0299fb4f1c7359eb3b844ee93e8f7e8fb v7-4a-038
+a08fa2919f2b39be0416109d87a42fbb5880ac76 v7-4a-039
+1261caf9bc5193d304140647c08ca5b52120ce52 v7-4a-040
+74d2f3188cd0aaa0d3d7cd3df001d88b04f77f5c v7-4a-041
+1899acc5aebd40f625b9fed7bc4c1b5f67e5bc3f v7-4a-042
+6fa64615c8d38ecf464702b102538c09fe250813 v7-4a-043
+647596ab1ae2f4b36bfc20293adf4b3a43372818 v7-4a-044
+da95a7f1d5a8413ae719188cec5b706b99db4a91 v7-4a-045
+f0361e297d9ceb533a17530647b4482c3990df3c v7-4a-046
+8c6615a30951fb9f2d2b218e55626f5dfa3fa24e v7-4a-047
+09c88160095d98a0b1403e9230c76e8adbb75d59 v7-4b-000
+47a09a572ea670d0498983eaa6ded5ab4f12fd15 v7-4b-001
+2e63b6c763f7af2ef11f751d3047847652dddfe0 v7-4b-002
+ea876fe914833a69018c54d6927dbbdb42ce6ecc v7-4b-003
+3c6e2b89875f39c8417021aa369695ec1ba762df v7-4b-004
+e63e4b4be9236c2d811b5ec7bdd79e387ec8bac9 v7-4b-005
+6b7ab6a4f31a54bceb4e7d6f0f9404b5a37bdad3 v7-4b-006
+b882d4b14e00af23444fd630aae3ac32214dd097 v7-4b-007
+3059c799fcd997ea60a63ed10a2a09d73e3ed3cf v7-4b-008
+cd971e951b0626c253059d8e25859032560920a6 v7-4b-009
+585b623a1aa3baea87a1584e6064612b2183d312 v7-4b-010
+7d1f89b2710305a00e6adac35a1fa6edd47982ba v7-4b-011
+25f67b62afd8c58b6c661961cc762f00ee89e562 v7-4b-012
+1ed6fd19c36051da73f9987777002b331853f5ea v7-4b-013
+3ddec3d25bd178d4f90114bce9ce889f3889e6d2 v7-4b-014
+d96f16667cc48d89c380fae29d86286b20040d5b v7-4b-015
+ba37e955913e85700677b89a720c6e5fc8d23cc3 v7-4b-016
+8c42772f05438e9f06200bca731cf301097be8ea v7-4b-017
+7ed1ec814dafe8109a2f34302174267d31bbc924 v7-4b-018
+74a211a0d3a3135dd67329cd981f5100f5e4d064 v7-4b-019
+46cf49cc9289920704999a971f397eee1efdb3fc v7-4b-020
+059c8a4b103f6971276435127c7ad970a81b0b2c v7-4b-021
+d5d6b78cff090e87d52924179e44131b5ba7436d v7-4b-022
+359743c1f59af353454dd80a26d9f8c20ae6ee8e v7-4
+3e9107b86b68d83bfa94e43afffbf17623afe55e v7-4-001
+e29f11399ccec9215cc8cfab1f9307dea0567d70 v7-4-002
+560a6a2329503d483db019a88cacc3307e5c30b7 v7-4-003
+f6247eaf4e1d556f782321890d725663f74babe6 v7-4-004
+3640cf4c0d4b6e5687bb7a31678fab70c88ed94b v7-4-005
+2374a05efe20287d55bd824689a41becc7662505 v7-4-006
+4fe1dfc7014e57b4beb5a01c9e94357265d19a92 v7-4-007
+b04bdb2c5fce70a278d26c477debb65a388da0ca v7-4-008
+8b5d80861c5e0403ea9f54ddddce2752a463c8a5 v7-4-009
+bb358cc41d920983629ace62bcf26decbf06cab4 v7-4-010
+54e66395831c1a58b4a9804e7884e505842157e8 v7-4-011
+8e28c23e482c5b3c8296d8022271822886793456 v7-4-012
+07737d3aa81725672796cbc9a010d63414ab6fea v7-4-013
+9801d06e7b4ccdcd02cf40bee34eaaada0ca0409 v7-4-014
+a7478f9f2551e95bff138cd658f7a86ced804ab1 v7-4-015
+8d5cd0ec3e7183a289f9bac41d3981307cdc1fac v7-4-016
+c47c8cd5fe5c014c141d9fb3fa8935b268436a4e v7-4-017
+460d5be9395ef3e05f4b1397ea98a5b54d825fc5 v7-4-018
+d5eb32dc231cd870c562e7b0be96fa994b505d9f v7-4-019
+c1ae5baa41f47bbf96be81e0158707a88af48b34 v7-4-020
+c514693882b9f1c7be2e76a0307926df799da3ea v7-4-021
+965044860b7f4884657fcaa042853238c7b13e69 v7-4-022
+09361f13580b075b6e87707c47165e8d45ee98a5 v7-4-023
+00d61a47df66cad21b80c6a683164e8d19180045 v7-4-024
+9085d32d7424963013650805452ede5dad22211c v7-4-025
+6bbb2ae990c92f6858b86c047e16dd12183d4273 v7-4-026
+73cc7272de5e0173b9578f715c4794a8b3803bce v7-4-027
+923738744a60e5e0bd2d9990758a2169106807ca v7-4-028
+2d3fbc68b3a84ad2bf4d58c77244043328e3fb81 v7-4-029
+0978e99043d2a9faedb1a3bad75b59121c270bde v7-4-030
+b21b5dcdca2197fc86b9bde77bd6777f0e2d5175 v7-4-031
+71e92a1cb37db719d6406858a50ca3bdfc9881fb v7-4-032
+91f6a28e010d49ae73c13c85dbb8b14c9e5edb36 v7-4-033
+22dfcd1494e4f7ea8ddc96e8dd895482e77e3b5a v7-4-034
+5481f188dcbb7143596f2d470c7d674bf36efe64 v7-4-035
+90e2f0729a0df249931a2dbe5f4310ba6c91cab4 v7-4-036
+c3d379c2a115b957d82eaa5f2215b688f36a22da v7-4-037
+6daa78b6b99a2ec07d20336db47c9f8165098062 v7-4-038
+4dfba3df303c51fe31efd1255338e9fcbedc5401 v7-4-039
+8336fd924e057d8c797043430325379d9a3ae37b v7-4-040
+408f2a1a953feef25a2c5c96352c82674655e797 v7-4-041
+70915ede509a737ac78c421f43c4447c9682ba41 v7-4-042
+6d11572e2c8b1117b90adf588ff1467b185c1b57 v7-4-043
+c0e3990aed3f179ef006e6de1458e9818c9ab896 v7-4-044
+8ced827b2e8ba49f9ae0da2033670fee83e7b55b v7-4-045
+68056d414f09fccb39219d7fde77fa06769ffa3b v7-4-046
+c21b2f52f1dd003d860e3b574602ed3fdc2b4f1c v7-4-047
+31c9acfeda8f1b84d51a480c1efbb56f384e76b1 v7-4-048
+15c1b8a20da6d650ee3ed0e73c2e3832093b60dd v7-4-049
+eb33cadafcabfc9cb3fc0741e169e84cafec11f8 v7-4-050
+e7a2f217a385e6aebfddc4d29182924ac017d262 v7-4-051
+b9c1c1f4cda9b82a2e703feec441d865b4722d56 v7-4-052
+733193bf24c3a80883c60964922c7cdc83662eb2 v7-4-053
+7b760cda2bbf086ba975fd5a4bdc6190a0f08caf v7-4-054
+38a755adc58063894c6695d702cc37f4910bad14 v7-4-055
+8d83c219fc7b2ec8685ab9e0dd7d3067b7f9d1e9 v7-4-056
+3109053ce4e3d17ca6ecab06c0ea0f38581d2f41 v7-4-057
+fa8447ec582378ca8d2c0245bd4ac195876abf2b v7-4-058
+2a72805a3038285c35f47dc0327a57cdabbdf09d v7-4-059
+46ca8fcee5257cc036ac928d91b2a490cf47a956 v7-4-060
+739074bdceb85d16b9e70791d91a59c2b846ed8d v7-4-061
+d59a0b8e5584c6e093990abb1b1e640aff7620bd v7-4-062
+9cedb4dfd4c830783ac65128dbbb118da2e3c638 v7-4-063
+d062239654688774d38e60ac42cec8ae1fd0f14b v7-4-064
+7f341db39d5bee0a9259a14a65e19bc9efa65417 v7-4-065
+38b948f534e4646bf879cb4d30151474e093d139 v7-4-066
+86bf09a1b6d0275131caf7ffc51598608e7242de v7-4-067
+efa40be729c2c94c1d8d0bf95000c4a7d2976dbc v7-4-068
+878ed73c70706d68bc7175343e4deb24b11963c2 v7-4-069
+e6f3f66028d448bb49ee2336cee60b13ced7cea9 v7-4-070
+faf7e86203b5d5c98bdd30dd92524e5062b2412a v7-4-071
+d563839a9be0be6e85d93e366b4f7ffe705d8e3b v7-4-072
+d0595545e98a3b7b6fe1a96ab0106d8afd63c31e v7-4-073
+9818311eeca0d76641879e95143f314e7295cc26 v7-4-074
+829aa8c8449d85d0de3a29ac8ce647ec706efd02 v7-4-075
+8f0c264db1e76a65499f0846d961907d7ecade9e v7-4-076
+53bc55e58fefee7a83a7a56fc7f05e0a4d36dd47 v7-4-077
+5c3064feddd7c9bfef18d8067172335f101122c5 v7-4-078
+6ae816249627b34aee618b49c4169b7ca1f54ff3 v7-4-079
+c5166fa1046462d73891f0b395d6619e7ce96c82 v7-4-080
+42927712b3d997bdba9d8ff5a1199fe4652c5899 v7-4-081
+9c777e2c702487bd0b5c48a22edc17c98b87e070 v7-4-082
+6367a766027d3b60caff43c35d8d3597ad90f6c6 v7-4-083
+a56f60cf683455bea96daf077458158041e4d6ba v7-4-084
+70c3289803b3129f34ffc327b113dcf152222a56 v7-4-085
+60a5b7b82016da631dd7acc6121913d02c5677f8 v7-4-086
+9334c994be7bb5e16a1f9c6b67e1c4342a6a386c v7-4-087
+853a76c7fdedefbc1dfdc2a4896d37a3806500e2 v7-4-088
+6707c44cec61d76026d5dcdd6573fb41cb89d0bd v7-4-089
+31217cc48e7d8c9aca703688d3d04d8edbc85bba v7-4-090
+9502d1caf90bf56f0125c99b7d17ba70944ebd85 v7-4-091
+1b4cb2c6b285265da4ffbe242af35a73e1b118e6 v7-4-092
+33f3e277ceab43179c74093f68196bd370199dbc v7-4-093
+68b5f8abca93dd035ba180aa673a5bbf035b89db v7-4-094
+acbe5414cb7f302f548bc1cbdc1ddb029dbf9094 v7-4-095
+645358801356c7b1c53a1d3b1543781a669a7733 v7-4-096
+93c8296281dd64e513d52db9f745965926df5cab v7-4-097
+79a8bac614c0c565617b404764f28675687ad442 v7-4-098
+8451f643a13eaf22e35a45e6bdd47c8d5b24c222 v7-4-099
+5ad60cd88339c6217fbea8cf4f92dae04ac1c71d v7-4-100
+ec5d11403c1952b2ed192f28afb6261d0867bb20 v7-4-101
+9417f4de27a2a6acfa6b1660ac6ef2b5692e4554 v7-4-102
+4db151014f93b7512919e452e6b3f4184758db7b v7-4-103
+dd7d1a86b311c11e9c03b7ca95c7b62206bbc7ab v7-4-104
+eed95874f30e9d9dad577f2361f2dfed93c5db4d v7-4-105
+de9a01851ebd1ce1d225b40c182b6f1e105863a7 v7-4-106
+064e2a080e2e158177acc017c318bc953fb7535b v7-4-107
+fa31c5b82424373885d2fa55b4f8531ac21baacd v7-4-108
+1cdf517067743dc33ebb9c7af8844abd9d9c7863 v7-4-109
+6e54d1b3408ca745341b0b219c588c265fa52494 v7-4-110
+3fbda56bb2008e2459951f3ad0258ff0500ba07c v7-4-111
+af8217e4ed7e28b797c628f067ebfd4433c07326 v7-4-112
+0e21e2a38ec6df5c4fe37d639906f56f9f445b96 v7-4-113
+6db758f82227989426560c19fdd234b154b54419 v7-4-114
+e35c69ad482370b2685bf1360a63fb27ce8b3819 v7-4-115
+40aff213baff00d43ea8c1b6a9734ccad63a3921 v7-4-116
+805ad8488dc88a575b841589f36c278aaead4e52 v7-4-117
+62c720661f81c17348636956c1158639d59e1e9f v7-4-118
+2f99966971b0556bc302ec809712f5ba3f030028 v7-4-119
+ca0e43bbf8f9e409130d5d1ce29621edbcdff92a v7-4-120
+4bf53c1ef37a5023e06f3c6b4f1c24857b4f52a6 v7-4-121
+270c62fe685ae943de64e1a4ab295dae6f4ccabe v7-4-122
+32e50f85d2c7a56c600a2c36107e56fa9f2952cb v7-4-123
+9faba192ea90a32ee137aa42f5027b098931ddb2 v7-4-124
+45ef9d2096e82d6a56a58606b6811620a61cb1ba v7-4-125
+b14554844756422a39c72e62b8c2391c2d5a2e17 v7-4-126
+6f5a7d3943007afc6bc03c445380776e18787f0c v7-4-127
+4b92012f6b18f56664c268200fb54f1316495dc5 v7-4-128
+1e28c0fad344549665c60c62374e6f511e5aec76 v7-4-129
+cf722c09236098ae585840d62eca68dbf8065247 v7-4-130
+4b23119cb58473ab70cf1a1204d4d3fad83881ec v7-4-131
+1b09d6792520cbe1c94c20f6c833ad57316e75bb v7-4-132
+6a28a9cf51537b81da7e9ec3f70fea55e393b345 v7-4-133
+0defb460a0ebbc954b0f22267cb06e9d210be43a v7-4-134
+1aeb7f4d6527369cf5f9101813ce8f10caf7a869 v7-4-135
+3881cd916014605875de128226b83a24d18afe46 v7-4-136
+6fdb1d6646b6b256623edb05f9dd770eeacaeb05 v7-4-137
+6eb60041548ce42748cd8d7d49bdbf9dd164c967 v7-4-138
+c8c80c9d2e2237fedeadfb1c6856c53c7a5e90d2 v7-4-139
+505cf1943dc238c2383dcbc37a93fbb136e1f08b v7-4-140
+2ca470c6096e3ec7cbbedeb1d0281056b088812b v7-4-141
+735b70faac4a54ca9d8ebc2303ba28d5d18017e2 v7-4-142
+d11f223f4c753889fa8f974f295c2a0a451c653c v7-4-143
+bcf25cc08236c2adc27a4d7d556e11e8ea6ddce2 v7-4-144
+1098b7b6e147cdd324ac665340540922c2cdceb3 v7-4-145
+ec93f50f1d93c4c279606117a9f3eb37301b051a v7-4-146
+d289f2167d702c87493d1934db863df29676e261 v7-4-147
+8507bf8874d816a79411bc74df71fa58b557b71d v7-4-148
+b43363a7b4c71a7a4e20dc21f4906f4595785983 v7-4-149
+15960ebc2ee8539a1f15f660d43df1a502c34829 v7-4-150
+ec02e1474bc2bbfd73349e7fedf62ae45f941ad9 v7-4-151
+2ace11abcfb59f6e88c3a40aa1d849d335cfd993 v7-4-152
+30e300c0b2c1c069d953afb258dba39c50772463 v7-4-153
+71837ace77dfdd6c01e0a334314a7c6c713a095c v7-4-154
+fa53233519c693591ce60f9270cf259c07d6cc26 v7-4-155
+05a5cb0d6b37eb7806eb902a72d8b00dde48bc1c v7-4-156
+be61f315eafe5cbadbd00bf7275e004fe09779db v7-4-157
+d59544f3022ba0a35af174d1085a321de6d3b9b4 v7-4-158
+a95a151402be5155cd89f8758e2e09ca95473ad1 v7-4-159
+f29febf858be9c7df896cc86ea89c3da8823b4fb v7-4-160
+91f3908748c29b0e8e759ac4cdafc95e536eab9a v7-4-161
+477665b4105fa80e3655981790e55fc9babfeed5 v7-4-162
+7db84aadd37aaf9d59f8f15dd6783a4e28dcb63c v7-4-163
+a01819fb6e2b5c270dac492ab2fe923ea9301651 v7-4-164
+c82339d8fdae0d43d51cde5216c979a5c9415bc4 v7-4-165
+5d03c374712128077ac4c342aad02120ed98df70 v7-4-166
+22387c8eec43ea8b1b704cad49c8f7187e2fd579 v7-4-167
+e61a2b709f693eea9108d475b9bab5ed10ac675d v7-4-168
+4e3a9dd25d428e7c08ed401afc244972e27e08e6 v7-4-169
+8122eab8fcdbbdaac62dfbf7c6458cb3e6f46b04 v7-4-170
+beb037a6c2708f539d50840637f70eed0811d93c v7-4-171
+391e10afccf6879dcfab8b28cb1587a13eb835c0 v7-4-172
+233ad7b960d0fbeb224b383918113b25c74ebe35 v7-4-173
+f2c8d86c460d75fec17a0527a2fe93ac7220693e v7-4-174
+6b69d8dde19e32909f4ee3a6337e6a2ecfbb6f72 v7-4-175
+ae228baaec2c5eda4cd948382c2bab498d1a34cc v7-4-176
+df3b0b70d8c1d29817597f45d19bb72755f86bd1 v7-4-177
+647e6bb15aa3f864eaf447fe77e3e3ae7e37b134 v7-4-178
+d1c8c1d6403485ff0135f0cf5c1ef07272a07173 v7-4-179
+b1b8b097539a001043d1f0aac4663d6ee358dee8 v7-4-180
+cb5683bcde03796baa7e845fd9a2fcaec3383538 v7-4-181
+708a6a5905217736a2a231e36ced82f9535c4954 v7-4-182
+1e2bfe4f3e903110f27cb6231f6642e721808837 v7-4-183
+9ac2fc63501d3eff92446c03b2822b30b169db5a v7-4-184
+b06e58f8dd3037f7f17145968d08432423ac8665 v7-4-185
+4d12112c5efae071aecbeed1a7196f18950457b3 v7-4-186
+a1c07956171a133583df42627d3498f935e59988 v7-4-187
+136f05449f29388e9023f7934d6344bf4ca61d0f v7-4-188
+0a9990bbd94a7dbdf20ca3f897cdf364c356d228 v7-4-189
+6050f52d7cd8d6f79ed5ee8ef3efff332aca4932 v7-4-190
+40f18a1c1592c8b4047f6f2a413557f48a99c55f v7-4-191
+04c4ef8c0a1b757494500e46400552b135135e94 v7-4-192
+a8650e2a0b5a5936f7d503429180df47df2aa775 v7-4-193
+767103b5bcb05171fc1be0d6f480e0aa39aff731 v7-4-194
+c2e88a40d530b7999cd29218555515bcd282d661 v7-4-195
+1ed6acdbfef55e6e80aea55c8bc52d05f8458bbd v7-4-196
+47a673b20e493db91844999f74aa3724808ac624 v7-4-197
+705f398ce6f58016fae80c945a570721fc989117 v7-4-198
+54b1a90c937380195fad6a52408aa3b4eed6d8d1 v7-4-199
+0559091e6f09b5b96619513639ac14578a019612 v7-4-200
+06e5f65c34d8136c3a9d2219429b7eca35cb3a21 v7-4-201
+22d7af9ff3e5e2b93fdbe8603df2f15155a5976b v7-4-202
+fb24b025c7cf07db79a559a3091db42e02c1af86 v7-4-203
+f5120cbf16b9a9c6e0fbb599a6524e05ecf11393 v7-4-204
+0ace3a24c2a0153f0aaf9b619d3958e7f486705f v7-4-205
+7e826028d3999b6125b4741d45b22a2d0a520679 v7-4-206
+2aa909427e44cd3aac7def024b66e41d0c9d0e0d v7-4-207
+9b5541e276aa56fd72c3bbba85a17ef023c54ba8 v7-4-208
+bb402c49379de97fcd475fbbbbdc5ed41e5dff07 v7-4-209
+420fd9cb86d51a92c4307a746557e81914c6d6c4 v7-4-210
+e90bef2240c8d187da6e8d8fa5007ec5afc12284 v7-4-211
+50dbef5e774af6a998d1798569566429c38378b1 v7-4-212
+e25a04c1c515e6eb32197291472f89bcadfabf89 v7-4-213
+fe02fdfbdec077d0dc501bca0c65c51e56e1bd11 v7-4-214
+f069a3a0f84451aa498c6c22d8f922d1e695e96d v7-4-215
+bf1775553d3bf561e289bbf367d014915d09eaad v7-4-216
+2f225a17c26b26eab87cfb89142fc0f95726ee92 v7-4-217
+ddc3f32a4b2191f829206322d46f0e9c7e365e22 v7-4-218
+37af1e6e91bb1e8ceb89d3ba1c49a04ffd889880 v7-4-219
+1e272e318daaba51ec932be83a2481987a133429 v7-4-220
+a548aae15b3a27a56d814900049785c29c01a37a v7-4-221
+9123b4d3ef05c7434b6f6cd011b63f63a9a4a539 v7-4-222
+4b78922d557c324de6b6a75515fb658235fa782c v7-4-223
+092b8f61021b91024b127de3983d1afb74b64996 v7-4-224
+eeb150c07647b3691d2696a3a4cdb96f6db5a63e v7-4-225
+b650f2db8f9604124c0ddfb14af0c04bd4ae0580 v7-4-226
+b0a9df477096e4abe938f998476e84e77db42e0b v7-4-227
+3ee5808a293c7436e34a696a09ed29ce38750d9a v7-4-228
+839cca5ec18d560e3714065e54ed38b6e812aaf7 v7-4-229
+57ecd7a8c0f052296b41b916eb1ae7f2a9a48b27 v7-4-230
+0a295a3c9e473512ad3b006a0fb752ad43d19094 v7-4-231
+845608965bd9d0b2755997a7be812746885ff105 v7-4-232
+22a1d5762ba3a75984e89dcc47a65498f63a6c2c v7-4-233
+d2286df8719d6e99c743e3bf6ac14d1f9debc84d v7-4-234
+5ab2946f7ce560985830fbc3c453bb0f7a01f385 v7-4-235
+a44087db72386d080e9da870d751daf498004be8 v7-4-236
+71b165a378ad580818f6d497ecf0f8ad054a9683 v7-4-237
+410ef4f1a3d2f4a6ecad9aaa87dae645d1578a19 v7-4-238
+98bfec9ea7608f312129475d4ca0ae6d1c6c232e v7-4-239
+8d1ba0a23588932d22ad37cbd87ae3bbd4bfeff8 v7-4-240
+a63d0cd691dc925283815d17d62f4e948d723a59 v7-4-241
+f084024c0ddbba46aabfafa2996c3f7d13080ab6 v7-4-242
+9f8fa56f1906f4f634cd602a7a2b4f8631faf526 v7-4-243
+da17c7de616e3829e4f59923ffa138a067928d9e v7-4-244
+80421d934ebde183ce545ab8d9eb3a4c2065c169 v7-4-245
+2cbac5608217cdce725a0f04d397d4466a3322fe v7-4-246
+76863b4b48a3684905527dcc688e5a8c4c5e23d9 v7-4-247
+e5f1f2ea0b4a4834791924880f78272ef52eb087 v7-4-248
+0b9a66ea49f435536745be0e0a6154be7b607249 v7-4-249
+a8f3f45896288bd7e0a27e0c28c3cc3457ccc507 v7-4-250
+29eb4c2a33ac701bfcd4d2e2bed7864eba876e0e v7-4-251
+a43a8262e1ceffc393625c53a1ffed9e6bcaba62 v7-4-252
+4901a36479f200b2e6700ad91c26911d92deb886 v7-4-253
+251acc686ca41e4bccb037ef44cd7b486774d580 v7-4-254
+5595506b985a198abae41ab0150ee50b8bf1686c v7-4-255
+afb542ea210cb9fc5fa8c5359bb4814370024b80 v7-4-256
+17903ded5e9a9d49ca73b324657b944f2954d4fd v7-4-257
+e8ffd1e6c8dc62c604d34e879791404bd15cab33 v7-4-258
+e4cd5bb75029d2c1208f3e31ebde4e03b16e8123 v7-4-259
+6bc874e4789a0f912b4fd6b23afecf19d80b1605 v7-4-260
+43c6cd07c8defd8505acbe479c6970764c08e6f9 v7-4-261
+0ea551fa607dc443b97c2fba97dc0c9cb0bcf303 v7-4-262
+af1bb39774f41c28eabd24d80cffc775695bc124 v7-4-263
+00acac0af680c2d8c82db5258474b121a5908926 v7-4-264
+8ec9d2196bee0c5108f2d2c196a660a7f4e5f29f v7-4-265
+8f84e906d454a95d3167678a745dde9de442b604 v7-4-266
+75f222d67cea335efbe0274de6340dba174c1e7e v7-4-267
+1a5ed2626b26a982e307a206572121a557adf709 v7-4-268
+81c26975e8f9dc7435353581346542409403f296 v7-4-269
+c519c446c5488bfd48c93a03efae4ae3e0c1f162 v7-4-270
+88b0571de4327ba5127a483493bd7d46e6a9850e v7-4-271
+00228400629e28384f7f52556c3c119ba0d0a44d v7-4-272
+747afb6a6de437131d9674e6b2bcc73d74863a89 v7-4-273
+1ee3fc5b40ae94c2a7fc5a62bca38d4f730f9bb2 v7-4-274
+8a3117a4887c1e12a1165c9719491f96753787d6 v7-4-275
+a6b59ee633a355095e6473ec5e2a7d9088bfb853 v7-4-276
+373204662d82e894b27ee76bc3319bc62c91f6ae v7-4-277
+b4ce0e1fb5a67d7d6b0bca8eaa3edc2e94a085d8 v7-4-278
+8e9db1f27a0063df023cc05a760fce73255dad24 v7-4-279
+daf7e98675cf395e1ef96f8040567affb2782a11 v7-4-280
+24c90f1fec859b54cf2b854b98c4c9e614c46061 v7-4-281
+6d0a1132dd71c7f55f7ed53fe99e97c79bfd05a4 v7-4-282
+aa99d04fa7e288a8580e3a5d4a9d6433a1572b48 v7-4-283
+3c35ca9666e88a8024af6dab585b8e79ab295f83 v7-4-284
+5cb1828fd0056de3c166e71fbafc67a74c57d7b1 v7-4-285
+be19015ef43cc17825929206790696c2e716035d v7-4-286
+66fe4908b649ba18426af6f69e8ccb01b487dcbd v7-4-287
+7965cb6a435ae1ea331c7c2f8740d3d4c3625f3b v7-4-288
+99374096a76b96d1128f5e6aa1fa92b4ba70fee9 v7-4-289
+b871734bf54ea185dbd2cc759d86dbfbe21cde26 v7-4-290
+b5972833add9de714f4651e26fd9ea63ec4a880c v7-4-291
+60cdaa05a6ad31cef55eb6b3dc1f57ecac6fcf79 v7-4-292
+10fc95f48546f438648b8357062e93c9c2c0a377 v7-4-293
+fdea5ea9afd139ea59dee6bdb3f1675b8b882bdf v7-4-294
+662ae48e7e246a63d38c9f3165b15b62252edaee v7-4-295
+53b87d790574b6d19034fb3390987c22fb928c58 v7-4-296
+81f5a056b2a582c8109da10cc538dc16a326a34d v7-4-297
+156f891d520e93eab5d3ce02784660fb13a3b0d3 v7-4-298
+daebf8ce66089c0c179fb436ceba359ef8d593d5 v7-4-299
+1157079ca5f167bcf8746dfc52ea5a85e6c87a30 v7-4-300
+8cb42aa3c4957a543e5dffe307475dbab969612f v7-4-301
+df141c80ea3a1ffcbf82d05c1314675231fcfa75 v7-4-302
+463ef551e9f62b63ac3f85f1f297b668b14bcd09 v7-4-303
+fed2e0967f8133ba9a44b0701f151c8d88c4896a v7-4-304
+63e7cc62402dffb180b40c04c63ceeb5f53957d7 v7-4-305
+05e1d8afcc5e375bf708ccc9810e2fd1a5a8a3cf v7-4-306
+06c10522d321d98874546b2a4d3b0ae145386f2e v7-4-307
+e3d2b8d83bb30c428a051f50791e454fcbc080af v7-4-308
+88a6e9f33822d33b6c32db578750c6c178c63f50 v7-4-309
+ccac0aa34eeaf46dad4b831461a532fc3fe71096 v7-4-310
+f6f7543043246107075f0d3739c471d51b7226da v7-4-311
+66eead134d6800fd4cf2d5d4b135d300c933f09a v7-4-312
+332a5c2b2956d9b18d85268a724d01deea27ec83 v7-4-313
+4d7af1962d6ce61df65fdc5c86544a61951f9517 v7-4-314
+646616b6ff4defcc7bef0b198b540f6d965a8126 v7-4-315
+0fc665889e8f0af532cb4e3be2f0ff0421bf2fbc v7-4-316
+8ffcb546d782121dfc9d88c7edc6f62421efce89 v7-4-317
+5c47dacf397c1c65d2dfc237b3ff395c66ec3d4d v7-4-318
+a076237d1c3849535681e82946a9041ed5525d7f v7-4-319
+f7bc601823e5c81e2ca412506a42eff9fd790ace v7-4-320
+c052937aae8ca5082f308b8ff0712c7eccdd30c8 v7-4-321
+fd96c55d683d76ece4ba01490d9796c13c988cdc v7-4-322
+238f5027830cad22e17a970483af9b160869cdf3 v7-4-323
+c476e0ac8b406693c3877baffa0e97ff25e59b06 v7-4-324
+1f288d2475488c3f44c7248e99019e2612580716 v7-4-325
+1dbcb23ae7a8b68ddbc28b4feb794c4c1db12395 v7-4-326
+99d8f2d72dcd4b850de81998cc9b1120c8165762 v7-4-327
+01d9ffdd6e6ffb39faf946e13ec63bd7dc31e162 v7-4-328
+018df65085f8990c1407442f8c783d4cee72a479 v7-4-329
+f9fa2e506b9f07549cd91074835c5c553db7b3a7 v7-4-330
+6d984caa0409fd284722c44cb09a0a2b5360bd4f v7-4-331
+8fed02d53b45848b0fff60de13d06858963cfb17 v7-4-332
+8ae50e3ef8bf733c0869c01b5132d02feffc0955 v7-4-333
+03d260a8ea0c0c67f424c387dbe2af5754e5e589 v7-4-334
+8ad2ecd116021ad5c945426e8bb80d741392b780 v7-4-335
+a42ba1e5099290a86cac1a9ac490c49e82e4c2cf v7-4-336
+0206ac84ff5fdce6d893c470e0909d2aed547a24 v7-4-337
+ef83b423ebf7de11c1063c795dd2186a9b59b90f v7-4-338
+fd7110d0c3bf4fea3cfa3d16da6c2a945d327c27 v7-4-339
+03f95f5e311b84653df70fb3c08a9d92cf21b8f0 v7-4-340
+adc4a84f72eb44dae657af713922a6e2c1f64ae3 v7-4-341
+8dcc6f142460b2d5eee119a174d441d46d95cd99 v7-4-342
+539ce56d8f35fe2deb5c4f57335e1adf97ae4e74 v7-4-343
+ce284c205558d103326a4c3f22f181774690b3eb v7-4-344
+ea2c5dfee1b04d216ebf992c5f46ecbdfee2854a v7-4-345
+3248c6e40aee01a7254d111dd846c6ec7889a804 v7-4-346
+a162d41f10e1c3c8673d86d8b0c58fdaf1bddeaf v7-4-347
+0b7586868f6da0372af7510650240e22dc1e6e64 v7-4-348
+79950dae1d7de8fc2cb0f8ddd087d403e2b9ce8e v7-4-349
+ad005d0114c1d2d83490787ef7ea2a3c6e5e7b9e v7-4-350
+f9ec944e4474c649faad642797ffd798a7102549 v7-4-351
+b4962cf3a1c06a1f60f1d750df8fcf7035b00b99 v7-4-352
+d42a1d3b74d40f580359dbd139d2d0dfa7235252 v7-4-353
+5deaa4e9812d4b4ae59d8a3e70bf19983e07e6da v7-4-354
+9a4efda75b5ef0f496d6a29c0a4dfcc7c03412f9 v7-4-355
+34465a179ce21c827cab4c65a75e6b490600a96f v7-4-356
+4eedfc4911a1db9c4874689f6c652be0094838f2 v7-4-357
+771b97ba3b4768c77f2070423a93152d6977f012 v7-4-358
+182c7b987283a567121e9c43d831779d1c88645f v7-4-359
+761687c6808f4c9c80d33a919a6bb506dfe9f674 v7-4-360
+a97e5b9dbc26800830e46cf3c1aa6efbfe258097 v7-4-361
+7fa2bed947fde3514a700c96861a537d816d6fd4 v7-4-362
+ff3816167b73fde35017d364b1a820014cd42e76 v7-4-363
+7b324826757595b21b0410a7b6f00227d73c655f v7-4-364
+4625fa27ba6f5b06294675b7f0d1bf8ae8f249fb v7-4-365
+ad775b58706587b6acfb0bb2c732e184efe4f778 v7-4-366
+bdbe2037066df6a463346be1768a56d98001fb36 v7-4-367
+021e16be3c026c9f883b2aba0b48469ecbae5d88 v7-4-368
+72ee0db83788638c36bbcb076cabc2ba6c8cd4e7 v7-4-369
+50575818a97fa4777e52272f5ffc769179d76a8d v7-4-370
+d44f298c43c74555f4ea21b710d377133f948d61 v7-4-371
+a122efb555c4f08405051369310451a627ed524b v7-4-372
+353330c512a9488cf5c1a3f8b8a57fa8cdd83a7a v7-4-373
+f59c4bf0ac3b525f703cafba9a9cb0aeb3cc7745 v7-4-374
+5a5492d676ab1e8334aa86ec552e7e33ee8828e1 v7-4-375
+c3bb76e5b2355c57d7f89997aa9e125e46afdea1 v7-4-376
+255561411d7ae4b3c713bfb2e2f13c5f08ce0c61 v7-4-377
+75ae211df37d789c54f660ccddddd0e370aa67ae v7-4-378
+16cfdf28be40ccbefaeb80ec574a098362a36a34 v7-4-379
+7cfbad4a78bf306e5aaf84dc9c29b48e7d77c1ef v7-4-380
+0a3d958e346ee051667d3e541273b78fb1dfed9a v7-4-381
+dbd7dc1ea2e6bd0fc3c9ec7faec76382412d0129 v7-4-382
+2f02675bc4b051fff7be63f5107f659045a010e1 v7-4-383
+6f88e2dafbf637f573372bb7d8957fe4f2fd0843 v7-4-384
+6e24b97dde6930a62ade6bee725babf4a39bb0a4 v7-4-385
+09af7cb358f0bafd4b7437ff580f4cd7e15b74a1 v7-4-386
+975d96776111914f69c8a0b98ef7db3bbb83cd10 v7-4-387
+76e7fb736c0e9d06b97ff95ee8baad1fb09d420b v7-4-388
+3d206df5c8284f7d5f4a987ae9c7a508f289f008 v7-4-389
+d3a674f6c7370f70d6b66dcefb9e36d22d73c7b7 v7-4-390
+f051e50a6a5feb0f0c6d209440d9d305b82f5836 v7-4-391
+589fd07888abc8a1208616c56b21898d3352fc5b v7-4-392
+1bff71d202621d97acc4ef21ce9f47b78f68bda3 v7-4-393
+d594c15521377493d5e23b03e4dbf5108df69acd v7-4-394
+65b0974c5bebf5d6b56e9abc90d86759d1c4f6d7 v7-4-395
+7766142fc7d3e90c2e15a9c606efcd97331edef8 v7-4-396
+8d361608fe86c534e51e4c7e583375642d34b7a4 v7-4-397
+f62b2e76dd809dc57cad9d0fd8f04a4f3a7193e9 v7-4-398
+18ac55444b37bcae8ea090f7b3abf4826c679bc3 v7-4-399
+50a658bf4cff030cbe6a97a53bb838b5976c2e1a v7-4-400
+ab71bb81b84e9a1cdf030b172f61d779ccda975c v7-4-401
+3aa37ad2c4ed4d4f979e7c7e7d5d88586c6b74ba v7-4-402
+86fb698a38d5c10f59928e57da94ce5b3e124a40 v7-4-403
+0242c27e40e1ce913ec2b6540371d5ea5fceeac9 v7-4-404
+4c25af735304ff17a27bb3ce21e7f7d3b304ff88 v7-4-405
+1134bba900c17abcecdc414c6e30da22c17d32a5 v7-4-406
+3f92ef156c664fb8fea1f036a4a4c87af487ba6b v7-4-407
+cb3218a69c2f0949bbff5bcf9beeccc83ef2ef59 v7-4-408
+de35e123e63c326be4a576f8e678ed9e63ed1f48 v7-4-409
+2fd550c75256cc1ecf06a4afc6a856b305cf7a8a v7-4-410
+d4e0c197e97968050596f4c441552383e31db63b v7-4-411
+4c845a1600d28db8edabd211e6d7a9cd03883ea6 v7-4-412
+121613e72e397db495f5e9b640b249aead5a61c1 v7-4-413
+67edf731a2403a8023440184872159ddc073093c v7-4-414
+20dbceb6f4713ccd01be45dc531abc269fbb7579 v7-4-415
+735bd597a8ffcb00edff68b34a26573b8f3cad9a v7-4-416
+e60327caf9095d5ec067a5ab47bf4a69c0f58580 v7-4-417
+00f58478e38b68faf783d8fe70c1439fe9dd732d v7-4-418
+0a42938f449cf306a429db373106d5e29d8d4312 v7-4-419
+93aa0340130912c69d4093fc626a3cbb0cc7ad68 v7-4-420
+3ee39fe2df7d60d6376b3429383c5c5e3f9bb3fe v7-4-421
+69da1498ce89dd093935c0e5013e1df8060a4e80 v7-4-422
+96a4fa8e530c12137af235a9aaad57d578f9eebd v7-4-423
+85a1802ae810f0e840f8b5d8f2827b4199b39750 v7-4-424
+2e804ebb3ee8cd59451f8f1c1be2f09ebce0d77a v7-4-425
+7ab9a9cf2859ae4b7c00c4fff016fd5a0869450e v7-4-426
+fca35aa9380a9e3acecc78f85e05f26436e87ae1 v7-4-427
+1fe61f6d52079f44f61b3e03cf9b0c300f2890d9 v7-4-428
+e98e415ea3b8c743a5ab04ad9f498ab1b11ae8cf v7-4-429
+f4e9c65a18d4a5753747f327ed55c10f05d8d91c v7-4-430
+5672a06e4bd84cae4194ff0584d487448bad8c38 v7-4-431
+59cd2b16f71846dec2e842491e509385beeda5e9 v7-4-432
+dd3dac42cb9b5f95ad16d5e08220b0c7adf4b024 v7-4-433
+4176c48c7dd51d0fcdb7403cbfb489a75b0d819d v7-4-434
+b98af9af378eebe674052aa9a1b1956ad3f96487 v7-4-435
+52fa8300ce205a8f3c45b3b1874564b7768630ea v7-4-436
+8515b42f939cdf3a59fa6120e989d9f8fe6f4571 v7-4-437
+db3b8fe8330ea2afabd6c4856be5c76ef86d4728 v7-4-438
+07b28e96af8bace1af65bac661f22716781103fd v7-4-439
+1f578cd9a65779d2597e0135a5916db621d65734 v7-4-440
+e754b23b7d1c3825dc2c6028867d631520a8cdca v7-4-441
+8c3c067b4ae3cc02ce4411042df05f97df5bc316 v7-4-442
+f1ba154c3a12d06cd0f40edbfc675103eb2dd7ad v7-4-443
+d4cc9f48d5a40382e3e3d52dfe6e948745ee13b4 v7-4-444
+1138726736fbdb92aa5259ca4b76573b8f4b3f79 v7-4-445
+63121fdd093ff71081725d5495337ea45d38daab v7-4-446
+0d2c821cdc2505879823a551baeeb8d3c61ce758 v7-4-447
+2fd96725b0632cd9183581ce13d7b2cbd734d8d4 v7-4-448
+cb5480096f1b9e8f44e9d742fa190a90d77e1c54 v7-4-449
+7c9abc70ffc187f9bb60d968cb7e3cc5ed6d4231 v7-4-450
+ac6cfdc02695b31b07e9beb60fd704f74f4d4c81 v7-4-451
+78aad99db7627a19574d10415780ded69936d7d7 v7-4-452
+c72eb8499a9d3f618de3528287d1de62025fdda4 v7-4-453
+0cdff7c268559f8f34eae073a013ece71b62b9e3 v7-4-454
+ebc72764fa1e74758ae1ef9d3f49301f80fc3aa4 v7-4-455
+54194bd6ed607aa0cec07d8a27d4794573eabba9 v7-4-456
+96761b6789f61a8dee1551b7cea98e669fb90fb3 v7-4-457
+fe1827921d50cb59ac680ea13e3f9103cd9db660 v7-4-458
+7816c24ff8907c9f24a9e35992a4d5f3cc9dbc7e v7-4-459
+d5eba03293a6193a1b462822800641b820252ce3 v7-4-460
+4eba2bdb26f2be61bfdb1f635c0ed65f4bc35b0b v7-4-461
+c0d93d67572b2d4161d0c5a5ab09477d6447ff49 v7-4-462
+6f80b9a773db0f3c69156f8768c8b6cfa4ad6785 v7-4-463
+74c65620c985f680eb1d7c1110f259cc37779ffa v7-4-464
+452e8b2a0ab39fb0cc037382cc4842a6d6b2a3f2 v7-4-465
+521c49b6de9d6352331dd8ff63286f6673014616 v7-4-466
+0a4efa3d20197cdf0bfe93080abc7cd197878e9a v7-4-467
+4f7f236d773d21e46ffa6c38d8df110d11413dca v7-4-468
+a6f5a4ac4d4666282179339abe696d7689f8681b v7-4-469
+9d5b8b015e5f32b84e0d74f21481b0cea2b84975 v7-4-470
+3005da486a71dc1171b3c8fe075701ea5e4b5668 v7-4-471
+af998690a8841d4df95cea0bed4246f2ba98e247 v7-4-472
+1cdd5804b538d578d71c9d85fddf8805cb200663 v7-4-473
diff -Naur vim74.orig/Filelist vim74/Filelist
--- vim74.orig/Filelist	2013-07-13 13:23:38.000000000 +0000
+++ vim74/Filelist	2014-10-10 14:53:39.565392559 +0000
@@ -3,6 +3,7 @@
 
 # source files for all source archives
 SRC_ALL =	\
+		.hgignore \
 		src/README.txt \
 		src/arabic.c \
 		src/arabic.h \
@@ -10,6 +11,8 @@
 		src/blowfish.c \
 		src/buffer.c \
 		src/charset.c \
+		src/crypt.c \
+		src/crypt_zip.c \
 		src/diff.c \
 		src/digraph.c \
 		src/edit.c \
@@ -79,11 +82,17 @@
 		src/xxd/xxd.c \
 		src/main.aap \
 		src/testdir/main.aap \
+		src/testdir/README.txt \
 		src/testdir/*.in \
+		src/testdir/sautest/autoload/*.vim \
 		src/testdir/test[0-9]*.ok \
+		src/testdir/test[0-9]*a.ok \
+		src/testdir/test_[a-z]*.ok \
 		src/testdir/test49.vim \
 		src/testdir/test60.vim \
 		src/testdir/test83-tags? \
+		src/testdir/test77a.com \
+		src/testdir/test_*.vim \
 		src/testdir/python2/*.py \
 		src/testdir/python3/*.py \
 		src/testdir/pythonx/*.py \
@@ -97,6 +106,8 @@
 		src/proto/blowfish.pro \
 		src/proto/buffer.pro \
 		src/proto/charset.pro \
+		src/proto/crypt.pro \
+		src/proto/crypt_zip.pro \
 		src/proto/diff.pro \
 		src/proto/digraph.pro \
 		src/proto/edit.pro \
@@ -283,6 +294,8 @@
 		src/dosinst.h \
 		src/glbl_ime.cpp \
 		src/glbl_ime.h \
+		src/gui_dwrite.cpp \
+		src/gui_dwrite.h \
 		src/gui_w16.c \
 		src/gui_w32.c \
 		src/gui_w48.c \
diff -Naur vim74.orig/runtime/autoload/clojurecomplete.vim vim74/runtime/autoload/clojurecomplete.vim
--- vim74.orig/runtime/autoload/clojurecomplete.vim	2013-02-06 14:35:23.000000000 +0000
+++ vim74/runtime/autoload/clojurecomplete.vim	2014-10-10 14:53:39.768725381 +0000
@@ -1,20 +1,22 @@
 " Vim completion script
-" Language:     Clojure
-" Maintainer:   Sung Pae <self@sungpae.com>
-" URL:          https://github.com/guns/vim-clojure-static
-" License:      Same as Vim
-" Last Change:  05 February 2013
+" Language:	Clojure
+" Maintainer:	Sung Pae <self@sungpae.com>
+" URL:		https://github.com/guns/vim-clojure-static
+" License:	Same as Vim
+" Last Change:	27 March 2014
 
-" Special forms and public vars in clojure.core
-" Generated from https://github.com/guns/vim-clojure-static/blob/vim-release-002/vim_clojure_static.clj
-" Clojure 1.5.0-RC6
-let s:words = ["*","*'","*1","*2","*3","*agent*","*allow-unresolved-vars*","*assert*","*clojure-version*","*command-line-args*","*compile-files*","*compile-path*","*compiler-options*","*data-readers*","*default-data-reader-fn*","*e","*err*","*file*","*flush-on-newline*","*fn-loader*","*in*","*math-context*","*ns*","*out*","*print-dup*","*print-length*","*print-level*","*print-meta*","*print-readably*","*read-eval*","*read-whitelist*","*source-path*","*unchecked-math*","*use-context-classloader*","*verbose-defrecords*","*warn-on-reflection*","+","+'","-","-'","->","->>","->ArrayChunk","->Vec","->VecNode","->VecSeq","-cache-protocol-fn","-reset-methods",".","..","/","<","<=","=","==",">",">=","EMPTY-NODE","accessor","aclone","add-classpath","add-watch","agent","agent-error","agent-errors","aget","alength","alias","all-ns","alter","alter-meta!","alter-var-root","amap","ancestors","and","apply","areduce","array-map","as->","aset","aset-boolean","aset-byte","aset-char","aset-double","aset-float","aset-int","aset-long","aset-short","assert","assoc!","assoc","assoc-in","associative?","atom","await","await-for","await1","bases","bean","bigdec","bigint","biginteger","binding","bit-and","bit-and-not","bit-clear","bit-flip","bit-not","bit-or","bit-set","bit-shift-left","bit-shift-right","bit-test","bit-xor","boolean","boolean-array","booleans","bound-fn","bound-fn*","bound?","butlast","byte","byte-array","bytes","case","cast","catch","char","char-array","char-escape-string","char-name-string","char?","chars","chunk","chunk-append","chunk-buffer","chunk-cons","chunk-first","chunk-next","chunk-rest","chunked-seq?","class","class?","clear-agent-errors","clojure-version","coll?","comment","commute","comp","comparator","compare","compare-and-set!","compile","complement","concat","cond","cond->","cond->>","condp","conj!","conj","cons","constantly","construct-proxy","contains?","count","counted?","create-ns","create-struct","cycle","dec","dec'","decimal?","declare","def","default-data-readers","definline","definterface","defmacro","defmethod","defmulti","defn","defn-","defonce","defprotocol","defrecord","defstruct","deftype","delay","delay?","deliver","denominator","deref","derive","descendants","destructure","disj!","disj","dissoc!","dissoc","distinct","distinct?","do","doall","dorun","doseq","dosync","dotimes","doto","double","double-array","doubles","drop","drop-last","drop-while","empty","empty?","ensure","enumeration-seq","error-handler","error-mode","eval","even?","every-pred","every?","ex-data","ex-info","extend","extend-protocol","extend-type","extenders","extends?","false?","ffirst","file-seq","filter","filterv","finally","find","find-keyword","find-ns","find-protocol-impl","find-protocol-method","find-var","first","flatten","float","float-array","float?","floats","flush","fn","fn","fn?","fnext","fnil","for","force","format","frequencies","future","future-call","future-cancel","future-cancelled?","future-done?","future?","gen-class","gen-interface","gensym","get","get-in","get-method","get-proxy-class","get-thread-bindings","get-validator","group-by","hash","hash-combine","hash-map","hash-set","identical?","identity","if","if-let","if-not","ifn?","import","in-ns","inc","inc'","init-proxy","instance?","int","int-array","integer?","interleave","intern","interpose","into","into-array","ints","io!","isa?","iterate","iterator-seq","juxt","keep","keep-indexed","key","keys","keyword","keyword?","last","lazy-cat","lazy-seq","let","let","letfn","line-seq","list","list*","list?","load","load-file","load-reader","load-string","loaded-libs","locking","long","long-array","longs","loop","loop","macroexpand","macroexpand-1","make-array","make-hierarchy","map","map-indexed","map?","mapcat","mapv","max","max-key","memfn","memoize","merge","merge-with","meta","method-sig","methods","min","min-key","mod","monitor-enter","monitor-exit","munge","name","namespace","namespace-munge","neg?","new","newline","next","nfirst","nil?","nnext","not","not-any?","not-empty","not-every?","not=","ns","ns-aliases","ns-imports","ns-interns","ns-map","ns-name","ns-publics","ns-refers","ns-resolve","ns-unalias","ns-unmap","nth","nthnext","nthrest","num","number?","numerator","object-array","odd?","or","parents","partial","partition","partition-all","partition-by","pcalls","peek","persistent!","pmap","pop!","pop","pop-thread-bindings","pos?","pr","pr-str","prefer-method","prefers","primitives-classnames","print","print-ctor","print-dup","print-method","print-simple","print-str","printf","println","println-str","prn","prn-str","promise","proxy","proxy-call-with-super","proxy-mappings","proxy-name","proxy-super","push-thread-bindings","pvalues","quot","quote","rand","rand-int","rand-nth","range","ratio?","rational?","rationalize","re-find","re-groups","re-matcher","re-matches","re-pattern","re-seq","read","read-line","read-string","realized?","recur","reduce","reduce-kv","reduced","reduced?","reductions","ref","ref-history-count","ref-max-history","ref-min-history","ref-set","refer","refer-clojure","reify","release-pending-sends","rem","remove","remove-all-methods","remove-method","remove-ns","remove-watch","repeat","repeatedly","replace","replicate","require","reset!","reset-meta!","resolve","rest","restart-agent","resultset-seq","reverse","reversible?","rseq","rsubseq","satisfies?","second","select-keys","send","send-off","send-via","seq","seq?","seque","sequence","sequential?","set!","set","set-agent-send-executor!","set-agent-send-off-executor!","set-error-handler!","set-error-mode!","set-validator!","set?","short","short-array","shorts","shuffle","shutdown-agents","slurp","some","some->","some->>","some-fn","sort","sort-by","sorted-map","sorted-map-by","sorted-set","sorted-set-by","sorted?","special-symbol?","spit","split-at","split-with","str","string?","struct","struct-map","subs","subseq","subvec","supers","swap!","symbol","symbol?","sync","take","take-last","take-nth","take-while","test","the-ns","thread-bound?","throw","time","to-array","to-array-2d","trampoline","transient","tree-seq","true?","try","type","unchecked-add","unchecked-add-int","unchecked-byte","unchecked-char","unchecked-dec","unchecked-dec-int","unchecked-divide-int","unchecked-double","unchecked-float","unchecked-inc","unchecked-inc-int","unchecked-int","unchecked-long","unchecked-multiply","unchecked-multiply-int","unchecked-negate","unchecked-negate-int","unchecked-remainder-int","unchecked-short","unchecked-subtract","unchecked-subtract-int","underive","unquote","unquote-splicing","update-in","update-proxy","use","val","vals","var","var-get","var-set","var?","vary-meta","vec","vector","vector-of","vector?","when","when-first","when-let","when-not","while","with-bindings","with-bindings*","with-in-str","with-loading-context","with-local-vars","with-meta","with-open","with-out-str","with-precision","with-redefs","with-redefs-fn","xml-seq","zero?","zipmap"]
+" -*- COMPLETION WORDS -*-
+" Generated from https://github.com/guns/vim-clojure-static/blob/vim-release-010/clj/src/vim_clojure_static/generate.clj
+" Clojure version 1.6.0
+let s:words = ["*","*'","*1","*2","*3","*agent*","*allow-unresolved-vars*","*assert*","*clojure-version*","*command-line-args*","*compile-files*","*compile-path*","*compiler-options*","*data-readers*","*default-data-reader-fn*","*e","*err*","*file*","*flush-on-newline*","*fn-loader*","*in*","*math-context*","*ns*","*out*","*print-dup*","*print-length*","*print-level*","*print-meta*","*print-readably*","*read-eval*","*source-path*","*unchecked-math*","*use-context-classloader*","*verbose-defrecords*","*warn-on-reflection*","+","+'","-","-'","->","->>","->ArrayChunk","->Vec","->VecNode","->VecSeq","-cache-protocol-fn","-reset-methods",".","..","/","<","<=","=","==",">",">=","EMPTY-NODE","accessor","aclone","add-classpath","add-watch","agent","agent-error","agent-errors","aget","alength","alias","all-ns","alter","alter-meta!","alter-var-root","amap","ancestors","and","apply","areduce","array-map","as->","aset","aset-boolean","aset-byte","aset-char","aset-double","aset-float","aset-int","aset-long","aset-short","assert","assoc!","assoc","assoc-in","associative?","atom","await","await-for","await1","bases","bean","bigdec","bigint","biginteger","binding","bit-and","bit-and-not","bit-clear","bit-flip","bit-not","bit-or","bit-set","bit-shift-left","bit-shift-right","bit-test","bit-xor","boolean","boolean-array","booleans","bound-fn","bound-fn*","bound?","butlast","byte","byte-array","bytes","case","cast","catch","char","char-array","char-escape-string","char-name-string","char?","chars","chunk","chunk-append","chunk-buffer","chunk-cons","chunk-first","chunk-next","chunk-rest","chunked-seq?","class","class?","clear-agent-errors","clojure-version","coll?","comment","commute","comp","comparator","compare","compare-and-set!","compile","complement","concat","cond","cond->","cond->>","condp","conj!","conj","cons","constantly","construct-proxy","contains?","count","counted?","create-ns","create-struct","cycle","dec","dec'","decimal?","declare","def","default-data-readers","definline","definterface","defmacro","defmethod","defmulti","defn","defn-","defonce","defprotocol","defrecord","defstruct","deftype","delay","delay?","deliver","denominator","deref","derive","descendants","destructure","disj!","disj","dissoc!","dissoc","distinct","distinct?","do","doall","dorun","doseq","dosync","dotimes","doto","double","double-array","doubles","drop","drop-last","drop-while","empty","empty?","ensure","enumeration-seq","error-handler","error-mode","eval","even?","every-pred","every?","ex-data","ex-info","extend","extend-protocol","extend-type","extenders","extends?","false?","ffirst","file-seq","filter","filterv","finally","find","find-keyword","find-ns","find-protocol-impl","find-protocol-method","find-var","first","flatten","float","float-array","float?","floats","flush","fn","fn","fn?","fnext","fnil","for","force","format","frequencies","future","future-call","future-cancel","future-cancelled?","future-done?","future?","gen-class","gen-interface","gensym","get","get-in","get-method","get-proxy-class","get-thread-bindings","get-validator","group-by","hash","hash-combine","hash-map","hash-ordered-coll","hash-set","hash-unordered-coll","identical?","identity","if","if-let","if-not","if-some","ifn?","import","in-ns","inc","inc'","init-proxy","instance?","int","int-array","integer?","interleave","intern","interpose","into","into-array","ints","io!","isa?","iterate","iterator-seq","juxt","keep","keep-indexed","key","keys","keyword","keyword?","last","lazy-cat","lazy-seq","let","let","letfn","line-seq","list","list*","list?","load","load-file","load-reader","load-string","loaded-libs","locking","long","long-array","longs","loop","loop","macroexpand","macroexpand-1","make-array","make-hierarchy","map","map-indexed","map?","mapcat","mapv","max","max-key","memfn","memoize","merge","merge-with","meta","method-sig","methods","min","min-key","mix-collection-hash","mod","monitor-enter","monitor-exit","munge","name","namespace","namespace-munge","neg?","new","newline","next","nfirst","nil?","nnext","not","not-any?","not-empty","not-every?","not=","ns","ns-aliases","ns-imports","ns-interns","ns-map","ns-name","ns-publics","ns-refers","ns-resolve","ns-unalias","ns-unmap","nth","nthnext","nthrest","num","number?","numerator","object-array","odd?","or","parents","partial","partition","partition-all","partition-by","pcalls","peek","persistent!","pmap","pop!","pop","pop-thread-bindings","pos?","pr","pr-str","prefer-method","prefers","primitives-classnames","print","print-ctor","print-dup","print-method","print-simple","print-str","printf","println","println-str","prn","prn-str","promise","proxy","proxy-call-with-super","proxy-mappings","proxy-name","proxy-super","push-thread-bindings","pvalues","quot","quote","rand","rand-int","rand-nth","range","ratio?","rational?","rationalize","re-find","re-groups","re-matcher","re-matches","re-pattern","re-seq","read","read-line","read-string","realized?","record?","recur","reduce","reduce-kv","reduced","reduced?","reductions","ref","ref-history-count","ref-max-history","ref-min-history","ref-set","refer","refer-clojure","reify","release-pending-sends","rem","remove","remove-all-methods","remove-method","remove-ns","remove-watch","repeat","repeatedly","replace","replicate","require","reset!","reset-meta!","resolve","rest","restart-agent","resultset-seq","reverse","reversible?","rseq","rsubseq","satisfies?","second","select-keys","send","send-off","send-via","seq","seq?","seque","sequence","sequential?","set!","set","set-agent-send-executor!","set-agent-send-off-executor!","set-error-handler!","set-error-mode!","set-validator!","set?","short","short-array","shorts","shuffle","shutdown-agents","slurp","some","some->","some->>","some-fn","some?","sort","sort-by","sorted-map","sorted-map-by","sorted-set","sorted-set-by","sorted?","special-symbol?","spit","split-at","split-with","str","string?","struct","struct-map","subs","subseq","subvec","supers","swap!","symbol","symbol?","sync","take","take-last","take-nth","take-while","test","the-ns","thread-bound?","throw","time","to-array","to-array-2d","trampoline","transient","tree-seq","true?","try","type","unchecked-add","unchecked-add-int","unchecked-byte","unchecked-char","unchecked-dec","unchecked-dec-int","unchecked-divide-int","unchecked-double","unchecked-float","unchecked-inc","unchecked-inc-int","unchecked-int","unchecked-long","unchecked-multiply","unchecked-multiply-int","unchecked-negate","unchecked-negate-int","unchecked-remainder-int","unchecked-short","unchecked-subtract","unchecked-subtract-int","underive","unquote","unquote-splicing","unsigned-bit-shift-right","update-in","update-proxy","use","val","vals","var","var-get","var-set","var?","vary-meta","vec","vector","vector-of","vector?","when","when-first","when-let","when-not","when-some","while","with-bindings","with-bindings*","with-in-str","with-loading-context","with-local-vars","with-meta","with-open","with-out-str","with-precision","with-redefs","with-redefs-fn","xml-seq","zero?","zipmap"]
 
-" Simple word completion omnifunc
+" Simple word completion for special forms and public vars in clojure.core
 function! clojurecomplete#Complete(findstart, base)
-    if a:findstart
-        return searchpos('\<', 'bnW', line('.'))[1] - 1
-    else
-        return { 'words': filter(copy(s:words), 'v:val =~ "\\V\\^' . a:base . '"') }
-    endif
+	if a:findstart
+		return searchpos('\<', 'bnW', line('.'))[1] - 1
+	else
+		return { 'words': filter(copy(s:words), 'v:val =~# "\\V\\^' . a:base . '"') }
+	endif
 endfunction
+
+" vim:sts=8:sw=8:ts=8:noet
diff -Naur vim74.orig/runtime/autoload/getscript.vim vim74/runtime/autoload/getscript.vim
--- vim74.orig/runtime/autoload/getscript.vim	2013-04-17 13:40:44.000000000 +0000
+++ vim74/runtime/autoload/getscript.vim	2014-10-10 14:53:39.775392031 +0000
@@ -1,8 +1,8 @@
 " ---------------------------------------------------------------------
 " getscript.vim
 "  Author:	Charles E. Campbell
-"  Date:	Apr 17, 2013
-"  Version:	35
+"  Date:	Jan 21, 2014
+"  Version:	36
 "  Installing:	:help glvs-install
 "  Usage:	:help glvs
 "
@@ -15,7 +15,7 @@
 if exists("g:loaded_getscript")
  finish
 endif
-let g:loaded_getscript= "v35"
+let g:loaded_getscript= "v36"
 if &cp
  echoerr "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
  finish
@@ -208,8 +208,8 @@
   let lastline    = line("$")
 "  call Decho("lastline#".lastline)
   let firstdir    = substitute(&rtp,',.*$','','')
-  let plugins     = split(globpath(firstdir,"plugin/*.vim"),'\n')
-  let plugins     = plugins + split(globpath(firstdir,"AsNeeded/*.vim"),'\n')
+  let plugins     = split(globpath(firstdir,"plugin/**/*.vim"),'\n')
+  let plugins     = plugins + split(globpath(firstdir,"AsNeeded/**/*.vim"),'\n')
   let foundscript = 0
 
   " this loop updates the GetLatestVimScripts.dat file
diff -Naur vim74.orig/runtime/autoload/htmlcomplete.vim vim74/runtime/autoload/htmlcomplete.vim
--- vim74.orig/runtime/autoload/htmlcomplete.vim	2011-04-28 11:13:20.000000000 +0000
+++ vim74/runtime/autoload/htmlcomplete.vim	2014-10-10 14:53:39.782058681 +0000
@@ -1,7 +1,49 @@
 " Vim completion script
 " Language:	HTML and XHTML
 " Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
-" Last Change:	2011 Apr 28
+" Last Change:	2014 Jun 20
+
+" Distinguish between HTML versions.
+" To use with other HTML versions add another "elseif" condition to match
+" proper DOCTYPE.
+function! htmlcomplete#DetectOmniFlavor()
+  if &filetype == 'xhtml'
+    let b:html_omni_flavor = 'xhtml10s'
+  else
+    let b:html_omni_flavor = 'html401t'
+  endif
+  let i = 1
+  let line = ""
+  while i < 10 && i < line("$")
+    let line = getline(i)
+    if line =~ '<!DOCTYPE.*\<DTD '
+      break
+    endif
+    let i += 1
+  endwhile
+  if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
+    if line =~ ' HTML 3\.2'
+      let b:html_omni_flavor = 'html32'
+    elseif line =~ ' XHTML 1\.1'
+      let b:html_omni_flavor = 'xhtml11'
+    else    " two-step detection with strict/frameset/transitional
+      if line =~ ' XHTML 1\.0'
+	let b:html_omni_flavor = 'xhtml10'
+      elseif line =~ ' HTML 4\.01'
+	let b:html_omni_flavor = 'html401'
+      elseif line =~ ' HTML 4.0\>'
+	let b:html_omni_flavor = 'html40'
+      endif
+      if line =~ '\<Transitional\>'
+	let b:html_omni_flavor .= 't'
+      elseif line =~ '\<Frameset\>'
+	let b:html_omni_flavor .= 'f'
+      else
+	let b:html_omni_flavor .= 's'
+      endif
+    endif
+  endif
+endfunction
 
 function! htmlcomplete#CompleteTags(findstart, base)
   if a:findstart
diff -Naur vim74.orig/runtime/autoload/netrw.vim vim74/runtime/autoload/netrw.vim
--- vim74.orig/runtime/autoload/netrw.vim	2013-05-19 03:28:33.000000000 +0000
+++ vim74/runtime/autoload/netrw.vim	2014-10-10 14:53:39.815391930 +0000
@@ -1,10 +1,10 @@
 " netrw.vim: Handles file transfer and remote directory listing across
 "            AUTOLOAD SECTION
-" Date:		May 18, 2013
-" Version:	149
+" Date:		May 13, 2014
+" Version:	152
 " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
 " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
-" Copyright:    Copyright (C) 1999-2012 Charles E. Campbell {{{1
+" Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
 "               Permission is hereby granted to use and distribute this code,
 "               with or without modifications, provided that this copyright
 "               notice is copied with it. Like anything else that's free,
@@ -22,13 +22,14 @@
 if &cp || exists("g:loaded_netrw")
   finish
 endif
-let g:loaded_netrw = "v149"
-if v:version < 703 || (v:version == 703 && !has("patch465"))
- echohl WarningMsg
- echo "***warning*** this version of netrw needs vim 7.3.465 or later"
- echohl Normal
+if v:version < 704 || !has("patch213")
+ if !exists("s:needpatch213")
+  echo "***sorry*** this version of netrw requires vim v7.4 with patch 213"
+ endif
+ let s:needpatch213= 1
  finish
 endif
+let g:loaded_netrw = "v152"
 if !exists("s:NOTE")
  let s:NOTE    = 0
  let s:WARNING = 1
@@ -36,8 +37,9 @@
 endif
 
 let s:keepcpo= &cpo
-set cpo&vim
-"DechoTabOn
+setl cpo&vim
+"let g:dechofuncname=1
+"DechoRemOn
 "call Decho("doing autoload/netrw.vim version ".g:loaded_netrw)
 
 " ======================
@@ -49,7 +51,7 @@
 "   0=note     = s:NOTE
 "   1=warning  = s:WARNING
 "   2=error    = s:ERROR
-"  May 01, 2013 : max errnum currently is 93
+"  Apr 16, 2014 : max errnum currently is 97
 fun! netrw#ErrorMsg(level,msg,errnum)
 "  call Dfunc("netrw#ErrorMsg(level=".a:level." msg<".a:msg."> errnum=".a:errnum.") g:netrw_use_errorwindow=".g:netrw_use_errorwindow)
 
@@ -104,8 +106,8 @@
     hi link netrwMesgWarning WarningMsg
     hi link netrwMesgError   Error
    endif
-"   call Decho("(ErrorMsg) setl noma ro bh=wipe")
-   setl noma ro bh=wipe
+"   call Decho("setl noma ro bh=wipe")
+   setl ro nomod noma bh=wipe
 
   else
    " (optional) netrw will show messages using echomsg.  Even if the
@@ -200,6 +202,7 @@
   let g:netrw_http_cmd	= ""
  endif
 endif
+call s:NetrwInit("g:netrw_http_put_cmd","curl -T")
 call s:NetrwInit("g:netrw_rcp_cmd"  , "rcp")
 call s:NetrwInit("g:netrw_rsync_cmd", "rsync")
 if !exists("g:netrw_scp_cmd")
@@ -249,7 +252,7 @@
 call s:NetrwInit("g:netrw_altv"        , &spr)
 call s:NetrwInit("g:netrw_banner"      , 1)
 call s:NetrwInit("g:netrw_browse_split", 0)
-call s:NetrwInit("g:netrw_bufsettings" , "noma nomod nonu nobl nowrap ro")
+call s:NetrwInit("g:netrw_bufsettings" , "noma nomod nonu nobl nowrap ro nornu")
 call s:NetrwInit("g:netrw_chgwin"      , -1)
 call s:NetrwInit("g:netrw_compress"    , "gzip")
 call s:NetrwInit("g:netrw_ctags"       , "ctags")
@@ -260,6 +263,7 @@
 call s:NetrwInit("g:netrw_cursor"      , 2)
 let s:netrw_usercul = &cursorline
 let s:netrw_usercuc = &cursorcolumn
+call s:NetrwInit("g:netrw_cygdrive","/cygdrive")
 " Default values - d-g ---------- {{{3
 call s:NetrwInit("s:didstarstar",0)
 call s:NetrwInit("g:netrw_dirhist_cnt"      , 0)
@@ -291,23 +295,19 @@
 endif
 call s:NetrwInit("g:netrw_keepdir",1)
 if !exists("g:netrw_list_cmd")
-
  if g:netrw_scp_cmd =~ '^pscp' && executable("pscp")
   if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable("c:\\private.ppk")
    " provide a pscp-based listing command
    let g:netrw_scp_cmd ="pscp -i C:\\private.ppk"
   endif
   let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME:"
-
  elseif executable(g:netrw_ssh_cmd)
   " provide a scp-based default listing command
   let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa"
-
  else
-"  call Decho(g:netrw_ssh_cmd." is not executable")
+"  call Decho("g:netrw_ssh_cmd." is not executable")
   let g:netrw_list_cmd= ""
  endif
-
 endif
 call s:NetrwInit("g:netrw_list_hide","")
 " Default values - lh-lz ---------- {{{3
@@ -323,7 +323,7 @@
   if g:netrw_cygwin
    let g:netrw_localcopycmd= "cp"
   else
-   let g:netrw_localcopycmd= "cmd /c copy"
+   let g:netrw_localcopycmd= expand("$COMSPEC")." /c copy"
   endif
  elseif has("unix") || has("macunix")
   let g:netrw_localcopycmd= "cp"
@@ -335,7 +335,15 @@
  let g:netrw_localmkdir= g:netrw_local_mkdir
  call netrw#ErrorMsg(s:NOTE,"g:netrw_local_mkdir is deprecated in favor of g:netrw_localmkdir",87)
 endif
-call s:NetrwInit("g:netrw_localmkdir","mkdir")
+if has("win32") || has("win95") || has("win64") || has("win16")
+  if g:netrw_cygwin
+   call s:NetrwInit("g:netrw_localmkdir","mkdir")
+  else
+   let g:netrw_localmkdir= expand("$COMSPEC")." /c mkdir"
+  endif
+else
+ call s:NetrwInit("g:netrw_localmkdir","mkdir")
+endif
 call s:NetrwInit("g:netrw_remote_mkdir","mkdir")
 if exists("g:netrw_local_movecmd")
  let g:netrw_localmovecmd= g:netrw_local_movecmd
@@ -346,7 +354,7 @@
   if g:netrw_cygwin
    let g:netrw_localmovecmd= "mv"
   else
-   let g:netrw_localmovecmd= "cmd /c move"
+   let g:netrw_localmovecmd= expand("$COMSPEC")." /c move"
   endif
  elseif has("unix") || has("macunix")
   let g:netrw_localmovecmd= "mv"
@@ -354,11 +362,19 @@
   let g:netrw_localmovecmd= ""
  endif
 endif
-call s:NetrwInit("g:netrw_localrmdir", "rmdir")
 if exists("g:netrw_local_rmdir")
  let g:netrw_localrmdir= g:netrw_local_rmdir
  call netrw#ErrorMsg(s:NOTE,"g:netrw_local_rmdir is deprecated in favor of g:netrw_localrmdir",86)
 endif
+if has("win32") || has("win95") || has("win64") || has("win16")
+  if g:netrw_cygwin
+   call s:NetrwInit("g:netrw_localrmdir","rmdir")
+  else
+   let g:netrw_localrmdir= expand("$COMSPEC")." /c rmdir"
+  endif
+else
+ call s:NetrwInit("g:netrw_localrmdir","rmdir")
+endif
 call s:NetrwInit("g:netrw_liststyle"  , s:THINLIST)
 " sanity checks
 if g:netrw_liststyle < 0 || g:netrw_liststyle >= s:MAXLIST
@@ -387,8 +403,17 @@
 call s:NetrwInit("g:netrw_rename_cmd"    , g:netrw_ssh_cmd." USEPORT HOSTNAME mv")
 call s:NetrwInit("g:netrw_rm_cmd"        , g:netrw_ssh_cmd." USEPORT HOSTNAME rm")
 call s:NetrwInit("g:netrw_rmdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME rmdir")
-call s:NetrwInit("g:netrw_rmf_cmd"       , g:netrw_ssh_cmd." USEPORT HOSTNAME rm -f")
-" Default values - s ---------- {{{3
+call s:NetrwInit("g:netrw_rmf_cmd"       , g:netrw_ssh_cmd." USEPORT HOSTNAME rm -f ")
+" Default values - q-s ---------- {{{3
+call s:NetrwInit("g:netrw_quickhelp",0)
+let s:QuickHelp= ["-:go up dir  D:delete  R:rename  s:sort-by  x:special",
+   \              "%:create new file  d:create new directory",
+   \              "o:split&open  v:vert-split&open",
+   \              "i:style  qf:file info  O:obtain  r:reverse  p:preview",
+   \              "mf:mark file  mt:set target  mm:move  mc:copy",
+   \              "-bookmarks-  mb:make  mB:delete  qb:list  gb:go to",
+   \              "-history-  qb:list  u:go up  U:go down",
+   \              "-targets-  mt:target Tb:use bookmark  Th:use history"]
 " g:netrw_sepchr: picking a character that doesn't appear in filenames that can be used to separate priority from filename
 call s:NetrwInit("g:netrw_sepchr"        , (&enc == "euc-jp")? "\<Char-0x01>" : "\<Char-0xff>")
 call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil keepj " : "keepj ")
@@ -404,7 +429,7 @@
 endif
 call s:NetrwInit("g:netrw_special_syntax"   , 0)
 call s:NetrwInit("g:netrw_ssh_browse_reject", '^total\s\+\d\+$')
-call s:NetrwInit("g:netrw_use_noswf"        , 0)
+call s:NetrwInit("g:netrw_use_noswf"        , 1)
 " Default values - t-w ---------- {{{3
 call s:NetrwInit("g:netrw_timefmt","%c")
 if !exists("g:netrw_xstrlen")
@@ -421,7 +446,6 @@
 call s:NetrwInit("g:NetrwTopLvlMenu","Netrw.")
 call s:NetrwInit("g:netrw_win95ftp",1)
 call s:NetrwInit("g:netrw_winsize",50)
-if g:netrw_winsize ==  0|let g:netrw_winsize=  -1|endif
 if g:netrw_winsize > 100|let g:netrw_winsize= 100|endif
 " ---------------------------------------------------------------------
 " Default values for netrw's script variables: {{{2
@@ -434,6 +458,11 @@
 call s:NetrwInit("g:netrw_menu_escape",'.&? \')
 call s:NetrwInit("g:netrw_tmpfile_escape",' &;')
 call s:NetrwInit("s:netrw_map_escape","<|\n\r\\\<C-V>\"")
+if has("gui_running") && (&enc == 'utf-8' || &enc == 'utf-16' || &enc == 'ucs-4')
+ let s:treedepthstring= " "
+else
+ let s:treedepthstring= "| "
+endif
 
 " BufEnter event ignored by decho when following variable is true
 "  Has a side effect that doau BufReadPost doesn't work, so
@@ -444,11 +473,18 @@
 "  Netrw Initialization: {{{1
 " ======================
 if v:version >= 700 && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on")
- let s:initbeval = &beval
-" let s:initbexpr = &l:bexpr
- let &l:bexpr    = "netrw#NetrwBalloonHelp()"
- set beval
- au BufWinEnter,WinEnter *	if &ft == "netrw"|set beval|else|let &beval= s:initbeval|endif
+" call Decho("installed beval events")
+ let &l:bexpr = "netrw#BalloonHelp()"
+ au FileType netrw	setl beval
+ au WinLeave *		if &ft == "netrw" && exists("s:initbeval")|let &beval= s:initbeval|endif
+ au VimEnter * 		let s:initbeval= &beval
+"else " Decho
+" if v:version < 700           | call Decho("did not install beval events: v:version=".v:version." < 700")     | endif
+" if !has("balloon_eval")      | call Decho("did not install beval events: does not have balloon_eval")        | endif
+" if exists("s:initbeval")     | call Decho("did not install beval events: s:initbeval exists")                | endif
+" if exists("g:netrw_nobeval") | call Decho("did not install beval events: g:netrw_nobeval exists")            | endif
+" if !has("syntax")            | call Decho("did not install beval events: does not have syntax highlighting") | endif
+" if exists("g:syntax_on")     | call Decho("did not install beval events: g:syntax_on exists")                | endif
 endif
 au WinEnter *	if &ft == "netrw"|call s:NetrwInsureWinVars()|endif
 
@@ -457,276 +493,43 @@
 " ==============================
 
 " ---------------------------------------------------------------------
-" netrw#NetrwBalloonHelp: {{{2
-if v:version >= 700 && has("balloon_eval") && &beval == 1 && has("syntax") && exists("g:syntax_on")
-  fun! netrw#NetrwBalloonHelp()
-    if !exists("w:netrw_bannercnt") || v:beval_lnum >= w:netrw_bannercnt || (exists("g:netrw_nobeval") && g:netrw_nobeval)
-     let mesg= ""
-    elseif     v:beval_text == "Netrw" || v:beval_text == "Directory" || v:beval_text == "Listing"
-     let mesg = "i: thin-long-wide-tree  gh: quick hide/unhide of dot-files   qf: quick file info  %:open new file"
-    elseif     getline(v:beval_lnum) =~ '^"\s*/'
-     let mesg = "<cr>: edit/enter   o: edit/enter in horiz window   t: edit/enter in new tab   v:edit/enter in vert window"
-    elseif     v:beval_text == "Sorted" || v:beval_text == "by"
-     let mesg = 's: sort by name, time, or file size   r: reverse sorting order   mt: mark target'
-    elseif v:beval_text == "Sort"   || v:beval_text == "sequence"
-     let mesg = "S: edit sorting sequence"
-    elseif v:beval_text == "Hiding" || v:beval_text == "Showing"
-     let mesg = "a: hiding-showing-all   ctrl-h: editing hiding list   mh: hide/show by suffix"
-    elseif v:beval_text == "Quick" || v:beval_text == "Help"
-     let mesg = "Help: press <F1>"
-    elseif v:beval_text == "Copy/Move" || v:beval_text == "Tgt"
-     let mesg = "mt: mark target   mc: copy marked file to target   mm: move marked file to target"
-    else
-     let mesg= ""
-    endif
-    return mesg
-  endfun
-endif
-
-" ------------------------------------------------------------------------
-" s:NetrwOptionSave: save options prior to setting to "netrw-buffer-standard" form {{{2
-"  06/08/07 : removed call to NetrwSafeOptions(), either placed
-"             immediately after NetrwOptionSave() calls in NetRead
-"             and NetWrite, or after the s:NetrwEnew() call in
-"             NetrwBrowse.
-"             vt: normally its "w:" or "s:" (a variable type)
-fun! s:NetrwOptionSave(vt)
-"  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
-"  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"))
-
-  if !exists("{a:vt}netrw_optionsave")
-   let {a:vt}netrw_optionsave= 1
-  else
-"   call Dret("s:NetrwOptionSave : options already saved")
-   return
-  endif
-"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff)
-
-  " Save current settings and current directory
-"  call Decho("saving current settings and current directory")
-  let s:yykeep          = @@
-  if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
-  let {a:vt}netrw_aikeep    = &l:ai
-  let {a:vt}netrw_awkeep    = &l:aw
-  let {a:vt}netrw_bhkeep    = &l:bh
-  let {a:vt}netrw_blkeep    = &l:bl
-  let {a:vt}netrw_btkeep    = &l:bt
-  let {a:vt}netrw_bombkeep  = &l:bomb
-  let {a:vt}netrw_cedit     = &cedit
-  let {a:vt}netrw_cikeep    = &l:ci
-  let {a:vt}netrw_cinkeep   = &l:cin
-  let {a:vt}netrw_cinokeep  = &l:cino
-  let {a:vt}netrw_comkeep   = &l:com
-  let {a:vt}netrw_cpokeep   = &l:cpo
-  let {a:vt}netrw_diffkeep  = &l:diff
-  let {a:vt}netrw_fenkeep   = &l:fen
-  let {a:vt}netrw_ffkeep    = &l:ff
-  let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
-  let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
-  let {a:vt}netrw_hidkeep   = &l:hidden
-  let {a:vt}netrw_imkeep    = &l:im
-  let {a:vt}netrw_iskkeep   = &l:isk
-  let {a:vt}netrw_lskeep    = &l:ls
-  let {a:vt}netrw_makeep    = &l:ma
-  let {a:vt}netrw_magickeep = &l:magic
-  let {a:vt}netrw_modkeep   = &l:mod
-  let {a:vt}netrw_nukeep    = &l:nu
-  let {a:vt}netrw_repkeep   = &l:report
-  let {a:vt}netrw_rokeep    = &l:ro
-  let {a:vt}netrw_selkeep   = &l:sel
-  let {a:vt}netrw_spellkeep = &l:spell
-  let {a:vt}netrw_tskeep    = &l:ts
-  let {a:vt}netrw_twkeep    = &l:tw           " textwidth
-  let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
-  let {a:vt}netrw_wrapkeep  = &l:wrap
-  let {a:vt}netrw_writekeep = &l:write
-  if g:netrw_use_noswf && has("win32") && !has("win95")
-   let {a:vt}netrw_swfkeep   = &l:swf
-  endif
-
-  " save a few selected netrw-related variables
-"  call Decho("saving a few selected netrw-related variables")
-  if g:netrw_keepdir
-   let {a:vt}netrw_dirkeep  = getcwd()
-  endif
-  if has("win32") && !has("win95")
-   let {a:vt}netrw_swfkeep  = &l:swf          " swapfile
-  endif
-  if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
-  sil! let {a:vt}netrw_regslash= @/
-
-"  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
-endfun
-
-" ------------------------------------------------------------------------
-" s:NetrwOptionRestore: restore options {{{2
-fun! s:NetrwOptionRestore(vt)
-"  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
-  if !exists("{a:vt}netrw_optionsave")
-   if exists("s:nbcd_curpos_{bufnr('%')}")
-"    call Decho("(NetrwOptionRestore) restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
-    keepj call netrw#NetrwRestorePosn(s:nbcd_curpos_{bufnr('%')})
-"    call Decho("(NetrwOptionRestore) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
-"    call Decho("(NetrwOptionRestore) unlet s:nbcd_curpos_".bufnr('%'))
-    unlet s:nbcd_curpos_{bufnr('%')}
-   else
-"    call Decho("(NetrwOptionRestore) no previous position")
-   endif
-"   call Decho("(NetrwOptionRestore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
-"   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
-   return
-  endif
-  unlet {a:vt}netrw_optionsave
-
-  if exists("+acd")
-   if exists("{a:vt}netrw_acdkeep")
-"    call Decho("(NetrwOptionRestore) g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
-    let curdir = getcwd()
-    let &l:acd = {a:vt}netrw_acdkeep
-    unlet {a:vt}netrw_acdkeep
-    if &l:acd
-"     call Decho("exe keepj lcd ".fnameescape(curdir))  " NOTE: was g:netrw_fname_escape for some reason
-     try
-      if !exists("&l:acd") && !&l:acd
-       exe 'keepj lcd '.fnameescape(curdir)
-      endif
-     catch /^Vim\%((\a\+)\)\=:E472/
-      call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".curdir."> (permissions?)",61)
-     endtry
-    endif
+" netrw#BalloonHelp: {{{2
+if v:version >= 700 && has("balloon_eval") && has("syntax") && exists("g:syntax_on") && !exists("g:netrw_nobeval")
+" call Decho("loading netrw#BalloonHelp()")
+ fun! netrw#BalloonHelp()
+   if &ft != "netrw"
+    return ""
    endif
-  endif
-  if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
-  if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
-  if g:netrw_liststyle != s:TREELIST
-   if exists("{a:vt}netrw_bhkeep")  |let &l:bh     = {a:vt}netrw_bhkeep      |unlet {a:vt}netrw_bhkeep   |endif
-  endif
-  if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
-  if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
-  if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
-  if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
-  if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
-  if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
-  if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
-  if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
-  if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
-  if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
-  if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
-  if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
-  if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
-  if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
-  if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
-  if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
-  if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
-  if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
-  if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
-  if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
-  if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
-  if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
-  if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
-  if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
-  if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
-  if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
-  " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
-"  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
-  if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
-  if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
-  if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
-  if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
-  if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
-  if exists("{a:vt}netrw_swfkeep")
-   if &directory == ""
-    " user hasn't specified a swapfile directory;
-    " netrw will temporarily set the swapfile directory
-    " to the current directory as returned by getcwd().
-    let &l:directory   = getcwd()
-    sil! let &l:swf = {a:vt}netrw_swfkeep
-    setl directory=
-    unlet {a:vt}netrw_swfkeep
-   elseif &l:swf != {a:vt}netrw_swfkeep
-    " following line causes a Press ENTER in windows -- can't seem to work around it!!!
-    sil! let &l:swf= {a:vt}netrw_swfkeep
-    unlet {a:vt}netrw_swfkeep
+   if !exists("w:netrw_bannercnt") || v:beval_lnum >= w:netrw_bannercnt || (exists("g:netrw_nobeval") && g:netrw_nobeval)
+    let mesg= ""
+   elseif     v:beval_text == "Netrw" || v:beval_text == "Directory" || v:beval_text == "Listing"
+    let mesg = "i: thin-long-wide-tree  gh: quick hide/unhide of dot-files   qf: quick file info  %:open new file"
+   elseif     getline(v:beval_lnum) =~ '^"\s*/'
+    let mesg = "<cr>: edit/enter   o: edit/enter in horiz window   t: edit/enter in new tab   v:edit/enter in vert window"
+   elseif     v:beval_text == "Sorted" || v:beval_text == "by"
+    let mesg = 's: sort by name, time, or file size   r: reverse sorting order   mt: mark target'
+   elseif v:beval_text == "Sort"   || v:beval_text == "sequence"
+    let mesg = "S: edit sorting sequence"
+   elseif v:beval_text == "Hiding" || v:beval_text == "Showing"
+    let mesg = "a: hiding-showing-all   ctrl-h: editing hiding list   mh: hide/show by suffix"
+   elseif v:beval_text == "Quick" || v:beval_text == "Help"
+    let mesg = "Help: press <F1>"
+   elseif v:beval_text == "Copy/Move" || v:beval_text == "Tgt"
+    let mesg = "mt: mark target   mc: copy marked file to target   mm: move marked file to target"
+   else
+    let mesg= ""
    endif
-  endif
-  if exists("{a:vt}netrw_dirkeep") && isdirectory({a:vt}netrw_dirkeep) && g:netrw_keepdir
-   let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
-   if exists("{a:vt}netrw_dirkeep")  |exe "keepj lcd ".fnameescape(dirkeep)|unlet {a:vt}netrw_dirkeep  |endif
-  endif
-  if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
-  if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
-  if exists("s:nbcd_curpos_{bufnr('%')}")
-"   call Decho("(NetrwOptionRestore) restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
-   keepj call netrw#NetrwRestorePosn(s:nbcd_curpos_{bufnr('%')})
-"   call Decho("(NetrwOptionRestore) unlet s:nbcd_curpos_".bufnr('%'))
-   unlet s:nbcd_curpos_{bufnr('%')}
-  else
-"   call Decho("no previous position")
-  endif
-
-"  call Decho("(NetrwOptionRestore) g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
-"  call Decho("(NetrwOptionRestore) fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"))
-"  call Decho("(NetrwOptionRestore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
-"  call Decho("(NetrwOptionRestore) diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"))
-"  call Decho("(NetrwOptionRestore) ts=".&l:ts)
-  " Moved the filetype detect here from NetrwGetFile() because remote files
-  " were having their filetype detect-generated settings overwritten by
-  " NetrwOptionRestore.
-  if &ft != "netrw"
-"   call Decho("(NetrwOptionRestore) filetype detect  (ft=".&ft.")")
-   filetype detect
-  endif
-"  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
-endfun
-
-" ---------------------------------------------------------------------
-" s:NetrwSafeOptions: sets options to help netrw do its job {{{2
-"                     Use  s:NetrwSaveOptions() to save user settings
-"                     Use  s:NetrwOptionRestore() to restore user settings
-fun! s:NetrwSafeOptions()
-"  call Dfunc("s:NetrwSafeOptions() win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
-"  call Decho("win#".winnr()."'s ft=".&ft)
-  if exists("+acd") | setl noacd | endif
-  setl noai
-  setl noaw
-  setl nobomb
-  setl noci
-  setl nocin
-  if g:netrw_liststyle == s:TREELIST
-   setl bh=hide
-  endif
-  setl cino=
-  setl com=
-  setl cpo-=a
-  setl cpo-=A
-  setl fo=nroql2
-   setl nohid
-  setl noim
-  setl isk+=@ isk+=* isk+=/
-  setl magic
-  setl report=10000
-  setl sel=inclusive
-  setl nospell
-  setl tw=0
-  setl wig=
-  set  cedit&
-  if g:netrw_use_noswf && has("win32") && !has("win95")
-   setl noswf
-  endif
-  call s:NetrwCursor()
-
-  " allow the user to override safe options
-"  call Decho("ft<".&ft."> ei=".&ei)
-  if &ft == "netrw"
-"   call Decho("do any netrw FileType autocmds (doau FileType netrw)")
-   sil! keepalt keepj doau FileType netrw
-  endif
-
-"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh)
-"  call Dret("s:NetrwSafeOptions")
-endfun
+   return mesg
+ endfun
+"else " Decho
+" if v:version < 700            |call Decho("did not load netrw#BalloonHelp(): vim version ".v:version." < 700 -")|endif
+" if !has("balloon_eval")       |call Decho("did not load netrw#BalloonHelp(): does not have balloon eval")       |endif
+" if !has("syntax")             |call Decho("did not load netrw#BalloonHelp(): syntax disabled")                  |endif
+" if !exists("g:syntax_on")     |call Decho("did not load netrw#BalloonHelp(): g:syntax_on=".g:syntax_on)         |endif
+" if  exists("g:netrw_nobeval") |call Decho("did not load netrw#BalloonHelp(): g:netrw_nobeval exists")           |endif
+endif
 
-" ---------------------------------------------------------------------
+" ------------------------------------------------------------------------
 " netrw#Explore: launch the local browser in the directory of the current file {{{2
 "          indx:  == -1: Nexplore
 "                 == -2: Pexplore
@@ -737,7 +540,7 @@
 "                      * If Hexplore or Vexplore, then this will override
 "                        g:netrw_winsize to specify the qty of rows or columns the
 "                        newly split window should have.
-"          dosplit==0: the window will be split iff the current file has been modified
+"          dosplit==0: the window will be split iff the current file has been modified and hidden not set
 "          dosplit==1: the window will be split before running the local browser
 "          style == 0: Explore     style == 1: Explore!
 "                == 2: Hexplore    style == 3: Hexplore!
@@ -747,26 +550,52 @@
 "  call Dfunc("netrw#Explore(indx=".a:indx." dosplit=".a:dosplit." style=".a:style.",a:1<".a:1.">) &modified=".&modified." modifiable=".&modifiable." a:0=".a:0." win#".winnr()." buf#".bufnr("%"))
   if !exists("b:netrw_curdir")
    let b:netrw_curdir= getcwd()
-   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
-    let b:netrw_curdir= substitute(b:netrw_curdir,'\','/','g')
-   endif
-"   call Decho("(Explore) set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)")
+"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)")
+  endif
+
+  " record current file for Rexplore's benefit
+  if &ft != "netrw"
+   let w:netrw_rexfile= expand("%:p")
   endif
+
+  " record current directory
   let curdir     = simplify(b:netrw_curdir)
   let curfiledir = substitute(expand("%:p"),'^\(.*[/\\]\)[^/\\]*$','\1','e')
   if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
    let curdir= substitute(curdir,'\','/','g')
   endif
-"  call Decho("(Explore) curdir<".curdir.">  curfiledir<".curfiledir.">")
+"  call Decho("curdir<".curdir.">  curfiledir<".curfiledir.">")
+
+  " using completion, directories with spaces in their names (thanks, Bill Gates, for a truly dumb idea)
+  " will end up with backslashes here.  Solution: strip off backslashes that precede white space and
+  " try Explore again.
+  if a:0 > 0
+"   call Decho('considering retry: a:1<'.a:1.'>: '.
+     \ ((a:1 =~ "\\\s")?     'has backslash whitespace' : 'does not have backslash whitespace').', '.
+     \ ((filereadable(a:1))? 'is readable'              : 'is not readable').', '.
+     \ ((isdirectory(a:1))?  'is a directory'           : 'is not a directory'))
+   if a:1 =~ "\\\s" && !filereadable(a:1) && !isdirectory(a:1)
+"    call Decho("re-trying Explore with <".substitute(a:1,'\\\(\s\)','\1','g').">")
+    call netrw#Explore(a:indx,a:dosplit,a:style,substitute(a:1,'\\\(\s\)','\1','g'))
+"    call Dret("netrw#Explore : returning from retry")
+    return
+"   else " Decho
+"    call Decho("retry not needed")
+   endif
+  endif
 
   " save registers
-  sil! let keepregstar = @*
-  sil! let keepregplus = @+
+  if has("clipboard")
+   sil! let keepregstar = @*
+   sil! let keepregplus = @+
+  endif
   sil! let keepregslash= @/
 
-  " if dosplit or file has been modified
-  if a:dosplit || &modified || a:style == 6
-"   call Decho("(Explore) case dosplit=".a:dosplit." modified=".&modified." a:style=".a:style.": dosplit or file has been modified")
+  " if   dosplit
+  " -or- file has been modified AND file not hidden when abandoned
+  " -or- Texplore used
+  if a:dosplit || (&modified && &hidden == 0 && &bufhidden != "hide") || a:style == 6
+"   call Decho("case dosplit=".a:dosplit." modified=".&modified." a:style=".a:style.": dosplit or file has been modified")
    call s:SaveWinVars()
    let winsz= g:netrw_winsize
    if a:indx > 0
@@ -774,106 +603,119 @@
    endif
 
    if a:style == 0      " Explore, Sexplore
-"    call Decho("(Explore) style=0: Explore or Sexplore")
+"    call Decho("style=0: Explore or Sexplore")
     let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
-    exe winsz."wincmd s"
+    if winsz == 0|let winsz= ""|endif
+    exe "noswapfile ".winsz."wincmd s"
+"    call Decho("exe noswapfile ".winsz."wincmd s")
 
    elseif a:style == 1  "Explore!, Sexplore!
-"    call Decho("(Explore) style=1: Explore! or Sexplore!")
+"    call Decho("style=1: Explore! or Sexplore!")
     let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
-    exe "keepalt ".winsz."wincmd v"
+    if winsz == 0|let winsz= ""|endif
+    exe "keepalt noswapfile ".winsz."wincmd v"
+"    call Decho("exe keepalt noswapfile ".winsz."wincmd v")
 
    elseif a:style == 2  " Hexplore
-"    call Decho("(Explore) style=2: Hexplore")
+"    call Decho("style=2: Hexplore")
     let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
-    exe "keepalt bel ".winsz."wincmd s"
+    if winsz == 0|let winsz= ""|endif
+    exe "keepalt noswapfile bel ".winsz."wincmd s"
+"    call Decho("exe keepalt noswapfile bel ".winsz."wincmd s")
 
    elseif a:style == 3  " Hexplore!
-"    call Decho("(Explore) style=3: Hexplore!")
+"    call Decho("style=3: Hexplore!")
     let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
-    exe "keepalt abo ".winsz."wincmd s"
+    if winsz == 0|let winsz= ""|endif
+    exe "keepalt noswapfile abo ".winsz."wincmd s"
+"    call Decho("exe keepalt noswapfile abo ".winsz."wincmd s")
 
    elseif a:style == 4  " Vexplore
-"    call Decho("(Explore) style=4: Vexplore")
+"    call Decho("style=4: Vexplore")
     let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
-    exe "keepalt lefta ".winsz."wincmd v"
+    if winsz == 0|let winsz= ""|endif
+    exe "keepalt noswapfile lefta ".winsz."wincmd v"
+"    call Decho("exe keepalt noswapfile lefta ".winsz."wincmd v")
 
    elseif a:style == 5  " Vexplore!
-"    call Decho("(Explore) style=5: Vexplore!")
+"    call Decho("style=5: Vexplore!")
     let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
-    exe "keepalt rightb ".winsz."wincmd v"
+    if winsz == 0|let winsz= ""|endif
+    exe "keepalt noswapfile rightb ".winsz."wincmd v"
+"    call Decho("exe keepalt noswapfile rightb ".winsz."wincmd v")
 
    elseif a:style == 6  " Texplore
     call s:SaveBufVars()
-"    call Decho("(Explore) style  = 6: Texplore")
+"    call Decho("style  = 6: Texplore")
     exe "keepalt tabnew ".fnameescape(curdir)
+"    call Decho("exe keepalt tabnew ".fnameescape(curdir))
     call s:RestoreBufVars()
    endif
    call s:RestoreWinVars()
 "  else " Decho
-"   call Decho("(Explore) case a:dosplit=".a:dosplit." AND modified=".&modified." AND a:style=".a:style." is not 6")
+"   call Decho("case a:dosplit=".a:dosplit." AND modified=".&modified." AND a:style=".a:style." is not 6")
   endif
   keepj norm! 0
 
   if a:0 > 0
-"   call Decho("(Explore) case [a:0=".a:0."] > 0: a:1<".a:1.">")
+"   call Decho("case [a:0=".a:0."] > 0: a:1<".a:1.">")
    if a:1 =~ '^\~' && (has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin))
-"    call Decho("(Explore) ..case a:1<".a:1.">: starts with ~ and unix or cygwin")
+"    call Decho("..case a:1<".a:1.">: starts with ~ and unix or cygwin")
     let dirname= simplify(substitute(a:1,'\~',expand("$HOME"),''))
-"    call Decho("(Explore) ..using dirname<".dirname.">  (case: ~ && unix||cygwin)")
+"    call Decho("..using dirname<".dirname.">  (case: ~ && unix||cygwin)")
    elseif a:1 == '.'
-"    call Decho("(Explore) ..case a:1<".a:1.">: matches .")
+"    call Decho("..case a:1<".a:1.">: matches .")
     let dirname= simplify(exists("b:netrw_curdir")? b:netrw_curdir : getcwd())
     if dirname !~ '/$'
      let dirname= dirname."/"
     endif
-"    call Decho("(Explore) ..using dirname<".dirname.">  (case: ".(exists("b:netrw_curdir")? "b:netrw_curdir" : "getcwd()").")")
+"    call Decho("..using dirname<".dirname.">  (case: ".(exists("b:netrw_curdir")? "b:netrw_curdir" : "getcwd()").")")
    elseif a:1 =~ '\$'
-"    call Decho("(Explore) ..case a:1<".a:1.">: matches ending $")
+"    call Decho("..case a:1<".a:1.">: matches ending $")
     let dirname= simplify(expand(a:1))
-"    call Decho("(Explore) ..using user-specified dirname<".dirname."> with $env-var")
+"    call Decho("..using user-specified dirname<".dirname."> with $env-var")
    elseif a:1 !~ '^\*\{1,2}/' && a:1 !~ '^\a\{3,}://'
-"    call Decho("(Explore) ..case a:1<".a:1.">: other, not pattern or filepattern")
+"    call Decho("..case a:1<".a:1.">: other, not pattern or filepattern")
     let dirname= simplify(a:1)
-"    call Decho("(Explore) ..using user-specified dirname<".dirname.">")
+"    call Decho("..using user-specified dirname<".dirname.">")
    else
-"    call Decho("(Explore) ..case a:1: pattern or filepattern")
+"    call Decho("..case a:1: pattern or filepattern")
     let dirname= a:1
    endif
   else
    " clear explore
-"   call Decho("(Explore) case a:0=".a:0.": clearing Explore list")
+"   call Decho("case a:0=".a:0.": clearing Explore list")
    call s:NetrwClearExplore()
 "   call Dret("netrw#Explore : cleared list")
    return
   endif
 
-"  call Decho("(Explore) dirname<".dirname.">")
+"  call Decho("dirname<".dirname.">")
   if dirname =~ '\.\./\=$'
    let dirname= simplify(fnamemodify(dirname,':p:h'))
   elseif dirname =~ '\.\.' || dirname == '.'
    let dirname= simplify(fnamemodify(dirname,':p'))
   endif
-"  call Decho("(Explore) dirname<".dirname.">  (after simplify)")
+"  call Decho("dirname<".dirname.">  (after simplify)")
 
   if dirname =~ '^\*//'
    " starpat=1: Explore *//pattern   (current directory only search for files containing pattern)
-"   call Decho("(Explore) case starpat=1: Explore *//pattern")
+"   call Decho("case starpat=1: Explore *//pattern")
    let pattern= substitute(dirname,'^\*//\(.*\)$','\1','')
    let starpat= 1
-"   call Decho("(Explore) ..Explore *//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">")
+"   call Decho("..Explore *//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">")
    if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
 
   elseif dirname =~ '^\*\*//'
    " starpat=2: Explore **//pattern  (recursive descent search for files containing pattern)
-"   call Decho("(Explore) case starpat=2: Explore **//pattern")
+"   call Decho("case starpat=2: Explore **//pattern")
    let pattern= substitute(dirname,'^\*\*//','','')
    let starpat= 2
-"   call Decho("(Explore) ..Explore **//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">")
+"   call Decho("..Explore **//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">")
 
   elseif dirname =~ '/\*\*/'
    " handle .../**/.../filepat
-"   call Decho("(Explore) case starpat=4: Explore .../**/.../filepat")
+"   call Decho("case starpat=4: Explore .../**/.../filepat")
    let prefixdir= substitute(dirname,'^\(.\{-}\)\*\*.*$','\1','')
    if prefixdir =~ '^/' || (prefixdir =~ '^\a:/' && (has("win32") || has("win95") || has("win64") || has("win16")))
     let b:netrw_curdir = prefixdir
@@ -882,30 +724,30 @@
    endif
    let dirname= substitute(dirname,'^.\{-}\(\*\*/.*\)$','\1','')
    let starpat= 4
-"   call Decho("(Explore) ..pwd<".getcwd()."> dirname<".dirname.">")
-"   call Decho("(Explore) ..case Explore ../**/../filepat (starpat=".starpat.")")
+"   call Decho("..pwd<".getcwd()."> dirname<".dirname.">")
+"   call Decho("..case Explore ../**/../filepat (starpat=".starpat.")")
 
   elseif dirname =~ '^\*/'
    " case starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
    let starpat= 3
-"   call Decho("(Explore) case starpat=3: Explore */filepat (starpat=".starpat.")")
+"   call Decho("case starpat=3: Explore */filepat (starpat=".starpat.")")
 
   elseif dirname=~ '^\*\*/'
    " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
    let starpat= 4
-"   call Decho("(Explore) case starpat=4: Explore **/filepat (starpat=".starpat.")")
+"   call Decho("case starpat=4: Explore **/filepat (starpat=".starpat.")")
 
   else
    let starpat= 0
-"   call Decho("(Explore) case starpat=0: default")
+"   call Decho("case starpat=0: default")
   endif
 
   if starpat == 0 && a:indx >= 0
    " [Explore Hexplore Vexplore Sexplore] [dirname]
-"   call Decho("(Explore) case starpat==0 && a:indx=".a:indx.": dirname<".dirname.">, handles Explore Hexplore Vexplore Sexplore")
+"   call Decho("case starpat==0 && a:indx=".a:indx.": dirname<".dirname.">, handles Explore Hexplore Vexplore Sexplore")
    if dirname == ""
     let dirname= curfiledir
-"    call Decho("(Explore) ..empty dirname, using current file's directory<".dirname.">")
+"    call Decho("..empty dirname, using current file's directory<".dirname.">")
    endif
    if dirname =~ '^scp://' || dirname =~ '^ftp://'
     call netrw#Nread(2,dirname)
@@ -914,15 +756,17 @@
     if dirname == ""
      let dirname= getcwd()
     elseif (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
-     if dirname !~ '^[a-zA-Z]:'
+     " Windows : check for a drive specifier, or else for a remote share name ('\\Foo' or '//Foo', 
+     " depending on whether backslashes have been converted to forward slashes by earlier code).
+     if dirname !~ '^[a-zA-Z]:' && dirname !~ '^\\\\\w\+' && dirname !~ '^//\w\+'
       let dirname= b:netrw_curdir."/".dirname
      endif
     elseif dirname !~ '^/'
      let dirname= b:netrw_curdir."/".dirname
     endif
-"    call Decho("(Explore) ..calling LocalBrowseCheck(dirname<".dirname.">)")
+"    call Decho("..calling LocalBrowseCheck(dirname<".dirname.">)")
     call netrw#LocalBrowseCheck(dirname)
-"    call Decho("(Explore) win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
+"    call Decho("win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
    endif
    if exists("w:netrw_bannercnt")
     " done to handle P08-Ingelrest. :Explore will _Always_ go to the line just after the banner.
@@ -930,7 +774,7 @@
     exe w:netrw_bannercnt
    endif
 
-"   call Decho("(Explore) curdir<".curdir.">")
+"   call Decho("curdir<".curdir.">")
    " ---------------------------------------------------------------------
    " Jan 24, 2013: not sure why the following was present.  See P08-Ingelrest
 "   if has("win32") || has("win95") || has("win64") || has("win16")
@@ -946,30 +790,32 @@
   " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
   elseif a:indx <= 0
    " Nexplore, Pexplore, Explore: handle starpat
-"   call Decho("(Explore) case a:indx<=0: Nexplore, Pexplore, <s-down>, <s-up> starpat=".starpat." a:indx=".a:indx)
+"   call Decho("case a:indx<=0: Nexplore, Pexplore, <s-down>, <s-up> starpat=".starpat." a:indx=".a:indx)
    if !mapcheck("<s-up>","n") && !mapcheck("<s-down>","n") && exists("b:netrw_curdir")
-"    call Decho("(Explore) ..set up <s-up> and <s-down> maps")
+"    call Decho("..set up <s-up> and <s-down> maps")
     let s:didstarstar= 1
     nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
     nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
    endif
 
    if has("path_extra")
-"    call Decho("(Explore) ..starpat=".starpat.": has +path_extra")
+"    call Decho("..starpat=".starpat.": has +path_extra")
     if !exists("w:netrw_explore_indx")
      let w:netrw_explore_indx= 0
     endif
 
     let indx = a:indx
-"    call Decho("(Explore) ..starpat=".starpat.": set indx= [a:indx=".indx."]")
+"    call Decho("..starpat=".starpat.": set indx= [a:indx=".indx."]")
 
     if indx == -1
      " Nexplore
-"     call Decho("(Explore) ..case Nexplore with starpat=".starpat.": (indx=".indx.")")
+"     call Decho("..case Nexplore with starpat=".starpat.": (indx=".indx.")")
      if !exists("w:netrw_explore_list") " sanity check
       keepj call netrw#ErrorMsg(s:WARNING,"using Nexplore or <s-down> improperly; see help for netrw-starstar",40)
-      sil! let @* = keepregstar
-      sil! let @+ = keepregstar
+      if has("clipboard")
+       sil! let @* = keepregstar
+       sil! let @+ = keepregstar
+      endif
       sil! let @/ = keepregslash
 "      call Dret("netrw#Explore")
       return
@@ -978,21 +824,23 @@
      if indx < 0                        | let indx= 0                           | endif
      if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
      let curfile= w:netrw_explore_list[indx]
-"     call Decho("(Explore) ....indx=".indx." curfile<".curfile.">")
+"     call Decho("....indx=".indx." curfile<".curfile.">")
      while indx < w:netrw_explore_listlen && curfile == w:netrw_explore_list[indx]
       let indx= indx + 1
-"      call Decho("(Explore) ....indx=".indx." (Nexplore while loop)")
+"      call Decho("....indx=".indx." (Nexplore while loop)")
      endwhile
      if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
-"     call Decho("(Explore) ....Nexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx)
+"     call Decho("....Nexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx)
 
     elseif indx == -2
      " Pexplore
-"     call Decho("(Explore) case Pexplore with starpat=".starpat.": (indx=".indx.")")
+"     call Decho("case Pexplore with starpat=".starpat.": (indx=".indx.")")
      if !exists("w:netrw_explore_list") " sanity check
       keepj call netrw#ErrorMsg(s:WARNING,"using Pexplore or <s-up> improperly; see help for netrw-starstar",41)
-      sil! let @* = keepregstar
-      sil! let @+ = keepregstar
+      if has("clipboard")
+       sil! let @* = keepregstar
+       sil! let @+ = keepregstar
+      endif
       sil! let @/ = keepregslash
 "      call Dret("netrw#Explore")
       return
@@ -1001,30 +849,30 @@
      if indx < 0                        | let indx= 0                           | endif
      if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
      let curfile= w:netrw_explore_list[indx]
-"     call Decho("(Explore) ....indx=".indx." curfile<".curfile.">")
+"     call Decho("....indx=".indx." curfile<".curfile.">")
      while indx >= 0 && curfile == w:netrw_explore_list[indx]
       let indx= indx - 1
-"      call Decho("(Explore) ....indx=".indx." (Pexplore while loop)")
+"      call Decho("....indx=".indx." (Pexplore while loop)")
      endwhile
      if indx < 0                        | let indx= 0                           | endif
-"     call Decho("(Explore) ....Pexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx)
+"     call Decho("....Pexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx)
 
     else
      " Explore -- initialize
      " build list of files to Explore with Nexplore/Pexplore
-"     call Decho("(Explore) ..starpat=".starpat.": case Explore: initialize (indx=".indx.")")
+"     call Decho("..starpat=".starpat.": case Explore: initialize (indx=".indx.")")
      keepj keepalt call s:NetrwClearExplore()
      let w:netrw_explore_indx= 0
      if !exists("b:netrw_curdir")
       let b:netrw_curdir= getcwd()
      endif
-"     call Decho("(Explore) ....starpat=".starpat.": b:netrw_curdir<".b:netrw_curdir.">")
+"     call Decho("....starpat=".starpat.": b:netrw_curdir<".b:netrw_curdir.">")
 
      " switch on starpat to build the w:netrw_explore_list of files
      if starpat == 1
       " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
-"      call Decho("(Explore) ..case starpat=".starpat.": build *//pattern list  (curdir-only srch for files containing pattern)  &hls=".&hls)
-"      call Decho("(Explore) ....pattern<".pattern.">")
+"      call Decho("..case starpat=".starpat.": build *//pattern list  (curdir-only srch for files containing pattern)  &hls=".&hls)
+"      call Decho("....pattern<".pattern.">")
       try
        exe "keepj noautocmd vimgrep /".pattern."/gj ".fnameescape(b:netrw_curdir)."/*"
       catch /^Vim\%((\a\+)\)\=:E480/
@@ -1037,15 +885,17 @@
 
      elseif starpat == 2
       " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
-"      call Decho("(Explore) ..case starpat=".starpat.": build **//pattern list  (recursive descent files containing pattern)")
-"      call Decho("(Explore) ....pattern<".pattern.">")
+"      call Decho("..case starpat=".starpat.": build **//pattern list  (recursive descent files containing pattern)")
+"      call Decho("....pattern<".pattern.">")
       try
        exe "sil keepj noautocmd keepalt vimgrep /".pattern."/gj "."**/*"
       catch /^Vim\%((\a\+)\)\=:E480/
        keepalt call netrw#ErrorMsg(s:WARNING,'no files matched pattern<'.pattern.'>',45)
        if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
-       sil! let @* = keepregstar
-       sil! let @+ = keepregstar
+       if has("clipboard")
+        sil! let @* = keepregstar
+        sil! let @+ = keepregstar
+       endif
        sil! let @/ = keepregslash
 "       call Dret("netrw#Explore : no files matched pattern")
        return
@@ -1057,53 +907,55 @@
 
      elseif starpat == 3
       " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
-"      call Decho("(Explore) ..case starpat=".starpat.": build */filepat list  (curdir-only srch filenames matching filepat)  &hls=".&hls)
+"      call Decho("..case starpat=".starpat.": build */filepat list  (curdir-only srch filenames matching filepat)  &hls=".&hls)
       let filepat= substitute(dirname,'^\*/','','')
       let filepat= substitute(filepat,'^[%#<]','\\&','')
-"      call Decho("(Explore) ....b:netrw_curdir<".b:netrw_curdir.">")
-"      call Decho("(Explore) ....filepat<".filepat.">")
+"      call Decho("....b:netrw_curdir<".b:netrw_curdir.">")
+"      call Decho("....filepat<".filepat.">")
       let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".filepat),'\n'))
       if &hls | let keepregslash= s:ExplorePatHls(filepat) | endif
 
      elseif starpat == 4
       " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
-"      call Decho("(Explore) ..case starpat=".starpat.": build **/filepat list  (recursive descent srch filenames matching filepat)  &hls=".&hls)
+"      call Decho("..case starpat=".starpat.": build **/filepat list  (recursive descent srch filenames matching filepat)  &hls=".&hls)
       let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".dirname),'\n'))
       if &hls | let keepregslash= s:ExplorePatHls(dirname) | endif
      endif " switch on starpat to build w:netrw_explore_list
 
      let w:netrw_explore_listlen = len(w:netrw_explore_list)
-"     call Decho("(Explore) ....w:netrw_explore_list<".string(w:netrw_explore_list).">")
-"     call Decho("(Explore) ....w:netrw_explore_listlen=".w:netrw_explore_listlen)
+"     call Decho("....w:netrw_explore_list<".string(w:netrw_explore_list).">")
+"     call Decho("....w:netrw_explore_listlen=".w:netrw_explore_listlen)
 
      if w:netrw_explore_listlen == 0 || (w:netrw_explore_listlen == 1 && w:netrw_explore_list[0] =~ '\*\*\/')
       keepalt keepj call netrw#ErrorMsg(s:WARNING,"no files matched",42)
-      sil! let @* = keepregstar
-      sil! let @+ = keepregstar
-      sil! let @/ = keepregslash
-"      call Dret("netrw#Explore : no files matched")
+      if has("clipboard")
+       sil! let @* = keepregstar
+       sil! let @+ = keepregstar
+      endif
+      sil! let @/ = keepregslash
+"      call Dret("netrw#Explore : no files matched")
       return
      endif
     endif  " if indx ... endif
 
     " NetrwStatusLine support - for exploring support
     let w:netrw_explore_indx= indx
-"    call Decho("(Explore) ....w:netrw_explore_list<".join(w:netrw_explore_list,',')."> len=".w:netrw_explore_listlen)
+"    call Decho("....w:netrw_explore_list<".join(w:netrw_explore_list,',')."> len=".w:netrw_explore_listlen)
 
     " wrap the indx around, but issue a note
     if indx >= w:netrw_explore_listlen || indx < 0
-"     call Decho("(Explore) ....wrap indx (indx=".indx." listlen=".w:netrw_explore_listlen.")")
+"     call Decho("....wrap indx (indx=".indx." listlen=".w:netrw_explore_listlen.")")
      let indx                = (indx < 0)? ( w:netrw_explore_listlen - 1 ) : 0
      let w:netrw_explore_indx= indx
      keepalt keepj call netrw#ErrorMsg(s:NOTE,"no more files match Explore pattern",43)
     endif
 
     exe "let dirfile= w:netrw_explore_list[".indx."]"
-"    call Decho("(Explore) ....dirfile=w:netrw_explore_list[indx=".indx."]= <".dirfile.">")
+"    call Decho("....dirfile=w:netrw_explore_list[indx=".indx."]= <".dirfile.">")
     let newdir= substitute(dirfile,'/[^/]*$','','e')
-"    call Decho("(Explore) ....newdir<".newdir.">")
+"    call Decho("....newdir<".newdir.">")
 
-"    call Decho("(Explore) ....calling LocalBrowseCheck(newdir<".newdir.">)")
+"    call Decho("....calling LocalBrowseCheck(newdir<".newdir.">)")
     call netrw#LocalBrowseCheck(newdir)
     if !exists("w:netrw_liststyle")
      let w:netrw_liststyle= g:netrw_liststyle
@@ -1117,22 +969,24 @@
     let w:netrw_explore_bufnr   = bufnr("%")
     let w:netrw_explore_line    = line(".")
     keepalt keepj call s:SetupNetrwStatusLine('%f %h%m%r%=%9*%{NetrwStatusLine()}')
-"    call Decho("(Explore) ....explore: mtchcnt=".w:netrw_explore_mtchcnt." bufnr=".w:netrw_explore_bufnr." line#".w:netrw_explore_line)
+"    call Decho("....explore: mtchcnt=".w:netrw_explore_mtchcnt." bufnr=".w:netrw_explore_bufnr." line#".w:netrw_explore_line)
 
    else
-"    call Decho("(Explore) ..your vim does not have +path_extra")
+"    call Decho("..your vim does not have +path_extra")
     if !exists("g:netrw_quiet")
      keepalt keepj call netrw#ErrorMsg(s:WARNING,"your vim needs the +path_extra feature for Exploring with **!",44)
     endif
-    sil! let @* = keepregstar
-    sil! let @+ = keepregstar
+    if has("clipboard")
+     sil! let @* = keepregstar
+     sil! let @+ = keepregstar
+    endif
     sil! let @/ = keepregslash
 "    call Dret("netrw#Explore : missing +path_extra")
     return
    endif
 
   else
-"   call Decho("(Explore) ..default case: Explore newdir<".dirname.">")
+"   call Decho("..default case: Explore newdir<".dirname.">")
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && dirname =~ '/'
     sil! unlet w:netrw_treedict
     sil! unlet w:netrw_treetop
@@ -1146,22 +1000,22 @@
   endif
 
   " visual display of **/ **// */ Exploration files
-"  call Decho("(Explore) w:netrw_explore_indx=".(exists("w:netrw_explore_indx")? w:netrw_explore_indx : "doesn't exist"))
-"  call Decho("(Explore) b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "n/a").">")
+"  call Decho("w:netrw_explore_indx=".(exists("w:netrw_explore_indx")? w:netrw_explore_indx : "doesn't exist"))
+"  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "n/a").">")
   if exists("w:netrw_explore_indx") && exists("b:netrw_curdir")
-"   call Decho("(Explore) s:explore_prvdir<".(exists("s:explore_prvdir")? s:explore_prvdir : "-doesn't exist-"))
+"   call Decho("s:explore_prvdir<".(exists("s:explore_prvdir")? s:explore_prvdir : "-doesn't exist-"))
    if !exists("s:explore_prvdir") || s:explore_prvdir != b:netrw_curdir
-    " only update match list if current directory isn't the same as before
-"    call Decho("(Explore) only update match list if current directory not the same as before")
+    " only update match list when current directory isn't the same as before
+"    call Decho("only update match list when current directory not the same as before")
     let s:explore_prvdir = b:netrw_curdir
     let s:explore_match  = ""
-    let dirlen           = s:Strlen(b:netrw_curdir)
+    let dirlen           = strlen(b:netrw_curdir)
     if b:netrw_curdir !~ '/$'
      let dirlen= dirlen + 1
     endif
     let prvfname= ""
     for fname in w:netrw_explore_list
-"     call Decho("(Explore) fname<".fname.">")
+"     call Decho("fname<".fname.">")
      if fname =~ '^'.b:netrw_curdir
       if s:explore_match == ""
        let s:explore_match= '\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
@@ -1177,7 +1031,7 @@
      endif
      let prvfname= fname
     endfor
-"    call Decho("(Explore) explore_match<".s:explore_match.">")
+"    call Decho("explore_match<".s:explore_match.">")
     exe "2match netrwMarkFile /".s:explore_match."/"
    endif
    echo "<s-up>==Pexplore  <s-down>==Nexplore"
@@ -1186,47 +1040,76 @@
    if exists("s:explore_match")  | unlet s:explore_match  | endif
    if exists("s:explore_prvdir") | unlet s:explore_prvdir | endif
    echo " "
-"   call Decho("(Explore) cleared explore match list")
+"   call Decho("cleared explore match list")
   endif
 
-  sil! let @* = keepregstar
-  sil! let @+ = keepregstar
+  " since Explore may be used to initialize netrw's browser,
+  " there's no danger of a late FocusGained event on initialization.
+  " Consequently, set s:netrw_events to 2.
+  let s:netrw_events= 2
+  if has("clipboard")
+   sil! let @* = keepregstar
+   sil! let @+ = keepregstar
+  endif
   sil! let @/ = keepregslash
 "  call Dret("netrw#Explore : @/<".@/.">")
 endfun
 
 " ---------------------------------------------------------------------
-" netrw#NetrwMakeTgt: make a target out of the directory name provided {{{2
-fun! netrw#NetrwMakeTgt(dname)
-"  call Dfunc("netrw#NetrwMakeTgt(dname<".a:dname.">)")
-   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
-  let svpos               = netrw#NetrwSavePosn()
-  let s:netrwmftgt_islocal= (a:dname !~ '^\a\+://')
-"  call Decho("s:netrwmftgt_islocal=".s:netrwmftgt_islocal)
-  if s:netrwmftgt_islocal
-   let netrwmftgt= simplify(a:dname)
-  else
-   let netrwmftgt= a:dname
+" netrw#Lexplore: toggle Explorer window, keeping it on the left of the current tab {{{2
+fun! netrw#Lexplore(...)
+"  call Dfunc("netrw#Lexplore() a:0=".a:0)
+  if a:0 > 0 && a:1 != ""
+   " if a netrw window is already on the left-side of the tab
+   " and a directory has been specified, explore with that
+   " directory.
+   let lexwinnr= winnr()
+   exe "1wincmd w"
+   if &ft == "netrw"
+    exe "Explore ".fnameescape(a:1)
+    exe lexwinnr."wincmd w"
+   endif
+   exe lexwinnr."wincmd w"
+"   call Dret("netrw#Lexplore")
+   return
   endif
-  if exists("s:netrwmftgt") && netrwmftgt == s:netrwmftgt
-   " re-selected target, so just clear it
-   unlet s:netrwmftgt s:netrwmftgt_islocal
+
+  if exists("t:netrw_lexbufnr")
+   " close down netrw explorer window
+   let lexwinnr = bufwinnr(t:netrw_lexbufnr)
+   if lexwinnr != -1
+    let curwin   = winnr()
+    exe lexwinnr."wincmd w"
+    close
+    exe curwin."wincmd w"
+   endif
+   unlet t:netrw_lexbufnr
+
   else
-   let s:netrwmftgt= netrwmftgt
+   " open netrw explorer window
+   exe "1wincmd w"
+   let keep_altv    = g:netrw_altv
+   let g:netrw_altv = 0
+   if a:0 > 0 && a:1 != ""
+    exe "Vexplore ".fnameescape(a:1)
+   else
+    Vexplore .
+   endif
+   let g:netrw_altv     = keep_altv
+   let t:netrw_lexbufnr = bufnr("%")
   endif
-  if g:netrw_fastbrowse <= 1
-   call s:NetrwRefresh((b:netrw_curdir !~ '\a\+://'),b:netrw_curdir)
+  if exists("g:netrw_chgwin") && g:netrw_chgwin == -1
+   let g:netrw_chgwin= 2
   endif
-  call netrw#NetrwRestorePosn(svpos)
-"  call Dret("netrw#NetrwMakeTgt")
+"  call Dret("netrw#Lexplore")
 endfun
 
 " ---------------------------------------------------------------------
-" netrw#NetrwClean: remove netrw {{{2
+" netrw#Clean: remove netrw {{{2
 " supports :NetrwClean  -- remove netrw from first directory on runtimepath
 "          :NetrwClean! -- remove netrw from all directories on runtimepath
-fun! netrw#NetrwClean(sys)
-"  call Dfunc("netrw#NetrwClean(sys=".a:sys.")")
+fun! netrw#Clean(sys)
+"  call Dfunc("netrw#Clean(sys=".a:sys.")")
 
   if a:sys
    let choice= confirm("Remove personal and system copies of netrw?","&Yes\n&No")
@@ -1264,28 +1147,44 @@
   endif
    echohl None
 
-"  call Dret("netrw#NetrwClean")
+"  call Dret("netrw#Clean")
 endfun
 
 " ---------------------------------------------------------------------
-" netrw#Nread: {{{2
-fun! netrw#Nread(mode,fname)
-"  call Dfunc("netrw#Nread(mode=".a:mode." fname<".a:fname.">)")
-  call netrw#NetrwSavePosn()
-  call netrw#NetRead(a:mode,a:fname)
-  call netrw#NetrwRestorePosn()
-"  call Dret("netrw#Nread")
+" netrw#MakeTgt: make a target out of the directory name provided {{{2
+fun! netrw#MakeTgt(dname)
+"  call Dfunc("netrw#MakeTgt(dname<".a:dname.">)")
+   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
+  let svpos               = netrw#SavePosn()
+  let s:netrwmftgt_islocal= (a:dname !~ '^\a\+://')
+"  call Decho("s:netrwmftgt_islocal=".s:netrwmftgt_islocal)
+  if s:netrwmftgt_islocal
+   let netrwmftgt= simplify(a:dname)
+  else
+   let netrwmftgt= a:dname
+  endif
+  if exists("s:netrwmftgt") && netrwmftgt == s:netrwmftgt
+   " re-selected target, so just clear it
+   unlet s:netrwmftgt s:netrwmftgt_islocal
+  else
+   let s:netrwmftgt= netrwmftgt
+  endif
+  if g:netrw_fastbrowse <= 1
+   call s:NetrwRefresh((b:netrw_curdir !~ '\a\+://'),b:netrw_curdir)
+  endif
+  call netrw#RestorePosn(svpos)
+"  call Dret("netrw#MakeTgt")
 endfun
 
-" ------------------------------------------------------------------------
-" netrw#NetrwObtain: {{{2
-"   netrw#NetrwObtain(islocal,fname[,tgtdirectory])
+" ---------------------------------------------------------------------
+" netrw#Obtain: {{{2
+"   netrw#Obtain(islocal,fname[,tgtdirectory])
 "     islocal=0  obtain from remote source
 "            =1  obtain from local source
 "     fname  :   a filename or a list of filenames
 "     tgtdir :   optional place where files are to go  (not present, uses getcwd())
-fun! netrw#NetrwObtain(islocal,fname,...)
-"  call Dfunc("netrw#NetrwObtain(islocal=".a:islocal." fname<".((type(a:fname) == 1)? a:fname : string(a:fname)).">) a:0=".a:0)
+fun! netrw#Obtain(islocal,fname,...)
+"  call Dfunc("netrw#Obtain(islocal=".a:islocal." fname<".((type(a:fname) == 1)? a:fname : string(a:fname)).">) a:0=".a:0)
   " NetrwStatusLine support - for obtaining support
 
   if type(a:fname) == 1
@@ -1294,7 +1193,7 @@
    let fnamelist= a:fname
   else
    call netrw#ErrorMsg(s:ERROR,"attempting to use NetrwObtain on something not a filename or a list",62)
-"   call Dret("netrw#NetrwObtain")
+"   call Dret("netrw#Obtain")
    return
   endif
 "  call Decho("fnamelist<".string(fnamelist).">")
@@ -1471,8 +1370,29 @@
       keepj call netrw#ErrorMsg(s:ERROR,getline(1),5)
      endif
     endif
+
+   elseif b:netrw_method == 9
+    " obtain file using sftp
+"    call Decho("obtain via sftp (method #9)")
+    if a:fname =~ '/'
+     let localfile= substitute(a:fname,'^.*/','','')
+    else
+     let localfile= a:fname
+    endif
+"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1).shellescape(localfile)." ".shellescape(tgtdir))
+    exe s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1).shellescape(localfile)." ".shellescape(tgtdir)
+
    elseif !exists("b:netrw_method") || b:netrw_method < 0
-"    call Dfunc("netrw#NetrwObtain : unsupported method")
+    " probably a badly formed url; protocol not recognized
+"    call Dret("netrw#Obtain : unsupported method")
+    return
+
+   else
+    " protocol recognized but not supported for Obtain (yet?)
+    if !exists("g:netrw_quiet")
+     keepj call netrw#ErrorMsg(s:ERROR,"current protocol not supported for obtaining file",97)
+    endif
+"    call Dret("netrw#Obtain : current protocol not supported for obtaining file")
     return
    endif
 
@@ -1492,107 +1412,387 @@
    endif
   endif
 
-"  call Dret("netrw#NetrwObtain")
+"  call Dret("netrw#Obtain")
 endfun
 
 " ---------------------------------------------------------------------
-" NetrwStatusLine: {{{2
-fun! NetrwStatusLine()
-
-" vvv NetrwStatusLine() debugging vvv
-"  let g:stlmsg=""
-"  if !exists("w:netrw_explore_bufnr")
-"   let g:stlmsg="!X<explore_bufnr>"
-"  elseif w:netrw_explore_bufnr != bufnr("%")
-"   let g:stlmsg="explore_bufnr!=".bufnr("%")
-"  endif
-"  if !exists("w:netrw_explore_line")
-"   let g:stlmsg=" !X<explore_line>"
-"  elseif w:netrw_explore_line != line(".")
-"   let g:stlmsg=" explore_line!={line(.)<".line(".").">"
-"  endif
-"  if !exists("w:netrw_explore_list")
-"   let g:stlmsg=" !X<explore_list>"
-"  endif
-" ^^^ NetrwStatusLine() debugging ^^^
+" netrw#Nread: save position, call netrw#NetRead(), and restore position {{{2
+fun! netrw#Nread(mode,fname)
+"  call Dfunc("netrw#Nread(mode=".a:mode." fname<".a:fname.">)")
+  call netrw#SavePosn()
+  call netrw#NetRead(a:mode,a:fname)
+  call netrw#RestorePosn()
 
-  if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
-   " restore user's status line
-   let &stl        = s:netrw_users_stl
-   let &laststatus = s:netrw_users_ls
-   if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
-   if exists("w:netrw_explore_line") |unlet w:netrw_explore_line |endif
-   return ""
-  else
-   return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
+  if exists("w:netrw_liststyle") && w:netrw_liststyle != s:TREELIST
+   if exists("w:netrw_bannercnt")
+    " start with cursor just after the banner
+    exe w:netrw_bannercnt
+   endif
   endif
+"  call Dret("netrw#Nread")
 endfun
 
-" ---------------------------------------------------------------------
-"  Netrw Transfer Functions: {{{1
-" ===============================
-
 " ------------------------------------------------------------------------
-" netrw#NetRead: responsible for reading a file over the net {{{2
-"   mode: =0 read remote file and insert before current line
-"         =1 read remote file and insert after current line
-"         =2 replace with remote file
-"         =3 obtain file, but leave in temporary format
-fun! netrw#NetRead(mode,...)
-"  call Dfunc("netrw#NetRead(mode=".a:mode.",...) a:0=".a:0." ".g:loaded_netrw.((a:0 > 0)? " a:1<".a:1.">" : ""))
-
-  " NetRead: save options {{{3
-  call s:NetrwOptionSave("w:")
-  call s:NetrwSafeOptions()
-  call s:RestoreCursorline()
+" s:NetrwOptionRestore: restore options (based on prior s:NetrwOptionSave) {{{2
+fun! s:NetrwOptionRestore(vt)
+"  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
+  if !exists("{a:vt}netrw_optionsave")
+   if exists("s:nbcd_curpos_{bufnr('%')}")
+"    call Decho("restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
+    keepj call netrw#RestorePosn(s:nbcd_curpos_{bufnr('%')})
+"    call Decho("win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
+"    call Decho("unlet s:nbcd_curpos_".bufnr('%'))
+    unlet s:nbcd_curpos_{bufnr('%')}
+   else
+"    call Decho("no previous position")
+   endif
+"   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
+"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
+   return
+  endif
+  unlet {a:vt}netrw_optionsave
 
-  " NetRead: interpret mode into a readcmd {{{3
-  if     a:mode == 0 " read remote file before current line
-   let readcmd = "0r"
-  elseif a:mode == 1 " read file after current line
-   let readcmd = "r"
-  elseif a:mode == 2 " replace with remote file
-   let readcmd = "%r"
-  elseif a:mode == 3 " skip read of file (leave as temporary)
-   let readcmd = "t"
+  if exists("+acd")
+   if exists("{a:vt}netrw_acdkeep")
+"    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
+    let curdir = getcwd()
+    let &l:acd = {a:vt}netrw_acdkeep
+    unlet {a:vt}netrw_acdkeep
+    if &l:acd
+     call s:NetrwLcd(curdir)
+    endif
+   endif
+  endif
+  if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
+  if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
+  if g:netrw_liststyle != s:TREELIST
+   if exists("{a:vt}netrw_bhkeep")  |let &l:bh     = {a:vt}netrw_bhkeep      |unlet {a:vt}netrw_bhkeep   |endif
+  endif
+  if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
+  if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
+  if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
+  if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
+  if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
+  if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
+  if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
+  if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
+  if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
+  if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
+  if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
+  if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
+  if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
+  if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
+  if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
+  if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
+  if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
+  if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
+  if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
+  if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
+  if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
+  if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
+  if exists("{a:vt}netrw_rnukeep")  |let &l:rnu    = {a:vt}netrw_rnukeep     |unlet {a:vt}netrw_rnukeep  |endif
+  if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
+  if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
+  if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
+  if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
+  if has("clipboard")
+   if exists("{a:vt}netrw_starkeep") |let @*        = {a:vt}netrw_starkeep    |unlet {a:vt}netrw_starkeep |endif
+  endif
+  " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
+"  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
+  if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
+  if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
+  if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
+  if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
+  if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
+  if exists("{a:vt}netrw_swfkeep")
+   if &directory == ""
+    " user hasn't specified a swapfile directory;
+    " netrw will temporarily set the swapfile directory
+    " to the current directory as returned by getcwd().
+    let &l:directory= getcwd()
+    sil! let &l:swf = {a:vt}netrw_swfkeep
+    setl directory=
+    unlet {a:vt}netrw_swfkeep
+   elseif &l:swf != {a:vt}netrw_swfkeep
+    " following line causes a Press ENTER in windows -- can't seem to work around it!!!
+    sil! let &l:swf= {a:vt}netrw_swfkeep
+    unlet {a:vt}netrw_swfkeep
+   endif
+  endif
+  if exists("{a:vt}netrw_dirkeep") && isdirectory({a:vt}netrw_dirkeep) && g:netrw_keepdir
+   let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
+   if exists("{a:vt}netrw_dirkeep")
+    call s:NetrwLcd(dirkeep)
+    unlet {a:vt}netrw_dirkeep
+   endif
+  endif
+  if has("clipboard")
+   if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
+  endif
+  if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
+  if exists("s:nbcd_curpos_{bufnr('%')}")
+"   call Decho("restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
+   keepj call netrw#RestorePosn(s:nbcd_curpos_{bufnr('%')})
+"   call Decho("unlet s:nbcd_curpos_".bufnr('%'))
+   if exists("s:nbcd_curpos_".bufnr('%'))
+    unlet s:nbcd_curpos_{bufnr('%')}
+   endif
   else
-   exe a:mode
-   let readcmd = "r"
+"   call Decho("no previous position")
   endif
-  let ichoice = (a:0 == 0)? 0 : 1
-"  call Decho("readcmd<".readcmd."> ichoice=".ichoice)
 
-  " NetRead: get temporary filename {{{3
-  let tmpfile= s:GetTempfile("")
-  if tmpfile == ""
-"   call Dret("netrw#NetRead : unable to get a tempfile!")
-   return
+"  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
+"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"))
+"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"))
+"  call Decho("ts=".&l:ts)
+  " Moved the filetype detect here from NetrwGetFile() because remote files
+  " were having their filetype detect-generated settings overwritten by
+  " NetrwOptionRestore.
+  if &ft != "netrw"
+"   call Decho("filetype detect  (ft=".&ft.")")
+   filetype detect
   endif
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
+"  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
+endfun
 
-  while ichoice <= a:0
-
-   " attempt to repeat with previous host-file-etc
-   if exists("b:netrw_lastfile") && a:0 == 0
-"    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">")
-    let choice = b:netrw_lastfile
-    let ichoice= ichoice + 1
+" ---------------------------------------------------------------------
+" s:NetrwOptionSave: save options prior to setting to "netrw-buffer-standard" form {{{2
+"             Options get restored by s:NetrwOptionRestore()
+"  06/08/07 : removed call to NetrwSafeOptions(), either placed
+"             immediately after NetrwOptionSave() calls in NetRead
+"             and NetWrite, or after the s:NetrwEnew() call in
+"             NetrwBrowse.
+"             vt: normally its "w:" or "s:" (a variable type)
+fun! s:NetrwOptionSave(vt)
+"  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
+"  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"))
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
 
-   else
-    exe "let choice= a:" . ichoice
-"    call Decho("no lastfile: choice<" . choice . ">")
+  if !exists("{a:vt}netrw_optionsave")
+   let {a:vt}netrw_optionsave= 1
+  else
+"   call Dret("s:NetrwOptionSave : options already saved")
+   return
+  endif
+"  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff)
 
-    if match(choice,"?") == 0
-     " give help
-     echomsg 'NetRead Usage:'
-     echomsg ':Nread machine:path                         uses rcp'
-     echomsg ':Nread "machine path"                       uses ftp   with <.netrc>'
-     echomsg ':Nread "machine id password path"           uses ftp'
-     echomsg ':Nread dav://machine[:port]/path            uses cadaver'
-     echomsg ':Nread fetch://machine/path                 uses fetch'
-     echomsg ':Nread ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
-     echomsg ':Nread http://[user@]machine/path           uses http  wget'
-     echomsg ':Nread rcp://[user@]machine/path            uses rcp'
-     echomsg ':Nread rsync://machine[:port]/path          uses rsync'
+  " Save current settings and current directory
+"  call Decho("saving current settings and current directory")
+  let s:yykeep          = @@
+  if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
+  let {a:vt}netrw_aikeep    = &l:ai
+  let {a:vt}netrw_awkeep    = &l:aw
+  let {a:vt}netrw_bhkeep    = &l:bh
+  let {a:vt}netrw_blkeep    = &l:bl
+  let {a:vt}netrw_btkeep    = &l:bt
+  let {a:vt}netrw_bombkeep  = &l:bomb
+  let {a:vt}netrw_cedit     = &cedit
+  let {a:vt}netrw_cikeep    = &l:ci
+  let {a:vt}netrw_cinkeep   = &l:cin
+  let {a:vt}netrw_cinokeep  = &l:cino
+  let {a:vt}netrw_comkeep   = &l:com
+  let {a:vt}netrw_cpokeep   = &l:cpo
+  let {a:vt}netrw_diffkeep  = &l:diff
+  let {a:vt}netrw_fenkeep   = &l:fen
+  if !exists("g:netrw_ffkeep") || g:netrw_ffkeep == 1
+   let {a:vt}netrw_ffkeep    = &l:ff
+  endif
+  let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
+  let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
+  let {a:vt}netrw_hidkeep   = &l:hidden
+  let {a:vt}netrw_imkeep    = &l:im
+  let {a:vt}netrw_iskkeep   = &l:isk
+  let {a:vt}netrw_lskeep    = &l:ls
+  let {a:vt}netrw_makeep    = &l:ma
+  let {a:vt}netrw_magickeep = &l:magic
+  let {a:vt}netrw_modkeep   = &l:mod
+  let {a:vt}netrw_nukeep    = &l:nu
+  let {a:vt}netrw_rnukeep   = &l:rnu
+  let {a:vt}netrw_repkeep   = &l:report
+  let {a:vt}netrw_rokeep    = &l:ro
+  let {a:vt}netrw_selkeep   = &l:sel
+  let {a:vt}netrw_spellkeep = &l:spell
+  if g:netrw_use_noswf
+   let {a:vt}netrw_swfkeep   = &l:swf
+  endif
+  if has("clipboard")
+   let {a:vt}netrw_starkeep  = @*
+  endif
+  let {a:vt}netrw_tskeep    = &l:ts
+  let {a:vt}netrw_twkeep    = &l:tw           " textwidth
+  let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
+  let {a:vt}netrw_wrapkeep  = &l:wrap
+  let {a:vt}netrw_writekeep = &l:write
+
+  " save a few selected netrw-related variables
+"  call Decho("saving a few selected netrw-related variables")
+  if g:netrw_keepdir
+   let {a:vt}netrw_dirkeep  = getcwd()
+  endif
+  if has("clipboard")
+   if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
+  endif
+  sil! let {a:vt}netrw_regslash= @/
+
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt)
+"  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr())
+endfun
+
+" ------------------------------------------------------------------------
+" s:NetrwSafeOptions: sets options to help netrw do its job {{{2
+"                     Use  s:NetrwSaveOptions() to save user settings
+"                     Use  s:NetrwOptionRestore() to restore user settings
+fun! s:NetrwSafeOptions()
+"  call Dfunc("s:NetrwSafeOptions() win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
+"  call Decho("win#".winnr()."'s ft=".&ft)
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
+  if exists("+acd") | setl noacd | endif
+  setl noai
+  setl noaw
+  setl nobl
+  setl nobomb
+  setl bt=nofile
+  setl noci
+  setl nocin
+  if g:netrw_liststyle == s:TREELIST
+   setl bh=hide
+  endif
+  setl cino=
+  setl com=
+  setl cpo-=a
+  setl cpo-=A
+  setl fo=nroql2
+  setl nohid
+  setl noim
+  setl isk+=@ isk+=* isk+=/
+  setl magic
+  if g:netrw_use_noswf
+   setl noswf
+  endif
+  setl report=10000
+  setl sel=inclusive
+  setl nospell
+  setl tw=0
+  setl wig=
+  setl cedit&
+  call s:NetrwCursor()
+
+  " allow the user to override safe options
+"  call Decho("ft<".&ft."> ei=".&ei)
+  if &ft == "netrw"
+"   call Decho("do any netrw FileType autocmds (doau FileType netrw)")
+   sil! keepalt keepj doau FileType netrw
+  endif
+
+"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh)
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
+"  call Dret("s:NetrwSafeOptions")
+endfun
+
+" ---------------------------------------------------------------------
+" NetrwStatusLine: {{{2
+fun! NetrwStatusLine()
+
+" vvv NetrwStatusLine() debugging vvv
+"  let g:stlmsg=""
+"  if !exists("w:netrw_explore_bufnr")
+"   let g:stlmsg="!X<explore_bufnr>"
+"  elseif w:netrw_explore_bufnr != bufnr("%")
+"   let g:stlmsg="explore_bufnr!=".bufnr("%")
+"  endif
+"  if !exists("w:netrw_explore_line")
+"   let g:stlmsg=" !X<explore_line>"
+"  elseif w:netrw_explore_line != line(".")
+"   let g:stlmsg=" explore_line!={line(.)<".line(".").">"
+"  endif
+"  if !exists("w:netrw_explore_list")
+"   let g:stlmsg=" !X<explore_list>"
+"  endif
+" ^^^ NetrwStatusLine() debugging ^^^
+
+  if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
+   " restore user's status line
+   let &stl        = s:netrw_users_stl
+   let &laststatus = s:netrw_users_ls
+   if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
+   if exists("w:netrw_explore_line") |unlet w:netrw_explore_line |endif
+   return ""
+  else
+   return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
+  endif
+endfun
+
+" ---------------------------------------------------------------------
+"  Netrw Transfer Functions: {{{1
+" ===============================
+
+" ------------------------------------------------------------------------
+" netrw#NetRead: responsible for reading a file over the net {{{2
+"   mode: =0 read remote file and insert before current line
+"         =1 read remote file and insert after current line
+"         =2 replace with remote file
+"         =3 obtain file, but leave in temporary format
+fun! netrw#NetRead(mode,...)
+"  call Dfunc("netrw#NetRead(mode=".a:mode.",...) a:0=".a:0." ".g:loaded_netrw.((a:0 > 0)? " a:1<".a:1.">" : ""))
+
+  " NetRead: save options {{{3
+  call s:NetrwOptionSave("w:")
+  call s:NetrwSafeOptions()
+  call s:RestoreCursorline()
+
+  " NetRead: interpret mode into a readcmd {{{3
+  if     a:mode == 0 " read remote file before current line
+   let readcmd = "0r"
+  elseif a:mode == 1 " read file after current line
+   let readcmd = "r"
+  elseif a:mode == 2 " replace with remote file
+   let readcmd = "%r"
+  elseif a:mode == 3 " skip read of file (leave as temporary)
+   let readcmd = "t"
+  else
+   exe a:mode
+   let readcmd = "r"
+  endif
+  let ichoice = (a:0 == 0)? 0 : 1
+"  call Decho("readcmd<".readcmd."> ichoice=".ichoice)
+
+  " NetRead: get temporary filename {{{3
+  let tmpfile= s:GetTempfile("")
+  if tmpfile == ""
+"   call Dret("netrw#NetRead : unable to get a tempfile!")
+   return
+  endif
+
+  while ichoice <= a:0
+
+   " attempt to repeat with previous host-file-etc
+   if exists("b:netrw_lastfile") && a:0 == 0
+"    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">")
+    let choice = b:netrw_lastfile
+    let ichoice= ichoice + 1
+
+   else
+    exe "let choice= a:" . ichoice
+"    call Decho("no lastfile: choice<" . choice . ">")
+
+    if match(choice,"?") == 0
+     " give help
+     echomsg 'NetRead Usage:'
+     echomsg ':Nread machine:path                         uses rcp'
+     echomsg ':Nread "machine path"                       uses ftp   with <.netrc>'
+     echomsg ':Nread "machine id password path"           uses ftp'
+     echomsg ':Nread dav://machine[:port]/path            uses cadaver'
+     echomsg ':Nread fetch://machine/path                 uses fetch'
+     echomsg ':Nread ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
+     echomsg ':Nread http://[user@]machine/path           uses http  wget'
+     echomsg ':Nread https://[user@]machine/path          uses http  wget'
+     echomsg ':Nread rcp://[user@]machine/path            uses rcp'
+     echomsg ':Nread rsync://machine[:port]/path          uses rsync'
      echomsg ':Nread scp://[user@]machine[[:#]port]/path  uses scp'
      echomsg ':Nread sftp://[user@]machine[[:#]port]/path uses sftp'
      sleep 4
@@ -1637,7 +1837,7 @@
    endif
    let tmpfile= s:GetTempfile(b:netrw_fname) " apply correct suffix
 
-   " Check if NetrwBrowse() should be handling this request
+   " Check whether or not NetrwBrowse() should be handling this request
 "   call Decho("checking if NetrwBrowse() should handle choice<".choice."> with netrw_list_cmd<".g:netrw_list_cmd.">")
    if choice =~ "^.*[\/]$" && b:netrw_method != 5 && choice !~ '^https\=://'
 "    call Decho("yes, choice matches '^.*[\/]$'")
@@ -1659,7 +1859,7 @@
 "    call Decho("read via rcp (method #1)")
    " ER: nothing done with g:netrw_uid yet?
    " ER: on Win2K" rcp machine[.user]:file tmpfile
-   " ER: if machine contains '.' adding .user is required (use $USERNAME)
+   " ER: when machine contains '.' adding .user is required (use $USERNAME)
    " ER: the tmpfile is full path: rcp sees C:\... as host C
    if s:netrw_has_nt_rcp == 1
     if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
@@ -1810,11 +2010,11 @@
      " using g:netrw_http_cmd (usually elinks, links, curl, wget, or fetch)
 "     call Decho('using '.g:netrw_http_cmd.' (# not in b:netrw_fname<'.b:netrw_fname.">)")
      if exists("g:netrw_http_xcmd")
-"      call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape("http://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".shellescape(tmpfile,1))
-      exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape("http://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".shellescape(tmpfile,1)
+"      call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".shellescape(tmpfile,1))
+      exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".shellescape(tmpfile,1)
      else
-"      call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape("http://".g:netrw_machine.b:netrw_fname,1))
-      exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape("http://".g:netrw_machine.b:netrw_fname,1)
+"      call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1))
+      exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)
      endif
      let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
 
@@ -1825,15 +2025,15 @@
      let netrw_tag = substitute(b:netrw_fname,"^.*#","","")
 "     call Decho("netrw_html<".netrw_html.">")
 "     call Decho("netrw_tag <".netrw_tag.">")
-"     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape("http://".g:netrw_machine.netrw_html,1))
-     exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape("http://".g:netrw_machine.netrw_html,1)
+"     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape(b:netrw_http."://".g:netrw_machine.netrw_html,1))
+     exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape(b:netrw_http."://".g:netrw_machine.netrw_html,1)
      let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
 "     call Decho('<\s*a\s*name=\s*"'.netrw_tag.'"/')
      exe 'keepj norm! 1G/<\s*a\s*name=\s*"'.netrw_tag.'"/'."\<CR>"
     endif
     let b:netrw_lastfile = choice
-"    call Decho("(NetRead) setl ro")
-    setl ro
+"    call Decho("setl ro")
+    setl ro nomod
 
    ".........................................
    " NetRead: (dav) NetRead Method #6 {{{3
@@ -1894,7 +2094,7 @@
 "     call Dret("NetRead")
      return
     endif
-    if exists("g:netrw_option") && g:netrw_option == ":https\="
+    if exists("g:netrw_option") && g:netrw_option =~ ":https\="
      let netrw_option= "http"
     else
      let netrw_option= "ftp"
@@ -1911,8 +2111,8 @@
 
     let result		= s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
     let b:netrw_lastfile = choice
-"    call Decho("(NetRead) setl ro")
-    setl ro
+"    call Decho("setl ro")
+    setl ro nomod
 
    ".........................................
    " NetRead: (sftp) NetRead Method #9 {{{3
@@ -1978,7 +2178,7 @@
    exe "sil keepj w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
   elseif g:netrw_cygwin
    " write (selected portion of) file to temporary
-   let cygtmpfile= substitute(tmpfile,'/cygdrive/\(.\)','\1:','')
+   let cygtmpfile= substitute(tmpfile,g:netrw_cygdrive.'/\(.\)','\1:','')
 "   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile))
    exe "sil keepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile)
   else
@@ -1988,7 +2188,7 @@
   endif
 
   if curbufname == ""
-   " if the file is [No Name], and one attempts to Nwrite it, the buffer takes
+   " when the file is [No Name], and one attempts to Nwrite it, the buffer takes
    " on the temporary file's name.  Deletion of the temporary file during
    " cleanup then causes an error message.
    0file!
@@ -2006,7 +2206,7 @@
    else
     exe "let choice= a:" . ichoice
 
-    " Reconstruct Choice if choice starts with '"'
+    " Reconstruct Choice when choice starts with '"'
     if match(choice,"?") == 0
      echomsg 'NetWrite Usage:"'
      echomsg ':Nwrite machine:path                        uses rcp'
@@ -2215,8 +2415,13 @@
    " NetWrite: (http) NetWrite Method #5 {{{3
    elseif     b:netrw_method == 5
 "    call Decho("write via http (method #5)")
-    if !exists("g:netrw_quiet")
-     call netrw#ErrorMsg(s:ERROR,"currently <netrw.vim> does not support writing using http:",16)
+    let curl= substitute(g:netrw_http_put_cmd,'\s\+.*$',"","")
+    if executable(curl)
+     let url= g:netrw_choice
+"     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_put_cmd." ".shellescape(tmpfile,1)." ".shellescape(url,1) )
+     exe s:netrw_silentxfer."!".g:netrw_http_put_cmd." ".shellescape(tmpfile,1)." ".shellescape(url,1) 
+    elseif !exists("g:netrw_quiet")
+     call netrw#ErrorMsg(s:ERROR,"can't write to http using <".g:netrw_http_put_cmd".">".",16)
     endif
 
    ".........................................
@@ -2313,12 +2518,12 @@
   if a:firstline == 1 && a:lastline == line("$")
    " restore modifiability; usually equivalent to set nomod
    let &mod= mod
-"   call Decho("(NetWrite)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
   elseif !exists("leavemod")
    " indicate that the buffer has not been modified since last written
-"   call Decho("(NetWrite) set nomod")
-   set nomod
-"   call Decho("(NetWrite)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"   call Decho("set nomod")
+   setl nomod
+"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
   endif
 
 "  call Dret("netrw#NetWrite")
@@ -2347,11 +2552,11 @@
    let i= 1
    while i <= a:0
     call netrw#NetRead(3,a:{i})
-"    call Decho("(netrw#NetSource) s:netread_tmpfile<".s:netrw_tmpfile.">")
+"    call Decho("s:netread_tmpfile<".s:netrw_tmpfile.">")
     if s:FileReadable(s:netrw_tmpfile)
-"     call Decho("(netrw#NetSource) exe so ".fnameescape(s:netrw_tmpfile))
+"     call Decho("exe so ".fnameescape(s:netrw_tmpfile))
      exe "so ".fnameescape(s:netrw_tmpfile)
-"     call Decho("(netrw#NetSource) delete(".s:netrw_tmpfile.")")
+"     call Decho("delete(".s:netrw_tmpfile.")")
      call delete(s:netrw_tmpfile)
      unlet s:netrw_tmpfile
     else
@@ -2363,6 +2568,49 @@
 "  call Dret("netrw#NetSource")
 endfun
 
+" ---------------------------------------------------------------------
+" netrw#SetTreetop: resets the tree top to the current directory/specified directory {{{2
+"                   (implements the :Ntree command)
+fun! netrw#SetTreetop(...)
+"  call Dfunc("netrw#SetTreetop(".((a:0 > 0)? a:1 : "").") a:0=".a:0)
+
+  " clear out the current tree
+  if exists("w:netrw_treetop")
+"   call Decho("clearing out current tree")
+   let inittreetop= w:netrw_treetop
+   unlet w:netrw_treetop
+  endif
+  if exists("w:netrw_treedict")
+"   call Decho("freeing w:netrw_treedict")
+   unlet w:netrw_treedict
+  endif
+
+  if a:1 == "" && exists("inittreetop")
+   let treedir= s:NetrwTreePath(inittreetop)
+"   call Decho("treedir<".treedir.">")
+  else
+   if isdirectory(a:1)
+"    call Decho("a:1<".a:1."> is a directory")
+    let treedir= a:1
+   elseif exists("b:netrw_curdir") && isdirectory(b:netrw_curdir."/".a:1)
+    let treedir= b:netrw_curdir."/".a:1
+"    call Decho("a:1<".a:1."> is NOT a directory, trying treedir<".treedir.">")
+   else
+    call netrw#ErrorMsg(s:ERROR,"sorry, ".a:1." doesn't seem to be a directory!",95)
+    let treedir= "."
+   endif
+  endif
+"  call Decho("treedir<".treedir.">")
+  let islocal= expand("%") !~ '^\a\+://'
+"  call Decho("islocal=".islocal)
+  if islocal
+   call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(islocal,treedir))
+  else
+   call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,treedir))
+  endif
+"  call Dret("netrw#SetTreetop")
+endfun
+
 " ===========================================
 " s:NetrwGetFile: Function to read temporary file "tfile" with command "readcmd". {{{2
 "    readcmd == %r : replace buffer with newly read file
@@ -2374,7 +2622,7 @@
 
   " readcmd=='t': simply do nothing
   if a:readcmd == 't'
-"   call Decho("(NetrwGetFile)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "   call Dret("NetrwGetFile : skip read of <".a:tfile.">")
    return
   endif
@@ -2394,7 +2642,7 @@
 
    " rename the current buffer to the temp file (ie. tfile)
    if g:netrw_cygwin
-    let tfile= substitute(a:tfile,'/cygdrive/\(.\)','\1:','')
+    let tfile= substitute(a:tfile,g:netrw_cygdrive.'/\(.\)','\1:','')
    else
     let tfile= a:tfile
    endif
@@ -2440,6 +2688,12 @@
    let line1 = 1
    let line2 = line("$")
 
+  elseif !&ma
+   " attempting to read a file after the current line in the file, but the buffer is not modifiable
+   keepj call netrw#ErrorMsg(s:WARNING,"attempt to read<".a:tfile."> into a non-modifiable buffer!",94)
+"   call Dret("NetrwGetFile : attempt to read<".a:tfile."> into a non-modifiable buffer!") 
+   return
+
   elseif s:FileReadable(a:tfile)
    " read file after current line
 "   call Decho("read file<".a:tfile."> after current line")
@@ -2452,7 +2706,7 @@
 
   else
    " not readable
-"   call Decho("(NetrwGetFile)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "   call Decho("tfile<".a:tfile."> not readable")
    keepj call netrw#ErrorMsg(s:WARNING,"file <".a:tfile."> not readable",9)
 "   call Dret("NetrwGetFile : tfile<".a:tfile."> not readable")
@@ -2477,7 +2731,7 @@
  " make sure file is being displayed
 "  redraw!
 
-"  call Decho("(NetrwGetFile)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"  call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "  call Dret("NetrwGetFile")
 endfun
 
@@ -2583,10 +2837,11 @@
 
   " Method#5: http[s]://user@hostname/...path-to-file {{{3
   elseif match(a:choice,httpurm) == 0
-"   call Decho("http://...")
+"   call Decho("http[s]://...")
    let b:netrw_method = 5
    let g:netrw_machine= substitute(a:choice,httpurm,'\1',"")
    let b:netrw_fname  = substitute(a:choice,httpurm,'\2',"")
+   let b:netrw_http   = (a:choice =~ '^https:')? "https" : "http"
 
   " Method#6: dav://hostname[:port]/..path-to-file.. {{{3
   elseif match(a:choice,davurm) == 0
@@ -2820,6 +3075,7 @@
   if a:1 =~ '^ftp:'
    " get host from ftp:... url
    " access userid and password from hup (host-user-passwd) dictionary
+"   call Decho("case a:0=1: a:1<".a:1."> (get host from ftp:... url)")
    let host = substitute(a:1,'^ftp:','','')
    let host = substitute(host,'\..*','','')
    if exists("s:netrw_hup[host]")
@@ -2834,8 +3090,13 @@
 
   else
    " case: one input argument, not an url.  Using it as a new user-id.
+"   call Decho("case a:0=1: a:1<".a:1."> (get host from input argument, not an url)")
    if exists("g:netrw_machine")
-    let host= substitute(g:netrw_machine,'\..*$','','')
+    if g:netrw_machine =~ '[0-9.]\+'
+     let host= g:netrw_machine
+    else
+     let host= substitute(g:netrw_machine,'\..*$','','')
+    endif
    else
     let g:netrw_machine= input('Enter hostname: ')
    endif
@@ -2885,365 +3146,32 @@
 " ===========================================
 
 " ---------------------------------------------------------------------
-" s:NetrwMaps: {{{2
-fun! s:NetrwMaps(islocal)
-"  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
+" s:ExplorePatHls: converts an Explore pattern into a regular expression search pattern {{{2
+fun! s:ExplorePatHls(pattern)
+"  call Dfunc("s:ExplorePatHls(pattern<".a:pattern.">)")
+  let repat= substitute(a:pattern,'^**/\{1,2}','','')
+"  call Decho("repat<".repat.">")
+  let repat= escape(repat,'][.\')
+"  call Decho("repat<".repat.">")
+  let repat= '\<'.substitute(repat,'\*','\\(\\S\\+ \\)*\\S\\+','g').'\>'
+"  call Dret("s:ExplorePatHls repat<".repat.">")
+  return repat
+endfun
 
-  " set up Rexplore and [ 2-leftmouse-click -or- c-leftmouse ]
-"  call Decho("(NetrwMaps) set up Rexplore command")
-  com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"not a former netrw window",79)|endif
-  if g:netrw_mousemaps && g:netrw_retmap
-"   call Decho("(NetrwMaps) set up Rexplore 2-leftmouse")
-   if !hasmapto("<Plug>NetrwReturn")
-    if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
-"     call Decho("(NetrwMaps) making map for 2-leftmouse")
-     nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
-    elseif maparg("<c-leftmouse>","n") == ""
-"     call Decho("(NetrwMaps) making map for c-leftmouse")
-     nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
-    endif
-   endif
-   nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
-"   call Decho("(NetrwMaps) made <Plug>NetrwReturn map")
-  endif
-
-  if a:islocal
-"   call Decho("(NetrwMaps) make local maps")
-   " local normal-mode maps
-   nnoremap <buffer> <silent> a		:call <SID>NetrwHide(1)<cr>
-   nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(1)<cr>
-   nnoremap <buffer> <silent> c		:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> C		:let g:netrw_chgwin= winnr()<cr>
-   nnoremap <buffer> <silent> <cr>	:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
-   nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>
-   nnoremap <buffer> <silent> -		:exe "norm! 0"<bar>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,'../'))<cr>
-   nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
-   nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
-   nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
-   nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
-   nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(1)<cr>
-   nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
-   nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
-   nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
-   nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
-   nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
-   nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
-   nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
-   nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
-   nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
-   nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
-   nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
-   nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
-   nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
-   nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
-   nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
-   nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
-   nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(1)<cr>
-   nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(3)<cr>
-   nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
-   nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(1)<cr>
-   nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
-   nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
-   nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
-   nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(1)<cr>
-   nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(1)<cr>
-   nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(4)<cr>
-   nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
-   nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
-   nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
-   nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
-   nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(5)<cr>
-   nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
-   nnoremap <buffer> <silent> X		:call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
-   " local insert-mode maps
-   inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(1)<cr>
-   inoremap <buffer> <silent> c		<c-o>:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> C		<c-o>:let g:netrw_chgwin= winnr()<cr>
-   inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(1)<cr>
-   inoremap <buffer> <silent> -		<c-o>:exe "norm! 0"<bar>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,'../'))<cr>
-   inoremap <buffer> <silent> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
-   inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>
-   inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
-   inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
-   inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(1)<cr>
-   inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
-   inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
-   inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
-   inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
-   inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
-   inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
-   inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
-   inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
-   inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
-   inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
-   inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
-   inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
-   inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
-   inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
-   inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
-   inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
-   inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(1)<cr>
-   inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(3)<cr>
-   inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
-   inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
-   inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
-   inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
-   inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
-   inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(1)<cr>
-   inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(1)<cr>
-   inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(4)<cr>
-   inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
-   inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
-   inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
-   inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
-   inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(5)<cr>
-   inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
-   if !hasmapto('<Plug>NetrwHideEdit')
-    nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
-    imap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
-   endif
-   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(1)<cr>
-   if !hasmapto('<Plug>NetrwRefresh')
-    nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
-    imap <buffer> <unique> <c-l> <Plug>NetrwRefresh
-   endif
-   nnoremap <buffer> <silent> <Plug>NetrwRefresh		:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
-   if s:didstarstar || !mapcheck("<s-down>","n")
-    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
-    inoremap <buffer> <silent> <s-down>	:Nexplore<cr>
-   endif
-   if s:didstarstar || !mapcheck("<s-up>","n")
-    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
-    inoremap <buffer> <silent> <s-up>	:Pexplore<cr>
-   endif
-   let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
-   if g:netrw_mousemaps == 1
-    nmap <buffer> <leftmouse>   <Plug>NetrwLeftmouse
-    nno  <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
-    nmap <buffer> <s-rightdrag>	<Plug>NetrwRightdrag
-    nno  <buffer> <silent>	<Plug>NetrwRightdrag	<leftmouse>:call <SID>NetrwRightdrag(1)<cr>
-    nmap <buffer> <middlemouse>	<Plug>NetrwMiddlemouse
-    nno  <buffer> <silent>	<Plug>NetrwMiddlemouse	<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
-    nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
-    nno  <buffer> <silent>	<Plug>NetrwSLeftmouse   <leftmouse>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
-    nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
-    nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
-    imap <buffer> <leftmouse>	<Plug>ILeftmouse
-    ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
-    imap <buffer> <middlemouse>	<Plug>IMiddlemouse
-    ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
-    imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
-    ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
-    exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-    exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-    exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-   endif
-   exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-   exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-   exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
-   exe 'nnoremap <buffer> <silent> <Leader>m	:call <SID>NetrwMakeDir("")<cr>'
-   exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-   exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-   exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
-   exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-   exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
-   exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
-   exe 'inoremap <buffer> <silent> <Leader>m	<c-o>:call <SID>NetrwMakeDir("")<cr>'
-   nnoremap <buffer> <F1>		:he netrw-quickhelp<cr>
-
-  else " remote
-"   call Decho("(NetrwMaps) make remote maps")
-   call s:RemotePathAnalysis(b:netrw_curdir)
-   " remote normal-mode maps
-   nnoremap <buffer> <silent> <cr>	:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
-   nnoremap <buffer> <silent> <c-l>	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
-   nnoremap <buffer> <silent> -		:exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'../'))<cr>
-   nnoremap <buffer> <silent> a		:call <SID>NetrwHide(0)<cr>
-   nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
-   nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
-   nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
-   nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
-   nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
-   nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
-   nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
-   nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
-   nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
-   nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
-   nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
-   nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
-   nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
-   nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
-   nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
-   nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
-   nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
-   nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
-   nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
-   nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> C		:let g:netrw_chgwin= winnr()<cr>
-   nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(0)<cr>
-   nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
-   nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(0)<cr>
-   nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(0)<cr>
-   nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
-   nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(0)<cr>
-   nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
-   nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
-   nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
-   nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(0)<cr>
-   nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(0)<cr>
-   nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(1)<cr>
-   nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
-   nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
-   nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
-   nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(2)<cr>
-   nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
-   nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(0)<cr>
-   " remote insert-mode maps
-   inoremap <buffer> <silent> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
-   inoremap <buffer> <silent> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
-   inoremap <buffer> <silent> -		<c-o>:exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'../'))<cr>
-   inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(0)<cr>
-   inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
-   inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
-   inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
-   inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
-   inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
-   inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
-   inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
-   inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
-   inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
-   inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
-   inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
-   inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
-   inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
-   inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
-   inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
-   inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
-   inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
-   inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> C		<c-o>:let g:netrw_chgwin= winnr()<cr>
-   inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
-   inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
-   inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(0)<cr>
-   inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(0)<cr>
-   inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
-   inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
-   inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
-   inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
-   inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
-   inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
-   inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(0)<cr>
-   inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(1)<cr>
-   inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
-   inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
-   inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
-   inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(2)<cr>
-   inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
-   inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
-   if !hasmapto('<Plug>NetrwHideEdit')
-    nmap <buffer> <c-h> <Plug>NetrwHideEdit
-    imap <buffer> <c-h> <Plug>NetrwHideEdit
-   endif
-   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
-   if !hasmapto('<Plug>NetrwRefresh')
-    nmap <buffer> <c-l> <Plug>NetrwRefresh
-    imap <buffer> <c-l> <Plug>NetrwRefresh
-   endif
-
-   let mapsafepath     = escape(s:path, s:netrw_map_escape)
-   let mapsafeusermach = escape(s:user.s:machine, s:netrw_map_escape)
-
-   nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
-   if g:netrw_mousemaps == 1
-    nmap <leftmouse>		<Plug>NetrwLeftmouse
-    nno <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
-    nmap <buffer> <leftdrag>	<Plug>NetrwLeftdrag
-    nno  <buffer> <silent>	<Plug>NetrwLeftdrag	:call <SID>NetrwLeftdrag(0)<cr>
-    nmap <middlemouse>		<Plug>NetrwMiddlemouse
-    nno  <buffer> <silent>	<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
-    nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
-    nno  <buffer> <silent>	<Plug>NetrwSLeftmouse   <leftmouse>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
-    nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
-    nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
-    imap <buffer> <leftmouse>	<Plug>ILeftmouse
-    ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
-    imap <buffer> <middlemouse>	<Plug>IMiddlemouse
-    ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
-    imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
-    ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
-    exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-    exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-    exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   endif
-   exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
-   exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
-   exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
-   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
-   inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>
-  endif
-
-  keepj call s:SetRexDir(a:islocal,b:netrw_curdir)
-
-"  call Dret("s:NetrwMaps")
-endfun
-
-" ---------------------------------------------------------------------
-" s:ExplorePatHls: converts an Explore pattern into a regular expression search pattern {{{2
-fun! s:ExplorePatHls(pattern)
-"  call Dfunc("s:ExplorePatHls(pattern<".a:pattern.">)")
-  let repat= substitute(a:pattern,'^**/\{1,2}','','')
-"  call Decho("repat<".repat.">")
-  let repat= escape(repat,'][.\')
-"  call Decho("repat<".repat.">")
-  let repat= '\<'.substitute(repat,'\*','\\(\\S\\+ \\)*\\S\\+','g').'\>'
-"  call Dret("s:ExplorePatHls repat<".repat.">")
-  return repat
-endfun
-
-" ---------------------------------------------------------------------
-"  s:NetrwBookHistHandler: {{{2
-"    0: (user: <mb>)   bookmark current directory
-"    1: (user: <gb>)   change to the bookmarked directory
-"    2: (user: <qb>)   list bookmarks
-"    3: (browsing)     record current directory history
-"    4: (user: <u>)    go up   (previous) bookmark
-"    5: (user: <U>)    go down (next)     bookmark
-"    6: (user: <mB>)   delete bookmark
-fun! s:NetrwBookHistHandler(chg,curdir)
-"  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhist_cnt." histmax=".g:netrw_dirhistmax)
-  if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
-"   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
-   return
+" ---------------------------------------------------------------------
+"  s:NetrwBookHistHandler: {{{2
+"    0: (user: <mb>)   bookmark current directory
+"    1: (user: <gb>)   change to the bookmarked directory
+"    2: (user: <qb>)   list bookmarks
+"    3: (browsing)     record current directory history
+"    4: (user: <u>)    go up   (previous) bookmark
+"    5: (user: <U>)    go down (next)     bookmark
+"    6: (user: <mB>)   delete bookmark
+fun! s:NetrwBookHistHandler(chg,curdir)
+"  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhist_cnt." histmax=".g:netrw_dirhistmax)
+  if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
+"   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
+   return
   endif
 
   let ykeep= @@
@@ -3338,13 +3266,13 @@
 "    call Decho("changedir u#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
     if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
      setl ma noro
-"     call Decho("(NetrwBookHistHandler) setl ma noro")
+"     call Decho("setl ma noro")
      sil! keepj %d
      setl nomod
-"     call Decho("(NetrwBookHistHandler) setl nomod")
-"     call Decho("(NetrwBookHistHandler)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"     call Decho("setl nomod")
+"     call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
     endif
-"    "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}))
+"    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}))
     exe "keepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
    else
     if g:netrw_dirhistmax > 0
@@ -3363,11 +3291,11 @@
     if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
 "    call Decho("changedir U#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
      if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
-"      call Decho("(NetrwBookHistHandler) setl ma noro")
+"      call Decho("setl ma noro")
       setl ma noro
       sil! keepj %d
 "      call Decho("removed all lines from buffer (%d)")
-"      call Decho("(NetrwBookHistHandler) setl nomod")
+"      call Decho("setl nomod")
       setl nomod
 "      call Decho("(set nomod)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
      endif
@@ -3505,7 +3433,9 @@
 fun! s:NetrwBrowse(islocal,dirname)
   if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
 "  call Dfunc("s:NetrwBrowse(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".w:netrw_liststyle." ".g:loaded_netrw." buf#".bufnr("%")."<".bufname("%")."> win#".winnr())
-"  call Decho("(NetrwBrowse) tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
+"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
+"  call Dredir("ls!")
+
   " s:NetrwBrowse: initialize history {{{3
   if !exists("s:netrw_initbookhist")
    keepj call s:NetrwBookHistRead()
@@ -3520,8 +3450,8 @@
 
   if exists("s:netrw_skipbrowse")
    unlet s:netrw_skipbrowse
-"   call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
-"   call Dret("s:NetrwBrowse : s:netrw_skipbrowse=".s:netrw_skipbrowse)
+"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." filename<".expand("%")."> win#".winnr()." ft<".&ft.">")
+"   call Dret("s:NetrwBrowse : s:netrw_skipbrowse existed")
    return
   endif
 
@@ -3542,27 +3472,27 @@
 
   " s:NetrwBrowse: re-instate any marked files {{{3
   if exists("s:netrwmarkfilelist_{bufnr('%')}")
-"   call Decho("(NetrwBrowse) clearing marked files")
+"   call Decho("clearing marked files")
    exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
   endif
 
   if a:islocal && exists("w:netrw_acdkeep") && w:netrw_acdkeep
    " s:NetrwBrowse: set up "safe" options for local directory/file {{{3
-"   call Decho("(NetrwBrowse) handle w:netrw_acdkeep:")
-"   call Decho("(NetrwBrowse) keepjumps lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")")
-   exe 'keepj lcd '.fnameescape(dirname)
+"   call Decho("handle w:netrw_acdkeep:")
+"   call Decho("keepjumps lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")")
+   call s:NetrwLcd(dirname)
    call s:NetrwSafeOptions()
-"   call Decho("(NetrwBrowse) getcwd<".getcwd().">")
+"   call Decho("getcwd<".getcwd().">")
 
   elseif !a:islocal && dirname !~ '[\/]$' && dirname !~ '^"'
    " s:NetrwBrowse: looks like a remote regular file, attempt transfer {{{3
-"   call Decho("(NetrwBrowse) attempt transfer as regular file<".dirname.">")
+"   call Decho("attempt transfer as regular file<".dirname.">")
 
    " remove any filetype indicator from end of dirname, except for the
    " "this is a directory" indicator (/).
    " There shouldn't be one of those here, anyway.
    let path= substitute(dirname,'[*=@|]\r\=$','','e')
-"   call Decho("(NetrwBrowse) new path<".path.">")
+"   call Decho("new path<".path.">")
    call s:RemotePathAnalysis(dirname)
 
    " s:NetrwBrowse: remote-read the requested file into current buffer {{{3
@@ -3570,24 +3500,33 @@
    call s:NetrwEnew(dirname)
    call s:NetrwSafeOptions()
    setl ma noro
-"   call Decho("(NetrwBrowse) setl ma noro")
+"   call Decho("setl ma noro")
    let b:netrw_curdir = dirname
    let url            = s:method."://".s:user.s:machine.(s:port ? ":".s:port : "")."/".s:path
-"   call Decho("(NetrwBrowse) exe sil! keepalt file ".fnameescape(url)." (bt=".&bt.")")
+"   call Decho("exe sil! keepalt file ".fnameescape(url)." (bt=".&bt.")")
    exe "sil! keepj keepalt file ".fnameescape(url)
    exe "sil! keepj keepalt doau BufReadPre ".fnameescape(s:fname)
    sil call netrw#NetRead(2,url)
-   if s:path !~ '.tar.bz2$' && s:path !~ '.tar.gz' && s:path !~ '.tar.xz' && s:path !~ '.txz'
-    " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
+   " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
+"   call Decho("url<".url.">")
+"   call Decho("s:path<".s:path.">")
+"   call Decho("s:fname<".s:fname.">")
+   if s:path =~ '.bz2'
+    exe "sil keepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.bz2$','',''))
+   elseif s:path =~ '.gz'
+    exe "sil keepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.gz$','',''))
+   elseif s:path =~ '.gz'
+    exe "sil keepj keepalt doau BufReadPost ".fnameescape(substitute(s:fname,'\.txz$','',''))
+   else
     exe "sil keepj keepalt doau BufReadPost ".fnameescape(s:fname)
    endif
 
    " s:NetrwBrowse: save certain window-oriented variables into buffer-oriented variables {{{3
    call s:SetBufWinVars()
    call s:NetrwOptionRestore("w:")
-"   call Decho("(NetrwBrowse) setl ma nomod")
+"   call Decho("setl ma nomod")
    setl ma nomod
-"   call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 
 "   call Dret("s:NetrwBrowse : file<".s:fname.">")
    return
@@ -3608,28 +3547,31 @@
   let reusing= s:NetrwGetBuffer(a:islocal,dirname)
   " maintain markfile highlighting
   if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
-"   call Decho("(NetrwBrowse) bufnr(%)=".bufnr('%'))
-"   call Decho("(NetrwBrowse) exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/")
+"   call Decho("bufnr(%)=".bufnr('%'))
+"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/")
    exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
   else
-"   call Decho("(NetrwBrowse) 2match none")
+"   call Decho("2match none")
    2match none
   endif
   if reusing && line("$") > 1
    call s:NetrwOptionRestore("w:")
-"   call Decho("(NetrwBrowse) setl noma nomod nowrap")
+"   call Decho("setl noma nomod nowrap")
    setl noma nomod nowrap
-"   call Decho("(NetrwBrowse) (set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"   call Decho("(set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "   call Dret("s:NetrwBrowse : re-using buffer")
    return
   endif
 
   " set b:netrw_curdir to the new directory name {{{3
-"  call Decho("(NetrwBrowse) set b:netrw_curdir to the new directory name:  (buf#".bufnr("%").")")
+"  call Decho("set b:netrw_curdir to the new directory name<".dirname."> (buf#".bufnr("%").")")
   let b:netrw_curdir= dirname
   if b:netrw_curdir =~ '[/\\]$'
    let b:netrw_curdir= substitute(b:netrw_curdir,'[/\\]$','','e')
   endif
+  if b:netrw_curdir =~ '\a:$' && (has("win32") || has("win95") || has("win64") || has("win16"))
+   let b:netrw_curdir= b:netrw_curdir."/"
+  endif
   if b:netrw_curdir == ''
    if has("amiga")
     " On the Amiga, the empty string connotes the current directory
@@ -3643,39 +3585,23 @@
   if !a:islocal && b:netrw_curdir !~ '/$'
    let b:netrw_curdir= b:netrw_curdir.'/'
   endif
-"  call Decho("(NetrwBrowse) b:netrw_curdir<".b:netrw_curdir.">")
+"  call Decho("b:netrw_curdir<".b:netrw_curdir.">")
 
   " ------------
   " (local only) {{{3
   " ------------
   if a:islocal
-"   call Decho("(NetrwBrowse) local only:")
+"   call Decho("local only:")
 
    " Set up ShellCmdPost handling.  Append current buffer to browselist
    call s:LocalFastBrowser()
 
   " handle g:netrw_keepdir: set vim's current directory to netrw's notion of the current directory {{{3
    if !g:netrw_keepdir
-"    call Decho("(NetrwBrowse) handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
-"    call Decho("(NetrwBrowse) l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"))
+"    call Decho("handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
+"    call Decho("l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"))
     if !exists("&l:acd") || !&l:acd
-"     call Decho('exe keepjumps lcd '.fnameescape(b:netrw_curdir))
-     try
-      exe 'keepj lcd '.fnameescape(b:netrw_curdir)
-     catch /^Vim\%((\a\+)\)\=:E472/
-      call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".b:netrw_curdir."> (permissions?)",61)
-      if exists("w:netrw_prvdir")
-       let b:netrw_curdir= w:netrw_prvdir
-      else
-       call s:NetrwOptionRestore("w:")
-"       call Decho("(NetrwBrowse) setl noma nomod nowrap")
-       setl noma nomod nowrap
-"       call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
-       let b:netrw_curdir= dirname
-"       call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
-       return
-      endif
-     endtry
+     call s:NetrwLcd(b:netrw_curdir)
     endif
    endif
 
@@ -3683,23 +3609,23 @@
   " remote handling: {{{3
   " --------------------------------
   else
-"   call Decho("(NetrwBrowse) remote only:")
+"   call Decho("remote only:")
 
    " analyze dirname and g:netrw_list_cmd {{{3
-"   call Decho("(NetrwBrowse) b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">")
+"   call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">")
    if dirname =~ "^NetrwTreeListing\>"
     let dirname= b:netrw_curdir
-"    call Decho("(NetrwBrowse) (dirname was <NetrwTreeListing>) dirname<".dirname.">")
+"    call Decho("(dirname was <NetrwTreeListing>) dirname<".dirname.">")
    elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
     let dirname= substitute(b:netrw_curdir,'\\','/','g')
     if dirname !~ '/$'
      let dirname= dirname.'/'
     endif
     let b:netrw_curdir = dirname
-"    call Decho("(NetrwBrowse) (liststyle is TREELIST) dirname<".dirname.">")
+"    call Decho("(liststyle is TREELIST) dirname<".dirname.">")
    else
     let dirname = substitute(dirname,'\\','/','g')
-"    call Decho("(NetrwBrowse) (normal) dirname<".dirname.">")
+"    call Decho("(normal) dirname<".dirname.">")
    endif
 
    let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/]\+\)/\(.*\)$'
@@ -3708,37 +3634,34 @@
      keepj call netrw#ErrorMsg(s:ERROR,"netrw doesn't understand your dirname<".dirname.">",20)
     endif
     keepj call s:NetrwOptionRestore("w:")
-"    call Decho("(NetrwBrowse) setl noma nomod nowrap")
+"    call Decho("setl noma nomod nowrap")
     setl noma nomod nowrap
-"    call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "    call Dret("s:NetrwBrowse : badly formatted dirname<".dirname.">")
     return
    endif
    let b:netrw_curdir= dirname
-"   call Decho("(NetrwBrowse) b:netrw_curdir<".b:netrw_curdir."> (remote)")
+"   call Decho("b:netrw_curdir<".b:netrw_curdir."> (remote)")
   endif  " (additional remote handling)
 
   " -----------------------
   " Directory Listing: {{{3
   " -----------------------
   keepj call s:NetrwMaps(a:islocal)
+  keepj call s:NetrwCommands(a:islocal)
   keepj call s:PerformListing(a:islocal)
   if v:version >= 700 && has("balloon_eval") && &beval == 0 && &l:bexpr == "" && !exists("g:netrw_nobeval")
-   let &l:bexpr= "netrw#NetrwBalloonHelp()"
-"   call Decho("(NetrwBrowse) set up balloon help: l:bexpr=".&l:bexpr)
-   set beval
+   let &l:bexpr= "netrw#BalloonHelp()"
+"   call Decho("set up balloon help: l:bexpr=".&l:bexpr)
+   setl beval
   endif
   call s:NetrwOptionRestore("w:")
 
-  " The s:LocalBrowseShellCmdRefresh() function is called by an autocmd
+  " The s:LocalBrowseRefresh() function is called by an autocmd
   " installed by s:LocalFastBrowser() when g:netrw_fastbrowse <= 1 (ie. slow, medium speed).
-  " However, s:NetrwBrowse() causes the ShellCmdPost event itself to fire once; setting
-  " the variable below avoids that second refresh of the screen.  The s:LocalBrowseShellCmdRefresh()
-  " function gets called due to that autocmd; it notices that the following variable is set
-  " and skips the refresh and sets s:locbrowseshellcmd to zero. Oct 13, 2008
-  let s:locbrowseshellcmd= 1
+  " However, s:NetrwBrowse() causes the FocusGained event to fire the firstt time.
 
-"  call Decho("(NetrwBrowse) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "  call Dret("s:NetrwBrowse : did PerformListing  ft<".&ft.">")
   return
 endfun
@@ -3746,20 +3669,33 @@
 " ---------------------------------------------------------------------
 " s:NetrwFileInfo: supports qf (query for file information) {{{2
 fun! s:NetrwFileInfo(islocal,fname)
-"  call Dfunc("s:NetrwFileInfo(islocal=".a:islocal." fname<".a:fname.">)")
+"  call Dfunc("s:NetrwFileInfo(islocal=".a:islocal." fname<".a:fname.">) b:netrw_curdir<".b:netrw_curdir.">")
   let ykeep= @@
   if a:islocal
    if (has("unix") || has("macunix")) && executable("/bin/ls")
-    if exists("b:netrw_curdir")
-"     call Decho('using ls with b:netrw_curdir<'.b:netrw_curdir.'>')
+
+    if getline(".") == "../"
+     echo system("/bin/ls -lsad ".shellescape(".."))
+"     call Decho("#1: echo system(/bin/ls -lsad ".shellescape(..).")")
+
+    elseif w:netrw_liststyle == s:TREELIST && getline(".") !~ '^'.s:treedepthstring
+     echo system("/bin/ls -lsad ".shellescape(b:netrw_curdir))
+"     call Decho("#2: echo system(/bin/ls -lsad ".shellescape(b:netrw_curdir).")")
+
+    elseif exists("b:netrw_curdir")
      if b:netrw_curdir =~ '/$'
       echo system("/bin/ls -lsad ".shellescape(b:netrw_curdir.a:fname))
+"      call Decho("#3: echo system(/bin/ls -lsad ".shellescape(b:netrw_curdir.a:fname).")")
+
      else
       echo system("/bin/ls -lsad ".shellescape(b:netrw_curdir."/".a:fname))
+"      call Decho("#4: echo system(/bin/ls -lsad ".shellescape(b:netrw_curdir."/".a:fname).")")
      endif
+
     else
 "     call Decho('using ls '.a:fname." using cwd<".getcwd().">")
      echo system("/bin/ls -lsad ".shellescape(a:fname))
+"     call Decho("#5: echo system(/bin/ls -lsad ".shellescape(a:fname).")")
     endif
    else
     " use vim functions to return information about file below cursor
@@ -3772,7 +3708,7 @@
     let t  = getftime(fname)
     let sz = getfsize(fname)
     echo a:fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname))
-"    call Decho(fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname)))
+"    call Decho("fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname)))
    endif
   else
    echo "sorry, \"qf\" not supported yet for remote files"
@@ -3787,40 +3723,42 @@
 "           1=re-used buffer
 fun! s:NetrwGetBuffer(islocal,dirname)
 "  call Dfunc("s:NetrwGetBuffer(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".g:netrw_liststyle)
-"  call Decho("(NetrwGetBuffer) modiable=".&mod." modifiable=".&ma." readonly=".&ro)
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
   let dirname= a:dirname
 
   " re-use buffer if possible {{{3
-"  call Decho("(NetrwGetBuffer) --re-use a buffer if possible--")
+"  call Decho("--re-use a buffer if possible--")
   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
    " find NetrwTreeList buffer if there is one
-"   call Decho("(NetrwGetBuffer) case liststyle=treelist: find NetrwTreeList buffer if there is one")
+"   call Decho("case liststyle=treelist: find NetrwTreeList buffer if there is one")
    if exists("w:netrw_treebufnr") && w:netrw_treebufnr > 0
-"    call Decho("(NetrwGetBuffer)   re-using w:netrw_treebufnr=".w:netrw_treebufnr)
-    setl mod
-    sil! keepj %d
+"    call Decho("  re-using w:netrw_treebufnr=".w:netrw_treebufnr)
     let eikeep= &ei
-    set ei=all
-    exe "sil! keepalt b ".w:netrw_treebufnr
+    setl ei=all
+    exe "sil! noswapfile keepalt b ".w:netrw_treebufnr
     let &ei= eikeep
+    setl ma
+    sil! keepj %d
+"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
 "    call Dret("s:NetrwGetBuffer 0<buffer cleared> : bufnum#".w:netrw_treebufnr."<NetrwTreeListing>")
     return 0
    endif
    let bufnum= -1
-"   call Decho("(NetrwGetBuffer)   liststyle=TREE but w:netrw_treebufnr doesn't exist")
+"   call Decho("  liststyle=TREE but w:netrw_treebufnr doesn't exist")
 
   else
    " find buffer number of buffer named precisely the same as dirname {{{3
-"   call Decho("(NetrwGetBuffer) case listtyle not treelist: find buffer numnber of buffer named precisely the same as dirname--")
+"   call Decho("case listtyle not treelist: find buffer numnber of buffer named precisely the same as dirname--")
+"   call Dredir("(NetrwGetBuffer) ls!","ls!")
 
    " get dirname and associated buffer number
    let bufnum  = bufnr(escape(dirname,'\'))
-"   call Decho("(NetrwGetBuffer)   find buffer<".dirname.">'s number ")
-"   call Decho("(NetrwGetBuffer)   bufnr(dirname<".escape(dirname,'\').">)=".bufnum)
+"   call Decho("  find buffer<".dirname.">'s number ")
+"   call Decho("  bufnr(dirname<".escape(dirname,'\').">)=".bufnum)
 
    if bufnum < 0 && dirname !~ '/$'
     " try appending a trailing /
-"    call Decho("(NetrwGetBuffer)   try appending a trailing / to dirname<".dirname.">")
+"    call Decho("  try appending a trailing / to dirname<".dirname.">")
     let bufnum= bufnr(escape(dirname.'/','\'))
     if bufnum > 0
      let dirname= dirname.'/'
@@ -3829,30 +3767,30 @@
 
    if bufnum < 0 && dirname =~ '/$'
     " try removing a trailing /
-"    call Decho("(NetrwGetBuffer)   try removing a trailing / from dirname<".dirname.">")
+"    call Decho("  try removing a trailing / from dirname<".dirname.">")
     let bufnum= bufnr(escape(substitute(dirname,'/$','',''),'\'))
     if bufnum > 0
      let dirname= substitute(dirname,'/$','','')
     endif
    endif
 
-"   call Decho("(NetrwGetBuffer)   findbuf1: bufnum=bufnr('".dirname."')=".bufnum." bufname(".bufnum.")<".bufname(bufnum)."> (initial)")
+"   call Decho("  findbuf1: bufnum=bufnr('".dirname."')=".bufnum." bufname(".bufnum.")<".bufname(bufnum)."> (initial)")
    " note: !~ was used just below, but that means using ../ to go back would match (ie. abc/def/  and abc/ matches)
    if bufnum > 0 && bufname(bufnum) != dirname && bufname(bufnum) != '.'
     " handle approximate matches
-"    call Decho("(NetrwGetBuffer)   handling approx match: bufnum#".bufnum.">0 AND bufname<".bufname(bufnum).">!=dirname<".dirname."> AND bufname(".bufnum.")!='.'")
+"    call Decho("  handling approx match: bufnum#".bufnum.">0 AND bufname<".bufname(bufnum).">!=dirname<".dirname."> AND bufname(".bufnum.")!='.'")
     let ibuf    = 1
     let buflast = bufnr("$")
-"    call Decho("(NetrwGetBuffer)   findbuf2: buflast=bufnr($)=".buflast)
+"    call Decho("  findbuf2: buflast=bufnr($)=".buflast)
     while ibuf <= buflast
      let bname= substitute(bufname(ibuf),'\\','/','g')
      let bname= substitute(bname,'.\zs/$','','')
-"     call Decho("(NetrwGetBuffer)   findbuf3: while [ibuf=",ibuf."]<=[buflast=".buflast."]: dirname<".dirname."> bname=bufname(".ibuf.")<".bname.">")
+"     call Decho("  findbuf3: while [ibuf=",ibuf."]<=[buflast=".buflast."]: dirname<".dirname."> bname=bufname(".ibuf.")<".bname.">")
      if bname != '' && dirname =~ '/'.bname.'/\=$' && dirname !~ '^/'
       " bname is not empty
       " dirname ends with bname,
       " dirname doesn't start with /, so its not a absolute path
-"      call Decho("(NetrwGetBuffer)   findbuf3a: passes test 1 : dirname<".dirname.'> =~ /'.bname.'/\=$ && dirname !~ ^/')
+"      call Decho("  findbuf3a: passes test 1 : dirname<".dirname.'> =~ /'.bname.'/\=$ && dirname !~ ^/')
       break
      endif
      if bname =~ '^'.dirname.'/\=$'
@@ -3875,79 +3813,83 @@
     else
      let bufnum= ibuf
     endif
-"    call Decho("(NetrwGetBuffer)   findbuf4: bufnum=".bufnum." (ibuf=".ibuf." buflast=".buflast.")")
+"    call Decho("  findbuf4: bufnum=".bufnum." (ibuf=".ibuf." buflast=".buflast.")")
    endif
   endif
 
   " get enew buffer and name it -or- re-use buffer {{{3
-"  call Decho("(NetrwGetBuffer)   get enew buffer and name it OR re-use buffer")
+"  call Decho("  get enew buffer and name it OR re-use buffer")
   sil! keepj keepalt mark '
   if bufnum < 0 || !bufexists(bufnum)
-"   call Decho("(NetrwGetBuffer) --get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)")
+"   call Decho("--get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)")
    call s:NetrwEnew(dirname)
-"   call Decho("(NetrwGetBuffer)   got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)")
+"   call Decho("  got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)")
    " name the buffer
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
     " Got enew buffer; transform into a NetrwTreeListing
-"    call Decho("(NetrwGetBuffer) --transform enew buffer#".bufnr("%")." into a NetrwTreeListing --")
+"    call Decho("--transform enew buffer#".bufnr("%")." into a NetrwTreeListing --")
     if !exists("s:netrw_treelistnum")
      let s:netrw_treelistnum= 1
     else
      let s:netrw_treelistnum= s:netrw_treelistnum + 1
     endif
     let w:netrw_treebufnr= bufnr("%")
-"    call Decho("(NetrwGetBuffer)   exe sil! keepalt file NetrwTreeListing ".fnameescape(s:netrw_treelistnum))
+"    call Decho("  exe sil! keepalt file NetrwTreeListing ".fnameescape(s:netrw_treelistnum))
     exe 'sil! keepalt file NetrwTreeListing\ '.fnameescape(s:netrw_treelistnum)
-    set bt=nofile noswf
+    setl bt=nofile noswf
     nnoremap <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
     nnoremap <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
     nnoremap <silent> <buffer> [[       :sil call <SID>TreeListMove('[')<cr>
     nnoremap <silent> <buffer> ]]       :sil call <SID>TreeListMove(']')<cr>
-"    call Decho("(NetrwGetBuffer)   tree listing#".s:netrw_treelistnum." bufnr=".w:netrw_treebufnr)
+"    call Decho("  tree listing#".s:netrw_treelistnum." bufnr=".w:netrw_treebufnr)
    else
 "    let v:errmsg= "" " Decho
     let escdirname= fnameescape(dirname)
-"    call Decho("(NetrwGetBuffer)   errmsg<".v:errmsg."> bufnr(escdirname<".escdirname.">)=".bufnr(escdirname)." bufname()<".bufname(bufnr(escdirname)).">")
+"    call Decho("  errmsg<".v:errmsg."> bufnr(escdirname<".escdirname.">)=".bufnr(escdirname)." bufname()<".bufname(bufnr(escdirname)).">")
 "    call Decho('  exe sil! keepalt file '.escdirname)
 "    let v:errmsg= "" " Decho
     exe 'sil! keepalt file '.escdirname
-"    call Decho("(NetrwGetBuffer)   errmsg<".v:errmsg."> bufnr(".escdirname.")=".bufnr(escdirname)."<".bufname(bufnr(escdirname)).">")
+"    call Decho("  errmsg<".v:errmsg."> bufnr(".escdirname.")=".bufnr(escdirname)."<".bufname(bufnr(escdirname)).">")
    endif
-"   call Decho("(NetrwGetBuffer)   named enew buffer#".bufnr("%")."<".bufname("%").">")
+"   call Decho("  named enew buffer#".bufnr("%")."<".bufname("%").">")
 
   else " Re-use the buffer
-"   call Decho("(NetrwGetBuffer) --re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)")
+"   call Decho("--re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)")
    let eikeep= &ei
-   set ei=all
+   setl ei=all
    if getline(2) =~ '^" Netrw Directory Listing'
-"    call Decho("(NetrwGetBuffer)   getline(2)<".getline(2).'> matches "Netrw Directory Listing" : using keepalt b '.bufnum)
-    exe "sil! keepalt b ".bufnum
+"    call Decho("  getline(2)<".getline(2).'> matches "Netrw Directory Listing" : using keepalt b '.bufnum)
+    exe "sil! noswapfile keepalt b ".bufnum
    else
-"    call Decho("(NetrwGetBuffer)   getline(2)<".getline(2).'> does not match "Netrw Directory Listing" : using b '.bufnum)
-    exe "sil! keepalt b ".bufnum
+"    call Decho("  getline(2)<".getline(2).'> does not match "Netrw Directory Listing" : using b '.bufnum)
+    exe "sil! noswapfile keepalt b ".bufnum
    endif
    if bufname("%") == '.'
-"    call Decho("(NetrwGetBuffer) exe sil! keepalt file ".fnameescape(getcwd()))
+"    call Decho("exe sil! keepalt file ".fnameescape(getcwd()))
     exe "sil! keepalt file ".fnameescape(getcwd())
    endif
    let &ei= eikeep
    if line("$") <= 1
     keepj call s:NetrwListSettings(a:islocal)
+"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
 "    call Dret("s:NetrwGetBuffer 0<buffer empty> : re-using buffer#".bufnr("%").", but its empty, so refresh it")
     return 0
    elseif g:netrw_fastbrowse == 0 || (a:islocal && g:netrw_fastbrowse == 1)
     keepj call s:NetrwListSettings(a:islocal)
     sil keepj %d
+"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
 "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but refreshing due to g:netrw_fastbrowse=".g:netrw_fastbrowse)
     return 0
    elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
-"    call Decho("(NetrwGetBuffer) --re-use tree listing--")
-"    call Decho("(NetrwGetBuffer)   clear buffer<".expand("%")."> with :%d")
+"    call Decho("--re-use tree listing--")
+"    call Decho("  clear buffer<".expand("%")."> with :%d")
     sil keepj %d
     keepj call s:NetrwListSettings(a:islocal)
+"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
 "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but treelist mode always needs a refresh")
     return 0
    else
+"    call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
 "    call Dret("s:NetrwGetBuffer 1<buffer not cleared> : buf#".bufnr("%"))
     return 1
    endif
@@ -3958,18 +3900,19 @@
   "  slow   0         D      D      Deleting a buffer implies it will not be re-used (slow)
   "  med    1         D      H
   "  fast   2         H      H
-"  call Decho("(NetrwGetBuffer) --do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--")
+"  call Decho("--do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--")
   let fname= expand("%")
   keepj call s:NetrwListSettings(a:islocal)
-"  call Decho("(NetrwGetBuffer) exe sil! keepalt file ".fnameescape(fname))
+"  call Decho("exe sil! keepalt file ".fnameescape(fname))
   exe "sil! keepj keepalt file ".fnameescape(fname)
 
   " delete all lines from buffer {{{3
-"  call Decho("(NetrwGetBuffer) --delete all lines from buffer--")
-"  call Decho("(NetrwGetBuffer)   clear buffer<".expand("%")."> with :%d")
+"  call Decho("--delete all lines from buffer--")
+"  call Decho("  clear buffer<".expand("%")."> with :%d")
   sil! keepalt keepj %d
 
-"  call Dret("s:NetrwGetBuffer 0<cleared buffer> : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
+"  call Dret("s:NetrwGetBuffer 0<cleared buffer> : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%"))
   return 0
 endfun
 
@@ -4048,7 +3991,7 @@
 
   elseif w:netrw_liststyle == s:TREELIST
 "   call Decho("treelist handling")
-   let dirname= substitute(getline('.'),'^\(| \)*','','e')
+   let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
 
   else
 "   call Decho("obtain word from wide listing")
@@ -4100,14 +4043,16 @@
 " s:NetrwListSettings: make standard settings for a netrw listing {{{2
 fun! s:NetrwListSettings(islocal)
 "  call Dfunc("s:NetrwListSettings(islocal=".a:islocal.")")
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
   let fname= bufname("%")
-"  call Decho("(NetrwListSettings) setl bt=nofile nobl ma nonu nowrap noro")
-  setl bt=nofile nobl ma nonu nowrap noro
+"  "  call Decho("(NetrwListSettings) setl bt=nofile nobl ma nonu nowrap noro nornu")
+  setl bt=nofile nobl ma nonu nowrap noro nornu
 "  call Decho("(NetrwListSettings) exe sil! keepalt file ".fnameescape(fname))
   exe "sil! keepalt file ".fnameescape(fname)
   if g:netrw_use_noswf
    setl noswf
   endif
+"  call Dredir("ls!")
 "  call Decho("(NetrwListSettings) exe setl ts=".(g:netrw_maxfilenamelen+1))
   exe "setl ts=".(g:netrw_maxfilenamelen+1)
   setl isk+=.,~,-
@@ -4116,6 +4061,7 @@
   else
    setl bh=delete
   endif
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
 "  call Dret("s:NetrwListSettings")
 endfun
 
@@ -4125,9 +4071,11 @@
 "         =1: local browsing
 fun! s:NetrwListStyle(islocal)
 "  call Dfunc("NetrwListStyle(islocal=".a:islocal.") w:netrw_liststyle=".w:netrw_liststyle)
+
   let ykeep             = @@
   let fname             = s:NetrwGetWord()
   if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
+  let svpos            = netrw#SavePosn()
   let w:netrw_liststyle = (w:netrw_liststyle + 1) % s:MAXLIST
 "  call Decho("fname<".fname.">")
 "  call Decho("chgd w:netrw_liststyle to ".w:netrw_liststyle)
@@ -4165,24 +4113,17 @@
 "  call Decho("clear buffer<".expand("%")."> with :%d")
   sil! keepj %d
   " following prevents tree listing buffer from being marked "modified"
-"  call Decho("(NetrwListStyle) setl nomod")
+"  call Decho("setl nomod")
   setl nomod
-"  call Decho("(NetrwListStyle) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 
   " refresh the listing
-"  call Decho("(NetrwListStyle) refresh the listing")
-  let svpos= netrw#NetrwSavePosn()
+"  call Decho("refresh the listing")
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-  keepj call netrw#NetrwRestorePosn(svpos)
   keepj call s:NetrwCursor()
 
-  " keep cursor on the filename
-  sil! keepj $
-  let result= search('\%(^\%(|\+\s\)\=\|\s\{2,}\)\zs'.escape(fname,'.\[]*$^').'\%(\s\{2,}\|$\)','bc')
-"  call Decho("search result=".result." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'N/A'))
-  if result <= 0 && exists("w:netrw_bannercnt")
-   exe "sil! keepj ".w:netrw_bannercnt
-  endif
+  " restore position; keep cursor on the filename
+  keepj call netrw#RestorePosn(svpos)
   let @@= ykeep
 
 "  call Dret("NetrwListStyle".(exists("w:netrw_liststyle")? ' : w:netrw_liststyle='.w:netrw_liststyle : ""))
@@ -4198,7 +4139,7 @@
   let g:netrw_banner= !g:netrw_banner
 
   " refresh the listing
-  let svpos= netrw#NetrwSavePosn()
+  let svpos= netrw#SavePosn()
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
 
   " keep cursor on the filename
@@ -4239,14 +4180,14 @@
    if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
     let cnt= 1
     for bmd in g:netrw_bookmarklist
-     let ebmd= escape(bmd,g:netrw_menu_escape)
-"     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.ebmd.'	:e '.bmd)
+"     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.bmd.'	:e '.bmd)
+     let bmd= escape(bmd,g:netrw_menu_escape)
 
      " show bookmarks for goto menu
-     exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.ebmd.'	:e '.bmd."\<cr>"
+     exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.bmd.'	:e '.bmd."\<cr>"
 
      " show bookmarks for deletion menu
-     exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.ebmd.'	'.cnt."mB"
+     exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.bmd.'	'.cnt."mB"
      let cnt= cnt + 1
     endfor
 
@@ -4284,78 +4225,109 @@
 "                       NetrwBrowseChgDir() edits the file.
 fun! s:NetrwBrowseChgDir(islocal,newdir,...)
 "  call Dfunc("s:NetrwBrowseChgDir(islocal=".a:islocal."> newdir<".a:newdir.">) a:0=".a:0." curpos<".string(getpos("."))."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "").">")
+"  call Decho("win#".winnr())
 
   let ykeep= @@
   if !exists("b:netrw_curdir")
    " Don't try to change-directory: this can happen, for example, when netrw#ErrorMsg has been called
    " and the current window is the NetrwMessage window.
    let @@= ykeep
-"   call Decho("(NetrwBrowseChgDir) b:netrw_curdir doesn't exist!")
-"   call Decho("(NetrwBrowseChgDir) getcwd<".getcwd().">")
+"   call Decho("b:netrw_curdir doesn't exist!")
+"   call Decho("getcwd<".getcwd().">")
+"   call Dredir("ls!")
 "   call Dret("s:NetrwBrowseChgDir")
    return
   endif
 
   " NetrwBrowseChgDir: save options and initialize {{{3
+"  call Decho("saving options")
   keepj call s:NetrwOptionSave("s:")
   keepj call s:NetrwSafeOptions()
-  let nbcd_curpos                = netrw#NetrwSavePosn()
+  let nbcd_curpos                = netrw#SavePosn()
   let s:nbcd_curpos_{bufnr('%')} = nbcd_curpos
-"  call Decho("(NetrwBrowseChgDir) setting s:nbcd_curpos_".bufnr('%')." to SavePosn")
+"  call Decho("setting s:nbcd_curpos_".bufnr('%')." to SavePosn")
   if (has("win32") || has("win95") || has("win64") || has("win16"))
-   let dirname                   = substitute(b:netrw_curdir,'\\','/','ge')
+   let dirname = substitute(b:netrw_curdir,'\\','/','ge')
   else
-   let dirname= b:netrw_curdir
+   let dirname = b:netrw_curdir
   endif
   let newdir    = a:newdir
   let dolockout = 0
+  let dorestore = 1
+"  call Decho("dirname<".dirname.">")
+
+  " ignore <cr>s when done in the banner
+  if g:netrw_banner
+"   call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." line(.)#".line('.')." line($)#".line("#"))
+   if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt && line("$") >= w:netrw_bannercnt
+    if getline(".") =~ 'Quick Help'
+"     call Decho("#1: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+     let g:netrw_quickhelp= (g:netrw_quickhelp + 1)%len(s:QuickHelp)
+"     call Decho("#2: quickhelp=".g:netrw_quickhelp." ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+     setl ma noro nowrap
+     keepj call setline(line('.'),'"   Quick Help: <F1>:help  '.s:QuickHelp[g:netrw_quickhelp])
+     setl noma nomod nowrap
+     keepj call netrw#RestorePosn(nbcd_curpos)
+     keepj call s:NetrwOptionRestore("s:")
+"     call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+    endif
+   endif
+"  else " Decho
+"   call Decho("(s:NetrwBrowseChgdir) g:netrw_banner=".g:netrw_banner." (no banner)")
+  endif
 
   " set up o/s-dependent directory recognition pattern
+"  call Decho("set up o/s-dependent directory recognition pattern")
   if has("amiga")
    let dirpat= '[\/:]$'
   else
    let dirpat= '[\/]$'
   endif
-"  call Decho("(NetrwBrowseChgDir) dirname<".dirname.">  dirpat<".dirpat.">")
+"  call Decho("dirname<".dirname.">  dirpat<".dirpat.">")
 
   if dirname !~ dirpat
    " apparently vim is "recognizing" that it is in a directory and
    " is removing the trailing "/".  Bad idea, so let's put it back.
    let dirname= dirname.'/'
-"   call Decho("(NetrwBrowseChgDir) adjusting dirname<".dirname.">")
+"   call Decho("adjusting dirname<".dirname.">")
   endif
 
   if newdir !~ dirpat
    " ------------------------------
    " NetrwBrowseChgDir: edit a file {{{3
    " ------------------------------
-"   call Decho('(NetrwBrowseChgDir:edit-a-file) case "handling a file": newdir<'.newdir.'> !~ dirpat<'.dirpat.">")
+"   call Decho('edit-a-file: case "handling a file": newdir<'.newdir.'> !~ dirpat<'.dirpat.">")
 
    " save position for benefit of Rexplore
-   let s:rexposn_{bufnr("%")}= netrw#NetrwSavePosn()
+   let s:rexposn_{bufnr("%")}= netrw#SavePosn()
+
+"   call Decho("edit-a-file: setting s:rexposn_".bufnr("%")." to SavePosn")
+"   call Decho("edit-a-file: win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft)
+"   call Decho("edit-a-file: w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a')." w:netrw_treedict:".(exists("w:netrw_treedict")? "exists" : 'n/a')." newdir<".newdir.">")
 
-"   call Decho("(NetrwBrowseChgDir:edit-a-file) setting s:rexposn_".bufnr("%")." to SavePosn")
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict") && newdir !~ '^\(/\|\a:\)'
+"    call Decho("edit-a-file: handle tree listing: w:netrw_treedict<".(exists("w:netrw_treedict")? string(w:netrw_treedict) : 'n/a').">")
+"    call Decho("edit-a-file: newdir<".newdir.">")
     let dirname= s:NetrwTreeDir()
     if dirname =~ '/$'
      let dirname= dirname.newdir
     else
-     let dirname= s:NetrwTreeDir()."/".newdir
+     let dirname= dirname."/".newdir
     endif
-"    call Decho("(NetrwBrowseChgDir:edit-a-file) dirname<".dirname.">")
-"    call Decho("(NetrwBrowseChgDir:edit-a-file) tree listing")
+"    call Decho("edit-a-file: dirname<".dirname.">")
+"    call Decho("edit-a-file: tree listing")
    elseif newdir =~ '^\(/\|\a:\)'
     let dirname= newdir
    else
     let dirname= s:ComposePath(dirname,newdir)
    endif
-"   call Decho("(NetrwBrowseChgDir:edit-a-file) handling a file: dirname<".dirname."> (a:0=".a:0.")")
+"   call Decho("edit-a-file: handling a file: dirname<".dirname."> (a:0=".a:0.")")
    " this lets NetrwBrowseX avoid the edit
    if a:0 < 1
-"    call Decho("(NetrwBrowseChgDir:edit-a-file) set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"))
+"    call Decho("edit-a-file: set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"))
     keepj call s:NetrwOptionRestore("s:")
     if !exists("s:didsplit")
-"     call Decho("(NetrwBrowseChgDir:edit-a-file) s:didsplit does not exist; g:netrw_browse_split=".g:netrw_browse_split." win#".winnr())
+"     call Decho("edit-a-file: s:didsplit does not exist; g:netrw_browse_split=".g:netrw_browse_split." win#".winnr())
      if     g:netrw_browse_split == 1
       " horizontally splitting the window first
       keepalt new
@@ -4380,10 +4352,18 @@
       endif
      else
       " handling a file, didn't split, so remove menu
-"      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a file+didn't split, so remove menu")
+"      call Decho("edit-a-file: handling a file+didn't split, so remove menu")
       call s:NetrwMenu(0)
       " optional change to window
       if g:netrw_chgwin >= 1
+       if winnr("$")+1 == g:netrw_chgwin
+	" if g:netrw_chgwin is set to one more than the last window, then
+	" vertically split the last window to make that window available.
+	let curwin= winnr()
+	exe "keepj keepalt ".g:netrw_chgwin."wincmd ".winnr("$")
+	vs
+	exe "keepj keepalt ".g:netrw_chgwin."wincmd ".curwin
+       endif
        exe "keepj keepalt ".g:netrw_chgwin."wincmd w"
       endif
      endif
@@ -4391,26 +4371,40 @@
 
     " the point where netrw actually edits the (local) file
     " if its local only: LocalBrowseCheck() doesn't edit a file, but NetrwBrowse() will
+    " no keepalt to support  :e #  to return to a directory listing
     if a:islocal
-"     call Decho("(NetrwBrowseChgDir:edit-a-file) edit local file: exe e! ".fnameescape(dirname))
-     exe "keepj keepalt e! ".fnameescape(dirname)
+"     call Decho("edit-a-file: edit local file: exe e! ".fnameescape(dirname))
+     " some like c-^ to return to the last edited file
+     " others like c-^ to return to the netrw buffer
+     if exists("g:netrw_altfile") && g:netrw_altfile
+      exe "keepj keepalt e! ".fnameescape(dirname)
+     else
+      exe "keepj e! ".fnameescape(dirname)
+     endif
+"     call Decho("after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
      call s:NetrwCursor()
+"     call Decho("COMBAK#1: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
+     if &hidden || &bufhidden == "hide"
+      " file came from vim's hidden storage.  Don't "restore" options with it.
+      let dorestore= 0
+     endif
     else
-"     call Decho("(NetrwBrowseChgDir:edit-a-file) remote file: NetrwBrowse will edit it")
+"     call Decho("edit-a-file: remote file: NetrwBrowse will edit it")
     endif
     let dolockout= 1
+"     call Decho("COMBAK#2: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
 
     " handle g:Netrw_funcref -- call external-to-netrw functions
     "   This code will handle g:Netrw_funcref as an individual function reference
     "   or as a list of function references.  It will ignore anything that's not
     "   a function reference.  See  :help Funcref  for information about function references.
     if exists("g:Netrw_funcref")
-"     call Decho("(NetrwBrowseChgDir:edit-a-file) handle optional Funcrefs")
+"     call Decho("edit-a-file: handle optional Funcrefs")
      if type(g:Netrw_funcref) == 2
-"      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a g:Netrw_funcref")
+"      call Decho("edit-a-file: handling a g:Netrw_funcref")
       keepj call g:Netrw_funcref()
      elseif type(g:Netrw_funcref) == 3
-"      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a list of g:Netrw_funcrefs")
+"      call Decho("edit-a-file: handling a list of g:Netrw_funcrefs")
       for Fncref in g:Netrw_funcref
        if type(FncRef) == 2
         keepj call FncRef()
@@ -4424,7 +4418,7 @@
    " ----------------------------------------------------
    " NetrwBrowseChgDir: just go to the new directory spec {{{3
    " ----------------------------------------------------
-"   call Decho('(NetrwBrowseChgDir:goto-newdir) case "just go to new directory spec": newdir<'.newdir.'>')
+"   call Decho('goto-newdir: case "just go to new directory spec": newdir<'.newdir.'>')
    let dirname    = newdir
    keepj call s:SetRexDir(a:islocal,dirname)
    keepj call s:NetrwOptionRestore("s:")
@@ -4433,37 +4427,52 @@
    " ---------------------------------------------
    " NetrwBrowseChgDir: refresh the directory list {{{3
    " ---------------------------------------------
-"   call Decho('(NetrwBrowseChgDir:refresh-dirlist) case "refresh directory listing": newdir == "./"')
+"   call Decho('refresh-dirlist: case "refresh directory listing": newdir == "./"')
    keepj call s:SetRexDir(a:islocal,dirname)
 
   elseif newdir == '../'
    " --------------------------------------
    " NetrwBrowseChgDir: go up one directory {{{3
    " --------------------------------------
-"   call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../"')
+"   call Decho('go-up: case "go up one directory": newdir == "../"')
 
    if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
     " force a refresh
-"    call Decho("(NetrwBrowseChgDir:go-up) clear buffer<".expand("%")."> with :%d")
-"    call Decho("(NetrwBrowseChgDir:go-up) setl noro ma")
+"    call Decho("go-up: clear buffer<".expand("%")."> with :%d")
+"    call Decho("go-up: setl noro ma")
     setl noro ma
     keepj %d
    endif
 
    if has("amiga")
     " amiga
-"    call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../" and amiga')
+"    call Decho('go-up: case "go up one directory": newdir == "../" and amiga')
     if a:islocal
      let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
      let dirname= substitute(dirname,'/$','','')
     else
      let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
     endif
-"    call Decho("(NetrwBrowseChgDir:go-up) amiga: dirname<".dirname."> (go up one dir)")
+"    call Decho("go-up: amiga: dirname<".dirname."> (go up one dir)")
+
+   elseif !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
+    " windows
+    if a:islocal
+     let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
+     if dirname == ""
+      let dirname= '/'
+     endif
+    else
+     let dirname= substitute(dirname,'^\(\a\+://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
+    endif
+    if dirname =~ '^\a:$'
+     let dirname= dirname.'/'
+    endif
+"    call Decho("go-up: windows: dirname<".dirname."> (go up one dir)")
 
    else
     " unix or cygwin
-"    call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../" and unix or cygwin')
+"    call Decho('go-up: case "go up one directory": newdir == "../" and unix or cygwin')
     if a:islocal
      let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
      if dirname == ""
@@ -4472,7 +4481,7 @@
     else
      let dirname= substitute(dirname,'^\(\a\+://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
     endif
-"    call Decho("(NetrwBrowseChgDir:go-up) unix: dirname<".dirname."> (go up one dir)")
+"    call Decho("go-up: unix: dirname<".dirname."> (go up one dir)")
    endif
    keepj call s:SetRexDir(a:islocal,dirname)
 
@@ -4480,35 +4489,35 @@
    " --------------------------------------
    " NetrwBrowseChgDir: Handle Tree Listing {{{3
    " --------------------------------------
-"   call Decho('(NetrwBrowseChgDir:tree-list) case liststyle is TREELIST and w:netrw_treedict exists')
+"   call Decho('tree-list: case liststyle is TREELIST and w:netrw_treedict exists')
    " force a refresh (for TREELIST, wait for NetrwTreeDir() to force the refresh)
-"   call Decho("(NetrwBrowseChgDir) (treelist) setl noro ma")
+"   call Decho("tree-list: setl noro ma")
    setl noro ma
    if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
-"    call Decho("(NetrwBrowseChgDir) clear buffer<".expand("%")."> with :%d")
+"    call Decho("tree-list: clear buffer<".expand("%")."> with :%d")
     keepj %d
    endif
    let treedir      = s:NetrwTreeDir()
    let s:treecurpos = nbcd_curpos
    let haskey= 0
-"   call Decho("(NetrwBrowseChgDir:tree-list) w:netrw_treedict<".string(w:netrw_treedict).">")
+"   call Decho("tree-list: w:netrw_treedict<".string(w:netrw_treedict).">")
 
    " search treedict for tree dir as-is
    if has_key(w:netrw_treedict,treedir)
-"    call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : found it!')
+"    call Decho('tree-list: ....searched for treedir<'.treedir.'> : found it!')
     let haskey= 1
    else
-"    call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : not found')
+"    call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found')
    endif
 
    " search treedict for treedir with a / appended
    if !haskey && treedir !~ '/$'
     if has_key(w:netrw_treedict,treedir."/")
      let treedir= treedir."/"
-"     call Decho('(NetrwBrowseChgDir:tree-list) ....searched.for treedir<'.treedir.'> found it!')
+"     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!')
      let haskey = 1
     else
-"     call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'/> : not found')
+"     call Decho('tree-list: ....searched for treedir<'.treedir.'/> : not found')
     endif
    endif
 
@@ -4516,24 +4525,24 @@
    if !haskey && treedir =~ '/$'
     let treedir= substitute(treedir,'/$','','')
     if has_key(w:netrw_treedict,treedir)
-"     call Decho('(NetrwBrowseChgDir:tree-list) ....searched.for treedir<'.treedir.'> found it!')
+"     call Decho('tree-list: ....searched.for treedir<'.treedir.'> found it!')
      let haskey = 1
     else
-"     call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : not found')
+"     call Decho('tree-list: ....searched for treedir<'.treedir.'> : not found')
     endif
    endif
 
    if haskey
     " close tree listing for selected subdirectory
-"    call Decho("(NetrwBrowseChgDir:tree-list) closing selected subdirectory<".dirname.">")
+"    call Decho("tree-list: closing selected subdirectory<".dirname.">")
     call remove(w:netrw_treedict,treedir)
-"    call Decho("(NetrwBrowseChgDir) removed     entry<".treedir."> from treedict")
-"    call Decho("(NetrwBrowseChgDir) yielding treedict<".string(w:netrw_treedict).">")
+"    call Decho("tree-list: removed     entry<".treedir."> from treedict")
+"    call Decho("tree-list: yielding treedict<".string(w:netrw_treedict).">")
     let dirname= w:netrw_treetop
    else
     " go down one directory
     let dirname= substitute(treedir,'/*$','/','')
-"    call Decho("(NetrwBrowseChgDir:tree-list) go down one dir: treedir<".treedir.">")
+"    call Decho("tree-list: go down one dir: treedir<".treedir.">")
    endif
    keepj call s:SetRexDir(a:islocal,dirname)
    let s:treeforceredraw = 1
@@ -4543,28 +4552,38 @@
    " NetrwBrowseChgDir: Go down one directory {{{3
    " ----------------------------------------
    let dirname    = s:ComposePath(dirname,newdir)
-"   call Decho("(NetrwBrowseChgDir:go-down) go down one dir: dirname<".dirname."> newdir<".newdir.">")
+"   call Decho("go down one dir: dirname<".dirname."> newdir<".newdir.">")
    keepj call s:SetRexDir(a:islocal,dirname)
   endif
 
  " --------------------------------------
  " NetrwBrowseChgDir: Restore and Cleanup {{{3
  " --------------------------------------
-  keepj call s:NetrwOptionRestore("s:")
-  if dolockout
-"   call Decho("(NetrwBrowseChgDir:restore) filewritable(dirname<".dirname.">)=".filewritable(dirname))
+"  call Decho("COMBAK#3: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
+  if dorestore
+   " dorestore is zero'd when a local file was hidden or bufhidden;
+   " in such a case, we want to keep whatever settings it may have.
+"   call Decho("doing option restore (dorestore=".dorestore.")")
+   keepj call s:NetrwOptionRestore("s:")
+"  else " Decho
+"   call Decho("skipping option restore (dorestore==0): hidden=".&hidden." bufhidden=".&bufhidden." mod=".&mod)
+  endif
+"  call Decho("COMBAK#4: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
+  if dolockout && dorestore
+"   call Decho("restore: filewritable(dirname<".dirname.">)=".filewritable(dirname))
    if filewritable(dirname)
-"    call Decho("(NetrwBrowseChgDir:restore) doing modification lockout settings: ma nomod noro")
-"    call Decho("(NetrwBrowseChgDir:restore) setl ma nomod noro")
-    setl ma nomod noro
-"    call Decho("(NetrwBrowseChgDir:restore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
-   else
-"    call Decho("(NetrwBrowseChgDir:restore) doing modification lockout settings: ma nomod ro")
-"    call Decho("(NetrwBrowseChgDir:restore) setl ma nomod noro")
-    setl ma nomod ro
-"    call Decho("(NetrwBrowseChgDir:restore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"    call Decho("restore: doing modification lockout settings: ma nomod noro")
+"    call Decho("restore: setl ma nomod noro")
+    setl ma noro nomod
+"    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+   else
+"    call Decho("restore: doing modification lockout settings: ma nomod ro")
+"    call Decho("restore: setl ma nomod noro")
+    setl ma ro nomod
+"    call Decho("restore: ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
    endif
   endif
+"  call Decho("COMBAK#5: after e! ".dirname.": hidden=".&hidden." bufhidden<".&bufhidden."> mod=".&mod)
   let @@= ykeep
 
 "  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
@@ -4572,6 +4591,55 @@
 endfun
 
 " ---------------------------------------------------------------------
+" s:NetrwBrowseUpDir: implements the "-" mappings {{{2
+"    for thin, long, and wide: cursor placed just after banner
+"    for tree, keeps cursor on current filename
+fun! s:NetrwBrowseUpDir(islocal)
+"  call Dfunc("s:NetrwBrowseUpDir(islocal=".a:islocal.")")
+  norm! 0
+  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
+"   call Decho("ftp + treestyle")
+   let curline= getline(".")
+   let swwline= winline() - 1
+   if exists("w:netrw_treetop")
+    let b:netrw_curdir= w:netrw_treetop
+   endif
+   if a:islocal
+    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
+   else
+    call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
+   endif
+   if !search('\c^'.s:treedepthstring.curline,'cw')
+    if !search('\c^'.curline,'cw')
+     sil! keepj 1
+    endif
+   endif
+   exe "sil! keepj norm! z\<cr>"
+   while winline() < swwline
+    let curwinline= winline()
+    exe "sil! keepj norm! \<c-y>"
+    if curwinline == winline()
+     break
+    endif
+   endwhile
+  else
+"   call Decho("ftp + not treestyle")
+   if a:islocal
+    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,'../'))
+   else
+    call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,'../'))
+   endif
+   if exists("w:netrw_bannercnt")
+"    call Decho("moving to line#".w:netrw_bannercnt)
+    exe w:netrw_bannercnt
+   else
+    1
+   endif
+  endif
+"  call Dret("s:NetrwBrowseUpDir")
+endfun
+
+" ---------------------------------------------------------------------
 " s:NetrwBrowseX:  (implements "x") executes a special "viewer" script or program for the {{{2
 "              given filename; typically this means given their extension.
 "              0=local, 1=remote
@@ -4579,7 +4647,7 @@
 "  call Dfunc("NetrwBrowseX(fname<".a:fname."> remote=".a:remote.")")
 
   let ykeep      = @@
-  let screenposn = netrw#NetrwSavePosn()
+  let screenposn = netrw#SavePosn()
 
   " special core dump handler
   if a:fname =~ '/core\(\.\d\+\)\=$'
@@ -4597,7 +4665,7 @@
       endif
      endfor
     endif
-    call netrw#NetrwRestorePosn(screenposn)
+    call netrw#RestorePosn(screenposn)
     let @@= ykeep
 "    call Dret("NetrwBrowseX : coredump handler invoked")
     return
@@ -4629,7 +4697,7 @@
 
   if a:remote == 1
    " create a local copy
-"   call Decho("(remote) a:remote=".a:remote.": create a local copy of <".a:fname.">")
+"   call Decho("remote: a:remote=".a:remote.": create a local copy of <".a:fname.">")
    setl bh=delete
    call netrw#NetRead(3,a:fname)
    " attempt to rename tempfile
@@ -4645,7 +4713,7 @@
     let fname= s:netrw_tmpfile
    endif
   else
-"   call Decho("(local) a:remote=".a:remote.": handling local copy of <".a:fname.">")
+"   call Decho("local: a:remote=".a:remote.": handling local copy of <".a:fname.">")
    let fname= a:fname
    " special ~ handler for local
    if fname =~ '^\~' && expand("$HOME") != ""
@@ -4783,7 +4851,7 @@
    exe "sil! keepj norm! \<c-o>"
 "   redraw!
   endif
-  call netrw#NetrwRestorePosn(screenposn)
+  call netrw#RestorePosn(screenposn)
   let @@= ykeep
 
 "  call Dret("NetrwBrowseX")
@@ -4901,10 +4969,10 @@
 fun! s:NetrwHide(islocal)
 "  call Dfunc("NetrwHide(islocal=".a:islocal.") g:netrw_hide=".g:netrw_hide)
   let ykeep= @@
-  let svpos= netrw#NetrwSavePosn()
+  let svpos= netrw#SavePosn()
 
   if exists("s:netrwmarkfilelist_{bufnr('%')}")
-"   call Decho(((g:netrw_hide == 1)? "unhide" : "hide")." files in markfilelist<".string(s:netrwmarkfilelist_{bufnr("%")}).">")
+"   call Decho("((g:netrw_hide == 1)? "unhide" : "hide")." files in markfilelist<".string(s:netrwmarkfilelist_{bufnr("%")}).">")
 "   call Decho("g:netrw_list_hide<".g:netrw_list_hide.">")
 
    " hide the files in the markfile list
@@ -4943,7 +5011,7 @@
   endif
 
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-  keepj call netrw#NetrwRestorePosn(svpos)
+  keepj call netrw#RestorePosn(svpos)
   let @@= ykeep
 "  call Dret("NetrwHide")
 endfun
@@ -4954,7 +5022,7 @@
 "  call Dfunc("s:NetrwHidden()")
   let ykeep= @@
   "  save current position
-  let svpos= netrw#NetrwSavePosn()
+  let svpos= netrw#SavePosn()
 
   if g:netrw_list_hide =~ '\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+'
    " remove pattern from hiding list
@@ -4967,7 +5035,7 @@
 
   " refresh screen and return to saved position
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-  keepj call netrw#NetrwRestorePosn(svpos)
+  keepj call netrw#RestorePosn(svpos)
   let @@= ykeep
 "  call Dret("s:NetrwHidden")
 endfun
@@ -5008,291 +5076,745 @@
 endfun
 
 " ---------------------------------------------------------------------
-" s:NetrwLeftmouse: handles the <leftmouse> when in a netrw browsing window {{{2
-fun! s:NetrwLeftmouse(islocal)
-  if exists("s:netrwdrag")
-   return
-  endif
-"  call Dfunc("s:NetrwLeftmouse(islocal=".a:islocal.")")
+" s:NetrwLeftmouse: handles the <leftmouse> when in a netrw browsing window {{{2
+fun! s:NetrwLeftmouse(islocal)
+  if exists("s:netrwdrag")
+   return
+  endif
+"  call Dfunc("s:NetrwLeftmouse(islocal=".a:islocal.")")
+
+  let ykeep= @@
+  " check if the status bar was clicked on instead of a file/directory name
+  while getchar(0) != 0
+   "clear the input stream
+  endwhile
+  call feedkeys("\<LeftMouse>")
+  let c          = getchar()
+  let mouse_lnum = v:mouse_lnum
+  let wlastline  = line('w$')
+  let lastline   = line('$')
+"  call Decho("v:mouse_lnum=".mouse_lnum." line(w$)=".wlastline." line($)=".lastline." v:mouse_win=".v:mouse_win." winnr#".winnr())
+"  call Decho("v:mouse_col =".v:mouse_col."     col=".col(".")."  wincol =".wincol()." winwidth   =".winwidth(0))
+  if mouse_lnum >= wlastline + 1 || v:mouse_win != winnr()
+   " appears to be a status bar leftmouse click
+   let @@= ykeep
+"   call Dret("s:NetrwLeftmouse : detected a status bar leftmouse click")
+   return
+  endif
+   " NOTE: following test is preventing leftmouse selection/deselection of directories and files in treelist mode (Dec 04, 2013)
+   " Windows are separated by vertical separator bars - but the mouse seems to be doing what it should when dragging that bar
+   " without this test.
+"  if v:mouse_col != col('.')
+"   let @@= ykeep
+"   call Dret("s:NetrwLeftmouse : detected a vertical separator bar leftmouse click")
+"   return
+"  endif
+
+  if a:islocal
+   if exists("b:netrw_curdir")
+    keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
+   endif
+  else
+   if exists("b:netrw_curdir")
+    keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
+   endif
+  endif
+  let @@= ykeep
+"  call Dret("s:NetrwLeftmouse")
+endfun
+
+" ---------------------------------------------------------------------
+" s:NetrwSLeftmouse: marks the file under the cursor.  May be dragged to select additional files {{{2
+fun! s:NetrwSLeftmouse(islocal)
+"  call Dfunc("s:NetrwSLeftmouse(islocal=".a:islocal.")")
+  
+  let s:ngw= s:NetrwGetWord()
+  call s:NetrwMarkFile(a:islocal,s:ngw)
+
+"  call Dret("s:NetrwSLeftmouse")
+endfun
+
+" ---------------------------------------------------------------------
+" s:NetrwSLeftdrag: invoked via a shift-leftmouse and dragging {{{2
+"                   Used to mark multiple files.
+fun! s:NetrwSLeftdrag(islocal)
+"  call Dfunc("s:NetrwSLeftdrag(islocal=".a:islocal.")")
+  if !exists("s:netrwdrag")
+   let s:netrwdrag = winnr()
+   if a:islocal
+    nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(1)<cr>
+   else
+    nno <silent> <s-leftrelease> <leftmouse>:<c-u>call <SID>NetrwSLeftrelease(0)<cr>
+   endif
+  endif
+  let ngw = s:NetrwGetWord()
+  if !exists("s:ngw") || s:ngw != ngw
+   call s:NetrwMarkFile(a:islocal,ngw)
+  endif
+  let s:ngw= ngw
+"  call Dret("s:NetrwSLeftdrag : s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
+endfun
+
+" ---------------------------------------------------------------------
+" s:NetrwSLeftrelease: terminates shift-leftmouse dragging {{{2
+fun! s:NetrwSLeftrelease(islocal)
+"  call Dfunc("s:NetrwSLeftrelease(islocal=".a:islocal.") s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
+  if exists("s:netrwdrag")
+   nunmap <s-leftrelease>
+   let ngw = s:NetrwGetWord()
+   if !exists("s:ngw") || s:ngw != ngw
+    call s:NetrwMarkFile(a:islocal,ngw)
+   endif
+   if exists("s:ngw")
+    unlet s:ngw
+   endif
+   unlet s:netrwdrag
+  endif
+"  call Dret("s:NetrwSLeftrelease")
+endfun
+
+" ---------------------------------------------------------------------
+" s:NetrwListHide: uses [range]g~...~d to delete files that match comma {{{2
+" separated patterns given in g:netrw_list_hide
+fun! s:NetrwListHide()
+"  call Dfunc("NetrwListHide() g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
+  let ykeep= @@
+
+  " find a character not in the "hide" string to use as a separator for :g and :v commands
+  " How-it-works: take the hiding command, convert it into a range.  Duplicate
+  " characters don't matter.  Remove all such characters from the '/~...90'
+  " string.  Use the first character left as a separator character.
+  let listhide= g:netrw_list_hide
+  let sep     = strpart(substitute('/~@#$%^&*{};:,<.>?|1234567890','['.escape(listhide,'-]^\').']','','ge'),1,1)
+"  call Decho("sep=".sep)
+
+  while listhide != ""
+   if listhide =~ ','
+    let hide     = substitute(listhide,',.*$','','e')
+    let listhide = substitute(listhide,'^.\{-},\(.*\)$','\1','e')
+   else
+    let hide     = listhide
+    let listhide = ""
+   endif
+
+   " Prune the list by hiding any files which match
+   if g:netrw_hide == 1
+"    call Decho("hiding<".hide."> listhide<".listhide.">")
+    exe 'sil! keepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'d'
+   elseif g:netrw_hide == 2
+"    call Decho("showing<".hide."> listhide<".listhide.">")
+    exe 'sil! keepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'s@^@ /-KEEP-/ @'
+   endif
+  endwhile
+  if g:netrw_hide == 2
+   exe 'sil! keepj '.w:netrw_bannercnt.',$v@^ /-KEEP-/ @d'
+   exe 'sil! keepj '.w:netrw_bannercnt.',$s@^\%( /-KEEP-/ \)\+@@e'
+  endif
+
+  " remove any blank lines that have somehow remained.
+  " This seems to happen under Windows.
+  exe 'sil! keepj 1,$g@^\s*$@d'
+
+  let @@= ykeep
+"  call Dret("NetrwListHide")
+endfun
+
+" ---------------------------------------------------------------------
+" NetrwHideEdit: allows user to edit the file/directory hiding list
+fun! s:NetrwHideEdit(islocal)
+"  call Dfunc("NetrwHideEdit(islocal=".a:islocal.")")
+
+  let ykeep= @@
+  " save current cursor position
+  let svpos= netrw#SavePosn()
+
+  " get new hiding list from user
+  call inputsave()
+  let newhide= input("Edit Hiding List: ",g:netrw_list_hide)
+  call inputrestore()
+  let g:netrw_list_hide= newhide
+"  call Decho("new g:netrw_list_hide<".g:netrw_list_hide.">")
+
+  " refresh the listing
+  sil keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,"./"))
+
+  " restore cursor position
+  call netrw#RestorePosn(svpos)
+  let @@= ykeep
+
+"  call Dret("NetrwHideEdit")
+endfun
+
+" ---------------------------------------------------------------------
+" NetSortSequence: allows user to edit the sorting sequence
+fun! s:NetSortSequence(islocal)
+"  call Dfunc("NetSortSequence(islocal=".a:islocal.")")
+
+  let ykeep= @@
+  let svpos= netrw#SavePosn()
+  call inputsave()
+  let newsortseq= input("Edit Sorting Sequence: ",g:netrw_sort_sequence)
+  call inputrestore()
+
+  " refresh the listing
+  let g:netrw_sort_sequence= newsortseq
+  keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
+  keepj call netrw#RestorePosn(svpos)
+  let @@= ykeep
+
+"  call Dret("NetSortSequence")
+endfun
+
+" ---------------------------------------------------------------------
+" s:NetrwMakeDir: this function makes a directory (both local and remote) {{{2
+fun! s:NetrwMakeDir(usrhost)
+"  call Dfunc("s:NetrwMakeDir(usrhost<".a:usrhost.">)")
 
   let ykeep= @@
-  " check if the status bar was clicked on instead of a file/directory name
-  while getchar(0) != 0
-   "clear the input stream
-  endwhile
-  call feedkeys("\<LeftMouse>")
-  let c          = getchar()
-  let mouse_lnum = v:mouse_lnum
-  let wlastline  = line('w$')
-  let lastline   = line('$')
-"  call Decho("v:mouse_lnum=".mouse_lnum." line(w$)=".wlastline." line($)=".lastline." v:mouse_win=".v:mouse_win." winnr#".winnr())
-"  call Decho("v:mouse_col =".v:mouse_col."     col=".col(".")."  wincol =".wincol()." winwidth   =".winwidth(0))
-  if mouse_lnum >= wlastline + 1 || v:mouse_win != winnr()
-   " appears to be a status bar leftmouse click
-   let @@= ykeep
-"   call Dret("s:NetrwLeftmouse : detected a status bar leftmouse click")
-   return
-  endif
-  if v:mouse_col != col('.')
+  " get name of new directory from user.  A bare <CR> will skip.
+  " if its currently a directory, also request will be skipped, but with
+  " a message.
+  call inputsave()
+  let newdirname= input("Please give directory name: ")
+  call inputrestore()
+"  call Decho("newdirname<".newdirname.">")
+
+  if newdirname == ""
    let @@= ykeep
-"   call Dret("s:NetrwLeftmouse : detected a vertical separator bar leftmouse click")
+"   call Dret("s:NetrwMakeDir : user aborted with bare <cr>")
    return
   endif
 
-  if a:islocal
-   if exists("b:netrw_curdir")
-    keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
+  if a:usrhost == ""
+"   call Decho("local mkdir")
+
+   " Local mkdir:
+   " sanity checks
+   let fullnewdir= b:netrw_curdir.'/'.newdirname
+"   call Decho("fullnewdir<".fullnewdir.">")
+   if isdirectory(fullnewdir)
+    if !exists("g:netrw_quiet")
+     keepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a directory!",24)
+    endif
+    let @@= ykeep
+"    call Dret("s:NetrwMakeDir : directory<".newdirname."> exists previously")
+    return
    endif
-  else
-   if exists("b:netrw_curdir")
-    keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
+   if s:FileReadable(fullnewdir)
+    if !exists("g:netrw_quiet")
+     keepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a file!",25)
+    endif
+    let @@= ykeep
+"    call Dret("s:NetrwMakeDir : file<".newdirname."> exists previously")
+    return
    endif
-  endif
-  let @@= ykeep
-"  call Dret("s:NetrwLeftmouse")
-endfun
 
-" ---------------------------------------------------------------------
-" s:NetrwRightdrag: {{{2
-"DechoTabOn
-fun! s:NetrwRightdrag(islocal)
-"  call Dfunc("s:NetrwRightdrag(islocal=".a:islocal.")")
-  if !exists("s:netrwdrag")
-   let s:netrwdrag     = winnr()
-   call s:NetrwMarkFile(a:islocal,s:NetrwGetWord())
-   if a:islocal
-    nno <silent> <s-rightrelease> <leftmouse>:<c-u>call <SID>NetrwRightrelease(1)<cr>
+   " requested new local directory is neither a pre-existing file or
+   " directory, so make it!
+   if exists("*mkdir")
+    if has("unix")
+     call mkdir(fullnewdir,"p",xor(0777, system("umask")))
+    else
+     call mkdir(fullnewdir,"p")
+    endif
+   else
+    let netrw_origdir= s:NetrwGetcwd(1)
+    call s:NetrwLcd(b:netrw_curdir)
+"    call Decho("netrw_origdir<".netrw_origdir.">: lcd b:netrw_curdir<".fnameescape(b:netrw_curdir).">")
+"    call Decho("exe sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1))
+    exe "sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1)
+    if v:shell_error != 0
+     let @@= ykeep
+     call netrw#ErrorMsg(s:ERROR,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
+"     call Dret("s:NetrwMakeDir : failed: sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1))
+     return
+    endif
+    if !g:netrw_keepdir
+"     call Decho("restoring netrw_origdir since g:netrw_keepdir=".g:netrw_keepdir)
+     call s:NetrwLcd(netrw_origdir)
+    endif
+   endif
+
+   if v:shell_error == 0
+    " refresh listing
+"    call Decho("refresh listing")
+    let svpos= netrw#SavePosn()
+    call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
+    call netrw#RestorePosn(svpos)
+   elseif !exists("g:netrw_quiet")
+    call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",26)
+   endif
+"   redraw!
+
+  elseif !exists("b:netrw_method") || b:netrw_method == 4
+   " Remote mkdir:  using ssh
+"   call Decho("remote mkdir")
+   let mkdircmd  = s:MakeSshCmd(g:netrw_mkdir_cmd)
+   let newdirname= substitute(b:netrw_curdir,'^\%(.\{-}/\)\{3}\(.*\)$','\1','').newdirname
+"   call Decho("exe sil! !".mkdircmd." ".shellescape(newdirname,1))
+   exe "sil! !".mkdircmd." ".shellescape(newdirname,1)
+   if v:shell_error == 0
+    " refresh listing
+    let svpos= netrw#SavePosn()
+    keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
+    keepj call netrw#RestorePosn(svpos)
+   elseif !exists("g:netrw_quiet")
+    keepj call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",27)
+   endif
+"   redraw!
+
+  elseif b:netrw_method == 2
+   " Remote mkdir:  using ftp+.netrc
+   let svpos= netrw#SavePosn()
+"   call Decho("b:netrw_curdir<".b:netrw_curdir.">")
+   if exists("b:netrw_fname")
+"    call Decho("b:netrw_fname<".b:netrw_fname.">")
+    let remotepath= b:netrw_fname
+   else
+    let remotepath= ""
+   endif
+   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
+   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
+   keepj call netrw#RestorePosn(svpos)
+
+  elseif b:netrw_method == 3
+   " Remote mkdir: using ftp + machine, id, passwd, and fname (ie. no .netrc)
+   let svpos= netrw#SavePosn()
+"   call Decho("b:netrw_curdir<".b:netrw_curdir.">")
+   if exists("b:netrw_fname")
+"    call Decho("b:netrw_fname<".b:netrw_fname.">")
+    let remotepath= b:netrw_fname
    else
-    nno <silent> <s-rightrelease> <leftmouse>:<c-u>call <SID>NetrwRightrelease(0)<cr>
+    let remotepath= ""
    endif
+   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
+   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
+   keepj call netrw#RestorePosn(svpos)
   endif
-"  call Dret("s:NetrwRightdrag : s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
+
+  let @@= ykeep
+"  call Dret("s:NetrwMakeDir")
 endfun
 
 " ---------------------------------------------------------------------
-" s:NetrwRightrelease: {{{2
-fun! s:NetrwRightrelease(islocal)
-"  call Dfunc("s:NetrwRightrelease(islocal=".a:islocal.") s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
-  if exists("s:netrwdrag")
-   nunmap <s-rightrelease>
-   let tgt = s:NetrwGetWord()
-"   call Decho("target#1: ".tgt)
-   if tgt =~ '/$' && tgt !~ '^\./$'
-    let tgt = b:netrw_curdir."/".tgt
-   else
-    let tgt= b:netrw_curdir
-   endif
-"   call Decho("target#2: ".tgt)
-   call netrw#NetrwMakeTgt(tgt)
-   let curwin= winnr()
-   exe s:netrwdrag."wincmd w"
-   call s:NetrwMarkFileMove(a:islocal)
-   exe curwin."wincmd w"
-   unlet s:netrwdrag
+" s:TreeSqueezeDir: allows a shift-cr (gvim only) to squeeze the current tree-listing directory {{{2
+fun! s:TreeSqueezeDir(islocal)
+"  call Dfunc("s:TreeSqueezeDir(islocal=".a:islocal.")")
+  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
+   " its a tree-listing style
+   let curdepth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
+   let iline    = line(".") - 1
+   let stopline = (exists("w:netrw_bannercnt")? (w:netrw_bannercnt + 1) : 1)
+"   call Decho("curdepth=".curdepth)
+"   call Decho("stopline#".stopline)
+"   call Decho("starting with line#".line(".").": ".getline('.'))
+   while iline > stopline
+    " find a line that has less depth
+    let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
+"    call Decho("considering  line#".line(".").": ".getline('.'))
+    if depth < curdepth
+     break
+    endif
+    norm! k
+   endwhile
+"   call Decho("squeezing at line#".line(".").": ".getline('.'))
+   call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,s:NetrwGetWord()))
   endif
-"  call Dret("s:NetrwRightrelease")
+"  call Dret("s:TreeSqueezeDir")
 endfun
 
 " ---------------------------------------------------------------------
-" s:NetrwListHide: uses [range]g~...~d to delete files that match comma {{{2
-" separated patterns given in g:netrw_list_hide
-fun! s:NetrwListHide()
-"  call Dfunc("NetrwListHide() g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
-  let ykeep= @@
+" s:NetrwMaps: {{{2
+fun! s:NetrwMaps(islocal)
+"  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
 
-  " find a character not in the "hide" string to use as a separator for :g and :v commands
-  " How-it-works: take the hiding command, convert it into a range.  Duplicate
-  " characters don't matter.  Remove all such characters from the '/~...90'
-  " string.  Use the first character left as a separator character.
-  let listhide= g:netrw_list_hide
-  let sep     = strpart(substitute('/~@#$%^&*{};:,<.>?|1234567890','['.escape(listhide,'-]^\').']','','ge'),1,1)
-"  call Decho("sep=".sep)
+  if g:netrw_mousemaps && g:netrw_retmap
+"   call Decho("set up Rexplore 2-leftmouse")
+   if !hasmapto("<Plug>NetrwReturn")
+    if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
+"     call Decho("making map for 2-leftmouse")
+     nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
+    elseif maparg("<c-leftmouse>","n") == ""
+"     call Decho("making map for c-leftmouse")
+     nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
+    endif
+   endif
+   nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
+"   call Decho("made <Plug>NetrwReturn map")
+  endif
 
-  while listhide != ""
-   if listhide =~ ','
-    let hide     = substitute(listhide,',.*$','','e')
-    let listhide = substitute(listhide,'^.\{-},\(.*\)$','\1','e')
-   else
-    let hide     = listhide
-    let listhide = ""
+  if a:islocal
+"   call Decho("make local maps")
+   " local normal-mode maps
+   nnoremap <buffer> <silent> a		:call <SID>NetrwHide(1)<cr>
+   nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(1)<cr>
+   nnoremap <buffer> <silent> c		:call <SID>NetrwLcd(b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> C		:<c-u>call <SID>NetrwSetChgwin()<cr>
+   nnoremap <buffer> <silent> <cr>	:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
+   nnoremap <buffer> <silent> <s-cr>	:call <SID>TreeSqueezeDir(1)<cr>
+   nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>
+   nnoremap <buffer> <silent> -		:call <SID>NetrwBrowseUpDir(1)<cr>
+   nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
+   nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
+   nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
+   nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
+   nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(1)<cr>
+   nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
+   nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
+   nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
+   nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
+   nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
+   nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
+   nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
+   nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
+   nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
+   nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
+   nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
+   nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
+   nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
+   nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
+   nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
+   nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
+   nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(1)<cr>
+   nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(3)<cr>
+   nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
+   nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(1)<cr>
+   nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
+   nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
+   nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
+   nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(1)<cr>
+   nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(1)<cr>
+   nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(4)<cr>
+   nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
+   nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
+   nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
+   nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
+   nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(5)<cr>
+   nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
+   nnoremap <buffer> <silent> X		:call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
+   " local insert-mode maps
+   inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(1)<cr>
+   inoremap <buffer> <silent> c		<c-o>:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> c		<c-o>:call <SID>NetrwLcd(b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
+   inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(1)<cr>
+   inoremap <buffer> <silent> -		<c-o>:call <SID>NetrwBrowseUpDir(1)<cr>
+   inoremap <buffer> <silent> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
+   inoremap <buffer> <silent> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(1)<cr>
+   inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>
+   inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
+   inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
+   inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(1)<cr>
+   inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
+   inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
+   inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
+   inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
+   inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
+   inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
+   inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
+   inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
+   inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
+   inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
+   inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
+   inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
+   inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
+   inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
+   inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
+   inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
+   inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(1)<cr>
+   inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(3)<cr>
+   inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
+   inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
+   inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
+   inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
+   inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
+   inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(1)<cr>
+   inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(1)<cr>
+   inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(4)<cr>
+   inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
+   inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
+   inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
+   inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
+   inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(5)<cr>
+   inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
+   if !hasmapto('<Plug>NetrwHideEdit')
+    nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
+    imap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
+   endif
+   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(1)<cr>
+   if !hasmapto('<Plug>NetrwRefresh')
+    nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
+    imap <buffer> <unique> <c-l> <Plug>NetrwRefresh
    endif
-
-   " Prune the list by hiding any files which match
-   if g:netrw_hide == 1
-"    call Decho("hiding<".hide."> listhide<".listhide.">")
-    exe 'sil! keepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'d'
-   elseif g:netrw_hide == 2
-"    call Decho("showing<".hide."> listhide<".listhide.">")
-    exe 'sil! keepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'s@^@ /-KEEP-/ @'
+   nnoremap <buffer> <silent> <Plug>NetrwRefresh		:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
+   if s:didstarstar || !mapcheck("<s-down>","n")
+    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
+    inoremap <buffer> <silent> <s-down>	:Nexplore<cr>
    endif
-  endwhile
-  if g:netrw_hide == 2
-   exe 'sil! keepj '.w:netrw_bannercnt.',$v@^ /-KEEP-/ @d'
-   exe 'sil! keepj '.w:netrw_bannercnt.',$s@^\%( /-KEEP-/ \)\+@@e'
-  endif
-
-  " remove any blank lines that have somehow remained.
-  " This seems to happen under Windows.
-  exe 'sil! keepj 1,$g@^\s*$@d'
-
-  let @@= ykeep
-"  call Dret("NetrwListHide")
-endfun
-
-" ---------------------------------------------------------------------
-" NetrwHideEdit: allows user to edit the file/directory hiding list
-fun! s:NetrwHideEdit(islocal)
-"  call Dfunc("NetrwHideEdit(islocal=".a:islocal.")")
-
-  let ykeep= @@
-  " save current cursor position
-  let svpos= netrw#NetrwSavePosn()
-
-  " get new hiding list from user
-  call inputsave()
-  let newhide= input("Edit Hiding List: ",g:netrw_list_hide)
-  call inputrestore()
-  let g:netrw_list_hide= newhide
-"  call Decho("new g:netrw_list_hide<".g:netrw_list_hide.">")
-
-  " refresh the listing
-  sil keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,"./"))
-
-  " restore cursor position
-  call netrw#NetrwRestorePosn(svpos)
-  let @@= ykeep
-
-"  call Dret("NetrwHideEdit")
-endfun
-
-" ---------------------------------------------------------------------
-" NetSortSequence: allows user to edit the sorting sequence
-fun! s:NetSortSequence(islocal)
-"  call Dfunc("NetSortSequence(islocal=".a:islocal.")")
-
-  let ykeep= @@
-  let svpos= netrw#NetrwSavePosn()
-  call inputsave()
-  let newsortseq= input("Edit Sorting Sequence: ",g:netrw_sort_sequence)
-  call inputrestore()
-
-  " refresh the listing
-  let g:netrw_sort_sequence= newsortseq
-  keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-  keepj call netrw#NetrwRestorePosn(svpos)
-  let @@= ykeep
-
-"  call Dret("NetSortSequence")
-endfun
-
-" ---------------------------------------------------------------------
-" s:NetrwMakeDir: this function makes a directory (both local and remote) {{{2
-fun! s:NetrwMakeDir(usrhost)
-"  call Dfunc("NetrwMakeDir(usrhost<".a:usrhost.">)")
-
-  let ykeep= @@
-  " get name of new directory from user.  A bare <CR> will skip.
-  " if its currently a directory, also request will be skipped, but with
-  " a message.
-  call inputsave()
-  let newdirname= input("Please give directory name: ")
-  call inputrestore()
-"  call Decho("newdirname<".newdirname.">")
-
-  if newdirname == ""
-   let @@= ykeep
-"   call Dret("NetrwMakeDir : user aborted with bare <cr>")
-   return
-  endif
-
-  if a:usrhost == ""
-"   call Decho("local mkdir")
+   if s:didstarstar || !mapcheck("<s-up>","n")
+    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
+    inoremap <buffer> <silent> <s-up>	:Pexplore<cr>
+   endif
+   let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
+   if g:netrw_mousemaps == 1
+    nmap <buffer> <leftmouse>   	<Plug>NetrwLeftmouse
+    nno  <buffer> <silent>		<Plug>NetrwLeftmouse		<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
+    nmap <buffer> <middlemouse>		<Plug>NetrwMiddlemouse
+    nno  <buffer> <silent>		<Plug>NetrwMiddlemouse		<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
+    nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
+    nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 		<leftmouse>:call <SID>NetrwSLeftmouse(1)<cr>
+    nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
+    nno  <buffer> <silent>		<Plug>NetrwSLeftdrag		<leftmouse>:call <SID>NetrwSLeftdrag(1)<cr>
+    nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
+    nmap <buffer> <silent>		<Plug>Netrw2Leftmouse		-
+    imap <buffer> <leftmouse>		<Plug>ILeftmouse
+    ino  <buffer> <silent>		<Plug>ILeftmouse		<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
+    imap <buffer> <middlemouse>		<Plug>IMiddlemouse
+    ino  <buffer> <silent>		<Plug>IMiddlemouse		<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
+    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
+    ino  <buffer> <silent>		<Plug>ISLeftmouse		<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
+    exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+    exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+    exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+   endif
+   exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+   exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+   exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
+   exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>'
+   exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+   exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+   exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
+   exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+   exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
+   exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
+   exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>'
+   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
 
-   " Local mkdir:
-   " sanity checks
-   let fullnewdir= b:netrw_curdir.'/'.newdirname
-"   call Decho("fullnewdir<".fullnewdir.">")
-   if isdirectory(fullnewdir)
-    if !exists("g:netrw_quiet")
-     keepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a directory!",24)
-    endif
-    let @@= ykeep
-"    call Dret("NetrwMakeDir : directory<".newdirname."> exists previously")
-    return
+  else " remote
+"   call Decho("make remote maps")
+   call s:RemotePathAnalysis(b:netrw_curdir)
+   " remote normal-mode maps
+   nnoremap <buffer> <silent> <cr>	:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
+   nnoremap <buffer> <silent> <s-cr>	:call <SID>TreeSqueezeDir(0)<cr>
+   nnoremap <buffer> <silent> <c-l>	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
+   nnoremap <buffer> <silent> -		:call <SID>NetrwBrowseUpDir(0)<cr>
+   nnoremap <buffer> <silent> a		:call <SID>NetrwHide(0)<cr>
+   nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
+   nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
+   nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
+   nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
+   nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
+   nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
+   nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
+   nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
+   nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
+   nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
+   nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
+   nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
+   nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
+   nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
+   nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
+   nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
+   nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
+   nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
+   nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
+   nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> C		:<c-u>call <SID>NetrwSetChgwin()<cr>
+   nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(0)<cr>
+   nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
+   nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(0)<cr>
+   nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(0)<cr>
+   nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
+   nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(0)<cr>
+   nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
+   nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
+   nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
+   nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(0)<cr>
+   nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(0)<cr>
+   nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(1)<cr>
+   nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
+   nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
+   nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
+   nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(2)<cr>
+   nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
+   nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(0)<cr>
+   " remote insert-mode maps
+   inoremap <buffer> <silent> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
+   inoremap <buffer> <silent> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
+   inoremap <buffer> <silent> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(0)<cr>
+   inoremap <buffer> <silent> -		<c-o>:call <SID>NetrwBrowseUpDir(0)<cr>
+   inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(0)<cr>
+   inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
+   inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
+   inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
+   inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
+   inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
+   inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
+   inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
+   inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
+   inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
+   inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
+   inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
+   inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
+   inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
+   inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
+   inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
+   inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
+   inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
+   inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
+   inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
+   inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
+   inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(0)<cr>
+   inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(0)<cr>
+   inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
+   inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
+   inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
+   inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
+   inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
+   inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
+   inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(0)<cr>
+   inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(1)<cr>
+   inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
+   inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
+   inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
+   inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(2)<cr>
+   inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
+   inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
+   if !hasmapto('<Plug>NetrwHideEdit')
+    nmap <buffer> <c-h> <Plug>NetrwHideEdit
+    imap <buffer> <c-h> <Plug>NetrwHideEdit
    endif
-   if s:FileReadable(fullnewdir)
-    if !exists("g:netrw_quiet")
-     keepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a file!",25)
-    endif
-    let @@= ykeep
-"    call Dret("NetrwMakeDir : file<".newdirname."> exists previously")
-    return
+   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
+   if !hasmapto('<Plug>NetrwRefresh')
+    nmap <buffer> <c-l> <Plug>NetrwRefresh
+    imap <buffer> <c-l> <Plug>NetrwRefresh
    endif
 
-   " requested new local directory is neither a pre-existing file or
-   " directory, so make it!
-   if exists("*mkdir")
-    call mkdir(fullnewdir,"p")
-   else
-    let netrw_origdir= s:NetrwGetcwd(1)
-    exe 'keepj lcd '.fnameescape(b:netrw_curdir)
-"    call Decho("netrw_origdir<".netrw_origdir.">: lcd b:netrw_curdir<".fnameescape(b:netrw_curdir).">")
-"    call Decho("exe sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1))
-    exe "sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1)
-    if v:shell_error != 0
-     let @@= ykeep
-     call netrw#ErrorMsg(s:ERROR,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
-"     call Dret("NetrwMakeDir : failed: sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1))
-     return
-    endif
-    if !g:netrw_keepdir
-     exe 'keepj lcd '.fnameescape(netrw_origdir)
-"     call Decho("netrw_keepdir=".g:netrw_keepdir.": keepjumps lcd ".fnameescape(netrw_origdir)." getcwd<".getcwd().">")
-    endif
+   let mapsafepath     = escape(s:path, s:netrw_map_escape)
+   let mapsafeusermach = escape(s:user.s:machine, s:netrw_map_escape)
+
+   nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
+   if g:netrw_mousemaps == 1
+    nmap <leftmouse>		<Plug>NetrwLeftmouse
+    nno <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
+    nmap <buffer> <leftdrag>	<Plug>NetrwLeftdrag
+    nno  <buffer> <silent>	<Plug>NetrwLeftdrag	:call <SID>NetrwLeftdrag(0)<cr>
+    nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
+    nno  <buffer> <silent>	<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(0)<cr>
+    nmap <buffer> <s-leftdrag>	<Plug>NetrwSLeftdrag
+    nno  <buffer> <silent>	<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(0)<cr>
+    nmap <middlemouse>		<Plug>NetrwMiddlemouse
+    nno  <buffer> <silent>	<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
+    nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
+    nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
+    imap <buffer> <leftmouse>	<Plug>ILeftmouse
+    ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
+    imap <buffer> <middlemouse>	<Plug>IMiddlemouse
+    ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
+    imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
+    ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
+    exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+    exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+    exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
    endif
+   exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
+   exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
+   exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
+   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
+   inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>
+  endif
 
-   if v:shell_error == 0
-    " refresh listing
-"    call Decho("refresh listing")
-    let svpos= netrw#NetrwSavePosn()
-    call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
-    call netrw#NetrwRestorePosn(svpos)
-   elseif !exists("g:netrw_quiet")
-    call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",26)
-   endif
-"   redraw!
+  keepj call s:SetRexDir(a:islocal,b:netrw_curdir)
 
-  elseif !exists("b:netrw_method") || b:netrw_method == 4
-   " Remote mkdir:
-"   call Decho("remote mkdir")
-   let mkdircmd  = s:MakeSshCmd(g:netrw_mkdir_cmd)
-   let newdirname= substitute(b:netrw_curdir,'^\%(.\{-}/\)\{3}\(.*\)$','\1','').newdirname
-"   call Decho("exe sil! !".mkdircmd." ".shellescape(newdirname,1))
-   exe "sil! !".mkdircmd." ".shellescape(newdirname,1)
-   if v:shell_error == 0
-    " refresh listing
-    let svpos= netrw#NetrwSavePosn()
-    keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
-    keepj call netrw#NetrwRestorePosn(svpos)
-   elseif !exists("g:netrw_quiet")
-    keepj call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",27)
-   endif
-"   redraw!
+"  call Dret("s:NetrwMaps")
+endfun
 
-  elseif b:netrw_method == 2
-   let svpos= netrw#NetrwSavePosn()
-   call s:NetrwRemoteFtpCmd("",g:netrw_remote_mkdir.' "'.newdirname.'"')
-   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
-   keepj call netrw#NetrwRestorePosn(svpos)
-  elseif b:netrw_method == 3
-   let svpos= netrw#NetrwSavePosn()
-   call s:NetrwRemoteFtpCmd("",g:netrw_remote_mkdir.' "'.newdirname.'"')
-   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
-   keepj call netrw#NetrwRestorePosn(svpos)
+" ---------------------------------------------------------------------
+" s:NetrwCommands: sets up commands available only in the netrw buffer windows {{{2
+fun! s:NetrwCommands(islocal)
+"  call Dfunc("s:NetrwCommands(islocal=".a:islocal.")")
+
+  com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"not a former netrw window",79)|endif
+  if a:islocal
+   com! -buffer -nargs=+ -complete=file MF	call s:NetrwMarkFiles(1,<f-args>)
+  else
+   com! -buffer -nargs=+ -complete=file MF	call s:NetrwMarkFiles(0,<f-args>)
   endif
+  com! -buffer -nargs=? -complete=file MT	call s:NetrwMarkTarget(<q-args>)
 
-  let @@= ykeep
-"  call Dret("NetrwMakeDir")
+"  call Dret("s:NetrwCommands")
+endfun
+
+" ---------------------------------------------------------------------
+" s:NetrwMarkFiles: apply s:NetrwMarkFile() to named file(s) {{{2
+"                   glob()ing only works with local files
+fun! s:NetrwMarkFiles(islocal,...)
+"  call Dfunc("s:NetrwMarkFiles(islocal=".a:islocal."...) a:0=".a:0)
+  let i = 1
+  while i <= a:0
+   if a:islocal
+    let mffiles= glob(a:{i},0,1)
+   else
+    let mffiles= [a:{i}]
+   endif
+"   call Decho("mffiles".string(mffiles))
+   for mffile in mffiles
+"    call Decho("mffile<".mffile.">")
+    call s:NetrwMarkFile(a:islocal,mffile)
+   endfor
+   let i= i + 1
+  endwhile
+"  call Dret("s:NetrwMarkFiles")
+endfun
+
+" ---------------------------------------------------------------------
+" s:NetrwMarkTarget: {{{2
+fun! s:NetrwMarkTarget(...)
+"  call Dfunc("s:NetrwMarkTarget() a:0=".a:0)
+  if a:0 == 0 || (a:0 == 1 && a:1 == "")
+   let tgt= b:netrw_curdir
+  else
+   let tgt= a:1
+  endif
+"  call Decho("tgt<".tgt.">")
+  let s:netrwmftgt         = tgt
+  let s:netrwmftgt_islocal = tgt !~ '^\a\+://'
+  let curislocal           = b:netrw_curdir !~ '^\a\+://'
+  let svpos                = netrw#SavePosn()
+  call s:NetrwRefresh(curislocal,s:NetrwBrowseChgDir(curislocal,'./'))
+  call netrw#RestorePosn(svpos)
+"  call Dret("s:NetrwMarkTarget")
 endfun
 
 " ---------------------------------------------------------------------
@@ -5324,7 +5846,16 @@
   let ykeep   = @@
   let curbufnr= bufnr("%")
   let curdir  = b:netrw_curdir
-  let trailer = '[@=|\/\*]\=\ze\%(  \|\t\|$\)'
+  if a:fname =~ '^\a'
+   let leader= '\<'
+  else
+   let leader= ''
+  endif
+  if a:fname =~ '\a$'
+   let trailer = '\>[@=|\/\*]\=\ze\%(  \|\t\|$\)'
+  else
+   let trailer = '[@=|\/\*]\=\ze\%(  \|\t\|$\)'
+  endif
 
   if exists("s:netrwmarkfilelist_{curbufnr}")
    " markfile list pre-exists
@@ -5336,7 +5867,7 @@
     " append filename to buffer's markfilelist
 "    call Decho("append filename<".a:fname."> to local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
     call add(s:netrwmarkfilelist_{curbufnr},a:fname)
-    let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|\<'.escape(a:fname,g:netrw_markfileesc."'".g:netrw_markfileesc."'").trailer
+    let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(a:fname,g:netrw_markfileesc).trailer
 
    else
     " remove filename from buffer's markfilelist
@@ -5350,12 +5881,12 @@
      " rebuild match list to display markings correctly
 "     call Decho("rebuild s:netrwmarkfilemtch_".curbufnr)
      let s:netrwmarkfilemtch_{curbufnr}= ""
-     let first                           = 1
+     let first                         = 1
      for fname in s:netrwmarkfilelist_{curbufnr}
       if first
-       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\<'.escape(fname,g:netrw_markfileesc."'".g:netrw_markfileesc."'").trailer
+       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.leader.escape(fname,g:netrw_markfileesc).trailer
       else
-       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|\<'.escape(fname,g:netrw_markfileesc."'".g:netrw_markfileesc."'").trailer
+       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(fname,g:netrw_markfileesc).trailer
       endif
       let first= 0
      endfor
@@ -5373,9 +5904,9 @@
 
    " build initial markfile matching pattern
    if a:fname =~ '/$'
-    let s:netrwmarkfilemtch_{curbufnr}= '\<'.escape(a:fname,g:netrw_markfileesc)
+    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc)
    else
-    let s:netrwmarkfilemtch_{curbufnr}= '\<'.escape(a:fname,g:netrw_markfileesc).trailer
+    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc).trailer
    endif
 "   call Decho("ending s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">")
   endif
@@ -5427,7 +5958,7 @@
 "                            g:netrw_decompress      = { ".gz" : "gunzip" , ".bz2" : "bunzip2" , ".zip" : "unzip" , ".tar" : "tar -xf", ".xz" : "unxz"}
 fun! s:NetrwMarkFileCompress(islocal)
 "  call Dfunc("s:NetrwMarkFileCompress(islocal=".a:islocal.")")
-  let svpos    = netrw#NetrwSavePosn()
+  let svpos    = netrw#SavePosn()
   let curdir   = b:netrw_curdir
   let curbufnr = bufnr("%")
 
@@ -5482,7 +6013,7 @@
 
    call s:NetrwUnmarkList(curbufnr,curdir)
    keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-   keepj call netrw#NetrwRestorePosn(svpos)
+   keepj call netrw#RestorePosn(svpos)
   endif
 "  call Dret("s:NetrwMarkFileCompress")
 endfun
@@ -5522,7 +6053,7 @@
   if      a:islocal &&  s:netrwmftgt_islocal
    " Copy marked files, local directory to local directory
 "   call Decho("copy from local to local")
-   if !executable(g:netrw_localcopycmd) && g:netrw_localcopycmd !~ '\<cmd\s'
+   if !executable(g:netrw_localcopycmd) && g:netrw_localcopycmd !~ '^'.expand("$COMSPEC").'\s'
     call netrw#ErrorMsg(s:ERROR,"g:netrw_localcopycmd<".g:netrw_localcopycmd."> not executable on your system, aborting",91)
 "    call Dfunc("s:NetrwMarkFileMove : g:netrw_localcopycmd<".g:netrw_localcopycmd."> n/a!")
     return
@@ -5596,7 +6127,7 @@
   elseif !a:islocal &&  s:netrwmftgt_islocal
    " Copy marked files, remote directory to local directory
 "   call Decho("copy from remote to local")
-   keepj call netrw#NetrwObtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)
+   keepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)
 
   elseif !a:islocal && !s:netrwmftgt_islocal
    " Copy marked files, remote directory to remote directory
@@ -5617,15 +6148,15 @@
     endif
    endif
    if isdirectory(tmpdir)
-    exe "keepj lcd ".fnameescape(tmpdir)
-    keepj call netrw#NetrwObtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},tmpdir)
+    call s:NetrwLcd(tmpdir)
+    keepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},tmpdir)
     let localfiles= map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),'substitute(v:val,"^.*/","","")')
     keepj call s:NetrwUpload(localfiles,s:netrwmftgt)
     if getcwd() == tmpdir
      for fname in s:netrwmarkfilelist_{bufnr('%')}
       keepj call s:NetrwDelete(fname)
      endfor
-     exe "keepj lcd ".fnameescape(curdir)
+     call s:NetrwLcd(curdir)
      exe "sil !".g:netrw_localrmdir." ".shellescape(tmpdir,1)
      if v:shell_error != 0
       call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localrmdir<".g:netrw_localrmdir."> to something that works",80)
@@ -5633,7 +6164,7 @@
       return
      endif
     else
-     exe "keepj lcd ".fnameescape(curdir)
+     call s:NetrwLcd(curdir)
     endif
    endif
   endif
@@ -5655,7 +6186,7 @@
    keepj call s:NetrwRefreshDir(a:islocal,curdir)
   endif
   if g:netrw_fastbrowse <= 1
-   keepj call s:LocalBrowseShellCmdRefresh()
+   keepj call s:LocalBrowseRefresh()
   endif
   
 "  call Dret("s:NetrwMarkFileCopy 1")
@@ -5679,7 +6210,7 @@
   endif
 "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
 
-  if exists("s:netrwmarkfilelist_{."curbufnr}")
+  if exists("s:netrwmarkfilelist_{".curbufnr."}")
    let cnt    = 0
    let curdir = b:netrw_curdir
    for fname in s:netrwmarkfilelist
@@ -5771,7 +6302,7 @@
 "                     Uses the local marked-file list.
 fun! s:NetrwMarkFileExe(islocal)
 "  call Dfunc("s:NetrwMarkFileExe(islocal=".a:islocal.")")
-  let svpos    = netrw#NetrwSavePosn()
+  let svpos    = netrw#SavePosn()
   let curdir   = b:netrw_curdir
   let curbufnr = bufnr("%")
 
@@ -5829,7 +6360,7 @@
 
    " refresh the listing
    keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-   keepj call netrw#NetrwRestorePosn(svpos)
+   keepj call netrw#RestorePosn(svpos)
   else
    keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
   endif
@@ -5843,7 +6374,7 @@
 "                  Uses the local marked file list.
 fun! s:NetrwMarkHideSfx(islocal)
 "  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
-  let svpos    = netrw#NetrwSavePosn()
+  let svpos    = netrw#SavePosn()
   let curbufnr = bufnr("%")
 
   " s:netrwmarkfilelist_{curbufnr}: the List of marked files
@@ -5886,7 +6417,7 @@
 
    " refresh the listing
    keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-   keepj call netrw#NetrwRestorePosn(svpos)
+   keepj call netrw#RestorePosn(svpos)
   else
    keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
   endif
@@ -5899,7 +6430,7 @@
 "                     Uses the local marked-file list.
 fun! s:NetrwMarkFileVimCmd(islocal)
 "  call Dfunc("s:NetrwMarkFileVimCmd(islocal=".a:islocal.")")
-  let svpos    = netrw#NetrwSavePosn()
+  let svpos    = netrw#SavePosn()
   let curdir   = b:netrw_curdir
   let curbufnr = bufnr("%")
 
@@ -5943,7 +6474,7 @@
 
    " refresh the listing
    keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-   keepj call netrw#NetrwRestorePosn(svpos)
+   keepj call netrw#RestorePosn(svpos)
   else
    keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
   endif
@@ -5957,7 +6488,7 @@
 "                  Uses the local marked file list.
 fun! s:NetrwMarkHideSfx(islocal)
 "  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
-  let svpos    = netrw#NetrwSavePosn()
+  let svpos    = netrw#SavePosn()
   let curbufnr = bufnr("%")
 
   " s:netrwmarkfilelist_{curbufnr}: the List of marked files
@@ -6000,7 +6531,7 @@
 
    " refresh the listing
    keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-   keepj call netrw#NetrwRestorePosn(svpos)
+   keepj call netrw#RestorePosn(svpos)
   else
    keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
   endif
@@ -6013,7 +6544,7 @@
 "                     Uses the global markfilelist
 fun! s:NetrwMarkFileGrep(islocal)
 "  call Dfunc("s:NetrwMarkFileGrep(islocal=".a:islocal.")")
-  let svpos    = netrw#NetrwSavePosn()
+  let svpos    = netrw#SavePosn()
   let curbufnr = bufnr("%")
 
   if exists("s:netrwmarkfilelist")
@@ -6053,7 +6584,7 @@
   echo "(use :cn, :cp to navigate, :Rex to return)"
 
   2match none
-  keepj call netrw#NetrwRestorePosn(svpos)
+  keepj call netrw#RestorePosn(svpos)
 
   if exists("nonisi")
    " original, user-supplied pattern did not begin with a character from isident
@@ -6094,8 +6625,8 @@
   if      a:islocal &&  s:netrwmftgt_islocal
    " move: local -> local
 "   call Decho("move from local to local")
-"   call Decho("(s:NetrwMarkFileMove) local to local move")
-   if !executable(g:netrw_localmovecmd) && g:netrw_localmovecmd !~ '\<cmd\s'
+"   call Decho("local to local move")
+   if !executable(g:netrw_localmovecmd) && g:netrw_localmovecmd !~ '^'.expand("$COMSPEC").'\s'
     call netrw#ErrorMsg(s:ERROR,"g:netrw_localmovecmd<".g:netrw_localmovecmd."> not executable on your system, aborting",90)
 "    call Dfunc("s:NetrwMarkFileMove : g:netrw_localmovecmd<".g:netrw_localmovecmd."> n/a!")
     return
@@ -6189,7 +6720,7 @@
   endif
   if g:netrw_fastbrowse <= 1
 "   call Decho("since g:netrw_fastbrowse=".g:netrw_fastbrowse.", perform shell cmd refresh")
-   keepj call s:LocalBrowseShellCmdRefresh()
+   keepj call s:LocalBrowseRefresh()
   endif
   
 "  call Dret("s:NetrwMarkFileMove")
@@ -6267,8 +6798,8 @@
    let eikeep = &ei
    let areg   = @a
    sil keepj %y a
-   set ei=all ma
-"   call Decho("set ei=all ma")
+   setl ei=all ma
+"   call Decho("setl ei=all ma")
    1split
    keepj call s:NetrwEnew()
    keepj call s:NetrwSafeOptions()
@@ -6276,7 +6807,7 @@
    keepj 2
    let bannercnt= search('^" =====','W')
    exe "sil keepj 1,".bannercnt."d"
-   set bt=nofile
+   setl bt=nofile
    if     g:netrw_liststyle == s:LONGLIST
     sil keepj %s/\s\{2,}\S.*$//e
     call histdel("/",-1)
@@ -6284,7 +6815,7 @@
     sil keepj %s/\s\{2,}/\r/ge
     call histdel("/",-1)
    elseif g:netrw_liststyle == s:TREELIST
-    sil keepj %s/^| //e
+    exe 'sil keepj %s/^'.s:treedepthstring.' //e'
     sil! keepj g/^ .*$/d
     call histdel("/",-1)
     call histdel("/",-1)
@@ -6348,7 +6879,7 @@
 "                     Uses the global markfilelist
 fun! s:NetrwMarkFileTag(islocal)
 "  call Dfunc("s:NetrwMarkFileTag(islocal=".a:islocal.")")
-  let svpos    = netrw#NetrwSavePosn()
+  let svpos    = netrw#SavePosn()
   let curdir   = b:netrw_curdir
   let curbufnr = bufnr("%")
 
@@ -6374,7 +6905,7 @@
     endif
    else
     let cmd   = s:RemoteSystem(g:netrw_ctags." ".netrwmarkfilelist)
-    call netrw#NetrwObtain(a:islocal,"tags")
+    call netrw#Obtain(a:islocal,"tags")
     let curdir= b:netrw_curdir
     1split
     e tags
@@ -6386,7 +6917,7 @@
    endif
    2match none
    call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-   call netrw#NetrwRestorePosn(svpos)
+   call netrw#RestorePosn(svpos)
   endif
 
 "  call Dret("s:NetrwMarkFileTag")
@@ -6400,7 +6931,7 @@
 "                            1=target directory is local
 fun! s:NetrwMarkFileTgt(islocal)
 "  call Dfunc("s:NetrwMarkFileTgt(islocal=".a:islocal.")")
-  let svpos  = netrw#NetrwSavePosn()
+  let svpos  = netrw#SavePosn()
   let curdir = b:netrw_curdir
   let hadtgt = exists("s:netrwmftgt")
   if !exists("w:netrw_bannercnt")
@@ -6414,10 +6945,10 @@
 "    call Decho("cursor in banner region, and target already is <".b:netrw_curdir.">: removing target")
     unlet s:netrwmftgt s:netrwmftgt_islocal
     if g:netrw_fastbrowse <= 1
-     call s:LocalBrowseShellCmdRefresh()
+     call s:LocalBrowseRefresh()
     endif
     call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-    call netrw#NetrwRestorePosn(svpos)
+    call netrw#RestorePosn(svpos)
 "    call Dret("s:NetrwMarkFileTgt : removed target")
     return
    else
@@ -6454,10 +6985,10 @@
   let s:netrwmftgt_islocal= a:islocal
 
   if g:netrw_fastbrowse <= 1
-   call s:LocalBrowseShellCmdRefresh()
+   call s:LocalBrowseRefresh()
   endif
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-  call netrw#NetrwRestorePosn(svpos)
+  call netrw#RestorePosn(svpos)
   if !hadtgt
    sil! keepj norm! j
   endif
@@ -6559,7 +7090,7 @@
 " s:NetrwUnMarkFile: {{{2
 fun! s:NetrwUnMarkFile(islocal)
 "  call Dfunc("s:NetrwUnMarkFile(islocal=".a:islocal.")")
-  let svpos    = netrw#NetrwSavePosn()
+  let svpos    = netrw#SavePosn()
   let curbufnr = bufnr("%")
 
   " unmark marked file list (although I expect s:NetrwUpload()
@@ -6573,7 +7104,7 @@
   endif
 
 "  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-  call netrw#NetrwRestorePosn(svpos)
+  call netrw#RestorePosn(svpos)
 "  call Dret("s:NetrwUnMarkFile")
 endfun
 
@@ -6688,10 +7219,10 @@
   let ykeep= @@
   if exists("s:netrwmarkfilelist_{bufnr('%')}")
    let islocal= s:netrwmarkfilelist_{bufnr('%')}[1] !~ '^\a\+://'
-   call netrw#NetrwObtain(islocal,s:netrwmarkfilelist_{bufnr('%')})
+   call netrw#Obtain(islocal,s:netrwmarkfilelist_{bufnr('%')})
    call s:NetrwUnmarkList(bufnr('%'),b:netrw_curdir)
   else
-   call netrw#NetrwObtain(a:islocal,expand("<cWORD>"))
+   call netrw#Obtain(a:islocal,expand("<cWORD>"))
   endif
   let @@= ykeep
 
@@ -6707,19 +7238,22 @@
 "     choice = 2 : didn't save modified file, opened window
 "     choice = 3 : cancel open
 fun! s:NetrwPrevWinOpen(islocal)
-"  call Dfunc("NetrwPrevWinOpen(islocal=".a:islocal.")")
+"  call Dfunc("s:NetrwPrevWinOpen(islocal=".a:islocal.")")
 
   let ykeep= @@
   " grab a copy of the b:netrw_curdir to pass it along to newly split windows
-  let curdir    = b:netrw_curdir
+  let curdir = b:netrw_curdir
 
   " get last window number and the word currently under the cursor
+  let origwin   = winnr()
   let lastwinnr = winnr("$")
   let curword   = s:NetrwGetWord()
   let choice    = 0
-"  call Decho("lastwinnr=".lastwinnr." curword<".curword.">")
+  let s:treedir = s:NetrwTreeDir()
+  let curdir    = s:treedir
+"  call Decho("winnr($)#".lastwinnr." curword<".curword.">")
 
-  let didsplit  = 0
+  let didsplit = 0
   if lastwinnr == 1
    " if only one window, open a new one first
 "   call Decho("only one window, so open a new one (g:netrw_alto=".g:netrw_alto.")")
@@ -6732,68 +7266,73 @@
 "    call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
     exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
    endif
-   let didsplit  = 1
+   let didsplit = 1
+"   call Decho("did split")
 
   else
    keepj call s:SaveBufVars()
-"   call Decho("wincmd p")
+   let eikeep= &ei
+   setl ei=all
    wincmd p
+"   call Decho("wincmd p  (now in win#".winnr().") curdir<".curdir.">")
+
+   " prevwinnr: the window number of the "prev" window
+   " prevbufnr: the buffer number of the buffer in the "prev" window
+   " bnrcnt   : the qty of windows open on the "prev" buffer
+   let prevwinnr   = winnr()
+   let prevbufnr   = bufnr("%")
+   let prevbufname = bufname("%")
+   let prevmod     = &mod
+   let bnrcnt      = 0
    keepj call s:RestoreBufVars()
-   " if the previous window's buffer has been changed (is modified),
+"   call Decho("after wincmd p: win#".winnr()." win($)#".winnr("$")." origwin#".origwin." &mod=".&mod." bufname(%)<".bufname("%")."> prevbufnr=".prevbufnr)
+
+   " if the previous window's buffer has been changed (ie. its modified flag is set),
    " and it doesn't appear in any other extant window, then ask the
    " user if s/he wants to abandon modifications therein.
-   let bnr    = winbufnr(0)
-   let bnrcnt = 0
-   if &mod
-"    call Decho("detected: prev window's buffer has been modified: bnr=".bnr." winnr#".winnr())
-    let eikeep= &ei
-    set ei=all
-    windo if winbufnr(0) == bnr | let bnrcnt=bnrcnt+1 | endif
-    exe bnr."wincmd p"
-    let &ei= eikeep
-"    call Decho("bnr=".bnr." bnrcnt=".bnrcnt." buftype=".&bt." winnr#".winnr())
-    if bnrcnt == 1
-     let bufname = bufname(winbufnr(winnr()))
-     let choice  = confirm("Save modified file<".bufname.">?","&Yes\n&No\n&Cancel")
-"     call Decho("bufname<".bufname."> choice=".choice." winnr#".winnr())
+   if prevmod
+"    call Decho("detected that prev window's buffer has been modified: prevbufnr=".prevbufnr." winnr()#".winnr())
+    windo if winbufnr(0) == prevbufnr | let bnrcnt=bnrcnt+1 | endif
+"    call Decho("prevbufnr=".prevbufnr." bnrcnt=".bnrcnt." buftype=".&bt." winnr()=".winnr()." prevwinnr#".prevwinnr)
+    exe prevwinnr."wincmd w"
+
+    if bnrcnt == 1 && &hidden == 0
+     " only one copy of the modified buffer in a window, and
+     " hidden not set, so overwriting will lose the modified file.  Ask first...
+     let choice = confirm("Save modified buffer<".prevbufname."> first?","&Yes\n&No\n&Cancel")
+"     call Decho("(NetrwPrevWinOpen) prevbufname<".prevbufname."> choice=".choice." current-winnr#".winnr())
+     let &ei= eikeep
 
      if choice == 1
       " Yes -- write file & then browse
       let v:errmsg= ""
       sil w
       if v:errmsg != ""
-       call netrw#ErrorMsg(s:ERROR,"unable to write <".bufname.">!",30)
-       if didsplit
-       	q
-       else
-       	wincmd p
-       endif
-       let @@= ykeep
-"       call Dret("NetrwPrevWinOpen ".choice." : unable to write <".bufname.">")
+       call netrw#ErrorMsg(s:ERROR,"unable to write <".prevbufname.">!",30)
+       exe origwin."wincmd w"
+       let &ei = eikeep
+       let @@  = ykeep
+"       call Dret("s:NetrwPrevWinOpen ".choice." : unable to write <".prevbufname.">")
        return choice
       endif
 
      elseif choice == 2
       " No -- don't worry about changed file, just browse anyway
-"      call Decho("(NetrwPrevWinOpen) setl nomod")
-      setl nomod
-"      call Decho("(NetrwPrevWinOpen) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
-      keepj call netrw#ErrorMsg(s:WARNING,bufname." changes to ".bufname." abandoned",31)
-      wincmd p
+"      call Decho("don't worry about chgd file, just browse anyway (winnr($)#".winnr("$").")")
+      echomsg "**note** changes to ".prevbufname." abandoned"
 
      else
       " Cancel -- don't do this
-      if didsplit
-       q
-      else
-       wincmd p
-      endif
-      let @@= ykeep
-"      call Dret("NetrwPrevWinOpen ".choice." : cancelled")
+"      call Decho("cancel, don't browse, switch to win#".origwin)
+      exe origwin."wincmd w"
+      let &ei= eikeep
+      let @@ = ykeep
+"      call Dret("s:NetrwPrevWinOpen ".choice." : cancelled")
       return choice
      endif
     endif
    endif
+   let &ei= eikeep
   endif
 
   " restore b:netrw_curdir (window split/enew may have lost it)
@@ -6806,7 +7345,7 @@
    endif
   endif
   let @@= ykeep
-"  call Dret("NetrwPrevWinOpen ".choice)
+"  call Dret("s:NetrwPrevWinOpen ".choice)
   return choice
 endfun
 
@@ -6855,7 +7394,7 @@
 "   call Decho("handle uploading a list of files via scp")
    let curdir= getcwd()
    if a:tgt =~ '^scp:'
-    exe "keepjumps sil lcd ".fnameescape(fromdir)
+    call s:NetrwLcd(fromdir)
     let filelist= deepcopy(s:netrwmarkfilelist_{bufnr('%')})
     let args    = join(map(filelist,"shellescape(v:val, 1)"))
     if exists("g:netrw_port") && g:netrw_port != ""
@@ -6867,7 +7406,7 @@
     let tgt     = substitute(a:tgt,'^scp://[^/]\+/\(.*\)$','\1','')
 "    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".args." ".shellescape(machine.":".tgt,1))
     exe s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".args." ".shellescape(machine.":".tgt,1)
-    exe "keepjumps sil lcd ".fnameescape(curdir)
+    call s:NetrwLcd(curdir)
 
    elseif a:tgt =~ '^ftp:'
     call s:NetrwMethod(a:tgt)
@@ -7029,13 +7568,14 @@
 fun! s:NetrwRefresh(islocal,dirname)
 "  call Dfunc("NetrwRefresh(islocal<".a:islocal.">,dirname=".a:dirname.") hide=".g:netrw_hide." sortdir=".g:netrw_sort_direction)
   " at the current time (Mar 19, 2007) all calls to NetrwRefresh() call NetrwBrowseChgDir() first.
-  " (defunct) NetrwBrowseChgDir() may clear the display; hence a NetrwSavePosn() may not work if its placed here.
-  " (defunct) Also, NetrwBrowseChgDir() now does a NetrwSavePosn() itself.
   setl ma noro
 "  call Decho("setl ma noro")
 "  call Decho("clear buffer<".expand("%")."> with :%d")
   let ykeep      = @@
-  let screenposn = netrw#NetrwSavePosn()
+
+  " save the cursor position before refresh.
+  let screenposn = netrw#SavePosn()
+"  call Decho("win#".winnr().": ".winheight(0)."x".winwidth(0)." curfile<".expand("%").">")
 "  call Decho("clearing buffer prior to refresh")
   sil! keepj %d
   if a:islocal
@@ -7043,7 +7583,9 @@
   else
    keepj call s:NetrwBrowse(a:islocal,a:dirname)
   endif
-  keepj call netrw#NetrwRestorePosn(screenposn)
+
+  " restore position
+  keepj call netrw#RestorePosn(screenposn)
 
   " restore file marks
   if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
@@ -7062,7 +7604,7 @@
 " ---------------------------------------------------------------------
 " s:NetrwRefreshDir: refreshes a directory by name {{{2
 "                    Called by NetrwMarkFileCopy()
-"                    Interfaces to s:NetrwRefresh() and s:LocalBrowseShellCmdRefresh()
+"                    Interfaces to s:NetrwRefresh() and s:LocalBrowseRefresh()
 fun! s:NetrwRefreshDir(islocal,dirname)
 "  call Dfunc("s:NetrwRefreshDir(islocal=".a:islocal." dirname<".a:dirname.">) g:netrw_fastbrowse=".g:netrw_fastbrowse)
   if g:netrw_fastbrowse == 0
@@ -7087,12 +7629,27 @@
 
   elseif g:netrw_fastbrowse <= 1
 "   call Decho("medium-speed mode: refresh local buffers only")
-   keepj call s:LocalBrowseShellCmdRefresh()
+   keepj call s:LocalBrowseRefresh()
   endif
 "  call Dret("s:NetrwRefreshDir")
 endfun
 
 " ---------------------------------------------------------------------
+" s:NetrwSetChgwin: set g:netrw_chgwin; a <cr> will use the specified
+" window number to do its editing in.
+" Supports   [count]C  where the count, if present, is used to specify
+" a window to use for editing via the <cr> mapping.
+fun! s:NetrwSetChgwin()
+"  call Dfunc("s:NetrwSetChgwin() v:count=".v:count)
+  if v:count > 0
+   let g:netrw_chgwin= v:count
+  else
+   let g:netrw_chgwin= winnr()
+  endif
+"  call Dret("s:NetrwSetChgwin")
+endfun
+
+" ---------------------------------------------------------------------
 " s:NetrwSetSort: sets up the sort based on the g:netrw_sort_sequence {{{2
 "          What this function does is to compute a priority for the patterns
 "          in the g:netrw_sort_sequence.  It applies a substitute to any
@@ -7149,7 +7706,7 @@
    let priority = priority + 1
   endwhile
   if exists("starpriority")
-   exe 'sil keepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/'
+   exe 'sil keepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/e'
    keepj call histdel("/",-1)
   endif
 
@@ -7178,7 +7735,7 @@
    " supports choosing a bookmark as a target using a qb-generated list
    let choice= a:choice - 1
    if exists("g:netrw_bookmarklist[".choice."]")
-    call netrw#NetrwMakeTgt(g:netrw_bookmarklist[choice])
+    call netrw#MakeTgt(g:netrw_bookmarklist[choice])
    else
     echomsg "Sorry, bookmark#".a:choice." doesn't exist!"
    endif
@@ -7188,7 +7745,7 @@
    let choice= (a:choice % g:netrw_dirhistmax) + 1
    if exists("g:netrw_dirhist_".choice)
     let histentry = g:netrw_dirhist_{choice}
-    call netrw#NetrwMakeTgt(histentry)
+    call netrw#MakeTgt(histentry)
    else
     echomsg "Sorry, history#".a:choice." not available!"
    endif
@@ -7202,12 +7759,12 @@
 fun! s:NetrwSortStyle(islocal)
 "  call Dfunc("s:NetrwSortStyle(islocal=".a:islocal.") netrw_sort_by<".g:netrw_sort_by.">")
   keepj call s:NetrwSaveWordPosn()
-  let svpos= netrw#NetrwSavePosn()
+  let svpos= netrw#SavePosn()
 
   let g:netrw_sort_by= (g:netrw_sort_by =~ 'n')? 'time' : (g:netrw_sort_by =~ 't')? 'size' : 'name'
   keepj norm! 0
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
-  keepj call netrw#NetrwRestorePosn(svpos)
+  keepj call netrw#RestorePosn(svpos)
 
 "  call Dret("s:NetrwSortStyle : netrw_sort_by<".g:netrw_sort_by.">")
 endfun
@@ -7229,6 +7786,7 @@
   if a:mode == 0
    " remote and o
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
+   if winsz == 0|let winsz= ""|endif
 "   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
    exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
    let s:didsplit= 1
@@ -7249,6 +7807,7 @@
   elseif a:mode == 2
    " remote and v
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
+   if winsz == 0|let winsz= ""|endif
 "   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v")
    exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
    let s:didsplit= 1
@@ -7259,6 +7818,7 @@
   elseif a:mode == 3
    " local and o
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
+   if winsz == 0|let winsz= ""|endif
 "   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
    exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
    let s:didsplit= 1
@@ -7269,18 +7829,35 @@
   elseif a:mode == 4
    " local and t
    let cursorword  = s:NetrwGetWord()
+   let eikeep      = &ei
+   let netrw_winnr = winnr()
+   let netrw_line  = line(".")
+   let netrw_col   = virtcol(".")
+   keepj norm! H0
+   let netrw_hline = line(".")
+   setl ei=all
+   exe "keepj norm! ".netrw_hline."G0z\<CR>"
+   exe "keepj norm! ".netrw_line."G0".netrw_col."\<bar>"
+   let &ei= eikeep
    let netrw_curdir= s:NetrwTreeDir()
 "   call Decho("tabnew")
    tabnew
-   let b:netrw_curdir= netrw_curdir
-   let s:didsplit= 1
+   let b:netrw_curdir = netrw_curdir
+   let s:didsplit     = 1
    keepj call s:RestoreWinVars()
    keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,cursorword))
+   if &ft == "netrw"
+    setl ei=all
+    exe "keepj norm! ".netrw_hline."G0z\<CR>"
+    exe "keepj norm! ".netrw_line."G0".netrw_col."\<bar>"
+    let &ei= eikeep
+   endif
    unlet s:didsplit
 
   elseif a:mode == 5
    " local and v
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
+   if winsz == 0|let winsz= ""|endif
 "   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v")
    exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
    let s:didsplit= 1
@@ -7322,7 +7899,7 @@
      let ebmd= escape(bmd,g:netrw_menu_escape)
      " show bookmarks for goto menu
 "     call Decho("menu: Targets: ".bmd)
-     exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#NetrwMakeTgt('".bmd."')\<cr>"
+     exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#MakeTgt('".bmd."')\<cr>"
      let cnt= cnt + 1
     endfor
    endif
@@ -7337,7 +7914,7 @@
       let histentry  = g:netrw_dirhist_{histcnt}
       let ehistentry = escape(histentry,g:netrw_menu_escape)
 "      call Decho("menu: Targets: ".histentry)
-      exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#NetrwMakeTgt('".histentry."')\<cr>"
+      exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#MakeTgt('".histentry."')\<cr>"
      endif
      let histcnt = histcnt + 1
     endwhile
@@ -7350,60 +7927,57 @@
 " s:NetrwTreeDir: determine tree directory given current cursor position {{{2
 " (full path directory with trailing slash returned)
 fun! s:NetrwTreeDir()
-"  call Dfunc("NetrwTreeDir() curline#".line(".")."<".getline('.')."> b:netrw_curdir<".b:netrw_curdir."> tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">")
+"  call Dfunc("s:NetrwTreeDir() getline(".line(".").")"."<".getline('.')."> b:netrw_curdir<".b:netrw_curdir."> tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft)
 
-  let treedir= b:netrw_curdir
-"  call Decho("(NetrwTreeDir) set initial treedir<".treedir.">")
-  let s:treecurpos= netrw#NetrwSavePosn()
+  if exists("s:treedir")
+   " s:NetrwPrevWinOpen opens a "previous" window -- and thus needs to and does call s:NetrwTreeDir early
+   let treedir= s:treedir
+   unlet s:treedir
+"   call Dret("s:NetrwTreeDir ".treedir)
+   return treedir
+  endif
+  if !exists("b:netrw_curdir") || b:netrw_curdir == ""
+   let b:netrw_curdir= getcwd()
+  endif
+  let treedir = b:netrw_curdir
+"  call Decho("set initial treedir<".treedir.">")
+  let s:treecurpos= netrw#SavePosn()
 
   if w:netrw_liststyle == s:TREELIST
-"   call Decho("(NetrwTreeDir) w:netrw_liststyle is TREELIST:")
-"   call Decho("(NetrwTreeDir) line#".line(".")." getline(.)<".getline('.')."> treecurpos<".string(s:treecurpos).">")
+"   call Decho("w:netrw_liststyle is TREELIST:")
+"   call Decho("line#".line(".")." getline(.)<".getline('.')."> treecurpos<".string(s:treecurpos).">")
 
    " extract tree directory if on a line specifying a subdirectory (ie. ends with "/")
    if getline('.') =~ '/$'
-    let treedir= substitute(getline('.'),'^\%(| \)*\([^|].\{-}\)$','\1','e')
+"    call Decho("extract tree subdirectory from current line")
+    let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
+"    call Decho("treedir<".treedir.">")
    else
+"    call Decho("do not extract tree subdirectory from current line and set treedir to empty")
     let treedir= ""
    endif
-"   call Decho("(NetrwTreeDir) treedir<".treedir.">")
 
    " detect user attempting to close treeroot
-   if getline('.') !~ '|' && getline('.') != '..'
-"    call Decho("user attempted to close treeroot")
+"   call Decho("win#".winnr()." buf#".bufnr("%")."<".bufname("%").">")
+"   call Decho("getline(".line(".").")<".getline('.').'> '.((getline('.') =~ '^'.s:treedepthstring)? '=~' : '!~').' ^'.s:treedepthstring)
+   if getline('.') !~ '^'.s:treedepthstring && getline('.') != '..'
+"    call Decho("user may have attempted to close treeroot")
     " now force a refresh
-"    call Decho("(NetrwTreeDir) clear buffer<".expand("%")."> with :%d")
+"    call Decho("clear buffer<".expand("%")."> with :%d")
     sil! keepj %d
-"    call Dret("NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
+"    call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
     return b:netrw_curdir
+"   else " Decho
+"    call Decho("user did not attempt to close treeroot")
    endif
 
-   " elide all non-depth information
-   let depth = substitute(getline('.'),'^\(\%(| \)*\)[^|].\{-}$','\1','e')
-"   call Decho("(NetrwTreeDir) depth<".depth."> 1st subst (non-depth info removed)")
-
-   " elide first depth
-   let depth = substitute(depth,'^| ','','')
-"   call Decho("(NetrwTreeDir) depth<".depth."> 2nd subst (first depth removed)")
-
-   " construct treedir by searching backwards at correct depth
-"   call Decho("(NetrwTreeDir) constructing treedir<".treedir."> depth<".depth.">")
-   while depth != "" && search('^'.depth.'[^|].\{-}/$','bW')
-    let dirname= substitute(getline('.'),'^\(| \)*','','e')
-    let treedir= dirname.treedir
-    let depth  = substitute(depth,'^| ','','')
-"    call Decho("(NetrwTreeDir) constructing treedir<".treedir.">: dirname<".dirname."> while depth<".depth.">")
-   endwhile
-   if w:netrw_treetop =~ '/$'
-    let treedir= w:netrw_treetop.treedir
-   else
-    let treedir= w:netrw_treetop.'/'.treedir
-   endif
-"   call Decho("(NetrwTreeDir) bufnr(.)=".bufnr("%")." line($)=".line("$")." line(.)=".line("."))
+   let treedir = s:NetrwTreePath(w:netrw_treetop)
   endif
+
+  " sanity maintenance: keep those //s away...
   let treedir= substitute(treedir,'//$','/','')
 
-"  call Dret("NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
+"  call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
   return treedir
 endfun
 
@@ -7440,7 +8014,7 @@
   endif
 
   " display subtrees (if any)
-  let depth= "| ".a:depth
+  let depth= s:treedepthstring.a:depth
 
 "  call Decho("display subtrees with depth<".depth."> and current leaves")
   for entry in w:netrw_treedict[a:dir]
@@ -7457,6 +8031,7 @@
     sil! keepj call setline(line("$")+1,depth.entry)
    endif
   endfor
+
 "  call Dret("NetrwTreeDisplay")
 endfun
 
@@ -7466,7 +8041,8 @@
   if w:netrw_liststyle == s:TREELIST
 "   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
 "   call Decho("curdir<".a:dirname.">")
-"   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exit")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"))
+"   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exist")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"))
+"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
 
    " update the treetop
 "   call Decho("update the treetop")
@@ -7485,7 +8061,7 @@
 
    " update the directory listing for the current directory
 "   call Decho("updating dictionary with ".a:dirname.":[..directory listing..]")
-"   call Decho("bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
+"   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
    exe "sil! keepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d'
    let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
 "   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]))
@@ -7498,9 +8074,19 @@
     let fname= ""
    endif
 "   call Decho("fname<".fname.">")
+"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
 
    " display from treetop on down
    keepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
+"   call Decho("s:NetrwTreeDisplay) setl noma nomod ro")
+
+   " remove any blank line remaining as line#1 (happens in treelisting mode with banner suppressed)
+   while getline(1) =~ '^\s*$' && byte2line(1) > 0
+"    call Decho("deleting blank line")
+    1d
+   endwhile
+
+   exe "setl ".g:netrw_bufsettings
 
 "   call Dret("NetrwTreeListing : bufname<".expand("%").">")
    return
@@ -7508,6 +8094,44 @@
 endfun
 
 " ---------------------------------------------------------------------
+" s:NetrwTreePath: returns path to current file in tree listing {{{2
+"                  Normally, treetop is w:netrw_treetop, but a
+"                  user of the function ( netrw#SetTreetop() )
+"                  wipes that out prior to calling this function
+fun! s:NetrwTreePath(treetop)
+"  call Dfunc("s:NetrwTreePath() line#".line(".")."<".getline(".").">")
+  let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
+"  call Decho("(s:NetrwTreePath) depth<".depth."> 1st subst")
+  let depth = substitute(depth,'^'.s:treedepthstring,'','')
+"  call Decho("(s:NetrwTreePath) depth<".depth."> 2nd subst (first depth removed)")
+  if getline('.') =~ '/$'
+"   call Decho("extract tree directory from current line")
+   let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
+"   call Decho("(s:NetrwTreePath) treedir<".treedir.">")
+  else
+"   call Decho("(s:NetrwTreePath) do not extract tree directory from current line and set treedir to empty")
+   let treedir= ""
+  endif
+  " construct treedir by searching backwards at correct depth
+"  call Decho("(s:NetrwTreePath) construct treedir by searching backwards for correct depth")
+"  call Decho("(s:NetrwTreePath) initial      treedir<".treedir."> depth<".depth.">")
+  while depth != "" && search('^'.depth.'[^'.s:treedepthstring.'].\{-}/$','bW')
+   let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
+   let treedir= dirname.treedir
+   let depth  = substitute(depth,'^'.s:treedepthstring,'','')
+"   call Decho("(s:NetrwTreePath) constructing treedir<".treedir.">: dirname<".dirname."> while depth<".depth.">")
+  endwhile
+  if a:treetop =~ '/$'
+   let treedir= a:treetop.treedir
+  else
+   let treedir= a:treetop.'/'.treedir
+  endif
+  let treedir= substitute(treedir,'//$','/','')
+"  call Dret("s:NetrwTreePath <".treedir.">")
+  return treedir
+endfun
+
+" ---------------------------------------------------------------------
 " s:NetrwWideListing: {{{2
 fun! s:NetrwWideListing()
 
@@ -7544,7 +8168,9 @@
    let newcolstart = w:netrw_bannercnt + fpc
    let newcolend   = newcolstart + fpc - 1
 "   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]")
-   sil! let keepregstar = @*
+   if has("clipboard")
+    sil! let keepregstar = @*
+   endif
    while line("$") >= newcolstart
     if newcolend > line("$") | let newcolend= line("$") | endif
     let newcolqty= newcolend - newcolstart
@@ -7557,13 +8183,15 @@
     exe "sil! keepj ".newcolstart.','.newcolend.'d'
     exe 'sil! keepj '.w:netrw_bannercnt
    endwhile
-   sil! let @*= keepregstar
+   if has("clipboard")
+    sil! let @*= keepregstar
+   endif
    exe "sil! keepj ".w:netrw_bannercnt.',$s/\s\+$//e'
    keepj call histdel("/",-1)
    exe "nmap <buffer> <silent> w	/^\\\\|\\s\\s\\zs\\S/\<cr>"
    exe "nmap <buffer> <silent> b	?^\\\\|\\s\\s\\zs\\S?\<cr>"
 "   call Decho("NetrwWideListing) setl noma nomod ro")
-   setl noma nomod ro
+   exe "setl ".g:netrw_bufsettings
 "   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "   call Dret("NetrwWideListing")
    return
@@ -7582,30 +8210,32 @@
 " s:PerformListing: {{{2
 fun! s:PerformListing(islocal)
 "  call Dfunc("s:PerformListing(islocal=".a:islocal.") bufnr(%)=".bufnr("%")."<".bufname("%").">")
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (enter)")
 
   " set up syntax highlighting {{{3
-"  call Decho("(PerformListing) set up syntax highlighting")
+"  call Decho("set up syntax highlighting")
   if has("syntax")
    if !exists("g:syntax_on") || !g:syntax_on
-"    call Decho("(PerformListing) but g:syntax_on".(exists("g:syntax_on")? "=".g:syntax_on : "<doesn't exist>"))
+"    call Decho("but g:syntax_on".(exists("g:syntax_on")? "=".g:syntax_on : "<doesn't exist>"))
     setl ft=
    elseif &ft != "netrw"
+"    call Decho("setl ft=netrw")
     setl ft=netrw
    endif
   endif
 
   keepj call s:NetrwSafeOptions()
-  set noro ma
-"  call Decho("(PerformListing) setl noro ma bh=".&bh)
+  setl noro ma
+"  call Decho("setl noro ma bh=".&bh)
 
 "  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
-"   call Decho("(PerformListing) (netrw) Processing your browsing request...")
+"   call Decho("(netrw) Processing your browsing request...")
 "  endif								" Decho
 
 "  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
    " force a refresh for tree listings
-"   call Decho("(PerformListing) force refresh for treelisting: clear buffer<".expand("%")."> with :%d")
+"   call Decho("force refresh for treelisting: clear buffer<".expand("%")."> with :%d")
    sil! keepj %d
   endif
 
@@ -7614,7 +8244,7 @@
 
   " Set up the banner {{{3
   if g:netrw_banner
-"   call Decho("(PerformListing) set up banner")
+"   call Decho("set up banner")
    keepj call setline(1,'" ============================================================================')
    keepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
    if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
@@ -7628,6 +8258,7 @@
    keepj 1
    let w:netrw_bannercnt= 1
   endif
+"  call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." win#".winnr())
 
   let sortby= g:netrw_sort_by
   if g:netrw_sort_direction =~ "^r"
@@ -7636,26 +8267,28 @@
 
   " Sorted by... {{{3
   if g:netrw_banner
-"   call Decho("(PerformListing) handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">")
+"   call Decho("handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">")
    if g:netrw_sort_by =~ "^n"
-"   call Decho("(PerformListing) directories will be sorted by name")
+"   call Decho("directories will be sorted by name")
     " sorted by name
     keepj put ='\"   Sorted by      '.sortby
     keepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
     let w:netrw_bannercnt= w:netrw_bannercnt + 2
    else
-"   call Decho("(PerformListing) directories will be sorted by size or time")
+"   call Decho("directories will be sorted by size or time")
     " sorted by size or date
     keepj put ='\"   Sorted by '.sortby
     let w:netrw_bannercnt= w:netrw_bannercnt + 1
    endif
    exe "sil! keepj ".w:netrw_bannercnt
+"  else " Decho
+"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
   endif
 
   " show copy/move target, if any
   if g:netrw_banner
    if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
-"    call Decho("(PerformListing) show copy/move target<".s:netrwmftgt.">")
+"    call Decho("show copy/move target<".s:netrwmftgt.">")
     keepj put =''
     if s:netrwmftgt_islocal
      sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
@@ -7664,14 +8297,14 @@
     endif
     let w:netrw_bannercnt= w:netrw_bannercnt + 1
    else
-"    call Decho("(PerformListing) s:netrwmftgt does not exist, don't make Copy/Move Tgt")
+"    call Decho("s:netrwmftgt does not exist, don't make Copy/Move Tgt")
    endif
    exe "sil! keepj ".w:netrw_bannercnt
   endif
 
   " Hiding...  -or-  Showing... {{{3
   if g:netrw_banner
-"   call Decho("(PerformListing) handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)")
+"   call Decho("handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)")
    if g:netrw_list_hide != "" && g:netrw_hide
     if g:netrw_hide == 1
      keepj put ='\"   Hiding:        '.g:netrw_list_hide
@@ -7681,47 +8314,62 @@
     let w:netrw_bannercnt= w:netrw_bannercnt + 1
    endif
    exe "keepjumps ".w:netrw_bannercnt
-   keepj put ='\"   Quick Help: <F1>:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec'
-   keepj put ='\" ============================================================================'
+
+"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+   let quickhelp   = g:netrw_quickhelp%len(s:QuickHelp)
+"   call Decho("quickhelp   =".quickhelp)
+   keepj put ='\"   Quick Help: <F1>:help  '.s:QuickHelp[quickhelp]
+"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+   keepj put ='\" =============================================================================='
    let w:netrw_bannercnt= w:netrw_bannercnt + 2
+"  else " Decho
+"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
   endif
 
   " bannercnt should index the line just after the banner
   if g:netrw_banner
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
    exe "sil! keepj ".w:netrw_bannercnt
-"   call Decho("(PerformListing) w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"))
+"   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"))
+"  else " Decho
+"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
   endif
 
   " get list of files
-"  call Decho("(PerformListing) Get list of files - islocal=".a:islocal)
+"  call Decho("Get list of files - islocal=".a:islocal)
   if a:islocal
    keepj call s:LocalListing()
   else " remote
-   keepj call s:NetrwRemoteListing()
+   keepj let badresult= s:NetrwRemoteListing()
+   if badresult
+"    call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">")
+"    call Dret("s:PerformListing : error detected by NetrwRemoteListing")
+    return
+   endif
   endif
 
   " manipulate the directory listing (hide, sort) {{{3
   if !exists("w:netrw_bannercnt")
    let w:netrw_bannercnt= 0
   endif
-"  call Decho("(PerformListing) g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)")
+"  call Decho("g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)")
+"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
 
   if !g:netrw_banner || line("$") >= w:netrw_bannercnt
-"   call Decho("(PerformListing) manipulate directory listing (hide)")
-"   call Decho("(PerformListing) g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
+"   call Decho("manipulate directory listing (hide)")
+"   call Decho("g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
    if g:netrw_hide && g:netrw_list_hide != ""
     keepj call s:NetrwListHide()
    endif
    if !g:netrw_banner || line("$") >= w:netrw_bannercnt
-"    call Decho("(PerformListing) manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">")
+"    call Decho("manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">")
 
     if g:netrw_sort_by =~ "^n"
      " sort by name
      keepj call s:NetrwSetSort()
 
      if !g:netrw_banner || w:netrw_bannercnt < line("$")
-"      call Decho("(PerformListing) g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")")
+"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")")
       if g:netrw_sort_direction =~ 'n'
        " normal direction sorting
        exe 'sil keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
@@ -7731,13 +8379,13 @@
       endif
      endif
      " remove priority pattern prefix
-"     call Decho("(PerformListing) remove priority pattern prefix")
+"     call Decho("remove priority pattern prefix")
      exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
      keepj call histdel("/",-1)
 
     elseif a:islocal
      if !g:netrw_banner || w:netrw_bannercnt < line("$")
-"      call Decho("(PerformListing) g:netrw_sort_direction=".g:netrw_sort_direction)
+"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction)
       if g:netrw_sort_direction =~ 'n'
 "       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort')
        exe 'sil! keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
@@ -7751,47 +8399,57 @@
     endif
 
    elseif g:netrw_sort_direction =~ 'r'
-"    call Decho('reverse the sorted listing')
+"    call Decho('(s:PerformListing) reverse the sorted listing')
     if !g:netrw_banner || w:netrw_bannercnt < line('$')
      exe 'sil! keepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
      call histdel("/",-1)
     endif
    endif
   endif
+"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
 
   " convert to wide/tree listing {{{3
-"  call Decho("(PerformListing) modify display if wide/tree listing style")
+"  call Decho("modify display if wide/tree listing style")
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#1)")
   keepj call s:NetrwWideListing()
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#2)")
   keepj call s:NetrwTreeListing(b:netrw_curdir)
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#3)")
 
   if exists("w:netrw_bannercnt") && (line("$") > w:netrw_bannercnt || !g:netrw_banner)
    " place cursor on the top-left corner of the file listing
-"   call Decho("(PerformListing) place cursor on top-left corner of file listing")
+"   call Decho("place cursor on top-left corner of file listing")
    exe 'sil! keepj '.w:netrw_bannercnt
    sil! keepj norm! 0
   endif
 
   " record previous current directory
   let w:netrw_prvdir= b:netrw_curdir
-"  call Decho("(PerformListing) record netrw_prvdir<".w:netrw_prvdir.">")
+"  call Decho("record netrw_prvdir<".w:netrw_prvdir.">")
 
   " save certain window-oriented variables into buffer-oriented variables {{{3
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#4)")
   keepj call s:SetBufWinVars()
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#5)")
   keepj call s:NetrwOptionRestore("w:")
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#6)")
 
   " set display to netrw display settings
-"  call Decho("(PerformListing) set display to netrw display settings (".g:netrw_bufsettings.")")
+"  call Decho("set display to netrw display settings (".g:netrw_bufsettings.")")
   exe "setl ".g:netrw_bufsettings
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#7)")
   if g:netrw_liststyle == s:LONGLIST
-"   call Decho("(PerformListing) exe setl ts=".(g:netrw_maxfilenamelen+1))
+"   call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1))
    exe "setl ts=".(g:netrw_maxfilenamelen+1)
   endif
-  if exists("s:treecurpos")
 
-   keepj call netrw#NetrwRestorePosn(s:treecurpos)
+  if exists("s:treecurpos")
+"   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#8)")
+   keepj call netrw#RestorePosn(s:treecurpos)
    unlet s:treecurpos
   endif
 
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (return)")
 "  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")
 endfun
 
@@ -7810,79 +8468,226 @@
    if !exists("s:netrw_users_ls")
     let s:netrw_users_ls= &laststatus
    endif
-
-   " set up User9 highlighting as needed
-   let keepa= @a
-   redir @a
-   try
-    hi User9
-   catch /^Vim\%((\a\+)\)\=:E411/
-    if &bg == "dark"
-     hi User9 ctermfg=yellow ctermbg=blue guifg=yellow guibg=blue
-    else
-     hi User9 ctermbg=yellow ctermfg=blue guibg=yellow guifg=blue
-    endif
-   endtry
-   redir END
-   let @a= keepa
+
+   " set up User9 highlighting as needed
+   let keepa= @a
+   redir @a
+   try
+    hi User9
+   catch /^Vim\%((\a\+)\)\=:E411/
+    if &bg == "dark"
+     hi User9 ctermfg=yellow ctermbg=blue guifg=yellow guibg=blue
+    else
+     hi User9 ctermbg=yellow ctermfg=blue guibg=yellow guifg=blue
+    endif
+   endtry
+   redir END
+   let @a= keepa
+  endif
+
+  " set up status line (may use User9 highlighting)
+  " insure that windows have a statusline
+  " make sure statusline is displayed
+  let &stl=a:statline
+  setl laststatus=2
+"  call Decho("stl=".&stl)
+  redraw
+
+"  call Dret("SetupNetrwStatusLine : stl=".&stl)
+endfun
+
+" ---------------------------------------------------------------------
+"  Remote Directory Browsing Support:    {{{1
+" ===========================================
+
+" ---------------------------------------------------------------------
+" s:NetrwRemoteFtpCmd: unfortunately, not all ftp servers honor options for ls {{{2
+"  This function assumes that a long listing will be received.  Size, time,
+"  and reverse sorts will be requested of the server but not otherwise
+"  enforced here.
+fun! s:NetrwRemoteFtpCmd(path,listcmd)
+"  call Dfunc("NetrwRemoteFtpCmd(path<".a:path."> listcmd<".a:listcmd.">) w:netrw_method=".(exists("w:netrw_method")? w:netrw_method : (exists("b:netrw_method")? b:netrw_method : "???")))
+"  call Decho("line($)=".line("$")." w:netrw_bannercnt=".w:netrw_bannercnt)
+  " sanity check: {{{3
+  if !exists("w:netrw_method")
+   if exists("b:netrw_method")
+    let w:netrw_method= b:netrw_method
+   else
+    call netrw#ErrorMsg(2,"(s:NetrwRemoteFtpCmd) internal netrw error",93)
+"    call Dret("NetrwRemoteFtpCmd")
+    return
+   endif
+  endif
+
+  " WinXX ftp uses unix style input, so set ff to unix	" {{{3
+  let ffkeep= &ff
+  setl ma ff=unix noro
+"  call Decho("setl ma ff=unix noro")
+
+  " clear off any older non-banner lines	" {{{3
+  " note that w:netrw_bannercnt indexes the line after the banner
+"  call Decho('exe sil! keepjumps '.w:netrw_bannercnt.",$d  (clear off old non-banner lines)")
+  exe "sil! keepjumps ".w:netrw_bannercnt.",$d"
+
+  ".........................................
+  if w:netrw_method == 2 || w:netrw_method == 5	" {{{3
+   " ftp + <.netrc>:  Method #2
+   if a:path != ""
+    keepj put ='cd \"'.a:path.'\"'
+   endif
+   if exists("g:netrw_ftpextracmd")
+    keepj put =g:netrw_ftpextracmd
+"    call Decho("filter input: ".getline('.'))
+   endif
+   keepj call setline(line("$")+1,a:listcmd)
+"   exe "keepjumps ".w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
+   if exists("g:netrw_port") && g:netrw_port != ""
+"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
+    exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
+   else
+"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
+    exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
+   endif
+
+  ".........................................
+  elseif w:netrw_method == 3	" {{{3
+   " ftp + machine,id,passwd,filename:  Method #3
+    setl ff=unix
+    if exists("g:netrw_port") && g:netrw_port != ""
+     keepj put ='open '.g:netrw_machine.' '.g:netrw_port
+    else
+     keepj put ='open '.g:netrw_machine
+    endif
+
+    " handle userid and password
+    let host= substitute(g:netrw_machine,'\..*$','','')
+"    call Decho("host<".host.">")
+    if exists("s:netrw_hup") && exists("s:netrw_hup[host]")
+     call NetUserPass("ftp:".host)
+    endif
+    if exists("g:netrw_uid") && g:netrw_uid != ""
+     if exists("g:netrw_ftp") && g:netrw_ftp == 1
+      keepj put =g:netrw_uid
+      if exists("s:netrw_passwd") && s:netrw_passwd != ""
+       keepj put ='\"'.s:netrw_passwd.'\"'
+      endif
+     elseif exists("s:netrw_passwd")
+      keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
+     endif
+    endif
+
+   if a:path != ""
+    keepj put ='cd \"'.a:path.'\"'
+   endif
+   if exists("g:netrw_ftpextracmd")
+    keepj put =g:netrw_ftpextracmd
+"    call Decho("filter input: ".getline('.'))
+   endif
+   keepj call setline(line("$")+1,a:listcmd)
+
+   " perform ftp:
+   " -i       : turns off interactive prompting from ftp
+   " -n  unix : DON'T use <.netrc>, even though it exists
+   " -n  win32: quit being obnoxious about password
+   if exists("w:netrw_bannercnt")
+"    exe w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
+"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
+    exe s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
+"   else " Decho
+"    call Decho("WARNING: w:netrw_bannercnt doesn't exist!")
+"    g/^./call Decho("SKIPPING ftp#".line(".").": ".getline(".")) " COMBAK
+   endif
+
+  ".........................................
+  elseif w:netrw_method == 9	" {{{3
+   " sftp username@machine: Method #9
+   " s:netrw_sftp_cmd
+   setl ff=unix
+
+   " restore settings
+   let &ff= ffkeep
+"   call Dret("NetrwRemoteFtpCmd")
+   return
+
+  ".........................................
+  else	" {{{3
+   keepj call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . bufname("%") . ">",23)
+  endif
+
+  " cleanup for Windows " {{{3
+  if has("win32") || has("win95") || has("win64") || has("win16")
+   sil! keepj %s/\r$//e
+   keepj call histdel("/",-1)
+  endif
+  if a:listcmd == "dir"
+   " infer directory/link based on the file permission string
+   sil! keepj g/d\%([-r][-w][-x]\)\{3}/keepj s@$@/@e
+   sil! keepj g/l\%([-r][-w][-x]\)\{3}/keepj s/$/@/e
+   keepj call histdel("/",-1)
+   keepj call histdel("/",-1)
+   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
+    exe "sil! keepj ".w:netrw_bannercnt.',$s/^\%(\S\+\s\+\)\{8}//e'
+    keepj call histdel("/",-1)
+   endif
   endif
 
-  " set up status line (may use User9 highlighting)
-  " insure that windows have a statusline
-  " make sure statusline is displayed
-  let &stl=a:statline
-  setl laststatus=2
-"  call Decho("stl=".&stl)
-  redraw
+  " ftp's listing doesn't seem to include ./ or ../ " {{{3
+  if !search('^\.\/$\|\s\.\/$','wn')
+   exe 'keepj '.w:netrw_bannercnt
+   keepj put ='./'
+  endif
+  if !search('^\.\.\/$\|\s\.\.\/$','wn')
+   exe 'keepj '.w:netrw_bannercnt
+   keepj put ='../'
+  endif
 
-"  call Dret("SetupNetrwStatusLine : stl=".&stl)
+  " restore settings " {{{3
+  let &ff= ffkeep
+"  call Dret("NetrwRemoteFtpCmd")
 endfun
 
 " ---------------------------------------------------------------------
-"  Remote Directory Browsing Support:    {{{1
-" ===========================================
-
-" ---------------------------------------------------------------------
 " s:NetrwRemoteListing: {{{2
 fun! s:NetrwRemoteListing()
 "  call Dfunc("s:NetrwRemoteListing() b:netrw_curdir<".b:netrw_curdir.">)")
 
+  if !exists("w:netrw_bannercnt") && exists("s:bannercnt")
+   let w:netrw_bannercnt= s:bannercnt
+  endif
+  if !exists("w:netrw_bannercnt") && exists("b:bannercnt")
+   let w:netrw_bannercnt= s:bannercnt
+  endif
+
   call s:RemotePathAnalysis(b:netrw_curdir)
-"  call Decho("b:netrw_method#".(exists("b:netrw_method")? b:netrw_method : 'n/a'))
-"  call Decho("g:netrw_list_cmd<".(exists("g:netrw_list_cmd")? g:netrw_list_cmd : 'n/a').">")
-"  call Decho("ssh  is ".(executable("ssh")?  "" : "not ")."executable")
-"  call Decho("ftp  is ".(executable("ftp")?  "" : "not ")."executable")
-"  call Decho("sftp is ".(executable("sftp")? "" : "not ")."executable")
 
   " sanity check:
   if exists("b:netrw_method") && b:netrw_method =~ '[235]'
-   " b:netrw_method = 2: ftp+.netrc
-   " b:netrw_method = 3: ftp+machine,id,p/w,filename (ie. no .netrc)
-   " b:netrw_method = 5: wget (http)
-"   call Decho("b:netrw_method=".b:netrw_method." (for ".s:method.")")
+"   call Decho("b:netrw_method=".b:netrw_method)
    if !executable("ftp")
+"    call Decho("ftp is not executable")
     if !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ftp",18)
     endif
     call s:NetrwOptionRestore("w:")
-"    call Dret("s:NetrwRemoteListing")
-    return
+"    call Dret("s:NetrwRemoteListing -1")
+    return -1
    endif
 
-  elseif s:method == "scp" && (!exists("g:netrw_list_cmd") || g:netrw_list_cmd == '')
-"   call Decho("g:netrw_list_cmd<".(exists("g:netrw_list_cmd")? g:netrw_list_cmd : 'n/a').">")
+  elseif !exists("g:netrw_list_cmd") || g:netrw_list_cmd == ''
+"   call Decho("g:netrw_list_cmd<",(exists("g:netrw_list_cmd")? 'n/a' : "-empty-").">")
    if !exists("g:netrw_quiet")
-    if !exists("g:netrw_list_cmd") || g:netrw_list_cmd == ""
-     keepj call netrw#ErrorMsg(s:ERROR,"neither ssh nor ftp"." is executable on your system",47)
+    if g:netrw_list_cmd == ""
+     keepj call netrw#ErrorMsg(s:ERROR,"your g:netrw_list_cmd is empty; perhaps ".g:netrw_ssh_cmd." is not executable on your system",47)
     else
      keepj call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ".g:netrw_list_cmd,19)
     endif
    endif
 
    keepj call s:NetrwOptionRestore("w:")
-"   call Dret("s:NetrwRemoteListing")
-   return
+"   call Dret("s:NetrwRemoteListing -1")
+   return -1
   endif  " (remote handling sanity check)
+"  call Decho("passed remote listing sanity checks")
 
   if exists("b:netrw_method")
 "   call Decho("setting w:netrw_method to b:netrw_method<".b:netrw_method.">")
@@ -7892,8 +8697,8 @@
   if s:method == "ftp"
    " use ftp to get remote file listing {{{3
 "   call Decho("use ftp to get remote file listing")
-   let s:method = "ftp"
-   let listcmd  = g:netrw_ftp_list_cmd
+   let s:method  = "ftp"
+   let listcmd = g:netrw_ftp_list_cmd
    if g:netrw_sort_by =~ '^t'
     let listcmd= g:netrw_ftp_timelist_cmd
    elseif g:netrw_sort_by =~ '^s'
@@ -7903,6 +8708,20 @@
    call s:NetrwRemoteFtpCmd(s:path,listcmd)
 "   exe "sil! keepalt keepj ".w:netrw_bannercnt.',$g/^./call Decho("raw listing: ".getline("."))'
 
+   " report on missing file or directory messages
+   if search('[Nn]o such file or directory\|Failed to change directory')
+    let mesg= getline(".")
+    if exists("w:netrw_bannercnt")
+     setl ma
+     exe w:netrw_bannercnt.",$d"
+     setl noma
+    endif
+    keepj call s:NetrwOptionRestore("w:")
+    call netrw#ErrorMsg(s:WARNING,mesg,96)
+"    call Dret("s:NetrwRemoteListing : -1")
+    return -1
+   endif
+
    if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
     " shorten the listing
 "    call Decho("generate short listing")
@@ -7944,7 +8763,7 @@
     endif
    endif
 
-  else
+   else
    " use ssh to get remote file listing {{{3
 "   call Decho("use ssh to get remote file listing: s:path<".s:path.">")
    let listcmd= s:MakeSshCmd(g:netrw_list_cmd)
@@ -7975,8 +8794,8 @@
    endif
 
    " cleanup
-   if g:netrw_ftp_browse_reject != ""
-"    call Decho("(cleanup) exe sil! g/".g:netrw_ssh_browse_reject."/keepjumps d")
+   if g:netrw_ssh_browse_reject != ""
+"    call Decho("cleanup: exe sil! g/".g:netrw_ssh_browse_reject."/keepjumps d")
     exe "sil! g/".g:netrw_ssh_browse_reject."/keepj d"
     keepj call histdel("/",-1)
    endif
@@ -8023,7 +8842,9 @@
 "  if exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$") " Decho
 "   exe "keepj ".w:netrw_bannercnt.',$g/^./call Decho("listing: ".getline("."))'
 "  endif " Decho
-"  call Dret("s:NetrwRemoteListing")
+
+"  call Dret("s:NetrwRemoteListing 0")
+  return 0
 endfun
 
 " ---------------------------------------------------------------------
@@ -8031,7 +8852,7 @@
 fun! s:NetrwRemoteRm(usrhost,path) range
 "  call Dfunc("s:NetrwRemoteRm(usrhost<".a:usrhost."> path<".a:path.">) virtcol=".virtcol("."))
 "  call Decho("firstline=".a:firstline." lastline=".a:lastline)
-  let svpos= netrw#NetrwSavePosn()
+  let svpos= netrw#SavePosn()
 
   let all= 0
   if exists("s:netrwmarkfilelist_{bufnr('%')}")
@@ -8070,7 +8891,7 @@
   " refresh the (remote) directory listing
 "  call Decho("refresh remote directory listing")
   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
-  keepj call netrw#NetrwRestorePosn(svpos)
+  keepj call netrw#RestorePosn(svpos)
 
 "  call Dret("s:NetrwRemoteRm")
 endfun
@@ -8190,141 +9011,12 @@
 endfun
 
 " ---------------------------------------------------------------------
-" s:NetrwRemoteFtpCmd: unfortunately, not all ftp servers honor options for ls {{{2
-"  This function assumes that a long listing will be received.  Size, time,
-"  and reverse sorts will be requested of the server but not otherwise
-"  enforced here.
-fun! s:NetrwRemoteFtpCmd(path,listcmd)
-"  call Dfunc("NetrwRemoteFtpCmd(path<".a:path."> listcmd<".a:listcmd.">) w:netrw_method=".(exists("w:netrw_method")? w:netrw_method : (exists("b:netrw_method")? b:netrw_method : "???")))
-"  call Decho("line($)=".line("$")." w:netrw_bannercnt=".w:netrw_bannercnt)
-  if !exists("w:netrw_method")
-   if exists("b:netrw_method")
-    let w:netrw_method= b:netrw_method
-   else
-    call netrw#ErrorMsg(2,"(s:NetrwRemoteFtpCmd) internal netrw error",93)
-"    call Dret("NetrwRemoteFtpCmd")
-    return
-   endif
-  endif
-
-  " because WinXX ftp uses unix style input
-  let ffkeep= &ff
-  setl ma ff=unix noro
-"  call Decho("setl ma ff=unix noro")
-
-  " clear off any older non-banner lines
-  " note that w:netrw_bannercnt indexes the line after the banner
-"  call Decho('exe sil! keepjumps '.w:netrw_bannercnt.",$d  (clear off old non-banner lines)")
-  exe "sil! keepjumps ".w:netrw_bannercnt.",$d"
-
-  ".........................................
-  if w:netrw_method == 2 || w:netrw_method == 5
-   " ftp + <.netrc>:  Method #2
-   if a:path != ""
-    keepj put ='cd \"'.a:path.'\"'
-   endif
-   if exists("g:netrw_ftpextracmd")
-    keepj put =g:netrw_ftpextracmd
-"    call Decho("filter input: ".getline('.'))
-   endif
-   keepj call setline(line("$")+1,a:listcmd)
-"   exe "keepjumps ".w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
-   if exists("g:netrw_port") && g:netrw_port != ""
-"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
-    exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
-   else
-"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
-    exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
-   endif
-
-   ".........................................
-  elseif w:netrw_method == 3
-   " ftp + machine,id,passwd,filename:  Method #3
-    setl ff=unix
-    if exists("g:netrw_port") && g:netrw_port != ""
-     keepj put ='open '.g:netrw_machine.' '.g:netrw_port
-    else
-     keepj put ='open '.g:netrw_machine
-    endif
-
-    " handle userid and password
-    let host= substitute(g:netrw_machine,'\..*$','','')
-"    call Decho("host<".host.">")
-    if exists("s:netrw_hup") && exists("s:netrw_hup[host]")
-     call NetUserPass("ftp:".host)
-    endif
-    if exists("g:netrw_uid") && g:netrw_uid != ""
-     if exists("g:netrw_ftp") && g:netrw_ftp == 1
-      keepj put =g:netrw_uid
-      if exists("s:netrw_passwd") && s:netrw_passwd != ""
-       keepj put ='\"'.s:netrw_passwd.'\"'
-      endif
-     elseif exists("s:netrw_passwd")
-      keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
-     endif
-    endif
-
-   if a:path != ""
-    keepj put ='cd \"'.a:path.'\"'
-   endif
-   if exists("g:netrw_ftpextracmd")
-    keepj put =g:netrw_ftpextracmd
-"    call Decho("filter input: ".getline('.'))
-   endif
-   keepj call setline(line("$")+1,a:listcmd)
-
-    " perform ftp:
-    " -i       : turns off interactive prompting from ftp
-    " -n  unix : DON'T use <.netrc>, even though it exists
-    " -n  win32: quit being obnoxious about password
-"    exe w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
-"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
-    exe s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
-
-   ".........................................
-  else
-   keepj call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",23)
-  endif
-
-  " cleanup for Windows
-  if has("win32") || has("win95") || has("win64") || has("win16")
-   sil! keepj %s/\r$//e
-   keepj call histdel("/",-1)
-  endif
-  if a:listcmd == "dir"
-   " infer directory/link based on the file permission string
-   sil! keepj g/d\%([-r][-w][-x]\)\{3}/keepj s@$@/@
-   sil! keepj g/l\%([-r][-w][-x]\)\{3}/keepj s/$/@/
-   keepj call histdel("/",-1)
-   keepj call histdel("/",-1)
-   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
-    exe "sil! keepj ".w:netrw_bannercnt.',$s/^\%(\S\+\s\+\)\{8}//e'
-    keepj call histdel("/",-1)
-   endif
-  endif
-
-  " ftp's listing doesn't seem to include ./ or ../
-  if !search('^\.\/$\|\s\.\/$','wn')
-   exe 'keepj '.w:netrw_bannercnt
-   keepj put ='./'
-  endif
-  if !search('^\.\.\/$\|\s\.\.\/$','wn')
-   exe 'keepj '.w:netrw_bannercnt
-   keepj put ='../'
-  endif
-
-  " restore settings
-  let &ff= ffkeep
-"  call Dret("NetrwRemoteFtpCmd")
-endfun
-
-" ---------------------------------------------------------------------
 " s:NetrwRemoteRename: rename a remote file or directory {{{2
 fun! s:NetrwRemoteRename(usrhost,path) range
 "  call Dfunc("NetrwRemoteRename(usrhost<".a:usrhost."> path<".a:path.">)")
 
   " preparation for removing multiple files/directories
-  let svpos      = netrw#NetrwSavePosn()
+  let svpos      = netrw#SavePosn()
   let ctr        = a:firstline
   let rename_cmd = s:MakeSshCmd(g:netrw_rename_cmd)
 
@@ -8387,7 +9079,7 @@
 
   " refresh the directory
   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
-  keepj call netrw#NetrwRestorePosn(svpos)
+  keepj call netrw#RestorePosn(svpos)
 
 "  call Dret("NetrwRemoteRename")
 endfun
@@ -8439,9 +9131,9 @@
   exe 'sil! bdelete '.plainfname
   exe 'keepalt file! '.plainfname
   keepj 1d
-"  call Decho("(FileUrlRead) setl nomod")
+"  call Decho("setl nomod")
   setl nomod
-"  call Decho("(FileUrlRead) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "  call Dret("netrw#FileUrlRead")
   exe "sil doau BufReadPost ".fname2396e
 endfun
@@ -8456,107 +9148,263 @@
   " The &ft == "netrw" test was installed because the BufEnter event
   " would hit when re-entering netrw windows, creating unexpected
   " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
-"  call Decho("(LocalBrowseCheck) isdir<".a:dirname.">=".isdirectory(a:dirname).((exists("s:treeforceredraw")? " treeforceredraw" : "")))
-"  call Dredir("LocalBrowseCheck","ls!")|redraw!|sleep 3
+"  call Dfunc("netrw#LocalBrowseCheck(dirname<".a:dirname.">")
+"  call Decho("isdir<".a:dirname.">=".isdirectory(a:dirname).((exists("s:treeforceredraw")? " treeforceredraw" : "")))
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
+"  call Dredir("ls!","ls!")
+
   let ykeep= @@
   if isdirectory(a:dirname)
-"   call Decho("(LocalBrowseCheck) is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse)
-   let svposn= netrw#NetrwSavePosn()
+"   call Decho("is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse)
+   let svposn= netrw#SavePosn()
    if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
+"    call Decho("case 1 : ft=".&ft)
     sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
-    keepalt call netrw#NetrwRestorePosn(svposn)
+    keepalt call netrw#RestorePosn(svposn)
+
    elseif &ft == "netrw" && line("$") == 1
+"    call Decho("case 2 (ftnetrw && line($)1)")
     sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
-    keepalt call netrw#NetrwRestorePosn(svposn)
+    keepalt call netrw#RestorePosn(svposn)
+
    elseif exists("s:treeforceredraw")
+"    call Decho("case 3 (treeforceredraw)")
     unlet s:treeforceredraw
     sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
-    keepalt call netrw#NetrwRestorePosn(svposn)
+    keepalt call netrw#RestorePosn(svposn)
+   endif
+
+"   call Dret("netrw#LocalBrowseCheck")
+   return
+  endif
+
+  " following code wipes out currently unused netrw buffers
+  "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
+  "   AND IF the listing style is not a tree listing
+  if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
+"   call Decho("wiping out currently unused netrw buffers")
+   let ibuf    = 1
+   let buflast = bufnr("$")
+   while ibuf <= buflast
+    if bufwinnr(ibuf) == -1 && isdirectory(bufname(ibuf))
+     exe "sil! keepalt ".ibuf."bw!"
+    endif
+    let ibuf= ibuf + 1
+   endwhile
+  endif
+  let @@= ykeep
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
+  " not a directory, ignore it
+"  call Dret("netrw#LocalBrowseCheck : not a directory, ignoring it; dirname<".a:dirname.">")
+endfun
+
+" ---------------------------------------------------------------------
+" s:LocalBrowseRefresh: this function is called after a user has {{{2
+" performed any shell command.  The idea is to cause all local-browsing
+" buffers to be refreshed after a user has executed some shell command,
+" on the chance that s/he removed/created a file/directory with it.
+fun! s:LocalBrowseRefresh()
+"  call Dfunc("s:LocalBrowseRefresh() tabpagenr($)=".tabpagenr("$"))
+"  call Decho("s:netrw_browselist =".(exists("s:netrw_browselist")?  string(s:netrw_browselist)  : '<n/a>'))
+"  call Decho("w:netrw_bannercnt  =".(exists("w:netrw_bannercnt")?   string(w:netrw_bannercnt)   : '<n/a>'))
+
+  " determine which buffers currently reside in a tab
+  if !exists("s:netrw_browselist")
+"   call Dret("s:LocalBrowseRefresh : browselist is empty")
+   return
+  endif
+  if !exists("w:netrw_bannercnt")
+"   call Dret("s:LocalBrowseRefresh : don't refresh when focus not on netrw window")
+   return
+  endif
+  if exists("s:netrw_events") && s:netrw_events == 1
+   " s:LocalFastBrowser gets called (indirectly) from a
+   let s:netrw_events= 2
+"   call Dret("s:LocalBrowseRefresh : avoid initial double refresh")
+   return
+  endif
+  let itab       = 1
+  let buftablist = []
+  let ykeep      = @@
+  while itab <= tabpagenr("$")
+   let buftablist = buftablist + tabpagebuflist()
+   let itab       = itab + 1
+   tabn
+  endwhile
+"  call Decho("buftablist".string(buftablist))
+"  call Decho("s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">")
+  "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
+  "   | refresh any netrw window
+  "   | wipe out any non-displaying netrw buffer
+  let curwin = winnr()
+  let ibl    = 0
+  for ibuf in s:netrw_browselist
+"   call Decho("bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf))
+   if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
+    " wipe out any non-displaying netrw buffer
+"    call Decho("wiping  buf#".ibuf,"<".bufname(ibuf).">")
+    exe "sil! bd ".fnameescape(ibuf)
+    call remove(s:netrw_browselist,ibl)
+"    call Decho("browselist=".string(s:netrw_browselist))
+    continue
+   elseif index(tabpagebuflist(),ibuf) != -1
+    " refresh any netrw buffer
+"    call Decho("refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf))
+    exe bufwinnr(ibuf)."wincmd w"
+    if getline(".") =~ 'Quick Help'
+     " decrement g:netrw_quickhelp to prevent refresh from changing g:netrw_quickhelp
+     " (counteracts s:NetrwBrowseChgDir()'s incrementing)
+     let g:netrw_quickhelp= g:netrw_quickhelp - 1
+    endif
+"    call Decho("#3: quickhelp=".g:netrw_quickhelp)
+    keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
    endif
+   let ibl= ibl + 1
+  endfor
+  exe curwin."wincmd w"
+  let @@= ykeep
+
+"  call Dret("s:LocalBrowseRefresh")
+endfun
+
+" ---------------------------------------------------------------------
+" s:LocalFastBrowser: handles setting up/taking down fast browsing for the local browser {{{2
+"
+"     g:netrw_    Directory Is
+"     fastbrowse  Local  Remote   
+"  slow   0         D      D      D=Deleting a buffer implies it will not be re-used (slow)
+"  med    1         D      H      H=Hiding a buffer implies it may be re-used        (fast)
+"  fast   2         H      H      
+"
+"  Deleting a buffer means that it will be re-loaded when examined, hence "slow".
+"  Hiding   a buffer means that it will be re-used   when examined, hence "fast".
+"                       (re-using a buffer may not be as accurate)
+"
+"  s:netrw_events : doesn't exist, s:LocalFastBrowser() will install autocmds whena med or fast browsing
+"                   =1: autocmds installed, but ignore next FocusGained event to avoid initial double-refresh of listing.
+"                       BufEnter may be first event, then a FocusGained event.  Ignore the first FocusGained event.
+"                       If :Explore used: it sets s:netrw_events to 2, so no FocusGained events are ignored.
+"                   =2: autocmds installed (doesn't ignore any FocusGained events)
+fun! s:LocalFastBrowser()
+"  call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse)
+"  call Decho("s:netrw_events        ".(exists("s:netrw_events")? "exists"    : 'n/a'))
+"  call Decho("autocmd: ShellCmdPost ".(exists("#ShellCmdPost")?  "installed" : "not installed"))
+"  call Decho("autocmd: FocusGained  ".(exists("#FocusGained")?   "installed" : "not installed"))
+
+  " initialize browselist, a list of buffer numbers that the local browser has used
+  if !exists("s:netrw_browselist")
+"   call Decho("initialize s:netrw_browselist")
+   let s:netrw_browselist= []
   endif
-  " following code wipes out currently unused netrw buffers
-  "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
-  "   AND IF the listing style is not a tree listing
-  if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
-   let ibuf    = 1
-   let buflast = bufnr("$")
-   while ibuf <= buflast
-    if bufwinnr(ibuf) == -1 && isdirectory(bufname(ibuf))
-     exe "sil! keepalt ".ibuf."bw!"
+
+  " append current buffer to fastbrowse list
+  if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
+"   call Decho("appendng current buffer to browselist")
+   call add(s:netrw_browselist,bufnr("%"))
+"   call Decho("browselist=".string(s:netrw_browselist))
+  endif
+
+  " enable autocmd events to handle refreshing/removing local browser buffers
+  "    If local browse buffer is currently showing: refresh it
+  "    If local browse buffer is currently hidden : wipe it
+  "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
+  "                      =1 : medium speed, re-use directory listing for remote only
+  "                      =2 : fast   speed, always re-use directory listing when possible
+  if g:netrw_fastbrowse <= 1 && !exists("#ShellCmdPost") && !exists("s:netrw_events")
+   let s:netrw_events= 1
+   augroup AuNetrwEvent
+    au!
+    if (has("win32") || has("win95") || has("win64") || has("win16"))
+"     call Decho("installing autocmd: ShellCmdPost")
+     au ShellCmdPost			*	call s:LocalBrowseRefresh()
+    else
+"     call Decho("installing autocmds: ShellCmdPost FocusGained")
+     au ShellCmdPost,FocusGained	*	call s:LocalBrowseRefresh()
     endif
-    let ibuf= ibuf + 1
-   endwhile
+   augroup END
+
+  " user must have changed fastbrowse to its fast setting, so remove
+  " the associated autocmd events
+  elseif g:netrw_fastbrowse > 1 && exists("#ShellCmdPost") && exists("s:netrw_events")
+"   call Decho("remove AuNetrwEvent autcmd group")
+   unlet s:netrw_events
+   augroup AuNetrwEvent
+    au!
+   augroup END
+   augroup! AuNetrwEvent
   endif
-  let @@= ykeep
-  " not a directory, ignore it
+
+"  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")
 endfun
 
 " ---------------------------------------------------------------------
 "  s:LocalListing: does the job of "ls" for local directories {{{2
 fun! s:LocalListing()
 "  call Dfunc("s:LocalListing()")
-"  call Decho("(LocalListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
-"  call Decho("(LocalListing) tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
+"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
 
-"  if exists("b:netrw_curdir") |call Decho('(LocalListing) b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("(LocalListing) b:netrw_curdir doesn't exist") |endif
-"  if exists("g:netrw_sort_by")|call Decho('(LocalListing) g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("(LocalListing) g:netrw_sort_by doesn't exist")|endif
+"  if exists("b:netrw_curdir") |call Decho('b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("b:netrw_curdir doesn't exist") |endif
+"  if exists("g:netrw_sort_by")|call Decho('g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("g:netrw_sort_by doesn't exist")|endif
+"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
 
   " get the list of files contained in the current directory
   let dirname    = b:netrw_curdir
-  let dirnamelen = s:Strlen(b:netrw_curdir)
+  let dirnamelen = strlen(b:netrw_curdir)
   let filelist   = glob(s:ComposePath(dirname,"*"),0,1)
   let filelist   = filelist + glob(s:ComposePath(dirname,".*"),0,1)
-"  call Decho("(LocalListing) filelist=".filelist)
+"  call Decho("filelist=".filelist)
 
   if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
-"   call Decho("(LocalListing) filelist=".string(filelist))
+"   call Decho("filelist=".string(filelist))
   elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
     " include ../ in the glob() entry if its missing
-"   call Decho("(LocalListing) forcibly including on \"..\"")
+"   call Decho("forcibly including on \"..\"")
    let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
-"   call Decho("(LocalListing) filelist=".string(filelist))
+"   call Decho("filelist=".string(filelist))
   endif
 
-"  call Decho("(LocalListing) (before while) dirname<".dirname.">")
-"  call Decho("(LocalListing) (before while) dirnamelen<".dirnamelen.">")
-"  call Decho("(LocalListing) (before while) filelist=".string(filelist))
+"  call Decho("before while: dirname<".dirname.">")
+"  call Decho("before while: dirnamelen<".dirnamelen.">")
+"  call Decho("before while: filelist=".string(filelist))
 
   if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
    let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
    let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
-"   call Decho("(LocalListing) dynamic_maxfilenamelen: filenames             =".string(filelistcopy))
-"   call Decho("(LocalListing) dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen)
+"   call Decho("dynamic_maxfilenamelen: filenames             =".string(filelistcopy))
+"   call Decho("dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen)
   endif
+"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
 
   for filename in filelist
-"   call Decho("(LocalListing)  ")
-"   call Decho("(LocalListing) (while) filename<".filename.">")
+"   call Decho(" ")
+"   call Decho("for filename in filelist: filename<".filename.">")
 
    if getftype(filename) == "link"
     " indicate a symbolic link
-"    call Decho("(LocalListing) indicate <".filename."> is a symbolic link with trailing @")
+"    call Decho("indicate <".filename."> is a symbolic link with trailing @")
     let pfile= filename."@"
 
    elseif getftype(filename) == "socket"
     " indicate a socket
-"    call Decho("(LocalListing) indicate <".filename."> is a socket with trailing =")
+"    call Decho("indicate <".filename."> is a socket with trailing =")
     let pfile= filename."="
 
    elseif getftype(filename) == "fifo"
     " indicate a fifo
-"    call Decho("(LocalListing) indicate <".filename."> is a fifo with trailing |")
+"    call Decho("indicate <".filename."> is a fifo with trailing |")
     let pfile= filename."|"
 
    elseif isdirectory(filename)
     " indicate a directory
-"    call Decho("(LocalListing) indicate <".filename."> is a directory with trailing /")
+"    call Decho("indicate <".filename."> is a directory with trailing /")
     let pfile= filename."/"
 
    elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(filename)
     if (has("win32") || has("win95") || has("win64") || has("win16"))
      if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
       " indicate an executable
-"      call Decho("(LocalListing) indicate <".filename."> is executable with trailing *")
+"      call Decho("indicate <".filename."> is executable with trailing *")
       let pfile= filename."*"
      else
       " normal file
@@ -8564,7 +9412,7 @@
      endif
     elseif executable(filename)
      " indicate an executable
-"     call Decho("(LocalListing) indicate <".filename."> is executable with trailing *")
+"     call Decho("indicate <".filename."> is executable with trailing *")
      let pfile= filename."*"
     else
      " normal file
@@ -8575,45 +9423,45 @@
     " normal file
     let pfile= filename
    endif
-"   call Decho("(LocalListing) pfile<".pfile."> (after *@/ appending)")
+"   call Decho("pfile<".pfile."> (after *@/ appending)")
 
    if pfile =~ '//$'
     let pfile= substitute(pfile,'//$','/','e')
-"    call Decho("(LocalListing) change // to /: pfile<".pfile.">")
+"    call Decho("change // to /: pfile<".pfile.">")
    endif
    let pfile= strpart(pfile,dirnamelen)
    let pfile= substitute(pfile,'^[/\\]','','e')
-"   call Decho("(LocalListing) filename<".filename.">")
-"   call Decho("(LocalListing) pfile   <".pfile.">")
+"   call Decho("filename<".filename.">")
+"   call Decho("pfile   <".pfile.">")
 
    if w:netrw_liststyle == s:LONGLIST
     let sz   = getfsize(filename)
     let fsz  = strpart("               ",1,15-strlen(sz)).sz
     let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
-"    call Decho("(LocalListing) sz=".sz." fsz=".fsz)
+"    call Decho("sz=".sz." fsz=".fsz)
    endif
 
    if     g:netrw_sort_by =~ "^t"
     " sort by time (handles time up to 1 quintillion seconds, US)
-"    call Decho("(LocalListing) getftime(".filename.")=".getftime(filename))
+"    call Decho("getftime(".filename.")=".getftime(filename))
     let t  = getftime(filename)
     let ft = strpart("000000000000000000",1,18-strlen(t)).t
-"    call Decho("(LocalListing) exe keepjumps put ='".ft.'/'.filename."'")
+"    call Decho("exe keepjumps put ='".ft.'/'.filename."'")
     let ftpfile= ft.'/'.pfile
     sil! keepj put=ftpfile
 
    elseif g:netrw_sort_by =~ "^s"
     " sort by size (handles file sizes up to 1 quintillion bytes, US)
-"    call Decho("(LocalListing) getfsize(".filename.")=".getfsize(filename))
+"    call Decho("getfsize(".filename.")=".getfsize(filename))
     let sz   = getfsize(filename)
     let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
-"    call Decho("(LocalListing) exe keepj put ='".fsz.'/'.filename."'")
+"    call Decho("exe keepj put ='".fsz.'/'.filename."'")
     let fszpfile= fsz.'/'.pfile
     sil! keepj put =fszpfile
 
    else
     " sort by name
-"    call Decho("(LocalListing) exe keepjumps put ='".pfile."'")
+"    call Decho("exe keepjumps put ='".pfile."'")
     sil! keepj put=pfile
    endif
   endfor
@@ -8622,138 +9470,13 @@
   sil! keepj g/^$/d
   sil! keepj %s/\r$//e
   call histdel("/",-1)
-"  call Decho("(LocalListing) exe setl ts=".(g:netrw_maxfilenamelen+1))
+"  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1))
   exe "setl ts=".(g:netrw_maxfilenamelen+1)
 
 "  call Dret("s:LocalListing")
 endfun
 
 " ---------------------------------------------------------------------
-" s:LocalBrowseShellCmdRefresh: this function is called after a user has {{{2
-" performed any shell command.  The idea is to cause all local-browsing
-" buffers to be refreshed after a user has executed some shell command,
-" on the chance that s/he removed/created a file/directory with it.
-fun! s:LocalBrowseShellCmdRefresh()
-"  call Dfunc("LocalBrowseShellCmdRefresh() browselist=".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "empty")." ".tabpagenr("$")." tabs")
-  " determine which buffers currently reside in a tab
-  if !exists("s:netrw_browselist")
-"   call Dret("LocalBrowseShellCmdRefresh : browselist is empty")
-   return
-  endif
-  if !exists("w:netrw_bannercnt")
-"   call Dret("LocalBrowseShellCmdRefresh : don't refresh when focus not on netrw window")
-   return
-  endif
-  if exists("s:locbrowseshellcmd")
-   if s:locbrowseshellcmd
-    let s:locbrowseshellcmd= 0
-"    call Dret("LocalBrowseShellCmdRefresh : NetrwBrowse itself caused the refresh")
-    return
-   endif
-   let s:locbrowseshellcmd= 0
-  endif
-  let itab       = 1
-  let buftablist = []
-  let ykeep      = @@
-  while itab <= tabpagenr("$")
-   let buftablist = buftablist + tabpagebuflist()
-   let itab       = itab + 1
-   tabn
-  endwhile
-"  call Decho("(LocalBrowseShellCmdRefresh) buftablist".string(buftablist))
-"  call Decho("(LocalBrowseShellCmdRefresh) s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">")
-  "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
-  "   | refresh any netrw window
-  "   | wipe out any non-displaying netrw buffer
-  let curwin = winnr()
-  let ibl    = 0
-  for ibuf in s:netrw_browselist
-"   call Decho("(LocalBrowseShellCmdRefresh) bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf))
-   if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
-    " wipe out any non-displaying netrw buffer
-"    call Decho("(LocalBrowseShellCmdRefresh) wiping  buf#".ibuf,"<".bufname(ibuf).">")
-    exe "sil! bd ".fnameescape(ibuf)
-    call remove(s:netrw_browselist,ibl)
-"    call Decho("(LocalBrowseShellCmdRefresh) browselist=".string(s:netrw_browselist))
-    continue
-   elseif index(tabpagebuflist(),ibuf) != -1
-    " refresh any netrw buffer
-"    call Decho("(LocalBrowseShellCmdRefresh) refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf))
-    exe bufwinnr(ibuf)."wincmd w"
-    keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
-   endif
-   let ibl= ibl + 1
-  endfor
-  exe curwin."wincmd w"
-  let @@= ykeep
-
-"  call Dret("LocalBrowseShellCmdRefresh")
-endfun
-
-" ---------------------------------------------------------------------
-" s:LocalFastBrowser: handles setting up/taking down fast browsing for the local browser {{{2
-"
-"     g:netrw_    Directory Is
-"     fastbrowse  Local  Remote   
-"  slow   0         D      D      D=Deleting a buffer implies it will not be re-used (slow)
-"  med    1         D      H      H=Hiding a buffer implies it may be re-used        (fast)
-"  fast   2         H      H      
-"
-"  Deleting a buffer means that it will be re-loaded when examined, hence "slow".
-"  Hiding   a buffer means that it will be re-used   when examined, hence "fast".
-"           (re-using a buffer may not be as accurate)
-fun! s:LocalFastBrowser()
-"    call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse."  s:netrw_browser_shellcmd ".(exists("s:netrw_browser_shellcmd")? "exists" : "does not exist"))
-
-  " initialize browselist, a list of buffer numbers that the local browser has used
-  if !exists("s:netrw_browselist")
-"   call Decho("(LocalFastBrowser) initialize s:netrw_browselist")
-   let s:netrw_browselist= []
-  endif
-
-  " append current buffer to fastbrowse list
-  if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
-"   call Decho("(LocalFastBrowser) appendng current buffer to browselist")
-   call add(s:netrw_browselist,bufnr("%"))
-"   call Decho("(LocalFastBrowser) browselist=".string(s:netrw_browselist))
-  endif
-
-  " enable autocmd events to handle refreshing/removing local browser buffers
-  "    If local browse buffer is currently showing: refresh it
-  "    If local browse buffer is currently hidden : wipe it
-  "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
-  "                      =1 : medium speed, re-use directory listing for remote only
-  "                      =2 : fast   speed, always re-use directory listing when possible
-  if !exists("s:netrw_browser_shellcmd") && g:netrw_fastbrowse <= 1
-"   call Decho("(LocalFastBrowser) setting up local-browser shell command refresh")
-   let s:netrw_browser_shellcmd= 1
-   augroup AuNetrwShellCmd
-    au!
-    if (has("win32") || has("win95") || has("win64") || has("win16"))
-"     call Decho("(LocalFastBrowser) autocmd: ShellCmdPost * call s:LocalBrowseShellCmdRefresh()")
-     au ShellCmdPost			*	call s:LocalBrowseShellCmdRefresh()
-    else
-     au ShellCmdPost,FocusGained	*	call s:LocalBrowseShellCmdRefresh()
-"     call Decho("(LocalFastBrowser) autocmd: ShellCmdPost,FocusGained * call s:LocalBrowseShellCmdRefresh()")
-    endif
-   augroup END
-  endif
-
-  " user must have changed fastbrowse to its fast setting, so remove
-  " the associated autocmd events
-  if g:netrw_fastbrowse > 1 && exists("s:netrw_browser_shellcmd")
-"   call Decho("(LocalFastBrowser) remove AuNetrwShellCmd autcmd group")
-   unlet s:netrw_browser_shellcmd
-   augroup AuNetrwShellCmd
-    au!
-   augroup END
-   augroup! AuNetrwShellCmd
-  endif
-
-"  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")
-endfun
-
-" ---------------------------------------------------------------------
 " s:NetrwLocalExecute: uses system() to execute command under cursor ("X" command support) {{{2
 fun! s:NetrwLocalExecute(cmd)
 "  call Dfunc("s:NetrwLocalExecute(cmd<".a:cmd.">)")
@@ -8769,7 +9492,7 @@
   let optargs= input(":!".a:cmd,"","file")
 "  call Decho("optargs<".optargs.">")
   let result= system(a:cmd.optargs)
-"  call Decho(result)
+"  call Decho("result)
 
   " strip any ansi escape sequences off
   let result = substitute(result,"\e\\[[0-9;]*m","","g")
@@ -8789,7 +9512,7 @@
   " preparation for removing multiple files/directories
   let ykeep = @@
   let ctr   = a:firstline
-  let svpos = netrw#NetrwSavePosn()
+  let svpos = netrw#SavePosn()
 
   " rename files given by the markfilelist
   if exists("s:netrwmarkfilelist_{bufnr('%')}")
@@ -8848,7 +9571,7 @@
   " refresh the directory
 "  call Decho("refresh the directory listing")
   keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
-  keepj call netrw#NetrwRestorePosn(svpos)
+  keepj call netrw#RestorePosn(svpos)
   let @@= ykeep
 
 "  call Dret("NetrwLocalRename")
@@ -8864,7 +9587,7 @@
   let ykeep = @@
   let ret   = 0
   let all   = 0
-  let svpos = netrw#NetrwSavePosn()
+  let svpos = netrw#SavePosn()
 
   if exists("s:netrwmarkfilelist_{bufnr('%')}")
    " remove all marked files
@@ -8911,7 +9634,7 @@
 "  call Decho("bufname<".bufname("%").">")
   if bufname("%") != "NetrwMessage"
    keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
-   keepj call netrw#NetrwRestorePosn(svpos)
+   keepj call netrw#RestorePosn(svpos)
   endif
   let @@= ykeep
 
@@ -9007,31 +9730,26 @@
 " Support Functions: {{{1
 
 " ---------------------------------------------------------------------
-" netrw#WinPath: tries to insure that the path is windows-acceptable, whether cygwin is used or not {{{2
-fun! netrw#WinPath(path)
-"  call Dfunc("netrw#WinPath(path<".a:path.">)")
-  if (!g:netrw_cygwin || &shell !~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$') && (has("win32") || has("win95") || has("win64") || has("win16"))
-   " remove cygdrive prefix, if present
-   let path = substitute(a:path,'/cygdrive/\(.\)','\1:','')
-   " remove trailing slash (Win95)
-   let path = substitute(path, '\(\\\|/\)$', '', 'g')
-   " remove escaped spaces
-   let path = substitute(path, '\ ', ' ', 'g')
-   " convert slashes to backslashes
-   let path = substitute(path, '/', '\', 'g')
-  else
-   let path= a:path
-  endif
-"  call Dret("netrw#WinPath <".path.">")
-  return path
+" netrw#Access: intended to provide access to variable values for netrw's test suite {{{2
+"   0: marked file list of current buffer
+"   1: marked file target
+fun! netrw#Access(ilist)
+  if     a:ilist == 0
+   if exists("s:netrwmarkfilelist_".bufnr('%'))
+    return s:netrwmarkfilelist_{bufnr('%')}
+   else
+    return "no-list-buf#".bufnr('%')
+   endif
+  elseif a:ilist == 1
+   return s:netrwmftgt
 endfun
 
-" ---------------------------------------------------------------------
-" netrw#NetrwRestorePosn: restores the cursor and file position as saved by NetrwSavePosn() {{{2
-fun! netrw#NetrwRestorePosn(...)
-"  call Dfunc("netrw#NetrwRestorePosn() a:0=".a:0." winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : -1)." line=".(exists("w:netrw_line")? w:netrw_line : -1)." col=".(exists("w:netrw_col")? w:netrw_col : -1)." hline=".(exists("w:netrw_hline")? w:netrw_hline : -1))
+" ------------------------------------------------------------------------
+" netrw#RestorePosn: restores the cursor and file position as saved by NetrwSavePosn() {{{2
+fun! netrw#RestorePosn(...)
+"  call Dfunc("netrw#RestorePosn() a:0=".a:0." winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : -1)." line=".(exists("w:netrw_line")? w:netrw_line : -1)." col=".(exists("w:netrw_col")? w:netrw_col : -1)." hline=".(exists("w:netrw_hline")? w:netrw_hline : -1))
   let eikeep= &ei
-  set ei=all
+  setl ei=all
   if expand("%") == "NetrwMessage"
    if exists("s:winBeforeErr")
     exe s:winBeforeErr."wincmd w"
@@ -9041,10 +9759,22 @@
   if a:0 > 0
    exe "keepj ".a:1
   endif
+"  call Decho("a:1             = ".((a:0 > 0)?              a:1       : 'n/a'))
+"  call Decho("liststyle       = ".(exists("liststyle")?    liststyle : 'n/a'). " w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
+  if exists("liststyle") && exists("w:netrw_liststyle") && liststyle != w:netrw_liststyle
+   let usesrch= 1
+  else
+   let usesrch= 0
+  endif
+
+"  call Decho("winh            = ".(exists("w:netrw_winh")?    w:netrw_winh    : -1))
+"  call Decho("winw            = ".(exists("w:netrw_winw")?    w:netrw_winw    : -1))
+"  call Decho("cur    winheight=".winheight(0)." winwidth=".winwidth(0))
+"  call Decho("w:netrw_winfile = ".(exists("w:netrw_winfile")? w:netrw_winfile : 'n/a'))
 
   " restore window
   if exists("w:netrw_winnr")
-"   call Decho("(NetrwRestorePosn) restore window: exe sil! ".w:netrw_winnr."wincmd w")
+"   call Decho("restore window: exe sil! ".w:netrw_winnr."wincmd w")
    exe "sil! ".w:netrw_winnr."wincmd w"
   endif
   if v:shell_error == 0
@@ -9055,64 +9785,111 @@
 
   " restore top-of-screen line
   if exists("w:netrw_hline")
-"   call Decho("(NetrwRestorePosn) restore topofscreen: exe keepj norm! ".w:netrw_hline."G0z")
+"   call Decho("restore topofscreen: exe keepj norm! ".w:netrw_hline."G0z")
    exe "keepj norm! ".w:netrw_hline."G0z\<CR>"
   endif
 
   " restore position
-  if exists("w:netrw_line") && exists("w:netrw_col")
-"   call Decho("(NetrwRestorePosn) restore posn: exe keepj norm! ".w:netrw_line."G0".w:netrw_col."|")
+  " when the window's height x width has changed, the line,col is no longer useful
+  if w:netrw_winh == winheight(0) && w:netrw_winw == winwidth(0) && exists("w:netrw_line") && exists("w:netrw_col") && !usesrch
+"   call Decho("using posn: exe keepj norm! ".w:netrw_line."G0".w:netrw_col."|")
    exe "keepj norm! ".w:netrw_line."G0".w:netrw_col."\<bar>"
+
+  elseif exists("w:netrw_winfile")
+   if !search('\<'.escape(w:netrw_winfile,g:netrw_fname_escape),'cw')
+    if exists("w:netrw_bannercnt")
+"     call Decho("using bannercnt: win#".winnr()." ".winheight(0)."x".winwidth(0)." w:netrw_winfile<".w:netrw_winfile.">")
+     exe "keepj ".w:netrw_bannercnt
+     norm! 0
+    else
+     " go to upper left corner
+"     call Decho("goto ulc: win#".winnr()." ".winheight(0)."x".winwidth(0)." w:netrw_winfile<".w:netrw_winfile.">")
+     keepj 1
+     norm! 0
+    endif
+   else
+"    call Decho("used search: w:netrw_winfile<".w:netrw_winfile.">")
+   endif
+
+  else
+"   call Decho("goto ulc: win#".winnr()." ".winheight(0)."x".winwidth(0))
+   keepj 1
+   norm! 0
   endif
 
   let &ei= eikeep
-"  call Dret("netrw#NetrwRestorePosn : line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
+"  call Dret("netrw#RestorePosn : line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
+endfun
+
+" ---------------------------------------------------------------------
+"  netrw#RFC2396: converts %xx into characters {{{2
+fun! netrw#RFC2396(fname)
+"  call Dfunc("netrw#RFC2396(fname<".a:fname.">)")
+  let fname = escape(substitute(a:fname,'%\(\x\x\)','\=nr2char("0x".submatch(1))','ge')," \t")
+"  call Dret("netrw#RFC2396 ".fname)
+  return fname
 endfun
 
 " ---------------------------------------------------------------------
-" netrw#NetrwSavePosn: saves position of cursor on screen {{{2
-fun! netrw#NetrwSavePosn()
-"  call Dfunc("netrw#NetrwSavePosn() line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
+" netrw#SavePosn: saves position of cursor on screen {{{2
+fun! netrw#SavePosn()
+"  call Dfunc("netrw#SavePosn() line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
   " Save current line and column
   let w:netrw_winnr= winnr()
   let w:netrw_line = line(".")
   let w:netrw_col  = virtcol(".")
-"  call Decho("(NetrwSavePosn) currently, win#".w:netrw_winnr." line#".w:netrw_line." col#".w:netrw_col)
+"  call Decho("currently, win#".w:netrw_winnr." line#".w:netrw_line." col#".w:netrw_col)
+
+  " save filename under cursor
+"  call Decho("line#".line(".")." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a'))
+  if exists("w:netrw_bannercnt") && line(".") >= w:netrw_bannercnt && &ft == "netrw"
+   let winfile = "|let w:netrw_winfile='".s:NetrwGetWord()."'"
+  else
+   let winfile= ""
+  endif
+"  call Decho("winfile<".winfile.">")
+  if exists("w:netrw_liststyle")
+   let liststyle = "|let liststyle=".w:netrw_liststyle
+  else
+   let liststyle= ""
+  endif
+"  call Decho("liststyle=".liststyle)
 
   " Save top-of-screen line
   keepj norm! H0
   let w:netrw_hline= line(".")
 
+  " save up alternate position information
+  " use this when window height x width has changed
+  let w:netrw_winh = winheight(0)
+  let w:netrw_winw = winwidth(0)
+
   " set up string holding position parameters
-  let ret          = "let w:netrw_winnr=".w:netrw_winnr."|let w:netrw_line=".w:netrw_line."|let w:netrw_col=".w:netrw_col."|let w:netrw_hline=".w:netrw_hline
+  let ret          = "let w:netrw_winnr=".w:netrw_winnr."|let w:netrw_line=".w:netrw_line."|let w:netrw_col=".w:netrw_col."|let w:netrw_hline=".w:netrw_hline."|let w:netrw_winh=".w:netrw_winh."|let w:netrw_winw=".w:netrw_winw.liststyle.winfile
 
-  keepj call netrw#NetrwRestorePosn()
-"  call Dret("netrw#NetrwSavePosn : winnr=".w:netrw_winnr." line=".w:netrw_line." col=".w:netrw_col." hline=".w:netrw_hline)
+  keepj call netrw#RestorePosn()
+"  call Dret("netrw#SavePosn : winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : "n/a")." line=".(exists("w:netrw_line")? w:netrw_line : "n/a")." col=".(exists("w:netrw_col")? w:netrw_col : "n/a")." hline=".(exists("w:netrw_hline")? w:netrw_hline : "n/a"))
   return ret
 endfun
 
 " ---------------------------------------------------------------------
-" netrw#NetrwAccess: intended to provide access to variable values for netrw's test suite {{{2
-"   0: marked file list of current buffer
-"   1: marked file target
-fun! netrw#NetrwAccess(ilist)
-  if     a:ilist == 0
-   if exists("s:netrwmarkfilelist_".bufnr('%'))
-    return s:netrwmarkfilelist_{bufnr('%')}
-   else
-    return "no-list-buf#".bufnr('%')
-   endif
-  elseif a:ilist == 1
-   return s:netrwmftgt
-endfun
-
-" ------------------------------------------------------------------------
-"  netrw#RFC2396: converts %xx into characters {{{2
-fun! netrw#RFC2396(fname)
-"  call Dfunc("netrw#RFC2396(fname<".a:fname.">)")
-  let fname = escape(substitute(a:fname,'%\(\x\x\)','\=nr2char("0x".submatch(1))','ge')," \t")
-"  call Dret("netrw#RFC2396 ".fname)
-  return fname
+" netrw#WinPath: tries to insure that the path is windows-acceptable, whether cygwin is used or not {{{2
+fun! netrw#WinPath(path)
+"  call Dfunc("netrw#WinPath(path<".a:path.">)")
+  if (!g:netrw_cygwin || &shell !~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$') && (has("win32") || has("win95") || has("win64") || has("win16"))
+   " remove cygdrive prefix, if present
+   let path = substitute(a:path,g:netrw_cygdrive.'/\(.\)','\1:','')
+   " remove trailing slash (Win95)
+   let path = substitute(path, '\(\\\|/\)$', '', 'g')
+   " remove escaped spaces
+   let path = substitute(path, '\ ', ' ', 'g')
+   " convert slashes to backslashes
+   let path = substitute(path, '/', '\', 'g')
+  else
+   let path= a:path
+  endif
+"  call Dret("netrw#WinPath <".path.">")
+  return path
 endfun
 
 " ---------------------------------------------------------------------
@@ -9179,7 +9956,7 @@
 "  call Dfunc("s:FileReadable(fname<".a:fname.">)")
 
   if g:netrw_cygwin
-   let ret= filereadable(substitute(a:fname,'/cygdrive/\(.\)','\1:/',''))
+   let ret= filereadable(substitute(a:fname,g:netrw_cygdrive.'/\(.\)','\1:/',''))
   else
    let ret= filereadable(a:fname)
   endif
@@ -9205,7 +9982,7 @@
 
    " sanity check -- does the temporary file's directory exist?
    if !isdirectory(substitute(tmpfile,'[^/]\+$','','e'))
-"    call Decho("(GetTempfile) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"    call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
     keepj call netrw#ErrorMsg(s:ERROR,"your <".substitute(tmpfile,'[^/]\+$','','e')."> directory is missing!",2)
 "    call Dret("s:GetTempfile getcwd<".getcwd().">")
     return ""
@@ -9217,7 +9994,7 @@
 
    " o/s dependencies
    if g:netrw_cygwin != 0
-    let tmpfile = substitute(tmpfile,'^\(\a\):','/cygdrive/\1','e')
+    let tmpfile = substitute(tmpfile,'^\(\a\):',g:netrw_cygdrive.'/\1','e')
    elseif has("win32") || has("win95") || has("win64") || has("win16")
     if !exists("+shellslash") || !&ssl
      let tmpfile = substitute(tmpfile,'/','\','g')
@@ -9253,7 +10030,7 @@
    endif
   endif
 
-"  call Decho("(GetTempFile) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
 "  call Dret("s:GetTempfile <".tmpfile.">")
   return tmpfile
 endfun
@@ -9263,7 +10040,11 @@
 "               a correct command for use with a system() call
 fun! s:MakeSshCmd(sshcmd)
 "  call Dfunc("s:MakeSshCmd(sshcmd<".a:sshcmd.">) user<".s:user."> machine<".s:machine.">")
-  let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user.s:machine,'')
+  if s:user == ""
+   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:machine,'')
+  else
+   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user."@".s:machine,'')
+  endif
   if exists("g:netrw_port") && g:netrw_port != ""
    let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.g:netrw_port,'')
   elseif exists("s:port") && s:port != ""
@@ -9342,7 +10123,7 @@
    let &l:cursorcolumn = s:netrw_usercuc
    if w:netrw_liststyle == s:WIDELIST
 "    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)")
-    set cursorline
+    setl cursorline
    else
 "    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)")
     let &l:cursorline   = s:netrw_usercul
@@ -9361,7 +10142,7 @@
 " ---------------------------------------------------------------------
 " s:RestoreCursorline: restores cursorline/cursorcolumn to original user settings {{{2
 fun! s:RestoreCursorline()
-"  call Dfunc("s:RestoreCursorline() currently, cul=".&l:cursorline." cuc=".&l:cursorcolumn." win#".winnr()." buf#".bufnr("%")." mod=".&mod)
+"  call Dfunc("s:RestoreCursorline() currently, cul=".&l:cursorline." cuc=".&l:cursorcolumn." win#".winnr()." buf#".bufnr("%"))
   if exists("s:netrw_usercul")
    let &l:cursorline   = s:netrw_usercul
   endif
@@ -9430,9 +10211,9 @@
   keepj call s:NetrwOptionRestore("w:")
 "  call Decho("generate a buffer with keepjumps keepalt enew!")
   let netrw_keepdiff= &l:diff
-  keepj keepalt enew!
+  noswapfile keepj keepalt enew!
   let &l:diff= netrw_keepdiff
-"  call Decho("bufnr($)=".bufnr("$"))
+"  call Decho("bufnr($)=".bufnr("$")." winnr($)=".winnr("$"))
   keepj call s:NetrwOptionSave("w:")
 
   " copy function-local-variables to buffer variable equivalents
@@ -9459,7 +10240,7 @@
    if b:netrw_curdir =~ '/$'
     if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
      file NetrwTreeListing
-     set bt=nowrite noswf bh=hide
+     setl bt=nowrite noswf bh=hide
      nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
      nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
     else
@@ -9468,7 +10249,7 @@
    endif
   endif
 
-"  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh)
+"  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))
 endfun
 
 " ---------------------------------------------------------------------
@@ -9499,6 +10280,43 @@
 "  call Dret("s:NetrwInsureWinVars win#".winnr())
 endfun
 
+" ---------------------------------------------------------------------
+" s:NetrwLcd: handles changing the (local) directory {{{2
+fun! s:NetrwLcd(newdir)
+"  call Dfunc("s:NetrwLcd(newdir<".a:newdir.">)")
+
+  try
+   exe 'keepj sil lcd '.fnameescape(a:newdir)
+  catch /^Vim\%((\a\+)\)\=:E344/
+     " Vim's lcd fails with E344 when attempting to go above the 'root' of a Windows share.
+     " Therefore, detect if a Windows share is present, and if E344 occurs, just settle at
+     " 'root' (ie. '\').  The share name may start with either backslashes ('\\Foo') or 
+     " forward slashes ('//Foo'), depending on whether backslashes have been converted to
+     " forward slashes by earlier code; so check for both.
+     if (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
+       if a:newdir =~ '^\\\\\w\+' || a:newdir =~ '^//\w\+'
+         let dirname = '\'
+	 exe 'keepj sil lcd '.fnameescape(dirname)
+       endif
+     endif
+  catch /^Vim\%((\a\+)\)\=:E472/
+   call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".a:newdir."> (permissions?)",61)
+   if exists("w:netrw_prvdir")
+    let a:newdir= w:netrw_prvdir
+   else
+    call s:NetrwOptionRestore("w:")
+"    call Decho("setl noma nomod nowrap")
+    exe "setl ".g:netrw_bufsettings
+"    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
+    let a:newdir= dirname
+"    call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
+    return
+   endif
+  endtry
+
+"  call Dret("s:NetrwLcd")
+endfun
+
 " ------------------------------------------------------------------------
 " s:NetrwSaveWordPosn: used to keep cursor on same word after refresh, {{{2
 " changed sorting, etc.  Also see s:NetrwRestoreWordPosn().
@@ -9537,13 +10355,19 @@
 fun! s:RemotePathAnalysis(dirname)
 "  call Dfunc("s:RemotePathAnalysis(a:dirname<".a:dirname.">)")
 
-  let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/:#]\+\)\%([:#]\(\d\+\)\)\=/\(.*\)$'
+  "                method   ://    user  @      machine      :port            /path
+  let dirpat  = '^\(\w\{-}\)://\(\(\w\+\)@\)\=\([^/:#]\+\)\%([:#]\(\d\+\)\)\=/\(.*\)$'
   let s:method  = substitute(a:dirname,dirpat,'\1','')
-  let s:user    = substitute(a:dirname,dirpat,'\2','')
-  let s:machine = substitute(a:dirname,dirpat,'\3','')
-  let s:port    = substitute(a:dirname,dirpat,'\4','')
-  let s:path    = substitute(a:dirname,dirpat,'\5','')
-  let s:fname   = substitute(a:dirname,'^.*/\ze.','','')
+  let s:user    = substitute(a:dirname,dirpat,'\3','')
+  let s:machine = substitute(a:dirname,dirpat,'\4','')
+  let s:port    = substitute(a:dirname,dirpat,'\5','')
+  let s:path    = substitute(a:dirname,dirpat,'\6','')
+  let s:fname   = substitute(s:path,'^.*/\ze.','','')
+  if s:machine =~ '@'
+   let dirpat    = '^\(.*\)@\(.\{-}\)$'
+   let s:user    = s:user.'@'.substitute(s:machine,dirpat,'\1','')
+   let s:machine = substitute(s:machine,dirpat,'\2','')
+  endif
 
 "  call Decho("set up s:method <".s:method .">")
 "  call Decho("set up s:user   <".s:user   .">")
@@ -9620,33 +10444,51 @@
    return
   endif
 "  call Dfunc("s:NetrwRexplore() w:netrw_rexlocal=".w:netrw_rexlocal." w:netrw_rexdir<".w:netrw_rexdir.">")
+"  call Decho("ft=".&ft." win#".winnr()." w:netrw_rexfile<".(exists("w:netrw_rexfile")? w:netrw_rexfile : 'n/a').">")
+
+  if &ft == "netrw" && exists("w:netrw_rexfile") && w:netrw_rexfile != ""
+"   call Decho("in netrw buffer, will edit file<".w:netrw_rexfile.">")
+   exe "e ".w:netrw_rexfile
+   unlet w:netrw_rexfile
+"   call Dret("s:NetrwRexplore returning from netrw to buf#".bufnr("%")."<".bufname("%").">  (ft=".&ft.")")
+   return
+  endif
+
+  " record current file so :Rex can return to it from netrw
+  let w:netrw_rexfile= expand("%")
+
   if !exists("w:netrw_rexlocal")
-"   "   call Dret("s:NetrwRexplore() w:netrw_rexlocal doesn't exist")
+"   call Dret("s:NetrwRexplore w:netrw_rexlocal doesn't exist (".&ft.")")
    return
   endif
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
   if w:netrw_rexlocal
    keepj call netrw#LocalBrowseCheck(w:netrw_rexdir)
   else
    keepj call s:NetrwBrowse(0,w:netrw_rexdir)
   endif
   if exists("s:initbeval")
-   set beval
+   setl beval
   endif
   if exists("s:rexposn_".bufnr("%"))
-"   call Decho("(NetrwRexplore) restore posn, then unlet s:rexposn_".bufnr('%'))
-   keepj call netrw#NetrwRestorePosn(s:rexposn_{bufnr('%')})
+"   call Decho("restore posn, then unlet s:rexposn_".bufnr('%'))
+   keepj call netrw#RestorePosn(s:rexposn_{bufnr('%')})
    unlet s:rexposn_{bufnr('%')}
   else
-"   call Decho("(NetrwRexplore) s:rexposn_".bufnr('%')." doesn't exist")
+"   call Decho("s:rexposn_".bufnr('%')." doesn't exist")
   endif
+
   if exists("s:explore_match")
    exe "2match netrwMarkFile /".s:explore_match."/"
   endif
-"  call Dret("s:NetrwRexplore")
+
+"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
+"  call Dret("s:NetrwRexplore : ft=".&ft)
 endfun
 
 " ---------------------------------------------------------------------
-" s:SaveBufVars: {{{2
+" s:SaveBufVars: save selected b: variables to s: variables {{{2
+"                use s:RestoreBufVars() to restore b: variables from s: variables
 fun! s:SaveBufVars()
 "  call Dfunc("s:SaveBufVars() buf#".bufnr("%"))
 
@@ -9717,42 +10559,48 @@
 endfun
 
 " ---------------------------------------------------------------------
-" s:Strlen: this function returns the length of a string, even if its {{{2
-"           using multiple-byte characters.
-"           Solution from Nicolai Weibull, vim docs (:help strlen()), Tony Mechelynck,
-"           and a bit from me.
-"           if g:netrw_xstrlen is zero (default), then the builtin strlen() function is used.
+" s:Strlen: this function returns the length of a string, even if its using multi-byte characters. {{{2
+"           Solution from Nicolai Weibull, vim docs (:help strlen()),
+"           Tony Mechelynck, and my own invention.
 fun! s:Strlen(x)
-"  call Dfunc("s:Strlen(x<".a:x.">")
-  if g:netrw_xstrlen == 1
+"  "" call Dfunc("s:Strlen(x<".a:x."> g:Align_xstrlen=".g:Align_xstrlen.")")
+
+  if v:version >= 703 && exists("*strdisplaywidth")
+   let ret= strdisplaywidth(a:x)
+ 
+  elseif type(g:Align_xstrlen) == 1
+   " allow user to specify a function to compute the string length  (ie. let g:Align_xstrlen="mystrlenfunc")
+   exe "let ret= ".g:Align_xstrlen."('".substitute(a:x,"'","''","g")."')"
+ 
+  elseif g:Align_xstrlen == 1
    " number of codepoints (Latin a + combining circumflex is two codepoints)
    " (comment from TM, solution from NW)
    let ret= strlen(substitute(a:x,'.','c','g'))
-
-  elseif g:netrw_xstrlen == 2
-   " number of spacing codepoints (Latin a + combining circumflex is one spacing 
+ 
+  elseif g:Align_xstrlen == 2
+   " number of spacing codepoints (Latin a + combining circumflex is one spacing
    " codepoint; a hard tab is one; wide and narrow CJK are one each; etc.)
    " (comment from TM, solution from TM)
-   let ret=strlen(substitute(a:x, '.\Z', 'x', 'g')) 
-
-  elseif g:netrw_xstrlen == 3
-   " virtual length (counting, for instance, tabs as anything between 1 and 
-   " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately 
+   let ret=strlen(substitute(a:x, '.\Z', 'x', 'g'))
+ 
+  elseif g:Align_xstrlen == 3
+   " virtual length (counting, for instance, tabs as anything between 1 and
+   " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately
    " preceded by lam, one otherwise, etc.)
    " (comment from TM, solution from me)
-   let modkeep= &mod
-   exe "keepj norm! o\<esc>"
+   let modkeep= &l:mod
+   exe "norm! o\<esc>"
    call setline(line("."),a:x)
    let ret= virtcol("$") - 1
-   keepj d
+   d
    keepj norm! k
-   let &mod= modkeep
-
+   let &l:mod= modkeep
+ 
   else
    " at least give a decent default
-   let ret= strlen(a:x)
+    let ret= strlen(a:x)
   endif
-"  call Dret("s:Strlen ".ret)
+"  "" call Dret("s:Strlen ".ret)
   return ret
 endfun
 
@@ -9764,7 +10612,7 @@
   let prvline  = (line(".") > 1)?         getline(line(".")-1) : ''
   let nxtline  = (line(".") < line("$"))? getline(line(".")+1) : ''
   let curindent= substitute(curline,'^\([| ]*\).\{-}$','\1','')
-  let indentm1 = substitute(curindent,'^| ','','')
+  let indentm1 = substitute(curindent,'^'.s:treedepthstring.' ','','')
 "  call Decho("prvline  <".prvline."> #".line(".")-1)
 "  call Decho("curline  <".curline."> #".line("."))
 "  call Decho("nxtline  <".nxtline."> #".line(".")+1)
@@ -9775,22 +10623,22 @@
 "   call Decho('regfile')
    if     a:dir == '[' && prvline != ''
     keepj norm! 0
-    let nl = search('^'.indentm1.'[^|]','bWe')    " search backwards from regular file
+    let nl = search('^'.indentm1.'[^'.s:treedepthstring.']','bWe')    " search backwards from regular file
 "    call Decho("regfile srch back: ".nl)
    elseif a:dir == ']' && nxtline != ''
     keepj norm! $
-    let nl = search('^'.indentm1.'[^|]','We')     " search forwards from regular file
+    let nl = search('^'.indentm1.'[^'.s:treedepthstring.']','We')     " search forwards from regular file
 "    call Decho("regfile srch fwd: ".nl)
    endif
 
   elseif a:dir == '[' && prvline != ''
    keepj norm! 0
    let curline= line(".")
-   let nl     = search('^'.curindent.'[^|]','bWe') " search backwards From directory, same indentation
+   let nl     = search('^'.curindent.'[^'.s:treedepthstring.']','bWe') " search backwards From directory, same indentation
 "   call Decho("dir srch back ind: ".nl)
    if nl != 0
     if line(".") == curline-1
-     let nl= search('^'.indentm1.'[^|]','bWe')     " search backwards from directory, indentation - 1
+     let nl= search('^'.indentm1.'[^'.s:treedepthstring.']','bWe')     " search backwards from directory, indentation - 1
 "     call Decho("dir srch back ind-1: ".nl)
     endif
    endif
@@ -9798,11 +10646,11 @@
   elseif a:dir == ']' && nxtline != ''
    keepj norm! $
    let curline = line(".")
-   let nl      = search('^'.curindent.'[^|]','We') " search forwards from directory, same indentation
+   let nl      = search('^'.curindent.'[^'.s:treedepthstring.']','We') " search forwards from directory, same indentation
 "   call Decho("dir srch fwd ind: ".nl)
    if nl != 0
     if line(".") == curline+1
-     let nl= search('^'.indentm1.'[^|]','We')         " search forwards from directory, indentation - 1
+     let nl= search('^'.indentm1.'[^'.s:treedepthstring.']','We')         " search forwards from directory, indentation - 1
 "     call Decho("dir srch fwd ind-1: ".nl)
     endif
    endif
diff -Naur vim74.orig/runtime/autoload/netrwSettings.vim vim74/runtime/autoload/netrwSettings.vim
--- vim74.orig/runtime/autoload/netrwSettings.vim	2013-05-03 19:53:43.000000000 +0000
+++ vim74/runtime/autoload/netrwSettings.vim	2014-10-10 14:53:39.825391905 +0000
@@ -1,7 +1,7 @@
 " netrwSettings.vim: makes netrw settings simpler
-" Date:		May 03, 2013
+" Date:		Aug 27, 2013
 " Maintainer:	Charles E Campbell <drchipNOSPAM at campbellfamily dot biz>
-" Version:	14a	ASTRO-ONLY
+" Version:	14
 " Copyright:    Copyright (C) 1999-2007 Charles E. Campbell {{{1
 "               Permission is hereby granted to use and distribute this code,
 "               with or without modifications, provided that this copyright
@@ -19,7 +19,7 @@
 if exists("g:loaded_netrwSettings") || &cp
   finish
 endif
-let g:loaded_netrwSettings = "v14a"
+let g:loaded_netrwSettings = "v14"
 if v:version < 700
  echohl WarningMsg
  echo "***warning*** this version of netrwSettings needs vim 7.0"
@@ -98,6 +98,11 @@
 
   put = ''
   put ='+ Netrw Browser Control'
+  if exists("g:netrw_altfile")
+   put = 'let g:netrw_altfile   = '.g:netrw_altfile
+  else
+   put = 'let g:netrw_altfile   = 0'
+  endif
   put = 'let g:netrw_alto              = '.g:netrw_alto
   put = 'let g:netrw_altv              = '.g:netrw_altv
   put = 'let g:netrw_banner            = '.g:netrw_banner
diff -Naur vim74.orig/runtime/autoload/netrw_gitignore.vim vim74/runtime/autoload/netrw_gitignore.vim
--- vim74.orig/runtime/autoload/netrw_gitignore.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/autoload/netrw_gitignore.vim	2014-10-10 14:53:39.828725230 +0000
@@ -0,0 +1,71 @@
+" netrw_gitignore#Hide: gitignore-based hiding
+"  Function returns a string of comma separated patterns convenient for
+"  assignment to `g:netrw_list_hide` option.
+"  Function can take additional filenames as arguments, example:
+"  netrw_gitignore#Hide('custom_gitignore1', 'custom_gitignore2')
+"
+" Usage examples:
+"  let g:netrw_list_hide = netrw_gitignore#Hide()
+"  let g:netrw_list_hide = netrw_gitignore#Hide() . 'more,hide,patterns'
+"
+" Copyright:    Copyright (C) 2013 Bruno Sutic {{{1
+"               Permission is hereby granted to use and distribute this code,
+"               with or without modifications, provided that this copyright
+"               notice is copied with it. Like anything else that's free,
+"               netrw_gitignore.vim is provided *as is* and comes with no
+"               warranty of any kind, either expressed or implied. By using
+"               this plugin, you agree that in no event will the copyright
+"               holder be liable for any damages resulting from the use
+"               of this software.
+function! netrw_gitignore#Hide(...)
+  let additional_files = a:000
+
+  let default_files = ['.gitignore', '.git/info/exclude']
+
+  " get existing global/system gitignore files
+  let global_gitignore = expand(substitute(system("git config --global core.excludesfile"), '\n', '', 'g'))
+  if global_gitignore !=# ''
+    let default_files = add(default_files, global_gitignore)
+  endif
+  let system_gitignore = expand(substitute(system("git config --system core.excludesfile"), '\n', '', 'g'))
+  if system_gitignore !=# ''
+    let default_files = add(default_files, system_gitignore)
+  endif
+
+  " append additional files if given as function arguments
+  if additional_files !=# []
+    let files = extend(default_files, additional_files)
+  else
+    let files = default_files
+  endif
+
+  " keep only existing/readable files
+  let gitignore_files = []
+  for file in files
+    if filereadable(file)
+      let gitignore_files = add(gitignore_files, file)
+    endif
+  endfor
+
+  " get contents of gitignore patterns from those files
+  let gitignore_lines = []
+  for file in gitignore_files
+    for line in readfile(file)
+      " filter empty lines and comments
+      if line !~# '^#' && line !~# '^$'
+        let gitignore_lines = add(gitignore_lines, line)
+      endif
+    endfor
+  endfor
+
+  " convert gitignore patterns to Netrw/Vim regex patterns
+  let escaped_lines = []
+  for line in gitignore_lines
+    let escaped       = line
+    let escaped       = substitute(escaped, '\.', '\\.', 'g')
+    let escaped       = substitute(escaped, '*', '.*', 'g')
+    let escaped_lines = add(escaped_lines, escaped)
+  endfor
+
+  return join(escaped_lines, ',')
+endfunction
diff -Naur vim74.orig/runtime/autoload/phpcomplete.vim vim74/runtime/autoload/phpcomplete.vim
--- vim74.orig/runtime/autoload/phpcomplete.vim	2011-12-08 15:38:25.000000000 +0000
+++ vim74/runtime/autoload/phpcomplete.vim	2014-10-10 14:53:39.842058530 +0000
@@ -1,28 +1,102 @@
 " Vim completion script
 " Language:	PHP
-" Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
-" Last Change:	2011 Dec 08
+" Maintainer:	Dvid Szab ( complex857 AT gmail DOT com )
+" Previous Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
+" URL: https://github.com/shawncplus/phpcomplete.vim
+" Last Change:  2014 Oct 02
 "
-"   TODO:
-"   - Class aware completion:
-"      a) caching?
-"   - Switching to HTML (XML?) completion (SQL) inside of phpStrings
-"   - allow also for XML completion <- better do html_flavor for HTML
-"     completion
-"   - outside of <?php?> getting parent tag may cause problems. Heh, even in
-"     perfect conditions GetLastOpenTag doesn't cooperate... Inside of
-"     phpStrings this can be even a bonus but outside of <?php?> it is not the
-"     best situation
+"	OPTIONS:
+"
+"		let g:phpcomplete_relax_static_constraint = 1/0  [default 0]
+"			Enables completion for non-static methods when completing for static context (::).
+"			This generates E_STRICT level warning, but php calls these methods nontheless.
+"
+"		let g:phpcomplete_complete_for_unknown_classes = 1/0 [default 0]
+"			Enables completion of variables and functions in "everything under the sun" fashion
+"			when completing for an instance or static class context but the code can't tell the class
+"			or locate the file that it lives in.
+"			The completion list generated this way is only filtered by the completion base
+"			and generally not much more accurate then simple keyword completion.
+"
+"		let g:phpcomplete_search_tags_for_variables = 1/0 [default 0]
+"			Enables use of tags when the plugin tries to find variables.
+"			When enabled the plugin will search for the variables in the tag files with kind 'v',
+"			lines like $some_var = new Foo; but these usually yield highly inaccurate results and
+"			can	be fairly slow.
+"
+"		let g:phpcomplete_min_num_of_chars_for_namespace_completion = n [default 1]
+"			This option controls the number of characters the user needs to type before
+"			the tags will be searched for namespaces and classes in typed out namespaces in
+"			"use ..." context. Setting this to 0 is not recommended because that means the code
+"			have to scan every tag, and vim's taglist() function runs extremly slow with a
+"			"match everything" pattern.
+"
+"		let g:phpcomplete_parse_docblock_comments = 1/0 [default 0]
+"			When enabled the preview window's content will include information
+"			extracted from docblock comments of the completions.
+"			Enabling this option will add return types to the completion menu for functions too.
+"
+"		let g:phpcomplete_cache_taglists = 1/0 [default 1]
+"			When enabled the taglist() lookups will be cached and subsequent searches
+"			for the same pattern will not check the tagfiles any more, thus making the
+"			lookups faster. Cache expiration is based on the mtimes of the tag files.
+"
+"	TODO:
+"	- Switching to HTML (XML?) completion (SQL) inside of phpStrings
+"	- allow also for XML completion <- better do html_flavor for HTML
+"	  completion
+"	- outside of <?php?> getting parent tag may cause problems. Heh, even in
+"	  perfect conditions GetLastOpenTag doesn't cooperate... Inside of
+"	  phpStrings this can be even a bonus but outside of <?php?> it is not the
+"	  best situation
+
+if !exists('g:phpcomplete_relax_static_constraint')
+	let g:phpcomplete_relax_static_constraint = 0
+endif
+
+if !exists('g:phpcomplete_complete_for_unknown_classes')
+	let g:phpcomplete_complete_for_unknown_classes = 0
+endif
+
+if !exists('g:phpcomplete_search_tags_for_variables')
+	let g:phpcomplete_search_tags_for_variables = 0
+endif
+
+if !exists('g:phpcomplete_min_num_of_chars_for_namespace_completion')
+	let g:phpcomplete_min_num_of_chars_for_namespace_completion = 1
+endif
+
+if !exists('g:phpcomplete_parse_docblock_comments')
+	let g:phpcomplete_parse_docblock_comments = 0
+endif
+
+if !exists('g:phpcomplete_cache_taglists')
+	let g:phpcomplete_cache_taglists = 1
+endif
+
+if !exists('s:cache_classstructures')
+	let s:cache_classstructures = {}
+endif
+
+if !exists('s:cache_tags')
+	let s:cache_tags = {}
+endif
+
+if !exists('s:cache_tags_checksum')
+	let s:cache_tags_checksum = ''
+endif
+
+let s:script_path = fnamemodify(resolve(expand('<sfile>:p')), ':h')
 
-function! phpcomplete#CompletePHP(findstart, base)
+function! phpcomplete#CompletePHP(findstart, base) " {{{
 	if a:findstart
 		unlet! b:php_menu
 		" Check if we are inside of PHP markup
 		let pos = getpos('.')
 		let phpbegin = searchpairpos('<?', '', '?>', 'bWn',
-				\ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\|comment"')
-		let phpend   = searchpairpos('<?', '', '?>', 'Wn',
-				\ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\|comment"')
+				\ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"')
+		let phpend = searchpairpos('<?', '', '?>', 'Wn',
+				\ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"')
 
 		if phpbegin == [0,0] && phpend == [0,0]
 			" We are outside of any PHP markup. Complete HTML
@@ -35,5118 +109,2550 @@
 			" locate the start of the word
 			let line = getline('.')
 			let start = col('.') - 1
-			let curline = line('.')
 			let compl_begin = col('.') - 2
-			while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\x7f-\xff$]'
+			while start >= 0 && line[start - 1] =~ '[\\a-zA-Z_0-9\x7f-\xff$]'
 				let start -= 1
 			endwhile
-			let b:compl_context = getline('.')[0:compl_begin]
-			return start
+			let b:phpbegin = phpbegin
+			let b:compl_context = phpcomplete#GetCurrentInstruction(line('.'), max([0, col('.') - 2]), phpbegin)
 
+			return start
 			" We can be also inside of phpString with HTML tags. Deal with
 			" it later (time, not lines).
 		endif
-
 	endif
+
+
 	" If exists b:php_menu it means completion was already constructed we
 	" don't need to do anything more
 	if exists("b:php_menu")
 		return b:php_menu
 	endif
-	" Initialize base return lists
-	let res = []
-	let res2 = []
+
+	if !exists('g:php_builtin_functions')
+		call phpcomplete#LoadData()
+	endif
+
 	" a:base is very short - we need context
 	if exists("b:compl_context")
 		let context = b:compl_context
 		unlet! b:compl_context
-	endif
+		" chop of the "base" from the end of the current instruction
+		if a:base != ""
+			let context = substitute(context, '\s*[$a-zA-Z_0-9\x7f-\xff]*$', '', '')
+		end
+	end
 
-	if !exists('g:php_builtin_functions')
-		call phpcomplete#LoadData()
+	let [current_namespace, imports] = phpcomplete#GetCurrentNameSpace(getline(0, line('.')))
+
+	if context =~? '^use\s'
+		return phpcomplete#CompleteUse(a:base)
 	endif
 
-	let scontext = substitute(context, '\$\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*$', '', '')
+	if context =~ '\(->\|::\)$'
+		" {{{
+		" Get name of the class
+		let classname = phpcomplete#GetClassName(line('.'), context, current_namespace, imports)
+
+		" Get location of class definition, we have to iterate through all
+		if classname != ''
+			if classname =~ '\'
+				" split the last \ segment as a classname, everything else is the namespace
+				let classname_parts = split(classname, '\')
+				let namespace = join(classname_parts[0:-2], '\')
+				let classname = classname_parts[-1]
+			else
+				let namespace = '\'
+			endif
+			let classlocation = phpcomplete#GetClassLocation(classname, namespace)
+		else
+			let classlocation = ''
+		endif
 
-	if scontext =~ '\(=\s*new\|extends\)\s\+$'
-		" Complete class name
-		" Internal solution for finding classes in current file.
-		let file = getline(1, '$')
-		call filter(file,
-				\ 'v:val =~ "class\\s\\+[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*("')
-		let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
-		let jfile = join(file, ' ')
-		let int_values = split(jfile, 'class\s\+')
-		let int_classes = {}
-		for i in int_values
-			let c_name = matchstr(i, '^[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
-			if c_name != ''
-				let int_classes[c_name] = ''
+		if classlocation != ''
+			if classlocation == 'VIMPHP_BUILTINOBJECT' && has_key(g:php_builtin_classes, tolower(classname))
+				return phpcomplete#CompleteBuiltInClass(context, classname, a:base)
 			endif
-		endfor
 
-		" Prepare list of classes from tags file
-		let ext_classes = {}
-		let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
-		if fnames != ''
-			exe 'silent! vimgrep /^'.a:base.'.*\tc\(\t\|$\)/j '.fnames
-			let qflist = getqflist()
-			if len(qflist) > 0
-				for field in qflist
-					" [:space:] thing: we don't have to be so strict when
-					" dealing with tags files - entries there were already
-					" checked by ctags.
-					let item = matchstr(field['text'], '^[^[:space:]]\+')
-					let ext_classes[item] = ''
-				endfor
+			if filereadable(classlocation)
+				let classfile = readfile(classlocation)
+				let classcontent = ''
+				let classcontent .= "\n".phpcomplete#GetClassContents(classlocation, classname)
+				let sccontent = split(classcontent, "\n")
+				let visibility = expand('%:p') == fnamemodify(classlocation, ':p') ? 'private' : 'public'
+
+				return phpcomplete#CompleteUserClass(context, a:base, sccontent, visibility)
 			endif
 		endif
 
-		" Prepare list of built in classes from g:php_builtin_functions
-		if !exists("g:php_omni_bi_classes")
-			let g:php_omni_bi_classes = {}
-			for i in keys(g:php_builtin_object_functions)
-				let g:php_omni_bi_classes[substitute(i, '::.*$', '', '')] = ''
-			endfor
+		return phpcomplete#CompleteUnknownClass(a:base, context)
+		" }}}
+	elseif context =~? 'implements'
+		return phpcomplete#CompleteClassName(a:base, ['i'], current_namespace, imports)
+	elseif context =~? 'extends\s\+.\+$'
+		return ['implements']
+	elseif context =~? 'extends'
+		let kinds = context =~? 'class\s' ? ['c'] : ['i']
+		return phpcomplete#CompleteClassName(a:base, kinds, current_namespace, imports)
+	elseif context =~? 'class [a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
+		" special case when you've typed the class keyword and the name too, only extends and implements allowed there
+		return filter(['extends', 'implements'], 'stridx(v:val, a:base) == 0')
+	elseif context =~? 'new'
+		return phpcomplete#CompleteClassName(a:base, ['c'], current_namespace, imports)
+	endif
+
+	if a:base =~ '^\$'
+		return phpcomplete#CompleteVariable(a:base)
+	else
+		return phpcomplete#CompleteGeneral(a:base, current_namespace, imports)
+	endif
+endfunction
+" }}}
+
+function! phpcomplete#CompleteUse(base) " {{{
+	" completes builtin class names regadless of g:phpcomplete_min_num_of_chars_for_namespace_completion
+	" completes namespaces from tags
+	"   * requires patched ctags
+	" completes classnames from tags within the already typed out namespace using the "namespace" field of tags
+	"   * requires patched ctags
+
+	let res = []
+
+	" class and namespace names are always considered absoltute in use ... expressions, leading slash is not recommended
+	" by the php manual, so we gonna get rid of that
+	if a:base =~? '^\'
+		let base = substitute(a:base, '^\', '', '')
+	else
+		let base = a:base
+	endif
+
+	let namespace_match_pattern  = substitute(base, '\\', '\\\\', 'g')
+	let classname_match_pattern = matchstr(base, '[^\\]\+$')
+	let namespace_for_class = substitute(substitute(namespace_match_pattern, '\\\\', '\\', 'g'), '\\*'.classname_match_pattern.'$', '', '')
+
+	if len(namespace_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
+		if len(classname_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
+			let tags = phpcomplete#GetTaglist('^\('.namespace_match_pattern.'\|'.classname_match_pattern.'\)')
+		else
+			let tags = phpcomplete#GetTaglist('^'.namespace_match_pattern)
 		endif
 
-		let classes = sort(keys(int_classes))
-		let classes += sort(keys(ext_classes))
-		let classes += sort(keys(g:php_omni_bi_classes))
-
-		for m in classes
-			if m =~ '^'.a:base
-				call add(res, m)
+		let patched_ctags_detected = 0
+		let namespaced_matches = []
+		let no_namespace_matches = []
+		for tag in tags
+			if has_key(tag, 'namespace')
+				let patched_ctags_detected = 1
+			endif
+			if tag.kind ==? 'n' && tag.name =~? '^'.namespace_match_pattern
+				let patched_ctags_detected = 1
+				call add(namespaced_matches, {'word': tag.name, 'kind': 'n', 'menu': tag.filename, 'info': tag.filename })
+			elseif has_key(tag, 'namespace') && (tag.kind ==? 'c' || tag.kind ==? 'i') && tag.namespace ==? namespace_for_class
+				call add(namespaced_matches, {'word': namespace_for_class.'\'.tag.name, 'kind': tag.kind, 'menu': tag.filename, 'info': tag.filename })
+			elseif (tag.kind ==? 'c' || tag.kind ==? 'i')
+				call add(no_namespace_matches, {'word': namespace_for_class.'\'.tag.name, 'kind': tag.kind, 'menu': tag.filename, 'info': tag.filename })
 			endif
 		endfor
+		" if it seems that the tags file have namespace informations we can safely throw
+		" away namespaceless tag matches since we can be sure they are invalid
+		if patched_ctags_detected
+			no_namespace_matches = []
+		endif
+		let res += namespaced_matches + no_namespace_matches
+	endif
 
-		let final_menu = []
-		for i in res
-			let final_menu += [{'word':i, 'kind':'c'}]
+	if base !~ '\'
+		let builtin_classnames = filter(keys(copy(g:php_builtin_classnames)), 'v:val =~? "^'.classname_match_pattern.'"')
+		for classname in builtin_classnames
+			call add(res, {'word': g:php_builtin_classes[tolower(classname)].name, 'kind': 'c'})
 		endfor
+		let builtin_interfacenames = filter(keys(copy(g:php_builtin_interfacenames)), 'v:val =~? "^'.classname_match_pattern.'"')
+		for interfacename in builtin_interfacenames
+			call add(res, {'word': g:php_builtin_interfaces[tolower(interfacename)].name, 'kind': 'i'})
+		endfor
+	endif
 
-		return final_menu
+	return res
+endfunction
+" }}}
 
-	elseif scontext =~ '\(->\|::\)$'
-		" Complete user functions and variables
-		" Internal solution for current file.
-		" That seems as unnecessary repeating of functions but there are
-		" few not so subtle differences as not appending of $ and addition
-		" of 'kind' tag (not necessary in regular completion)
-
-		if scontext =~ '->$' && scontext !~ '\$this->$'
-
-			" Get name of the class
-			let classname = phpcomplete#GetClassName(scontext)
-
-			" Get location of class definition, we have to iterate through all
-			" tags files separately because we need relative path from current
-			" file to the exact file (tags file can be in different dir)
-			if classname != ''
-				let classlocation = phpcomplete#GetClassLocation(classname)
-			else
-				let classlocation = ''
-			endif
+function! phpcomplete#CompleteGeneral(base, current_namespace, imports) " {{{
+	" Complete everything
+	"  + functions,  DONE
+	"  + keywords of language DONE
+	"  + defines (constant definitions), DONE
+	"  + extend keywords for predefined constants, DONE
+	"  + classes (after new), DONE
+	"  + limit choice after -> and :: to funcs and vars DONE
 
-			if classlocation == 'VIMPHP_BUILTINOBJECT'
+	" Internal solution for finding functions in current file.
 
-				for object in keys(g:php_builtin_object_functions)
-					if object =~ '^'.classname
-						let res += [{'word':substitute(object, '.*::', '', ''),
-							   	\    'info': g:php_builtin_object_functions[object]}]
-					endif
-				endfor
+	if a:base =~? '^\'
+		let leading_slash = '\'
+	else
+		let leading_slash = ''
+	endif
 
-				return res
+	let file = getline(1, '$')
+	call filter(file,
+				\ 'v:val =~ "function\\s\\+&\\?[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*("')
+	let jfile = join(file, ' ')
+	let int_values = split(jfile, 'function\s\+')
+	let int_functions = {}
+	for i in int_values
+		let f_name = matchstr(i,
+					\ '^&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
+		if f_name =~? '^'.substitute(a:base, '\\', '\\\\', 'g')
+			let f_args = matchstr(i,
+						\ '^&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\zs.\{-}\ze)\_s*\({\|$\)')
+			let int_functions[f_name.'('] = f_args.')'
+		endif
+	endfor
 
-			endif
+	" Internal solution for finding constants in current file
+	let file = getline(1, '$')
+	call filter(file, 'v:val =~ "define\\s*("')
+	let jfile = join(file, ' ')
+	let int_values = split(jfile, 'define\s*(\s*')
+	let int_constants = {}
+	for i in int_values
+		let c_name = matchstr(i, '\(["'']\)\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze\1')
+		if c_name != '' && c_name =~# '^'.substitute(a:base, '\\', '\\\\', 'g')
+			let int_constants[leading_slash.c_name] = ''
+		endif
+	endfor
 
-			if filereadable(classlocation)
-				let classfile = readfile(classlocation)
-				let classcontent = ''
-				let classcontent .= "\n".phpcomplete#GetClassContents(classfile, classname)
-				let sccontent = split(classcontent, "\n")
+	" Prepare list of functions from tags file
+	let ext_functions  = {}
+	let ext_constants  = {}
+	let ext_classes    = {}
+	let ext_interfaces = {}
+	let ext_namespaces = {}
+
+	let base = substitute(a:base, '^\\', '', '')
+	let [tag_match_pattern, namespace_for_tag] = phpcomplete#ExpandClassName(a:base, a:current_namespace, a:imports)
+	let namespace_match_pattern  = substitute((namespace_for_tag == '' ? '' : namespace_for_tag.'\').tag_match_pattern, '\\', '\\\\', 'g')
+
+	let tags = []
+	if len(namespace_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion && len(tag_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion && tag_match_pattern != namespace_match_pattern
+		let tags = phpcomplete#GetTaglist('\c^\('.tag_match_pattern.'\|'.namespace_match_pattern.'\)')
+	elseif len(namespace_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
+		let tags = phpcomplete#GetTaglist('\c^'.namespace_match_pattern)
+	elseif len(tag_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
+		let tags = phpcomplete#GetTaglist('\c^'.tag_match_pattern)
+	endif
 
-				" YES, YES, YES! - we have whole content including extends!
-				" Now we need to get two elements: public functions and public
-				" vars
-				" NO, NO, NO! - third separate filtering looking for content
-				" :(, but all of them have differences. To squeeze them into
-				" one implementation would require many additional arguments
-				" and ifs. No good solution
-				" Functions declared with public keyword or without any
-				" keyword are public
-				let functions = filter(deepcopy(sccontent),
-						\ 'v:val =~ "^\\s*\\(static\\s\\+\\|public\\s\\+\\)*function"')
-				let jfuncs = join(functions, ' ')
-				let sfuncs = split(jfuncs, 'function\s\+')
-				let c_functions = {}
-				for i in sfuncs
-					let f_name = matchstr(i,
-							\ '^&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
-					let f_args = matchstr(i,
-							\ '^&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\zs.\{-}\ze)\_s*{')
-					if f_name != ''
-						let c_functions[f_name.'('] = f_args
-					endif
-				endfor
-				" Variables declared with var or with public keyword are
-				" public
-				let variables = filter(deepcopy(sccontent),
-						\ 'v:val =~ "^\\s*\\(public\\|var\\)\\s\\+\\$"')
-				let jvars = join(variables, ' ')
-				let svars = split(jvars, '\$')
-				let c_variables = {}
-				for i in svars
-					let c_var = matchstr(i,
-							\ '^\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
-					if c_var != ''
-						let c_variables[c_var] = ''
-					endif
-				endfor
+	for tag in tags
+		if !has_key(tag, 'namespace') || tag.namespace ==? a:current_namespace || tag.namespace ==? namespace_for_tag
+			if has_key(tag, 'namespace')
+				let full_name = tag.namespace.'\'.tag.name " absolute namespaced name (without leading '\')
+
+				let base_parts = split(a:base, '\')
+				if len(base_parts) > 1
+					let namespace_part = join(base_parts[0:-2], '\')
+				else
+					let namespace_part = ''
+				endif
+				let relative_name = (namespace_part == '' ? '' : namespace_part.'\').tag.name
+			endif
 
-				let all_values = {}
-				call extend(all_values, c_functions)
-				call extend(all_values, c_variables)
-
-				for m in sort(keys(all_values))
-					if m =~ '^'.a:base && m !~ '::'
-						call add(res, m)
-					elseif m =~ '::'.a:base
-						call add(res2, m)
+			if tag.kind ==? 'n' && tag.name =~? '^'.namespace_match_pattern
+				let info = tag.name.' - '.tag.filename
+				" patched ctag provides absolute namespace names as tag name, namespace tags dont have namespace fields
+				let full_name = tag.name
+
+				let base_parts = split(a:base, '\')
+				let full_name_parts = split(full_name, '\')
+				if len(base_parts) > 1
+					" the first segment could be a renamed import, take the first segment from the user provided input
+					" so if it's a sub namespace of a renamed namespace, just use the typed in segments in place of the absolute path
+					" for example:
+					"     you have a namespace NS1\SUBNS as SUB
+					"     you have a sub-sub-namespace NS1\SUBNS\SUBSUB
+					"     typed in SUB\SU
+					"     the tags will return NS1\SUBNS\SUBSUB
+					"     the completion should be: SUB\SUBSUB by replacing the NS1\SUBSN to SUB as in the import
+					if has_key(a:imports, base_parts[0]) && a:imports[base_parts[0]].kind == 'n'
+						let import = a:imports[base_parts[0]]
+						let relative_name = substitute(full_name, '^'.substitute(import.name, '\\', '\\\\', 'g'), base_parts[0], '')
+					else
+						let relative_name = strpart(full_name, stridx(full_name, a:base))
 					endif
-				endfor
+				else
+					let relative_name = strpart(full_name, stridx(full_name, a:base))
+				endif
 
-				let start_list = res + res2
+				if leading_slash == ''
+					let ext_namespaces[relative_name.'\'] = info
+				else
+					let ext_namespaces['\'.full_name.'\'] = info
+				endif
+			elseif tag.kind ==? 'f' && !has_key(tag, 'class') " class related functions (methods) completed elsewhere, only works with patched ctags
+				if has_key(tag, 'signature')
+					let prototype = tag.signature[1:-2] " drop the ()s around the string
+				else
+					let prototype = matchstr(tag.cmd,
+								\ 'function\s\+&\?[^[:space:]]\+\s*(\s*\zs.\{-}\ze\s*)\s*{\?')
+				endif
+				let info = prototype.') - '.tag.filename
 
-				let final_list = []
-				for i in start_list
-					if has_key(c_variables, i)
-						let class = ' '
-						if all_values[i] != ''
-							let class = i.' class '
+				if !has_key(tag, 'namespace')
+					let ext_functions[tag.name.'('] = info
+				else
+					if tag.namespace ==? namespace_for_tag
+						if leading_slash == ''
+							let ext_functions[relative_name.'('] = info
+						else
+							let ext_functions['\'.full_name.'('] = info
 						endif
-						let final_list +=
-								\ [{'word':i,
-								\   'info':class.all_values[i],
-								\   'kind':'v'}]
-					else
-						let final_list +=
-								\ [{'word':substitute(i, '.*::', '', ''),
-								\   'info':i.all_values[i].')',
-								\   'kind':'f'}]
 					endif
-				endfor
+				endif
+			elseif tag.kind ==? 'd'
+				let info = ' - '.tag.filename
+				if !has_key(tag, 'namespace')
+					let ext_constants[tag.name] = info
+				else
+					if tag.namespace ==? namespace_for_tag
+						if leading_slash == ''
+							let ext_constants[relative_name] = info
+						else
+							let ext_constants['\'.full_name] = info
+						endif
+					endif
+				endif
+			elseif tag.kind ==? 'c' || tag.kind ==? 'i'
+				let info = ' - '.tag.filename
 
-				return final_list
+				let key = ''
+				if !has_key(tag, 'namespace')
+					let key = tag.name
+				else
+					if tag.namespace ==? namespace_for_tag
+						if leading_slash == ''
+							let key = relative_name
+						else
+							let key = '\'.full_name
+						endif
+					endif
+				endif
 
+				if key != ''
+					if tag.kind ==? 'c'
+						let ext_classes[key] = info
+					elseif tag.kind ==? 'i'
+						let ext_interfaces[key] = info
+					endif
+				endif
 			endif
-
 		endif
+	endfor
 
-		if a:base =~ '^\$'
-			let adddollar = '$'
-		else
-			let adddollar = ''
-		endif
-		let file = getline(1, '$')
-		let jfile = join(file, ' ')
-		let sfile = split(jfile, '\$')
-		let int_vars = {}
-		for i in sfile
-			if i =~ '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*=\s*new'
-				let val = matchstr(i, '^[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*').'->'
-			else
-				let val = matchstr(i, '^[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
-			endif
-			if val !~ ''
-				let int_vars[adddollar.val] = ''
+	let builtin_constants  = {}
+	let builtin_classnames = {}
+	let builtin_interfaces = {}
+	let builtin_functions  = {}
+	let builtin_keywords   = {}
+	let base = substitute(a:base, '^\', '', '')
+	if a:current_namespace == '\' || (a:base =~ '^\\' && a:base =~ '^\\[^\\]*$')
+
+		" Add builtin class names
+		for [classname, info] in items(g:php_builtin_classnames)
+			if classname =~? '^'.base
+				let builtin_classnames[leading_slash.g:php_builtin_classes[tolower(classname)].name] = info
 			endif
 		endfor
-
-		" ctags has good support for PHP, use tags file for external
-		" variables
-		let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
-		let ext_vars = {}
-		if fnames != ''
-			let sbase = substitute(a:base, '^\$', '', '')
-			exe 'silent! vimgrep /^'.sbase.'.*\tv\(\t\|$\)/j '.fnames
-			let qflist = getqflist()
-			if len(qflist) > 0
-				for field in qflist
-					let item = matchstr(field['text'], '^[^[:space:]]\+')
-					" Add -> if it is possible object declaration
-					let classname = ''
-					if field['text'] =~ item.'\s*=\s*new\s\+'
-						let item = item.'->'
-						let classname = matchstr(field['text'],
-								\ '=\s*new\s\+\zs[a-zA-Z_0-9\x7f-\xff]\+\ze')
-					endif
-					let ext_vars[adddollar.item] = classname
-				endfor
+		for [interfacename, info] in items(g:php_builtin_interfacenames)
+			if interfacename =~? '^'.base
+				let builtin_interfaces[leading_slash.interfacename] = info
 			endif
-		endif
-
-		" Now we have all variables in int_vars dictionary
-		call extend(int_vars, ext_vars)
-
-		" Internal solution for finding functions in current file.
-		let file = getline(1, '$')
-		call filter(file,
-				\ 'v:val =~ "function\\s\\+&\\?[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*("')
-		let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
-		let jfile = join(file, ' ')
-		let int_values = split(jfile, 'function\s\+')
-		let int_functions = {}
-		for i in int_values
-			let f_name = matchstr(i,
-					\ '^&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
-			let f_args = matchstr(i,
-					\ '^&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\zs.\{-}\ze)\_s*{')
-			let int_functions[f_name.'('] = f_args.')'
 		endfor
+	endif
 
-		" Prepare list of functions from tags file
-		let ext_functions = {}
-		if fnames != ''
-			exe 'silent! vimgrep /^'.a:base.'.*\tf\(\t\|$\)/j '.fnames
-			let qflist = getqflist()
-			if len(qflist) > 0
-				for field in qflist
-					" File name
-					let item = matchstr(field['text'], '^[^[:space:]]\+')
-					let fname = matchstr(field['text'], '\t\zs\f\+\ze')
-					let prototype = matchstr(field['text'],
-							\ 'function\s\+&\?[^[:space:]]\+\s*(\s*\zs.\{-}\ze\s*)\s*{\?')
-					let ext_functions[item.'('] = prototype.') - '.fname
-				endfor
-			endif
+	" Prepare list of constants from built-in constants
+	for [constant, info] in items(g:php_constants)
+		if constant =~# '^'.base
+			let builtin_constants[leading_slash.constant] = info
 		endif
+	endfor
 
-		let all_values = {}
-		call extend(all_values, int_functions)
-		call extend(all_values, ext_functions)
-		call extend(all_values, int_vars) " external variables are already in
-		call extend(all_values, g:php_builtin_object_functions)
-
-		for m in sort(keys(all_values))
-			if m =~ '\(^\|::\)'.a:base
-				call add(res, m)
+	if leading_slash == '' " keywords should not be completed when base starts with '\'
+		" Treat keywords as constants
+		for [constant, info] in items(g:php_keywords)
+			if constant =~? '^'.a:base
+				let builtin_keywords[constant] = info
 			endif
 		endfor
+	endif
 
-		let start_list = res
+	for [function_name, info] in items(g:php_builtin_functions)
+		if function_name =~? '^'.base
+			let builtin_functions[leading_slash.function_name] = info
+		endif
+	endfor
 
-		let final_list = []
-		for i in start_list
-			if has_key(int_vars, i)
-				let class = ' '
-				if all_values[i] != ''
-					let class = i.' class '
+	" All constants
+	call extend(int_constants, ext_constants)
+
+	" All functions
+	call extend(int_functions, ext_functions)
+	call extend(int_functions, builtin_functions)
+
+	for [imported_name, import] in items(a:imports)
+		if imported_name =~? '^'.base
+			if import.kind ==? 'c'
+				if import.builtin
+					let builtin_classnames[imported_name] = ' '.import.name
+				else
+					let ext_classes[imported_name] = ' '.import.name.' - '.import.filename
+				endif
+			elseif import.kind ==? 'i'
+				if import.builtin
+					let builtin_interfaces[imported_name] = ' '.import.name
+				else
+					let ext_interfaces[imported_name] = ' '.import.name.' - '.import.filename
 				endif
-				let final_list += [{'word':i, 'info':class.all_values[i], 'kind':'v'}]
-			else
-				let final_list +=
-						\ [{'word':substitute(i, '.*::', '', ''),
-						\   'info':i.all_values[i],
-						\   'kind':'f'}]
 			endif
-		endfor
 
-		return final_list
-	endif
+			" no builtin interfaces
+			if import.kind == 'n'
+				let ext_namespaces[imported_name.'\'] = ' '.import.name.' - '.import.filename
+			endif
+		end
+	endfor
 
-	if a:base =~ '^\$'
-		" Complete variables
-		" Built-in variables {{{
-		let g:php_builtin_vars = {'$GLOBALS':'',
-								\ '$_SERVER':'',
-								\ '$_GET':'',
-								\ '$_POST':'',
-								\ '$_COOKIE':'',
-								\ '$_FILES':'',
-								\ '$_ENV':'',
-								\ '$_REQUEST':'',
-								\ '$_SESSION':'',
-								\ '$HTTP_SERVER_VARS':'',
-								\ '$HTTP_ENV_VARS':'',
-								\ '$HTTP_COOKIE_VARS':'',
-								\ '$HTTP_GET_VARS':'',
-								\ '$HTTP_POST_VARS':'',
-								\ '$HTTP_POST_FILES':'',
-								\ '$HTTP_SESSION_VARS':'',
-								\ '$php_errormsg':'',
-								\ '$this':''
-								\ }
-		" }}}
+	let all_values = {}
 
-		" Internal solution for current file.
-		let file = getline(1, '$')
-		let jfile = join(file, ' ')
-		let int_vals = split(jfile, '\ze\$')
-		let int_vars = {}
-		for i in int_vals
-			if i =~ '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*=\s*new'
-				let val = matchstr(i,
-						\ '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*').'->'
-			else
-				let val = matchstr(i,
-						\ '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
-			endif
-			if val != ''
-				let int_vars[val] = ''
-			endif
-		endfor
+	" Add functions found in this file
+	call extend(all_values, int_functions)
 
-		call extend(int_vars,g:php_builtin_vars)
+	" Add namespaces from tags
+	call extend(all_values, ext_namespaces)
 
-		" ctags has support for PHP, use tags file for external variables
-		let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
-		let ext_vars = {}
-		if fnames != ''
-			let sbase = substitute(a:base, '^\$', '', '')
-			exe 'silent! vimgrep /^'.sbase.'.*\tv\(\t\|$\)/j '.fnames
-			let qflist = getqflist()
-			if len(qflist) > 0
-				for field in qflist
-					let item = '$'.matchstr(field['text'], '^[^[:space:]]\+')
-					let m_menu = ''
-					" Add -> if it is possible object declaration
-					if field['text'] =~ item.'\s*=\s*new\s\+'
-						let item = item.'->'
-						let m_menu = matchstr(field['text'],
-								\ '=\s*new\s\+\zs[a-zA-Z_0-9\x7f-\xff]\+\ze')
-					endif
-					let ext_vars[item] = m_menu
-				endfor
-			endif
-		endif
+	" Add constants from the current file
+	call extend(all_values, int_constants)
 
-		call extend(int_vars, ext_vars)
-		let g:a0 = keys(int_vars)
+	" Add built-in constants
+	call extend(all_values, builtin_constants)
 
-		for m in sort(keys(int_vars))
-			if m =~ '^\'.a:base
-				call add(res, m)
-			endif
-		endfor
+	" Add external classes
+	call extend(all_values, ext_classes)
 
-		let int_list = res
+	" Add external interfaces
+	call extend(all_values, ext_interfaces)
 
-		let int_dict = []
-		for i in int_list
-			if int_vars[i] != ''
-				let class = ' '
-				if int_vars[i] != ''
-					let class = i.' class '
-				endif
-				let int_dict += [{'word':i, 'info':class.int_vars[i], 'kind':'v'}]
-			else
-				let int_dict += [{'word':i, 'kind':'v'}]
-			endif
-		endfor
+	" Add built-in classes
+	call extend(all_values, builtin_classnames)
 
-		return int_dict
+	" Add built-in interfaces
+	call extend(all_values, builtin_interfaces)
 
-	else
-		" Complete everything else -
-		"  + functions,  DONE
-		"  + keywords of language DONE
-		"  + defines (constant definitions), DONE
-		"  + extend keywords for predefined constants, DONE
-		"  + classes (after new), DONE
-		"  + limit choice after -> and :: to funcs and vars DONE
-
-		" Internal solution for finding functions in current file.
-		let file = getline(1, '$')
-		call filter(file,
-				\ 'v:val =~ "function\\s\\+&\\?[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*("')
-		let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
-		let jfile = join(file, ' ')
-		let int_values = split(jfile, 'function\s\+')
-		let int_functions = {}
-		for i in int_values
-			let f_name = matchstr(i,
-					\ '^&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
-			let f_args = matchstr(i,
-					\ '^&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\s*\zs.\{-}\ze\s*)\_s*{')
-			let int_functions[f_name.'('] = f_args.')'
-		endfor
+	" Add php keywords
+	call extend(all_values, builtin_keywords)
 
-		" Prepare list of functions from tags file
-		let ext_functions = {}
-		if fnames != ''
-			exe 'silent! vimgrep /^'.a:base.'.*\tf\(\t\|$\)/j '.fnames
-			let qflist = getqflist()
-			if len(qflist) > 0
-				for field in qflist
-					" File name
-					let item = matchstr(field['text'], '^[^[:space:]]\+')
-					let fname = matchstr(field['text'], '\t\zs\f\+\ze')
-					let prototype = matchstr(field['text'],
-							\ 'function\s\+&\?[^[:space:]]\+\s*(\s*\zs.\{-}\ze\s*)\s*{\?')
-					let ext_functions[item.'('] = prototype.') - '.fname
-				endfor
-			endif
+	let final_list = []
+	let int_list = sort(keys(all_values))
+	for i in int_list
+		if has_key(ext_namespaces, i)
+			let final_list += [{'word':i, 'kind':'n', 'menu': ext_namespaces[i], 'info': ext_namespaces[i]}]
+		elseif has_key(int_functions, i)
+			let final_list +=
+						\ [{'word':i,
+						\	'info':i.int_functions[i],
+						\	'menu':int_functions[i],
+						\	'kind':'f'}]
+		elseif has_key(ext_classes, i) || has_key(builtin_classnames, i)
+			let info = has_key(ext_classes, i) ? ext_classes[i] : builtin_classnames[i].' - builtin'
+			let final_list += [{'word':i, 'kind': 'c', 'menu': info, 'info': i.info}]
+		elseif has_key(ext_interfaces, i) || has_key(builtin_interfaces, i)
+			let info = has_key(ext_interfaces, i) ? ext_interfaces[i] : builtin_interfaces[i].' - builtin'
+			let final_list += [{'word':i, 'kind': 'i', 'menu': info, 'info': i.info}]
+		elseif has_key(int_constants, i) || has_key(builtin_constants, i)
+			let info = has_key(int_constants, i) ? int_constants[i] : ' - builtin'
+			let final_list += [{'word':i, 'kind': 'd', 'menu': info, 'info': i.info}]
+		else
+			let final_list += [{'word':i}]
 		endif
+	endfor
 
-		" All functions
-		call extend(int_functions, ext_functions)
-		call extend(int_functions, g:php_builtin_functions)
-
-		" Internal solution for finding constants in current file
-		let file = getline(1, '$')
-		call filter(file, 'v:val =~ "define\\s*("')
-		let jfile = join(file, ' ')
-		let int_values = split(jfile, 'define\s*(\s*')
-		let int_constants = {}
-		for i in int_values
-			let c_name = matchstr(i, '\(["'']\)\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze\1')
-			" let c_value = matchstr(i,
-			" \ '\(["'']\)[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\1\s*,\s*\zs.\{-}\ze\s*)')
-			if c_name != ''
-				let int_constants[c_name] = '' " c_value
-			endif
-		endfor
+	return final_list
+endfunction
+" }}}
 
-		" Prepare list of constants from tags file
-		let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
-		let ext_constants = {}
-		if fnames != ''
-			exe 'silent! vimgrep /^'.a:base.'.*\td\(\t\|$\)/j '.fnames
-			let qflist = getqflist()
-			if len(qflist) > 0
-				for field in qflist
-					let item = matchstr(field['text'], '^[^[:space:]]\+')
-					let ext_constants[item] = ''
-				endfor
-			endif
-		endif
+function! phpcomplete#CompleteUnknownClass(base, context) " {{{
+	let res = []
 
-		" All constants
-		call extend(int_constants, ext_constants)
-		" Treat keywords as constants
+	if g:phpcomplete_complete_for_unknown_classes != 1
+		return []
+	endif
+
+	if a:base =~ '^\$'
+		let adddollar = '$'
+	else
+		let adddollar = ''
+	endif
 
-		let all_values = {}
+	let file = getline(1, '$')
 
-		" One big dictionary of functions
-		call extend(all_values, int_functions)
+	" Internal solution for finding object properties in current file.
+	if a:context =~ '::'
+		let variables = filter(deepcopy(file),
+					\ 'v:val =~ "^\\s*\\(static\\|static\\s\\+\\(public\\|var\\)\\|\\(public\\|var\\)\\s\\+static\\)\\s\\+\\$"')
+	elseif a:context =~ '->'
+		let variables = filter(deepcopy(file),
+					\ 'v:val =~ "^\\s*\\(public\\|var\\)\\s\\+\\$"')
+	endif
+	let jvars = join(variables, ' ')
+	let svars = split(jvars, '\$')
+	let int_vars = {}
+	for i in svars
+		let c_var = matchstr(i,
+					\ '^\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
+		if c_var != ''
+			let int_vars[adddollar.c_var] = ''
+		endif
+	endfor
 
-		" Add constants
-		call extend(all_values, int_constants)
-		" Add keywords
-		call extend(all_values, g:php_keywords)
-
-		for m in sort(keys(all_values))
-			if m =~ '^'.a:base
-				call add(res, m)
-			endif
-		endfor
+	" Internal solution for finding functions in current file.
+	call filter(deepcopy(file),
+			\ 'v:val =~ "function\\s\\+&\\?[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*("')
+	let jfile = join(file, ' ')
+	let int_values = split(jfile, 'function\s\+')
+	let int_functions = {}
+	for i in int_values
+		let f_name = matchstr(i,
+				\ '^&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
+		let f_args = matchstr(i,
+				\ '^&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\zs.\{-}\ze)\_s*\({\|$\)')
 
-		let int_list = res
+		let int_functions[f_name.'('] = f_args.')'
+	endfor
 
-		let final_list = []
-		for i in int_list
-			if has_key(int_functions, i)
-				let final_list +=
-						\ [{'word':i,
-						\   'info':i.int_functions[i],
-						\   'kind':'f'}]
-			elseif has_key(int_constants, i)
-				let final_list += [{'word':i, 'kind':'d'}]
+	" collect external functions from tags
+	let ext_functions = {}
+	let tags = phpcomplete#GetTaglist('^'.substitute(a:base, '^\$', '', ''))
+	for tag in tags
+		if tag.kind ==? 'f'
+			let item = tag.name
+			if has_key(tag, 'signature')
+				let prototype = tag.signature[1:-2]
 			else
-				let final_list += [{'word':i}]
+				let prototype = matchstr(tag.cmd,
+						\ 'function\s\+&\?[^[:space:]]\+\s*(\s*\zs.\{-}\ze\s*)\s*{\?')
 			endif
-		endfor
+			let ext_functions[item.'('] = prototype.') - '.tag['filename']
+		endif
+	endfor
 
-		return final_list
+	" All functions to one hash for later reference when deciding kind
+	call extend(int_functions, ext_functions)
 
-	endif
+	let all_values = {}
+	call extend(all_values, int_functions)
+	call extend(all_values, int_vars) " external variables are already in
+	call extend(all_values, g:php_builtin_object_functions)
+
+	for m in sort(keys(all_values))
+		if m =~ '\(^\|::\)'.a:base
+			call add(res, m)
+		endif
+	endfor
 
+	let start_list = res
+
+	let final_list = []
+	for i in start_list
+		if has_key(int_vars, i)
+			let class = ' '
+			if all_values[i] != ''
+				let class = i.' class '
+			endif
+			let final_list += [{'word':i, 'info':class.all_values[i], 'kind':'v'}]
+		else
+			let final_list +=
+					\ [{'word':substitute(i, '.*::', '', ''),
+					\	'info':i.all_values[i],
+					\	'menu':all_values[i],
+					\	'kind':'f'}]
+		endif
+	endfor
+	return final_list
 endfunction
+" }}}
 
-function! phpcomplete#GetClassName(scontext) " {{{
-	" Get class name
-	" Class name can be detected in few ways:
-	" @var $myVar class
-	" line above
-	" or line in tags file
+function! phpcomplete#CompleteVariable(base) " {{{
+	let res = []
 
-	let object = matchstr(a:scontext, '\zs[a-zA-Z_0-9\x7f-\xff]\+\ze->')
-	let i = 1
-	while i < line('.')
-		let line = getline(line('.')-i)
-		if line =~ '^\s*\*\/\?\s*$'
-			let i += 1
-			continue
+	" Internal solution for current file.
+	let file = getline(1, '$')
+	let jfile = join(file, ' ')
+	let int_vals = split(jfile, '\ze\$')
+	let int_vars = {}
+	for i in int_vals
+		if i =~? '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*=\s*new'
+			let val = matchstr(i,
+						\ '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
 		else
-			if line =~ '@var\s\+\$'.object.'\s\+[a-zA-Z_0-9\x7f-\xff]\+'
-				let classname = matchstr(line, '@var\s\+\$'.object.'\s\+\zs[a-zA-Z_0-9\x7f-\xff]\+')
-				return classname
-			else
-				break
-			endif
+			let val = matchstr(i,
+						\ '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
 		endif
-	endwhile
+		if val != ''
+			let int_vars[val] = ''
+		endif
+	endfor
 
-	" OK, first way failed, now check tags file(s)
-	let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
-	exe 'silent! vimgrep /^'.object.'.*\$'.object.'.*=\s*new\s\+.*\tv\(\t\|$\)/j '.fnames
-	let qflist = getqflist()
-	if len(qflist) == 0
-		return ''
-	else
-		" In all properly managed projects it should be one item list, even if it
-		" *is* longer we cannot solve conflicts, assume it is first element
-		let classname = matchstr(qflist[0]['text'], '=\s*new\s\+\zs[a-zA-Z_0-9\x7f-\xff]\+\ze')
-		return classname
-	endif
+	call extend(int_vars, g:php_builtin_vars)
 
-endfunction
-" }}}
-function! phpcomplete#GetClassLocation(classname) " {{{
-	" Check classname may be name of built in object
-	if !exists("g:php_omni_bi_classes")
-		let g:php_omni_bi_classes = {}
-		for i in keys(g:php_builtin_object_functions)
-			let g:php_omni_bi_classes[substitute(i, '::.*$', '', '')] = ''
+	" ctags has support for PHP, use tags file for external variables
+	if  g:phpcomplete_search_tags_for_variables
+		let ext_vars = {}
+		let tags = phpcomplete#GetTaglist('\C^'.substitute(a:base, '^\$', '', ''))
+		for tag in tags
+			if tag.kind ==? 'v'
+				let item = tag.name
+				let m_menu = ''
+				if tag.cmd =~? tag['name'].'\s*=\s*new\s\+'
+					let m_menu = matchstr(tag.cmd,
+								\ '\c=\s*new\s\+\zs[a-zA-Z_0-9\x7f-\xff]\+\ze')
+				endif
+				let ext_vars['$'.item] = m_menu
+			endif
 		endfor
-	endif
-	if has_key(g:php_omni_bi_classes, a:classname)
-		return 'VIMPHP_BUILTINOBJECT'
+		call extend(int_vars, ext_vars)
 	endif
 
-	" Get class location
-	for fname in tagfiles()
-		let fhead = fnamemodify(fname, ":h")
-		if fhead != ''
-			let psep = '/' " Note: slash is potential problem!
-			let fhead .= psep
-		endif
-		let fname = escape(fname, " \\")
-		exe 'silent! vimgrep /^'.a:classname.'.*\tc\(\t\|$\)/j '.fname
-		let qflist = getqflist()
-		" As in GetClassName we can manage only one element if it exists
-		if len(qflist) > 0
-			let classlocation = matchstr(qflist[0]['text'], '\t\zs\f\+\ze\t')
-		else
-			return ''
+	for m in sort(keys(int_vars))
+		if m =~# '^\'.a:base
+			call add(res, m)
 		endif
-		" And only one class location
-		if classlocation != ''
-			let classlocation = fhead.classlocation
-			return classlocation
+	endfor
+
+	let int_list = res
+
+	let int_dict = []
+	for i in int_list
+		if int_vars[i] != ''
+			let class = ' '
+			if int_vars[i] != ''
+				let class = i.' class '
+			endif
+			let int_dict += [{'word':i, 'info':class.int_vars[i], 'menu':int_vars[i], 'kind':'v'}]
 		else
-			return ''
+			let int_dict += [{'word':i, 'kind':'v'}]
 		endif
 	endfor
 
+	return int_dict
 endfunction
 " }}}
 
-function! phpcomplete#GetClassContents(file, name) " {{{
-	let cfile = join(a:file, "\n")
-	" We use new buffer and (later) normal! because
-	" this is the most efficient way. The other way
-	" is to go through the looong string looking for
-	" matching {}
-	let original_window = winnr()
-	below 1new
-	0put =cfile
-	call search('class\s\+'.a:name)
-	let cfline = line('.')
-	" Catch extends
-	if getline('.') =~ 'extends'
-		let extends_class = matchstr(getline('.'),
-				\ 'class\s\+'.a:name.'\s\+extends\s\+\zs[a-zA-Z_0-9\x7f-\xff]\+\ze')
+function! phpcomplete#CompleteClassName(base, kinds, current_namespace, imports) " {{{
+	let kinds = sort(a:kinds)
+	" Complete class name
+	let res = []
+	if a:base =~? '^\'
+		let leading_slash = '\'
+		let base = substitute(a:base, '^\', '', '')
 	else
-		let extends_class = ''
+		let leading_slash = ''
+		let base = a:base
 	endif
-	call search('{')
-	normal! %
-	let classc = getline(cfline, ".")
-	let classcontent = join(classc, "\n")
-
-	bw! %
-	" go back to where we started
-	exe original_window.'wincmd w'
 
-	if extends_class != ''
-		let classlocation = phpcomplete#GetClassLocation(extends_class)
-		if filereadable(classlocation)
-			let classfile = readfile(classlocation)
-			let classcontent .= "\n".phpcomplete#GetClassContents(classfile, extends_class)
-		endif
+	" Internal solution for finding classes in current file.
+	let file = getline(1, '$')
+	let filterstr = ''
+
+	if kinds == ['c', 'i']
+		let filterstr = 'v:val =~? "\\(class\\|interface\\)\\s\\+[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*"'
+	elseif kinds == ['c']
+		let filterstr = 'v:val =~? "class\\s\\+[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*"'
+	elseif kinds == ['i']
+		let filterstr = 'v:val =~? "interface\\s\\+[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*"'
 	endif
 
-	return classcontent
-endfunction
-" }}}
+	call filter(file, filterstr)
 
-function! phpcomplete#LoadData() " {{{
-" Keywords/reserved words, all other special things {{{
-" Later it is possible to add some help to values, or type of
-" defined variable
-let g:php_keywords = {
-\ 'PHP_SELF':'',
-\ 'argv':'',
-\ 'argc':'',
-\ 'GATEWAY_INTERFACE':'',
-\ 'SERVER_ADDR':'',
-\ 'SERVER_NAME':'',
-\ 'SERVER_SOFTWARE':'',
-\ 'SERVER_PROTOCOL':'',
-\ 'REQUEST_METHOD':'',
-\ 'REQUEST_TIME':'',
-\ 'QUERY_STRING':'',
-\ 'DOCUMENT_ROOT':'',
-\ 'HTTP_ACCEPT':'',
-\ 'HTTP_ACCEPT_CHARSET':'',
-\ 'HTTP_ACCEPT_ENCODING':'',
-\ 'HTTP_ACCEPT_LANGUAGE':'',
-\ 'HTTP_CONNECTION':'',
-\ 'HTTP_POST':'',
-\ 'HTTP_REFERER':'',
-\ 'HTTP_USER_AGENT':'',
-\ 'HTTPS':'',
-\ 'REMOTE_ADDR':'',
-\ 'REMOTE_HOST':'',
-\ 'REMOTE_PORT':'',
-\ 'SCRIPT_FILENAME':'',
-\ 'SERVER_ADMIN':'',
-\ 'SERVER_PORT':'',
-\ 'SERVER_SIGNATURE':'',
-\ 'PATH_TRANSLATED':'',
-\ 'SCRIPT_NAME':'',
-\ 'REQUEST_URI':'',
-\ 'PHP_AUTH_DIGEST':'',
-\ 'PHP_AUTH_USER':'',
-\ 'PHP_AUTH_PW':'',
-\ 'AUTH_TYPE':'',
-\ 'and':'',
-\ 'or':'',
-\ 'xor':'',
-\ '__FILE__':'',
-\ 'exception':'',
-\ '__LINE__':'',
-\ 'as':'',
-\ 'break':'',
-\ 'case':'',
-\ 'class':'',
-\ 'const':'',
-\ 'continue':'',
-\ 'declare':'',
-\ 'default':'',
-\ 'do':'',
-\ 'echo':'',
-\ 'else':'',
-\ 'elseif':'',
-\ 'enddeclare':'',
-\ 'endfor':'',
-\ 'endforeach':'',
-\ 'endif':'',
-\ 'endswitch':'',
-\ 'endwhile':'',
-\ 'extends':'',
-\ 'for':'',
-\ 'foreach':'',
-\ 'function':'',
-\ 'global':'',
-\ 'if':'',
-\ 'new':'',
-\ 'static':'',
-\ 'switch':'',
-\ 'use':'',
-\ 'var':'',
-\ 'while':'',
-\ '__FUNCTION__':'',
-\ '__CLASS__':'',
-\ '__METHOD__':'',
-\ 'final':'',
-\ 'php_user_filter':'',
-\ 'interface':'',
-\ 'implements':'',
-\ 'public':'',
-\ 'private':'',
-\ 'protected':'',
-\ 'abstract':'',
-\ 'clone':'',
-\ 'try':'',
-\ 'catch':'',
-\ 'throw':'',
-\ 'cfunction':'',
-\ 'old_function':'',
-\ 'this':'',
-\ 'PHP_VERSION': '',
-\ 'PHP_OS': '',
-\ 'PHP_SAPI': '',
-\ 'PHP_EOL': '',
-\ 'PHP_INT_MAX': '',
-\ 'PHP_INT_SIZE': '',
-\ 'DEFAULT_INCLUDE_PATH': '',
-\ 'PEAR_INSTALL_DIR': '',
-\ 'PEAR_EXTENSION_DIR': '',
-\ 'PHP_EXTENSION_DIR': '',
-\ 'PHP_PREFIX': '',
-\ 'PHP_BINDIR': '',
-\ 'PHP_LIBDIR': '',
-\ 'PHP_DATADIR': '',
-\ 'PHP_SYSCONFDIR': '',
-\ 'PHP_LOCALSTATEDIR': '',
-\ 'PHP_CONFIG_FILE_PATH': '',
-\ 'PHP_CONFIG_FILE_SCAN_DIR': '',
-\ 'PHP_SHLIB_SUFFIX': '',
-\ 'PHP_OUTPUT_HANDLER_START': '',
-\ 'PHP_OUTPUT_HANDLER_CONT': '',
-\ 'PHP_OUTPUT_HANDLER_END': '',
-\ 'E_ERROR': '',
-\ 'E_WARNING': '',
-\ 'E_PARSE': '',
-\ 'E_NOTICE': '',
-\ 'E_CORE_ERROR': '',
-\ 'E_CORE_WARNING': '',
-\ 'E_COMPILE_ERROR': '',
-\ 'E_COMPILE_WARNING': '',
-\ 'E_USER_ERROR': '',
-\ 'E_USER_WARNING': '',
-\ 'E_USER_NOTICE': '',
-\ 'E_ALL': '',
-\ 'E_STRICT': '',
-\ '__COMPILER_HALT_OFFSET__': '',
-\ 'EXTR_OVERWRITE': '',
-\ 'EXTR_SKIP': '',
-\ 'EXTR_PREFIX_SAME': '',
-\ 'EXTR_PREFIX_ALL': '',
-\ 'EXTR_PREFIX_INVALID': '',
-\ 'EXTR_PREFIX_IF_EXISTS': '',
-\ 'EXTR_IF_EXISTS': '',
-\ 'SORT_ASC': '',
-\ 'SORT_DESC': '',
-\ 'SORT_REGULAR': '',
-\ 'SORT_NUMERIC': '',
-\ 'SORT_STRING': '',
-\ 'CASE_LOWER': '',
-\ 'CASE_UPPER': '',
-\ 'COUNT_NORMAL': '',
-\ 'COUNT_RECURSIVE': '',
-\ 'ASSERT_ACTIVE': '',
-\ 'ASSERT_CALLBACK': '',
-\ 'ASSERT_BAIL': '',
-\ 'ASSERT_WARNING': '',
-\ 'ASSERT_QUIET_EVAL': '',
-\ 'CONNECTION_ABORTED': '',
-\ 'CONNECTION_NORMAL': '',
-\ 'CONNECTION_TIMEOUT': '',
-\ 'INI_USER': '',
-\ 'INI_PERDIR': '',
-\ 'INI_SYSTEM': '',
-\ 'INI_ALL': '',
-\ 'M_E': '',
-\ 'M_LOG2E': '',
-\ 'M_LOG10E': '',
-\ 'M_LN2': '',
-\ 'M_LN10': '',
-\ 'M_PI': '',
-\ 'M_PI_2': '',
-\ 'M_PI_4': '',
-\ 'M_1_PI': '',
-\ 'M_2_PI': '',
-\ 'M_2_SQRTPI': '',
-\ 'M_SQRT2': '',
-\ 'M_SQRT1_2': '',
-\ 'CRYPT_SALT_LENGTH': '',
-\ 'CRYPT_STD_DES': '',
-\ 'CRYPT_EXT_DES': '',
-\ 'CRYPT_MD5': '',
-\ 'CRYPT_BLOWFISH': '',
-\ 'DIRECTORY_SEPARATOR': '',
-\ 'SEEK_SET': '',
-\ 'SEEK_CUR': '',
-\ 'SEEK_END': '',
-\ 'LOCK_SH': '',
-\ 'LOCK_EX': '',
-\ 'LOCK_UN': '',
-\ 'LOCK_NB': '',
-\ 'HTML_SPECIALCHARS': '',
-\ 'HTML_ENTITIES': '',
-\ 'ENT_COMPAT': '',
-\ 'ENT_QUOTES': '',
-\ 'ENT_NOQUOTES': '',
-\ 'INFO_GENERAL': '',
-\ 'INFO_CREDITS': '',
-\ 'INFO_CONFIGURATION': '',
-\ 'INFO_MODULES': '',
-\ 'INFO_ENVIRONMENT': '',
-\ 'INFO_VARIABLES': '',
-\ 'INFO_LICENSE': '',
-\ 'INFO_ALL': '',
-\ 'CREDITS_GROUP': '',
-\ 'CREDITS_GENERAL': '',
-\ 'CREDITS_SAPI': '',
-\ 'CREDITS_MODULES': '',
-\ 'CREDITS_DOCS': '',
-\ 'CREDITS_FULLPAGE': '',
-\ 'CREDITS_QA': '',
-\ 'CREDITS_ALL': '',
-\ 'STR_PAD_LEFT': '',
-\ 'STR_PAD_RIGHT': '',
-\ 'STR_PAD_BOTH': '',
-\ 'PATHINFO_DIRNAME': '',
-\ 'PATHINFO_BASENAME': '',
-\ 'PATHINFO_EXTENSION': '',
-\ 'PATH_SEPARATOR': '',
-\ 'CHAR_MAX': '',
-\ 'LC_CTYPE': '',
-\ 'LC_NUMERIC': '',
-\ 'LC_TIME': '',
-\ 'LC_COLLATE': '',
-\ 'LC_MONETARY': '',
-\ 'LC_ALL': '',
-\ 'LC_MESSAGES': '',
-\ 'ABDAY_1': '',
-\ 'ABDAY_2': '',
-\ 'ABDAY_3': '',
-\ 'ABDAY_4': '',
-\ 'ABDAY_5': '',
-\ 'ABDAY_6': '',
-\ 'ABDAY_7': '',
-\ 'DAY_1': '',
-\ 'DAY_2': '',
-\ 'DAY_3': '',
-\ 'DAY_4': '',
-\ 'DAY_5': '',
-\ 'DAY_6': '',
-\ 'DAY_7': '',
-\ 'ABMON_1': '',
-\ 'ABMON_2': '',
-\ 'ABMON_3': '',
-\ 'ABMON_4': '',
-\ 'ABMON_5': '',
-\ 'ABMON_6': '',
-\ 'ABMON_7': '',
-\ 'ABMON_8': '',
-\ 'ABMON_9': '',
-\ 'ABMON_10': '',
-\ 'ABMON_11': '',
-\ 'ABMON_12': '',
-\ 'MON_1': '',
-\ 'MON_2': '',
-\ 'MON_3': '',
-\ 'MON_4': '',
-\ 'MON_5': '',
-\ 'MON_6': '',
-\ 'MON_7': '',
-\ 'MON_8': '',
-\ 'MON_9': '',
-\ 'MON_10': '',
-\ 'MON_11': '',
-\ 'MON_12': '',
-\ 'AM_STR': '',
-\ 'PM_STR': '',
-\ 'D_T_FMT': '',
-\ 'D_FMT': '',
-\ 'T_FMT': '',
-\ 'T_FMT_AMPM': '',
-\ 'ERA': '',
-\ 'ERA_YEAR': '',
-\ 'ERA_D_T_FMT': '',
-\ 'ERA_D_FMT': '',
-\ 'ERA_T_FMT': '',
-\ 'ALT_DIGITS': '',
-\ 'INT_CURR_SYMBOL': '',
-\ 'CURRENCY_SYMBOL': '',
-\ 'CRNCYSTR': '',
-\ 'MON_DECIMAL_POINT': '',
-\ 'MON_THOUSANDS_SEP': '',
-\ 'MON_GROUPING': '',
-\ 'POSITIVE_SIGN': '',
-\ 'NEGATIVE_SIGN': '',
-\ 'INT_FRAC_DIGITS': '',
-\ 'FRAC_DIGITS': '',
-\ 'P_CS_PRECEDES': '',
-\ 'P_SEP_BY_SPACE': '',
-\ 'N_CS_PRECEDES': '',
-\ 'N_SEP_BY_SPACE': '',
-\ 'P_SIGN_POSN': '',
-\ 'N_SIGN_POSN': '',
-\ 'DECIMAL_POINT': '',
-\ 'RADIXCHAR': '',
-\ 'THOUSANDS_SEP': '',
-\ 'THOUSEP': '',
-\ 'GROUPING': '',
-\ 'YESEXPR': '',
-\ 'NOEXPR': '',
-\ 'YESSTR': '',
-\ 'NOSTR': '',
-\ 'CODESET': '',
-\ 'LOG_EMERG': '',
-\ 'LOG_ALERT': '',
-\ 'LOG_CRIT': '',
-\ 'LOG_ERR': '',
-\ 'LOG_WARNING': '',
-\ 'LOG_NOTICE': '',
-\ 'LOG_INFO': '',
-\ 'LOG_DEBUG': '',
-\ 'LOG_KERN': '',
-\ 'LOG_USER': '',
-\ 'LOG_MAIL': '',
-\ 'LOG_DAEMON': '',
-\ 'LOG_AUTH': '',
-\ 'LOG_SYSLOG': '',
-\ 'LOG_LPR': '',
-\ 'LOG_NEWS': '',
-\ 'LOG_UUCP': '',
-\ 'LOG_CRON': '',
-\ 'LOG_AUTHPRIV': '',
-\ 'LOG_LOCAL0': '',
-\ 'LOG_LOCAL1': '',
-\ 'LOG_LOCAL2': '',
-\ 'LOG_LOCAL3': '',
-\ 'LOG_LOCAL4': '',
-\ 'LOG_LOCAL5': '',
-\ 'LOG_LOCAL6': '',
-\ 'LOG_LOCAL7': '',
-\ 'LOG_PID': '',
-\ 'LOG_CONS': '',
-\ 'LOG_ODELAY': '',
-\ 'LOG_NDELAY': '',
-\ 'LOG_NOWAIT': '',
-\ 'LOG_PERROR': '',
-\ }
-" }}}
-" PHP builtin functions {{{
-" To create from scratch list of functions:
-" 1. Download multi html file PHP documentation
-" 2. run for i in `ls | grep "^function\."`; do grep -A4 Description $i >> funcs; done
-" 3. Open funcs in Vim and
-"    a) g/Description/normal! 5J
-"    b) remove all html tags (it will require few s/// and g//)
-"    c) :%s/^\([^[:space:]]\+\) \([^[:space:]]\+\) ( \(.*\))/\\ '\2(': '\3| \1',
-"       This will create Dictionary
-"    d) remove all /^[^\\] lines
-let g:php_builtin_functions = {
-\ 'abs(': 'mixed number | number',
-\ 'acosh(': 'float arg | float',
-\ 'acos(': 'float arg | float',
-\ 'addcslashes(': 'string str, string charlist | string',
-\ 'addslashes(': 'string str | string',
-\ 'aggregate(': 'object object, string class_name | void',
-\ 'aggregate_info(': 'object object | array',
-\ 'aggregate_methods_by_list(': 'object object, string class_name, array methods_list [, bool exclude] | void',
-\ 'aggregate_methods_by_regexp(': 'object object, string class_name, string regexp [, bool exclude] | void',
-\ 'aggregate_methods(': 'object object, string class_name | void',
-\ 'aggregate_properties_by_list(': 'object object, string class_name, array properties_list [, bool exclude] | void',
-\ 'aggregate_properties_by_regexp(': 'object object, string class_name, string regexp [, bool exclude] | void',
-\ 'aggregate_properties(': 'object object, string class_name | void',
-\ 'apache_child_terminate(': 'void  | bool',
-\ 'apache_getenv(': 'string variable [, bool walk_to_top] | string',
-\ 'apache_get_modules(': 'void  | array',
-\ 'apache_get_version(': 'void  | string',
-\ 'apache_lookup_uri(': 'string filename | object',
-\ 'apache_note(': 'string note_name [, string note_value] | string',
-\ 'apache_request_headers(': 'void  | array',
-\ 'apache_reset_timeout(': 'void  | bool',
-\ 'apache_response_headers(': 'void  | array',
-\ 'apache_setenv(': 'string variable, string value [, bool walk_to_top] | bool',
-\ 'apc_cache_info(': '[string cache_type] | array',
-\ 'apc_clear_cache(': '[string cache_type] | bool',
-\ 'apc_define_constants(': 'string key, array constants [, bool case_sensitive] | bool',
-\ 'apc_delete(': 'string key | bool',
-\ 'apc_fetch(': 'string key | mixed',
-\ 'apc_load_constants(': 'string key [, bool case_sensitive] | bool',
-\ 'apc_sma_info(': 'void  | array',
-\ 'apc_store(': 'string key, mixed var [, int ttl] | bool',
-\ 'apd_breakpoint(': 'int debug_level | bool',
-\ 'apd_callstack(': 'void  | array',
-\ 'apd_clunk(': 'string warning [, string delimiter] | void',
-\ 'apd_continue(': 'int debug_level | bool',
-\ 'apd_croak(': 'string warning [, string delimiter] | void',
-\ 'apd_dump_function_table(': 'void  | void',
-\ 'apd_dump_persistent_resources(': 'void  | array',
-\ 'apd_dump_regular_resources(': 'void  | array',
-\ 'apd_echo(': 'string output | bool',
-\ 'apd_get_active_symbols(': ' | array',
-\ 'apd_set_pprof_trace(': '[string dump_directory] | void',
-\ 'apd_set_session(': 'int debug_level | void',
-\ 'apd_set_session_trace(': 'int debug_level [, string dump_directory] | void',
-\ 'apd_set_socket_session_trace(': 'string ip_address_or_unix_socket_file, int socket_type, int port, int debug_level | bool',
-\ 'array_change_key_case(': 'array input [, int case] | array',
-\ 'array_chunk(': 'array input, int size [, bool preserve_keys] | array',
-\ 'array_combine(': 'array keys, array values | array',
-\ 'array_count_values(': 'array input | array',
-\ 'array_diff_assoc(': 'array array1, array array2 [, array ...] | array',
-\ 'array_diff(': 'array array1, array array2 [, array ...] | array',
-\ 'array_diff_key(': 'array array1, array array2 [, array ...] | array',
-\ 'array_diff_uassoc(': 'array array1, array array2 [, array ..., callback key_compare_func] | array',
-\ 'array_diff_ukey(': 'array array1, array array2 [, array ..., callback key_compare_func] | array',
-\ 'array_fill(': 'int start_index, int num, mixed value | array',
-\ 'array_filter(': 'array input [, callback callback] | array',
-\ 'array_flip(': 'array trans | array',
-\ 'array(': '[mixed ...] | array',
-\ 'array_intersect_assoc(': 'array array1, array array2 [, array ...] | array',
-\ 'array_intersect(': 'array array1, array array2 [, array ...] | array',
-\ 'array_intersect_key(': 'array array1, array array2 [, array ...] | array',
-\ 'array_intersect_uassoc(': 'array array1, array array2 [, array ..., callback key_compare_func] | array',
-\ 'array_intersect_ukey(': 'array array1, array array2 [, array ..., callback key_compare_func] | array',
-\ 'array_key_exists(': 'mixed key, array search | bool',
-\ 'array_keys(': 'array input [, mixed search_value [, bool strict]] | array',
-\ 'array_map(': 'callback callback, array arr1 [, array ...] | array',
-\ 'array_merge(': 'array array1 [, array array2 [, array ...]] | array',
-\ 'array_merge_recursive(': 'array array1 [, array ...] | array',
-\ 'array_multisort(': 'array ar1 [, mixed arg [, mixed ... [, array ...]]] | bool',
-\ 'array_pad(': 'array input, int pad_size, mixed pad_value | array',
-\ 'array_pop(': 'array &#38;array | mixed',
-\ 'array_product(': 'array array | number',
-\ 'array_push(': 'array &#38;array, mixed var [, mixed ...] | int',
-\ 'array_rand(': 'array input [, int num_req] | mixed',
-\ 'array_reduce(': 'array input, callback function [, int initial] | mixed',
-\ 'array_reverse(': 'array array [, bool preserve_keys] | array',
-\ 'array_search(': 'mixed needle, array haystack [, bool strict] | mixed',
-\ 'array_shift(': 'array &#38;array | mixed',
-\ 'array_slice(': 'array array, int offset [, int length [, bool preserve_keys]] | array',
-\ 'array_splice(': 'array &#38;input, int offset [, int length [, array replacement]] | array',
-\ 'array_sum(': 'array array | number',
-\ 'array_udiff_assoc(': 'array array1, array array2 [, array ..., callback data_compare_func] | array',
-\ 'array_udiff(': 'array array1, array array2 [, array ..., callback data_compare_func] | array',
-\ 'array_udiff_uassoc(': 'array array1, array array2 [, array ..., callback data_compare_func, callback key_compare_func] | array',
-\ 'array_uintersect_assoc(': 'array array1, array array2 [, array ..., callback data_compare_func] | array',
-\ 'array_uintersect(': 'array array1, array array2 [, array ..., callback data_compare_func] | array',
-\ 'array_uintersect_uassoc(': 'array array1, array array2 [, array ..., callback data_compare_func, callback key_compare_func] | array',
-\ 'array_unique(': 'array array | array',
-\ 'array_unshift(': 'array &#38;array, mixed var [, mixed ...] | int',
-\ 'array_values(': 'array input | array',
-\ 'array_walk(': 'array &#38;array, callback funcname [, mixed userdata] | bool',
-\ 'array_walk_recursive(': 'array &#38;input, callback funcname [, mixed userdata] | bool',
-\ 'arsort(': 'array &#38;array [, int sort_flags] | bool',
-\ 'ascii2ebcdic(': 'string ascii_str | int',
-\ 'asinh(': 'float arg | float',
-\ 'asin(': 'float arg | float',
-\ 'asort(': 'array &#38;array [, int sort_flags] | bool',
-\ 'aspell_check(': 'int dictionary_link, string word | bool',
-\ 'aspell_check_raw(': 'int dictionary_link, string word | bool',
-\ 'aspell_new(': 'string master [, string personal] | int',
-\ 'aspell_suggest(': 'int dictionary_link, string word | array',
-\ 'assert(': 'mixed assertion | bool',
-\ 'assert_options(': 'int what [, mixed value] | mixed',
-\ 'atan2(': 'float y, float x | float',
-\ 'atanh(': 'float arg | float',
-\ 'atan(': 'float arg | float',
-\ 'base64_decode(': 'string encoded_data | string',
-\ 'base64_encode(': 'string data | string',
-\ 'base_convert(': 'string number, int frombase, int tobase | string',
-\ 'basename(': 'string path [, string suffix] | string',
-\ 'bcadd(': 'string left_operand, string right_operand [, int scale] | string',
-\ 'bccomp(': 'string left_operand, string right_operand [, int scale] | int',
-\ 'bcdiv(': 'string left_operand, string right_operand [, int scale] | string',
-\ 'bcmod(': 'string left_operand, string modulus | string',
-\ 'bcmul(': 'string left_operand, string right_operand [, int scale] | string',
-\ 'bcompiler_load_exe(': 'string filename | bool',
-\ 'bcompiler_load(': 'string filename | bool',
-\ 'bcompiler_parse_class(': 'string class, string callback | bool',
-\ 'bcompiler_read(': 'resource filehandle | bool',
-\ 'bcompiler_write_class(': 'resource filehandle, string className [, string extends] | bool',
-\ 'bcompiler_write_constant(': 'resource filehandle, string constantName | bool',
-\ 'bcompiler_write_exe_footer(': 'resource filehandle, int startpos | bool',
-\ 'bcompiler_write_file(': 'resource filehandle, string filename | bool',
-\ 'bcompiler_write_footer(': 'resource filehandle | bool',
-\ 'bcompiler_write_function(': 'resource filehandle, string functionName | bool',
-\ 'bcompiler_write_functions_from_file(': 'resource filehandle, string fileName | bool',
-\ 'bcompiler_write_header(': 'resource filehandle [, string write_ver] | bool',
-\ 'bcpow(': 'string x, string y [, int scale] | string',
-\ 'bcpowmod(': 'string x, string y, string modulus [, int scale] | string',
-\ 'bcscale(': 'int scale | bool',
-\ 'bcsqrt(': 'string operand [, int scale] | string',
-\ 'bcsub(': 'string left_operand, string right_operand [, int scale] | string',
-\ 'bin2hex(': 'string str | string',
-\ 'bindec(': 'string binary_string | number',
-\ 'bind_textdomain_codeset(': 'string domain, string codeset | string',
-\ 'bindtextdomain(': 'string domain, string directory | string',
-\ 'bzclose(': 'resource bz | int',
-\ 'bzcompress(': 'string source [, int blocksize [, int workfactor]] | mixed',
-\ 'bzdecompress(': 'string source [, int small] | mixed',
-\ 'bzerrno(': 'resource bz | int',
-\ 'bzerror(': 'resource bz | array',
-\ 'bzerrstr(': 'resource bz | string',
-\ 'bzflush(': 'resource bz | int',
-\ 'bzopen(': 'string filename, string mode | resource',
-\ 'bzread(': 'resource bz [, int length] | string',
-\ 'bzwrite(': 'resource bz, string data [, int length] | int',
-\ 'cal_days_in_month(': 'int calendar, int month, int year | int',
-\ 'cal_from_jd(': 'int jd, int calendar | array',
-\ 'cal_info(': '[int calendar] | array',
-\ 'call_user_func_array(': 'callback function, array param_arr | mixed',
-\ 'call_user_func(': 'callback function [, mixed parameter [, mixed ...]] | mixed',
-\ 'call_user_method_array(': 'string method_name, object &#38;obj, array paramarr | mixed',
-\ 'call_user_method(': 'string method_name, object &#38;obj [, mixed parameter [, mixed ...]] | mixed',
-\ 'cal_to_jd(': 'int calendar, int month, int day, int year | int',
-\ 'ccvs_add(': 'string session, string invoice, string argtype, string argval | string',
-\ 'ccvs_auth(': 'string session, string invoice | string',
-\ 'ccvs_command(': 'string session, string type, string argval | string',
-\ 'ccvs_count(': 'string session, string type | int',
-\ 'ccvs_delete(': 'string session, string invoice | string',
-\ 'ccvs_done(': 'string sess | string',
-\ 'ccvs_init(': 'string name | string',
-\ 'ccvs_lookup(': 'string session, string invoice, int inum | string',
-\ 'ccvs_new(': 'string session, string invoice | string',
-\ 'ccvs_report(': 'string session, string type | string',
-\ 'ccvs_return(': 'string session, string invoice | string',
-\ 'ccvs_reverse(': 'string session, string invoice | string',
-\ 'ccvs_sale(': 'string session, string invoice | string',
-\ 'ccvs_status(': 'string session, string invoice | string',
-\ 'ccvs_textvalue(': 'string session | string',
-\ 'ccvs_void(': 'string session, string invoice | string',
-\ 'ceil(': 'float value | float',
-\ 'chdir(': 'string directory | bool',
-\ 'checkdate(': 'int month, int day, int year | bool',
-\ 'checkdnsrr(': 'string host [, string type] | int',
-\ 'chgrp(': 'string filename, mixed group | bool',
-\ 'chmod(': 'string filename, int mode | bool',
-\ 'chown(': 'string filename, mixed user | bool',
-\ 'chr(': 'int ascii | string',
-\ 'chroot(': 'string directory | bool',
-\ 'chunk_split(': 'string body [, int chunklen [, string end]] | string',
-\ 'class_exists(': 'string class_name [, bool autoload] | bool',
-\ 'class_implements(': 'mixed class [, bool autoload] | array',
-\ 'classkit_import(': 'string filename | array',
-\ 'classkit_method_add(': 'string classname, string methodname, string args, string code [, int flags] | bool',
-\ 'classkit_method_copy(': 'string dClass, string dMethod, string sClass [, string sMethod] | bool',
-\ 'classkit_method_redefine(': 'string classname, string methodname, string args, string code [, int flags] | bool',
-\ 'classkit_method_remove(': 'string classname, string methodname | bool',
-\ 'classkit_method_rename(': 'string classname, string methodname, string newname | bool',
-\ 'class_parents(': 'mixed class [, bool autoload] | array',
-\ 'clearstatcache(': 'void  | void',
-\ 'closedir(': 'resource dir_handle | void',
-\ 'closelog(': 'void  | bool',
-\ 'com_addref(': 'void  | void',
-\ 'com_create_guid(': 'void  | string',
-\ 'com_event_sink(': 'variant comobject, object sinkobject [, mixed sinkinterface] | bool',
-\ 'com_get_active_object(': 'string progid [, int code_page] | variant',
-\ 'com_get(': 'resource com_object, string property | mixed',
-\ 'com_invoke(': 'resource com_object, string function_name [, mixed function_parameters] | mixed',
-\ 'com_isenum(': 'variant com_module | bool',
-\ 'com_load(': 'string module_name [, string server_name [, int codepage]] | resource',
-\ 'com_load_typelib(': 'string typelib_name [, bool case_insensitive] | bool',
-\ 'com_message_pump(': '[int timeoutms] | bool',
-\ 'compact(': 'mixed varname [, mixed ...] | array',
-\ 'com_print_typeinfo(': 'object comobject [, string dispinterface [, bool wantsink]] | bool',
-\ 'com_release(': 'void  | void',
-\ 'com_set(': 'resource com_object, string property, mixed value | void',
-\ 'connection_aborted(': 'void  | int',
-\ 'connection_status(': 'void  | int',
-\ 'connection_timeout(': 'void  | bool',
-\ 'constant(': 'string name | mixed',
-\ 'convert_cyr_string(': 'string str, string from, string to | string',
-\ 'convert_uudecode(': 'string data | string',
-\ 'convert_uuencode(': 'string data | string',
-\ 'copy(': 'string source, string dest | bool',
-\ 'cosh(': 'float arg | float',
-\ 'cos(': 'float arg | float',
-\ 'count_chars(': 'string string [, int mode] | mixed',
-\ 'count(': 'mixed var [, int mode] | int',
-\ 'cpdf_add_annotation(': 'int pdf_document, float llx, float lly, float urx, float ury, string title, string content [, int mode] | bool',
-\ 'cpdf_add_outline(': 'int pdf_document, int lastoutline, int sublevel, int open, int pagenr, string text | int',
-\ 'cpdf_arc(': 'int pdf_document, float x_coor, float y_coor, float radius, float start, float end [, int mode] | bool',
-\ 'cpdf_begin_text(': 'int pdf_document | bool',
-\ 'cpdf_circle(': 'int pdf_document, float x_coor, float y_coor, float radius [, int mode] | bool',
-\ 'cpdf_clip(': 'int pdf_document | bool',
-\ 'cpdf_close(': 'int pdf_document | bool',
-\ 'cpdf_closepath_fill_stroke(': 'int pdf_document | bool',
-\ 'cpdf_closepath(': 'int pdf_document | bool',
-\ 'cpdf_closepath_stroke(': 'int pdf_document | bool',
-\ 'cpdf_continue_text(': 'int pdf_document, string text | bool',
-\ 'cpdf_curveto(': 'int pdf_document, float x1, float y1, float x2, float y2, float x3, float y3 [, int mode] | bool',
-\ 'cpdf_end_text(': 'int pdf_document | bool',
-\ 'cpdf_fill(': 'int pdf_document | bool',
-\ 'cpdf_fill_stroke(': 'int pdf_document | bool',
-\ 'cpdf_finalize(': 'int pdf_document | bool',
-\ 'cpdf_finalize_page(': 'int pdf_document, int page_number | bool',
-\ 'cpdf_global_set_document_limits(': 'int maxpages, int maxfonts, int maximages, int maxannotations, int maxobjects | bool',
-\ 'cpdf_import_jpeg(': 'int pdf_document, string file_name, float x_coor, float y_coor, float angle, float width, float height, float x_scale, float y_scale, int gsave [, int mode] | bool',
-\ 'cpdf_lineto(': 'int pdf_document, float x_coor, float y_coor [, int mode] | bool',
-\ 'cpdf_moveto(': 'int pdf_document, float x_coor, float y_coor [, int mode] | bool',
-\ 'cpdf_newpath(': 'int pdf_document | bool',
-\ 'cpdf_open(': 'int compression [, string filename [, array doc_limits]] | int',
-\ 'cpdf_output_buffer(': 'int pdf_document | bool',
-\ 'cpdf_page_init(': 'int pdf_document, int page_number, int orientation, float height, float width [, float unit] | bool',
-\ 'cpdf_place_inline_image(': 'int pdf_document, int image, float x_coor, float y_coor, float angle, float width, float height, int gsave [, int mode] | bool',
-\ 'cpdf_rect(': 'int pdf_document, float x_coor, float y_coor, float width, float height [, int mode] | bool',
-\ 'cpdf_restore(': 'int pdf_document | bool',
-\ 'cpdf_rlineto(': 'int pdf_document, float x_coor, float y_coor [, int mode] | bool',
-\ 'cpdf_rmoveto(': 'int pdf_document, float x_coor, float y_coor [, int mode] | bool',
-\ 'cpdf_rotate(': 'int pdf_document, float angle | bool',
-\ 'cpdf_rotate_text(': 'int pdfdoc, float angle | bool',
-\ 'cpdf_save(': 'int pdf_document | bool',
-\ 'cpdf_save_to_file(': 'int pdf_document, string filename | bool',
-\ 'cpdf_scale(': 'int pdf_document, float x_scale, float y_scale | bool',
-\ 'cpdf_set_action_url(': 'int pdfdoc, float xll, float yll, float xur, float xur, string url [, int mode] | bool',
-\ 'cpdf_set_char_spacing(': 'int pdf_document, float space | bool',
-\ 'cpdf_set_creator(': 'int pdf_document, string creator | bool',
-\ 'cpdf_set_current_page(': 'int pdf_document, int page_number | bool',
-\ 'cpdf_setdash(': 'int pdf_document, float white, float black | bool',
-\ 'cpdf_setflat(': 'int pdf_document, float value | bool',
-\ 'cpdf_set_font_directories(': 'int pdfdoc, string pfmdir, string pfbdir | bool',
-\ 'cpdf_set_font(': 'int pdf_document, string font_name, float size, string encoding | bool',
-\ 'cpdf_set_font_map_file(': 'int pdfdoc, string filename | bool',
-\ 'cpdf_setgray_fill(': 'int pdf_document, float value | bool',
-\ 'cpdf_setgray(': 'int pdf_document, float gray_value | bool',
-\ 'cpdf_setgray_stroke(': 'int pdf_document, float gray_value | bool',
-\ 'cpdf_set_horiz_scaling(': 'int pdf_document, float scale | bool',
-\ 'cpdf_set_keywords(': 'int pdf_document, string keywords | bool',
-\ 'cpdf_set_leading(': 'int pdf_document, float distance | bool',
-\ 'cpdf_setlinecap(': 'int pdf_document, int value | bool',
-\ 'cpdf_setlinejoin(': 'int pdf_document, int value | bool',
-\ 'cpdf_setlinewidth(': 'int pdf_document, float width | bool',
-\ 'cpdf_setmiterlimit(': 'int pdf_document, float value | bool',
-\ 'cpdf_set_page_animation(': 'int pdf_document, int transition, float duration, float direction, int orientation, int inout | bool',
-\ 'cpdf_setrgbcolor_fill(': 'int pdf_document, float red_value, float green_value, float blue_value | bool',
-\ 'cpdf_setrgbcolor(': 'int pdf_document, float red_value, float green_value, float blue_value | bool',
-\ 'cpdf_setrgbcolor_stroke(': 'int pdf_document, float red_value, float green_value, float blue_value | bool',
-\ 'cpdf_set_subject(': 'int pdf_document, string subject | bool',
-\ 'cpdf_set_text_matrix(': 'int pdf_document, array matrix | bool',
-\ 'cpdf_set_text_pos(': 'int pdf_document, float x_coor, float y_coor [, int mode] | bool',
-\ 'cpdf_set_text_rendering(': 'int pdf_document, int rendermode | bool',
-\ 'cpdf_set_text_rise(': 'int pdf_document, float value | bool',
-\ 'cpdf_set_title(': 'int pdf_document, string title | bool',
-\ 'cpdf_set_viewer_preferences(': 'int pdfdoc, array preferences | bool',
-\ 'cpdf_set_word_spacing(': 'int pdf_document, float space | bool',
-\ 'cpdf_show(': 'int pdf_document, string text | bool',
-\ 'cpdf_show_xy(': 'int pdf_document, string text, float x_coor, float y_coor [, int mode] | bool',
-\ 'cpdf_stringwidth(': 'int pdf_document, string text | float',
-\ 'cpdf_stroke(': 'int pdf_document | bool',
-\ 'cpdf_text(': 'int pdf_document, string text [, float x_coor, float y_coor [, int mode [, float orientation [, int alignmode]]]] | bool',
-\ 'cpdf_translate(': 'int pdf_document, float x_coor, float y_coor | bool',
-\ 'crack_check(': 'resource dictionary, string password | bool',
-\ 'crack_closedict(': '[resource dictionary] | bool',
-\ 'crack_getlastmessage(': 'void  | string',
-\ 'crack_opendict(': 'string dictionary | resource',
-\ 'crc32(': 'string str | int',
-\ 'create_function(': 'string args, string code | string',
-\ 'crypt(': 'string str [, string salt] | string',
-\ 'ctype_alnum(': 'string text | bool',
-\ 'ctype_alpha(': 'string text | bool',
-\ 'ctype_cntrl(': 'string text | bool',
-\ 'ctype_digit(': 'string text | bool',
-\ 'ctype_graph(': 'string text | bool',
-\ 'ctype_lower(': 'string text | bool',
-\ 'ctype_print(': 'string text | bool',
-\ 'ctype_punct(': 'string text | bool',
-\ 'ctype_space(': 'string text | bool',
-\ 'ctype_upper(': 'string text | bool',
-\ 'ctype_xdigit(': 'string text | bool',
-\ 'curl_close(': 'resource ch | void',
-\ 'curl_copy_handle(': 'resource ch | resource',
-\ 'curl_errno(': 'resource ch | int',
-\ 'curl_error(': 'resource ch | string',
-\ 'curl_exec(': 'resource ch | mixed',
-\ 'curl_getinfo(': 'resource ch [, int opt] | mixed',
-\ 'curl_init(': '[string url] | resource',
-\ 'curl_multi_add_handle(': 'resource mh, resource ch | int',
-\ 'curl_multi_close(': 'resource mh | void',
-\ 'curl_multi_exec(': 'resource mh, int &#38;still_running | int',
-\ 'curl_multi_getcontent(': 'resource ch | string',
-\ 'curl_multi_info_read(': 'resource mh | array',
-\ 'curl_multi_init(': 'void  | resource',
-\ 'curl_multi_remove_handle(': 'resource mh, resource ch | int',
-\ 'curl_multi_select(': 'resource mh [, float timeout] | int',
-\ 'curl_setopt(': 'resource ch, int option, mixed value | bool',
-\ 'curl_version(': '[int version] | array',
-\ 'current(': 'array &#38;array | mixed',
-\ 'cybercash_base64_decode(': 'string inbuff | string',
-\ 'cybercash_base64_encode(': 'string inbuff | string',
-\ 'cybercash_decr(': 'string wmk, string sk, string inbuff | array',
-\ 'cybercash_encr(': 'string wmk, string sk, string inbuff | array',
-\ 'cybermut_creerformulairecm(': 'string url_cm, string version, string tpe, string price, string ref_command, string text_free, string url_return, string url_return_ok, string url_return_err, string language, string code_company, string text_button | string',
-\ 'cybermut_creerreponsecm(': 'string sentence | string',
-\ 'cybermut_testmac(': 'string code_mac, string version, string tpe, string cdate, string price, string ref_command, string text_free, string code_return | bool',
-\ 'cyrus_authenticate(': 'resource connection [, string mechlist [, string service [, string user [, int minssf [, int maxssf [, string authname [, string password]]]]]]] | void',
-\ 'cyrus_bind(': 'resource connection, array callbacks | bool',
-\ 'cyrus_close(': 'resource connection | bool',
-\ 'cyrus_connect(': '[string host [, string port [, int flags]]] | resource',
-\ 'cyrus_query(': 'resource connection, string query | array',
-\ 'cyrus_unbind(': 'resource connection, string trigger_name | bool',
-\ 'date_default_timezone_get(': 'void  | string',
-\ 'date_default_timezone_set(': 'string timezone_identifier | bool',
-\ 'date(': 'string format [, int timestamp] | string',
-\ 'date_sunrise(': 'int timestamp [, int format [, float latitude [, float longitude [, float zenith [, float gmt_offset]]]]] | mixed',
-\ 'date_sunset(': 'int timestamp [, int format [, float latitude [, float longitude [, float zenith [, float gmt_offset]]]]] | mixed',
-\ 'db2_autocommit(': 'resource connection [, bool value] | mixed',
-\ 'db2_bind_param(': 'resource stmt, int parameter-number, string variable-name [, int parameter-type [, int data-type [, int precision [, int scale]]]] | bool',
-\ 'db2_client_info(': 'resource connection | object',
-\ 'db2_close(': 'resource connection | bool',
-\ 'db2_column_privileges(': 'resource connection [, string qualifier [, string schema [, string table-name [, string column-name]]]] | resource',
-\ 'db2_columns(': 'resource connection [, string qualifier [, string schema [, string table-name [, string column-name]]]] | resource',
-\ 'db2_commit(': 'resource connection | bool',
-\ 'db2_connect(': 'string database, string username, string password [, array options] | resource',
-\ 'db2_conn_error(': '[resource connection] | string',
-\ 'db2_conn_errormsg(': '[resource connection] | string',
-\ 'db2_cursor_type(': 'resource stmt | int',
-\ 'db2_exec(': 'resource connection, string statement [, array options] | resource',
-\ 'db2_execute(': 'resource stmt [, array parameters] | bool',
-\ 'db2_fetch_array(': 'resource stmt [, int row_number] | array',
-\ 'db2_fetch_assoc(': 'resource stmt [, int row_number] | array',
-\ 'db2_fetch_both(': 'resource stmt [, int row_number] | array',
-\ 'db2_fetch_object(': 'resource stmt [, int row_number] | object',
-\ 'db2_fetch_row(': 'resource stmt [, int row_number] | bool',
-\ 'db2_field_display_size(': 'resource stmt, mixed column | int',
-\ 'db2_field_name(': 'resource stmt, mixed column | string',
-\ 'db2_field_num(': 'resource stmt, mixed column | int',
-\ 'db2_field_precision(': 'resource stmt, mixed column | int',
-\ 'db2_field_scale(': 'resource stmt, mixed column | int',
-\ 'db2_field_type(': 'resource stmt, mixed column | string',
-\ 'db2_field_width(': 'resource stmt, mixed column | int',
-\ 'db2_foreign_keys(': 'resource connection, string qualifier, string schema, string table-name | resource',
-\ 'db2_free_result(': 'resource stmt | bool',
-\ 'db2_free_stmt(': 'resource stmt | bool',
-\ 'db2_next_result(': 'resource stmt | resource',
-\ 'db2_num_fields(': 'resource stmt | int',
-\ 'db2_num_rows(': 'resource stmt | int',
-\ 'db2_pconnect(': 'string database, string username, string password [, array options] | resource',
-\ 'db2_prepare(': 'resource connection, string statement [, array options] | resource',
-\ 'db2_primary_keys(': 'resource connection, string qualifier, string schema, string table-name | resource',
-\ 'db2_procedure_columns(': 'resource connection, string qualifier, string schema, string procedure, string parameter | resource',
-\ 'db2_procedures(': 'resource connection, string qualifier, string schema, string procedure | resource',
-\ 'db2_result(': 'resource stmt, mixed column | mixed',
-\ 'db2_rollback(': 'resource connection | bool',
-\ 'db2_server_info(': 'resource connection | object',
-\ 'db2_special_columns(': 'resource connection, string qualifier, string schema, string table_name, int scope | resource',
-\ 'db2_statistics(': 'resource connection, string qualifier, string schema, string table-name, bool unique | resource',
-\ 'db2_stmt_error(': '[resource stmt] | string',
-\ 'db2_stmt_errormsg(': '[resource stmt] | string',
-\ 'db2_table_privileges(': 'resource connection [, string qualifier [, string schema [, string table_name]]] | resource',
-\ 'db2_tables(': 'resource connection [, string qualifier [, string schema [, string table-name [, string table-type]]]] | resource',
-\ 'dba_close(': 'resource handle | void',
-\ 'dba_delete(': 'string key, resource handle | bool',
-\ 'dba_exists(': 'string key, resource handle | bool',
-\ 'dba_fetch(': 'string key, resource handle | string',
-\ 'dba_firstkey(': 'resource handle | string',
-\ 'dba_handlers(': '[bool full_info] | array',
-\ 'dba_insert(': 'string key, string value, resource handle | bool',
-\ 'dba_key_split(': 'mixed key | mixed',
-\ 'dba_list(': 'void  | array',
-\ 'dba_nextkey(': 'resource handle | string',
-\ 'dba_open(': 'string path, string mode [, string handler [, mixed ...]] | resource',
-\ 'dba_optimize(': 'resource handle | bool',
-\ 'dba_popen(': 'string path, string mode [, string handler [, mixed ...]] | resource',
-\ 'dba_replace(': 'string key, string value, resource handle | bool',
-\ 'dbase_add_record(': 'int dbase_identifier, array record | bool',
-\ 'dbase_close(': 'int dbase_identifier | bool',
-\ 'dbase_create(': 'string filename, array fields | int',
-\ 'dbase_delete_record(': 'int dbase_identifier, int record_number | bool',
-\ 'dbase_get_header_info(': 'int dbase_identifier | array',
-\ 'dbase_get_record(': 'int dbase_identifier, int record_number | array',
-\ 'dbase_get_record_with_names(': 'int dbase_identifier, int record_number | array',
-\ 'dbase_numfields(': 'int dbase_identifier | int',
-\ 'dbase_numrecords(': 'int dbase_identifier | int',
-\ 'dbase_open(': 'string filename, int mode | int',
-\ 'dbase_pack(': 'int dbase_identifier | bool',
-\ 'dbase_replace_record(': 'int dbase_identifier, array record, int record_number | bool',
-\ 'dba_sync(': 'resource handle | bool',
-\ 'dblist(': 'void  | string',
-\ 'dbmclose(': 'resource dbm_identifier | bool',
-\ 'dbmdelete(': 'resource dbm_identifier, string key | bool',
-\ 'dbmexists(': 'resource dbm_identifier, string key | bool',
-\ 'dbmfetch(': 'resource dbm_identifier, string key | string',
-\ 'dbmfirstkey(': 'resource dbm_identifier | string',
-\ 'dbminsert(': 'resource dbm_identifier, string key, string value | int',
-\ 'dbmnextkey(': 'resource dbm_identifier, string key | string',
-\ 'dbmopen(': 'string filename, string flags | resource',
-\ 'dbmreplace(': 'resource dbm_identifier, string key, string value | int',
-\ 'dbplus_add(': 'resource relation, array tuple | int',
-\ 'dbplus_aql(': 'string query [, string server [, string dbpath]] | resource',
-\ 'dbplus_chdir(': '[string newdir] | string',
-\ 'dbplus_close(': 'resource relation | mixed',
-\ 'dbplus_curr(': 'resource relation, array &#38;tuple | int',
-\ 'dbplus_errcode(': '[int errno] | string',
-\ 'dbplus_errno(': 'void  | int',
-\ 'dbplus_find(': 'resource relation, array constraints, mixed tuple | int',
-\ 'dbplus_first(': 'resource relation, array &#38;tuple | int',
-\ 'dbplus_flush(': 'resource relation | int',
-\ 'dbplus_freealllocks(': 'void  | int',
-\ 'dbplus_freelock(': 'resource relation, string tname | int',
-\ 'dbplus_freerlocks(': 'resource relation | int',
-\ 'dbplus_getlock(': 'resource relation, string tname | int',
-\ 'dbplus_getunique(': 'resource relation, int uniqueid | int',
-\ 'dbplus_info(': 'resource relation, string key, array &#38;result | int',
-\ 'dbplus_last(': 'resource relation, array &#38;tuple | int',
-\ 'dbplus_lockrel(': 'resource relation | int',
-\ 'dbplus_next(': 'resource relation, array &#38;tuple | int',
-\ 'dbplus_open(': 'string name | resource',
-\ 'dbplus_prev(': 'resource relation, array &#38;tuple | int',
-\ 'dbplus_rchperm(': 'resource relation, int mask, string user, string group | int',
-\ 'dbplus_rcreate(': 'string name, mixed domlist [, bool overwrite] | resource',
-\ 'dbplus_rcrtexact(': 'string name, resource relation [, bool overwrite] | mixed',
-\ 'dbplus_rcrtlike(': 'string name, resource relation [, int overwrite] | mixed',
-\ 'dbplus_resolve(': 'string relation_name | array',
-\ 'dbplus_restorepos(': 'resource relation, array tuple | int',
-\ 'dbplus_rkeys(': 'resource relation, mixed domlist | mixed',
-\ 'dbplus_ropen(': 'string name | resource',
-\ 'dbplus_rquery(': 'string query [, string dbpath] | resource',
-\ 'dbplus_rrename(': 'resource relation, string name | int',
-\ 'dbplus_rsecindex(': 'resource relation, mixed domlist, int type | mixed',
-\ 'dbplus_runlink(': 'resource relation | int',
-\ 'dbplus_rzap(': 'resource relation | int',
-\ 'dbplus_savepos(': 'resource relation | int',
-\ 'dbplus_setindexbynumber(': 'resource relation, int idx_number | int',
-\ 'dbplus_setindex(': 'resource relation, string idx_name | int',
-\ 'dbplus_sql(': 'string query [, string server [, string dbpath]] | resource',
-\ 'dbplus_tcl(': 'int sid, string script | string',
-\ 'dbplus_tremove(': 'resource relation, array tuple [, array &#38;current] | int',
-\ 'dbplus_undo(': 'resource relation | int',
-\ 'dbplus_undoprepare(': 'resource relation | int',
-\ 'dbplus_unlockrel(': 'resource relation | int',
-\ 'dbplus_unselect(': 'resource relation | int',
-\ 'dbplus_update(': 'resource relation, array old, array new | int',
-\ 'dbplus_xlockrel(': 'resource relation | int',
-\ 'dbplus_xunlockrel(': 'resource relation | int',
-\ 'dbx_close(': 'object link_identifier | bool',
-\ 'dbx_compare(': 'array row_a, array row_b, string column_key [, int flags] | int',
-\ 'dbx_connect(': 'mixed module, string host, string database, string username, string password [, int persistent] | object',
-\ 'dbx_error(': 'object link_identifier | string',
-\ 'dbx_escape_string(': 'object link_identifier, string text | string',
-\ 'dbx_fetch_row(': 'object result_identifier | mixed',
-\ 'dbx_query(': 'object link_identifier, string sql_statement [, int flags] | mixed',
-\ 'dbx_sort(': 'object result, string user_compare_function | bool',
-\ 'dcgettext(': 'string domain, string message, int category | string',
-\ 'dcngettext(': 'string domain, string msgid1, string msgid2, int n, int category | string',
-\ 'deaggregate(': 'object object [, string class_name] | void',
-\ 'debug_backtrace(': 'void  | array',
-\ 'debugger_off(': 'void  | int',
-\ 'debugger_on(': 'string address | int',
-\ 'debug_print_backtrace(': 'void  | void',
-\ 'debug_zval_dump(': 'mixed variable | void',
-\ 'decbin(': 'int number | string',
-\ 'dechex(': 'int number | string',
-\ 'decoct(': 'int number | string',
-\ 'defined(': 'string name | bool',
-\ 'define(': 'string name, mixed value [, bool case_insensitive] | bool',
-\ 'define_syslog_variables(': 'void  | void',
-\ 'deg2rad(': 'float number | float',
-\ 'delete(': 'string file | void',
-\ 'dgettext(': 'string domain, string message | string',
-\ 'dio_close(': 'resource fd | void',
-\ 'dio_fcntl(': 'resource fd, int cmd [, mixed args] | mixed',
-\ 'dio_open(': 'string filename, int flags [, int mode] | resource',
-\ 'dio_read(': 'resource fd [, int len] | string',
-\ 'dio_seek(': 'resource fd, int pos [, int whence] | int',
-\ 'dio_stat(': 'resource fd | array',
-\ 'dio_tcsetattr(': 'resource fd, array options | bool',
-\ 'dio_truncate(': 'resource fd, int offset | bool',
-\ 'dio_write(': 'resource fd, string data [, int len] | int',
-\ 'dirname(': 'string path | string',
-\ 'disk_free_space(': 'string directory | float',
-\ 'disk_total_space(': 'string directory | float',
-\ 'dl(': 'string library | int',
-\ 'dngettext(': 'string domain, string msgid1, string msgid2, int n | string',
-\ 'dns_check_record(': 'string host [, string type] | bool',
-\ 'dns_get_mx(': 'string hostname, array &#38;mxhosts [, array &#38;weight] | bool',
-\ 'dns_get_record(': 'string hostname [, int type [, array &#38;authns, array &#38;addtl]] | array',
-\ 'DomDocument-&#62;add_root(': 'string name | domelement',
-\ 'DomDocument-&#62;create_attribute(': 'string name, string value | domattribute',
-\ 'DomDocument-&#62;create_cdata_section(': 'string content | domcdata',
-\ 'DomDocument-&#62;create_comment(': 'string content | domcomment',
-\ 'DomDocument-&#62;create_element(': 'string name | domelement',
-\ 'DomDocument-&#62;create_element_ns(': 'string uri, string name [, string prefix] | domelement',
-\ 'DomDocument-&#62;create_entity_reference(': 'string content | domentityreference',
-\ 'DomDocument-&#62;create_processing_instruction(': 'string content | domprocessinginstruction',
-\ 'DomDocument-&#62;create_text_node(': 'string content | domtext',
-\ 'DomDocument-&#62;doctype(': 'void  | domdocumenttype',
-\ 'DomDocument-&#62;document_element(': 'void  | domelement',
-\ 'DomDocument-&#62;dump_file(': 'string filename [, bool compressionmode [, bool format]] | string',
-\ 'DomDocument-&#62;dump_mem(': '[bool format [, string encoding]] | string',
-\ 'DomDocument-&#62;get_element_by_id(': 'string id | domelement',
-\ 'DomDocument-&#62;get_elements_by_tagname(': 'string name | array',
-\ 'DomDocument-&#62;html_dump_mem(': 'void  | string',
-\ 'DomDocument-&#62;xinclude(': 'void  | int',
-\ 'dom_import_simplexml(': 'SimpleXMLElement node | DOMElement',
-\ 'DomNode-&#62;append_sibling(': 'domelement newnode | domelement',
-\ 'DomNode-&#62;attributes(': 'void  | array',
-\ 'DomNode-&#62;child_nodes(': 'void  | array',
-\ 'DomNode-&#62;clone_node(': 'void  | domelement',
-\ 'DomNode-&#62;dump_node(': 'void  | string',
-\ 'DomNode-&#62;first_child(': 'void  | domelement',
-\ 'DomNode-&#62;get_content(': 'void  | string',
-\ 'DomNode-&#62;has_attributes(': 'void  | bool',
-\ 'DomNode-&#62;has_child_nodes(': 'void  | bool',
-\ 'DomNode-&#62;insert_before(': 'domelement newnode, domelement refnode | domelement',
-\ 'DomNode-&#62;is_blank_node(': 'void  | bool',
-\ 'DomNode-&#62;last_child(': 'void  | domelement',
-\ 'DomNode-&#62;next_sibling(': 'void  | domelement',
-\ 'DomNode-&#62;node_name(': 'void  | string',
-\ 'DomNode-&#62;node_type(': 'void  | int',
-\ 'DomNode-&#62;node_value(': 'void  | string',
-\ 'DomNode-&#62;owner_document(': 'void  | domdocument',
-\ 'DomNode-&#62;parent_node(': 'void  | domnode',
-\ 'DomNode-&#62;prefix(': 'void  | string',
-\ 'DomNode-&#62;previous_sibling(': 'void  | domelement',
-\ 'DomNode-&#62;remove_child(': 'domtext oldchild | domtext',
-\ 'DomNode-&#62;replace_child(': 'domelement oldnode, domelement newnode | domelement',
-\ 'DomNode-&#62;replace_node(': 'domelement newnode | domelement',
-\ 'DomNode-&#62;set_content(': 'string content | bool',
-\ 'DomNode-&#62;set_name(': 'void  | bool',
-\ 'DomNode-&#62;set_namespace(': 'string uri [, string prefix] | void',
-\ 'DomNode-&#62;unlink_node(': 'void  | void',
-\ 'domxml_new_doc(': 'string version | DomDocument',
-\ 'domxml_open_file(': 'string filename [, int mode [, array &#38;error]] | DomDocument',
-\ 'domxml_open_mem(': 'string str [, int mode [, array &#38;error]] | DomDocument',
-\ 'domxml_version(': 'void  | string',
-\ 'domxml_xmltree(': 'string str | DomDocument',
-\ 'domxml_xslt_stylesheet_doc(': 'DomDocument xsl_doc | DomXsltStylesheet',
-\ 'domxml_xslt_stylesheet_file(': 'string xsl_file | DomXsltStylesheet',
-\ 'domxml_xslt_stylesheet(': 'string xsl_buf | DomXsltStylesheet',
-\ 'domxml_xslt_version(': 'void  | int',
-\ 'dotnet_load(': 'string assembly_name [, string datatype_name [, int codepage]] | int',
-\ 'each(': 'array &#38;array | array',
-\ 'easter_date(': '[int year] | int',
-\ 'easter_days(': '[int year [, int method]] | int',
-\ 'ebcdic2ascii(': 'string ebcdic_str | int',
-\ 'echo(': 'string arg1 [, string ...] | void',
-\ 'empty(': 'mixed var | bool',
-\ 'end(': 'array &#38;array | mixed',
-\ 'ereg(': 'string pattern, string string [, array &#38;regs] | int',
-\ 'eregi(': 'string pattern, string string [, array &#38;regs] | int',
-\ 'eregi_replace(': 'string pattern, string replacement, string string | string',
-\ 'ereg_replace(': 'string pattern, string replacement, string string | string',
-\ 'error_log(': 'string message [, int message_type [, string destination [, string extra_headers]]] | bool',
-\ 'error_reporting(': '[int level] | int',
-\ 'escapeshellarg(': 'string arg | string',
-\ 'escapeshellcmd(': 'string command | string',
-\ 'eval(': 'string code_str | mixed',
-\ 'exec(': 'string command [, array &#38;output [, int &#38;return_var]] | string',
-\ 'exif_imagetype(': 'string filename | int',
-\ 'exif_read_data(': 'string filename [, string sections [, bool arrays [, bool thumbnail]]] | array',
-\ 'exif_tagname(': 'string index | string',
-\ 'exif_thumbnail(': 'string filename [, int &#38;width [, int &#38;height [, int &#38;imagetype]]] | string',
-\ 'exit(': '[string status] | void',
-\ 'expect_expectl(': 'resource expect, array cases, string &#38;match | mixed',
-\ 'expect_popen(': 'string command | resource',
-\ 'exp(': 'float arg | float',
-\ 'explode(': 'string separator, string string [, int limit] | array',
-\ 'expm1(': 'float number | float',
-\ 'extension_loaded(': 'string name | bool',
-\ 'extract(': 'array var_array [, int extract_type [, string prefix]] | int',
-\ 'ezmlm_hash(': 'string addr | int',
-\ 'fam_cancel_monitor(': 'resource fam, resource fam_monitor | bool',
-\ 'fam_close(': 'resource fam | void',
-\ 'fam_monitor_collection(': 'resource fam, string dirname, int depth, string mask | resource',
-\ 'fam_monitor_directory(': 'resource fam, string dirname | resource',
-\ 'fam_monitor_file(': 'resource fam, string filename | resource',
-\ 'fam_next_event(': 'resource fam | array',
-\ 'fam_open(': '[string appname] | resource',
-\ 'fam_pending(': 'resource fam | int',
-\ 'fam_resume_monitor(': 'resource fam, resource fam_monitor | bool',
-\ 'fam_suspend_monitor(': 'resource fam, resource fam_monitor | bool',
-\ 'fbsql_affected_rows(': '[resource link_identifier] | int',
-\ 'fbsql_autocommit(': 'resource link_identifier [, bool OnOff] | bool',
-\ 'fbsql_blob_size(': 'string blob_handle [, resource link_identifier] | int',
-\ 'fbsql_change_user(': 'string user, string password [, string database [, resource link_identifier]] | resource',
-\ 'fbsql_clob_size(': 'string clob_handle [, resource link_identifier] | int',
-\ 'fbsql_close(': '[resource link_identifier] | bool',
-\ 'fbsql_commit(': '[resource link_identifier] | bool',
-\ 'fbsql_connect(': '[string hostname [, string username [, string password]]] | resource',
-\ 'fbsql_create_blob(': 'string blob_data [, resource link_identifier] | string',
-\ 'fbsql_create_clob(': 'string clob_data [, resource link_identifier] | string',
-\ 'fbsql_create_db(': 'string database_name [, resource link_identifier [, string database_options]] | bool',
-\ 'fbsql_database(': 'resource link_identifier [, string database] | string',
-\ 'fbsql_database_password(': 'resource link_identifier [, string database_password] | string',
-\ 'fbsql_data_seek(': 'resource result_identifier, int row_number | bool',
-\ 'fbsql_db_query(': 'string database, string query [, resource link_identifier] | resource',
-\ 'fbsql_db_status(': 'string database_name [, resource link_identifier] | int',
-\ 'fbsql_drop_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'fbsql_errno(': '[resource link_identifier] | int',
-\ 'fbsql_error(': '[resource link_identifier] | string',
-\ 'fbsql_fetch_array(': 'resource result [, int result_type] | array',
-\ 'fbsql_fetch_assoc(': 'resource result | array',
-\ 'fbsql_fetch_field(': 'resource result [, int field_offset] | object',
-\ 'fbsql_fetch_lengths(': 'resource result | array',
-\ 'fbsql_fetch_object(': 'resource result [, int result_type] | object',
-\ 'fbsql_fetch_row(': 'resource result | array',
-\ 'fbsql_field_flags(': 'resource result [, int field_offset] | string',
-\ 'fbsql_field_len(': 'resource result [, int field_offset] | int',
-\ 'fbsql_field_name(': 'resource result [, int field_index] | string',
-\ 'fbsql_field_seek(': 'resource result [, int field_offset] | bool',
-\ 'fbsql_field_table(': 'resource result [, int field_offset] | string',
-\ 'fbsql_field_type(': 'resource result [, int field_offset] | string',
-\ 'fbsql_free_result(': 'resource result | bool',
-\ 'fbsql_get_autostart_info(': '[resource link_identifier] | array',
-\ 'fbsql_hostname(': 'resource link_identifier [, string host_name] | string',
-\ 'fbsql_insert_id(': '[resource link_identifier] | int',
-\ 'fbsql_list_dbs(': '[resource link_identifier] | resource',
-\ 'fbsql_list_fields(': 'string database_name, string table_name [, resource link_identifier] | resource',
-\ 'fbsql_list_tables(': 'string database [, resource link_identifier] | resource',
-\ 'fbsql_next_result(': 'resource result_id | bool',
-\ 'fbsql_num_fields(': 'resource result | int',
-\ 'fbsql_num_rows(': 'resource result | int',
-\ 'fbsql_password(': 'resource link_identifier [, string password] | string',
-\ 'fbsql_pconnect(': '[string hostname [, string username [, string password]]] | resource',
-\ 'fbsql_query(': 'string query [, resource link_identifier [, int batch_size]] | resource',
-\ 'fbsql_read_blob(': 'string blob_handle [, resource link_identifier] | string',
-\ 'fbsql_read_clob(': 'string clob_handle [, resource link_identifier] | string',
-\ 'fbsql_result(': 'resource result [, int row [, mixed field]] | mixed',
-\ 'fbsql_rollback(': '[resource link_identifier] | bool',
-\ 'fbsql_select_db(': '[string database_name [, resource link_identifier]] | bool',
-\ 'fbsql_set_lob_mode(': 'resource result, string database_name | bool',
-\ 'fbsql_set_password(': 'resource link_identifier, string user, string password, string old_password | bool',
-\ 'fbsql_set_transaction(': 'resource link_identifier, int Locking, int Isolation | void',
-\ 'fbsql_start_db(': 'string database_name [, resource link_identifier [, string database_options]] | bool',
-\ 'fbsql_stop_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'fbsql_tablename(': 'resource result, int i | string',
-\ 'fbsql_username(': 'resource link_identifier [, string username] | string',
-\ 'fbsql_warnings(': '[bool OnOff] | bool',
-\ 'fclose(': 'resource handle | bool',
-\ 'fdf_add_doc_javascript(': 'resource fdfdoc, string script_name, string script_code | bool',
-\ 'fdf_add_template(': 'resource fdfdoc, int newpage, string filename, string template, int rename | bool',
-\ 'fdf_close(': 'resource fdf_document | void',
-\ 'fdf_create(': 'void  | resource',
-\ 'fdf_enum_values(': 'resource fdfdoc, callback function [, mixed userdata] | bool',
-\ 'fdf_errno(': 'void  | int',
-\ 'fdf_error(': '[int error_code] | string',
-\ 'fdf_get_ap(': 'resource fdf_document, string field, int face, string filename | bool',
-\ 'fdf_get_attachment(': 'resource fdf_document, string fieldname, string savepath | array',
-\ 'fdf_get_encoding(': 'resource fdf_document | string',
-\ 'fdf_get_file(': 'resource fdf_document | string',
-\ 'fdf_get_flags(': 'resource fdfdoc, string fieldname, int whichflags | int',
-\ 'fdf_get_opt(': 'resource fdfdof, string fieldname [, int element] | mixed',
-\ 'fdf_get_status(': 'resource fdf_document | string',
-\ 'fdf_get_value(': 'resource fdf_document, string fieldname [, int which] | mixed',
-\ 'fdf_get_version(': '[resource fdf_document] | string',
-\ 'fdf_header(': 'void  | void',
-\ 'fdf_next_field_name(': 'resource fdf_document [, string fieldname] | string',
-\ 'fdf_open(': 'string filename | resource',
-\ 'fdf_open_string(': 'string fdf_data | resource',
-\ 'fdf_remove_item(': 'resource fdfdoc, string fieldname, int item | bool',
-\ 'fdf_save(': 'resource fdf_document [, string filename] | bool',
-\ 'fdf_save_string(': 'resource fdf_document | string',
-\ 'fdf_set_ap(': 'resource fdf_document, string field_name, int face, string filename, int page_number | bool',
-\ 'fdf_set_encoding(': 'resource fdf_document, string encoding | bool',
-\ 'fdf_set_file(': 'resource fdf_document, string url [, string target_frame] | bool',
-\ 'fdf_set_flags(': 'resource fdf_document, string fieldname, int whichFlags, int newFlags | bool',
-\ 'fdf_set_javascript_action(': 'resource fdf_document, string fieldname, int trigger, string script | bool',
-\ 'fdf_set_on_import_javascript(': 'resource fdfdoc, string script, bool before_data_import | bool',
-\ 'fdf_set_opt(': 'resource fdf_document, string fieldname, int element, string str1, string str2 | bool',
-\ 'fdf_set_status(': 'resource fdf_document, string status | bool',
-\ 'fdf_set_submit_form_action(': 'resource fdf_document, string fieldname, int trigger, string script, int flags | bool',
-\ 'fdf_set_target_frame(': 'resource fdf_document, string frame_name | bool',
-\ 'fdf_set_value(': 'resource fdf_document, string fieldname, mixed value [, int isName] | bool',
-\ 'fdf_set_version(': 'resource fdf_document, string version | bool',
-\ 'feof(': 'resource handle | bool',
-\ 'fflush(': 'resource handle | bool',
-\ 'fgetc(': 'resource handle | string',
-\ 'fgetcsv(': 'resource handle [, int length [, string delimiter [, string enclosure]]] | array',
-\ 'fgets(': 'resource handle [, int length] | string',
-\ 'fgetss(': 'resource handle [, int length [, string allowable_tags]] | string',
-\ 'fileatime(': 'string filename | int',
-\ 'filectime(': 'string filename | int',
-\ 'file_exists(': 'string filename | bool',
-\ 'file_get_contents(': 'string filename [, bool use_include_path [, resource context [, int offset [, int maxlen]]]] | string',
-\ 'filegroup(': 'string filename | int',
-\ 'file(': 'string filename [, int use_include_path [, resource context]] | array',
-\ 'fileinode(': 'string filename | int',
-\ 'filemtime(': 'string filename | int',
-\ 'fileowner(': 'string filename | int',
-\ 'fileperms(': 'string filename | int',
-\ 'filepro_fieldcount(': 'void  | int',
-\ 'filepro_fieldname(': 'int field_number | string',
-\ 'filepro_fieldtype(': 'int field_number | string',
-\ 'filepro_fieldwidth(': 'int field_number | int',
-\ 'filepro(': 'string directory | bool',
-\ 'filepro_retrieve(': 'int row_number, int field_number | string',
-\ 'filepro_rowcount(': 'void  | int',
-\ 'file_put_contents(': 'string filename, mixed data [, int flags [, resource context]] | int',
-\ 'filesize(': 'string filename | int',
-\ 'filetype(': 'string filename | string',
-\ 'floatval(': 'mixed var | float',
-\ 'flock(': 'resource handle, int operation [, int &#38;wouldblock] | bool',
-\ 'floor(': 'float value | float',
-\ 'flush(': 'void  | void',
-\ 'fmod(': 'float x, float y | float',
-\ 'fnmatch(': 'string pattern, string string [, int flags] | bool',
-\ 'fopen(': 'string filename, string mode [, bool use_include_path [, resource zcontext]] | resource',
-\ 'fpassthru(': 'resource handle | int',
-\ 'fprintf(': 'resource handle, string format [, mixed args [, mixed ...]] | int',
-\ 'fputcsv(': 'resource handle [, array fields [, string delimiter [, string enclosure]]] | int',
-\ 'fread(': 'resource handle, int length | string',
-\ 'frenchtojd(': 'int month, int day, int year | int',
-\ 'fribidi_log2vis(': 'string str, string direction, int charset | string',
-\ 'fscanf(': 'resource handle, string format [, mixed &#38;...] | mixed',
-\ 'fseek(': 'resource handle, int offset [, int whence] | int',
-\ 'fsockopen(': 'string target [, int port [, int &#38;errno [, string &#38;errstr [, float timeout]]]] | resource',
-\ 'fstat(': 'resource handle | array',
-\ 'ftell(': 'resource handle | int',
-\ 'ftok(': 'string pathname, string proj | int',
-\ 'ftp_alloc(': 'resource ftp_stream, int filesize [, string &#38;result] | bool',
-\ 'ftp_cdup(': 'resource ftp_stream | bool',
-\ 'ftp_chdir(': 'resource ftp_stream, string directory | bool',
-\ 'ftp_chmod(': 'resource ftp_stream, int mode, string filename | int',
-\ 'ftp_close(': 'resource ftp_stream | bool',
-\ 'ftp_connect(': 'string host [, int port [, int timeout]] | resource',
-\ 'ftp_delete(': 'resource ftp_stream, string path | bool',
-\ 'ftp_exec(': 'resource ftp_stream, string command | bool',
-\ 'ftp_fget(': 'resource ftp_stream, resource handle, string remote_file, int mode [, int resumepos] | bool',
-\ 'ftp_fput(': 'resource ftp_stream, string remote_file, resource handle, int mode [, int startpos] | bool',
-\ 'ftp_get(': 'resource ftp_stream, string local_file, string remote_file, int mode [, int resumepos] | bool',
-\ 'ftp_get_option(': 'resource ftp_stream, int option | mixed',
-\ 'ftp_login(': 'resource ftp_stream, string username, string password | bool',
-\ 'ftp_mdtm(': 'resource ftp_stream, string remote_file | int',
-\ 'ftp_mkdir(': 'resource ftp_stream, string directory | string',
-\ 'ftp_nb_continue(': 'resource ftp_stream | int',
-\ 'ftp_nb_fget(': 'resource ftp_stream, resource handle, string remote_file, int mode [, int resumepos] | int',
-\ 'ftp_nb_fput(': 'resource ftp_stream, string remote_file, resource handle, int mode [, int startpos] | int',
-\ 'ftp_nb_get(': 'resource ftp_stream, string local_file, string remote_file, int mode [, int resumepos] | int',
-\ 'ftp_nb_put(': 'resource ftp_stream, string remote_file, string local_file, int mode [, int startpos] | int',
-\ 'ftp_nlist(': 'resource ftp_stream, string directory | array',
-\ 'ftp_pasv(': 'resource ftp_stream, bool pasv | bool',
-\ 'ftp_put(': 'resource ftp_stream, string remote_file, string local_file, int mode [, int startpos] | bool',
-\ 'ftp_pwd(': 'resource ftp_stream | string',
-\ 'ftp_raw(': 'resource ftp_stream, string command | array',
-\ 'ftp_rawlist(': 'resource ftp_stream, string directory [, bool recursive] | array',
-\ 'ftp_rename(': 'resource ftp_stream, string oldname, string newname | bool',
-\ 'ftp_rmdir(': 'resource ftp_stream, string directory | bool',
-\ 'ftp_set_option(': 'resource ftp_stream, int option, mixed value | bool',
-\ 'ftp_site(': 'resource ftp_stream, string command | bool',
-\ 'ftp_size(': 'resource ftp_stream, string remote_file | int',
-\ 'ftp_ssl_connect(': 'string host [, int port [, int timeout]] | resource',
-\ 'ftp_systype(': 'resource ftp_stream | string',
-\ 'ftruncate(': 'resource handle, int size | bool',
-\ 'func_get_arg(': 'int arg_num | mixed',
-\ 'func_get_args(': 'void  | array',
-\ 'func_num_args(': 'void  | int',
-\ 'function_exists(': 'string function_name | bool',
-\ 'fwrite(': 'resource handle, string string [, int length] | int',
-\ 'gd_info(': 'void  | array',
-\ 'getallheaders(': 'void  | array',
-\ 'get_browser(': '[string user_agent [, bool return_array]] | mixed',
-\ 'get_cfg_var(': 'string varname | string',
-\ 'get_class(': '[object obj] | string',
-\ 'get_class_methods(': 'mixed class_name | array',
-\ 'get_class_vars(': 'string class_name | array',
-\ 'get_current_user(': 'void  | string',
-\ 'getcwd(': 'void  | string',
-\ 'getdate(': '[int timestamp] | array',
-\ 'get_declared_classes(': 'void  | array',
-\ 'get_declared_interfaces(': 'void  | array',
-\ 'get_defined_constants(': '[mixed categorize] | array',
-\ 'get_defined_functions(': 'void  | array',
-\ 'get_defined_vars(': 'void  | array',
-\ 'getenv(': 'string varname | string',
-\ 'get_extension_funcs(': 'string module_name | array',
-\ 'get_headers(': 'string url [, int format] | array',
-\ 'gethostbyaddr(': 'string ip_address | string',
-\ 'gethostbyname(': 'string hostname | string',
-\ 'gethostbynamel(': 'string hostname | array',
-\ 'get_html_translation_table(': '[int table [, int quote_style]] | array',
-\ 'getimagesize(': 'string filename [, array &#38;imageinfo] | array',
-\ 'get_included_files(': 'void  | array',
-\ 'get_include_path(': 'void  | string',
-\ 'getlastmod(': 'void  | int',
-\ 'get_loaded_extensions(': 'void  | array',
-\ 'get_magic_quotes_gpc(': 'void  | int',
-\ 'get_magic_quotes_runtime(': 'void  | int',
-\ 'get_meta_tags(': 'string filename [, bool use_include_path] | array',
-\ 'getmxrr(': 'string hostname, array &#38;mxhosts [, array &#38;weight] | bool',
-\ 'getmygid(': 'void  | int',
-\ 'getmyinode(': 'void  | int',
-\ 'getmypid(': 'void  | int',
-\ 'getmyuid(': 'void  | int',
-\ 'get_object_vars(': 'object obj | array',
-\ 'getopt(': 'string options | array',
-\ 'get_parent_class(': '[mixed obj] | string',
-\ 'getprotobyname(': 'string name | int',
-\ 'getprotobynumber(': 'int number | string',
-\ 'getrandmax(': 'void  | int',
-\ 'get_resource_type(': 'resource handle | string',
-\ 'getrusage(': '[int who] | array',
-\ 'getservbyname(': 'string service, string protocol | int',
-\ 'getservbyport(': 'int port, string protocol | string',
-\ 'gettext(': 'string message | string',
-\ 'gettimeofday(': '[bool return_float] | mixed',
-\ 'gettype(': 'mixed var | string',
-\ 'glob(': 'string pattern [, int flags] | array',
-\ 'gmdate(': 'string format [, int timestamp] | string',
-\ 'gmmktime(': '[int hour [, int minute [, int second [, int month [, int day [, int year [, int is_dst]]]]]]] | int',
-\ 'gmp_abs(': 'resource a | resource',
-\ 'gmp_add(': 'resource a, resource b | resource',
-\ 'gmp_and(': 'resource a, resource b | resource',
-\ 'gmp_clrbit(': 'resource &#38;a, int index | void',
-\ 'gmp_cmp(': 'resource a, resource b | int',
-\ 'gmp_com(': 'resource a | resource',
-\ 'gmp_divexact(': 'resource n, resource d | resource',
-\ 'gmp_div_q(': 'resource a, resource b [, int round] | resource',
-\ 'gmp_div_qr(': 'resource n, resource d [, int round] | array',
-\ 'gmp_div_r(': 'resource n, resource d [, int round] | resource',
-\ 'gmp_fact(': 'int a | resource',
-\ 'gmp_gcdext(': 'resource a, resource b | array',
-\ 'gmp_gcd(': 'resource a, resource b | resource',
-\ 'gmp_hamdist(': 'resource a, resource b | int',
-\ 'gmp_init(': 'mixed number [, int base] | resource',
-\ 'gmp_intval(': 'resource gmpnumber | int',
-\ 'gmp_invert(': 'resource a, resource b | resource',
-\ 'gmp_jacobi(': 'resource a, resource p | int',
-\ 'gmp_legendre(': 'resource a, resource p | int',
-\ 'gmp_mod(': 'resource n, resource d | resource',
-\ 'gmp_mul(': 'resource a, resource b | resource',
-\ 'gmp_neg(': 'resource a | resource',
-\ 'gmp_or(': 'resource a, resource b | resource',
-\ 'gmp_perfect_square(': 'resource a | bool',
-\ 'gmp_popcount(': 'resource a | int',
-\ 'gmp_pow(': 'resource base, int exp | resource',
-\ 'gmp_powm(': 'resource base, resource exp, resource mod | resource',
-\ 'gmp_prob_prime(': 'resource a [, int reps] | int',
-\ 'gmp_random(': 'int limiter | resource',
-\ 'gmp_scan0(': 'resource a, int start | int',
-\ 'gmp_scan1(': 'resource a, int start | int',
-\ 'gmp_setbit(': 'resource &#38;a, int index [, bool set_clear] | void',
-\ 'gmp_sign(': 'resource a | int',
-\ 'gmp_sqrt(': 'resource a | resource',
-\ 'gmp_sqrtrem(': 'resource a | array',
-\ 'gmp_strval(': 'resource gmpnumber [, int base] | string',
-\ 'gmp_sub(': 'resource a, resource b | resource',
-\ 'gmp_xor(': 'resource a, resource b | resource',
-\ 'gmstrftime(': 'string format [, int timestamp] | string',
-\ 'gnupg_adddecryptkey(': 'resource identifier, string fingerprint, string passphrase | bool',
-\ 'gnupg_addencryptkey(': 'resource identifier, string fingerprint | bool',
-\ 'gnupg_addsignkey(': 'resource identifier, string fingerprint [, string passphrase] | bool',
-\ 'gnupg_cleardecryptkeys(': 'resource identifier | bool',
-\ 'gnupg_clearencryptkeys(': 'resource identifier | bool',
-\ 'gnupg_clearsignkeys(': 'resource identifier | bool',
-\ 'gnupg_decrypt(': 'resource identifier, string text | string',
-\ 'gnupg_decryptverify(': 'resource identifier, string text, string plaintext | array',
-\ 'gnupg_encrypt(': 'resource identifier, string plaintext | string',
-\ 'gnupg_encryptsign(': 'resource identifier, string plaintext | string',
-\ 'gnupg_export(': 'resource identifier, string fingerprint | string',
-\ 'gnupg_geterror(': 'resource identifier | string',
-\ 'gnupg_getprotocol(': 'resource identifier | int',
-\ 'gnupg_import(': 'resource identifier, string keydata | array',
-\ 'gnupg_keyinfo(': 'resource identifier, string pattern | array',
-\ 'gnupg_setarmor(': 'resource identifier, int armor | bool',
-\ 'gnupg_seterrormode(': 'resource identifier, int errormode | void',
-\ 'gnupg_setsignmode(': 'resource identifier, int signmode | bool',
-\ 'gnupg_sign(': 'resource identifier, string plaintext | string',
-\ 'gnupg_verify(': 'resource identifier, string signed_text, string signature [, string plaintext] | array',
-\ 'gopher_parsedir(': 'string dirent | array',
-\ 'gregoriantojd(': 'int month, int day, int year | int',
-\ 'gzclose(': 'resource zp | bool',
-\ 'gzcompress(': 'string data [, int level] | string',
-\ 'gzdeflate(': 'string data [, int level] | string',
-\ 'gzencode(': 'string data [, int level [, int encoding_mode]] | string',
-\ 'gzeof(': 'resource zp | int',
-\ 'gzfile(': 'string filename [, int use_include_path] | array',
-\ 'gzgetc(': 'resource zp | string',
-\ 'gzgets(': 'resource zp, int length | string',
-\ 'gzgetss(': 'resource zp, int length [, string allowable_tags] | string',
-\ 'gzinflate(': 'string data [, int length] | string',
-\ 'gzopen(': 'string filename, string mode [, int use_include_path] | resource',
-\ 'gzpassthru(': 'resource zp | int',
-\ 'gzread(': 'resource zp, int length | string',
-\ 'gzrewind(': 'resource zp | bool',
-\ 'gzseek(': 'resource zp, int offset | int',
-\ 'gztell(': 'resource zp | int',
-\ 'gzuncompress(': 'string data [, int length] | string',
-\ 'gzwrite(': 'resource zp, string string [, int length] | int',
-\ '__halt_compiler(': 'void  | void',
-\ 'hash_algos(': 'void  | array',
-\ 'hash_file(': 'string algo, string filename [, bool raw_output] | string',
-\ 'hash_final(': 'resource context [, bool raw_output] | string',
-\ 'hash_hmac_file(': 'string algo, string filename, string key [, bool raw_output] | string',
-\ 'hash_hmac(': 'string algo, string data, string key [, bool raw_output] | string',
-\ 'hash(': 'string algo, string data [, bool raw_output] | string',
-\ 'hash_init(': 'string algo [, int options, string key] | resource',
-\ 'hash_update_file(': 'resource context, string filename [, resource context] | bool',
-\ 'hash_update(': 'resource context, string data | bool',
-\ 'hash_update_stream(': 'resource context, resource handle [, int length] | int',
-\ 'header(': 'string string [, bool replace [, int http_response_code]] | void',
-\ 'headers_list(': 'void  | array',
-\ 'headers_sent(': '[string &#38;file [, int &#38;line]] | bool',
-\ 'hebrevc(': 'string hebrew_text [, int max_chars_per_line] | string',
-\ 'hebrev(': 'string hebrew_text [, int max_chars_per_line] | string',
-\ 'hexdec(': 'string hex_string | number',
-\ 'highlight_file(': 'string filename [, bool return] | mixed',
-\ 'highlight_string(': 'string str [, bool return] | mixed',
-\ 'htmlentities(': 'string string [, int quote_style [, string charset]] | string',
-\ 'html_entity_decode(': 'string string [, int quote_style [, string charset]] | string',
-\ 'htmlspecialchars_decode(': 'string string [, int quote_style] | string',
-\ 'htmlspecialchars(': 'string string [, int quote_style [, string charset]] | string',
-\ 'http_build_query(': 'array formdata [, string numeric_prefix] | string',
-\ 'hw_api_attribute(': '[string name [, string value]] | HW_API_Attribute',
-\ 'hw_api_attribute-&#62;key(': 'void  | string',
-\ 'hw_api_attribute-&#62;langdepvalue(': 'string language | string',
-\ 'hw_api_attribute-&#62;value(': 'void  | string',
-\ 'hw_api_attribute-&#62;values(': 'void  | array',
-\ 'hw_api-&#62;checkin(': 'array parameter | bool',
-\ 'hw_api-&#62;checkout(': 'array parameter | bool',
-\ 'hw_api-&#62;children(': 'array parameter | array',
-\ 'hw_api-&#62;content(': 'array parameter | HW_API_Content',
-\ 'hw_api_content-&#62;mimetype(': 'void  | string',
-\ 'hw_api_content-&#62;read(': 'string buffer, int len | string',
-\ 'hw_api-&#62;copy(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;dbstat(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;dcstat(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;dstanchors(': 'array parameter | array',
-\ 'hw_api-&#62;dstofsrcanchor(': 'array parameter | hw_api_object',
-\ 'hw_api_error-&#62;count(': 'void  | int',
-\ 'hw_api_error-&#62;reason(': 'void  | HW_API_Reason',
-\ 'hw_api-&#62;find(': 'array parameter | array',
-\ 'hw_api-&#62;ftstat(': 'array parameter | hw_api_object',
-\ 'hwapi_hgcsp(': 'string hostname [, int port] | HW_API',
-\ 'hw_api-&#62;hwstat(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;identify(': 'array parameter | bool',
-\ 'hw_api-&#62;info(': 'array parameter | array',
-\ 'hw_api-&#62;insertanchor(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;insertcollection(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;insertdocument(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;insert(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;link(': 'array parameter | bool',
-\ 'hw_api-&#62;lock(': 'array parameter | bool',
-\ 'hw_api-&#62;move(': 'array parameter | bool',
-\ 'hw_api_content(': 'string content, string mimetype | HW_API_Content',
-\ 'hw_api_object-&#62;assign(': 'array parameter | bool',
-\ 'hw_api_object-&#62;attreditable(': 'array parameter | bool',
-\ 'hw_api-&#62;objectbyanchor(': 'array parameter | hw_api_object',
-\ 'hw_api_object-&#62;count(': 'array parameter | int',
-\ 'hw_api-&#62;object(': 'array parameter | hw_api_object',
-\ 'hw_api_object-&#62;insert(': 'HW_API_Attribute attribute | bool',
-\ 'hw_api_object(': 'array parameter | hw_api_object',
-\ 'hw_api_object-&#62;remove(': 'string name | bool',
-\ 'hw_api_object-&#62;title(': 'array parameter | string',
-\ 'hw_api_object-&#62;value(': 'string name | string',
-\ 'hw_api-&#62;parents(': 'array parameter | array',
-\ 'hw_api_reason-&#62;description(': 'void  | string',
-\ 'hw_api_reason-&#62;type(': 'void  | HW_API_Reason',
-\ 'hw_api-&#62;remove(': 'array parameter | bool',
-\ 'hw_api-&#62;replace(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;setcommittedversion(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;srcanchors(': 'array parameter | array',
-\ 'hw_api-&#62;srcsofdst(': 'array parameter | array',
-\ 'hw_api-&#62;unlock(': 'array parameter | bool',
-\ 'hw_api-&#62;user(': 'array parameter | hw_api_object',
-\ 'hw_api-&#62;userlist(': 'array parameter | array',
-\ 'hw_array2objrec(': 'array object_array | string',
-\ 'hw_changeobject(': 'int link, int objid, array attributes | bool',
-\ 'hw_children(': 'int connection, int objectID | array',
-\ 'hw_childrenobj(': 'int connection, int objectID | array',
-\ 'hw_close(': 'int connection | bool',
-\ 'hw_connect(': 'string host, int port [, string username, string password] | int',
-\ 'hw_connection_info(': 'int link | void',
-\ 'hw_cp(': 'int connection, array object_id_array, int destination_id | int',
-\ 'hw_deleteobject(': 'int connection, int object_to_delete | bool',
-\ 'hw_docbyanchor(': 'int connection, int anchorID | int',
-\ 'hw_docbyanchorobj(': 'int connection, int anchorID | string',
-\ 'hw_document_attributes(': 'int hw_document | string',
-\ 'hw_document_bodytag(': 'int hw_document [, string prefix] | string',
-\ 'hw_document_content(': 'int hw_document | string',
-\ 'hw_document_setcontent(': 'int hw_document, string content | bool',
-\ 'hw_document_size(': 'int hw_document | int',
-\ 'hw_dummy(': 'int link, int id, int msgid | string',
-\ 'hw_edittext(': 'int connection, int hw_document | bool',
-\ 'hw_error(': 'int connection | int',
-\ 'hw_errormsg(': 'int connection | string',
-\ 'hw_free_document(': 'int hw_document | bool',
-\ 'hw_getanchors(': 'int connection, int objectID | array',
-\ 'hw_getanchorsobj(': 'int connection, int objectID | array',
-\ 'hw_getandlock(': 'int connection, int objectID | string',
-\ 'hw_getchildcoll(': 'int connection, int objectID | array',
-\ 'hw_getchildcollobj(': 'int connection, int objectID | array',
-\ 'hw_getchilddoccoll(': 'int connection, int objectID | array',
-\ 'hw_getchilddoccollobj(': 'int connection, int objectID | array',
-\ 'hw_getobjectbyquerycoll(': 'int connection, int objectID, string query, int max_hits | array',
-\ 'hw_getobjectbyquerycollobj(': 'int connection, int objectID, string query, int max_hits | array',
-\ 'hw_getobjectbyquery(': 'int connection, string query, int max_hits | array',
-\ 'hw_getobjectbyqueryobj(': 'int connection, string query, int max_hits | array',
-\ 'hw_getobject(': 'int connection, mixed objectID [, string query] | mixed',
-\ 'hw_getparents(': 'int connection, int objectID | array',
-\ 'hw_getparentsobj(': 'int connection, int objectID | array',
-\ 'hw_getrellink(': 'int link, int rootid, int sourceid, int destid | string',
-\ 'hw_getremotechildren(': 'int connection, string object_record | mixed',
-\ 'hw_getremote(': 'int connection, int objectID | int',
-\ 'hw_getsrcbydestobj(': 'int connection, int objectID | array',
-\ 'hw_gettext(': 'int connection, int objectID [, mixed rootID/prefix] | int',
-\ 'hw_getusername(': 'int connection | string',
-\ 'hw_identify(': 'int link, string username, string password | string',
-\ 'hw_incollections(': 'int connection, array object_id_array, array collection_id_array, int return_collections | array',
-\ 'hw_info(': 'int connection | string',
-\ 'hw_inscoll(': 'int connection, int objectID, array object_array | int',
-\ 'hw_insdoc(': 'resource connection, int parentID, string object_record [, string text] | int',
-\ 'hw_insertanchors(': 'int hwdoc, array anchorecs, array dest [, array urlprefixes] | bool',
-\ 'hw_insertdocument(': 'int connection, int parent_id, int hw_document | int',
-\ 'hw_insertobject(': 'int connection, string object_rec, string parameter | int',
-\ 'hw_mapid(': 'int connection, int server_id, int object_id | int',
-\ 'hw_modifyobject(': 'int connection, int object_to_change, array remove, array add [, int mode] | bool',
-\ 'hw_mv(': 'int connection, array object_id_array, int source_id, int destination_id | int',
-\ 'hw_new_document(': 'string object_record, string document_data, int document_size | int',
-\ 'hw_objrec2array(': 'string object_record [, array format] | array',
-\ 'hw_output_document(': 'int hw_document | bool',
-\ 'hw_pconnect(': 'string host, int port [, string username, string password] | int',
-\ 'hw_pipedocument(': 'int connection, int objectID [, array url_prefixes] | int',
-\ 'hw_root(': ' | int',
-\ 'hw_setlinkroot(': 'int link, int rootid | int',
-\ 'hw_stat(': 'int link | string',
-\ 'hw_unlock(': 'int connection, int objectID | bool',
-\ 'hw_who(': 'int connection | array',
-\ 'hypot(': 'float x, float y | float',
-\ 'i18n_loc_get_default(': 'void  | string',
-\ 'i18n_loc_set_default(': 'string name | bool',
-\ 'ibase_add_user(': 'resource service_handle, string user_name, string password [, string first_name [, string middle_name [, string last_name]]] | bool',
-\ 'ibase_affected_rows(': '[resource link_identifier] | int',
-\ 'ibase_backup(': 'resource service_handle, string source_db, string dest_file [, int options [, bool verbose]] | mixed',
-\ 'ibase_blob_add(': 'resource blob_handle, string data | void',
-\ 'ibase_blob_cancel(': 'resource blob_handle | bool',
-\ 'ibase_blob_close(': 'resource blob_handle | mixed',
-\ 'ibase_blob_create(': '[resource link_identifier] | resource',
-\ 'ibase_blob_echo(': 'resource link_identifier, string blob_id | bool',
-\ 'ibase_blob_get(': 'resource blob_handle, int len | string',
-\ 'ibase_blob_import(': 'resource link_identifier, resource file_handle | string',
-\ 'ibase_blob_info(': 'resource link_identifier, string blob_id | array',
-\ 'ibase_blob_open(': 'resource link_identifier, string blob_id | resource',
-\ 'ibase_close(': '[resource connection_id] | bool',
-\ 'ibase_commit(': '[resource link_or_trans_identifier] | bool',
-\ 'ibase_commit_ret(': '[resource link_or_trans_identifier] | bool',
-\ 'ibase_connect(': '[string database [, string username [, string password [, string charset [, int buffers [, int dialect [, string role [, int sync]]]]]]]] | resource',
-\ 'ibase_db_info(': 'resource service_handle, string db, int action [, int argument] | string',
-\ 'ibase_delete_user(': 'resource service_handle, string user_name | bool',
-\ 'ibase_drop_db(': '[resource connection] | bool',
-\ 'ibase_errcode(': 'void  | int',
-\ 'ibase_errmsg(': 'void  | string',
-\ 'ibase_execute(': 'resource query [, mixed bind_arg [, mixed ...]] | resource',
-\ 'ibase_fetch_assoc(': 'resource result [, int fetch_flag] | array',
-\ 'ibase_fetch_object(': 'resource result_id [, int fetch_flag] | object',
-\ 'ibase_fetch_row(': 'resource result_identifier [, int fetch_flag] | array',
-\ 'ibase_field_info(': 'resource result, int field_number | array',
-\ 'ibase_free_event_handler(': 'resource event | bool',
-\ 'ibase_free_query(': 'resource query | bool',
-\ 'ibase_free_result(': 'resource result_identifier | bool',
-\ 'ibase_gen_id(': 'string generator [, int increment [, resource link_identifier]] | mixed',
-\ 'ibase_maintain_db(': 'resource service_handle, string db, int action [, int argument] | bool',
-\ 'ibase_modify_user(': 'resource service_handle, string user_name, string password [, string first_name [, string middle_name [, string last_name]]] | bool',
-\ 'ibase_name_result(': 'resource result, string name | bool',
-\ 'ibase_num_fields(': 'resource result_id | int',
-\ 'ibase_num_params(': 'resource query | int',
-\ 'ibase_param_info(': 'resource query, int param_number | array',
-\ 'ibase_pconnect(': '[string database [, string username [, string password [, string charset [, int buffers [, int dialect [, string role [, int sync]]]]]]]] | resource',
-\ 'ibase_prepare(': 'string query | resource',
-\ 'ibase_query(': '[resource link_identifier, string query [, int bind_args]] | resource',
-\ 'ibase_restore(': 'resource service_handle, string source_file, string dest_db [, int options [, bool verbose]] | mixed',
-\ 'ibase_rollback(': '[resource link_or_trans_identifier] | bool',
-\ 'ibase_rollback_ret(': '[resource link_or_trans_identifier] | bool',
-\ 'ibase_server_info(': 'resource service_handle, int action | string',
-\ 'ibase_service_attach(': 'string host, string dba_username, string dba_password | resource',
-\ 'ibase_service_detach(': 'resource service_handle | bool',
-\ 'ibase_set_event_handler(': 'callback event_handler, string event_name1 [, string event_name2 [, string ...]] | resource',
-\ 'ibase_timefmt(': 'string format [, int columntype] | int',
-\ 'ibase_trans(': '[int trans_args [, resource link_identifier]] | resource',
-\ 'ibase_wait_event(': 'string event_name1 [, string event_name2 [, string ...]] | string',
-\ 'icap_close(': 'int icap_stream [, int flags] | int',
-\ 'icap_create_calendar(': 'int stream_id, string calendar | string',
-\ 'icap_delete_calendar(': 'int stream_id, string calendar | string',
-\ 'icap_delete_event(': 'int stream_id, int uid | string',
-\ 'icap_fetch_event(': 'int stream_id, int event_id [, int options] | int',
-\ 'icap_list_alarms(': 'int stream_id, array date, array time | int',
-\ 'icap_list_events(': 'int stream_id, int begin_date [, int end_date] | array',
-\ 'icap_open(': 'string calendar, string username, string password, string options | resource',
-\ 'icap_rename_calendar(': 'int stream_id, string old_name, string new_name | string',
-\ 'icap_reopen(': 'int stream_id, string calendar [, int options] | int',
-\ 'icap_snooze(': 'int stream_id, int uid | string',
-\ 'icap_store_event(': 'int stream_id, object event | string',
-\ 'iconv_get_encoding(': '[string type] | mixed',
-\ 'iconv(': 'string in_charset, string out_charset, string str | string',
-\ 'iconv_mime_decode_headers(': 'string encoded_headers [, int mode [, string charset]] | array',
-\ 'iconv_mime_decode(': 'string encoded_header [, int mode [, string charset]] | string',
-\ 'iconv_mime_encode(': 'string field_name, string field_value [, array preferences] | string',
-\ 'iconv_set_encoding(': 'string type, string charset | bool',
-\ 'iconv_strlen(': 'string str [, string charset] | int',
-\ 'iconv_strpos(': 'string haystack, string needle [, int offset [, string charset]] | int',
-\ 'iconv_strrpos(': 'string haystack, string needle [, string charset] | int',
-\ 'iconv_substr(': 'string str, int offset [, int length [, string charset]] | string',
-\ 'id3_get_frame_long_name(': 'string frameId | string',
-\ 'id3_get_frame_short_name(': 'string frameId | string',
-\ 'id3_get_genre_id(': 'string genre | int',
-\ 'id3_get_genre_list(': 'void  | array',
-\ 'id3_get_genre_name(': 'int genre_id | string',
-\ 'id3_get_tag(': 'string filename [, int version] | array',
-\ 'id3_get_version(': 'string filename | int',
-\ 'id3_remove_tag(': 'string filename [, int version] | bool',
-\ 'id3_set_tag(': 'string filename, array tag [, int version] | bool',
-\ 'idate(': 'string format [, int timestamp] | int',
-\ 'ifx_affected_rows(': 'int result_id | int',
-\ 'ifx_blobinfile_mode(': 'int mode | void',
-\ 'ifx_byteasvarchar(': 'int mode | void',
-\ 'ifx_close(': '[int link_identifier] | int',
-\ 'ifx_connect(': '[string database [, string userid [, string password]]] | int',
-\ 'ifx_copy_blob(': 'int bid | int',
-\ 'ifx_create_blob(': 'int type, int mode, string param | int',
-\ 'ifx_create_char(': 'string param | int',
-\ 'ifx_do(': 'int result_id | int',
-\ 'ifx_error(': 'void  | string',
-\ 'ifx_errormsg(': '[int errorcode] | string',
-\ 'ifx_fetch_row(': 'int result_id [, mixed position] | array',
-\ 'ifx_fieldproperties(': 'int result_id | array',
-\ 'ifx_fieldtypes(': 'int result_id | array',
-\ 'ifx_free_blob(': 'int bid | int',
-\ 'ifx_free_char(': 'int bid | int',
-\ 'ifx_free_result(': 'int result_id | int',
-\ 'ifx_get_blob(': 'int bid | int',
-\ 'ifx_get_char(': 'int bid | int',
-\ 'ifx_getsqlca(': 'int result_id | array',
-\ 'ifx_htmltbl_result(': 'int result_id [, string html_table_options] | int',
-\ 'ifx_nullformat(': 'int mode | void',
-\ 'ifx_num_fields(': 'int result_id | int',
-\ 'ifx_num_rows(': 'int result_id | int',
-\ 'ifx_pconnect(': '[string database [, string userid [, string password]]] | int',
-\ 'ifx_prepare(': 'string query, int conn_id [, int cursor_def, mixed blobidarray] | int',
-\ 'ifx_query(': 'string query, int link_identifier [, int cursor_type [, mixed blobidarray]] | int',
-\ 'ifx_textasvarchar(': 'int mode | void',
-\ 'ifx_update_blob(': 'int bid, string content | bool',
-\ 'ifx_update_char(': 'int bid, string content | int',
-\ 'ifxus_close_slob(': 'int bid | int',
-\ 'ifxus_create_slob(': 'int mode | int',
-\ 'ifxus_free_slob(': 'int bid | int',
-\ 'ifxus_open_slob(': 'int bid, int mode | int',
-\ 'ifxus_read_slob(': 'int bid, int nbytes | int',
-\ 'ifxus_seek_slob(': 'int bid, int mode, int offset | int',
-\ 'ifxus_tell_slob(': 'int bid | int',
-\ 'ifxus_write_slob(': 'int bid, string content | int',
-\ 'ignore_user_abort(': '[bool setting] | int',
-\ 'iis_add_server(': 'string path, string comment, string server_ip, int port, string host_name, int rights, int start_server | int',
-\ 'iis_get_dir_security(': 'int server_instance, string virtual_path | int',
-\ 'iis_get_script_map(': 'int server_instance, string virtual_path, string script_extension | string',
-\ 'iis_get_server_by_comment(': 'string comment | int',
-\ 'iis_get_server_by_path(': 'string path | int',
-\ 'iis_get_server_rights(': 'int server_instance, string virtual_path | int',
-\ 'iis_get_service_state(': 'string service_id | int',
-\ 'iis_remove_server(': 'int server_instance | int',
-\ 'iis_set_app_settings(': 'int server_instance, string virtual_path, string application_scope | int',
-\ 'iis_set_dir_security(': 'int server_instance, string virtual_path, int directory_flags | int',
-\ 'iis_set_script_map(': 'int server_instance, string virtual_path, string script_extension, string engine_path, int allow_scripting | int',
-\ 'iis_set_server_rights(': 'int server_instance, string virtual_path, int directory_flags | int',
-\ 'iis_start_server(': 'int server_instance | int',
-\ 'iis_start_service(': 'string service_id | int',
-\ 'iis_stop_server(': 'int server_instance | int',
-\ 'iis_stop_service(': 'string service_id | int',
-\ 'image2wbmp(': 'resource image [, string filename [, int threshold]] | int',
-\ 'imagealphablending(': 'resource image, bool blendmode | bool',
-\ 'imageantialias(': 'resource im, bool on | bool',
-\ 'imagearc(': 'resource image, int cx, int cy, int w, int h, int s, int e, int color | bool',
-\ 'imagechar(': 'resource image, int font, int x, int y, string c, int color | bool',
-\ 'imagecharup(': 'resource image, int font, int x, int y, string c, int color | bool',
-\ 'imagecolorallocatealpha(': 'resource image, int red, int green, int blue, int alpha | int',
-\ 'imagecolorallocate(': 'resource image, int red, int green, int blue | int',
-\ 'imagecolorat(': 'resource image, int x, int y | int',
-\ 'imagecolorclosestalpha(': 'resource image, int red, int green, int blue, int alpha | int',
-\ 'imagecolorclosest(': 'resource image, int red, int green, int blue | int',
-\ 'imagecolorclosesthwb(': 'resource image, int red, int green, int blue | int',
-\ 'imagecolordeallocate(': 'resource image, int color | bool',
-\ 'imagecolorexactalpha(': 'resource image, int red, int green, int blue, int alpha | int',
-\ 'imagecolorexact(': 'resource image, int red, int green, int blue | int',
-\ 'imagecolormatch(': 'resource image1, resource image2 | bool',
-\ 'imagecolorresolvealpha(': 'resource image, int red, int green, int blue, int alpha | int',
-\ 'imagecolorresolve(': 'resource image, int red, int green, int blue | int',
-\ 'imagecolorset(': 'resource image, int index, int red, int green, int blue | void',
-\ 'imagecolorsforindex(': 'resource image, int index | array',
-\ 'imagecolorstotal(': 'resource image | int',
-\ 'imagecolortransparent(': 'resource image [, int color] | int',
-\ 'imageconvolution(': 'resource image, array matrix3x3, float div, float offset | bool',
-\ 'imagecopy(': 'resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h | bool',
-\ 'imagecopymergegray(': 'resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct | bool',
-\ 'imagecopymerge(': 'resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct | bool',
-\ 'imagecopyresampled(': 'resource dst_image, resource src_image, int dst_x, int dst_y, int src_x, int src_y, int dst_w, int dst_h, int src_w, int src_h | bool',
-\ 'imagecopyresized(': 'resource dst_image, resource src_image, int dst_x, int dst_y, int src_x, int src_y, int dst_w, int dst_h, int src_w, int src_h | bool',
-\ 'imagecreatefromgd2(': 'string filename | resource',
-\ 'imagecreatefromgd2part(': 'string filename, int srcX, int srcY, int width, int height | resource',
-\ 'imagecreatefromgd(': 'string filename | resource',
-\ 'imagecreatefromgif(': 'string filename | resource',
-\ 'imagecreatefromjpeg(': 'string filename | resource',
-\ 'imagecreatefrompng(': 'string filename | resource',
-\ 'imagecreatefromstring(': 'string image | resource',
-\ 'imagecreatefromwbmp(': 'string filename | resource',
-\ 'imagecreatefromxbm(': 'string filename | resource',
-\ 'imagecreatefromxpm(': 'string filename | resource',
-\ 'imagecreate(': 'int x_size, int y_size | resource',
-\ 'imagecreatetruecolor(': 'int x_size, int y_size | resource',
-\ 'imagedashedline(': 'resource image, int x1, int y1, int x2, int y2, int color | bool',
-\ 'imagedestroy(': 'resource image | bool',
-\ 'imageellipse(': 'resource image, int cx, int cy, int w, int h, int color | bool',
-\ 'imagefilledarc(': 'resource image, int cx, int cy, int w, int h, int s, int e, int color, int style | bool',
-\ 'imagefilledellipse(': 'resource image, int cx, int cy, int w, int h, int color | bool',
-\ 'imagefilledpolygon(': 'resource image, array points, int num_points, int color | bool',
-\ 'imagefilledrectangle(': 'resource image, int x1, int y1, int x2, int y2, int color | bool',
-\ 'imagefill(': 'resource image, int x, int y, int color | bool',
-\ 'imagefilltoborder(': 'resource image, int x, int y, int border, int color | bool',
-\ 'imagefilter(': 'resource src_im, int filtertype [, int arg1 [, int arg2 [, int arg3]]] | bool',
-\ 'imagefontheight(': 'int font | int',
-\ 'imagefontwidth(': 'int font | int',
-\ 'imageftbbox(': 'float size, float angle, string font_file, string text [, array extrainfo] | array',
-\ 'imagefttext(': 'resource image, float size, float angle, int x, int y, int col, string font_file, string text [, array extrainfo] | array',
-\ 'imagegammacorrect(': 'resource image, float inputgamma, float outputgamma | bool',
-\ 'imagegd2(': 'resource image [, string filename [, int chunk_size [, int type]]] | bool',
-\ 'imagegd(': 'resource image [, string filename] | bool',
-\ 'imagegif(': 'resource image [, string filename] | bool',
-\ 'imageinterlace(': 'resource image [, int interlace] | int',
-\ 'imageistruecolor(': 'resource image | bool',
-\ 'imagejpeg(': 'resource image [, string filename [, int quality]] | bool',
-\ 'imagelayereffect(': 'resource image, int effect | bool',
-\ 'imageline(': 'resource image, int x1, int y1, int x2, int y2, int color | bool',
-\ 'imageloadfont(': 'string file | int',
-\ 'imagepalettecopy(': 'resource destination, resource source | void',
-\ 'imagepng(': 'resource image [, string filename] | bool',
-\ 'imagepolygon(': 'resource image, array points, int num_points, int color | bool',
-\ 'imagepsbbox(': 'string text, int font, int size [, int space, int tightness, float angle] | array',
-\ 'imagepscopyfont(': 'resource fontindex | int',
-\ 'imagepsencodefont(': 'resource font_index, string encodingfile | bool',
-\ 'imagepsextendfont(': 'int font_index, float extend | bool',
-\ 'imagepsfreefont(': 'resource fontindex | bool',
-\ 'imagepsloadfont(': 'string filename | resource',
-\ 'imagepsslantfont(': 'resource font_index, float slant | bool',
-\ 'imagepstext(': 'resource image, string text, resource font, int size, int foreground, int background, int x, int y [, int space, int tightness, float angle, int antialias_steps] | array',
-\ 'imagerectangle(': 'resource image, int x1, int y1, int x2, int y2, int col | bool',
-\ 'imagerotate(': 'resource src_im, float angle, int bgd_color [, int ignore_transparent] | resource',
-\ 'imagesavealpha(': 'resource image, bool saveflag | bool',
-\ 'imagesetbrush(': 'resource image, resource brush | bool',
-\ 'imagesetpixel(': 'resource image, int x, int y, int color | bool',
-\ 'imagesetstyle(': 'resource image, array style | bool',
-\ 'imagesetthickness(': 'resource image, int thickness | bool',
-\ 'imagesettile(': 'resource image, resource tile | bool',
-\ 'imagestring(': 'resource image, int font, int x, int y, string s, int col | bool',
-\ 'imagestringup(': 'resource image, int font, int x, int y, string s, int col | bool',
-\ 'imagesx(': 'resource image | int',
-\ 'imagesy(': 'resource image | int',
-\ 'imagetruecolortopalette(': 'resource image, bool dither, int ncolors | bool',
-\ 'imagettfbbox(': 'float size, float angle, string fontfile, string text | array',
-\ 'imagettftext(': 'resource image, float size, float angle, int x, int y, int color, string fontfile, string text | array',
-\ 'imagetypes(': 'void  | int',
-\ 'image_type_to_extension(': 'int imagetype [, bool include_dot] | string',
-\ 'image_type_to_mime_type(': 'int imagetype | string',
-\ 'imagewbmp(': 'resource image [, string filename [, int foreground]] | bool',
-\ 'imagexbm(': 'resource image, string filename [, int foreground] | bool',
-\ 'imap_8bit(': 'string string | string',
-\ 'imap_alerts(': 'void  | array',
-\ 'imap_append(': 'resource imap_stream, string mbox, string message [, string options] | bool',
-\ 'imap_base64(': 'string text | string',
-\ 'imap_binary(': 'string string | string',
-\ 'imap_body(': 'resource imap_stream, int msg_number [, int options] | string',
-\ 'imap_bodystruct(': 'resource stream_id, int msg_no, string section | object',
-\ 'imap_check(': 'resource imap_stream | object',
-\ 'imap_clearflag_full(': 'resource stream, string sequence, string flag [, string options] | bool',
-\ 'imap_close(': 'resource imap_stream [, int flag] | bool',
-\ 'imap_createmailbox(': 'resource imap_stream, string mbox | bool',
-\ 'imap_delete(': 'int imap_stream, int msg_number [, int options] | bool',
-\ 'imap_deletemailbox(': 'resource imap_stream, string mbox | bool',
-\ 'imap_errors(': 'void  | array',
-\ 'imap_expunge(': 'resource imap_stream | bool',
-\ 'imap_fetchbody(': 'resource imap_stream, int msg_number, string part_number [, int options] | string',
-\ 'imap_fetchheader(': 'resource imap_stream, int msgno [, int options] | string',
-\ 'imap_fetch_overview(': 'resource imap_stream, string sequence [, int options] | array',
-\ 'imap_fetchstructure(': 'resource imap_stream, int msg_number [, int options] | object',
-\ 'imap_getacl(': 'resource stream_id, string mailbox | array',
-\ 'imap_getmailboxes(': 'resource imap_stream, string ref, string pattern | array',
-\ 'imap_get_quota(': 'resource imap_stream, string quota_root | array',
-\ 'imap_get_quotaroot(': 'resource imap_stream, string quota_root | array',
-\ 'imap_getsubscribed(': 'resource imap_stream, string ref, string pattern | array',
-\ 'imap_headerinfo(': 'resource imap_stream, int msg_number [, int fromlength [, int subjectlength [, string defaulthost]]] | object',
-\ 'imap_headers(': 'resource imap_stream | array',
-\ 'imap_last_error(': 'void  | string',
-\ 'imap_list(': 'resource imap_stream, string ref, string pattern | array',
-\ 'imap_listscan(': 'resource imap_stream, string ref, string pattern, string content | array',
-\ 'imap_lsub(': 'resource imap_stream, string ref, string pattern | array',
-\ 'imap_mailboxmsginfo(': 'resource imap_stream | object',
-\ 'imap_mail_compose(': 'array envelope, array body | string',
-\ 'imap_mail_copy(': 'resource imap_stream, string msglist, string mbox [, int options] | bool',
-\ 'imap_mail(': 'string to, string subject, string message [, string additional_headers [, string cc [, string bcc [, string rpath]]]] | bool',
-\ 'imap_mail_move(': 'resource imap_stream, string msglist, string mbox [, int options] | bool',
-\ 'imap_mime_header_decode(': 'string text | array',
-\ 'imap_msgno(': 'resource imap_stream, int uid | int',
-\ 'imap_num_msg(': 'resource imap_stream | int',
-\ 'imap_num_recent(': 'resource imap_stream | int',
-\ 'imap_open(': 'string mailbox, string username, string password [, int options] | resource',
-\ 'imap_ping(': 'resource imap_stream | bool',
-\ 'imap_qprint(': 'string string | string',
-\ 'imap_renamemailbox(': 'resource imap_stream, string old_mbox, string new_mbox | bool',
-\ 'imap_reopen(': 'resource imap_stream, string mailbox [, int options] | bool',
-\ 'imap_rfc822_parse_adrlist(': 'string address, string default_host | array',
-\ 'imap_rfc822_parse_headers(': 'string headers [, string defaulthost] | object',
-\ 'imap_rfc822_write_address(': 'string mailbox, string host, string personal | string',
-\ 'imap_search(': 'resource imap_stream, string criteria [, int options [, string charset]] | array',
-\ 'imap_setacl(': 'resource stream_id, string mailbox, string id, string rights | bool',
-\ 'imap_setflag_full(': 'resource stream, string sequence, string flag [, string options] | bool',
-\ 'imap_set_quota(': 'resource imap_stream, string quota_root, int quota_limit | bool',
-\ 'imap_sort(': 'resource stream, int criteria, int reverse [, int options [, string search_criteria [, string charset]]] | array',
-\ 'imap_status(': 'resource imap_stream, string mailbox, int options | object',
-\ 'imap_subscribe(': 'resource imap_stream, string mbox | bool',
-\ 'imap_thread(': 'resource stream_id [, int options] | array',
-\ 'imap_timeout(': 'int timeout_type [, int timeout] | mixed',
-\ 'imap_uid(': 'resource imap_stream, int msgno | int',
-\ 'imap_undelete(': 'resource imap_stream, int msg_number [, int flags] | bool',
-\ 'imap_unsubscribe(': 'string imap_stream, string mbox | bool',
-\ 'imap_utf7_decode(': 'string text | string',
-\ 'imap_utf7_encode(': 'string data | string',
-\ 'imap_utf8(': 'string mime_encoded_text | string',
-\ 'implode(': 'string glue, array pieces | string',
-\ 'import_request_variables(': 'string types [, string prefix] | bool',
-\ 'in_array(': 'mixed needle, array haystack [, bool strict] | bool',
-\ 'inet_ntop(': 'string in_addr | string',
-\ 'inet_pton(': 'string address | string',
-\ 'ingres_autocommit(': '[resource link] | bool',
-\ 'ingres_close(': '[resource link] | bool',
-\ 'ingres_commit(': '[resource link] | bool',
-\ 'ingres_connect(': '[string database [, string username [, string password]]] | resource',
-\ 'ingres_cursor(': '[resource link] | string',
-\ 'ingres_errno(': '[resource link] | int',
-\ 'ingres_error(': '[resource link] | string',
-\ 'ingres_errsqlstate(': '[resource link] | string',
-\ 'ingres_fetch_array(': '[int result_type [, resource link]] | array',
-\ 'ingres_fetch_object(': '[int result_type [, resource link]] | object',
-\ 'ingres_fetch_row(': '[resource link] | array',
-\ 'ingres_field_length(': 'int index [, resource link] | int',
-\ 'ingres_field_name(': 'int index [, resource link] | string',
-\ 'ingres_field_nullable(': 'int index [, resource link] | bool',
-\ 'ingres_field_precision(': 'int index [, resource link] | int',
-\ 'ingres_field_scale(': 'int index [, resource link] | int',
-\ 'ingres_field_type(': 'int index [, resource link] | string',
-\ 'ingres_num_fields(': '[resource link] | int',
-\ 'ingres_num_rows(': '[resource link] | int',
-\ 'ingres_pconnect(': '[string database [, string username [, string password]]] | resource',
-\ 'ingres_query(': 'string query [, resource link] | bool',
-\ 'ingres_rollback(': '[resource link] | bool',
-\ 'ini_get_all(': '[string extension] | array',
-\ 'ini_get(': 'string varname | string',
-\ 'ini_restore(': 'string varname | void',
-\ 'ini_set(': 'string varname, string newvalue | string',
-\ 'interface_exists(': 'string interface_name [, bool autoload] | bool',
-\ 'intval(': 'mixed var [, int base] | int',
-\ 'ip2long(': 'string ip_address | int',
-\ 'iptcembed(': 'string iptcdata, string jpeg_file_name [, int spool] | mixed',
-\ 'iptcparse(': 'string iptcblock | array',
-\ 'ircg_channel_mode(': 'resource connection, string channel, string mode_spec, string nick | bool',
-\ 'ircg_disconnect(': 'resource connection, string reason | bool',
-\ 'ircg_eval_ecmascript_params(': 'string params | array',
-\ 'ircg_fetch_error_msg(': 'resource connection | array',
-\ 'ircg_get_username(': 'resource connection | string',
-\ 'ircg_html_encode(': 'string html_string [, bool auto_links [, bool conv_br]] | string',
-\ 'ircg_ignore_add(': 'resource connection, string nick | void',
-\ 'ircg_ignore_del(': 'resource connection, string nick | bool',
-\ 'ircg_invite(': 'resource connection, string channel, string nickname | bool',
-\ 'ircg_is_conn_alive(': 'resource connection | bool',
-\ 'ircg_join(': 'resource connection, string channel [, string key] | bool',
-\ 'ircg_kick(': 'resource connection, string channel, string nick, string reason | bool',
-\ 'ircg_list(': 'resource connection, string channel | bool',
-\ 'ircg_lookup_format_messages(': 'string name | bool',
-\ 'ircg_lusers(': 'resource connection | bool',
-\ 'ircg_msg(': 'resource connection, string recipient, string message [, bool suppress] | bool',
-\ 'ircg_names(': 'int connection, string channel [, string target] | bool',
-\ 'ircg_nick(': 'resource connection, string nick | bool',
-\ 'ircg_nickname_escape(': 'string nick | string',
-\ 'ircg_nickname_unescape(': 'string nick | string',
-\ 'ircg_notice(': 'resource connection, string recipient, string message | bool',
-\ 'ircg_oper(': 'resource connection, string name, string password | bool',
-\ 'ircg_part(': 'resource connection, string channel | bool',
-\ 'ircg_pconnect(': 'string username [, string server_ip [, int server_port [, string msg_format [, array ctcp_messages [, array user_settings [, bool bailout_on_trivial]]]]]] | resource',
-\ 'ircg_register_format_messages(': 'string name, array messages | bool',
-\ 'ircg_set_current(': 'resource connection | bool',
-\ 'ircg_set_file(': 'resource connection, string path | bool',
-\ 'ircg_set_on_die(': 'resource connection, string host, int port, string data | bool',
-\ 'ircg_topic(': 'resource connection, string channel, string new_topic | bool',
-\ 'ircg_who(': 'resource connection, string mask [, bool ops_only] | bool',
-\ 'ircg_whois(': 'resource connection, string nick | bool',
-\ 'is_a(': 'object object, string class_name | bool',
-\ 'is_array(': 'mixed var | bool',
-\ 'is_bool(': 'mixed var | bool',
-\ 'is_callable(': 'mixed var [, bool syntax_only [, string &#38;callable_name]] | bool',
-\ 'is_dir(': 'string filename | bool',
-\ 'is_executable(': 'string filename | bool',
-\ 'is_file(': 'string filename | bool',
-\ 'is_finite(': 'float val | bool',
-\ 'is_float(': 'mixed var | bool',
-\ 'is_infinite(': 'float val | bool',
-\ 'is_int(': 'mixed var | bool',
-\ 'is_link(': 'string filename | bool',
-\ 'is_nan(': 'float val | bool',
-\ 'is_null(': 'mixed var | bool',
-\ 'is_numeric(': 'mixed var | bool',
-\ 'is_object(': 'mixed var | bool',
-\ 'is_readable(': 'string filename | bool',
-\ 'is_resource(': 'mixed var | bool',
-\ 'is_scalar(': 'mixed var | bool',
-\ 'isset(': 'mixed var [, mixed var [, ...]] | bool',
-\ 'is_soap_fault(': 'mixed obj | bool',
-\ 'is_string(': 'mixed var | bool',
-\ 'is_subclass_of(': 'mixed object, string class_name | bool',
-\ 'is_uploaded_file(': 'string filename | bool',
-\ 'is_writable(': 'string filename | bool',
-\ 'iterator_count(': 'IteratorAggregate iterator | int',
-\ 'iterator_to_array(': 'IteratorAggregate iterator | array',
-\ 'java_last_exception_clear(': 'void  | void',
-\ 'java_last_exception_get(': 'void  | object',
-\ 'jddayofweek(': 'int julianday [, int mode] | mixed',
-\ 'jdmonthname(': 'int julianday, int mode | string',
-\ 'jdtofrench(': 'int juliandaycount | string',
-\ 'jdtogregorian(': 'int julianday | string',
-\ 'jdtojewish(': 'int juliandaycount [, bool hebrew [, int fl]] | string',
-\ 'jdtojulian(': 'int julianday | string',
-\ 'jdtounix(': 'int jday | int',
-\ 'jewishtojd(': 'int month, int day, int year | int',
-\ 'jpeg2wbmp(': 'string jpegname, string wbmpname, int d_height, int d_width, int threshold | int',
-\ 'juliantojd(': 'int month, int day, int year | int',
-\ 'kadm5_chpass_principal(': 'resource handle, string principal, string password | bool',
-\ 'kadm5_create_principal(': 'resource handle, string principal [, string password [, array options]] | bool',
-\ 'kadm5_delete_principal(': 'resource handle, string principal | bool',
-\ 'kadm5_destroy(': 'resource handle | bool',
-\ 'kadm5_flush(': 'resource handle | bool',
-\ 'kadm5_get_policies(': 'resource handle | array',
-\ 'kadm5_get_principal(': 'resource handle, string principal | array',
-\ 'kadm5_get_principals(': 'resource handle | array',
-\ 'kadm5_init_with_password(': 'string admin_server, string realm, string principal, string password | resource',
-\ 'kadm5_modify_principal(': 'resource handle, string principal, array options | bool',
-\ 'key(': 'array &#38;array | mixed',
-\ 'krsort(': 'array &#38;array [, int sort_flags] | bool',
-\ 'ksort(': 'array &#38;array [, int sort_flags] | bool',
-\ 'lcg_value(': 'void  | float',
-\ 'ldap_8859_to_t61(': 'string value | string',
-\ 'ldap_add(': 'resource link_identifier, string dn, array entry | bool',
-\ 'ldap_bind(': 'resource link_identifier [, string bind_rdn [, string bind_password]] | bool',
-\ 'ldap_compare(': 'resource link_identifier, string dn, string attribute, string value | mixed',
-\ 'ldap_connect(': '[string hostname [, int port]] | resource',
-\ 'ldap_count_entries(': 'resource link_identifier, resource result_identifier | int',
-\ 'ldap_delete(': 'resource link_identifier, string dn | bool',
-\ 'ldap_dn2ufn(': 'string dn | string',
-\ 'ldap_err2str(': 'int errno | string',
-\ 'ldap_errno(': 'resource link_identifier | int',
-\ 'ldap_error(': 'resource link_identifier | string',
-\ 'ldap_explode_dn(': 'string dn, int with_attrib | array',
-\ 'ldap_first_attribute(': 'resource link_identifier, resource result_entry_identifier, int &#38;ber_identifier | string',
-\ 'ldap_first_entry(': 'resource link_identifier, resource result_identifier | resource',
-\ 'ldap_first_reference(': 'resource link, resource result | resource',
-\ 'ldap_free_result(': 'resource result_identifier | bool',
-\ 'ldap_get_attributes(': 'resource link_identifier, resource result_entry_identifier | array',
-\ 'ldap_get_dn(': 'resource link_identifier, resource result_entry_identifier | string',
-\ 'ldap_get_entries(': 'resource link_identifier, resource result_identifier | array',
-\ 'ldap_get_option(': 'resource link_identifier, int option, mixed &#38;retval | bool',
-\ 'ldap_get_values(': 'resource link_identifier, resource result_entry_identifier, string attribute | array',
-\ 'ldap_get_values_len(': 'resource link_identifier, resource result_entry_identifier, string attribute | array',
-\ 'ldap_list(': 'resource link_identifier, string base_dn, string filter [, array attributes [, int attrsonly [, int sizelimit [, int timelimit [, int deref]]]]] | resource',
-\ 'ldap_mod_add(': 'resource link_identifier, string dn, array entry | bool',
-\ 'ldap_mod_del(': 'resource link_identifier, string dn, array entry | bool',
-\ 'ldap_modify(': 'resource link_identifier, string dn, array entry | bool',
-\ 'ldap_mod_replace(': 'resource link_identifier, string dn, array entry | bool',
-\ 'ldap_next_attribute(': 'resource link_identifier, resource result_entry_identifier, resource &#38;ber_identifier | string',
-\ 'ldap_next_entry(': 'resource link_identifier, resource result_entry_identifier | resource',
-\ 'ldap_next_reference(': 'resource link, resource entry | resource',
-\ 'ldap_parse_reference(': 'resource link, resource entry, array &#38;referrals | bool',
-\ 'ldap_parse_result(': 'resource link, resource result, int &#38;errcode [, string &#38;matcheddn [, string &#38;errmsg [, array &#38;referrals]]] | bool',
-\ 'ldap_read(': 'resource link_identifier, string base_dn, string filter [, array attributes [, int attrsonly [, int sizelimit [, int timelimit [, int deref]]]]] | resource',
-\ 'ldap_rename(': 'resource link_identifier, string dn, string newrdn, string newparent, bool deleteoldrdn | bool',
-\ 'ldap_sasl_bind(': 'resource link [, string binddn [, string password [, string sasl_mech [, string sasl_realm [, string sasl_authz_id [, string props]]]]]] | bool',
-\ 'ldap_search(': 'resource link_identifier, string base_dn, string filter [, array attributes [, int attrsonly [, int sizelimit [, int timelimit [, int deref]]]]] | resource',
-\ 'ldap_set_option(': 'resource link_identifier, int option, mixed newval | bool',
-\ 'ldap_set_rebind_proc(': 'resource link, callback callback | bool',
-\ 'ldap_sort(': 'resource link, resource result, string sortfilter | bool',
-\ 'ldap_start_tls(': 'resource link | bool',
-\ 'ldap_t61_to_8859(': 'string value | string',
-\ 'ldap_unbind(': 'resource link_identifier | bool',
-\ 'levenshtein(': 'string str1, string str2 [, int cost_ins [, int cost_rep, int cost_del]] | int',
-\ 'libxml_clear_errors(': 'void  | void',
-\ 'libxml_get_errors(': 'void  | array',
-\ 'libxml_get_last_error(': 'void  | LibXMLError',
-\ 'libxml_set_streams_context(': 'resource streams_context | void',
-\ 'libxml_use_internal_errors(': '[bool use_errors] | bool',
-\ 'link(': 'string target, string link | bool',
-\ 'linkinfo(': 'string path | int',
-\ 'list(': 'mixed varname, mixed ... | void',
-\ 'localeconv(': 'void  | array',
-\ 'localtime(': '[int timestamp [, bool is_associative]] | array',
-\ 'log10(': 'float arg | float',
-\ 'log1p(': 'float number | float',
-\ 'log(': 'float arg [, float base] | float',
-\ 'long2ip(': 'int proper_address | string',
-\ 'lstat(': 'string filename | array',
-\ 'ltrim(': 'string str [, string charlist] | string',
-\ 'lzf_compress(': 'string data | string',
-\ 'lzf_decompress(': 'string data | string',
-\ 'lzf_optimized_for(': 'void  | int',
-\ 'mail(': 'string to, string subject, string message [, string additional_headers [, string additional_parameters]] | bool',
-\ 'mailparse_determine_best_xfer_encoding(': 'resource fp | string',
-\ 'mailparse_msg_create(': 'void  | resource',
-\ 'mailparse_msg_extract_part_file(': 'resource rfc2045, string filename [, callback callbackfunc] | string',
-\ 'mailparse_msg_extract_part(': 'resource rfc2045, string msgbody [, callback callbackfunc] | void',
-\ 'mailparse_msg_free(': 'resource rfc2045buf | bool',
-\ 'mailparse_msg_get_part_data(': 'resource rfc2045 | array',
-\ 'mailparse_msg_get_part(': 'resource rfc2045, string mimesection | resource',
-\ 'mailparse_msg_get_structure(': 'resource rfc2045 | array',
-\ 'mailparse_msg_parse_file(': 'string filename | resource',
-\ 'mailparse_msg_parse(': 'resource rfc2045buf, string data | bool',
-\ 'mailparse_rfc822_parse_addresses(': 'string addresses | array',
-\ 'mailparse_stream_encode(': 'resource sourcefp, resource destfp, string encoding | bool',
-\ 'mailparse_uudecode_all(': 'resource fp | array',
-\ 'maxdb_connect_errno(': 'void  | int',
-\ 'maxdb_connect_error(': 'void  | string',
-\ 'maxdb_debug(': 'string debug | void',
-\ 'maxdb_disable_rpl_parse(': 'resource link | bool',
-\ 'maxdb_dump_debug_info(': 'resource link | bool',
-\ 'maxdb_embedded_connect(': '[string dbname] | resource',
-\ 'maxdb_enable_reads_from_master(': 'resource link | bool',
-\ 'maxdb_enable_rpl_parse(': 'resource link | bool',
-\ 'maxdb_get_client_info(': 'void  | string',
-\ 'maxdb_get_client_version(': 'void  | int',
-\ 'maxdb_init(': 'void  | resource',
-\ 'maxdb_master_query(': 'resource link, string query | bool',
-\ 'maxdb_more_results(': 'resource link | bool',
-\ 'maxdb_next_result(': 'resource link | bool',
-\ 'maxdb_report(': 'int flags | bool',
-\ 'maxdb_rollback(': 'resource link | bool',
-\ 'maxdb_rpl_parse_enabled(': 'resource link | int',
-\ 'maxdb_rpl_probe(': 'resource link | bool',
-\ 'maxdb_rpl_query_type(': 'resource link | int',
-\ 'maxdb_select_db(': 'resource link, string dbname | bool',
-\ 'maxdb_send_query(': 'resource link, string query | bool',
-\ 'maxdb_server_end(': 'void  | void',
-\ 'maxdb_server_init(': '[array server [, array groups]] | bool',
-\ 'maxdb_stmt_sqlstate(': 'resource stmt | string',
-\ 'max(': 'number arg1, number arg2 [, number ...] | mixed',
-\ 'mb_convert_case(': 'string str, int mode [, string encoding] | string',
-\ 'mb_convert_encoding(': 'string str, string to_encoding [, mixed from_encoding] | string',
-\ 'mb_convert_kana(': 'string str [, string option [, string encoding]] | string',
-\ 'mb_convert_variables(': 'string to_encoding, mixed from_encoding, mixed &#38;vars [, mixed &#38;...] | string',
-\ 'mb_decode_mimeheader(': 'string str | string',
-\ 'mb_decode_numericentity(': 'string str, array convmap [, string encoding] | string',
-\ 'mb_detect_encoding(': 'string str [, mixed encoding_list [, bool strict]] | string',
-\ 'mb_detect_order(': '[mixed encoding_list] | mixed',
-\ 'mb_encode_mimeheader(': 'string str [, string charset [, string transfer_encoding [, string linefeed]]] | string',
-\ 'mb_encode_numericentity(': 'string str, array convmap [, string encoding] | string',
-\ 'mb_ereg(': 'string pattern, string string [, array regs] | int',
-\ 'mb_eregi(': 'string pattern, string string [, array regs] | int',
-\ 'mb_eregi_replace(': 'string pattern, string replace, string string [, string option] | string',
-\ 'mb_ereg_match(': 'string pattern, string string [, string option] | bool',
-\ 'mb_ereg_replace(': 'string pattern, string replacement, string string [, string option] | string',
-\ 'mb_ereg_search_getpos(': 'void  | int',
-\ 'mb_ereg_search_getregs(': 'void  | array',
-\ 'mb_ereg_search(': '[string pattern [, string option]] | bool',
-\ 'mb_ereg_search_init(': 'string string [, string pattern [, string option]] | bool',
-\ 'mb_ereg_search_pos(': '[string pattern [, string option]] | array',
-\ 'mb_ereg_search_regs(': '[string pattern [, string option]] | array',
-\ 'mb_ereg_search_setpos(': 'int position | bool',
-\ 'mb_get_info(': '[string type] | mixed',
-\ 'mb_http_input(': '[string type] | mixed',
-\ 'mb_http_output(': '[string encoding] | mixed',
-\ 'mb_internal_encoding(': '[string encoding] | mixed',
-\ 'mb_language(': '[string language] | mixed',
-\ 'mb_list_encodings(': 'void  | array',
-\ 'mb_output_handler(': 'string contents, int status | string',
-\ 'mb_parse_str(': 'string encoded_string [, array &#38;result] | bool',
-\ 'mb_preferred_mime_name(': 'string encoding | string',
-\ 'mb_regex_encoding(': '[string encoding] | mixed',
-\ 'mb_regex_set_options(': '[string options] | string',
-\ 'mb_send_mail(': 'string to, string subject, string message [, string additional_headers [, string additional_parameter]] | bool',
-\ 'mb_split(': 'string pattern, string string [, int limit] | array',
-\ 'mb_strcut(': 'string str, int start [, int length [, string encoding]] | string',
-\ 'mb_strimwidth(': 'string str, int start, int width [, string trimmarker [, string encoding]] | string',
-\ 'mb_strlen(': 'string str [, string encoding] | int',
-\ 'mb_strpos(': 'string haystack, string needle [, int offset [, string encoding]] | int',
-\ 'mb_strrpos(': 'string haystack, string needle [, string encoding] | int',
-\ 'mb_strtolower(': 'string str [, string encoding] | string',
-\ 'mb_strtoupper(': 'string str [, string encoding] | string',
-\ 'mb_strwidth(': 'string str [, string encoding] | int',
-\ 'mb_substitute_character(': '[mixed substrchar] | mixed',
-\ 'mb_substr_count(': 'string haystack, string needle [, string encoding] | int',
-\ 'mb_substr(': 'string str, int start [, int length [, string encoding]] | string',
-\ 'mcal_append_event(': 'int mcal_stream | int',
-\ 'mcal_close(': 'int mcal_stream [, int flags] | bool',
-\ 'mcal_create_calendar(': 'int stream, string calendar | bool',
-\ 'mcal_date_compare(': 'int a_year, int a_month, int a_day, int b_year, int b_month, int b_day | int',
-\ 'mcal_date_valid(': 'int year, int month, int day | bool',
-\ 'mcal_day_of_week(': 'int year, int month, int day | int',
-\ 'mcal_day_of_year(': 'int year, int month, int day | int',
-\ 'mcal_days_in_month(': 'int month, int leap_year | int',
-\ 'mcal_delete_calendar(': 'int stream, string calendar | bool',
-\ 'mcal_delete_event(': 'int mcal_stream, int event_id | bool',
-\ 'mcal_event_add_attribute(': 'int stream, string attribute, string value | bool',
-\ 'mcal_event_init(': 'int stream | void',
-\ 'mcal_event_set_alarm(': 'int stream, int alarm | void',
-\ 'mcal_event_set_category(': 'int stream, string category | void',
-\ 'mcal_event_set_class(': 'int stream, int class | void',
-\ 'mcal_event_set_description(': 'int stream, string description | void',
-\ 'mcal_event_set_end(': 'int stream, int year, int month, int day [, int hour [, int min [, int sec]]] | void',
-\ 'mcal_event_set_recur_daily(': 'int stream, int year, int month, int day, int interval | void',
-\ 'mcal_event_set_recur_monthly_mday(': 'int stream, int year, int month, int day, int interval | void',
-\ 'mcal_event_set_recur_monthly_wday(': 'int stream, int year, int month, int day, int interval | void',
-\ 'mcal_event_set_recur_none(': 'int stream | void',
-\ 'mcal_event_set_recur_weekly(': 'int stream, int year, int month, int day, int interval, int weekdays | void',
-\ 'mcal_event_set_recur_yearly(': 'int stream, int year, int month, int day, int interval | void',
-\ 'mcal_event_set_start(': 'int stream, int year, int month, int day [, int hour [, int min [, int sec]]] | void',
-\ 'mcal_event_set_title(': 'int stream, string title | void',
-\ 'mcal_expunge(': 'int stream | bool',
-\ 'mcal_fetch_current_stream_event(': 'int stream | object',
-\ 'mcal_fetch_event(': 'int mcal_stream, int event_id [, int options] | object',
-\ 'mcal_is_leap_year(': 'int year | bool',
-\ 'mcal_list_alarms(': 'int mcal_stream [, int begin_year, int begin_month, int begin_day, int end_year, int end_month, int end_day] | array',
-\ 'mcal_list_events(': 'int mcal_stream [, int begin_year, int begin_month, int begin_day, int end_year, int end_month, int end_day] | array',
-\ 'mcal_next_recurrence(': 'int stream, int weekstart, array next | object',
-\ 'mcal_open(': 'string calendar, string username, string password [, int options] | int',
-\ 'mcal_popen(': 'string calendar, string username, string password [, int options] | int',
-\ 'mcal_rename_calendar(': 'int stream, string old_name, string new_name | bool',
-\ 'mcal_reopen(': 'int mcal_stream, string calendar [, int options] | bool',
-\ 'mcal_snooze(': 'int stream_id, int event_id | bool',
-\ 'mcal_store_event(': 'int mcal_stream | int',
-\ 'mcal_time_valid(': 'int hour, int minutes, int seconds | bool',
-\ 'mcal_week_of_year(': 'int day, int month, int year | int',
-\ 'm_checkstatus(': 'resource conn, int identifier | int',
-\ 'm_completeauthorizations(': 'resource conn, int &#38;array | int',
-\ 'm_connect(': 'resource conn | int',
-\ 'm_connectionerror(': 'resource conn | string',
-\ 'mcrypt_cbc(': 'int cipher, string key, string data, int mode [, string iv] | string',
-\ 'mcrypt_cfb(': 'int cipher, string key, string data, int mode, string iv | string',
-\ 'mcrypt_create_iv(': 'int size [, int source] | string',
-\ 'mcrypt_decrypt(': 'string cipher, string key, string data, string mode [, string iv] | string',
-\ 'mcrypt_ecb(': 'int cipher, string key, string data, int mode | string',
-\ 'mcrypt_enc_get_algorithms_name(': 'resource td | string',
-\ 'mcrypt_enc_get_block_size(': 'resource td | int',
-\ 'mcrypt_enc_get_iv_size(': 'resource td | int',
-\ 'mcrypt_enc_get_key_size(': 'resource td | int',
-\ 'mcrypt_enc_get_modes_name(': 'resource td | string',
-\ 'mcrypt_enc_get_supported_key_sizes(': 'resource td | array',
-\ 'mcrypt_enc_is_block_algorithm(': 'resource td | bool',
-\ 'mcrypt_enc_is_block_algorithm_mode(': 'resource td | bool',
-\ 'mcrypt_enc_is_block_mode(': 'resource td | bool',
-\ 'mcrypt_encrypt(': 'string cipher, string key, string data, string mode [, string iv] | string',
-\ 'mcrypt_enc_self_test(': 'resource td | int',
-\ 'mcrypt_generic_deinit(': 'resource td | bool',
-\ 'mcrypt_generic_end(': 'resource td | bool',
-\ 'mcrypt_generic(': 'resource td, string data | string',
-\ 'mcrypt_generic_init(': 'resource td, string key, string iv | int',
-\ 'mcrypt_get_block_size(': 'int cipher | int',
-\ 'mcrypt_get_cipher_name(': 'int cipher | string',
-\ 'mcrypt_get_iv_size(': 'string cipher, string mode | int',
-\ 'mcrypt_get_key_size(': 'int cipher | int',
-\ 'mcrypt_list_algorithms(': '[string lib_dir] | array',
-\ 'mcrypt_list_modes(': '[string lib_dir] | array',
-\ 'mcrypt_module_close(': 'resource td | bool',
-\ 'mcrypt_module_get_algo_block_size(': 'string algorithm [, string lib_dir] | int',
-\ 'mcrypt_module_get_algo_key_size(': 'string algorithm [, string lib_dir] | int',
-\ 'mcrypt_module_get_supported_key_sizes(': 'string algorithm [, string lib_dir] | array',
-\ 'mcrypt_module_is_block_algorithm(': 'string algorithm [, string lib_dir] | bool',
-\ 'mcrypt_module_is_block_algorithm_mode(': 'string mode [, string lib_dir] | bool',
-\ 'mcrypt_module_is_block_mode(': 'string mode [, string lib_dir] | bool',
-\ 'mcrypt_module_open(': 'string algorithm, string algorithm_directory, string mode, string mode_directory | resource',
-\ 'mcrypt_module_self_test(': 'string algorithm [, string lib_dir] | bool',
-\ 'mcrypt_ofb(': 'int cipher, string key, string data, int mode, string iv | string',
-\ 'md5_file(': 'string filename [, bool raw_output] | string',
-\ 'md5(': 'string str [, bool raw_output] | string',
-\ 'mdecrypt_generic(': 'resource td, string data | string',
-\ 'm_deletetrans(': 'resource conn, int identifier | bool',
-\ 'm_destroyconn(': 'resource conn | bool',
-\ 'm_destroyengine(': 'void  | void',
-\ 'memcache_debug(': 'bool on_off | bool',
-\ 'memory_get_usage(': 'void  | int',
-\ 'metaphone(': 'string str [, int phones] | string',
-\ 'method_exists(': 'object object, string method_name | bool',
-\ 'm_getcellbynum(': 'resource conn, int identifier, int column, int row | string',
-\ 'm_getcell(': 'resource conn, int identifier, string column, int row | string',
-\ 'm_getcommadelimited(': 'resource conn, int identifier | string',
-\ 'm_getheader(': 'resource conn, int identifier, int column_num | string',
-\ 'mhash_count(': 'void  | int',
-\ 'mhash_get_block_size(': 'int hash | int',
-\ 'mhash_get_hash_name(': 'int hash | string',
-\ 'mhash(': 'int hash, string data [, string key] | string',
-\ 'mhash_keygen_s2k(': 'int hash, string password, string salt, int bytes | string',
-\ 'microtime(': '[bool get_as_float] | mixed',
-\ 'mime_content_type(': 'string filename | string',
-\ 'ming_keypress(': 'string str | int',
-\ 'ming_setcubicthreshold(': 'int threshold | void',
-\ 'ming_setscale(': 'int scale | void',
-\ 'ming_useConstants(': 'int use | void',
-\ 'ming_useswfversion(': 'int version | void',
-\ 'min(': 'number arg1, number arg2 [, number ...] | mixed',
-\ 'm_initconn(': 'void  | resource',
-\ 'm_initengine(': 'string location | int',
-\ 'm_iscommadelimited(': 'resource conn, int identifier | int',
-\ 'mkdir(': 'string pathname [, int mode [, bool recursive [, resource context]]] | bool',
-\ 'mktime(': '[int hour [, int minute [, int second [, int month [, int day [, int year [, int is_dst]]]]]]] | int',
-\ 'm_maxconntimeout(': 'resource conn, int secs | bool',
-\ 'm_monitor(': 'resource conn | int',
-\ 'm_numcolumns(': 'resource conn, int identifier | int',
-\ 'm_numrows(': 'resource conn, int identifier | int',
-\ 'money_format(': 'string format, float number | string',
-\ 'move_uploaded_file(': 'string filename, string destination | bool',
-\ 'm_parsecommadelimited(': 'resource conn, int identifier | int',
-\ 'm_responsekeys(': 'resource conn, int identifier | array',
-\ 'm_responseparam(': 'resource conn, int identifier, string key | string',
-\ 'm_returnstatus(': 'resource conn, int identifier | int',
-\ 'msession_connect(': 'string host, string port | bool',
-\ 'msession_count(': 'void  | int',
-\ 'msession_create(': 'string session | bool',
-\ 'msession_destroy(': 'string name | bool',
-\ 'msession_disconnect(': 'void  | void',
-\ 'msession_find(': 'string name, string value | array',
-\ 'msession_get_array(': 'string session | array',
-\ 'msession_get_data(': 'string session | string',
-\ 'msession_get(': 'string session, string name, string value | string',
-\ 'msession_inc(': 'string session, string name | string',
-\ 'msession_list(': 'void  | array',
-\ 'msession_listvar(': 'string name | array',
-\ 'msession_lock(': 'string name | int',
-\ 'msession_plugin(': 'string session, string val [, string param] | string',
-\ 'msession_randstr(': 'int param | string',
-\ 'msession_set_array(': 'string session, array tuples | void',
-\ 'msession_set_data(': 'string session, string value | bool',
-\ 'msession_set(': 'string session, string name, string value | bool',
-\ 'msession_timeout(': 'string session [, int param] | int',
-\ 'msession_uniq(': 'int param | string',
-\ 'msession_unlock(': 'string session, int key | int',
-\ 'm_setblocking(': 'resource conn, int tf | int',
-\ 'm_setdropfile(': 'resource conn, string directory | int',
-\ 'm_setip(': 'resource conn, string host, int port | int',
-\ 'm_setssl_cafile(': 'resource conn, string cafile | int',
-\ 'm_setssl_files(': 'resource conn, string sslkeyfile, string sslcertfile | int',
-\ 'm_setssl(': 'resource conn, string host, int port | int',
-\ 'm_settimeout(': 'resource conn, int seconds | int',
-\ 'msg_get_queue(': 'int key [, int perms] | resource',
-\ 'msg_receive(': 'resource queue, int desiredmsgtype, int &#38;msgtype, int maxsize, mixed &#38;message [, bool unserialize [, int flags [, int &#38;errorcode]]] | bool',
-\ 'msg_remove_queue(': 'resource queue | bool',
-\ 'msg_send(': 'resource queue, int msgtype, mixed message [, bool serialize [, bool blocking [, int &#38;errorcode]]] | bool',
-\ 'msg_set_queue(': 'resource queue, array data | bool',
-\ 'msg_stat_queue(': 'resource queue | array',
-\ 'msql_affected_rows(': 'resource result | int',
-\ 'msql_close(': '[resource link_identifier] | bool',
-\ 'msql_connect(': '[string hostname] | resource',
-\ 'msql_create_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'msql_data_seek(': 'resource result, int row_number | bool',
-\ 'msql_db_query(': 'string database, string query [, resource link_identifier] | resource',
-\ 'msql_drop_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'msql_error(': 'void  | string',
-\ 'msql_fetch_array(': 'resource result [, int result_type] | array',
-\ 'msql_fetch_field(': 'resource result [, int field_offset] | object',
-\ 'msql_fetch_object(': 'resource result | object',
-\ 'msql_fetch_row(': 'resource result | array',
-\ 'msql_field_flags(': 'resource result, int field_offset | string',
-\ 'msql_field_len(': 'resource result, int field_offset | int',
-\ 'msql_field_name(': 'resource result, int field_offset | string',
-\ 'msql_field_seek(': 'resource result, int field_offset | bool',
-\ 'msql_field_table(': 'resource result, int field_offset | int',
-\ 'msql_field_type(': 'resource result, int field_offset | string',
-\ 'msql_free_result(': 'resource result | bool',
-\ 'msql_list_dbs(': '[resource link_identifier] | resource',
-\ 'msql_list_fields(': 'string database, string tablename [, resource link_identifier] | resource',
-\ 'msql_list_tables(': 'string database [, resource link_identifier] | resource',
-\ 'msql_num_fields(': 'resource result | int',
-\ 'msql_num_rows(': 'resource query_identifier | int',
-\ 'msql_pconnect(': '[string hostname] | resource',
-\ 'msql_query(': 'string query [, resource link_identifier] | resource',
-\ 'msql_result(': 'resource result, int row [, mixed field] | string',
-\ 'msql_select_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'm_sslcert_gen_hash(': 'string filename | string',
-\ 'mssql_bind(': 'resource stmt, string param_name, mixed &#38;var, int type [, int is_output [, int is_null [, int maxlen]]] | bool',
-\ 'mssql_close(': '[resource link_identifier] | bool',
-\ 'mssql_connect(': '[string servername [, string username [, string password]]] | resource',
-\ 'mssql_data_seek(': 'resource result_identifier, int row_number | bool',
-\ 'mssql_execute(': 'resource stmt [, bool skip_results] | mixed',
-\ 'mssql_fetch_array(': 'resource result [, int result_type] | array',
-\ 'mssql_fetch_assoc(': 'resource result_id | array',
-\ 'mssql_fetch_batch(': 'resource result_index | int',
-\ 'mssql_fetch_field(': 'resource result [, int field_offset] | object',
-\ 'mssql_fetch_object(': 'resource result | object',
-\ 'mssql_fetch_row(': 'resource result | array',
-\ 'mssql_field_length(': 'resource result [, int offset] | int',
-\ 'mssql_field_name(': 'resource result [, int offset] | string',
-\ 'mssql_field_seek(': 'resource result, int field_offset | bool',
-\ 'mssql_field_type(': 'resource result [, int offset] | string',
-\ 'mssql_free_result(': 'resource result | bool',
-\ 'mssql_free_statement(': 'resource statement | bool',
-\ 'mssql_get_last_message(': 'void  | string',
-\ 'mssql_guid_string(': 'string binary [, int short_format] | string',
-\ 'mssql_init(': 'string sp_name [, resource conn_id] | resource',
-\ 'mssql_min_error_severity(': 'int severity | void',
-\ 'mssql_min_message_severity(': 'int severity | void',
-\ 'mssql_next_result(': 'resource result_id | bool',
-\ 'mssql_num_fields(': 'resource result | int',
-\ 'mssql_num_rows(': 'resource result | int',
-\ 'mssql_pconnect(': '[string servername [, string username [, string password]]] | resource',
-\ 'mssql_query(': 'string query [, resource link_identifier [, int batch_size]] | mixed',
-\ 'mssql_result(': 'resource result, int row, mixed field | string',
-\ 'mssql_rows_affected(': 'resource conn_id | int',
-\ 'mssql_select_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'mt_getrandmax(': 'void  | int',
-\ 'mt_rand(': '[int min, int max] | int',
-\ 'm_transactionssent(': 'resource conn | int',
-\ 'm_transinqueue(': 'resource conn | int',
-\ 'm_transkeyval(': 'resource conn, int identifier, string key, string value | int',
-\ 'm_transnew(': 'resource conn | int',
-\ 'm_transsend(': 'resource conn, int identifier | int',
-\ 'mt_srand(': '[int seed] | void',
-\ 'muscat_close(': 'resource muscat_handle | void',
-\ 'muscat_get(': 'resource muscat_handle | string',
-\ 'muscat_give(': 'resource muscat_handle, string string | void',
-\ 'muscat_setup(': 'int size [, string muscat_dir] | resource',
-\ 'muscat_setup_net(': 'string muscat_host | resource',
-\ 'm_uwait(': 'int microsecs | int',
-\ 'm_validateidentifier(': 'resource conn, int tf | int',
-\ 'm_verifyconnection(': 'resource conn, int tf | bool',
-\ 'm_verifysslcert(': 'resource conn, int tf | bool',
-\ 'mysql_affected_rows(': '[resource link_identifier] | int',
-\ 'mysql_change_user(': 'string user, string password [, string database [, resource link_identifier]] | int',
-\ 'mysql_client_encoding(': '[resource link_identifier] | string',
-\ 'mysql_close(': '[resource link_identifier] | bool',
-\ 'mysql_connect(': '[string server [, string username [, string password [, bool new_link [, int client_flags]]]]] | resource',
-\ 'mysql_create_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'mysql_data_seek(': 'resource result, int row_number | bool',
-\ 'mysql_db_name(': 'resource result, int row [, mixed field] | string',
-\ 'mysql_db_query(': 'string database, string query [, resource link_identifier] | resource',
-\ 'mysql_drop_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'mysql_errno(': '[resource link_identifier] | int',
-\ 'mysql_error(': '[resource link_identifier] | string',
-\ 'mysql_escape_string(': 'string unescaped_string | string',
-\ 'mysql_fetch_array(': 'resource result [, int result_type] | array',
-\ 'mysql_fetch_assoc(': 'resource result | array',
-\ 'mysql_fetch_field(': 'resource result [, int field_offset] | object',
-\ 'mysql_fetch_lengths(': 'resource result | array',
-\ 'mysql_fetch_object(': 'resource result | object',
-\ 'mysql_fetch_row(': 'resource result | array',
-\ 'mysql_field_flags(': 'resource result, int field_offset | string',
-\ 'mysql_field_len(': 'resource result, int field_offset | int',
-\ 'mysql_field_name(': 'resource result, int field_offset | string',
-\ 'mysql_field_seek(': 'resource result, int field_offset | bool',
-\ 'mysql_field_table(': 'resource result, int field_offset | string',
-\ 'mysql_field_type(': 'resource result, int field_offset | string',
-\ 'mysql_free_result(': 'resource result | bool',
-\ 'mysql_get_client_info(': 'void  | string',
-\ 'mysql_get_host_info(': '[resource link_identifier] | string',
-\ 'mysql_get_proto_info(': '[resource link_identifier] | int',
-\ 'mysql_get_server_info(': '[resource link_identifier] | string',
-\ 'mysqli_connect_errno(': 'void  | int',
-\ 'mysqli_connect_error(': 'void  | string',
-\ 'mysqli_debug(': 'string debug | bool',
-\ 'mysqli_disable_rpl_parse(': 'mysqli link | bool',
-\ 'mysqli_dump_debug_info(': 'mysqli link | bool',
-\ 'mysqli_embedded_connect(': '[string dbname] | mysqli',
-\ 'mysqli_enable_reads_from_master(': 'mysqli link | bool',
-\ 'mysqli_enable_rpl_parse(': 'mysqli link | bool',
-\ 'mysqli_get_client_info(': 'void  | string',
-\ 'mysqli_get_client_version(': 'void  | int',
-\ 'mysqli_init(': 'void  | mysqli',
-\ 'mysqli_master_query(': 'mysqli link, string query | bool',
-\ 'mysqli_more_results(': 'mysqli link | bool',
-\ 'mysqli_next_result(': 'mysqli link | bool',
-\ 'mysql_info(': '[resource link_identifier] | string',
-\ 'mysql_insert_id(': '[resource link_identifier] | int',
-\ 'mysqli_report(': 'int flags | bool',
-\ 'mysqli_rollback(': 'mysqli link | bool',
-\ 'mysqli_rpl_parse_enabled(': 'mysqli link | int',
-\ 'mysqli_rpl_probe(': 'mysqli link | bool',
-\ 'mysqli_select_db(': 'mysqli link, string dbname | bool',
-\ 'mysqli_server_end(': 'void  | void',
-\ 'mysqli_server_init(': '[array server [, array groups]] | bool',
-\ 'mysqli_set_charset(': 'mysqli link, string charset | bool',
-\ 'mysqli_stmt_sqlstate(': 'mysqli_stmt stmt | string',
-\ 'mysql_list_dbs(': '[resource link_identifier] | resource',
-\ 'mysql_list_fields(': 'string database_name, string table_name [, resource link_identifier] | resource',
-\ 'mysql_list_processes(': '[resource link_identifier] | resource',
-\ 'mysql_list_tables(': 'string database [, resource link_identifier] | resource',
-\ 'mysql_num_fields(': 'resource result | int',
-\ 'mysql_num_rows(': 'resource result | int',
-\ 'mysql_pconnect(': '[string server [, string username [, string password [, int client_flags]]]] | resource',
-\ 'mysql_ping(': '[resource link_identifier] | bool',
-\ 'mysql_query(': 'string query [, resource link_identifier] | resource',
-\ 'mysql_real_escape_string(': 'string unescaped_string [, resource link_identifier] | string',
-\ 'mysql_result(': 'resource result, int row [, mixed field] | string',
-\ 'mysql_select_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'mysql_stat(': '[resource link_identifier] | string',
-\ 'mysql_tablename(': 'resource result, int i | string',
-\ 'mysql_thread_id(': '[resource link_identifier] | int',
-\ 'mysql_unbuffered_query(': 'string query [, resource link_identifier] | resource',
-\ 'natcasesort(': 'array &#38;array | bool',
-\ 'natsort(': 'array &#38;array | bool',
-\ 'ncurses_addch(': 'int ch | int',
-\ 'ncurses_addchnstr(': 'string s, int n | int',
-\ 'ncurses_addchstr(': 'string s | int',
-\ 'ncurses_addnstr(': 'string s, int n | int',
-\ 'ncurses_addstr(': 'string text | int',
-\ 'ncurses_assume_default_colors(': 'int fg, int bg | int',
-\ 'ncurses_attroff(': 'int attributes | int',
-\ 'ncurses_attron(': 'int attributes | int',
-\ 'ncurses_attrset(': 'int attributes | int',
-\ 'ncurses_baudrate(': 'void  | int',
-\ 'ncurses_beep(': 'void  | int',
-\ 'ncurses_bkgd(': 'int attrchar | int',
-\ 'ncurses_bkgdset(': 'int attrchar | void',
-\ 'ncurses_border(': 'int left, int right, int top, int bottom, int tl_corner, int tr_corner, int bl_corner, int br_corner | int',
-\ 'ncurses_bottom_panel(': 'resource panel | int',
-\ 'ncurses_can_change_color(': 'void  | bool',
-\ 'ncurses_cbreak(': 'void  | bool',
-\ 'ncurses_clear(': 'void  | bool',
-\ 'ncurses_clrtobot(': 'void  | bool',
-\ 'ncurses_clrtoeol(': 'void  | bool',
-\ 'ncurses_color_content(': 'int color, int &#38;r, int &#38;g, int &#38;b | int',
-\ 'ncurses_color_set(': 'int pair | int',
-\ 'ncurses_curs_set(': 'int visibility | int',
-\ 'ncurses_define_key(': 'string definition, int keycode | int',
-\ 'ncurses_def_prog_mode(': 'void  | bool',
-\ 'ncurses_def_shell_mode(': 'void  | bool',
-\ 'ncurses_delay_output(': 'int milliseconds | int',
-\ 'ncurses_delch(': 'void  | bool',
-\ 'ncurses_deleteln(': 'void  | bool',
-\ 'ncurses_del_panel(': 'resource panel | bool',
-\ 'ncurses_delwin(': 'resource window | bool',
-\ 'ncurses_doupdate(': 'void  | bool',
-\ 'ncurses_echochar(': 'int character | int',
-\ 'ncurses_echo(': 'void  | bool',
-\ 'ncurses_end(': 'void  | int',
-\ 'ncurses_erasechar(': 'void  | string',
-\ 'ncurses_erase(': 'void  | bool',
-\ 'ncurses_filter(': 'void  | void',
-\ 'ncurses_flash(': 'void  | bool',
-\ 'ncurses_flushinp(': 'void  | bool',
-\ 'ncurses_getch(': 'void  | int',
-\ 'ncurses_getmaxyx(': 'resource window, int &#38;y, int &#38;x | void',
-\ 'ncurses_getmouse(': 'array &#38;mevent | bool',
-\ 'ncurses_getyx(': 'resource window, int &#38;y, int &#38;x | void',
-\ 'ncurses_halfdelay(': 'int tenth | int',
-\ 'ncurses_has_colors(': 'void  | bool',
-\ 'ncurses_has_ic(': 'void  | bool',
-\ 'ncurses_has_il(': 'void  | bool',
-\ 'ncurses_has_key(': 'int keycode | int',
-\ 'ncurses_hide_panel(': 'resource panel | int',
-\ 'ncurses_hline(': 'int charattr, int n | int',
-\ 'ncurses_inch(': 'void  | string',
-\ 'ncurses_init_color(': 'int color, int r, int g, int b | int',
-\ 'ncurses_init(': 'void  | void',
-\ 'ncurses_init_pair(': 'int pair, int fg, int bg | int',
-\ 'ncurses_insch(': 'int character | int',
-\ 'ncurses_insdelln(': 'int count | int',
-\ 'ncurses_insertln(': 'void  | bool',
-\ 'ncurses_insstr(': 'string text | int',
-\ 'ncurses_instr(': 'string &#38;buffer | int',
-\ 'ncurses_isendwin(': 'void  | bool',
-\ 'ncurses_keyok(': 'int keycode, bool enable | int',
-\ 'ncurses_keypad(': 'resource window, bool bf | int',
-\ 'ncurses_killchar(': 'void  | string',
-\ 'ncurses_longname(': 'void  | string',
-\ 'ncurses_meta(': 'resource window, bool 8bit | int',
-\ 'ncurses_mouseinterval(': 'int milliseconds | int',
-\ 'ncurses_mousemask(': 'int newmask, int &#38;oldmask | int',
-\ 'ncurses_mouse_trafo(': 'int &#38;y, int &#38;x, bool toscreen | bool',
-\ 'ncurses_move(': 'int y, int x | int',
-\ 'ncurses_move_panel(': 'resource panel, int startx, int starty | int',
-\ 'ncurses_mvaddch(': 'int y, int x, int c | int',
-\ 'ncurses_mvaddchnstr(': 'int y, int x, string s, int n | int',
-\ 'ncurses_mvaddchstr(': 'int y, int x, string s | int',
-\ 'ncurses_mvaddnstr(': 'int y, int x, string s, int n | int',
-\ 'ncurses_mvaddstr(': 'int y, int x, string s | int',
-\ 'ncurses_mvcur(': 'int old_y, int old_x, int new_y, int new_x | int',
-\ 'ncurses_mvdelch(': 'int y, int x | int',
-\ 'ncurses_mvgetch(': 'int y, int x | int',
-\ 'ncurses_mvhline(': 'int y, int x, int attrchar, int n | int',
-\ 'ncurses_mvinch(': 'int y, int x | int',
-\ 'ncurses_mvvline(': 'int y, int x, int attrchar, int n | int',
-\ 'ncurses_mvwaddstr(': 'resource window, int y, int x, string text | int',
-\ 'ncurses_napms(': 'int milliseconds | int',
-\ 'ncurses_newpad(': 'int rows, int cols | resource',
-\ 'ncurses_new_panel(': 'resource window | resource',
-\ 'ncurses_newwin(': 'int rows, int cols, int y, int x | resource',
-\ 'ncurses_nl(': 'void  | bool',
-\ 'ncurses_nocbreak(': 'void  | bool',
-\ 'ncurses_noecho(': 'void  | bool',
-\ 'ncurses_nonl(': 'void  | bool',
-\ 'ncurses_noqiflush(': 'void  | void',
-\ 'ncurses_noraw(': 'void  | bool',
-\ 'ncurses_pair_content(': 'int pair, int &#38;f, int &#38;b | int',
-\ 'ncurses_panel_above(': 'resource panel | resource',
-\ 'ncurses_panel_below(': 'resource panel | resource',
-\ 'ncurses_panel_window(': 'resource panel | resource',
-\ 'ncurses_pnoutrefresh(': 'resource pad, int pminrow, int pmincol, int sminrow, int smincol, int smaxrow, int smaxcol | int',
-\ 'ncurses_prefresh(': 'resource pad, int pminrow, int pmincol, int sminrow, int smincol, int smaxrow, int smaxcol | int',
-\ 'ncurses_putp(': 'string text | int',
-\ 'ncurses_qiflush(': 'void  | void',
-\ 'ncurses_raw(': 'void  | bool',
-\ 'ncurses_refresh(': 'int ch | int',
-\ 'ncurses_replace_panel(': 'resource panel, resource window | int',
-\ 'ncurses_reset_prog_mode(': 'void  | int',
-\ 'ncurses_reset_shell_mode(': 'void  | int',
-\ 'ncurses_resetty(': 'void  | bool',
-\ 'ncurses_savetty(': 'void  | bool',
-\ 'ncurses_scr_dump(': 'string filename | int',
-\ 'ncurses_scr_init(': 'string filename | int',
-\ 'ncurses_scrl(': 'int count | int',
-\ 'ncurses_scr_restore(': 'string filename | int',
-\ 'ncurses_scr_set(': 'string filename | int',
-\ 'ncurses_show_panel(': 'resource panel | int',
-\ 'ncurses_slk_attr(': 'void  | bool',
-\ 'ncurses_slk_attroff(': 'int intarg | int',
-\ 'ncurses_slk_attron(': 'int intarg | int',
-\ 'ncurses_slk_attrset(': 'int intarg | int',
-\ 'ncurses_slk_clear(': 'void  | bool',
-\ 'ncurses_slk_color(': 'int intarg | int',
-\ 'ncurses_slk_init(': 'int format | bool',
-\ 'ncurses_slk_noutrefresh(': 'void  | bool',
-\ 'ncurses_slk_refresh(': 'void  | bool',
-\ 'ncurses_slk_restore(': 'void  | bool',
-\ 'ncurses_slk_set(': 'int labelnr, string label, int format | bool',
-\ 'ncurses_slk_touch(': 'void  | bool',
-\ 'ncurses_standend(': 'void  | int',
-\ 'ncurses_standout(': 'void  | int',
-\ 'ncurses_start_color(': 'void  | int',
-\ 'ncurses_termattrs(': 'void  | bool',
-\ 'ncurses_termname(': 'void  | string',
-\ 'ncurses_timeout(': 'int millisec | void',
-\ 'ncurses_top_panel(': 'resource panel | int',
-\ 'ncurses_typeahead(': 'int fd | int',
-\ 'ncurses_ungetch(': 'int keycode | int',
-\ 'ncurses_ungetmouse(': 'array mevent | bool',
-\ 'ncurses_update_panels(': 'void  | void',
-\ 'ncurses_use_default_colors(': 'void  | bool',
-\ 'ncurses_use_env(': 'bool flag | void',
-\ 'ncurses_use_extended_names(': 'bool flag | int',
-\ 'ncurses_vidattr(': 'int intarg | int',
-\ 'ncurses_vline(': 'int charattr, int n | int',
-\ 'ncurses_waddch(': 'resource window, int ch | int',
-\ 'ncurses_waddstr(': 'resource window, string str [, int n] | int',
-\ 'ncurses_wattroff(': 'resource window, int attrs | int',
-\ 'ncurses_wattron(': 'resource window, int attrs | int',
-\ 'ncurses_wattrset(': 'resource window, int attrs | int',
-\ 'ncurses_wborder(': 'resource window, int left, int right, int top, int bottom, int tl_corner, int tr_corner, int bl_corner, int br_corner | int',
-\ 'ncurses_wclear(': 'resource window | int',
-\ 'ncurses_wcolor_set(': 'resource window, int color_pair | int',
-\ 'ncurses_werase(': 'resource window | int',
-\ 'ncurses_wgetch(': 'resource window | int',
-\ 'ncurses_whline(': 'resource window, int charattr, int n | int',
-\ 'ncurses_wmouse_trafo(': 'resource window, int &#38;y, int &#38;x, bool toscreen | bool',
-\ 'ncurses_wmove(': 'resource window, int y, int x | int',
-\ 'ncurses_wnoutrefresh(': 'resource window | int',
-\ 'ncurses_wrefresh(': 'resource window | int',
-\ 'ncurses_wstandend(': 'resource window | int',
-\ 'ncurses_wstandout(': 'resource window | int',
-\ 'ncurses_wvline(': 'resource window, int charattr, int n | int',
-\ 'newt_bell(': 'void  | void',
-\ 'newt_button_bar(': 'array &#38;buttons | resource',
-\ 'newt_button(': 'int left, int top, string text | resource',
-\ 'newt_centered_window(': 'int width, int height [, string title] | int',
-\ 'newt_checkbox_get_value(': 'resource checkbox | string',
-\ 'newt_checkbox(': 'int left, int top, string text, string def_value [, string seq] | resource',
-\ 'newt_checkbox_set_flags(': 'resource checkbox, int flags, int sense | void',
-\ 'newt_checkbox_set_value(': 'resource checkbox, string value | void',
-\ 'newt_checkbox_tree_add_item(': 'resource checkboxtree, string text, mixed data, int flags, int index [, int ...] | void',
-\ 'newt_checkbox_tree_find_item(': 'resource checkboxtree, mixed data | array',
-\ 'newt_checkbox_tree_get_current(': 'resource checkboxtree | mixed',
-\ 'newt_checkbox_tree_get_entry_value(': 'resource checkboxtree, mixed data | string',
-\ 'newt_checkbox_tree_get_multi_selection(': 'resource checkboxtree, string seqnum | array',
-\ 'newt_checkbox_tree_get_selection(': 'resource checkboxtree | array',
-\ 'newt_checkbox_tree(': 'int left, int top, int height [, int flags] | resource',
-\ 'newt_checkbox_tree_multi(': 'int left, int top, int height, string seq [, int flags] | resource',
-\ 'newt_checkbox_tree_set_current(': 'resource checkboxtree, mixed data | void',
-\ 'newt_checkbox_tree_set_entry(': 'resource checkboxtree, mixed data, string text | void',
-\ 'newt_checkbox_tree_set_entry_value(': 'resource checkboxtree, mixed data, string value | void',
-\ 'newt_checkbox_tree_set_width(': 'resource checkbox_tree, int width | void',
-\ 'newt_clear_key_buffer(': 'void  | void',
-\ 'newt_cls(': 'void  | void',
-\ 'newt_compact_button(': 'int left, int top, string text | resource',
-\ 'newt_component_add_callback(': 'resource component, mixed func_name, mixed data | void',
-\ 'newt_component_takes_focus(': 'resource component, bool takes_focus | void',
-\ 'newt_create_grid(': 'int cols, int rows | resource',
-\ 'newt_cursor_off(': 'void  | void',
-\ 'newt_cursor_on(': 'void  | void',
-\ 'newt_delay(': 'int microseconds | void',
-\ 'newt_draw_form(': 'resource form | void',
-\ 'newt_draw_root_text(': 'int left, int top, string text | void',
-\ 'newt_entry_get_value(': 'resource entry | string',
-\ 'newt_entry(': 'int left, int top, int width [, string init_value [, int flags]] | resource',
-\ 'newt_entry_set_filter(': 'resource entry, callback filter, mixed data | void',
-\ 'newt_entry_set_flags(': 'resource entry, int flags, int sense | void',
-\ 'newt_entry_set(': 'resource entry, string value [, bool cursor_at_end] | void',
-\ 'newt_finished(': 'void  | int',
-\ 'newt_form_add_component(': 'resource form, resource component | void',
-\ 'newt_form_add_components(': 'resource form, array components | void',
-\ 'newt_form_add_host_key(': 'resource form, int key | void',
-\ 'newt_form_destroy(': 'resource form | void',
-\ 'newt_form_get_current(': 'resource form | resource',
-\ 'newt_form(': '[resource vert_bar [, string help [, int flags]]] | resource',
-\ 'newt_form_run(': 'resource form, array &#38;exit_struct | void',
-\ 'newt_form_set_background(': 'resource from, int background | void',
-\ 'newt_form_set_height(': 'resource form, int height | void',
-\ 'newt_form_set_size(': 'resource form | void',
-\ 'newt_form_set_timer(': 'resource form, int milliseconds | void',
-\ 'newt_form_set_width(': 'resource form, int width | void',
-\ 'newt_form_watch_fd(': 'resource form, resource stream [, int flags] | void',
-\ 'newt_get_screen_size(': 'int &#38;cols, int &#38;rows | void',
-\ 'newt_grid_add_components_to_form(': 'resource grid, resource form, bool recurse | void',
-\ 'newt_grid_basic_window(': 'resource text, resource middle, resource buttons | resource',
-\ 'newt_grid_free(': 'resource grid, bool recurse | void',
-\ 'newt_grid_get_size(': 'resouce grid, int &#38;width, int &#38;height | void',
-\ 'newt_grid_h_close_stacked(': 'int element1_type, resource element1 [, int ... [, resource ...]] | resource',
-\ 'newt_grid_h_stacked(': 'int element1_type, resource element1 [, int ... [, resource ...]] | resource',
-\ 'newt_grid_place(': 'resource grid, int left, int top | void',
-\ 'newt_grid_set_field(': 'resource grid, int col, int row, int type, resource val, int pad_left, int pad_top, int pad_right, int pad_bottom, int anchor [, int flags] | void',
-\ 'newt_grid_simple_window(': 'resource text, resource middle, resource buttons | resource',
-\ 'newt_grid_v_close_stacked(': 'int element1_type, resource element1 [, int ... [, resource ...]] | resource',
-\ 'newt_grid_v_stacked(': 'int element1_type, resource element1 [, int ... [, resource ...]] | resource',
-\ 'newt_grid_wrapped_window_at(': 'resource grid, string title, int left, int top | void',
-\ 'newt_grid_wrapped_window(': 'resource grid, string title | void',
-\ 'newt_init(': 'void  | int',
-\ 'newt_label(': 'int left, int top, string text | resource',
-\ 'newt_label_set_text(': 'resource label, string text | void',
-\ 'newt_listbox_append_entry(': 'resource listbox, string text, mixed data | void',
-\ 'newt_listbox_clear(': 'resource listobx | void',
-\ 'newt_listbox_clear_selection(': 'resource listbox | void',
-\ 'newt_listbox_delete_entry(': 'resource listbox, mixed key | void',
-\ 'newt_listbox_get_current(': 'resource listbox | string',
-\ 'newt_listbox_get_selection(': 'resource listbox | array',
-\ 'newt_listbox(': 'int left, int top, int height [, int flags] | resource',
-\ 'newt_listbox_insert_entry(': 'resource listbox, string text, mixed data, mixed key | void',
-\ 'newt_listbox_item_count(': 'resource listbox | int',
-\ 'newt_listbox_select_item(': 'resource listbox, mixed key, int sense | void',
-\ 'newt_listbox_set_current_by_key(': 'resource listbox, mixed key | void',
-\ 'newt_listbox_set_current(': 'resource listbox, int num | void',
-\ 'newt_listbox_set_data(': 'resource listbox, int num, mixed data | void',
-\ 'newt_listbox_set_entry(': 'resource listbox, int num, string text | void',
-\ 'newt_listbox_set_width(': 'resource listbox, int width | void',
-\ 'newt_listitem_get_data(': 'resource item | mixed',
-\ 'newt_listitem(': 'int left, int top, string text, bool is_default, resouce prev_item, mixed data [, int flags] | resource',
-\ 'newt_listitem_set(': 'resource item, string text | void',
-\ 'newt_open_window(': 'int left, int top, int width, int height [, string title] | int',
-\ 'newt_pop_help_line(': 'void  | void',
-\ 'newt_pop_window(': 'void  | void',
-\ 'newt_push_help_line(': '[string text] | void',
-\ 'newt_radiobutton(': 'int left, int top, string text, bool is_default [, resource prev_button] | resource',
-\ 'newt_radio_get_current(': 'resource set_member | resource',
-\ 'newt_redraw_help_line(': 'void  | void',
-\ 'newt_reflow_text(': 'string text, int width, int flex_down, int flex_up, int &#38;actual_width, int &#38;actual_height | string',
-\ 'newt_refresh(': 'void  | void',
-\ 'newt_resize_screen(': '[bool redraw] | void',
-\ 'newt_resume(': 'void  | void',
-\ 'newt_run_form(': 'resource form | resource',
-\ 'newt_scale(': 'int left, int top, int width, int full_value | resource',
-\ 'newt_scale_set(': 'resource scale, int amount | void',
-\ 'newt_scrollbar_set(': 'resource scrollbar, int where, int total | void',
-\ 'newt_set_help_callback(': 'mixed function | void',
-\ 'newt_set_suspend_callback(': 'callback function, mixed data | void',
-\ 'newt_suspend(': 'void  | void',
-\ 'newt_texbox_set_text(': 'resource textbox, string text | void',
-\ 'newt_textbox_get_num_lines(': 'resource textbox | int',
-\ 'newt_textbox(': 'int left, int top, int width, int height [, int flags] | resource',
-\ 'newt_textbox_reflowed(': 'int left, int top, char *text, int width, int flex_down, int flex_up [, int flags] | resource',
-\ 'newt_textbox_set_height(': 'resource textbox, int height | void',
-\ 'newt_vertical_scrollbar(': 'int left, int top, int height [, int normal_colorset [, int thumb_colorset]] | resource',
-\ 'newt_wait_for_key(': 'void  | void',
-\ 'newt_win_choice(': 'string title, string button1_text, string button2_text, string format [, mixed args [, mixed ...]] | int',
-\ 'newt_win_entries(': 'string title, string text, int suggested_width, int flex_down, int flex_up, int data_width, array &#38;items, string button1 [, string ...] | int',
-\ 'newt_win_menu(': 'string title, string text, int suggestedWidth, int flexDown, int flexUp, int maxListHeight, array items, int &#38;listItem [, string button1 [, string ...]] | int',
-\ 'newt_win_message(': 'string title, string button_text, string format [, mixed args [, mixed ...]] | void',
-\ 'newt_win_messagev(': 'string title, string button_text, string format, array args | void',
-\ 'newt_win_ternary(': 'string title, string button1_text, string button2_text, string button3_text, string format [, mixed args [, mixed ...]] | int',
-\ 'next(': 'array &#38;array | mixed',
-\ 'ngettext(': 'string msgid1, string msgid2, int n | string',
-\ 'nl2br(': 'string string | string',
-\ 'nl_langinfo(': 'int item | string',
-\ 'notes_body(': 'string server, string mailbox, int msg_number | array',
-\ 'notes_copy_db(': 'string from_database_name, string to_database_name | bool',
-\ 'notes_create_db(': 'string database_name | bool',
-\ 'notes_create_note(': 'string database_name, string form_name | bool',
-\ 'notes_drop_db(': 'string database_name | bool',
-\ 'notes_find_note(': 'string database_name, string name [, string type] | int',
-\ 'notes_header_info(': 'string server, string mailbox, int msg_number | object',
-\ 'notes_list_msgs(': 'string db | bool',
-\ 'notes_mark_read(': 'string database_name, string user_name, string note_id | bool',
-\ 'notes_mark_unread(': 'string database_name, string user_name, string note_id | bool',
-\ 'notes_nav_create(': 'string database_name, string name | bool',
-\ 'notes_search(': 'string database_name, string keywords | array',
-\ 'notes_unread(': 'string database_name, string user_name | array',
-\ 'notes_version(': 'string database_name | float',
-\ 'nsapi_request_headers(': 'void  | array',
-\ 'nsapi_response_headers(': 'void  | array',
-\ 'nsapi_virtual(': 'string uri | bool',
-\ 'number_format(': 'float number [, int decimals [, string dec_point, string thousands_sep]] | string',
-\ 'ob_clean(': 'void  | void',
-\ 'ob_end_clean(': 'void  | bool',
-\ 'ob_end_flush(': 'void  | bool',
-\ 'ob_flush(': 'void  | void',
-\ 'ob_get_clean(': 'void  | string',
-\ 'ob_get_contents(': 'void  | string',
-\ 'ob_get_flush(': 'void  | string',
-\ 'ob_get_length(': 'void  | int',
-\ 'ob_get_level(': 'void  | int',
-\ 'ob_gzhandler(': 'string buffer, int mode | string',
-\ 'ob_iconv_handler(': 'string contents, int status | string',
-\ 'ob_implicit_flush(': '[int flag] | void',
-\ 'ob_list_handlers(': 'void  | array',
-\ 'ob_start(': '[callback output_callback [, int chunk_size [, bool erase]]] | bool',
-\ 'ob_tidyhandler(': 'string input [, int mode] | string',
-\ 'oci_bind_by_name(': 'resource stmt, string ph_name, mixed &#38;variable [, int maxlength [, int type]] | bool',
-\ 'oci_cancel(': 'resource stmt | bool',
-\ 'oci_close(': 'resource connection | bool',
-\ 'oci_commit(': 'resource connection | bool',
-\ 'oci_connect(': 'string username, string password [, string db [, string charset [, int session_mode]]] | resource',
-\ 'oci_define_by_name(': 'resource statement, string column_name, mixed &#38;variable [, int type] | bool',
-\ 'oci_error(': '[resource source] | array',
-\ 'oci_execute(': 'resource stmt [, int mode] | bool',
-\ 'oci_fetch_all(': 'resource statement, array &#38;output [, int skip [, int maxrows [, int flags]]] | int',
-\ 'oci_fetch_array(': 'resource statement [, int mode] | array',
-\ 'oci_fetch_assoc(': 'resource statement | array',
-\ 'oci_fetch(': 'resource statement | bool',
-\ 'ocifetchinto(': 'resource statement, array &#38;result [, int mode] | int',
-\ 'oci_fetch_object(': 'resource statement | object',
-\ 'oci_fetch_row(': 'resource statement | array',
-\ 'oci_field_is_null(': 'resource stmt, mixed field | bool',
-\ 'oci_field_name(': 'resource statement, int field | string',
-\ 'oci_field_precision(': 'resource statement, int field | int',
-\ 'oci_field_scale(': 'resource statement, int field | int',
-\ 'oci_field_size(': 'resource stmt, mixed field | int',
-\ 'oci_field_type(': 'resource stmt, int field | mixed',
-\ 'oci_field_type_raw(': 'resource statement, int field | int',
-\ 'oci_free_statement(': 'resource statement | bool',
-\ 'oci_internal_debug(': 'int onoff | void',
-\ 'oci_lob_copy(': 'OCI-Lob lob_to, OCI-Lob lob_from [, int length] | bool',
-\ 'oci_lob_is_equal(': 'OCI-Lob lob1, OCI-Lob lob2 | bool',
-\ 'oci_new_collection(': 'resource connection, string tdo [, string schema] | OCI-Collection',
-\ 'oci_new_connect(': 'string username, string password [, string db [, string charset [, int session_mode]]] | resource',
-\ 'oci_new_cursor(': 'resource connection | resource',
-\ 'oci_new_descriptor(': 'resource connection [, int type] | OCI-Lob',
-\ 'oci_num_fields(': 'resource statement | int',
-\ 'oci_num_rows(': 'resource stmt | int',
-\ 'oci_parse(': 'resource connection, string query | resource',
-\ 'oci_password_change(': 'resource connection, string username, string old_password, string new_password | bool',
-\ 'oci_pconnect(': 'string username, string password [, string db [, string charset [, int session_mode]]] | resource',
-\ 'oci_result(': 'resource statement, mixed field | mixed',
-\ 'oci_rollback(': 'resource connection | bool',
-\ 'oci_server_version(': 'resource connection | string',
-\ 'oci_set_prefetch(': 'resource statement [, int rows] | bool',
-\ 'oci_statement_type(': 'resource statement | string',
-\ 'octdec(': 'string octal_string | number',
-\ 'odbc_autocommit(': 'resource connection_id [, bool OnOff] | mixed',
-\ 'odbc_binmode(': 'resource result_id, int mode | bool',
-\ 'odbc_close_all(': 'void  | void',
-\ 'odbc_close(': 'resource connection_id | void',
-\ 'odbc_columnprivileges(': 'resource connection_id, string qualifier, string owner, string table_name, string column_name | resource',
-\ 'odbc_columns(': 'resource connection_id [, string qualifier [, string schema [, string table_name [, string column_name]]]] | resource',
-\ 'odbc_commit(': 'resource connection_id | bool',
-\ 'odbc_connect(': 'string dsn, string user, string password [, int cursor_type] | resource',
-\ 'odbc_cursor(': 'resource result_id | string',
-\ 'odbc_data_source(': 'resource connection_id, int fetch_type | array',
-\ 'odbc_do(': 'resource conn_id, string query | resource',
-\ 'odbc_error(': '[resource connection_id] | string',
-\ 'odbc_errormsg(': '[resource connection_id] | string',
-\ 'odbc_exec(': 'resource connection_id, string query_string [, int flags] | resource',
-\ 'odbc_execute(': 'resource result_id [, array parameters_array] | bool',
-\ 'odbc_fetch_array(': 'resource result [, int rownumber] | array',
-\ 'odbc_fetch_into(': 'resource result_id, array &#38;result_array [, int rownumber] | int',
-\ 'odbc_fetch_object(': 'resource result [, int rownumber] | object',
-\ 'odbc_fetch_row(': 'resource result_id [, int row_number] | bool',
-\ 'odbc_field_len(': 'resource result_id, int field_number | int',
-\ 'odbc_field_name(': 'resource result_id, int field_number | string',
-\ 'odbc_field_num(': 'resource result_id, string field_name | int',
-\ 'odbc_field_precision(': 'resource result_id, int field_number | int',
-\ 'odbc_field_scale(': 'resource result_id, int field_number | int',
-\ 'odbc_field_type(': 'resource result_id, int field_number | string',
-\ 'odbc_foreignkeys(': 'resource connection_id, string pk_qualifier, string pk_owner, string pk_table, string fk_qualifier, string fk_owner, string fk_table | resource',
-\ 'odbc_free_result(': 'resource result_id | bool',
-\ 'odbc_gettypeinfo(': 'resource connection_id [, int data_type] | resource',
-\ 'odbc_longreadlen(': 'resource result_id, int length | bool',
-\ 'odbc_next_result(': 'resource result_id | bool',
-\ 'odbc_num_fields(': 'resource result_id | int',
-\ 'odbc_num_rows(': 'resource result_id | int',
-\ 'odbc_pconnect(': 'string dsn, string user, string password [, int cursor_type] | resource',
-\ 'odbc_prepare(': 'resource connection_id, string query_string | resource',
-\ 'odbc_primarykeys(': 'resource connection_id, string qualifier, string owner, string table | resource',
-\ 'odbc_procedurecolumns(': 'resource connection_id [, string qualifier, string owner, string proc, string column] | resource',
-\ 'odbc_procedures(': 'resource connection_id [, string qualifier, string owner, string name] | resource',
-\ 'odbc_result_all(': 'resource result_id [, string format] | int',
-\ 'odbc_result(': 'resource result_id, mixed field | mixed',
-\ 'odbc_rollback(': 'resource connection_id | bool',
-\ 'odbc_setoption(': 'resource id, int function, int option, int param | bool',
-\ 'odbc_specialcolumns(': 'resource connection_id, int type, string qualifier, string owner, string table, int scope, int nullable | resource',
-\ 'odbc_statistics(': 'resource connection_id, string qualifier, string owner, string table_name, int unique, int accuracy | resource',
-\ 'odbc_tableprivileges(': 'resource connection_id, string qualifier, string owner, string name | resource',
-\ 'odbc_tables(': 'resource connection_id [, string qualifier [, string owner [, string name [, string types]]]] | resource',
-\ 'openal_buffer_create(': 'void  | resource',
-\ 'openal_buffer_data(': 'resource buffer, int format, string data, int freq | bool',
-\ 'openal_buffer_destroy(': 'resource buffer | bool',
-\ 'openal_buffer_get(': 'resource buffer, int property | int',
-\ 'openal_buffer_loadwav(': 'resource buffer, string wavfile | bool',
-\ 'openal_context_create(': 'resource device | resource',
-\ 'openal_context_current(': 'resource context | bool',
-\ 'openal_context_destroy(': 'resource context | bool',
-\ 'openal_context_process(': 'resource context | bool',
-\ 'openal_context_suspend(': 'resource context | bool',
-\ 'openal_device_close(': 'resource device | bool',
-\ 'openal_device_open(': '[string device_desc] | resource',
-\ 'openal_listener_get(': 'int property | mixed',
-\ 'openal_listener_set(': 'int property, mixed setting | bool',
-\ 'openal_source_create(': 'void  | resource',
-\ 'openal_source_destroy(': 'resource source | bool',
-\ 'openal_source_get(': 'resource source, int property | mixed',
-\ 'openal_source_pause(': 'resource source | bool',
-\ 'openal_source_play(': 'resource source | bool',
-\ 'openal_source_rewind(': 'resource source | bool',
-\ 'openal_source_set(': 'resource source, int property, mixed setting | bool',
-\ 'openal_source_stop(': 'resource source | bool',
-\ 'openal_stream(': 'resource source, int format, int rate | resource',
-\ 'opendir(': 'string path [, resource context] | resource',
-\ 'openlog(': 'string ident, int option, int facility | bool',
-\ 'openssl_csr_export(': 'resource csr, string &#38;out [, bool notext] | bool',
-\ 'openssl_csr_export_to_file(': 'resource csr, string outfilename [, bool notext] | bool',
-\ 'openssl_csr_new(': 'array dn, resource &#38;privkey [, array configargs [, array extraattribs]] | mixed',
-\ 'openssl_csr_sign(': 'mixed csr, mixed cacert, mixed priv_key, int days [, array configargs [, int serial]] | resource',
-\ 'openssl_error_string(': 'void  | string',
-\ 'openssl_free_key(': 'resource key_identifier | void',
-\ 'openssl_open(': 'string sealed_data, string &#38;open_data, string env_key, mixed priv_key_id | bool',
-\ 'openssl_pkcs7_decrypt(': 'string infilename, string outfilename, mixed recipcert [, mixed recipkey] | bool',
-\ 'openssl_pkcs7_encrypt(': 'string infile, string outfile, mixed recipcerts, array headers [, int flags [, int cipherid]] | bool',
-\ 'openssl_pkcs7_sign(': 'string infilename, string outfilename, mixed signcert, mixed privkey, array headers [, int flags [, string extracerts]] | bool',
-\ 'openssl_pkcs7_verify(': 'string filename, int flags [, string outfilename [, array cainfo [, string extracerts]]] | mixed',
-\ 'openssl_pkey_export(': 'mixed key, string &#38;out [, string passphrase [, array configargs]] | bool',
-\ 'openssl_pkey_export_to_file(': 'mixed key, string outfilename [, string passphrase [, array configargs]] | bool',
-\ 'openssl_pkey_free(': 'resource key | void',
-\ 'openssl_pkey_get_private(': 'mixed key [, string passphrase] | resource',
-\ 'openssl_pkey_get_public(': 'mixed certificate | resource',
-\ 'openssl_pkey_new(': '[array configargs] | resource',
-\ 'openssl_private_decrypt(': 'string data, string &#38;decrypted, mixed key [, int padding] | bool',
-\ 'openssl_private_encrypt(': 'string data, string &#38;crypted, mixed key [, int padding] | bool',
-\ 'openssl_public_decrypt(': 'string data, string &#38;decrypted, mixed key [, int padding] | bool',
-\ 'openssl_public_encrypt(': 'string data, string &#38;crypted, mixed key [, int padding] | bool',
-\ 'openssl_seal(': 'string data, string &#38;sealed_data, array &#38;env_keys, array pub_key_ids | int',
-\ 'openssl_sign(': 'string data, string &#38;signature, mixed priv_key_id [, int signature_alg] | bool',
-\ 'openssl_verify(': 'string data, string signature, mixed pub_key_id | int',
-\ 'openssl_x509_check_private_key(': 'mixed cert, mixed key | bool',
-\ 'openssl_x509_checkpurpose(': 'mixed x509cert, int purpose [, array cainfo [, string untrustedfile]] | int',
-\ 'openssl_x509_export(': 'mixed x509, string &#38;output [, bool notext] | bool',
-\ 'openssl_x509_export_to_file(': 'mixed x509, string outfilename [, bool notext] | bool',
-\ 'openssl_x509_free(': 'resource x509cert | void',
-\ 'openssl_x509_parse(': 'mixed x509cert [, bool shortnames] | array',
-\ 'openssl_x509_read(': 'mixed x509certdata | resource',
-\ 'ora_bind(': 'resource cursor, string PHP_variable_name, string SQL_parameter_name, int length [, int type] | bool',
-\ 'ora_close(': 'resource cursor | bool',
-\ 'ora_columnname(': 'resource cursor, int column | string',
-\ 'ora_columnsize(': 'resource cursor, int column | int',
-\ 'ora_columntype(': 'resource cursor, int column | string',
-\ 'ora_commit(': 'resource conn | bool',
-\ 'ora_commitoff(': 'resource conn | bool',
-\ 'ora_commiton(': 'resource conn | bool',
-\ 'ora_do(': 'resource conn, string query | resource',
-\ 'ora_errorcode(': '[resource cursor_or_connection] | int',
-\ 'ora_error(': '[resource cursor_or_connection] | string',
-\ 'ora_exec(': 'resource cursor | bool',
-\ 'ora_fetch(': 'resource cursor | bool',
-\ 'ora_fetch_into(': 'resource cursor, array &#38;result [, int flags] | int',
-\ 'ora_getcolumn(': 'resource cursor, int column | string',
-\ 'ora_logoff(': 'resource connection | bool',
-\ 'ora_logon(': 'string user, string password | resource',
-\ 'ora_numcols(': 'resource cursor | int',
-\ 'ora_numrows(': 'resource cursor | int',
-\ 'ora_open(': 'resource connection | resource',
-\ 'ora_parse(': 'resource cursor, string sql_statement [, int defer] | bool',
-\ 'ora_plogon(': 'string user, string password | resource',
-\ 'ora_rollback(': 'resource connection | bool',
-\ 'OrbitEnum(': 'string id | new',
-\ 'OrbitObject(': 'string ior | new',
-\ 'OrbitStruct(': 'string id | new',
-\ 'ord(': 'string string | int',
-\ 'output_add_rewrite_var(': 'string name, string value | bool',
-\ 'output_reset_rewrite_vars(': 'void  | bool',
-\ 'overload(': '[string class_name] | void',
-\ 'override_function(': 'string function_name, string function_args, string function_code | bool',
-\ 'ovrimos_close(': 'int connection | void',
-\ 'ovrimos_commit(': 'int connection_id | bool',
-\ 'ovrimos_connect(': 'string host, string db, string user, string password | int',
-\ 'ovrimos_cursor(': 'int result_id | string',
-\ 'ovrimos_exec(': 'int connection_id, string query | int',
-\ 'ovrimos_execute(': 'int result_id [, array parameters_array] | bool',
-\ 'ovrimos_fetch_into(': 'int result_id, array &#38;result_array [, string how [, int rownumber]] | bool',
-\ 'ovrimos_fetch_row(': 'int result_id [, int how [, int row_number]] | bool',
-\ 'ovrimos_field_len(': 'int result_id, int field_number | int',
-\ 'ovrimos_field_name(': 'int result_id, int field_number | string',
-\ 'ovrimos_field_num(': 'int result_id, string field_name | int',
-\ 'ovrimos_field_type(': 'int result_id, int field_number | int',
-\ 'ovrimos_free_result(': 'int result_id | bool',
-\ 'ovrimos_longreadlen(': 'int result_id, int length | bool',
-\ 'ovrimos_num_fields(': 'int result_id | int',
-\ 'ovrimos_num_rows(': 'int result_id | int',
-\ 'ovrimos_prepare(': 'int connection_id, string query | int',
-\ 'ovrimos_result_all(': 'int result_id [, string format] | int',
-\ 'ovrimos_result(': 'int result_id, mixed field | string',
-\ 'ovrimos_rollback(': 'int connection_id | bool',
-\ 'pack(': 'string format [, mixed args [, mixed ...]] | string',
-\ 'parse_ini_file(': 'string filename [, bool process_sections] | array',
-\ 'parsekit_compile_file(': 'string filename [, array &#38;errors [, int options]] | array',
-\ 'parsekit_compile_string(': 'string phpcode [, array &#38;errors [, int options]] | array',
-\ 'parsekit_func_arginfo(': 'mixed function | array',
-\ 'parse_str(': 'string str [, array &#38;arr] | void',
-\ 'parse_url(': 'string url | array',
-\ 'passthru(': 'string command [, int &#38;return_var] | void',
-\ 'pathinfo(': 'string path [, int options] | mixed',
-\ 'pclose(': 'resource handle | int',
-\ 'pcntl_alarm(': 'int seconds | int',
-\ 'pcntl_exec(': 'string path [, array args [, array envs]] | void',
-\ 'pcntl_fork(': 'void  | int',
-\ 'pcntl_getpriority(': '[int pid [, int process_identifier]] | int',
-\ 'pcntl_setpriority(': 'int priority [, int pid [, int process_identifier]] | bool',
-\ 'pcntl_signal(': 'int signo, callback handle [, bool restart_syscalls] | bool',
-\ 'pcntl_wait(': 'int &#38;status [, int options] | int',
-\ 'pcntl_waitpid(': 'int pid, int &#38;status [, int options] | int',
-\ 'pcntl_wexitstatus(': 'int status | int',
-\ 'pcntl_wifexited(': 'int status | bool',
-\ 'pcntl_wifsignaled(': 'int status | bool',
-\ 'pcntl_wifstopped(': 'int status | bool',
-\ 'pcntl_wstopsig(': 'int status | int',
-\ 'pcntl_wtermsig(': 'int status | int',
-\ 'pdf_activate_item(': 'resource pdfdoc, int id | bool',
-\ 'pdf_add_launchlink(': 'resource pdfdoc, float llx, float lly, float urx, float ury, string filename | bool',
-\ 'pdf_add_locallink(': 'resource pdfdoc, float lowerleftx, float lowerlefty, float upperrightx, float upperrighty, int page, string dest | bool',
-\ 'pdf_add_nameddest(': 'resource pdfdoc, string name, string optlist | bool',
-\ 'pdf_add_note(': 'resource pdfdoc, float llx, float lly, float urx, float ury, string contents, string title, string icon, int open | bool',
-\ 'pdf_add_pdflink(': 'resource pdfdoc, float bottom_left_x, float bottom_left_y, float up_right_x, float up_right_y, string filename, int page, string dest | bool',
-\ 'pdf_add_thumbnail(': 'resource pdfdoc, int image | bool',
-\ 'pdf_add_weblink(': 'resource pdfdoc, float lowerleftx, float lowerlefty, float upperrightx, float upperrighty, string url | bool',
-\ 'pdf_arc(': 'resource p, float x, float y, float r, float alpha, float beta | bool',
-\ 'pdf_arcn(': 'resource p, float x, float y, float r, float alpha, float beta | bool',
-\ 'pdf_attach_file(': 'resource pdfdoc, float llx, float lly, float urx, float ury, string filename, string description, string author, string mimetype, string icon | bool',
-\ 'pdf_begin_document(': 'resource pdfdoc, string filename, string optlist | int',
-\ 'pdf_begin_font(': 'resource pdfdoc, string filename, float a, float b, float c, float d, float e, float f, string optlist | bool',
-\ 'pdf_begin_glyph(': 'resource pdfdoc, string glyphname, float wx, float llx, float lly, float urx, float ury | bool',
-\ 'pdf_begin_item(': 'resource pdfdoc, string tag, string optlist | int',
-\ 'pdf_begin_layer(': 'resource pdfdoc, int layer | bool',
-\ 'pdf_begin_page_ext(': 'resource pdfdoc, float width, float height, string optlist | bool',
-\ 'pdf_begin_page(': 'resource pdfdoc, float width, float height | bool',
-\ 'pdf_begin_pattern(': 'resource pdfdoc, float width, float height, float xstep, float ystep, int painttype | int',
-\ 'pdf_begin_template(': 'resource pdfdoc, float width, float height | int',
-\ 'pdf_circle(': 'resource pdfdoc, float x, float y, float r | bool',
-\ 'pdf_clip(': 'resource p | bool',
-\ 'pdf_close(': 'resource p | bool',
-\ 'pdf_close_image(': 'resource p, int image | void',
-\ 'pdf_closepath_fill_stroke(': 'resource p | bool',
-\ 'pdf_closepath(': 'resource p | bool',
-\ 'pdf_closepath_stroke(': 'resource p | bool',
-\ 'pdf_close_pdi(': 'resource p, int doc | bool',
-\ 'pdf_close_pdi_page(': 'resource p, int page | bool',
-\ 'pdf_concat(': 'resource p, float a, float b, float c, float d, float e, float f | bool',
-\ 'pdf_continue_text(': 'resource p, string text | bool',
-\ 'pdf_create_action(': 'resource pdfdoc, string type, string optlist | int',
-\ 'pdf_create_annotation(': 'resource pdfdoc, float llx, float lly, float urx, float ury, string type, string optlist | bool',
-\ 'pdf_create_bookmark(': 'resource pdfdoc, string text, string optlist | int',
-\ 'pdf_create_fieldgroup(': 'resource pdfdoc, string name, string optlist | bool',
-\ 'pdf_create_field(': 'resource pdfdoc, float llx, float lly, float urx, float ury, string name, string type, string optlist | bool',
-\ 'pdf_create_gstate(': 'resource pdfdoc, string optlist | int',
-\ 'pdf_create_pvf(': 'resource pdfdoc, string filename, string data, string optlist | bool',
-\ 'pdf_create_textflow(': 'resource pdfdoc, string text, string optlist | int',
-\ 'pdf_curveto(': 'resource p, float x1, float y1, float x2, float y2, float x3, float y3 | bool',
-\ 'pdf_define_layer(': 'resource pdfdoc, string name, string optlist | int',
-\ 'pdf_delete(': 'resource pdfdoc | bool',
-\ 'pdf_delete_pvf(': 'resource pdfdoc, string filename | int',
-\ 'pdf_delete_textflow(': 'resource pdfdoc, int textflow | bool',
-\ 'pdf_encoding_set_char(': 'resource pdfdoc, string encoding, int slot, string glyphname, int uv | bool',
-\ 'pdf_end_document(': 'resource pdfdoc, string optlist | bool',
-\ 'pdf_end_font(': 'resource pdfdoc | bool',
-\ 'pdf_end_glyph(': 'resource pdfdoc | bool',
-\ 'pdf_end_item(': 'resource pdfdoc, int id | bool',
-\ 'pdf_end_layer(': 'resource pdfdoc | bool',
-\ 'pdf_end_page_ext(': 'resource pdfdoc, string optlist | bool',
-\ 'pdf_end_page(': 'resource p | bool',
-\ 'pdf_end_pattern(': 'resource p | bool',
-\ 'pdf_end_template(': 'resource p | bool',
-\ 'pdf_fill(': 'resource p | bool',
-\ 'pdf_fill_imageblock(': 'resource pdfdoc, int page, string blockname, int image, string optlist | int',
-\ 'pdf_fill_pdfblock(': 'resource pdfdoc, int page, string blockname, int contents, string optlist | int',
-\ 'pdf_fill_stroke(': 'resource p | bool',
-\ 'pdf_fill_textblock(': 'resource pdfdoc, int page, string blockname, string text, string optlist | int',
-\ 'pdf_findfont(': 'resource p, string fontname, string encoding, int embed | int',
-\ 'pdf_fit_image(': 'resource pdfdoc, int image, float x, float y, string optlist | bool',
-\ 'pdf_fit_pdi_page(': 'resource pdfdoc, int page, float x, float y, string optlist | bool',
-\ 'pdf_fit_textflow(': 'resource pdfdoc, int textflow, float llx, float lly, float urx, float ury, string optlist | string',
-\ 'pdf_fit_textline(': 'resource pdfdoc, string text, float x, float y, string optlist | bool',
-\ 'pdf_get_apiname(': 'resource pdfdoc | string',
-\ 'pdf_get_buffer(': 'resource p | string',
-\ 'pdf_get_errmsg(': 'resource pdfdoc | string',
-\ 'pdf_get_errnum(': 'resource pdfdoc | int',
-\ 'pdf_get_majorversion(': 'void  | int',
-\ 'pdf_get_minorversion(': 'void  | int',
-\ 'pdf_get_parameter(': 'resource p, string key, float modifier | string',
-\ 'pdf_get_pdi_parameter(': 'resource p, string key, int doc, int page, int reserved | string',
-\ 'pdf_get_pdi_value(': 'resource p, string key, int doc, int page, int reserved | float',
-\ 'pdf_get_value(': 'resource p, string key, float modifier | float',
-\ 'pdf_info_textflow(': 'resource pdfdoc, int textflow, string keyword | float',
-\ 'pdf_initgraphics(': 'resource p | bool',
-\ 'pdf_lineto(': 'resource p, float x, float y | bool',
-\ 'pdf_load_font(': 'resource pdfdoc, string fontname, string encoding, string optlist | int',
-\ 'pdf_load_iccprofile(': 'resource pdfdoc, string profilename, string optlist | int',
-\ 'pdf_load_image(': 'resource pdfdoc, string imagetype, string filename, string optlist | int',
-\ 'pdf_makespotcolor(': 'resource p, string spotname | int',
-\ 'pdf_moveto(': 'resource p, float x, float y | bool',
-\ 'pdf_new(': ' | resource',
-\ 'pdf_open_ccitt(': 'resource pdfdoc, string filename, int width, int height, int BitReverse, int k, int Blackls1 | int',
-\ 'pdf_open_file(': 'resource p, string filename | bool',
-\ 'pdf_open_image_file(': 'resource p, string imagetype, string filename, string stringparam, int intparam | int',
-\ 'pdf_open_image(': 'resource p, string imagetype, string source, string data, int length, int width, int height, int components, int bpc, string params | int',
-\ 'pdf_open_memory_image(': 'resource p, resource image | int',
-\ 'pdf_open_pdi(': 'resource pdfdoc, string filename, string optlist, int len | int',
-\ 'pdf_open_pdi_page(': 'resource p, int doc, int pagenumber, string optlist | int',
-\ 'pdf_place_image(': 'resource pdfdoc, int image, float x, float y, float scale | bool',
-\ 'pdf_place_pdi_page(': 'resource pdfdoc, int page, float x, float y, float sx, float sy | bool',
-\ 'pdf_process_pdi(': 'resource pdfdoc, int doc, int page, string optlist | int',
-\ 'pdf_rect(': 'resource p, float x, float y, float width, float height | bool',
-\ 'pdf_restore(': 'resource p | bool',
-\ 'pdf_resume_page(': 'resource pdfdoc, string optlist | bool',
-\ 'pdf_rotate(': 'resource p, float phi | bool',
-\ 'pdf_save(': 'resource p | bool',
-\ 'pdf_scale(': 'resource p, float sx, float sy | bool',
-\ 'pdf_set_border_color(': 'resource p, float red, float green, float blue | bool',
-\ 'pdf_set_border_dash(': 'resource pdfdoc, float black, float white | bool',
-\ 'pdf_set_border_style(': 'resource pdfdoc, string style, float width | bool',
-\ 'pdf_setcolor(': 'resource p, string fstype, string colorspace, float c1, float c2, float c3, float c4 | bool',
-\ 'pdf_setdash(': 'resource pdfdoc, float b, float w | bool',
-\ 'pdf_setdashpattern(': 'resource pdfdoc, string optlist | bool',
-\ 'pdf_setflat(': 'resource pdfdoc, float flatness | bool',
-\ 'pdf_setfont(': 'resource pdfdoc, int font, float fontsize | bool',
-\ 'pdf_setgray_fill(': 'resource p, float g | bool',
-\ 'pdf_setgray(': 'resource p, float g | bool',
-\ 'pdf_setgray_stroke(': 'resource p, float g | bool',
-\ 'pdf_set_gstate(': 'resource pdfdoc, int gstate | bool',
-\ 'pdf_set_info(': 'resource p, string key, string value | bool',
-\ 'pdf_set_layer_dependency(': 'resource pdfdoc, string type, string optlist | bool',
-\ 'pdf_setlinecap(': 'resource p, int linecap | bool',
-\ 'pdf_setlinejoin(': 'resource p, int value | bool',
-\ 'pdf_setlinewidth(': 'resource p, float width | bool',
-\ 'pdf_setmatrix(': 'resource p, float a, float b, float c, float d, float e, float f | bool',
-\ 'pdf_setmiterlimit(': 'resource pdfdoc, float miter | bool',
-\ 'pdf_set_parameter(': 'resource p, string key, string value | bool',
-\ 'pdf_setrgbcolor_fill(': 'resource p, float red, float green, float blue | bool',
-\ 'pdf_setrgbcolor(': 'resource p, float red, float green, float blue | bool',
-\ 'pdf_setrgbcolor_stroke(': 'resource p, float red, float green, float blue | bool',
-\ 'pdf_set_text_pos(': 'resource p, float x, float y | bool',
-\ 'pdf_set_value(': 'resource p, string key, float value | bool',
-\ 'pdf_shading(': 'resource pdfdoc, string shtype, float x0, float y0, float x1, float y1, float c1, float c2, float c3, float c4, string optlist | int',
-\ 'pdf_shading_pattern(': 'resource pdfdoc, int shading, string optlist | int',
-\ 'pdf_shfill(': 'resource pdfdoc, int shading | bool',
-\ 'pdf_show_boxed(': 'resource p, string text, float left, float top, float width, float height, string mode, string feature | int',
-\ 'pdf_show(': 'resource pdfdoc, string text | bool',
-\ 'pdf_show_xy(': 'resource p, string text, float x, float y | bool',
-\ 'pdf_skew(': 'resource p, float alpha, float beta | bool',
-\ 'pdf_stringwidth(': 'resource p, string text, int font, float fontsize | float',
-\ 'pdf_stroke(': 'resource p | bool',
-\ 'pdf_suspend_page(': 'resource pdfdoc, string optlist | bool',
-\ 'pdf_translate(': 'resource p, float tx, float ty | bool',
-\ 'pdf_utf16_to_utf8(': 'resource pdfdoc, string utf16string | string',
-\ 'pdf_utf8_to_utf16(': 'resource pdfdoc, string utf8string, string ordering | string',
-\ 'pdf_xshow(': 'resource pdfdoc, string text | bool',
-\ 'pfpro_cleanup(': 'void  | bool',
-\ 'pfpro_init(': 'void  | bool',
-\ 'pfpro_process(': 'array parameters [, string address [, int port [, int timeout [, string proxy_address [, int proxy_port [, string proxy_logon [, string proxy_password]]]]]]] | array',
-\ 'pfpro_process_raw(': 'string parameters [, string address [, int port [, int timeout [, string proxy_address [, int proxy_port [, string proxy_logon [, string proxy_password]]]]]]] | string',
-\ 'pfpro_version(': 'void  | string',
-\ 'pfsockopen(': 'string hostname [, int port [, int &#38;errno [, string &#38;errstr [, float timeout]]]] | resource',
-\ 'pg_affected_rows(': 'resource result | int',
-\ 'pg_cancel_query(': 'resource connection | bool',
-\ 'pg_client_encoding(': '[resource connection] | string',
-\ 'pg_close(': '[resource connection] | bool',
-\ 'pg_connect(': 'string connection_string [, int connect_type] | resource',
-\ 'pg_connection_busy(': 'resource connection | bool',
-\ 'pg_connection_reset(': 'resource connection | bool',
-\ 'pg_connection_status(': 'resource connection | int',
-\ 'pg_convert(': 'resource connection, string table_name, array assoc_array [, int options] | array',
-\ 'pg_copy_from(': 'resource connection, string table_name, array rows [, string delimiter [, string null_as]] | bool',
-\ 'pg_copy_to(': 'resource connection, string table_name [, string delimiter [, string null_as]] | array',
-\ 'pg_dbname(': '[resource connection] | string',
-\ 'pg_delete(': 'resource connection, string table_name, array assoc_array [, int options] | mixed',
-\ 'pg_end_copy(': '[resource connection] | bool',
-\ 'pg_escape_bytea(': 'string data | string',
-\ 'pg_escape_string(': 'string data | string',
-\ 'pg_execute(': 'resource connection, string stmtname, array params | resource',
-\ 'pg_fetch_all_columns(': 'resource result [, int column] | array',
-\ 'pg_fetch_all(': 'resource result | array',
-\ 'pg_fetch_array(': 'resource result [, int row [, int result_type]] | array',
-\ 'pg_fetch_assoc(': 'resource result [, int row] | array',
-\ 'pg_fetch_object(': 'resource result [, int row [, int result_type]] | object',
-\ 'pg_fetch_result(': 'resource result, int row, mixed field | string',
-\ 'pg_fetch_row(': 'resource result [, int row] | array',
-\ 'pg_field_is_null(': 'resource result, int row, mixed field | int',
-\ 'pg_field_name(': 'resource result, int field_number | string',
-\ 'pg_field_num(': 'resource result, string field_name | int',
-\ 'pg_field_prtlen(': 'resource result, int row_number, mixed field_name_or_number | int',
-\ 'pg_field_size(': 'resource result, int field_number | int',
-\ 'pg_field_type(': 'resource result, int field_number | string',
-\ 'pg_field_type_oid(': 'resource result, int field_number | int',
-\ 'pg_free_result(': 'resource result | bool',
-\ 'pg_get_notify(': 'resource connection [, int result_type] | array',
-\ 'pg_get_pid(': 'resource connection | int',
-\ 'pg_get_result(': '[resource connection] | resource',
-\ 'pg_host(': '[resource connection] | string',
-\ 'pg_insert(': 'resource connection, string table_name, array assoc_array [, int options] | mixed',
-\ 'pg_last_error(': '[resource connection] | string',
-\ 'pg_last_notice(': 'resource connection | string',
-\ 'pg_last_oid(': 'resource result | string',
-\ 'pg_lo_close(': 'resource large_object | bool',
-\ 'pg_lo_create(': '[resource connection] | int',
-\ 'pg_lo_export(': 'resource connection, int oid, string pathname | bool',
-\ 'pg_lo_import(': 'resource connection, string pathname | int',
-\ 'pg_lo_open(': 'resource connection, int oid, string mode | resource',
-\ 'pg_lo_read_all(': 'resource large_object | int',
-\ 'pg_lo_read(': 'resource large_object [, int len] | string',
-\ 'pg_lo_seek(': 'resource large_object, int offset [, int whence] | bool',
-\ 'pg_lo_tell(': 'resource large_object | int',
-\ 'pg_lo_unlink(': 'resource connection, int oid | bool',
-\ 'pg_lo_write(': 'resource large_object, string data [, int len] | int',
-\ 'pg_meta_data(': 'resource connection, string table_name | array',
-\ 'pg_num_fields(': 'resource result | int',
-\ 'pg_num_rows(': 'resource result | int',
-\ 'pg_options(': '[resource connection] | string',
-\ 'pg_parameter_status(': 'resource connection, string param_name | string',
-\ 'pg_pconnect(': 'string connection_string [, int connect_type] | resource',
-\ 'pg_ping(': '[resource connection] | bool',
-\ 'pg_port(': '[resource connection] | int',
-\ 'pg_prepare(': 'resource connection, string stmtname, string query | resource',
-\ 'pg_put_line(': 'string data | bool',
-\ 'pg_query(': 'string query | resource',
-\ 'pg_query_params(': 'resource connection, string query, array params | resource',
-\ 'pg_result_error_field(': 'resource result, int fieldcode | string',
-\ 'pg_result_error(': 'resource result | string',
-\ 'pg_result_seek(': 'resource result, int offset | bool',
-\ 'pg_result_status(': 'resource result [, int type] | mixed',
-\ 'pg_select(': 'resource connection, string table_name, array assoc_array [, int options] | mixed',
-\ 'pg_send_execute(': 'resource connection, string stmtname, array params | bool',
-\ 'pg_send_prepare(': 'resource connection, string stmtname, string query | bool',
-\ 'pg_send_query(': 'resource connection, string query | bool',
-\ 'pg_send_query_params(': 'resource connection, string query, array params | bool',
-\ 'pg_set_client_encoding(': 'string encoding | int',
-\ 'pg_set_error_verbosity(': 'resource connection, int verbosity | int',
-\ 'pg_trace(': 'string pathname [, string mode [, resource connection]] | bool',
-\ 'pg_transaction_status(': 'resource connection | int',
-\ 'pg_tty(': '[resource connection] | string',
-\ 'pg_unescape_bytea(': 'string data | string',
-\ 'pg_untrace(': '[resource connection] | bool',
-\ 'pg_update(': 'resource connection, string table_name, array data, array condition [, int options] | mixed',
-\ 'pg_version(': '[resource connection] | array',
-\ 'php_check_syntax(': 'string file_name [, string &#38;error_message] | bool',
-\ 'phpcredits(': '[int flag] | bool',
-\ 'phpinfo(': '[int what] | bool',
-\ 'php_ini_scanned_files(': 'void  | string',
-\ 'php_logo_guid(': 'void  | string',
-\ 'php_sapi_name(': 'void  | string',
-\ 'php_strip_whitespace(': 'string filename | string',
-\ 'php_uname(': '[string mode] | string',
-\ 'phpversion(': '[string extension] | string',
-\ 'pi(': 'void  | float',
-\ 'png2wbmp(': 'string pngname, string wbmpname, int d_height, int d_width, int threshold | int',
-\ 'popen(': 'string command, string mode | resource',
-\ 'posix_access(': 'string file [, int mode] | bool',
-\ 'posix_ctermid(': 'void  | string',
-\ 'posix_getcwd(': 'void  | string',
-\ 'posix_getegid(': 'void  | int',
-\ 'posix_geteuid(': 'void  | int',
-\ 'posix_getgid(': 'void  | int',
-\ 'posix_getgrgid(': 'int gid | array',
-\ 'posix_getgrnam(': 'string name | array',
-\ 'posix_getgroups(': 'void  | array',
-\ 'posix_get_last_error(': 'void  | int',
-\ 'posix_getlogin(': 'void  | string',
-\ 'posix_getpgid(': 'int pid | int',
-\ 'posix_getpgrp(': 'void  | int',
-\ 'posix_getpid(': 'void  | int',
-\ 'posix_getppid(': 'void  | int',
-\ 'posix_getpwnam(': 'string username | array',
-\ 'posix_getpwuid(': 'int uid | array',
-\ 'posix_getrlimit(': 'void  | array',
-\ 'posix_getsid(': 'int pid | int',
-\ 'posix_getuid(': 'void  | int',
-\ 'posix_isatty(': 'int fd | bool',
-\ 'posix_kill(': 'int pid, int sig | bool',
-\ 'posix_mkfifo(': 'string pathname, int mode | bool',
-\ 'posix_mknod(': 'string pathname, int mode [, int major [, int minor]] | bool',
-\ 'posix_setegid(': 'int gid | bool',
-\ 'posix_seteuid(': 'int uid | bool',
-\ 'posix_setgid(': 'int gid | bool',
-\ 'posix_setpgid(': 'int pid, int pgid | bool',
-\ 'posix_setsid(': 'void  | int',
-\ 'posix_setuid(': 'int uid | bool',
-\ 'posix_strerror(': 'int errno | string',
-\ 'posix_times(': 'void  | array',
-\ 'posix_ttyname(': 'int fd | string',
-\ 'posix_uname(': 'void  | array',
-\ 'pow(': 'number base, number exp | number',
-\ 'preg_grep(': 'string pattern, array input [, int flags] | array',
-\ 'preg_match_all(': 'string pattern, string subject, array &#38;matches [, int flags [, int offset]] | int',
-\ 'preg_match(': 'string pattern, string subject [, array &#38;matches [, int flags [, int offset]]] | int',
-\ 'preg_quote(': 'string str [, string delimiter] | string',
-\ 'preg_replace_callback(': 'mixed pattern, callback callback, mixed subject [, int limit [, int &#38;count]] | mixed',
-\ 'preg_replace(': 'mixed pattern, mixed replacement, mixed subject [, int limit [, int &#38;count]] | mixed',
-\ 'preg_split(': 'string pattern, string subject [, int limit [, int flags]] | array',
-\ 'prev(': 'array &#38;array | mixed',
-\ 'printer_abort(': 'resource handle | void',
-\ 'printer_close(': 'resource handle | void',
-\ 'printer_create_brush(': 'int style, string color | resource',
-\ 'printer_create_dc(': 'resource handle | void',
-\ 'printer_create_font(': 'string face, int height, int width, int font_weight, bool italic, bool underline, bool strikeout, int orientation | resource',
-\ 'printer_create_pen(': 'int style, int width, string color | resource',
-\ 'printer_delete_brush(': 'resource handle | void',
-\ 'printer_delete_dc(': 'resource handle | bool',
-\ 'printer_delete_font(': 'resource handle | void',
-\ 'printer_delete_pen(': 'resource handle | void',
-\ 'printer_draw_bmp(': 'resource handle, string filename, int x, int y [, int width, int height] | bool',
-\ 'printer_draw_chord(': 'resource handle, int rec_x, int rec_y, int rec_x1, int rec_y1, int rad_x, int rad_y, int rad_x1, int rad_y1 | void',
-\ 'printer_draw_elipse(': 'resource handle, int ul_x, int ul_y, int lr_x, int lr_y | void',
-\ 'printer_draw_line(': 'resource printer_handle, int from_x, int from_y, int to_x, int to_y | void',
-\ 'printer_draw_pie(': 'resource handle, int rec_x, int rec_y, int rec_x1, int rec_y1, int rad1_x, int rad1_y, int rad2_x, int rad2_y | void',
-\ 'printer_draw_rectangle(': 'resource handle, int ul_x, int ul_y, int lr_x, int lr_y | void',
-\ 'printer_draw_roundrect(': 'resource handle, int ul_x, int ul_y, int lr_x, int lr_y, int width, int height | void',
-\ 'printer_draw_text(': 'resource printer_handle, string text, int x, int y | void',
-\ 'printer_end_doc(': 'resource handle | bool',
-\ 'printer_end_page(': 'resource handle | bool',
-\ 'printer_get_option(': 'resource handle, string option | mixed',
-\ 'printer_list(': 'int enumtype [, string name [, int level]] | array',
-\ 'printer_logical_fontheight(': 'resource handle, int height | int',
-\ 'printer_open(': '[string devicename] | resource',
-\ 'printer_select_brush(': 'resource printer_handle, resource brush_handle | void',
-\ 'printer_select_font(': 'resource printer_handle, resource font_handle | void',
-\ 'printer_select_pen(': 'resource printer_handle, resource pen_handle | void',
-\ 'printer_set_option(': 'resource handle, int option, mixed value | bool',
-\ 'printer_start_doc(': 'resource handle [, string document] | bool',
-\ 'printer_start_page(': 'resource handle | bool',
-\ 'printer_write(': 'resource handle, string content | bool',
-\ 'printf(': 'string format [, mixed args [, mixed ...]] | int',
-\ 'print(': 'string arg | int',
-\ 'print_r(': 'mixed expression [, bool return] | bool',
-\ 'proc_close(': 'resource process | int',
-\ 'proc_get_status(': 'resource process | array',
-\ 'proc_nice(': 'int increment | bool',
-\ 'proc_open(': 'string cmd, array descriptorspec, array &#38;pipes [, string cwd [, array env [, array other_options]]] | resource',
-\ 'proc_terminate(': 'resource process [, int signal] | int',
-\ 'property_exists(': 'mixed class, string property | bool',
-\ 'ps_add_bookmark(': 'resource psdoc, string text [, int parent [, int open]] | int',
-\ 'ps_add_launchlink(': 'resource psdoc, float llx, float lly, float urx, float ury, string filename | bool',
-\ 'ps_add_locallink(': 'resource psdoc, float llx, float lly, float urx, float ury, int page, string dest | bool',
-\ 'ps_add_note(': 'resource psdoc, float llx, float lly, float urx, float ury, string contents, string title, string icon, int open | bool',
-\ 'ps_add_pdflink(': 'resource psdoc, float llx, float lly, float urx, float ury, string filename, int page, string dest | bool',
-\ 'ps_add_weblink(': 'resource psdoc, float llx, float lly, float urx, float ury, string url | bool',
-\ 'ps_arc(': 'resource psdoc, float x, float y, float radius, float alpha, float beta | bool',
-\ 'ps_arcn(': 'resource psdoc, float x, float y, float radius, float alpha, float beta | bool',
-\ 'ps_begin_page(': 'resource psdoc, float width, float height | bool',
-\ 'ps_begin_pattern(': 'resource psdoc, float width, float height, float xstep, float ystep, int painttype | bool',
-\ 'ps_begin_template(': 'resource psdoc, float width, float height | bool',
-\ 'ps_circle(': 'resource psdoc, float x, float y, float radius | bool',
-\ 'ps_clip(': 'resource psdoc | bool',
-\ 'ps_close(': 'resource psdoc | bool',
-\ 'ps_close_image(': 'resource psdoc, int imageid | void',
-\ 'ps_closepath(': 'resource psdoc | bool',
-\ 'ps_closepath_stroke(': 'resource psdoc | bool',
-\ 'ps_continue_text(': 'resource psdoc, string text | bool',
-\ 'ps_curveto(': 'resource psdoc, float x1, float y1, float x2, float y2, float x3, float y3 | bool',
-\ 'ps_delete(': 'resource psdoc | bool',
-\ 'ps_end_page(': 'resource psdoc | bool',
-\ 'ps_end_pattern(': 'resource psdoc | bool',
-\ 'ps_end_template(': 'resource psdoc | bool',
-\ 'ps_fill(': 'resource psdoc | bool',
-\ 'ps_fill_stroke(': 'resource psdoc | bool',
-\ 'ps_findfont(': 'resource psdoc, string fontname, string encoding [, bool embed] | int',
-\ 'ps_get_buffer(': 'resource psdoc | string',
-\ 'ps_get_parameter(': 'resource psdoc, string name [, float modifier] | string',
-\ 'ps_get_value(': 'resource psdoc, string name [, float modifier] | float',
-\ 'ps_hyphenate(': 'resource psdoc, string text | array',
-\ 'ps_lineto(': 'resource psdoc, float x, float y | bool',
-\ 'ps_makespotcolor(': 'resource psdoc, string name [, float reserved] | int',
-\ 'ps_moveto(': 'resource psdoc, float x, float y | bool',
-\ 'ps_new(': 'void  | resource',
-\ 'ps_open_file(': 'resource psdoc [, string filename] | bool',
-\ 'ps_open_image_file(': 'resource psdoc, string type, string filename [, string stringparam [, int intparam]] | int',
-\ 'ps_open_image(': 'resource psdoc, string type, string source, string data, int lenght, int width, int height, int components, int bpc, string params | int',
-\ 'pspell_add_to_personal(': 'int dictionary_link, string word | bool',
-\ 'pspell_add_to_session(': 'int dictionary_link, string word | bool',
-\ 'pspell_check(': 'int dictionary_link, string word | bool',
-\ 'pspell_clear_session(': 'int dictionary_link | bool',
-\ 'pspell_config_create(': 'string language [, string spelling [, string jargon [, string encoding]]] | int',
-\ 'pspell_config_data_dir(': 'int conf, string directory | bool',
-\ 'pspell_config_dict_dir(': 'int conf, string directory | bool',
-\ 'pspell_config_ignore(': 'int dictionary_link, int n | bool',
-\ 'pspell_config_mode(': 'int dictionary_link, int mode | bool',
-\ 'pspell_config_personal(': 'int dictionary_link, string file | bool',
-\ 'pspell_config_repl(': 'int dictionary_link, string file | bool',
-\ 'pspell_config_runtogether(': 'int dictionary_link, bool flag | bool',
-\ 'pspell_config_save_repl(': 'int dictionary_link, bool flag | bool',
-\ 'pspell_new_config(': 'int config | int',
-\ 'pspell_new(': 'string language [, string spelling [, string jargon [, string encoding [, int mode]]]] | int',
-\ 'pspell_new_personal(': 'string personal, string language [, string spelling [, string jargon [, string encoding [, int mode]]]] | int',
-\ 'pspell_save_wordlist(': 'int dictionary_link | bool',
-\ 'pspell_store_replacement(': 'int dictionary_link, string misspelled, string correct | bool',
-\ 'pspell_suggest(': 'int dictionary_link, string word | array',
-\ 'ps_place_image(': 'resource psdoc, int imageid, float x, float y, float scale | bool',
-\ 'ps_rect(': 'resource psdoc, float x, float y, float width, float height | bool',
-\ 'ps_restore(': 'resource psdoc | bool',
-\ 'ps_rotate(': 'resource psdoc, float rot | bool',
-\ 'ps_save(': 'resource psdoc | bool',
-\ 'ps_scale(': 'resource psdoc, float x, float y | bool',
-\ 'ps_set_border_color(': 'resource psdoc, float red, float green, float blue | bool',
-\ 'ps_set_border_dash(': 'resource psdoc, float black, float white | bool',
-\ 'ps_set_border_style(': 'resource psdoc, string style, float width | bool',
-\ 'ps_setcolor(': 'resource psdoc, string type, string colorspace, float c1, float c2, float c3, float c4 | bool',
-\ 'ps_setdash(': 'resource psdoc, float on, float off | bool',
-\ 'ps_setflat(': 'resource psdoc, float value | bool',
-\ 'ps_setfont(': 'resource psdoc, int fontid, float size | bool',
-\ 'ps_setgray(': 'resource psdoc, float gray | bool',
-\ 'ps_set_info(': 'resource p, string key, string val | bool',
-\ 'ps_setlinecap(': 'resource psdoc, int type | bool',
-\ 'ps_setlinejoin(': 'resource psdoc, int type | bool',
-\ 'ps_setlinewidth(': 'resource psdoc, float width | bool',
-\ 'ps_setmiterlimit(': 'resource psdoc, float value | bool',
-\ 'ps_set_parameter(': 'resource psdoc, string name, string value | bool',
-\ 'ps_setpolydash(': 'resource psdoc, float arr | bool',
-\ 'ps_set_text_pos(': 'resource psdoc, float x, float y | bool',
-\ 'ps_set_value(': 'resource psdoc, string name, float value | bool',
-\ 'ps_shading(': 'resource psdoc, string type, float x0, float y0, float x1, float y1, float c1, float c2, float c3, float c4, string optlist | int',
-\ 'ps_shading_pattern(': 'resource psdoc, int shadingid, string optlist | int',
-\ 'ps_shfill(': 'resource psdoc, int shadingid | bool',
-\ 'ps_show_boxed(': 'resource psdoc, string text, float left, float bottom, float width, float height, string hmode [, string feature] | int',
-\ 'ps_show(': 'resource psdoc, string text | bool',
-\ 'ps_show_xy(': 'resource psdoc, string text, float x, float y | bool',
-\ 'ps_string_geometry(': 'resource psdoc, string text [, int fontid [, float size]] | array',
-\ 'ps_stringwidth(': 'resource psdoc, string text [, int fontid [, float size]] | float',
-\ 'ps_stroke(': 'resource psdoc | bool',
-\ 'ps_symbol(': 'resource psdoc, int ord | bool',
-\ 'ps_symbol_name(': 'resource psdoc, int ord [, int fontid] | string',
-\ 'ps_symbol_width(': 'resource psdoc, int ord [, int fontid [, float size]] | float',
-\ 'ps_translate(': 'resource psdoc, float x, float y | bool',
-\ 'putenv(': 'string setting | bool',
-\ 'px_close(': 'resource pxdoc | bool',
-\ 'px_create_fp(': 'resource pxdoc, resource file, array fielddesc | bool',
-\ 'px_date2string(': 'resource pxdoc, int value, string format | string',
-\ 'px_delete(': 'resource pxdoc | bool',
-\ 'px_delete_record(': 'resource pxdoc, int num | bool',
-\ 'px_get_field(': 'resource pxdoc, int fieldno | array',
-\ 'px_get_info(': 'resource pxdoc | array',
-\ 'px_get_parameter(': 'resource pxdoc, string name | string',
-\ 'px_get_record(': 'resource pxdoc, int num [, int mode] | array',
-\ 'px_get_schema(': 'resource pxdoc [, int mode] | array',
-\ 'px_get_value(': 'resource pxdoc, string name | float',
-\ 'px_insert_record(': 'resource pxdoc, array data | int',
-\ 'px_new(': 'void  | resource',
-\ 'px_numfields(': 'resource pxdoc | int',
-\ 'px_numrecords(': 'resource pxdoc | int',
-\ 'px_open_fp(': 'resource pxdoc, resource file | bool',
-\ 'px_put_record(': 'resource pxdoc, array record [, int recpos] | bool',
-\ 'px_retrieve_record(': 'resource pxdoc, int num [, int mode] | array',
-\ 'px_set_blob_file(': 'resource pxdoc, string filename | bool',
-\ 'px_set_parameter(': 'resource pxdoc, string name, string value | bool',
-\ 'px_set_tablename(': 'resource pxdoc, string name | void',
-\ 'px_set_targetencoding(': 'resource pxdoc, string encoding | bool',
-\ 'px_set_value(': 'resource pxdoc, string name, float value | bool',
-\ 'px_timestamp2string(': 'resource pxdoc, float value, string format | string',
-\ 'px_update_record(': 'resource pxdoc, array data, int num | bool',
-\ 'qdom_error(': 'void  | string',
-\ 'qdom_tree(': 'string doc | QDomDocument',
-\ 'quoted_printable_decode(': 'string str | string',
-\ 'quotemeta(': 'string str | string',
-\ 'rad2deg(': 'float number | float',
-\ 'radius_acct_open(': 'void  | resource',
-\ 'radius_add_server(': 'resource radius_handle, string hostname, int port, string secret, int timeout, int max_tries | bool',
-\ 'radius_auth_open(': 'void  | resource',
-\ 'radius_close(': 'resource radius_handle | bool',
-\ 'radius_config(': 'resource radius_handle, string file | bool',
-\ 'radius_create_request(': 'resource radius_handle, int type | bool',
-\ 'radius_cvt_addr(': 'string data | string',
-\ 'radius_cvt_int(': 'string data | int',
-\ 'radius_cvt_string(': 'string data | string',
-\ 'radius_demangle(': 'resource radius_handle, string mangled | string',
-\ 'radius_demangle_mppe_key(': 'resource radius_handle, string mangled | string',
-\ 'radius_get_attr(': 'resource radius_handle | mixed',
-\ 'radius_get_vendor_attr(': 'string data | array',
-\ 'radius_put_addr(': 'resource radius_handle, int type, string addr | bool',
-\ 'radius_put_attr(': 'resource radius_handle, int type, string value | bool',
-\ 'radius_put_int(': 'resource radius_handle, int type, int value | bool',
-\ 'radius_put_string(': 'resource radius_handle, int type, string value | bool',
-\ 'radius_put_vendor_addr(': 'resource radius_handle, int vendor, int type, string addr | bool',
-\ 'radius_put_vendor_attr(': 'resource radius_handle, int vendor, int type, string value | bool',
-\ 'radius_put_vendor_int(': 'resource radius_handle, int vendor, int type, int value | bool',
-\ 'radius_put_vendor_string(': 'resource radius_handle, int vendor, int type, string value | bool',
-\ 'radius_request_authenticator(': 'resource radius_handle | string',
-\ 'radius_send_request(': 'resource radius_handle | int',
-\ 'radius_server_secret(': 'resource radius_handle | string',
-\ 'radius_strerror(': 'resource radius_handle | string',
-\ 'rand(': '[int min, int max] | int',
-\ 'range(': 'mixed low, mixed high [, number step] | array',
-\ 'rar_close(': 'resource rar_file | bool',
-\ 'rar_entry_get(': 'resource rar_file, string entry_name | RarEntry',
-\ 'rar_list(': 'resource rar_file | array',
-\ 'rar_open(': 'string filename [, string password] | resource',
-\ 'rawurldecode(': 'string str | string',
-\ 'rawurlencode(': 'string str | string',
-\ 'readdir(': 'resource dir_handle | string',
-\ 'readfile(': 'string filename [, bool use_include_path [, resource context]] | int',
-\ 'readgzfile(': 'string filename [, int use_include_path] | int',
-\ 'readline_add_history(': 'string line | bool',
-\ 'readline_callback_handler_install(': 'string prompt, callback callback | bool',
-\ 'readline_callback_handler_remove(': 'void  | bool',
-\ 'readline_callback_read_char(': 'void  | void',
-\ 'readline_clear_history(': 'void  | bool',
-\ 'readline_completion_function(': 'callback function | bool',
-\ 'readline(': 'string prompt | string',
-\ 'readline_info(': '[string varname [, string newvalue]] | mixed',
-\ 'readline_list_history(': 'void  | array',
-\ 'readline_on_new_line(': 'void  | void',
-\ 'readline_read_history(': '[string filename] | bool',
-\ 'readline_redisplay(': 'void  | void',
-\ 'readline_write_history(': '[string filename] | bool',
-\ 'readlink(': 'string path | string',
-\ 'realpath(': 'string path | string',
-\ 'recode_file(': 'string request, resource input, resource output | bool',
-\ 'recode_string(': 'string request, string string | string',
-\ 'register_shutdown_function(': 'callback function [, mixed parameter [, mixed ...]] | void',
-\ 'register_tick_function(': 'callback function [, mixed arg [, mixed ...]] | bool',
-\ 'rename_function(': 'string original_name, string new_name | bool',
-\ 'rename(': 'string oldname, string newname [, resource context] | bool',
-\ 'reset(': 'array &#38;array | mixed',
-\ 'restore_error_handler(': 'void  | bool',
-\ 'restore_exception_handler(': 'void  | bool',
-\ 'restore_include_path(': 'void  | void',
-\ 'rewinddir(': 'resource dir_handle | void',
-\ 'rewind(': 'resource handle | bool',
-\ 'rmdir(': 'string dirname [, resource context] | bool',
-\ 'round(': 'float val [, int precision] | float',
-\ 'rpm_close(': 'resource rpmr | boolean',
-\ 'rpm_get_tag(': 'resource rpmr, int tagnum | mixed',
-\ 'rpm_is_valid(': 'string filename | boolean',
-\ 'rpm_open(': 'string filename | resource',
-\ 'rpm_version(': 'void  | string',
-\ 'rsort(': 'array &#38;array [, int sort_flags] | bool',
-\ 'rtrim(': 'string str [, string charlist] | string',
-\ 'runkit_class_adopt(': 'string classname, string parentname | bool',
-\ 'runkit_class_emancipate(': 'string classname | bool',
-\ 'runkit_constant_add(': 'string constname, mixed value | bool',
-\ 'runkit_constant_redefine(': 'string constname, mixed newvalue | bool',
-\ 'runkit_constant_remove(': 'string constname | bool',
-\ 'runkit_function_add(': 'string funcname, string arglist, string code | bool',
-\ 'runkit_function_copy(': 'string funcname, string targetname | bool',
-\ 'runkit_function_redefine(': 'string funcname, string arglist, string code | bool',
-\ 'runkit_function_remove(': 'string funcname | bool',
-\ 'runkit_function_rename(': 'string funcname, string newname | bool',
-\ 'runkit_import(': 'string filename [, int flags] | bool',
-\ 'runkit_lint_file(': 'string filename | bool',
-\ 'runkit_lint(': 'string code | bool',
-\ 'runkit_method_add(': 'string classname, string methodname, string args, string code [, int flags] | bool',
-\ 'runkit_method_copy(': 'string dClass, string dMethod, string sClass [, string sMethod] | bool',
-\ 'runkit_method_redefine(': 'string classname, string methodname, string args, string code [, int flags] | bool',
-\ 'runkit_method_remove(': 'string classname, string methodname | bool',
-\ 'runkit_method_rename(': 'string classname, string methodname, string newname | bool',
-\ 'runkit_return_value_used(': 'void  | bool',
-\ 'runkit_sandbox_output_handler(': 'object sandbox [, mixed callback] | mixed',
-\ 'runkit_superglobals(': 'void  | array',
-\ 'satellite_caught_exception(': 'void  | bool',
-\ 'satellite_exception_id(': 'void  | string',
-\ 'satellite_exception_value(': 'void  | OrbitStruct',
-\ 'satellite_get_repository_id(': 'object obj | int',
-\ 'satellite_load_idl(': 'string file | bool',
-\ 'satellite_object_to_string(': 'object obj | string',
-\ 'scandir(': 'string directory [, int sorting_order [, resource context]] | array',
-\ 'sem_acquire(': 'resource sem_identifier | bool',
-\ 'sem_get(': 'int key [, int max_acquire [, int perm [, int auto_release]]] | resource',
-\ 'sem_release(': 'resource sem_identifier | bool',
-\ 'sem_remove(': 'resource sem_identifier | bool',
-\ 'serialize(': 'mixed value | string',
-\ 'sesam_affected_rows(': 'string result_id | int',
-\ 'sesam_commit(': 'void  | bool',
-\ 'sesam_connect(': 'string catalog, string schema, string user | bool',
-\ 'sesam_diagnostic(': 'void  | array',
-\ 'sesam_disconnect(': 'void  | bool',
-\ 'sesam_errormsg(': 'void  | string',
-\ 'sesam_execimm(': 'string query | string',
-\ 'sesam_fetch_array(': 'string result_id [, int whence [, int offset]] | array',
-\ 'sesam_fetch_result(': 'string result_id [, int max_rows] | mixed',
-\ 'sesam_fetch_row(': 'string result_id [, int whence [, int offset]] | array',
-\ 'sesam_field_array(': 'string result_id | array',
-\ 'sesam_field_name(': 'string result_id, int index | int',
-\ 'sesam_free_result(': 'string result_id | int',
-\ 'sesam_num_fields(': 'string result_id | int',
-\ 'sesam_query(': 'string query [, bool scrollable] | string',
-\ 'sesam_rollback(': 'void  | bool',
-\ 'sesam_seek_row(': 'string result_id, int whence [, int offset] | bool',
-\ 'sesam_settransaction(': 'int isolation_level, int read_only | bool',
-\ 'session_cache_expire(': '[int new_cache_expire] | int',
-\ 'session_cache_limiter(': '[string cache_limiter] | string',
-\ 'session_decode(': 'string data | bool',
-\ 'session_destroy(': 'void  | bool',
-\ 'session_encode(': 'void  | string',
-\ 'session_get_cookie_params(': 'void  | array',
-\ 'session_id(': '[string id] | string',
-\ 'session_is_registered(': 'string name | bool',
-\ 'session_module_name(': '[string module] | string',
-\ 'session_name(': '[string name] | string',
-\ 'session_pgsql_add_error(': 'int error_level [, string error_message] | bool',
-\ 'session_pgsql_get_error(': '[bool with_error_message] | array',
-\ 'session_pgsql_get_field(': 'void  | string',
-\ 'session_pgsql_reset(': 'void  | bool',
-\ 'session_pgsql_set_field(': 'string value | bool',
-\ 'session_pgsql_status(': 'void  | array',
-\ 'session_regenerate_id(': '[bool delete_old_session] | bool',
-\ 'session_register(': 'mixed name [, mixed ...] | bool',
-\ 'session_save_path(': '[string path] | string',
-\ 'session_set_cookie_params(': 'int lifetime [, string path [, string domain [, bool secure]]] | void',
-\ 'session_set_save_handler(': 'callback open, callback close, callback read, callback write, callback destroy, callback gc | bool',
-\ 'session_start(': 'void  | bool',
-\ 'session_unregister(': 'string name | bool',
-\ 'session_unset(': 'void  | void',
-\ 'session_write_close(': 'void  | void',
-\ 'setcookie(': 'string name [, string value [, int expire [, string path [, string domain [, bool secure]]]]] | bool',
-\ 'set_error_handler(': 'callback error_handler [, int error_types] | mixed',
-\ 'set_exception_handler(': 'callback exception_handler | string',
-\ 'set_include_path(': 'string new_include_path | string',
-\ 'setlocale(': 'int category, string locale [, string ...] | string',
-\ 'set_magic_quotes_runtime(': 'int new_setting | bool',
-\ 'setrawcookie(': 'string name [, string value [, int expire [, string path [, string domain [, bool secure]]]]] | bool',
-\ 'set_time_limit(': 'int seconds | void',
-\ 'settype(': 'mixed &#38;var, string type | bool',
-\ 'sha1_file(': 'string filename [, bool raw_output] | string',
-\ 'sha1(': 'string str [, bool raw_output] | string',
-\ 'shell_exec(': 'string cmd | string',
-\ 'shm_attach(': 'int key [, int memsize [, int perm]] | int',
-\ 'shm_detach(': 'int shm_identifier | bool',
-\ 'shm_get_var(': 'int shm_identifier, int variable_key | mixed',
-\ 'shmop_close(': 'int shmid | void',
-\ 'shmop_delete(': 'int shmid | bool',
-\ 'shmop_open(': 'int key, string flags, int mode, int size | int',
-\ 'shmop_read(': 'int shmid, int start, int count | string',
-\ 'shmop_size(': 'int shmid | int',
-\ 'shmop_write(': 'int shmid, string data, int offset | int',
-\ 'shm_put_var(': 'int shm_identifier, int variable_key, mixed variable | bool',
-\ 'shm_remove(': 'int shm_identifier | bool',
-\ 'shm_remove_var(': 'int shm_identifier, int variable_key | bool',
-\ 'shuffle(': 'array &#38;array | bool',
-\ 'similar_text(': 'string first, string second [, float &#38;percent] | int',
-\ 'SimpleXMLElement-&#62;asXML(': '[string filename] | mixed',
-\ 'simplexml_element-&#62;attributes(': '[string data] | SimpleXMLElement',
-\ 'simplexml_element-&#62;children(': '[string nsprefix] | SimpleXMLElement',
-\ 'SimpleXMLElement-&#62;xpath(': 'string path | array',
-\ 'simplexml_import_dom(': 'DOMNode node [, string class_name] | SimpleXMLElement',
-\ 'simplexml_load_file(': 'string filename [, string class_name [, int options]] | object',
-\ 'simplexml_load_string(': 'string data [, string class_name [, int options]] | object',
-\ 'sinh(': 'float arg | float',
-\ 'sin(': 'float arg | float',
-\ 'sleep(': 'int seconds | int',
-\ 'snmpget(': 'string hostname, string community, string object_id [, int timeout [, int retries]] | string',
-\ 'snmpgetnext(': 'string host, string community, string object_id [, int timeout [, int retries]] | string',
-\ 'snmp_get_quick_print(': 'void  | bool',
-\ 'snmp_get_valueretrieval(': 'void  | int',
-\ 'snmp_read_mib(': 'string filename | bool',
-\ 'snmprealwalk(': 'string host, string community, string object_id [, int timeout [, int retries]] | array',
-\ 'snmp_set_enum_print(': 'int enum_print | void',
-\ 'snmpset(': 'string hostname, string community, string object_id, string type, mixed value [, int timeout [, int retries]] | bool',
-\ 'snmp_set_oid_numeric_print(': 'int oid_numeric_print | void',
-\ 'snmp_set_quick_print(': 'bool quick_print | void',
-\ 'snmp_set_valueretrieval(': 'int method | void',
-\ 'snmpwalk(': 'string hostname, string community, string object_id [, int timeout [, int retries]] | array',
-\ 'snmpwalkoid(': 'string hostname, string community, string object_id [, int timeout [, int retries]] | array',
-\ 'socket_accept(': 'resource socket | resource',
-\ 'socket_bind(': 'resource socket, string address [, int port] | bool',
-\ 'socket_clear_error(': '[resource socket] | void',
-\ 'socket_close(': 'resource socket | void',
-\ 'socket_connect(': 'resource socket, string address [, int port] | bool',
-\ 'socket_create(': 'int domain, int type, int protocol | resource',
-\ 'socket_create_listen(': 'int port [, int backlog] | resource',
-\ 'socket_create_pair(': 'int domain, int type, int protocol, array &#38;fd | bool',
-\ 'socket_get_option(': 'resource socket, int level, int optname | mixed',
-\ 'socket_getpeername(': 'resource socket, string &#38;addr [, int &#38;port] | bool',
-\ 'socket_getsockname(': 'resource socket, string &#38;addr [, int &#38;port] | bool',
-\ 'socket_last_error(': '[resource socket] | int',
-\ 'socket_listen(': 'resource socket [, int backlog] | bool',
-\ 'socket_read(': 'resource socket, int length [, int type] | string',
-\ 'socket_recvfrom(': 'resource socket, string &#38;buf, int len, int flags, string &#38;name [, int &#38;port] | int',
-\ 'socket_recv(': 'resource socket, string &#38;buf, int len, int flags | int',
-\ 'socket_select(': 'array &#38;read, array &#38;write, array &#38;except, int tv_sec [, int tv_usec] | int',
-\ 'socket_send(': 'resource socket, string buf, int len, int flags | int',
-\ 'socket_sendto(': 'resource socket, string buf, int len, int flags, string addr [, int port] | int',
-\ 'socket_set_block(': 'resource socket | bool',
-\ 'socket_set_nonblock(': 'resource socket | bool',
-\ 'socket_set_option(': 'resource socket, int level, int optname, mixed optval | bool',
-\ 'socket_shutdown(': 'resource socket [, int how] | bool',
-\ 'socket_strerror(': 'int errno | string',
-\ 'socket_write(': 'resource socket, string buffer [, int length] | int',
-\ 'sort(': 'array &#38;array [, int sort_flags] | bool',
-\ 'soundex(': 'string str | string',
-\ 'spl_classes(': 'void  | array',
-\ 'split(': 'string pattern, string string [, int limit] | array',
-\ 'spliti(': 'string pattern, string string [, int limit] | array',
-\ 'sprintf(': 'string format [, mixed args [, mixed ...]] | string',
-\ 'sqlite_array_query(': 'resource dbhandle, string query [, int result_type [, bool decode_binary]] | array',
-\ 'sqlite_busy_timeout(': 'resource dbhandle, int milliseconds | void',
-\ 'sqlite_changes(': 'resource dbhandle | int',
-\ 'sqlite_close(': 'resource dbhandle | void',
-\ 'sqlite_column(': 'resource result, mixed index_or_name [, bool decode_binary] | mixed',
-\ 'sqlite_create_aggregate(': 'resource dbhandle, string function_name, callback step_func, callback finalize_func [, int num_args] | void',
-\ 'sqlite_create_function(': 'resource dbhandle, string function_name, callback callback [, int num_args] | void',
-\ 'sqlite_current(': 'resource result [, int result_type [, bool decode_binary]] | array',
-\ 'sqlite_error_string(': 'int error_code | string',
-\ 'sqlite_escape_string(': 'string item | string',
-\ 'sqlite_exec(': 'resource dbhandle, string query [, string &#38;error_msg] | bool',
-\ 'sqlite_factory(': 'string filename [, int mode [, string &#38;error_message]] | SQLiteDatabase',
-\ 'sqlite_fetch_all(': 'resource result [, int result_type [, bool decode_binary]] | array',
-\ 'sqlite_fetch_array(': 'resource result [, int result_type [, bool decode_binary]] | array',
-\ 'sqlite_fetch_column_types(': 'string table_name, resource dbhandle [, int result_type] | array',
-\ 'sqlite_fetch_object(': 'resource result [, string class_name [, array ctor_params [, bool decode_binary]]] | object',
-\ 'sqlite_fetch_single(': 'resource result [, bool decode_binary] | string',
-\ 'sqlite_field_name(': 'resource result, int field_index | string',
-\ 'sqlite_has_more(': 'resource result | bool',
-\ 'sqlite_has_prev(': 'resource result | bool',
-\ 'sqlite_key(': 'resource result | int',
-\ 'sqlite_last_error(': 'resource dbhandle | int',
-\ 'sqlite_last_insert_rowid(': 'resource dbhandle | int',
-\ 'sqlite_libencoding(': 'void  | string',
-\ 'sqlite_libversion(': 'void  | string',
-\ 'sqlite_next(': 'resource result | bool',
-\ 'sqlite_num_fields(': 'resource result | int',
-\ 'sqlite_num_rows(': 'resource result | int',
-\ 'sqlite_open(': 'string filename [, int mode [, string &#38;error_message]] | resource',
-\ 'sqlite_popen(': 'string filename [, int mode [, string &#38;error_message]] | resource',
-\ 'sqlite_prev(': 'resource result | bool',
-\ 'sqlite_query(': 'resource dbhandle, string query [, int result_type [, string &#38;error_msg]] | resource',
-\ 'sqlite_rewind(': 'resource result | bool',
-\ 'sqlite_seek(': 'resource result, int rownum | bool',
-\ 'sqlite_single_query(': 'resource db, string query [, bool first_row_only [, bool decode_binary]] | array',
-\ 'sqlite_udf_decode_binary(': 'string data | string',
-\ 'sqlite_udf_encode_binary(': 'string data | string',
-\ 'sqlite_unbuffered_query(': 'resource dbhandle, string query [, int result_type [, string &#38;error_msg]] | resource',
-\ 'sqlite_valid(': 'resource result | bool',
-\ 'sql_regcase(': 'string string | string',
-\ 'sqrt(': 'float arg | float',
-\ 'srand(': '[int seed] | void',
-\ 'sscanf(': 'string str, string format [, mixed &#38;...] | mixed',
-\ 'ssh2_auth_hostbased_file(': 'resource session, string username, string hostname, string pubkeyfile, string privkeyfile [, string passphrase [, string local_username]] | bool',
-\ 'ssh2_auth_none(': 'resource session, string username | mixed',
-\ 'ssh2_auth_password(': 'resource session, string username, string password | bool',
-\ 'ssh2_auth_pubkey_file(': 'resource session, string username, string pubkeyfile, string privkeyfile [, string passphrase] | bool',
-\ 'ssh2_connect(': 'string host [, int port [, array methods [, array callbacks]]] | resource',
-\ 'ssh2_exec(': 'resource session, string command [, string pty [, array env [, int width [, int height [, int width_height_type]]]]] | resource',
-\ 'ssh2_fetch_stream(': 'resource channel, int streamid | resource',
-\ 'ssh2_fingerprint(': 'resource session [, int flags] | string',
-\ 'ssh2_methods_negotiated(': 'resource session | array',
-\ 'ssh2_publickey_add(': 'resource pkey, string algoname, string blob [, bool overwrite [, array attributes]] | bool',
-\ 'ssh2_publickey_init(': 'resource session | resource',
-\ 'ssh2_publickey_list(': 'resource pkey | array',
-\ 'ssh2_publickey_remove(': 'resource pkey, string algoname, string blob | bool',
-\ 'ssh2_scp_recv(': 'resource session, string remote_file, string local_file | bool',
-\ 'ssh2_scp_send(': 'resource session, string local_file, string remote_file [, int create_mode] | bool',
-\ 'ssh2_sftp(': 'resource session | resource',
-\ 'ssh2_sftp_lstat(': 'resource sftp, string path | array',
-\ 'ssh2_sftp_mkdir(': 'resource sftp, string dirname [, int mode [, bool recursive]] | bool',
-\ 'ssh2_sftp_readlink(': 'resource sftp, string link | string',
-\ 'ssh2_sftp_realpath(': 'resource sftp, string filename | string',
-\ 'ssh2_sftp_rename(': 'resource sftp, string from, string to | bool',
-\ 'ssh2_sftp_rmdir(': 'resource sftp, string dirname | bool',
-\ 'ssh2_sftp_stat(': 'resource sftp, string path | array',
-\ 'ssh2_sftp_symlink(': 'resource sftp, string target, string link | bool',
-\ 'ssh2_sftp_unlink(': 'resource sftp, string filename | bool',
-\ 'ssh2_shell(': 'resource session [, string term_type [, array env [, int width [, int height [, int width_height_type]]]]] | resource',
-\ 'ssh2_tunnel(': 'resource session, string host, int port | resource',
-\ 'stat(': 'string filename | array',
-\ 'stats_absolute_deviation(': 'array a | float',
-\ 'stats_cdf_beta(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_binomial(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_cauchy(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_chisquare(': 'float par1, float par2, int which | float',
-\ 'stats_cdf_exponential(': 'float par1, float par2, int which | float',
-\ 'stats_cdf_f(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_gamma(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_laplace(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_logistic(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_negative_binomial(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_noncentral_chisquare(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_noncentral_f(': 'float par1, float par2, float par3, float par4, int which | float',
-\ 'stats_cdf_poisson(': 'float par1, float par2, int which | float',
-\ 'stats_cdf_t(': 'float par1, float par2, int which | float',
-\ 'stats_cdf_uniform(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_cdf_weibull(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_covariance(': 'array a, array b | float',
-\ 'stats_dens_beta(': 'float x, float a, float b | float',
-\ 'stats_dens_cauchy(': 'float x, float ave, float stdev | float',
-\ 'stats_dens_chisquare(': 'float x, float dfr | float',
-\ 'stats_dens_exponential(': 'float x, float scale | float',
-\ 'stats_dens_f(': 'float x, float dfr1, float dfr2 | float',
-\ 'stats_dens_gamma(': 'float x, float shape, float scale | float',
-\ 'stats_dens_laplace(': 'float x, float ave, float stdev | float',
-\ 'stats_dens_logistic(': 'float x, float ave, float stdev | float',
-\ 'stats_dens_negative_binomial(': 'float x, float n, float pi | float',
-\ 'stats_dens_normal(': 'float x, float ave, float stdev | float',
-\ 'stats_dens_pmf_binomial(': 'float x, float n, float pi | float',
-\ 'stats_dens_pmf_hypergeometric(': 'float n1, float n2, float N1, float N2 | float',
-\ 'stats_dens_pmf_poisson(': 'float x, float lb | float',
-\ 'stats_dens_t(': 'float x, float dfr | float',
-\ 'stats_dens_weibull(': 'float x, float a, float b | float',
-\ 'stats_den_uniform(': 'float x, float a, float b | float',
-\ 'stats_harmonic_mean(': 'array a | number',
-\ 'stats_kurtosis(': 'array a | float',
-\ 'stats_rand_gen_beta(': 'float a, float b | float',
-\ 'stats_rand_gen_chisquare(': 'float df | float',
-\ 'stats_rand_gen_exponential(': 'float av | float',
-\ 'stats_rand_gen_f(': 'float dfn, float dfd | float',
-\ 'stats_rand_gen_funiform(': 'float low, float high | float',
-\ 'stats_rand_gen_gamma(': 'float a, float r | float',
-\ 'stats_rand_gen_ibinomial(': 'int n, float pp | int',
-\ 'stats_rand_gen_ibinomial_negative(': 'int n, float p | int',
-\ 'stats_rand_gen_int(': 'void  | int',
-\ 'stats_rand_gen_ipoisson(': 'float mu | int',
-\ 'stats_rand_gen_iuniform(': 'int low, int high | int',
-\ 'stats_rand_gen_noncenral_chisquare(': 'float df, float xnonc | float',
-\ 'stats_rand_gen_noncentral_f(': 'float dfn, float dfd, float xnonc | float',
-\ 'stats_rand_gen_noncentral_t(': 'float df, float xnonc | float',
-\ 'stats_rand_gen_normal(': 'float av, float sd | float',
-\ 'stats_rand_gen_t(': 'float df | float',
-\ 'stats_rand_get_seeds(': 'void  | array',
-\ 'stats_rand_phrase_to_seeds(': 'string phrase | array',
-\ 'stats_rand_ranf(': 'void  | float',
-\ 'stats_rand_setall(': 'int iseed1, int iseed2 | void',
-\ 'stats_skew(': 'array a | float',
-\ 'stats_standard_deviation(': 'array a [, bool sample] | float',
-\ 'stats_stat_binomial_coef(': 'int x, int n | float',
-\ 'stats_stat_correlation(': 'array arr1, array arr2 | float',
-\ 'stats_stat_gennch(': 'int n | float',
-\ 'stats_stat_independent_t(': 'array arr1, array arr2 | float',
-\ 'stats_stat_innerproduct(': 'array arr1, array arr2 | float',
-\ 'stats_stat_noncentral_t(': 'float par1, float par2, float par3, int which | float',
-\ 'stats_stat_paired_t(': 'array arr1, array arr2 | float',
-\ 'stats_stat_percentile(': 'float df, float xnonc | float',
-\ 'stats_stat_powersum(': 'array arr, float power | float',
-\ 'stats_variance(': 'array a [, bool sample] | float',
-\ 'strcasecmp(': 'string str1, string str2 | int',
-\ 'strcmp(': 'string str1, string str2 | int',
-\ 'strcoll(': 'string str1, string str2 | int',
-\ 'strcspn(': 'string str1, string str2 [, int start [, int length]] | int',
-\ 'stream_bucket_append(': 'resource brigade, resource bucket | void',
-\ 'stream_bucket_make_writeable(': 'resource brigade | object',
-\ 'stream_bucket_new(': 'resource stream, string buffer | object',
-\ 'stream_bucket_prepend(': 'resource brigade, resource bucket | void',
-\ 'stream_context_create(': '[array options] | resource',
-\ 'stream_context_get_default(': '[array options] | resource',
-\ 'stream_context_get_options(': 'resource stream_or_context | array',
-\ 'stream_context_set_option(': 'resource stream_or_context, string wrapper, string option, mixed value | bool',
-\ 'stream_context_set_params(': 'resource stream_or_context, array params | bool',
-\ 'stream_copy_to_stream(': 'resource source, resource dest [, int maxlength [, int offset]] | int',
-\ 'stream_filter_append(': 'resource stream, string filtername [, int read_write [, mixed params]] | resource',
-\ 'stream_filter_prepend(': 'resource stream, string filtername [, int read_write [, mixed params]] | resource',
-\ 'stream_filter_register(': 'string filtername, string classname | bool',
-\ 'stream_filter_remove(': 'resource stream_filter | bool',
-\ 'stream_get_contents(': 'resource handle [, int maxlength [, int offset]] | string',
-\ 'stream_get_filters(': 'void  | array',
-\ 'stream_get_line(': 'resource handle, int length [, string ending] | string',
-\ 'stream_get_meta_data(': 'resource stream | array',
-\ 'stream_get_transports(': 'void  | array',
-\ 'stream_get_wrappers(': 'void  | array',
-\ 'stream_select(': 'array &#38;read, array &#38;write, array &#38;except, int tv_sec [, int tv_usec] | int',
-\ 'stream_set_blocking(': 'resource stream, int mode | bool',
-\ 'stream_set_timeout(': 'resource stream, int seconds [, int microseconds] | bool',
-\ 'stream_set_write_buffer(': 'resource stream, int buffer | int',
-\ 'stream_socket_accept(': 'resource server_socket [, float timeout [, string &#38;peername]] | resource',
-\ 'stream_socket_client(': 'string remote_socket [, int &#38;errno [, string &#38;errstr [, float timeout [, int flags [, resource context]]]]] | resource',
-\ 'stream_socket_enable_crypto(': 'resource stream, bool enable [, int crypto_type [, resource session_stream]] | mixed',
-\ 'stream_socket_get_name(': 'resource handle, bool want_peer | string',
-\ 'stream_socket_pair(': 'int domain, int type, int protocol | array',
-\ 'stream_socket_recvfrom(': 'resource socket, int length [, int flags [, string &#38;address]] | string',
-\ 'stream_socket_sendto(': 'resource socket, string data [, int flags [, string address]] | int',
-\ 'stream_socket_server(': 'string local_socket [, int &#38;errno [, string &#38;errstr [, int flags [, resource context]]]] | resource',
-\ 'stream_wrapper_register(': 'string protocol, string classname | bool',
-\ 'stream_wrapper_restore(': 'string protocol | bool',
-\ 'stream_wrapper_unregister(': 'string protocol | bool',
-\ 'strftime(': 'string format [, int timestamp] | string',
-\ 'stripcslashes(': 'string str | string',
-\ 'stripos(': 'string haystack, string needle [, int offset] | int',
-\ 'stripslashes(': 'string str | string',
-\ 'strip_tags(': 'string str [, string allowable_tags] | string',
-\ 'str_ireplace(': 'mixed search, mixed replace, mixed subject [, int &#38;count] | mixed',
-\ 'stristr(': 'string haystack, string needle | string',
-\ 'strlen(': 'string string | int',
-\ 'strnatcasecmp(': 'string str1, string str2 | int',
-\ 'strnatcmp(': 'string str1, string str2 | int',
-\ 'strncasecmp(': 'string str1, string str2, int len | int',
-\ 'strncmp(': 'string str1, string str2, int len | int',
-\ 'str_pad(': 'string input, int pad_length [, string pad_string [, int pad_type]] | string',
-\ 'strpbrk(': 'string haystack, string char_list | string',
-\ 'strpos(': 'string haystack, mixed needle [, int offset] | int',
-\ 'strptime(': 'string date, string format | array',
-\ 'strrchr(': 'string haystack, string needle | string',
-\ 'str_repeat(': 'string input, int multiplier | string',
-\ 'str_replace(': 'mixed search, mixed replace, mixed subject [, int &#38;count] | mixed',
-\ 'strrev(': 'string string | string',
-\ 'strripos(': 'string haystack, string needle [, int offset] | int',
-\ 'str_rot13(': 'string str | string',
-\ 'strrpos(': 'string haystack, string needle [, int offset] | int',
-\ 'str_shuffle(': 'string str | string',
-\ 'str_split(': 'string string [, int split_length] | array',
-\ 'strspn(': 'string str1, string str2 [, int start [, int length]] | int',
-\ 'strstr(': 'string haystack, string needle | string',
-\ 'strtok(': 'string str, string token | string',
-\ 'strtolower(': 'string str | string',
-\ 'strtotime(': 'string time [, int now] | int',
-\ 'strtoupper(': 'string string | string',
-\ 'strtr(': 'string str, string from, string to | string',
-\ 'strval(': 'mixed var | string',
-\ 'str_word_count(': 'string string [, int format [, string charlist]] | mixed',
-\ 'substr_compare(': 'string main_str, string str, int offset [, int length [, bool case_insensitivity]] | int',
-\ 'substr_count(': 'string haystack, string needle [, int offset [, int length]] | int',
-\ 'substr(': 'string string, int start [, int length] | string',
-\ 'substr_replace(': 'mixed string, string replacement, int start [, int length] | mixed',
-\ 'swf_actiongeturl(': 'string url, string target | void',
-\ 'swf_actiongotoframe(': 'int framenumber | void',
-\ 'swf_actiongotolabel(': 'string label | void',
-\ 'swfaction(': 'string script | SWFAction',
-\ 'swf_actionnextframe(': 'void  | void',
-\ 'swf_actionplay(': 'void  | void',
-\ 'swf_actionprevframe(': 'void  | void',
-\ 'swf_actionsettarget(': 'string target | void',
-\ 'swf_actionstop(': 'void  | void',
-\ 'swf_actiontogglequality(': 'void  | void',
-\ 'swf_actionwaitforframe(': 'int framenumber, int skipcount | void',
-\ 'swf_addbuttonrecord(': 'int states, int shapeid, int depth | void',
-\ 'swf_addcolor(': 'float r, float g, float b, float a | void',
-\ 'swfbitmap-&#62;getheight(': 'void  | float',
-\ 'swfbitmap-&#62;getwidth(': 'void  | float',
-\ 'swfbitmap(': 'mixed file [, mixed alphafile] | SWFBitmap',
-\ 'swfbutton-&#62;addaction(': 'resource action, int flags | void',
-\ 'swfbutton-&#62;addshape(': 'resource shape, int flags | void',
-\ 'swfbutton(': 'void  | SWFButton',
-\ 'swfbutton-&#62;setaction(': 'resource action | void',
-\ 'swfbutton-&#62;setdown(': 'resource shape | void',
-\ 'swfbutton-&#62;sethit(': 'resource shape | void',
-\ 'swfbutton-&#62;setover(': 'resource shape | void',
-\ 'swfbutton-&#62;setup(': 'resource shape | void',
-\ 'swf_closefile(': '[int return_file] | void',
-\ 'swf_definebitmap(': 'int objid, string image_name | void',
-\ 'swf_definefont(': 'int fontid, string fontname | void',
-\ 'swf_defineline(': 'int objid, float x1, float y1, float x2, float y2, float width | void',
-\ 'swf_definepoly(': 'int objid, array coords, int npoints, float width | void',
-\ 'swf_definerect(': 'int objid, float x1, float y1, float x2, float y2, float width | void',
-\ 'swf_definetext(': 'int objid, string str, int docenter | void',
-\ 'swfdisplayitem-&#62;addcolor(': 'int red, int green, int blue [, int a] | void',
-\ 'swfdisplayitem-&#62;move(': 'int dx, int dy | void',
-\ 'swfdisplayitem-&#62;moveto(': 'int x, int y | void',
-\ 'swfdisplayitem-&#62;multcolor(': 'int red, int green, int blue [, int a] | void',
-\ 'swfdisplayitem-&#62;remove(': 'void  | void',
-\ 'swfdisplayitem-&#62;rotate(': 'float ddegrees | void',
-\ 'swfdisplayitem-&#62;rotateto(': 'float degrees | void',
-\ 'swfdisplayitem-&#62;scale(': 'int dx, int dy | void',
-\ 'swfdisplayitem-&#62;scaleto(': 'int x [, int y] | void',
-\ 'swfdisplayitem-&#62;setdepth(': 'float depth | void',
-\ 'swfdisplayitem-&#62;setname(': 'string name | void',
-\ 'swfdisplayitem-&#62;setratio(': 'float ratio | void',
-\ 'swfdisplayitem-&#62;skewx(': 'float ddegrees | void',
-\ 'swfdisplayitem-&#62;skewxto(': 'float degrees | void',
-\ 'swfdisplayitem-&#62;skewy(': 'float ddegrees | void',
-\ 'swfdisplayitem-&#62;skewyto(': 'float degrees | void',
-\ 'swf_endbutton(': 'void  | void',
-\ 'swf_enddoaction(': 'void  | void',
-\ 'swf_endshape(': 'void  | void',
-\ 'swf_endsymbol(': 'void  | void',
-\ 'swffill(': 'void  | SWFFill',
-\ 'swffill-&#62;moveto(': 'int x, int y | void',
-\ 'swffill-&#62;rotateto(': 'float degrees | void',
-\ 'swffill-&#62;scaleto(': 'int x [, int y] | void',
-\ 'swffill-&#62;skewxto(': 'float x | void',
-\ 'swffill-&#62;skewyto(': 'float y | void',
-\ 'swffont-&#62;getwidth(': 'string string | float',
-\ 'swffont(': 'string filename | SWFFont',
-\ 'swf_fontsize(': 'float size | void',
-\ 'swf_fontslant(': 'float slant | void',
-\ 'swf_fonttracking(': 'float tracking | void',
-\ 'swf_getbitmapinfo(': 'int bitmapid | array',
-\ 'swf_getfontinfo(': 'void  | array',
-\ 'swf_getframe(': 'void  | int',
-\ 'swfgradient-&#62;addentry(': 'float ratio, int red, int green, int blue [, int a] | void',
-\ 'swfgradient(': 'void  | SWFGradient',
-\ 'swf_labelframe(': 'string name | void',
-\ 'swf_lookat(': 'float view_x, float view_y, float view_z, float reference_x, float reference_y, float reference_z, float twist | void',
-\ 'swf_modifyobject(': 'int depth, int how | void',
-\ 'swfmorph-&#62;getshape1(': 'void  | mixed',
-\ 'swfmorph-&#62;getshape2(': 'void  | mixed',
-\ 'swfmorph(': 'void  | SWFMorph',
-\ 'swfmovie-&#62;add(': 'resource instance | void',
-\ 'swfmovie(': 'void  | SWFMovie',
-\ 'swfmovie-&#62;nextframe(': 'void  | void',
-\ 'swfmovie-&#62;output(': '[int compression] | int',
-\ 'swfmovie-&#62;remove(': 'resource instance | void',
-\ 'swfmovie-&#62;save(': 'string filename [, int compression] | int',
-\ 'swfmovie-&#62;setbackground(': 'int red, int green, int blue | void',
-\ 'swfmovie-&#62;setdimension(': 'int width, int height | void',
-\ 'swfmovie-&#62;setframes(': 'string numberofframes | void',
-\ 'swfmovie-&#62;setrate(': 'int rate | void',
-\ 'swfmovie-&#62;streammp3(': 'mixed mp3File | void',
-\ 'swf_mulcolor(': 'float r, float g, float b, float a | void',
-\ 'swf_nextid(': 'void  | int',
-\ 'swf_oncondition(': 'int transition | void',
-\ 'swf_openfile(': 'string filename, float width, float height, float framerate, float r, float g, float b | void',
-\ 'swf_ortho2(': 'float xmin, float xmax, float ymin, float ymax | void',
-\ 'swf_ortho(': 'float xmin, float xmax, float ymin, float ymax, float zmin, float zmax | void',
-\ 'swf_perspective(': 'float fovy, float aspect, float near, float far | void',
-\ 'swf_placeobject(': 'int objid, int depth | void',
-\ 'swf_polarview(': 'float dist, float azimuth, float incidence, float twist | void',
-\ 'swf_popmatrix(': 'void  | void',
-\ 'swf_posround(': 'int round | void',
-\ 'SWFPrebuiltClip(': '[string file] | SWFPrebuiltClip',
-\ 'swf_pushmatrix(': 'void  | void',
-\ 'swf_removeobject(': 'int depth | void',
-\ 'swf_rotate(': 'float angle, string axis | void',
-\ 'swf_scale(': 'float x, float y, float z | void',
-\ 'swf_setfont(': 'int fontid | void',
-\ 'swf_setframe(': 'int framenumber | void',
-\ 'SWFShape-&#62;addFill(': 'int red, int green, int blue [, int a] | SWFFill',
-\ 'swf_shapearc(': 'float x, float y, float r, float ang1, float ang2 | void',
-\ 'swf_shapecurveto3(': 'float x1, float y1, float x2, float y2, float x3, float y3 | void',
-\ 'swf_shapecurveto(': 'float x1, float y1, float x2, float y2 | void',
-\ 'swfshape-&#62;drawcurve(': 'int controldx, int controldy, int anchordx, int anchordy [, int targetdx, int targetdy] | int',
-\ 'swfshape-&#62;drawcurveto(': 'int controlx, int controly, int anchorx, int anchory [, int targetx, int targety] | int',
-\ 'swfshape-&#62;drawline(': 'int dx, int dy | void',
-\ 'swfshape-&#62;drawlineto(': 'int x, int y | void',
-\ 'swf_shapefillbitmapclip(': 'int bitmapid | void',
-\ 'swf_shapefillbitmaptile(': 'int bitmapid | void',
-\ 'swf_shapefilloff(': 'void  | void',
-\ 'swf_shapefillsolid(': 'float r, float g, float b, float a | void',
-\ 'swfshape(': 'void  | SWFShape',
-\ 'swf_shapelinesolid(': 'float r, float g, float b, float a, float width | void',
-\ 'swf_shapelineto(': 'float x, float y | void',
-\ 'swfshape-&#62;movepen(': 'int dx, int dy | void',
-\ 'swfshape-&#62;movepento(': 'int x, int y | void',
-\ 'swf_shapemoveto(': 'float x, float y | void',
-\ 'swfshape-&#62;setleftfill(': 'swfgradient fill | void',
-\ 'swfshape-&#62;setline(': 'swfshape shape | void',
-\ 'swfshape-&#62;setrightfill(': 'swfgradient fill | void',
-\ 'swf_showframe(': 'void  | void',
-\ 'SWFSound(': 'string filename, int flags | SWFSound',
-\ 'swfsprite-&#62;add(': 'resource object | void',
-\ 'swfsprite(': 'void  | SWFSprite',
-\ 'swfsprite-&#62;nextframe(': 'void  | void',
-\ 'swfsprite-&#62;remove(': 'resource object | void',
-\ 'swfsprite-&#62;setframes(': 'int numberofframes | void',
-\ 'swf_startbutton(': 'int objid, int type | void',
-\ 'swf_startdoaction(': 'void  | void',
-\ 'swf_startshape(': 'int objid | void',
-\ 'swf_startsymbol(': 'int objid | void',
-\ 'swftext-&#62;addstring(': 'string string | void',
-\ 'swftextfield-&#62;addstring(': 'string string | void',
-\ 'swftextfield-&#62;align(': 'int alignement | void',
-\ 'swftextfield(': '[int flags] | SWFTextField',
-\ 'swftextfield-&#62;setbounds(': 'int width, int height | void',
-\ 'swftextfield-&#62;setcolor(': 'int red, int green, int blue [, int a] | void',
-\ 'swftextfield-&#62;setfont(': 'string font | void',
-\ 'swftextfield-&#62;setheight(': 'int height | void',
-\ 'swftextfield-&#62;setindentation(': 'int width | void',
-\ 'swftextfield-&#62;setleftmargin(': 'int width | void',
-\ 'swftextfield-&#62;setlinespacing(': 'int height | void',
-\ 'swftextfield-&#62;setmargins(': 'int left, int right | void',
-\ 'swftextfield-&#62;setname(': 'string name | void',
-\ 'swftextfield-&#62;setrightmargin(': 'int width | void',
-\ 'swftext-&#62;getwidth(': 'string string | float',
-\ 'swftext(': 'void  | SWFText',
-\ 'swftext-&#62;moveto(': 'int x, int y | void',
-\ 'swftext-&#62;setcolor(': 'int red, int green, int blue [, int a] | void',
-\ 'swftext-&#62;setfont(': 'string font | void',
-\ 'swftext-&#62;setheight(': 'int height | void',
-\ 'swftext-&#62;setspacing(': 'float spacing | void',
-\ 'swf_textwidth(': 'string str | float',
-\ 'swf_translate(': 'float x, float y, float z | void',
-\ 'SWFVideoStream(': '[string file] | SWFVideoStream',
-\ 'swf_viewport(': 'float xmin, float xmax, float ymin, float ymax | void',
-\ 'sybase_affected_rows(': '[resource link_identifier] | int',
-\ 'sybase_close(': '[resource link_identifier] | bool',
-\ 'sybase_connect(': '[string servername [, string username [, string password [, string charset [, string appname]]]]] | resource',
-\ 'sybase_data_seek(': 'resource result_identifier, int row_number | bool',
-\ 'sybase_deadlock_retry_count(': 'int retry_count | void',
-\ 'sybase_fetch_array(': 'resource result | array',
-\ 'sybase_fetch_assoc(': 'resource result | array',
-\ 'sybase_fetch_field(': 'resource result [, int field_offset] | object',
-\ 'sybase_fetch_object(': 'resource result [, mixed object] | object',
-\ 'sybase_fetch_row(': 'resource result | array',
-\ 'sybase_field_seek(': 'resource result, int field_offset | bool',
-\ 'sybase_free_result(': 'resource result | bool',
-\ 'sybase_get_last_message(': 'void  | string',
-\ 'sybase_min_client_severity(': 'int severity | void',
-\ 'sybase_min_error_severity(': 'int severity | void',
-\ 'sybase_min_message_severity(': 'int severity | void',
-\ 'sybase_min_server_severity(': 'int severity | void',
-\ 'sybase_num_fields(': 'resource result | int',
-\ 'sybase_num_rows(': 'resource result | int',
-\ 'sybase_pconnect(': '[string servername [, string username [, string password [, string charset [, string appname]]]]] | resource',
-\ 'sybase_query(': 'string query [, resource link_identifier] | mixed',
-\ 'sybase_result(': 'resource result, int row, mixed field | string',
-\ 'sybase_select_db(': 'string database_name [, resource link_identifier] | bool',
-\ 'sybase_set_message_handler(': 'callback handler [, resource connection] | bool',
-\ 'sybase_unbuffered_query(': 'string query, resource link_identifier [, bool store_result] | resource',
-\ 'symlink(': 'string target, string link | bool',
-\ 'sys_getloadavg(': 'void  | array',
-\ 'syslog(': 'int priority, string message | bool',
-\ 'system(': 'string command [, int &#38;return_var] | string',
-\ 'tanh(': 'float arg | float',
-\ 'tan(': 'float arg | float',
-\ 'tcpwrap_check(': 'string daemon, string address [, string user [, bool nodns]] | bool',
-\ 'tempnam(': 'string dir, string prefix | string',
-\ 'textdomain(': 'string text_domain | string',
-\ 'tidy_access_count(': 'tidy object | int',
-\ 'tidy_config_count(': 'tidy object | int',
-\ 'tidy_error_count(': 'tidy object | int',
-\ 'tidy_get_output(': 'tidy object | string',
-\ 'tidy_load_config(': 'string filename, string encoding | void',
-\ 'tidy_node-&#62;get_attr(': 'int attrib_id | tidy_attr',
-\ 'tidy_node-&#62;get_nodes(': 'int node_id | array',
-\ 'tidyNode-&#62;hasChildren(': 'void  | bool',
-\ 'tidyNode-&#62;hasSiblings(': 'void  | bool',
-\ 'tidyNode-&#62;isAsp(': 'void  | bool',
-\ 'tidyNode-&#62;isComment(': 'void  | bool',
-\ 'tidyNode-&#62;isHtml(': 'void  | bool',
-\ 'tidyNode-&#62;isJste(': 'void  | bool',
-\ 'tidyNode-&#62;isPhp(': 'void  | bool',
-\ 'tidyNode-&#62;isText(': 'void  | bool',
-\ 'tidy_node-&#62;next(': 'void  | tidy_node',
-\ 'tidy_node-&#62;prev(': 'void  | tidy_node',
-\ 'tidy_repair_file(': 'string filename [, mixed config [, string encoding [, bool use_include_path]]] | string',
-\ 'tidy_repair_string(': 'string data [, mixed config [, string encoding]] | string',
-\ 'tidy_reset_config(': 'void  | bool',
-\ 'tidy_save_config(': 'string filename | bool',
-\ 'tidy_set_encoding(': 'string encoding | bool',
-\ 'tidy_setopt(': 'string option, mixed value | bool',
-\ 'tidy_warning_count(': 'tidy object | int',
-\ 'time(': 'void  | int',
-\ 'time_nanosleep(': 'int seconds, int nanoseconds | mixed',
-\ 'time_sleep_until(': 'float timestamp | bool',
-\ 'tmpfile(': 'void  | resource',
-\ 'token_get_all(': 'string source | array',
-\ 'token_name(': 'int token | string',
-\ 'touch(': 'string filename [, int time [, int atime]] | bool',
-\ 'trigger_error(': 'string error_msg [, int error_type] | bool',
-\ 'trim(': 'string str [, string charlist] | string',
-\ 'uasort(': 'array &#38;array, callback cmp_function | bool',
-\ 'ucfirst(': 'string str | string',
-\ 'ucwords(': 'string str | string',
-\ 'udm_add_search_limit(': 'resource agent, int var, string val | bool',
-\ 'udm_alloc_agent_array(': 'array databases | resource',
-\ 'udm_alloc_agent(': 'string dbaddr [, string dbmode] | resource',
-\ 'udm_api_version(': 'void  | int',
-\ 'udm_cat_list(': 'resource agent, string category | array',
-\ 'udm_cat_path(': 'resource agent, string category | array',
-\ 'udm_check_charset(': 'resource agent, string charset | bool',
-\ 'udm_check_stored(': 'resource agent, int link, string doc_id | int',
-\ 'udm_clear_search_limits(': 'resource agent | bool',
-\ 'udm_close_stored(': 'resource agent, int link | int',
-\ 'udm_crc32(': 'resource agent, string str | int',
-\ 'udm_errno(': 'resource agent | int',
-\ 'udm_error(': 'resource agent | string',
-\ 'udm_find(': 'resource agent, string query | resource',
-\ 'udm_free_agent(': 'resource agent | int',
-\ 'udm_free_ispell_data(': 'int agent | bool',
-\ 'udm_free_res(': 'resource res | bool',
-\ 'udm_get_doc_count(': 'resource agent | int',
-\ 'udm_get_res_field(': 'resource res, int row, int field | string',
-\ 'udm_get_res_param(': 'resource res, int param | string',
-\ 'udm_hash32(': 'resource agent, string str | int',
-\ 'udm_load_ispell_data(': 'resource agent, int var, string val1, string val2, int flag | bool',
-\ 'udm_open_stored(': 'resource agent, string storedaddr | int',
-\ 'udm_set_agent_param(': 'resource agent, int var, string val | bool',
-\ 'uksort(': 'array &#38;array, callback cmp_function | bool',
-\ 'umask(': '[int mask] | int',
-\ 'unicode_encode(': 'unicode input, string encoding | string',
-\ 'unicode_semantics(': 'void  | bool',
-\ 'uniqid(': '[string prefix [, bool more_entropy]] | string',
-\ 'unixtojd(': '[int timestamp] | int',
-\ 'unlink(': 'string filename [, resource context] | bool',
-\ 'unpack(': 'string format, string data | array',
-\ 'unregister_tick_function(': 'string function_name | void',
-\ 'unserialize(': 'string str | mixed',
-\ 'unset(': 'mixed var [, mixed var [, mixed ...]] | void',
-\ 'urldecode(': 'string str | string',
-\ 'urlencode(': 'string str | string',
-\ 'use_soap_error_handler(': '[bool handler] | bool',
-\ 'usleep(': 'int micro_seconds | void',
-\ 'usort(': 'array &#38;array, callback cmp_function | bool',
-\ 'utf8_decode(': 'string data | string',
-\ 'utf8_encode(': 'string data | string',
-\ 'var_dump(': 'mixed expression [, mixed expression [, ...]] | void',
-\ 'var_export(': 'mixed expression [, bool return] | mixed',
-\ 'variant_abs(': 'mixed val | mixed',
-\ 'variant_add(': 'mixed left, mixed right | mixed',
-\ 'variant_and(': 'mixed left, mixed right | mixed',
-\ 'variant_cast(': 'variant variant, int type | variant',
-\ 'variant_cat(': 'mixed left, mixed right | mixed',
-\ 'variant_cmp(': 'mixed left, mixed right [, int lcid [, int flags]] | int',
-\ 'variant_date_from_timestamp(': 'int timestamp | variant',
-\ 'variant_date_to_timestamp(': 'variant variant | int',
-\ 'variant_div(': 'mixed left, mixed right | mixed',
-\ 'variant_eqv(': 'mixed left, mixed right | mixed',
-\ 'variant_fix(': 'mixed variant | mixed',
-\ 'variant_get_type(': 'variant variant | int',
-\ 'variant_idiv(': 'mixed left, mixed right | mixed',
-\ 'variant_imp(': 'mixed left, mixed right | mixed',
-\ 'variant_int(': 'mixed variant | mixed',
-\ 'variant_mod(': 'mixed left, mixed right | mixed',
-\ 'variant_mul(': 'mixed left, mixed right | mixed',
-\ 'variant_neg(': 'mixed variant | mixed',
-\ 'variant_not(': 'mixed variant | mixed',
-\ 'variant_or(': 'mixed left, mixed right | mixed',
-\ 'variant_pow(': 'mixed left, mixed right | mixed',
-\ 'variant_round(': 'mixed variant, int decimals | mixed',
-\ 'variant_set(': 'variant variant, mixed value | void',
-\ 'variant_set_type(': 'variant variant, int type | void',
-\ 'variant_sub(': 'mixed left, mixed right | mixed',
-\ 'variant_xor(': 'mixed left, mixed right | mixed',
-\ 'version_compare(': 'string version1, string version2 [, string operator] | mixed',
-\ 'vfprintf(': 'resource handle, string format, array args | int',
-\ 'virtual(': 'string filename | bool',
-\ 'vpopmail_add_alias_domain_ex(': 'string olddomain, string newdomain | bool',
-\ 'vpopmail_add_alias_domain(': 'string domain, string aliasdomain | bool',
-\ 'vpopmail_add_domain_ex(': 'string domain, string passwd [, string quota [, string bounce [, bool apop]]] | bool',
-\ 'vpopmail_add_domain(': 'string domain, string dir, int uid, int gid | bool',
-\ 'vpopmail_add_user(': 'string user, string domain, string password [, string gecos [, bool apop]] | bool',
-\ 'vpopmail_alias_add(': 'string user, string domain, string alias | bool',
-\ 'vpopmail_alias_del_domain(': 'string domain | bool',
-\ 'vpopmail_alias_del(': 'string user, string domain | bool',
-\ 'vpopmail_alias_get_all(': 'string domain | array',
-\ 'vpopmail_alias_get(': 'string alias, string domain | array',
-\ 'vpopmail_auth_user(': 'string user, string domain, string password [, string apop] | bool',
-\ 'vpopmail_del_domain_ex(': 'string domain | bool',
-\ 'vpopmail_del_domain(': 'string domain | bool',
-\ 'vpopmail_del_user(': 'string user, string domain | bool',
-\ 'vpopmail_error(': 'void  | string',
-\ 'vpopmail_passwd(': 'string user, string domain, string password [, bool apop] | bool',
-\ 'vpopmail_set_user_quota(': 'string user, string domain, string quota | bool',
-\ 'vprintf(': 'string format, array args | int',
-\ 'vsprintf(': 'string format, array args | string',
-\ 'w32api_deftype(': 'string typename, string member1_type, string member1_name [, string ... [, string ...]] | bool',
-\ 'w32api_init_dtype(': 'string typename, mixed value [, mixed ...] | resource',
-\ 'w32api_invoke_function(': 'string funcname, mixed argument [, mixed ...] | mixed',
-\ 'w32api_register_function(': 'string library, string function_name, string return_type | bool',
-\ 'w32api_set_call_method(': 'int method | void',
-\ 'wddx_add_vars(': 'int packet_id, mixed name_var [, mixed ...] | bool',
-\ 'wddx_packet_end(': 'resource packet_id | string',
-\ 'wddx_packet_start(': '[string comment] | resource',
-\ 'wddx_serialize_value(': 'mixed var [, string comment] | string',
-\ 'wddx_serialize_vars(': 'mixed var_name [, mixed ...] | string',
-\ 'wddx_unserialize(': 'string packet | mixed',
-\ 'win32_create_service(': 'array details [, string machine] | int',
-\ 'win32_delete_service(': 'string servicename [, string machine] | int',
-\ 'win32_get_last_control_message(': 'void  | int',
-\ 'win32_ps_list_procs(': 'void  | array',
-\ 'win32_ps_stat_mem(': 'void  | array',
-\ 'win32_ps_stat_proc(': '[int pid] | array',
-\ 'win32_query_service_status(': 'string servicename [, string machine] | mixed',
-\ 'win32_set_service_status(': 'int status | bool',
-\ 'win32_start_service_ctrl_dispatcher(': 'string name | bool',
-\ 'win32_start_service(': 'string servicename [, string machine] | int',
-\ 'win32_stop_service(': 'string servicename [, string machine] | int',
-\ 'wordwrap(': 'string str [, int width [, string break [, bool cut]]] | string',
-\ 'xattr_get(': 'string filename, string name [, int flags] | string',
-\ 'xattr_list(': 'string filename [, int flags] | array',
-\ 'xattr_remove(': 'string filename, string name [, int flags] | bool',
-\ 'xattr_set(': 'string filename, string name, string value [, int flags] | bool',
-\ 'xattr_supported(': 'string filename [, int flags] | bool',
-\ 'xdiff_file_diff_binary(': 'string file1, string file2, string dest | bool',
-\ 'xdiff_file_diff(': 'string file1, string file2, string dest [, int context [, bool minimal]] | bool',
-\ 'xdiff_file_merge3(': 'string file1, string file2, string file3, string dest | mixed',
-\ 'xdiff_file_patch_binary(': 'string file, string patch, string dest | bool',
-\ 'xdiff_file_patch(': 'string file, string patch, string dest [, int flags] | mixed',
-\ 'xdiff_string_diff_binary(': 'string str1, string str2 | string',
-\ 'xdiff_string_diff(': 'string str1, string str2 [, int context [, bool minimal]] | string',
-\ 'xdiff_string_merge3(': 'string str1, string str2, string str3 [, string &#38;error] | mixed',
-\ 'xdiff_string_patch_binary(': 'string str, string patch | string',
-\ 'xdiff_string_patch(': 'string str, string patch [, int flags [, string &#38;error]] | string',
-\ 'xml_error_string(': 'int code | string',
-\ 'xml_get_current_byte_index(': 'resource parser | int',
-\ 'xml_get_current_column_number(': 'resource parser | int',
-\ 'xml_get_current_line_number(': 'resource parser | int',
-\ 'xml_get_error_code(': 'resource parser | int',
-\ 'xml_parse(': 'resource parser, string data [, bool is_final] | int',
-\ 'xml_parse_into_struct(': 'resource parser, string data, array &#38;values [, array &#38;index] | int',
-\ 'xml_parser_create(': '[string encoding] | resource',
-\ 'xml_parser_create_ns(': '[string encoding [, string separator]] | resource',
-\ 'xml_parser_free(': 'resource parser | bool',
-\ 'xml_parser_get_option(': 'resource parser, int option | mixed',
-\ 'xml_parser_set_option(': 'resource parser, int option, mixed value | bool',
-\ 'xmlrpc_decode(': 'string xml [, string encoding] | array',
-\ 'xmlrpc_decode_request(': 'string xml, string &#38;method [, string encoding] | array',
-\ 'xmlrpc_encode(': 'mixed value | string',
-\ 'xmlrpc_encode_request(': 'string method, mixed params [, array output_options] | string',
-\ 'xmlrpc_get_type(': 'mixed value | string',
-\ 'xmlrpc_is_fault(': 'array arg | bool',
-\ 'xmlrpc_parse_method_descriptions(': 'string xml | array',
-\ 'xmlrpc_server_add_introspection_data(': 'resource server, array desc | int',
-\ 'xmlrpc_server_call_method(': 'resource server, string xml, mixed user_data [, array output_options] | string',
-\ 'xmlrpc_server_create(': 'void  | resource',
-\ 'xmlrpc_server_destroy(': 'resource server | int',
-\ 'xmlrpc_server_register_introspection_callback(': 'resource server, string function | bool',
-\ 'xmlrpc_server_register_method(': 'resource server, string method_name, string function | bool',
-\ 'xmlrpc_set_type(': 'string &#38;value, string type | bool',
-\ 'xml_set_character_data_handler(': 'resource parser, callback handler | bool',
-\ 'xml_set_default_handler(': 'resource parser, callback handler | bool',
-\ 'xml_set_element_handler(': 'resource parser, callback start_element_handler, callback end_element_handler | bool',
-\ 'xml_set_end_namespace_decl_handler(': 'resource parser, callback handler | bool',
-\ 'xml_set_external_entity_ref_handler(': 'resource parser, callback handler | bool',
-\ 'xml_set_notation_decl_handler(': 'resource parser, callback handler | bool',
-\ 'xml_set_object(': 'resource parser, object &#38;object | bool',
-\ 'xml_set_processing_instruction_handler(': 'resource parser, callback handler | bool',
-\ 'xml_set_start_namespace_decl_handler(': 'resource parser, callback handler | bool',
-\ 'xml_set_unparsed_entity_decl_handler(': 'resource parser, callback handler | bool',
-\ 'xmlwriter_end_attribute(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_cdata(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_comment(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_document(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_dtd_attlist(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_dtd_element(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_dtd_entity(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_dtd(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_element(': 'resource xmlwriter | bool',
-\ 'xmlwriter_end_pi(': 'resource xmlwriter | bool',
-\ 'xmlwriter_flush(': 'resource xmlwriter [, bool empty] | mixed',
-\ 'xmlwriter_full_end_element(': 'resource xmlwriter | bool',
-\ 'xmlwriter_open_memory(': 'void  | resource',
-\ 'xmlwriter_open_uri(': 'string source | resource',
-\ 'xmlwriter_output_memory(': 'resource xmlwriter [, bool flush] | string',
-\ 'xmlwriter_set_indent(': 'resource xmlwriter, bool indent | bool',
-\ 'xmlwriter_set_indent_string(': 'resource xmlwriter, string indentString | bool',
-\ 'xmlwriter_start_attribute(': 'resource xmlwriter, string name | bool',
-\ 'xmlwriter_start_attribute_ns(': 'resource xmlwriter, string prefix, string name, string uri | bool',
-\ 'xmlwriter_start_cdata(': 'resource xmlwriter | bool',
-\ 'xmlwriter_start_comment(': 'resource xmlwriter | bool',
-\ 'xmlwriter_start_document(': 'resource xmlwriter [, string version [, string encoding [, string standalone]]] | bool',
-\ 'xmlwriter_start_dtd_attlist(': 'resource xmlwriter, string name | bool',
-\ 'xmlwriter_start_dtd_element(': 'resource xmlwriter, string name | bool',
-\ 'xmlwriter_start_dtd_entity(': 'resource xmlwriter, string name, bool isparam | bool',
-\ 'xmlwriter_start_dtd(': 'resource xmlwriter, string name [, string pubid [, string sysid]] | bool',
-\ 'xmlwriter_start_element(': 'resource xmlwriter, string name | bool',
-\ 'xmlwriter_start_element_ns(': 'resource xmlwriter, string prefix, string name, string uri | bool',
-\ 'xmlwriter_start_pi(': 'resource xmlwriter, string target | bool',
-\ 'xmlwriter_text(': 'resource xmlwriter, string content | bool',
-\ 'xmlwriter_write_attribute(': 'resource xmlwriter, string name, string content | bool',
-\ 'xmlwriter_write_attribute_ns(': 'resource xmlwriter, string prefix, string name, string uri, string content | bool',
-\ 'xmlwriter_write_cdata(': 'resource xmlwriter, string content | bool',
-\ 'xmlwriter_write_comment(': 'resource xmlwriter, string content | bool',
-\ 'xmlwriter_write_dtd_attlist(': 'resource xmlwriter, string name, string content | bool',
-\ 'xmlwriter_write_dtd_element(': 'resource xmlwriter, string name, string content | bool',
-\ 'xmlwriter_write_dtd_entity(': 'resource xmlwriter, string name, string content | bool',
-\ 'xmlwriter_write_dtd(': 'resource xmlwriter, string name [, string pubid [, string sysid [, string subset]]] | bool',
-\ 'xmlwriter_write_element(': 'resource xmlwriter, string name, string content | bool',
-\ 'xmlwriter_write_element_ns(': 'resource xmlwriter, string prefix, string name, string uri, string content | bool',
-\ 'xmlwriter_write_pi(': 'resource xmlwriter, string target, string content | bool',
-\ 'xmlwriter_write_raw(': 'resource xmlwriter, string content | bool',
-\ 'xpath_new_context(': 'domdocument dom_document | XPathContext',
-\ 'xpath_register_ns_auto(': 'XPathContext xpath_context [, object context_node] | bool',
-\ 'xpath_register_ns(': 'XPathContext xpath_context, string prefix, string uri | bool',
-\ 'xptr_new_context(': 'void  | XPathContext',
-\ 'xslt_backend_info(': 'void  | string',
-\ 'xslt_backend_name(': 'void  | string',
-\ 'xslt_backend_version(': 'void  | string',
-\ 'xslt_create(': 'void  | resource',
-\ 'xslt_errno(': 'resource xh | int',
-\ 'xslt_error(': 'resource xh | string',
-\ 'xslt_free(': 'resource xh | void',
-\ 'xslt_getopt(': 'resource processor | int',
-\ 'xslt_process(': 'resource xh, string xmlcontainer, string xslcontainer [, string resultcontainer [, array arguments [, array parameters]]] | mixed',
-\ 'xslt_set_base(': 'resource xh, string uri | void',
-\ 'xslt_set_encoding(': 'resource xh, string encoding | void',
-\ 'xslt_set_error_handler(': 'resource xh, mixed handler | void',
-\ 'xslt_set_log(': 'resource xh [, mixed log] | void',
-\ 'xslt_set_object(': 'resource processor, object &#38;obj | bool',
-\ 'xslt_setopt(': 'resource processor, int newmask | mixed',
-\ 'xslt_set_sax_handler(': 'resource xh, array handlers | void',
-\ 'xslt_set_sax_handlers(': 'resource processor, array handlers | void',
-\ 'xslt_set_scheme_handler(': 'resource xh, array handlers | void',
-\ 'xslt_set_scheme_handlers(': 'resource processor, array handlers | void',
-\ 'yaz_addinfo(': 'resource id | string',
-\ 'yaz_ccl_conf(': 'resource id, array config | void',
-\ 'yaz_ccl_parse(': 'resource id, string query, array &#38;result | bool',
-\ 'yaz_close(': 'resource id | bool',
-\ 'yaz_connect(': 'string zurl [, mixed options] | mixed',
-\ 'yaz_database(': 'resource id, string databases | bool',
-\ 'yaz_element(': 'resource id, string elementset | bool',
-\ 'yaz_errno(': 'resource id | int',
-\ 'yaz_error(': 'resource id | string',
-\ 'yaz_es_result(': 'resource id | array',
-\ 'yaz_get_option(': 'resource id, string name | string',
-\ 'yaz_hits(': 'resource id [, array searchresult] | int',
-\ 'yaz_itemorder(': 'resource id, array args | void',
-\ 'yaz_present(': 'resource id | bool',
-\ 'yaz_range(': 'resource id, int start, int number | void',
-\ 'yaz_record(': 'resource id, int pos, string type | string',
-\ 'yaz_scan(': 'resource id, string type, string startterm [, array flags] | void',
-\ 'yaz_scan_result(': 'resource id [, array &#38;result] | array',
-\ 'yaz_schema(': 'resource id, string schema | void',
-\ 'yaz_search(': 'resource id, string type, string query | bool',
-\ 'yaz_set_option(': 'resource id, string name, string value | void',
-\ 'yaz_sort(': 'resource id, string criteria | void',
-\ 'yaz_syntax(': 'resource id, string syntax | void',
-\ 'yaz_wait(': '[array &#38;options] | mixed',
-\ 'yp_all(': 'string domain, string map, string callback | void',
-\ 'yp_cat(': 'string domain, string map | array',
-\ 'yp_errno(': 'void  | int',
-\ 'yp_err_string(': 'int errorcode | string',
-\ 'yp_first(': 'string domain, string map | array',
-\ 'yp_get_default_domain(': 'void  | string',
-\ 'yp_master(': 'string domain, string map | string',
-\ 'yp_match(': 'string domain, string map, string key | string',
-\ 'yp_next(': 'string domain, string map, string key | array',
-\ 'yp_order(': 'string domain, string map | int',
-\ 'zend_logo_guid(': 'void  | string',
-\ 'zend_version(': 'void  | string',
-\ 'zip_close(': 'resource zip | void',
-\ 'zip_entry_close(': 'resource zip_entry | void',
-\ 'zip_entry_compressedsize(': 'resource zip_entry | int',
-\ 'zip_entry_compressionmethod(': 'resource zip_entry | string',
-\ 'zip_entry_filesize(': 'resource zip_entry | int',
-\ 'zip_entry_name(': 'resource zip_entry | string',
-\ 'zip_entry_open(': 'resource zip, resource zip_entry [, string mode] | bool',
-\ 'zip_entry_read(': 'resource zip_entry [, int length] | string',
-\ 'zip_open(': 'string filename | resource',
-\ 'zip_read(': 'resource zip | resource',
-\ 'zlib_get_coding_type(': 'void  | string'
-\ }
-" }}}
-" built-in object functions {{{
-let g:php_builtin_object_functions = {
-\ 'ArrayIterator::current(': 'void  | mixed',
-\ 'ArrayIterator::key(': 'void  | mixed',
-\ 'ArrayIterator::next(': 'void  | void',
-\ 'ArrayIterator::rewind(': 'void  | void',
-\ 'ArrayIterator::seek(': 'int position | void',
-\ 'ArrayIterator::valid(': 'void  | bool',
-\ 'ArrayObject::append(': 'mixed newval | void',
-\ 'ArrayObject::__construct(': 'mixed input | ArrayObject',
-\ 'ArrayObject::count(': 'void  | int',
-\ 'ArrayObject::getIterator(': 'void  | ArrayIterator',
-\ 'ArrayObject::offsetExists(': 'mixed index | bool',
-\ 'ArrayObject::offsetGet(': 'mixed index | bool',
-\ 'ArrayObject::offsetSet(': 'mixed index, mixed newval | void',
-\ 'ArrayObject::offsetUnset(': 'mixed index | void',
-\ 'CachingIterator::hasNext(': 'void  | bool',
-\ 'CachingIterator::next(': 'void  | void',
-\ 'CachingIterator::rewind(': 'void  | void',
-\ 'CachingIterator::__toString(': 'void  | string',
-\ 'CachingIterator::valid(': 'void  | bool',
-\ 'CachingRecursiveIterator::getChildren(': 'void  | CachingRecursiveIterator',
-\ 'CachingRecursiveIterator::hasChildren(': 'void  | bolean',
-\ 'DirectoryIterator::__construct(': 'string path | DirectoryIterator',
-\ 'DirectoryIterator::current(': 'void  | DirectoryIterator',
-\ 'DirectoryIterator::getATime(': 'void  | int',
-\ 'DirectoryIterator::getChildren(': 'void  | RecursiveDirectoryIterator',
-\ 'DirectoryIterator::getCTime(': 'void  | int',
-\ 'DirectoryIterator::getFilename(': 'void  | string',
-\ 'DirectoryIterator::getGroup(': 'void  | int',
-\ 'DirectoryIterator::getInode(': 'void  | int',
-\ 'DirectoryIterator::getMTime(': 'void  | int',
-\ 'DirectoryIterator::getOwner(': 'void  | int',
-\ 'DirectoryIterator::getPath(': 'void  | string',
-\ 'DirectoryIterator::getPathname(': 'void  | string',
-\ 'DirectoryIterator::getPerms(': 'void  | int',
-\ 'DirectoryIterator::getSize(': 'void  | int',
-\ 'DirectoryIterator::getType(': 'void  | string',
-\ 'DirectoryIterator::isDir(': 'void  | bool',
-\ 'DirectoryIterator::isDot(': 'void  | bool',
-\ 'DirectoryIterator::isExecutable(': 'void  | bool',
-\ 'DirectoryIterator::isFile(': 'void  | bool',
-\ 'DirectoryIterator::isLink(': 'void  | bool',
-\ 'DirectoryIterator::isReadable(': 'void  | bool',
-\ 'DirectoryIterator::isWritable(': 'void  | bool',
-\ 'DirectoryIterator::key(': 'void  | string',
-\ 'DirectoryIterator::next(': 'void  | void',
-\ 'DirectoryIterator::rewind(': 'void  | void',
-\ 'DirectoryIterator::valid(': 'void  | string',
-\ 'FilterIterator::current(': 'void  | mixed',
-\ 'FilterIterator::getInnerIterator(': 'void  | Iterator',
-\ 'FilterIterator::key(': 'void  | mixed',
-\ 'FilterIterator::next(': 'void  | void',
-\ 'FilterIterator::rewind(': 'void  | void',
-\ 'FilterIterator::valid(': 'void  | bool',
-\ 'LimitIterator::getPosition(': 'void  | int',
-\ 'LimitIterator::next(': 'void  | void',
-\ 'LimitIterator::rewind(': 'void  | void',
-\ 'LimitIterator::seek(': 'int position | void',
-\ 'LimitIterator::valid(': 'void  | bool',
-\ 'Memcache::add(': 'string key, mixed var [, int flag [, int expire]] | bool',
-\ 'Memcache::addServer(': 'string host [, int port [, bool persistent [, int weight [, int timeout [, int retry_interval]]]]] | bool',
-\ 'Memcache::close(': 'void  | bool',
-\ 'Memcache::connect(': 'string host [, int port [, int timeout]] | bool',
-\ 'Memcache::decrement(': 'string key [, int value] | int',
-\ 'Memcache::delete(': 'string key [, int timeout] | bool',
-\ 'Memcache::flush(': 'void  | bool',
-\ 'Memcache::getExtendedStats(': 'void  | array',
-\ 'Memcache::get(': 'string key | string',
-\ 'Memcache::getStats(': 'void  | array',
-\ 'Memcache::getVersion(': 'void  | string',
-\ 'Memcache::increment(': 'string key [, int value] | int',
-\ 'Memcache::pconnect(': 'string host [, int port [, int timeout]] | bool',
-\ 'Memcache::replace(': 'string key, mixed var [, int flag [, int expire]] | bool',
-\ 'Memcache::setCompressThreshold(': 'int threshold [, float min_savings] | bool',
-\ 'Memcache::set(': 'string key, mixed var [, int flag [, int expire]] | bool',
-\ 'ParentIterator::getChildren(': 'void  | ParentIterator',
-\ 'ParentIterator::hasChildren(': 'void  | bool',
-\ 'ParentIterator::next(': 'void  | void',
-\ 'ParentIterator::rewind(': 'void  | void',
-\ 'PDO::beginTransaction(': 'void  | bool',
-\ 'PDO::commit(': 'void  | bool',
-\ 'PDO::__construct(': 'string dsn [, string username [, string password [, array driver_options]]] | PDO',
-\ 'PDO::errorCode(': 'void  | string',
-\ 'PDO::errorInfo(': 'void  | array',
-\ 'PDO::exec(': 'string statement | int',
-\ 'PDO::getAttribute(': 'int attribute | mixed',
-\ 'PDO::getAvailableDrivers(': 'void  | array',
-\ 'PDO::lastInsertId(': '[string name] | string',
-\ 'PDO::prepare(': 'string statement [, array driver_options] | PDOStatement',
-\ 'PDO::query(': 'string statement | PDOStatement',
-\ 'PDO::quote(': 'string string [, int parameter_type] | string',
-\ 'PDO::rollBack(': 'void  | bool',
-\ 'PDO::setAttribute(': 'int attribute, mixed value | bool',
-\ 'PDO::sqliteCreateAggregate(': 'string function_name, callback step_func, callback finalize_func [, int num_args] | bool',
-\ 'PDO::sqliteCreateFunction(': 'string function_name, callback callback [, int num_args] | bool',
-\ 'PDOStatement::bindColumn(': 'mixed column, mixed &#38;param [, int type] | bool',
-\ 'PDOStatement::bindParam(': 'mixed parameter, mixed &#38;variable [, int data_type [, int length [, mixed driver_options]]] | bool',
-\ 'PDOStatement::bindValue(': 'mixed parameter, mixed value [, int data_type] | bool',
-\ 'PDOStatement::closeCursor(': 'void  | bool',
-\ 'PDOStatement::columnCount(': 'void  | int',
-\ 'PDOStatement::errorCode(': 'void  | string',
-\ 'PDOStatement::errorInfo(': 'void  | array',
-\ 'PDOStatement::execute(': '[array input_parameters] | bool',
-\ 'PDOStatement::fetchAll(': '[int fetch_style [, int column_index]] | array',
-\ 'PDOStatement::fetchColumn(': '[int column_number] | string',
-\ 'PDOStatement::fetch(': '[int fetch_style [, int cursor_orientation [, int cursor_offset]]] | mixed',
-\ 'PDOStatement::fetchObject(': '[string class_name [, array ctor_args]] | mixed',
-\ 'PDOStatement::getAttribute(': 'int attribute | mixed',
-\ 'PDOStatement::getColumnMeta(': 'int column | mixed',
-\ 'PDOStatement::nextRowset(': 'void  | bool',
-\ 'PDOStatement::rowCount(': 'void  | int',
-\ 'PDOStatement::setAttribute(': 'int attribute, mixed value | bool',
-\ 'PDOStatement::setFetchMode(': 'int mode | bool',
-\ 'Rar::extract(': 'string dir [, string filepath] | bool',
-\ 'Rar::getAttr(': 'void  | int',
-\ 'Rar::getCrc(': 'void  | int',
-\ 'Rar::getFileTime(': 'void  | string',
-\ 'Rar::getHostOs(': 'void  | int',
-\ 'Rar::getMethod(': 'void  | int',
-\ 'Rar::getName(': 'void  | string',
-\ 'Rar::getPackedSize(': 'void  | int',
-\ 'Rar::getUnpackedSize(': 'void  | int',
-\ 'Rar::getVersion(': 'void  | int',
-\ 'RecursiveDirectoryIterator::getChildren(': 'void  | object',
-\ 'RecursiveDirectoryIterator::hasChildren(': '[bool allow_links] | bool',
-\ 'RecursiveDirectoryIterator::key(': 'void  | string',
-\ 'RecursiveDirectoryIterator::next(': 'void  | void',
-\ 'RecursiveDirectoryIterator::rewind(': 'void  | void',
-\ 'RecursiveIteratorIterator::current(': 'void  | mixed',
-\ 'RecursiveIteratorIterator::getDepth(': 'void  | int',
-\ 'RecursiveIteratorIterator::getSubIterator(': 'void  | RecursiveIterator',
-\ 'RecursiveIteratorIterator::key(': 'void  | mixed',
-\ 'RecursiveIteratorIterator::next(': 'void  | void',
-\ 'RecursiveIteratorIterator::rewind(': 'void  | void',
-\ 'RecursiveIteratorIterator::valid(': 'void  | bolean',
-\ 'SDO_DAS_ChangeSummary::beginLogging(': 'void  | void',
-\ 'SDO_DAS_ChangeSummary::endLogging(': 'void  | void',
-\ 'SDO_DAS_ChangeSummary::getChangedDataObjects(': 'void  | SDO_List',
-\ 'SDO_DAS_ChangeSummary::getChangeType(': 'SDO_DataObject dataObject | int',
-\ 'SDO_DAS_ChangeSummary::getOldContainer(': 'SDO_DataObject data_object | SDO_DataObject',
-\ 'SDO_DAS_ChangeSummary::getOldValues(': 'SDO_DataObject data_object | SDO_List',
-\ 'SDO_DAS_ChangeSummary::isLogging(': 'void  | bool',
-\ 'SDO_DAS_DataFactory::addPropertyToType(': 'string parent_type_namespace_uri, string parent_type_name, string property_name, string type_namespace_uri, string type_name [, array options] | void',
-\ 'SDO_DAS_DataFactory::addType(': 'string type_namespace_uri, string type_name [, array options] | void',
-\ 'SDO_DAS_DataFactory::getDataFactory(': 'void  | SDO_DAS_DataFactory',
-\ 'SDO_DAS_DataObject::getChangeSummary(': 'void  | SDO_DAS_ChangeSummary',
-\ 'SDO_DAS_Relational::applyChanges(': 'PDO database_handle, SDODataObject root_data_object | void',
-\ 'SDO_DAS_Relational::__construct(': 'array database_metadata [, string application_root_type [, array SDO_containment_references_metadata]] | SDO_DAS_Relational',
-\ 'SDO_DAS_Relational::createRootDataObject(': 'void  | SDODataObject',
-\ 'SDO_DAS_Relational::executePreparedQuery(': 'PDO database_handle, PDOStatement prepared_statement, array value_list [, array column_specifier] | SDODataObject',
-\ 'SDO_DAS_Relational::executeQuery(': 'PDO database_handle, string SQL_statement [, array column_specifier] | SDODataObject',
-\ 'SDO_DAS_Setting::getListIndex(': 'void  | int',
-\ 'SDO_DAS_Setting::getPropertyIndex(': 'void  | int',
-\ 'SDO_DAS_Setting::getPropertyName(': 'void  | string',
-\ 'SDO_DAS_Setting::getValue(': 'void  | mixed',
-\ 'SDO_DAS_Setting::isSet(': 'void  | bool',
-\ 'SDO_DAS_XML::addTypes(': 'string xsd_file | void',
-\ 'SDO_DAS_XML::createDataObject(': 'string namespace_uri, string type_name | SDO_DataObject',
-\ 'SDO_DAS_XML::createDocument(': '[string document_element_name] | SDO_DAS_XML_Document',
-\ 'SDO_DAS_XML::create(': '[string xsd_file] | SDO_DAS_XML',
-\ 'SDO_DAS_XML_Document::getRootDataObject(': 'void  | SDO_DataObject',
-\ 'SDO_DAS_XML_Document::getRootElementName(': 'void  | string',
-\ 'SDO_DAS_XML_Document::getRootElementURI(': 'void  | string',
-\ 'SDO_DAS_XML_Document::setEncoding(': 'string encoding | void',
-\ 'SDO_DAS_XML_Document::setXMLDeclaration(': 'bool xmlDeclatation | void',
-\ 'SDO_DAS_XML_Document::setXMLVersion(': 'string xmlVersion | void',
-\ 'SDO_DAS_XML::loadFile(': 'string xml_file | SDO_XMLDocument',
-\ 'SDO_DAS_XML::loadString(': 'string xml_string | SDO_DAS_XML_Document',
-\ 'SDO_DAS_XML::saveFile(': 'SDO_XMLDocument xdoc, string xml_file [, int indent] | void',
-\ 'SDO_DAS_XML::saveString(': 'SDO_XMLDocument xdoc [, int indent] | string',
-\ 'SDO_DataFactory::create(': 'string type_namespace_uri, string type_name | void',
-\ 'SDO_DataObject::clear(': 'void  | void',
-\ 'SDO_DataObject::createDataObject(': 'mixed identifier | SDO_DataObject',
-\ 'SDO_DataObject::getContainer(': 'void  | SDO_DataObject',
-\ 'SDO_DataObject::getSequence(': 'void  | SDO_Sequence',
-\ 'SDO_DataObject::getTypeName(': 'void  | string',
-\ 'SDO_DataObject::getTypeNamespaceURI(': 'void  | string',
-\ 'SDO_Exception::getCause(': 'void  | mixed',
-\ 'SDO_List::insert(': 'mixed value [, int index] | void',
-\ 'SDO_Model_Property::getContainingType(': 'void  | SDO_Model_Type',
-\ 'SDO_Model_Property::getDefault(': 'void  | mixed',
-\ 'SDO_Model_Property::getName(': 'void  | string',
-\ 'SDO_Model_Property::getType(': 'void  | SDO_Model_Type',
-\ 'SDO_Model_Property::isContainment(': 'void  | bool',
-\ 'SDO_Model_Property::isMany(': 'void  | bool',
-\ 'SDO_Model_ReflectionDataObject::__construct(': 'SDO_DataObject data_object | SDO_Model_ReflectionDataObject',
-\ 'SDO_Model_ReflectionDataObject::export(': 'SDO_Model_ReflectionDataObject rdo [, bool return] | mixed',
-\ 'SDO_Model_ReflectionDataObject::getContainmentProperty(': 'void  | SDO_Model_Property',
-\ 'SDO_Model_ReflectionDataObject::getInstanceProperties(': 'void  | array',
-\ 'SDO_Model_ReflectionDataObject::getType(': 'void  | SDO_Model_Type',
-\ 'SDO_Model_Type::getBaseType(': 'void  | SDO_Model_Type',
-\ 'SDO_Model_Type::getName(': 'void  | string',
-\ 'SDO_Model_Type::getNamespaceURI(': 'void  | string',
-\ 'SDO_Model_Type::getProperties(': 'void  | array',
-\ 'SDO_Model_Type::getProperty(': 'mixed identifier | SDO_Model_Property',
-\ 'SDO_Model_Type::isAbstractType(': 'void  | bool',
-\ 'SDO_Model_Type::isDataType(': 'void  | bool',
-\ 'SDO_Model_Type::isInstance(': 'SDO_DataObject data_object | bool',
-\ 'SDO_Model_Type::isOpenType(': 'void  | bool',
-\ 'SDO_Model_Type::isSequencedType(': 'void  | bool',
-\ 'SDO_Sequence::getProperty(': 'int sequence_index | SDO_Model_Property',
-\ 'SDO_Sequence::insert(': 'mixed value [, int sequenceIndex [, mixed propertyIdentifier]] | void',
-\ 'SDO_Sequence::move(': 'int toIndex, int fromIndex | void',
-\ 'SimpleXMLIterator::current(': 'void  | mixed',
-\ 'SimpleXMLIterator::getChildren(': 'void  | object',
-\ 'SimpleXMLIterator::hasChildren(': 'void  | bool',
-\ 'SimpleXMLIterator::key(': 'void  | mixed',
-\ 'SimpleXMLIterator::next(': 'void  | void',
-\ 'SimpleXMLIterator::rewind(': 'void  | void',
-\ 'SimpleXMLIterator::valid(': 'void  | bool',
-\ 'SWFButton::addASound(': 'SWFSound sound, int flags | SWFSoundInstance',
-\ 'SWFButton::setMenu(': 'int flag | void',
-\ 'SWFDisplayItem::addAction(': 'SWFAction action, int flags | void',
-\ 'SWFDisplayItem::endMask(': 'void  | void',
-\ 'SWFDisplayItem::getRot(': 'void  | float',
-\ 'SWFDisplayItem::getX(': 'void  | float',
-\ 'SWFDisplayItem::getXScale(': 'void  | float',
-\ 'SWFDisplayItem::getXSkew(': 'void  | float',
-\ 'SWFDisplayItem::getY(': 'void  | float',
-\ 'SWFDisplayItem::getYScale(': 'void  | float',
-\ 'SWFDisplayItem::getYSkew(': 'void  | float',
-\ 'SWFDisplayItem::setMaskLevel(': 'int level | void',
-\ 'SWFDisplayItem::setMatrix(': 'float a, float b, float c, float d, float x, float y | void',
-\ 'SWFFontChar::addChars(': 'string char | void',
-\ 'SWFFontChar::addUTF8Chars(': 'string char | void',
-\ 'SWFFont::getAscent(': 'void  | float',
-\ 'SWFFont::getDescent(': 'void  | float',
-\ 'SWFFont::getLeading(': 'void  | float',
-\ 'SWFFont::getShape(': 'int code | string',
-\ 'SWFFont::getUTF8Width(': 'string string | float',
-\ 'SWFMovie::addExport(': 'SWFCharacter char, string name | void',
-\ 'SWFMovie::addFont(': 'SWFFont font | SWFFontChar',
-\ 'SWFMovie::importChar(': 'string libswf, string name | SWFSprite',
-\ 'SWFMovie::importFont(': 'string libswf, string name | SWFFontChar',
-\ 'SWFMovie::labelFrame(': 'string label | void',
-\ 'SWFMovie::saveToFile(': 'stream x [, int compression] | int',
-\ 'SWFMovie::startSound(': 'SWFSound sound | SWFSoundInstance',
-\ 'SWFMovie::stopSound(': 'SWFSound sound | void',
-\ 'SWFMovie::writeExports(': 'void  | void',
-\ 'SWFShape::drawArc(': 'float r, float startAngle, float endAngle | void',
-\ 'SWFShape::drawCircle(': 'float r | void',
-\ 'SWFShape::drawCubic(': 'float bx, float by, float cx, float cy, float dx, float dy | int',
-\ 'SWFShape::drawCubicTo(': 'float bx, float by, float cx, float cy, float dx, float dy | int',
-\ 'SWFShape::drawGlyph(': 'SWFFont font, string character [, int size] | void',
-\ 'SWFSoundInstance::loopCount(': 'int point | void',
-\ 'SWFSoundInstance::loopInPoint(': 'int point | void',
-\ 'SWFSoundInstance::loopOutPoint(': 'int point | void',
-\ 'SWFSoundInstance::noMultiple(': 'void  | void',
-\ 'SWFSprite::labelFrame(': 'string label | void',
-\ 'SWFSprite::startSound(': 'SWFSound sound | SWFSoundInstance',
-\ 'SWFSprite::stopSound(': 'SWFSound sound | void',
-\ 'SWFText::addUTF8String(': 'string text | void',
-\ 'SWFTextField::addChars(': 'string chars | void',
-\ 'SWFTextField::setPadding(': 'float padding | void',
-\ 'SWFText::getAscent(': 'void  | float',
-\ 'SWFText::getDescent(': 'void  | float',
-\ 'SWFText::getLeading(': 'void  | float',
-\ 'SWFText::getUTF8Width(': 'string string | float',
-\ 'SWFVideoStream::getNumFrames(': 'void  | int',
-\ 'SWFVideoStream::setDimension(': 'int x, int y | void',
-\ 'tidy::__construct(': '[string filename [, mixed config [, string encoding [, bool use_include_path]]]] | tidy'
-\ }
-			" }}}
-" Add control structures (they are outside regular pattern of PHP functions)
-let php_control = {
-			\ 'include(': 'string filename | resource',
-			\ 'include_once(': 'string filename | resource',
-			\ 'require(': 'string filename | resource',
+	for line in file
+		let c_name = matchstr(line, '\c\(class\|interface\)\s*\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
+		let kind = (line =~? '^\s*class' ? 'c' : 'i')
+		if c_name != '' && c_name =~? '^'.base
+			call add(res, {'word': c_name, 'kind': kind})
+		endif
+	endfor
+
+	" resolve the typed in part with namespaces (if theres a \ in it)
+	let [tag_match_pattern, namespace_for_class] = phpcomplete#ExpandClassName(a:base, a:current_namespace, a:imports)
+
+	let tags = []
+	if len(tag_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
+		let tags = phpcomplete#GetTaglist('^'.tag_match_pattern)
+	endif
+
+	if len(tags)
+		let base_parts = split(a:base, '\')
+		if len(base_parts) > 1
+			let namespace_part = join(base_parts[0:-2], '\').'\'
+		else
+			let namespace_part = ''
+		endif
+		let no_namespace_matches = []
+		let namespaced_matches = []
+		let seen_namespaced_tag = 0
+		for tag in tags
+			if has_key(tag, 'namespace')
+				let seen_namespaced_tag = 1
+			endif
+			let relative_name = namespace_part.tag.name
+			" match base without the namespace part for namespaced base but not namespaced tags, for tagfiles with old ctags
+			if !has_key(tag, 'namespace') && index(kinds, tag.kind) != -1 && stridx(tolower(tag.name), tolower(base[len(namespace_part):])) == 0
+				call add(no_namespace_matches, {'word': leading_slash.relative_name, 'kind': tag.kind, 'menu': tag.filename, 'info': tag.filename })
+			endif
+			if has_key(tag, 'namespace') && index(kinds, tag.kind) != -1 && tag.namespace ==? namespace_for_class
+				let full_name = tag.namespace.'\'.tag.name " absolute namespaced name (without leading '\')
+				call add(namespaced_matches, {'word': leading_slash == '\' ? leading_slash.full_name : relative_name, 'kind': tag.kind, 'menu': tag.filename, 'info': tag.filename })
+			endif
+		endfor
+		" if there was a tag with namespace field, assume tag files with namespace support, so the matches
+		" without a namespace field are in the global namespace so if there were namespace in the base
+		" we should not add them to the matches
+		if seen_namespaced_tag && namespace_part != ''
+			let no_namespace_matches = []
+		endif
+		let res += no_namespace_matches + namespaced_matches
+	endif
+
+	" look for built in classnames and interfaces
+	let base_parts = split(base, '\')
+	if a:current_namespace == '\' || (leading_slash == '\' && len(base_parts) < 2)
+		if index(kinds, 'c') != -1
+			let builtin_classnames = filter(keys(copy(g:php_builtin_classnames)), 'v:val =~? "^'.substitute(a:base, '\\', '', 'g').'"')
+			for classname in builtin_classnames
+				let menu = ''
+				" if we have a constructor for this class, add parameters as to the info
+				if has_key(g:php_builtin_classes[tolower(classname)].methods, '__construct')
+					let menu = g:php_builtin_classes[tolower(classname)]['methods']['__construct']['signature']
+				endif
+				call add(res, {'word': leading_slash.g:php_builtin_classes[tolower(classname)].name, 'kind': 'c', 'menu': menu})
+			endfor
+		endif
+
+		if index(kinds, 'i') != -1
+			let builtin_interfaces = filter(keys(copy(g:php_builtin_interfaces)), 'v:val =~? "^'.substitute(a:base, '\\', '', 'g').'"')
+			for interfacename in builtin_interfaces
+				call add(res, {'word': leading_slash.g:php_builtin_interfaces[interfacename]['name'], 'kind': 'i', 'menu': ''})
+			endfor
+		endif
+	endif
+
+	" add matching imported things
+	for [imported_name, import] in items(a:imports)
+		if imported_name =~? '^'.base && index(kinds, import.kind) != -1
+			let menu = import.name.(import.builtin ? ' - builtin' : '')
+			call add(res, {'word': imported_name, 'kind': import.kind, 'menu': menu})
+		endif
+	endfor
+
+	let res = sort(res, 'phpcomplete#CompareCompletionRow')
+	return res
+endfunction
+" }}}
+
+function! phpcomplete#CompareCompletionRow(i1, i2) " {{{
+	return a:i1.word == a:i2.word ? 0 : a:i1.word > a:i2.word ? 1 : -1
+endfunction
+" }}}
+
+function! phpcomplete#EvaluateModifiers(modifiers, required_modifiers, prohibited_modifiers) " {{{
+	" if theres no modifier, and no modifier is allowed and no modifier is required
+	if len(a:modifiers) == 0 && len(a:required_modifiers) == 0
+		return 1
+	else
+		" check if every requred modifier is present
+		for required_modifier in a:required_modifiers
+			if index(a:modifiers, required_modifier) == -1
+				return 0
+			endif
+		endfor
+
+		for modifier in a:modifiers
+			" if the modifier is prohibited its a no match
+			if index(a:prohibited_modifiers, modifier) != -1
+				return 0
+			endif
+		endfor
+
+		" anything that is not explicitly required or prohibited is allowed
+		return 1
+	endif
+endfunction
+" }}}
+
+function! phpcomplete#CompleteUserClass(context, base, sccontent, visibility) " {{{
+	let final_list = []
+	let res  = []
+
+	let required_modifiers = []
+	let prohibited_modifiers = []
+
+	if a:visibility == 'public'
+		let prohibited_modifiers += ['private', 'protected']
+	endif
+
+	" limit based on context to static or normal methods
+	let static_con = ''
+	if a:context =~ '::$' && a:context !~? 'parent::$'
+		if g:phpcomplete_relax_static_constraint != 1
+			let required_modifiers += ['static']
+		endif
+	elseif a:context =~ '->$'
+		let prohibited_modifiers += ['static']
+	endif
+
+	let all_function = filter(deepcopy(a:sccontent),
+				\ 'v:val =~ "^\\s*\\(public\\s\\+\\|protected\\s\\+\\|private\\s\\+\\|final\\s\\+\\|abstract\\s\\+\\|static\\s\\+\\)*function"')
+
+	let functions = []
+	for i in all_function
+		let modifiers = split(matchstr(tolower(i), '\zs.\+\zefunction'), '\s\+')
+		if phpcomplete#EvaluateModifiers(modifiers, required_modifiers, prohibited_modifiers) == 1
+			call add(functions, i)
+		endif
+	endfor
+
+	let c_functions = {}
+	let c_doc = {}
+	for i in functions
+		let f_name = matchstr(i,
+					\ 'function\s*&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
+		let f_args = matchstr(i,
+					\ 'function\s*&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\zs.\{-}\ze)\_s*\({\|\_$\)')
+		if f_name != '' && stridx(f_name, '__') != 0
+			let c_functions[f_name.'('] = f_args
+			if g:phpcomplete_parse_docblock_comments
+				let c_doc[f_name.'('] = phpcomplete#GetDocBlock(a:sccontent, 'function\s*&\?\<'.f_name.'\>')
+			endif
+		endif
+	endfor
+
+	" limit based on context to static or normal attributes
+	if a:context =~ '::$' && a:context !~? 'parent::$'
+		" variables must have static to be accessed as static unlike functions
+		let required_modifiers += ['static']
+	endif
+	let all_variable = filter(deepcopy(a:sccontent),
+					\ 'v:val =~ "^\\s*\\(var\\s\\+\\|public\\s\\+\\|protected\\s\\+\\|private\\s\\+\\|final\\s\\+\\|abstract\\s\\+\\|static\\s\\+\\)\\+\\$"')
+
+	let variables = []
+	for i in all_variable
+		let modifiers = split(matchstr(tolower(i), '\zs.\+\ze\$'), '\s\+')
+		if phpcomplete#EvaluateModifiers(modifiers, required_modifiers, prohibited_modifiers) == 1
+			call add(variables, i)
+		endif
+	endfor
+
+	let static_vars = split(join(variables, ' '), '\$')
+	let c_variables = {}
+
+	let var_index = 0
+	for i in static_vars
+		let c_var = matchstr(i,
+					\ '^\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
+		if c_var != ''
+			if a:context =~ '::$'
+				let c_var = '$'.c_var
+			endif
+			let c_variables[c_var] = ''
+			if g:phpcomplete_parse_docblock_comments && len(get(variables, var_index)) > 0
+				let c_doc[c_var] = phpcomplete#GetDocBlock(a:sccontent, variables[var_index])
+			endif
+			let var_index += 1
+		endif
+	endfor
+
+	let constants = filter(deepcopy(a:sccontent),
+				\ 'v:val =~ "^\\s*const\\s\\+"')
+
+	let jcons = join(constants, ' ')
+	let scons = split(jcons, 'const')
+
+	let c_constants = {}
+	let const_index = 0
+	for i in scons
+		let c_con = matchstr(i,
+					\ '^\s*\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
+		if c_con != ''
+			let c_constants[c_con] = ''
+			if g:phpcomplete_parse_docblock_comments && len(get(constants, const_index)) > 0
+				let c_doc[c_con] = phpcomplete#GetDocBlock(a:sccontent, constants[const_index])
+			endif
+			let const_index += 1
+		endif
+	endfor
+
+	let all_values = {}
+	call extend(all_values, c_functions)
+	call extend(all_values, c_variables)
+	call extend(all_values, c_constants)
+
+	for m in sort(keys(all_values))
+		if stridx(m, a:base) == 0
+			call add(res, m)
+		endif
+	endfor
+
+	let start_list = res
+
+	let final_list = []
+	for i in start_list
+		let docblock = phpcomplete#ParseDocBlock(get(c_doc, i, ''))
+		if has_key(c_variables, i)
+			let final_list +=
+						\ [{'word': i,
+						\	'info':phpcomplete#FormatDocBlock(docblock),
+						\	'menu':get(docblock.var, 'type', ''),
+						\	'kind':'v'}]
+		elseif has_key(c_constants, i)
+			let info = phpcomplete#FormatDocBlock(docblock)
+			if info != ''
+				let info = "\n".info
+			endif
+			let final_list +=
+						\ [{'word':i,
+						\	'info':i.info,
+						\	'menu':all_values[i],
+						\	'kind':'d'}]
+		else
+			let return_type = get(docblock.return, 'type', '')
+			if return_type != ''
+				let return_type = ' | '.return_type
+			endif
+			let info = phpcomplete#FormatDocBlock(docblock)
+			if info != ''
+				let info = "\n".info
+			endif
+			let final_list +=
+						\ [{'word':substitute(i, '.*::', '', ''),
+						\	'info':i.all_values[i].')'.info,
+						\	'menu':all_values[i].')'.return_type,
+						\	'kind':'f'}]
+		endif
+	endfor
+
+	return final_list
+endfunction
+" }}}
+
+function! phpcomplete#CompleteBuiltInClass(context, classname, base) " {{{
+	let class_info = g:php_builtin_classes[tolower(a:classname)]
+	let res = []
+	if a:context =~ '->$' " complete for everything instance related
+		" methods
+		for [method_name, method_info] in items(class_info.methods)
+			if stridx(method_name, '__') != 0 && (a:base == '' || method_name =~? '^'.a:base)
+				call add(res, {'word':method_name.'(', 'kind': 'f', 'menu': method_info.signature, 'info': method_info.signature })
+			endif
+		endfor
+		" properties
+		for [property_name, property_info] in items(class_info.properties)
+			if a:base == '' || property_name =~? '^'.a:base
+				call add(res, {'word':property_name, 'kind': 'v', 'menu': property_info.type, 'info': property_info.type })
+			endif
+		endfor
+	elseif a:context =~ '::$' " complete for everything static
+		" methods
+		for [method_name, method_info] in items(class_info.static_methods)
+			if a:base == '' || method_name =~? '^'.a:base
+				call add(res, {'word':method_name.'(', 'kind': 'f', 'menu': method_info.signature, 'info': method_info.signature })
+			endif
+		endfor
+		" properties
+		for [property_name, property_info] in items(class_info.static_properties)
+			if a:base == '' || property_name =~? '^'.a:base
+				call add(res, {'word':property_name, 'kind': 'v', 'menu': property_info.type, 'info': property_info.type })
+			endif
+		endfor
+		" constants
+		for [constant_name, constant_info] in items(class_info.constants)
+			if a:base == '' || constant_name =~? '^'.a:base
+				call add(res, {'word':constant_name, 'kind': 'd', 'menu': constant_info, 'info': constant_info})
+			endif
+		endfor
+	endif
+	return res
+endfunction
+" }}}
+
+function! phpcomplete#GetTaglist(pattern) " {{{
+	let cache_checksum = ''
+	if g:phpcomplete_cache_taglists == 1
+		" build a string with  format of "<tagfile>:<mtime>$<tagfile2>:<mtime2>..."
+		" to validate that the tags are not changed since the time we saved the results in cache
+		for tagfile in sort(tagfiles())
+			let cache_checksum .= fnamemodify(tagfile, ':p').':'.getftime(tagfile).'$'
+		endfor
+
+		if s:cache_tags_checksum != cache_checksum
+			" tag file(s) changed
+			" since we don't know where individual tags coming from when calling taglist() we zap the whole cache
+			" no way to clear only the entries originating from the changed tag file
+			let s:cache_tags = {}
+		endif
+
+		if has_key(s:cache_tags, a:pattern)
+			return s:cache_tags[a:pattern]
+		endif
+	endif
+
+	let tags = taglist(a:pattern)
+	let s:cache_tags[a:pattern] = tags
+	let has_key = has_key(s:cache_tags, a:pattern)
+	let s:cache_tags_checksum = cache_checksum
+	return tags
+endfunction
+" }}}
+
+function! phpcomplete#GetCurrentInstruction(line_number, col_number, phpbegin) " {{{
+	" locate the current instruction (up until the previous non comment or string ";" or php region start (<?php or <?) without newlines
+	let col_number = a:col_number
+	let line_number = a:line_number
+	let line = getline(a:line_number)
+	let current_char = -1
+	let instruction = ''
+	let parent_depth = 0
+	let bracket_depth = 0
+	let stop_chars = [
+				\ '!', '@', '%', '^', '&',
+				\ '*', '/', '-', '+', '=',
+				\ ':', '>', '<', '.', '?',
+				\ ';', '(', '|', '['
+				\ ]
+
+	let phpbegin_length = len(matchstr(getline(a:phpbegin[0]), '\zs<?\(php\)\?\ze'))
+	let phpbegin_end = [a:phpbegin[0], a:phpbegin[1] - 1 + phpbegin_length]
+
+	" will hold the first place where a coma could have ended the match
+	let first_coma_break_pos = -1
+	let next_char = len(line) < col_number ? line[col_number + 1] : ''
+
+	while !(line_number == 1 && col_number == 1)
+		if current_char != -1
+			let next_char = current_char
+		endif
+
+		let current_char = line[col_number]
+		let synIDName = synIDattr(synID(line_number, col_number + 1, 0), 'name')
+
+		if col_number - 1 == -1
+			let prev_line_number = line_number - 1
+			let prev_line = getline(line_number - 1)
+			let prev_col_number = strlen(prev_line)
+		else
+			let prev_line_number = line_number
+			let prev_col_number = col_number - 1
+			let prev_line = line
+		endif
+		let prev_char = prev_line[prev_col_number]
+
+		" skip comments
+		if synIDName =~? 'comment\|phpDocTags'
+			let current_char = ''
+		endif
+
+		" break on the last char of the "and" and "or" operators
+		if synIDName == 'phpOperator' && (current_char == 'r' || current_char == 'd')
+			break
+		endif
+
+		" break on statements as "return" or "throws"
+		if synIDName == 'phpStatement' || synIDName == 'phpException'
+			break
+		endif
+
+		" if the current char should be considered
+		if current_char != '' && parent_depth >= 0 && bracket_depth >= 0 && synIDName !~? 'comment\|string'
+			" break if we are on a "naked" stop_char (operators, colon, openparent...)
+			if index(stop_chars, current_char) != -1
+				let do_break = 1
+				" dont break does not look like a "->"
+				if (prev_char == '-' && current_char == '>') || (current_char == '-' && next_char == '>')
+					let do_break = 0
+				endif
+				" dont break if its looks like a "::"
+				if (prev_char == ':' && current_char == ':') || (current_char == ':' && next_char == ':')
+					let do_break = 0
+				endif
+
+				if do_break
+					break
+				endif
+			endif
+
+			" save the coma position for later use if theres a "naked" , possibly separating a parameter and it is not in a parented part
+			if first_coma_break_pos == -1 && current_char == ','
+				let first_coma_break_pos = len(instruction)
+			endif
+		endif
+
+		" count nested darenthesis and brackets so we can tell if we need to break on a ';' or not (think of for (;;) loops)
+		if synIDName =~? 'phpBraceFunc\|phpParent\|Delimiter'
+			if current_char == '('
+				let parent_depth += 1
+			elseif current_char == ')'
+				let parent_depth -= 1
+
+			elseif current_char == '['
+				let bracket_depth += 1
+			elseif current_char == ']'
+				let bracket_depth -= 1
+			endif
+		endif
+
+		" stop collecting chars if we see a function start { (think of first line in a function)
+		if (current_char == '{' || current_char == '}') && synIDName =~? 'phpBraceFunc\|phpParent\|Delimiter'
+			break
+		endif
+
+		" break if we are reached the php block start (<?php or <?)
+		if [line_number, col_number] == phpbegin_end
+			break
+		endif
+
+		let instruction = current_char.instruction
+
+		" step a char or a line back if we are on the first column of the line already
+		let col_number -= 1
+		if col_number == -1
+			let line_number -= 1
+			let line = getline(line_number)
+			let col_number = strlen(line)
+		endif
+	endwhile
+
+	" strip leading whitespace
+	let instruction = substitute(instruction, '^\s\+', '', '')
+
+	" there were a "naked" coma in the instruction
+	if first_coma_break_pos != -1
+		if instruction !~? '^use' && instruction !~? '^class' " use ... statements and class delcarations should not be broken up by comas
+			let pos = (-1 * first_coma_break_pos) + 1
+			let instruction = instruction[pos :]
+		endif
+	endif
+
+	" HACK to remove one line conditionals from code like "if ($foo) echo 'bar'"
+	" what the plugin really need is a proper php tokenizer
+	if instruction =~? '\c^\(if\|while\|foreach\|for\)\s*('
+		" clear everything up until the first (
+		let instruction = substitute(instruction, '^\(if\|while\|foreach\|for\)\s*(\s*', '', '')
+
+		" lets iterate trough the instruction until we can find the pair for the opening (
+		let i = 0
+		let depth = 1
+		while i < len(instruction)
+			if instruction[i] == '('
+				let depth += 1
+			endif
+			if instruction[i] == ')'
+				let depth -= 1
+			endif
+			if depth == 0
+				break
+			end
+			let i += 1
+		endwhile
+		let instruction = instruction[i + 1 : len(instruction)]
+	endif
+
+	" trim whitespace from the ends
+	let instruction = substitute(instruction, '\v^(^\s+)|(\s+)$', '', 'g')
+
+	return instruction
+endfunction " }}}
+
+function! phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, imports, methodstack) " {{{
+	" Tries to get the classname and namespace for a chained method call like:
+	"	$this->foo()->bar()->baz()->
+
+	let classname_candidate = a:classname_candidate
+	let class_candidate_namespace = a:class_candidate_namespace
+	let methodstack = a:methodstack
+	let unknown_result = ['', '']
+	let prev_method_is_array = (methodstack[0] =~ '\v^[^([]+\[' ? 1 : 0)
+	let classname_candidate_is_array = (classname_candidate =~ '\[\]$' ? 1 : 0)
+
+	if prev_method_is_array
+		if classname_candidate_is_array
+			let classname_candidate = substitute(classname_candidate, '\[\]$', '', '')
+		else
+			return unknown_result
+		endif
+	endif
+
+	if (len(methodstack) == 1)
+		let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, class_candidate_namespace, a:imports)
+		return [classname_candidate, class_candidate_namespace]
+	else
+		call remove(methodstack, 0)
+		let method_is_array = (methodstack[0] =~ '\v^[^[]+\[' ? 1 : 0)
+		let method = matchstr(methodstack[0], '\v^\$*\zs[^[(]+\ze')
+
+		let classlocation = phpcomplete#GetClassLocation(classname_candidate, class_candidate_namespace)
+
+		if classlocation == 'VIMPHP_BUILTINOBJECT' && has_key(g:php_builtin_classes, tolower(classname_candidate))
+			let class_info = g:php_builtin_classes[tolower(classname_candidate)]
+			if has_key(class_info['methods'], method)
+				return phpcomplete#GetCallChainReturnType(class_info['methods'][method].return_type, '\', a:imports, methodstack)
+			endif
+			if has_key(class_info['properties'], method)
+				return phpcomplete#GetCallChainReturnType(class_info['properties'][method].type, '\', a:imports, methodstack)
+			endif
+			if has_key(class_info['static_methods'], method)
+				return phpcomplete#GetCallChainReturnType(class_info['static_methods'][method].return_type, '\', a:imports, methodstack)
+			endif
+			if has_key(class_info['static_properties'], method)
+				return phpcomplete#GetCallChainReturnType(class_info['static_properties'][method].type, '\', a:imports, methodstack)
+			endif
+
+			return unknown_result
+
+		elseif classlocation != '' && filereadable(classlocation)
+			" Read the next method from the stack and extract only the name
+
+			let classcontents = phpcomplete#GetCachedClassContents(classlocation, classname_candidate)
+
+			" Get Structured information of all classes and subclasses including namespace and includes
+			" try to find the method's return type in docblock comment
+			for classstructure in classcontents
+				let doclock_target_pattern = 'function\s\+&\?'.method.'\|\(public\|private\|protected\|var\).\+\$'.method
+				let doc_str = phpcomplete#GetDocBlock(split(classstructure.content, '\n'), doclock_target_pattern)
+				if doc_str != ''
+					break
+				endif
+			endfor
+			if doc_str != ''
+				let docblock = phpcomplete#ParseDocBlock(doc_str)
+				if has_key(docblock.return, 'type') || has_key(docblock.var, 'type')
+					let type = has_key(docblock.return, 'type') ? docblock.return.type : docblock.var.type
+
+					" there's a namespace in the type, threat the type as FQCN
+					if type =~ '\\'
+						let parts = split(substitute(type, '^\\', '', ''), '\')
+						let class_candidate_namespace = join(parts[0:-2], '\')
+						let classname_candidate = parts[-1]
+						" check for renamed namepsace in imports
+						if has_key(classstructure.imports, class_candidate_namespace)
+							let class_candidate_namespace = classstructure.imports[class_candidate_namespace].name
+						endif
+					else
+						" no namespace in the type, threat it as a relative classname
+						let returnclass = type
+						if has_key(classstructure.imports, returnclass)
+							if has_key(classstructure.imports[returnclass], 'namespace')
+								let fullnamespace = classstructure.imports[returnclass].namespace
+							else
+								let fullnamespace = class_candidate_namespace
+							endif
+						else
+							let fullnamespace = class_candidate_namespace
+						endif
+						" make @return self, static, $this the same way
+						" (not exactly what php means by these)
+						if returnclass == 'self' || returnclass == 'static' || returnclass == '$this'
+							let classname_candidate = a:classname_candidate
+							let class_candidate_namespace = a:class_candidate_namespace
+						else
+							let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(returnclass, fullnamespace, a:imports)
+						endif
+					endif
+
+					return phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, a:imports, methodstack)
+				endif
+			endif
+
+			return unknown_result
+		else
+			return unknown_result
+		endif
+	endif
+endfunction " }}}
+
+function! phpcomplete#GetMethodStack(line) " {{{
+	let methodstack = []
+	let i = 0
+	let end = len(a:line)
+
+	let current_part = ''
+
+	let parent_depth = 0
+	let in_string = 0
+	let string_start = ''
+
+	let next_char = ''
+
+	while i	< end
+		let current_char = a:line[i]
+		let next_char = i + 1 < end ? a:line[i + 1] : ''
+		let prev_char = i >= 1 ? a:line[i - 1] : ''
+		let prev_prev_char = i >= 2 ? a:line[i - 2] : ''
+
+		if in_string == 0 && parent_depth == 0 && ((current_char == '-' && next_char == '>') || (current_char == ':' && next_char == ':'))
+			call add(methodstack, current_part)
+			let current_part = ''
+			let i += 2
+			continue
+		endif
+
+		" if it's looks like a string
+		if current_char == "'" || current_char == '"'
+			" and it is not escaped
+			if prev_char != '\' || (prev_char == '\' && prev_prev_char == '\')
+				" and we are in a string already
+				if in_string
+					" and that string started with this char too
+					if current_char == string_start
+						" clear the string mark
+						let in_string = 0
+					endif
+				else " ... and we are not in a string
+					" set the string mark
+					let in_string = 1
+					let string_start = current_char
+				endif
+			endif
+		endif
+
+		if !in_string && a:line[i] == '('
+			let parent_depth += 1
+		endif
+		if !in_string && a:line[i] == ')'
+			let parent_depth -= 1
+		endif
+
+		let current_part .= current_char
+		let i += 1
+	endwhile
+
+	" add the last remaining part, this can be an empty string and this is expected
+	" the empty string represents the completion base (which happen to be an empty string)
+	if current_part != ''
+		call add(methodstack, current_part)
+	endif
+
+	return methodstack
+endfunction
+" }}}
+
+function! phpcomplete#GetClassName(start_line, context, current_namespace, imports) " {{{
+	" Get class name
+	" Class name can be detected in few ways:
+	" @var $myVar class
+	" @var class $myVar
+	" in the same line (php 5.4 (new Class)-> syntax)
+	" line above
+	" or line in tags file
+
+	let class_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
+	let function_name_pattern = '[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*'
+	let function_invocation_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*('
+	let variable_name_pattern = '\$[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
+
+	let classname_candidate = ''
+	let class_candidate_namespace = a:current_namespace
+	let class_candidate_imports = a:imports
+	let methodstack = phpcomplete#GetMethodStack(a:context)
+
+	if a:context =~? '\$this->' || a:context =~? '\(self\|static\)::' || a:context =~? 'parent::'
+		let i = 1
+		while i < a:start_line
+			let line = getline(a:start_line - i)
+
+			" Don't complete self:: or $this if outside of a class
+			" (assumes correct indenting)
+			if line =~ '^}'
+				return ''
+			endif
+
+			if line =~? '\v^\s*(abstract\s+|final\s+)*\s*class'
+				let class_name = matchstr(line, '\c\s*class\s*\zs'.class_name_pattern.'\ze')
+				let extended_class = matchstr(line, '\cclass\s\+'.class_name_pattern.'\s\+extends\s\+\zs'.class_name_pattern.'\ze')
+
+				let classname_candidate = a:context =~? 'parent::' ? extended_class : class_name
+			else
+				let i += 1
+				continue
+			endif
+
+			if classname_candidate != ''
+				let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
+				" return absolute classname, without leading \
+				return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
+			endif
+		endwhile
+	elseif a:context =~? '(\s*new\s\+'.class_name_pattern.'\s*)->'
+		let classname_candidate = matchstr(a:context, '\cnew\s\+\zs'.class_name_pattern.'\ze')
+		let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
+		" return absolute classname, without leading \
+		return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
+	elseif get(methodstack, 0) =~# function_invocation_pattern
+		let function_name = matchstr(methodstack[0], '^\s*\zs'.function_name_pattern)
+		let function_file = phpcomplete#GetFunctionLocation(function_name, a:current_namespace)
+
+		if function_file == 'VIMPHP_BUILTINFUNCTION'
+			" built in function, grab the return type from the info string
+			let return_type = matchstr(g:php_builtin_functions[function_name.'('], '\v\|\s+\zs.+$')
+			let classname_candidate = return_type
+			let class_candidate_namespace = '\'
+		elseif function_file != '' && filereadable(function_file)
+			let file_lines = readfile(function_file)
+			let docblock_str = phpcomplete#GetDocBlock(file_lines, 'function\s*&\?\<'.function_name.'\>')
+			let docblock = phpcomplete#ParseDocBlock(docblock_str)
+			if has_key(docblock.return, 'type')
+				let classname_candidate = docblock.return.type
+				let [class_candidate_namespace, function_imports] = phpcomplete#GetCurrentNameSpace(file_lines)
+				" try to expand the classname of the returned type with the context got from the function's source file
+
+				let [classname_candidate, unused] = phpcomplete#ExpandClassName(classname_candidate, class_candidate_namespace, function_imports)
+			endif
+		endif
+		if classname_candidate != ''
+			let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
+			" return absolute classname, without leading \
+			return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
+		endif
+	else
+		" extract the variable name from the context
+		let object = methodstack[0]
+		let object_is_array = (object =~ '\v^[^[]+\[' ? 1 : 0)
+		let object = matchstr(object, variable_name_pattern)
+
+		let function_boundary = phpcomplete#GetCurrentFunctionBoundaries()
+		let search_end_line = max([1, function_boundary[0][0]])
+		" -1 makes us ignore the current line (where the completion was invoked
+		let lines = reverse(getline(search_end_line, line('.') - 1))
+
+		" check Constant lookup
+		let constant_object = matchstr(a:context, '\zs'.class_name_pattern.'\ze::')
+		if constant_object != ''
+			let classname_candidate = constant_object
+		endif
+
+		if classname_candidate == ''
+			" scan the file backwards from current line for explicit type declaration (@var $variable Classname)
+			for line in lines
+				" in file lookup for /* @var $foo Class */
+				if line =~# '@var\s\+'.object.'\s\+'.class_name_pattern
+					let classname_candidate = matchstr(line, '@var\s\+'.object.'\s\+\zs'.class_name_pattern.'\(\[\]\)\?')
+					let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
+					break
+				endif
+				" in file lookup for /* @var Class $foo */
+				if line =~# '@var\s\+'.class_name_pattern.'\s\+'.object
+					let classname_candidate = matchstr(line, '@var\s\+\zs'.class_name_pattern.'\(\[\]\)\?\ze'.'\s\+'.object)
+					let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
+					break
+				endif
+			endfor
+		endif
+
+		if classname_candidate != ''
+			let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
+			" return absolute classname, without leading \
+			return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
+		endif
+		" scan the file backwards from the current line
+		let i = 1
+		for line in lines " {{{
+			" do in-file lookup of $var = new Class
+			if line =~# '^\s*'.object.'\s*=\s*new\s\+'.class_name_pattern && !object_is_array
+				let classname_candidate = matchstr(line, object.'\c\s*=\s*new\s*\zs'.class_name_pattern.'\ze')
+				let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
+				break
+			endif
+
+			" in-file lookup for Class::getInstance()
+			if line =~# '^\s*'.object.'\s*=&\?\s*'.class_name_pattern.'\s*::\s*getInstance' && !object_is_array
+				let classname_candidate = matchstr(line, object.'\s*=&\?\s*\zs'.class_name_pattern.'\ze\s*::\s*getInstance')
+				let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
+				break
+			endif
+
+			" do in-file lookup for static method invocation of a built-in class, like: $d = DateTime::createFromFormat()
+			if line =~# '^\s*'.object.'\s*=&\?\s*'.class_name_pattern.'\s*::\s*$\?[a-zA-Z_0-9\x7f-\xff]\+'
+				let classname  = matchstr(line, '^\s*'.object.'\s*=&\?\s*\zs'.class_name_pattern.'\ze\s*::')
+				if has_key(a:imports, classname) && a:imports[classname].kind == 'c'
+					let classname = a:imports[classname].name
+				endif
+				if has_key(g:php_builtin_classes, tolower(classname))
+					let sub_methodstack = phpcomplete#GetMethodStack(matchstr(line, '^\s*'.object.'\s*=&\?\s*\s\+\zs.*'))
+					let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname, '\', {}, sub_methodstack)
+					return classname_candidate
+				else
+					" try to get the class name from the static method's docblock
+					let [classname, namespace_for_class] = phpcomplete#ExpandClassName(classname, a:current_namespace, a:imports)
+					let sub_methodstack = phpcomplete#GetMethodStack(matchstr(line, '^\s*'.object.'\s*=&\?\s*\s\+\zs.*'))
+					let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(
+						\ classname,
+						\ a:current_namespace,
+						\ a:imports,
+						\ sub_methodstack)
+					return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
+				endif
+			endif
+
+			" in-file lookup for typehinted function arguments
+			"   - the function can have a name or be anonymous (e.g., function qux() { ... } vs. function () { ... })
+			"   - the type-hinted argument can be anywhere in the arguments list.
+			if line =~? 'function\(\s\+'.function_name_pattern.'\)\?\s*(.\{-}'.class_name_pattern.'\s\+'.object && !object_is_array
+				let f_args = matchstr(line, '\cfunction\(\s\+'.function_name_pattern.'\)\?\s*(\zs.\{-}\ze)')
+				let args = split(f_args, '\s*\zs,\ze\s*')
+				for arg in args
+					if arg =~# object.'\(,\|$\)'
+						let classname_candidate = matchstr(arg, '\s*\zs'.class_name_pattern.'\ze\s\+'.object)
+						let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
+						break
+					endif
+				endfor
+				if classname_candidate != ''
+					break
+				endif
+			endif
+
+			" if we see a function declaration, try loading the docblock for it and look for matching @params
+			if line =~? 'function\(\s\+'.function_name_pattern.'\)\?\s*(.\{-}'.object
+				let match_line = substitute(line, '\\', '\\\\', 'g')
+				let sccontent = getline(0, a:start_line - i)
+				let doc_str = phpcomplete#GetDocBlock(sccontent, match_line)
+				if doc_str != ''
+					let docblock = phpcomplete#ParseDocBlock(doc_str)
+					for param in docblock.params
+						if param.name =~? object
+							let classname_candidate = matchstr(param.type, class_name_pattern.'\(\[\]\)\?')
+							let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
+							break
+						endif
+					endfor
+					if classname_candidate != ''
+						break
+					endif
+				endif
+			endif
+
+			" assignment for the variable in question with a variable on the right hand side
+			if line =~# '^\s*'.object.'\s*=&\?\s*'.variable_name_pattern
+				let tailing_semicolon = match(line, ';\s*$')
+				let tailing_semicolon = tailing_semicolon != -1 ? tailing_semicolon : strlen(getline(a:start_line - i))
+				let prev_context = phpcomplete#GetCurrentInstruction(a:start_line - i, tailing_semicolon - 1, b:phpbegin)
+				let prev_class = phpcomplete#GetClassName(a:start_line - i, prev_context, a:current_namespace, a:imports)
+
+				if stridx(prev_class, '\') != -1
+					let classname_parts = split(prev_class, '\\\+')
+					let classname_candidate = classname_parts[-1]
+					let class_candidate_namespace = join(classname_parts[0:-2], '\')
+				else
+					let classname_candidate = prev_class
+					let class_candidate_namespace = '\'
+				endif
+				break
+			endif
+
+			" assignment for the variable in question with a function on the right hand side
+			if line =~# '^\s*'.object.'\s*=&\?\s*'.function_invocation_pattern
+				let tailing_semicolon = match(line, ';\s*$')
+				let tailing_semicolon = tailing_semicolon != -1 ? tailing_semicolon : strlen(getline(a:start_line - i))
+				let prev_context = phpcomplete#GetCurrentInstruction(a:start_line - i, tailing_semicolon - 1, b:phpbegin)
+
+				let function_name = matchstr(prev_context, '^'.function_invocation_pattern.'\ze')
+				let function_name = matchstr(function_name, '^\zs.\+\ze\s*($') " strip the trailing (
+				let [function_name, function_namespace] = phpcomplete#ExpandClassName(function_name, a:current_namespace, a:imports)
+
+				let function_file = phpcomplete#GetFunctionLocation(function_name, function_namespace)
+
+				if function_file == 'VIMPHP_BUILTINFUNCTION'
+					" built in function, grab the return type from the info string
+					let return_type = matchstr(g:php_builtin_functions[function_name.'('], '\v\|\s+\zs.+$')
+					let classname_candidate = return_type
+					let class_candidate_namespace = '\'
+					break
+				elseif function_file != '' && filereadable(function_file)
+					let file_lines = readfile(function_file)
+					let docblock_str = phpcomplete#GetDocBlock(file_lines, 'function\s*&\?\<'.function_name.'\>')
+					let docblock = phpcomplete#ParseDocBlock(docblock_str)
+					if has_key(docblock.return, 'type')
+						let classname_candidate = docblock.return.type
+						let [class_candidate_namespace, function_imports] = phpcomplete#GetCurrentNameSpace(file_lines)
+						" try to expand the classname of the returned type with the context got from the function's source file
+						let [classname_candidate, unused] = phpcomplete#ExpandClassName(classname_candidate, class_candidate_namespace, function_imports)
+						break
+					endif
+				endif
+			endif
+
+			" foreach with the variable in question
+			if line =~? 'foreach\s*(.\{-}\s\+'.object.'\s*)'
+				let sub_context = matchstr(line, 'foreach\s*(\s*\zs.\{-}\ze\s\+as')
+				let prev_class = phpcomplete#GetClassName(a:start_line - i, sub_context, a:current_namespace, a:imports)
+
+				" the iterated expression should return an array type
+				if prev_class =~ '\[\]$'
+					let prev_class = matchstr(prev_class, '\v^[^[]+')
+				else
+					return
+				endif
+
+				if stridx(prev_class, '\') != -1
+					let classname_parts = split(prev_class, '\\\+')
+					let classname_candidate = classname_parts[-1]
+					let class_candidate_namespace = join(classname_parts[0:-2], '\')
+				else
+					let classname_candidate = prev_class
+					let class_candidate_namespace = '\'
+				endif
+				break
+			endif
+
+			" catch clause with the variable in question
+			if line =~? 'catch\s*(\zs'.class_name_pattern.'\ze\s\+'.object
+				let classname = matchstr(line, 'catch\s*(\zs'.class_name_pattern.'\ze\s\+'.object)
+				if stridx(classname, '\') != -1
+					let classname_parts = split(classname, '\\\+')
+					let classname_candidate = classname_parts[-1]
+					let class_candidate_namespace = join(classname_parts[0:-2], '\')
+				else
+					let classname_candidate = classname
+					let class_candidate_namespace = '\'
+				endif
+				break
+			endif
+
+			let i += 1
+		endfor " }}}
+
+		if classname_candidate != ''
+			let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
+			" return absolute classname, without leading \
+			return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
+		endif
+
+		" OK, first way failed, now check tags file(s)
+		" This method is useless when local variables are not indexed by ctags and
+		" pretty inaccurate even if it is
+		if g:phpcomplete_search_tags_for_variables
+			let tags = phpcomplete#GetTaglist('^'.substitute(object, '^\$', '', ''))
+			if len(tags) == 0
+				return
+			else
+				for tag in tags
+					if tag.kind ==? 'v' && tag.cmd =~? '=\s*new\s\+\zs'.class_name_pattern.'\ze'
+						let classname = matchstr(tag.cmd, '=\s*new\s\+\zs'.class_name_pattern.'\ze')
+						return classname
+					endif
+				endfor
+			endif
+		endif
+	endif
+endfunction
+" }}}
+
+function! phpcomplete#GetClassLocation(classname, namespace) " {{{
+	" Check classname may be name of built in object
+	if has_key(g:php_builtin_classes, tolower(a:classname)) && (a:namespace == '' || a:namespace == '\')
+		return 'VIMPHP_BUILTINOBJECT'
+	endif
+
+	if a:namespace == '' || a:namespace == '\'
+		let search_namespace = '\'
+	else
+		let search_namespace = tolower(a:namespace)
+	endif
+	let [current_namespace, imports] = phpcomplete#GetCurrentNameSpace(getline(0, line('.')))
+
+	" do in-file lookup for class definition
+	let i = 1
+	while i < line('.')
+		let line = getline(line('.')-i)
+		if line =~? '^\s*\(abstract\s\+\|final\s\+\)*\s*class\s*'.a:classname.'\(\s\+\|$\)' && tolower(current_namespace) == search_namespace
+			return expand('%:p')
+		else
+			let i += 1
+			continue
+		endif
+	endwhile
+
+	" Get class location from tags
+	let no_namespace_candidate = ''
+	let tags = phpcomplete#GetTaglist('^'.a:classname.'$')
+	for tag in tags
+		if tag.kind == 'c' || tag.kind == 'i'
+			if !has_key(tag, 'namespace')
+				let no_namespace_candidate = tag.filename
+			else
+				if search_namespace == tolower(tag.namespace)
+					return tag.filename
+				endif
+			endif
+		endif
+	endfor
+	if no_namespace_candidate != ''
+		return no_namespace_candidate
+	endif
+
+	return ''
+endfunction
+" }}}
+
+function! phpcomplete#GetFunctionLocation(function_name, namespace) " {{{
+	" builtin functions doesn't need explicit \ in front of them even in namespaces,
+	" aliased built-in function names are not handled
+	if has_key(g:php_builtin_functions, a:function_name.'(')
+		return 'VIMPHP_BUILTINFUNCTION'
+	endif
+
+
+	" do in-file lookup for function definition
+	let i = 1
+	let buffer_lines = getline(1, line('$'))
+	for line in buffer_lines
+		if line =~? '^\s*function\s\+&\?'.a:function_name.'\s*('
+			return expand('%:p')
+		endif
+	endfor
+
+
+	if a:namespace == '' || a:namespace == '\'
+		let search_namespace = '\'
+	else
+		let search_namespace = tolower(a:namespace)
+	endif
+	let no_namespace_candidate = ''
+	let tags = phpcomplete#GetTaglist('\c^'.a:function_name.'$')
+
+	for tag in tags
+		if tag.kind == 'f'
+			if !has_key(tag, 'namespace')
+				let no_namespace_candidate = tag.filename
+			else
+				if search_namespace == tolower(tag.namespace)
+					return tag.filename
+				endif
+			endif
+		endif
+	endfor
+	if no_namespace_candidate != ''
+		return no_namespace_candidate
+	endif
+
+	return ''
+endfunction
+" }}}
+
+function! phpcomplete#GetCachedClassContents(classlocation, class_name) " {{{
+	let full_file_path = fnamemodify(a:classlocation, ':p')
+	let cache_key = full_file_path.'#'.a:class_name.'#'.getftime(full_file_path)
+
+	" try to read from the cache first
+	if has_key(s:cache_classstructures, cache_key)
+		let classcontents = s:cache_classstructures[cache_key]
+		" cached class contents can contain content from multiple files (superclasses) so we have to
+		" validate cached result's validness by the filemtimes used to create the cached value
+		let valid = 1
+		for classstructure in classcontents
+			if getftime(classstructure.file) != classstructure.mtime
+				let valid = 0
+				" we could break here, but the time required for checking probably worth
+				" the the memory we can free by checking every file in the cached hirearchy
+				call phpcomplete#ClearCachedClassContents(classstructure.file)
+			endif
+		endfor
+
+		if valid
+			" cache hit, we found an entry for this file + class pair and every
+			" file in the response is also valid
+			return classcontents
+		else
+			" clear the outdated cached value from the cache store
+			call remove(s:cache_classstructures, cache_key)
+			call phpcomplete#ClearCachedClassContents(full_file_path)
+
+			" fall trough for the read from files path
+		endif
+	else
+		call phpcomplete#ClearCachedClassContents(full_file_path)
+	endif
+
+	" cache miss, fetch the content from the files itself
+	let classfile = readfile(a:classlocation)
+	let classcontents = phpcomplete#GetClassContentsStructure(full_file_path, classfile, a:class_name)
+	let s:cache_classstructures[cache_key] = classcontents
+
+	return classcontents
+endfunction " }}}
+
+function! phpcomplete#ClearCachedClassContents(full_file_path) " {{{
+	for [cache_key, cached_value] in items(s:cache_classstructures)
+		if stridx(cache_key, a:full_file_path.'#') == 0
+			call remove(s:cache_classstructures, cache_key)
+		endif
+	endfor
+endfunction " }}}
+
+function! phpcomplete#GetClassContentsStructure(file_path, file_lines, class_name) " {{{
+	" returns dictionary containing content, namespace and imports for the class and all parent classes.
+	" Example:
+	" [
+	"	{
+	"		class: 'foo',
+	"		content: '... class foo extends bar ... ',
+	"		namespace: 'NS\Foo',
+	"		imports : { ... },
+	"		file: '/foo.php',
+	"		mtime: 42,
+	"	},
+	"	{
+	"		class: 'bar',
+	"		content: '... class bar extends baz ... ',
+	"		namespace: 'NS\Bar',
+	"		imports : { ... }
+	"		file: '/bar.php',
+	"		mtime: 42,
+	"	},
+	"	...
+	" ]
+	"
+	let full_file_path = fnamemodify(a:file_path, ':p')
+	let class_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
+	let cfile = join(a:file_lines, "\n")
+	let result = []
+	" We use new buffer and (later) normal! because
+	" this is the most efficient way. The other way
+	" is to go through the looong string looking for
+	" matching {}
+
+	" remember the window we started at
+	let phpcomplete_original_window = winnr()
+
+	silent! below 1new
+	silent! 0put =cfile
+	call search('\(class\|interface\)\_s\+'.a:class_name.'\(\>\|$\)')
+	let cfline = line('.')
+	call search('{')
+	let endline = line('.')
+
+	let content = join(getline(cfline, endline), "\n")
+	" Catch extends
+	if content =~? 'extends'
+		let extends_class = matchstr(content, 'class\_s\+'.a:class_name.'\_s\+extends\_s\+\zs'.class_name_pattern.'\ze')
+	else
+		let extends_class = ''
+	endif
+	call searchpair('{', '', '}', 'W')
+	let classcontent = join(getline(cfline, line('.')), "\n")
+	silent! bw! %
+	let [current_namespace, imports] = phpcomplete#GetCurrentNameSpace(a:file_lines[0:cfline])
+	" go back to original window
+	exe phpcomplete_original_window.'wincmd w'
+	call add(result, {
+				\ 'class': a:class_name,
+				\ 'content': classcontent,
+				\ 'namespace': current_namespace,
+				\ 'imports': imports,
+				\ 'file': full_file_path,
+				\ 'mtime': getftime(full_file_path),
+				\ })
+
+	if extends_class != ''
+		let [extends_class, namespace] = phpcomplete#ExpandClassName(extends_class, current_namespace, imports)
+		if namespace == ''
+			let namespace = '\'
+		endif
+		let classlocation = phpcomplete#GetClassLocation(extends_class, namespace)
+		if classlocation == "VIMPHP_BUILTINOBJECT"
+			let result += [phpcomplete#GenerateBuiltinClassStub(g:php_builtin_classes[tolower(extends_class)])]
+		elseif classlocation != '' && filereadable(classlocation)
+			let full_file_path = fnamemodify(classlocation, ':p')
+			let result += phpcomplete#GetClassContentsStructure(full_file_path, readfile(full_file_path), extends_class)
+		elseif tolower(current_namespace) == tolower(namespace)
+			" try to find the declaration in the same file.
+			let result += phpcomplete#GetClassContentsStructure(full_file_path, a:file_lines, extends_class)
+		endif
+	endif
+
+	return result
+endfunction
+" }}}
+
+function! phpcomplete#GetClassContents(classlocation, class_name) " {{{
+	let classcontents = phpcomplete#GetCachedClassContents(a:classlocation, a:class_name)
+	let result = []
+	for classstructure in classcontents
+		call add(result, classstructure.content)
+	endfor
+	return join(result, "\n")
+endfunction
+" }}}
+
+function! phpcomplete#GenerateBuiltinClassStub(class_info) " {{{
+	let re = 'class '.a:class_info['name']." {"
+	for [name, initializer] in items(a:class_info.constants)
+		let re .= "\n\tconst ".name." = ".initializer.";"
+	endfor
+	for [name, info] in items(a:class_info.properties)
+		let re .= "\n\t// @var $".name." ".info.type
+		let re .= "\n\tpublic $".name.";"
+	endfor
+	for [name, info] in items(a:class_info.static_properties)
+		let re .= "\n\t// @var ".name." ".info.type
+		let re .= "\n\tpublic static ".name." = ".info.initializer.";"
+	endfor
+	for [name, info] in items(a:class_info.methods)
+		if name =~ '^__'
+			continue
+		endif
+		let re .= "\n\t/**"
+		let re .= "\n\t * ".name
+		let re .= "\n\t *"
+		let re .= "\n\t * @return ".info.return_type
+		let re .= "\n\t */"
+		let re .= "\n\tpublic function ".name."(".info.signature."){"
+		let re .= "\n\t}"
+	endfor
+	for [name, info] in items(a:class_info.static_methods)
+		let re .= "\n\t/**"
+		let re .= "\n\t * ".name
+		let re .= "\n\t *"
+		let re .= "\n\t * @return ".info.return_type
+		let re .= "\n\t */"
+		let re .= "\n\tpublic static function ".name."(".info.signature."){"
+		let re .= "\n\t}"
+	endfor
+	let re .= "\n}"
+
+	return { 'class': a:class_info['name'],
+				\ 'content': re,
+				\ 'namespace': '',
+				\ 'imports': {},
+				\ 'file': 'VIMPHP_BUILTINOBJECT',
+				\ 'mtime': 0,
+				\ }
+endfunction " }}}
+
+function! phpcomplete#GetDocBlock(sccontent, search) " {{{
+	let i = 0
+	let l = 0
+	let comment_start = -1
+	let comment_end = -1
+	let sccontent_len = len(a:sccontent)
+
+	while (i < sccontent_len)
+		let line = a:sccontent[i]
+		" search for a function declaration
+		if line =~? a:search
+			let l = i - 1
+			" start backward serch for the comment block
+			while l != 0
+				let line = a:sccontent[l]
+				" if comment end found save line position and end search
+				if line =~? '^\s*\*/'
+					let comment_end = l
+					break
+				" ... or the line doesn't blank (only whitespace or nothing) end search
+				elseif line !~? '^\s*$'
+					break
+				endif
+				let l -= 1
+			endwhile
+			" no comment found
+			if comment_end == -1
+				return ''
+			end
+
+			while l != 0
+				let line = a:sccontent[l]
+				if line =~? '^\s*/\*\*'
+					let comment_start = l
+					break
+				endif
+				let l -= 1
+			endwhile
+			" no docblock comment start found
+			if comment_start == -1
+				return ''
+			end
+
+			let comment_start += 1 " we dont need the /**
+			let comment_end   -= 1 " we dont need the */
+
+			" remove leading whitespace and '*'s
+			let docblock = join(map(copy(a:sccontent[comment_start :comment_end]), 'substitute(v:val, "^\\s*\\*\\s*", "", "")'), "\n")
+			return docblock
+		endif
+		let i += 1
+	endwhile
+	return ''
+endfunction
+" }}}
+
+function! phpcomplete#ParseDocBlock(docblock) " {{{
+	let res = {
+		\ 'description': '',
+		\ 'params': [],
+		\ 'return': {},
+		\ 'throws': [],
+		\ 'var': {},
+		\ }
+
+	let res.description = substitute(matchstr(a:docblock, '\zs\_.\{-}\ze\(@var\|@param\|@return\|$\)'), '\(^\_s*\|\_s*$\)', '', 'g')
+	let docblock_lines = split(a:docblock, "\n")
+
+	let param_lines = filter(copy(docblock_lines), 'v:val =~? "^@param"')
+	for param_line in param_lines
+		let parts = matchlist(param_line, '@param\s\+\(\S\+\)\s\+\(\S\+\)\s*\(.*\)')
+		if len(parts) > 0
+			call add(res.params, {
+						\ 'line': parts[0],
+						\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(parts, 1, '')),
+						\ 'name': get(parts, 2, ''),
+						\ 'description': get(parts, 3, '')})
+		endif
+	endfor
+
+	let return_line = filter(copy(docblock_lines), 'v:val =~? "^@return"')
+	if len(return_line) > 0
+		let return_parts = matchlist(return_line[0], '@return\s\+\(\S\+\)\s*\(.*\)')
+		let res['return'] = {
+					\ 'line': return_parts[0],
+					\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(return_parts, 1, '')),
+					\ 'description': get(return_parts, 2, '')}
+	endif
+
+	let exception_lines = filter(copy(docblock_lines), 'v:val =~? "^\\(@throws\\|@exception\\)"')
+	for exception_line in exception_lines
+		let parts = matchlist(exception_line, '^\(@throws\|@exception\)\s\+\(\S\+\)\s*\(.*\)')
+		if len(parts) > 0
+			call add(res.throws, {
+						\ 'line': parts[0],
+						\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(parts, 2, '')),
+						\ 'description': get(parts, 3, '')})
+		endif
+	endfor
+
+	let var_line = filter(copy(docblock_lines), 'v:val =~? "^@var"')
+	if len(var_line) > 0
+		let var_parts = matchlist(var_line[0], '@var\s\+\(\S\+\)\s*\(.*\)')
+		let res['var'] = {
+					\ 'line': var_parts[0],
+					\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(var_parts, 1, '')),
+					\ 'description': get(var_parts, 2, '')}
+	endif
+
+	return res
+endfunction
+" }}}
+
+function! phpcomplete#GetTypeFromDocBlockParam(docblock_type) " {{{
+	if a:docblock_type !~ '|'
+		return a:docblock_type
+	endif
+
+	let primitive_types = [
+				\ 'string', 'float', 'double', 'int',
+				\ 'scalar', 'array', 'bool', 'void', 'mixed',
+				\ 'null', 'callable', 'resource', 'object']
+
+	" add array of primitives to the list too, like string[]
+	let primitive_types += map(copy(primitive_types), 'v:val."[]"')
+	let types = split(a:docblock_type, '|')
+	for type in types
+		if index(primitive_types, type) == -1
+			return type
+		endif
+	endfor
+
+	" only primitive types found, return the first one
+	return types[0]
+
+endfunction
+" }}}
+
+function! phpcomplete#FormatDocBlock(info) " {{{
+	let res = ''
+	if len(a:info.description)
+		let res .= "Description:\n".join(map(split(a:info['description'], "\n"), '"\t".v:val'), "\n")."\n"
+	endif
+
+	if len(a:info.params)
+		let res .= "\nArguments:\n"
+		for arginfo in a:info.params
+			let res .= "\t".arginfo['name'].' '.arginfo['type']
+			if len(arginfo.description) > 0
+				let res .= ': '.arginfo['description']
+			endif
+			let res .= "\n"
+		endfor
+	endif
+
+	if has_key(a:info.return, 'type')
+		let res .= "\nReturn:\n\t".a:info['return']['type']
+		if len(a:info.return.description) > 0
+			let res .= ": ".a:info['return']['description']
+		endif
+		let res .= "\n"
+	endif
+
+	if len(a:info.throws)
+		let res .= "\nThrows:\n"
+		for excinfo in a:info.throws
+			let res .= "\t".excinfo['type']
+			if len(excinfo['description']) > 0
+				let res .= ": ".excinfo['description']
+			endif
+			let res .= "\n"
+		endfor
+	endif
+
+	if has_key(a:info.var, 'type')
+		let res .= "Type:\n\t".a:info['var']['type']."\n"
+		if len(a:info['var']['description']) > 0
+			let res .= ': '.a:info['var']['description']
+		endif
+	endif
+
+	return res
+endfunction!
+" }}}
+
+function! phpcomplete#GetCurrentNameSpace(file_lines) " {{{
+	let namespace_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
+	let file_lines = reverse(copy(a:file_lines))
+	let i = 0
+	let file_length = len(file_lines)
+	let imports = {}
+
+	let current_namespace = '\'
+
+	while i < file_length
+		let line = file_lines[i]
+
+		if line =~? '^\s*namespace\s*'.namespace_name_pattern
+			let current_namespace = matchstr(line, '^\s*namespace\s*\zs'.namespace_name_pattern.'\ze')
+			break
+		endif
+
+		if line =~? '^\s*use\>'
+			if line =~? ';'
+				let use_line = line
+			else
+				" try to find the next line containing ';'
+				let l = i
+				let search_line = line
+				let use_line = line
+
+				" add lines from the file until theres no ';' in them
+				while search_line !~? ';' && l > 0
+					" file lines are reversed so we need to go backwards
+					let l -= 1
+					let search_line = file_lines[l]
+					let use_line .= ' '.substitute(search_line, '\(^\s\+\|\s\+$\)', '', 'g')
+				endwhile
+			endif
+			let use_expression = matchstr(use_line, '^\s*use\s\+\zs.\{-}\ze;')
+			let use_parts = map(split(use_expression, '\s*,\s*'), 'substitute(v:val, "\\s+", " ", "g")')
+			for part in use_parts
+				if part =~? '\s\+as\s\+'
+					let [object, name] = split(part, '\s\+as\s\+')
+					let object = substitute(object, '^\\', '', '')
+					let name   = substitute(name, '^\\', '', '')
+				else
+					let object = part
+					let name = part
+					let object = substitute(object, '^\\', '', '')
+					let name   = substitute(name, '^\\', '', '')
+					if name =~? '\\'
+						let	name = matchstr(name, '\\\zs[^\\]\+\ze$')
+					endif
+				endif
+				" leading slash is not required use imports are always absolute
+				let imports[name] = {'name': object, 'kind': ''}
+			endfor
+
+			" find kind flags from tags or built in methods for the objects we extracted
+			" they can be either classes, interfaces or namespaces, no other thing is importable in php
+			for [key, import] in items(imports)
+				" if theres a \ in the name we have it's definetly not a built in thing, look for tags
+				if import.name =~ '\\'
+					let patched_ctags_detected = 0
+					let [classname, namespace_for_classes] = phpcomplete#ExpandClassName(import.name, '\', {})
+					let namespace_name_candidate = substitute(import.name, '\\', '\\\\', 'g')
+					" can be a namespace name as is, or can be a tagname at the end with a namespace
+					let tags = phpcomplete#GetTaglist('^\('.namespace_name_candidate.'\|'.classname.'\)$')
+					if len(tags) > 0
+						for tag in tags
+							" if there's a namespace with the name of the import
+							if tag.kind == 'n' && tag.name == import.name
+								call extend(import, tag)
+								let import['builtin'] = 0
+								let patched_ctags_detected = 1
+								break
+							endif
+							" if the name matches with the extracted classname and namespace
+							if (tag.kind == 'c' || tag.kind == 'i') && tag.name == classname
+								if has_key(tag, 'namespace')
+									let patched_ctags_detected = 1
+									if tag.namespace == namespace_for_classes
+										call extend(import, tag)
+										let import['builtin'] = 0
+										break
+									endif
+								elseif !exists('no_namespace_candidate')
+									" save the first namespacless match to be used if no better
+									" candidate found later on
+									let no_namespace_candidate = tag
+								endif
+							endif
+						endfor
+						" there were a namespacless class name match, if we think that the
+						" tags are not generated with patched ctags we will take it as a match
+						if exists('no_namespace_candidate') && !patched_ctags_detected
+							call extend(import, no_namespace_candidate)
+							let import['builtin'] = 0
+						endif
+					else
+						" if no tags are found, extract the namespace from the name
+						let ns = matchstr(import.name, '\c\zs[a-zA-Z0-9\\]\+\ze\\' . name)
+						if len(ns) > 0
+							let import['name'] = name
+							let import['namespace'] = ns
+							let import['builtin'] = 0
+						endif
+					endif
+				else
+					" if no \ in the name, it can be a built in class
+					if has_key(g:php_builtin_classnames, tolower(import.name))
+						let import['kind'] = 'c'
+						let import['builtin'] = 1
+					elseif has_key(g:php_builtin_interfacenames, tolower(import.name))
+						let import['kind'] = 'i'
+						let import['builtin'] = 1
+					else
+						" or can be a tag with exactly matchign name
+						let tags = phpcomplete#GetTaglist('^'.import['name'].'$')
+						for tag in tags
+							" search for the first matchin namespace, class, interface with no namespace
+							if !has_key(tag, 'namespace') && (tag.kind == 'n' || tag.kind == 'c' || tag.kind == 'i')
+								call extend(import, tag)
+								let import['builtin'] = 0
+								break
+							endif
+						endfor
+					endif
+				endif
+				if exists('no_namespace_candidate')
+					unlet no_namespace_candidate
+				endif
+			endfor
+		endif
+		let i += 1
+	endwhile
+	let sorted_imports = {}
+	for name in sort(keys(imports))
+		let sorted_imports[name] = imports[name]
+	endfor
+	return [current_namespace, sorted_imports]
+endfunction
+" }}}
+
+function! phpcomplete#GetCurrentFunctionBoundaries() " {{{
+	let old_cursor_pos = [line('.'), col('.')]
+	let current_line_no = old_cursor_pos[0]
+	let function_pattern = '\c\(.*\%#\)\@!\_^\s*\zs\(abstract\s\+\|final\s\+\|private\s\+\|protected\s\+\|public\s\+\|static\s\+\)*function\_.\{-}(\_.\{-})\_.\{-}{'
+
+	let func_start_pos = searchpos(function_pattern, 'Wbc')
+	if func_start_pos == [0, 0]
+		call cursor(old_cursor_pos[0], old_cursor_pos[1])
+		return 0
+	endif
+
+	" get the line where the function declaration actually started
+	call search('\cfunction\_.\{-}(\_.\{-})\_.\{-}{', 'Wce')
+
+	" get the position of the function block's closing "}"
+	let func_end_pos = searchpairpos('{', '', '}', 'W')
+	if func_end_pos == [0, 0]
+		" there is a function start but no end found, assume that we are in a
+		" function but the user did not typed the closing "}" yet and the
+		" function runs to the end of the file
+		let func_end_pos = [line('$'), len(getline(line('$')))]
+	endif
+
+	" Decho func_start_pos[0].' <= '.current_line_no.' && '.current_line_no.' <= '.func_end_pos[0]
+	if func_start_pos[0] <= current_line_no && current_line_no <= func_end_pos[0]
+		call cursor(old_cursor_pos[0], old_cursor_pos[1])
+		return [func_start_pos, func_end_pos]
+	endif
+
+	call cursor(old_cursor_pos[0], old_cursor_pos[1])
+	return 0
+endfunction
+" }}}
+
+function! phpcomplete#ExpandClassName(classname, current_namespace, imports) " {{{
+	" if there's an imported class, just use that class's information
+	if has_key(a:imports, a:classname) && (a:imports[a:classname].kind == 'c' || a:imports[a:classname].kind == 'i')
+		let namespace = has_key(a:imports[a:classname], 'namespace') ? a:imports[a:classname].namespace : ''
+		return [a:imports[a:classname].name, namespace]
+	endif
+
+	" try to find relative namespace in imports, imported names takes precedence over
+	" current namespace when resolving relative namespaced class names
+	if a:classname !~ '^\' && a:classname =~ '\\'
+		let classname_parts = split(a:classname, '\\\+')
+		if has_key(a:imports, classname_parts[0]) && a:imports[classname_parts[0]].kind == 'n'
+			let classname_parts[0] = a:imports[classname_parts[0]].name
+			let namespace = join(classname_parts[0:-2], '\')
+			let classname = classname_parts[-1]
+			return [classname, namespace]
+		endif
+	endif
+
+	" no imported class or namespace matched, expand with the current namespace
+	let namespace = ''
+	let classname = a:classname
+	" if the classname have namespaces in in or we are in a namespace
+	if a:classname =~ '\\' || (a:current_namespace != '\' && a:current_namespace != '')
+		" add current namespace to the a:classname
+		if a:classname !~ '^\'
+			let classname = a:current_namespace.'\'.substitute(a:classname, '^\\', '', '')
+		else
+			" remove leading \, tag files doesn't have those
+			let classname = substitute(a:classname, '^\\', '', '')
+		endif
+		" split classname to classname and namespace
+		let classname_parts = split(classname, '\\\+')
+		if len(classname_parts) > 1
+			let namespace = join(classname_parts[0:-2], '\')
+			let classname = classname_parts[-1]
+		endif
+	endif
+	return [classname, namespace]
+endfunction
+" }}}
+
+function! phpcomplete#LoadData() " {{{
+" Keywords/reserved words, all other special things
+" Later it is possible to add some help to values, or type of defined variable
+let g:php_keywords={'PHP_SELF':'','argv':'','argc':'','GATEWAY_INTERFACE':'','SERVER_ADDR':'','SERVER_NAME':'','SERVER_SOFTWARE':'','SERVER_PROTOCOL':'','REQUEST_METHOD':'','REQUEST_TIME':'','QUERY_STRING':'','DOCUMENT_ROOT':'','HTTP_ACCEPT':'','HTTP_ACCEPT_CHARSET':'','HTTP_ACCEPT_ENCODING':'','HTTP_ACCEPT_LANGUAGE':'','HTTP_CONNECTION':'','HTTP_POST':'','HTTP_REFERER':'','HTTP_USER_AGENT':'','HTTPS':'','REMOTE_ADDR':'','REMOTE_HOST':'','REMOTE_PORT':'','SCRIPT_FILENAME':'','SERVER_ADMIN':'','SERVER_PORT':'','SERVER_SIGNATURE':'','PATH_TRANSLATED':'','SCRIPT_NAME':'','REQUEST_URI':'','PHP_AUTH_DIGEST':'','PHP_AUTH_USER':'','PHP_AUTH_PW':'','AUTH_TYPE':'','and':'','or':'','xor':'','__FILE__':'','exception':'','__LINE__':'','as':'','break':'','case':'','class':'','const':'','continue':'','declare':'','default':'','do':'','echo':'','else':'','elseif':'','enddeclare':'','endfor':'','endforeach':'','endif':'','endswitch':'','endwhile':'','extends':'','for':'','foreach':'','function':'','global':'','if':'','new':'','static':'','switch':'','use':'','var':'','while':'','final':'','php_user_filter':'','interface':'','implements':'','public':'','private':'','protected':'','abstract':'','clone':'','try':'','catch':'','throw':'','cfunction':'','old_function':'','this':'','INI_USER': '','INI_PERDIR': '','INI_SYSTEM': '','INI_ALL': '','ABDAY_1': '','ABDAY_2': '','ABDAY_3': '','ABDAY_4': '','ABDAY_5': '','ABDAY_6': '','ABDAY_7': '','DAY_1': '','DAY_2': '','DAY_3': '','DAY_4': '','DAY_5': '','DAY_6': '','DAY_7': '','ABMON_1': '','ABMON_2': '','ABMON_3': '','ABMON_4': '','ABMON_5': '','ABMON_6': '','ABMON_7': '','ABMON_8': '','ABMON_9': '','ABMON_10': '','ABMON_11': '','ABMON_12': '','MON_1': '','MON_2': '','MON_3': '','MON_4': '','MON_5': '','MON_6': '','MON_7': '','MON_8': '','MON_9': '','MON_10': '','MON_11': '','MON_12': '','AM_STR': '','D_T_FMT': '','ALT_DIGITS': '',}
+" One giant hash of all built-in function, class, interface and constant grouped by extension
+let php_builtin = {'functions':{},'classes':{},'interfaces':{},'constants':{},}
+let php_builtin['functions']['math']={'abs(':'mixed $number | number','acos(':'float $arg | float','acosh(':'float $arg | float','asin(':'float $arg | float','asinh(':'float $arg | float','atan(':'float $arg | float','atan2(':'float $y, float $x | float','atanh(':'float $arg | float','base_convert(':'string $number, int $frombase, int $tobase | string','bindec(':'string $binary_string | number','ceil(':'float $value | float','cos(':'float $arg | float','cosh(':'float $arg | float','decbin(':'int $number | string','dechex(':'int $number | string','decoct(':'int $number | string','deg2rad(':'float $number | float','exp(':'float $arg | float','expm1(':'float $arg | float','floor(':'float $value | float','fmod(':'float $x, float $y | float','getrandmax(':'void | int','hexdec(':'string $hex_string | number','hypot(':'float $x, float $y | float','is_finite(':'float $val | bool','is_infinite(':'float $val | bool','is_nan(':'float $val | bool','lcg_value(':'void | float','log(':'float $arg [, float $base = M_E] | float','log10(':'float $arg | float','log1p(':'float $number | float','max(':'array $values | mixed','min(':'array $values | mixed','mt_getrandmax(':'void | int','mt_rand(':'void | int','mt_srand(':'[ int $seed] | void','octdec(':'string $octal_string | number','pi(':'void | float','pow(':'number $base, number $exp | number','rad2deg(':'float $number | float','rand(':'void | int','round(':'float $val [, int $precision = 0 [, int $mode = PHP_ROUND_HALF_UP]] | float','sin(':'float $arg | float','sinh(':'float $arg | float','sqrt(':'float $arg | float','srand(':'[ int $seed] | void','tan(':'float $arg | float','tanh(':'float $arg | float',}
+let php_builtin['functions']['strings']={'addcslashes(':'string $str, string $charlist | string','addslashes(':'string $str | string','bin2hex(':'string $str | string','chop(':'chop  Alias of rtrim()','chr(':'int $ascii | string','chunk_split(':'string $body [, int $chunklen = 76 [, string $end = "\r\n"]] | string','convert_cyr_string(':'string $str, string $from, string $to | string','convert_uudecode(':'string $data | string','convert_uuencode(':'string $data | string','count_chars(':'string $string [, int $mode = 0] | mixed','crc32(':'string $str | int','crypt(':'string $str [, string $salt] | string','echo(':'string $arg1 [, string $...] | void','explode(':'string $delimiter, string $string [, int $limit] | array','fprintf(':'resource $handle, string $format [, mixed $args [, mixed $...]] | int','get_html_translation_table(':'[ int $table = HTML_SPECIALCHARS [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'']]] | array','hebrev(':'string $hebrew_text [, int $max_chars_per_line = 0] | string','hebrevc(':'string $hebrew_text [, int $max_chars_per_line = 0] | string','hex2bin(':'string $data | string','html_entity_decode(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'']] | string','htmlentities(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'' [, bool $double_encode = true]]] | string','htmlspecialchars_decode(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401] | string','htmlspecialchars(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'' [, bool $double_encode = true]]] | string','implode(':'string $glue, array $pieces | string','join(':'join  Alias of implode()','lcfirst(':'string $str | string','levenshtein(':'string $str1, string $str2 | int','localeconv(':'void | array','ltrim(':'string $str [, string $character_mask] | string','md5_file(':'string $filename [, bool $raw_output = false] | string','md5(':'string $str [, bool $raw_output = false] | string','metaphone(':'string $str [, int $phonemes = 0] | string','money_format(':'string $format, float $number | string','nl_langinfo(':'int $item | string','nl2br(':'string $string [, bool $is_xhtml = true] | string','number_format(':'float $number [, int $decimals = 0] | string','ord(':'string $string | int','parse_str(':'string $str [, array &$arr] | void','print(':'string $arg | int','printf(':'string $format [, mixed $args [, mixed $...]] | int','quoted_printable_decode(':'string $str | string','quoted_printable_encode(':'string $str | string','quotemeta(':'string $str | string','rtrim(':'string $str [, string $character_mask] | string','setlocale(':'int $category, string $locale [, string $...] | string','sha1_file(':'string $filename [, bool $raw_output = false] | string','sha1(':'string $str [, bool $raw_output = false] | string','similar_text(':'string $first, string $second [, float &$percent] | int','soundex(':'string $str | string','sprintf(':'string $format [, mixed $args [, mixed $...]] | string','sscanf(':'string $str, string $format [, mixed &$...] | mixed','str_getcsv(':'string $input [, string $delimiter = '','' [, string $enclosure = ''"'' [, string $escape = ''\\'']]] | array','str_ireplace(':'mixed $search, mixed $replace, mixed $subject [, int &$count] | mixed','str_pad(':'string $input, int $pad_length [, string $pad_string = " " [, int $pad_type = STR_PAD_RIGHT]] | string','str_repeat(':'string $input, int $multiplier | string','str_replace(':'mixed $search, mixed $replace, mixed $subject [, int &$count] | mixed','str_rot13(':'string $str | string','str_shuffle(':'string $str | string','str_split(':'string $string [, int $split_length = 1] | array','str_word_count(':'string $string [, int $format = 0 [, string $charlist]] | mixed','strcasecmp(':'string $str1, string $str2 | int','strchr(':'strchr  Alias of strstr()','strcmp(':'string $str1, string $str2 | int','strcoll(':'string $str1, string $str2 | int','strcspn(':'string $str1, string $str2 [, int $start [, int $length]] | int','strip_tags(':'string $str [, string $allowable_tags] | string','stripcslashes(':'string $str | string','stripos(':'string $haystack, string $needle [, int $offset = 0] | int','stripslashes(':'string $str | string','stristr(':'string $haystack, mixed $needle [, bool $before_needle = false] | string','strlen(':'string $string | int','strnatcasecmp(':'string $str1, string $str2 | int','strnatcmp(':'string $str1, string $str2 | int','strncasecmp(':'string $str1, string $str2, int $len | int','strncmp(':'string $str1, string $str2, int $len | int','strpbrk(':'string $haystack, string $char_list | string','strpos(':'string $haystack, mixed $needle [, int $offset = 0] | mixed','strrchr(':'string $haystack, mixed $needle | string','strrev(':'string $string | string','strripos(':'string $haystack, string $needle [, int $offset = 0] | int','strrpos(':'string $haystack, string $needle [, int $offset = 0] | int','strspn(':'string $subject, string $mask [, int $start [, int $length]] | int','strstr(':'string $haystack, mixed $needle [, bool $before_needle = false] | string','strtok(':'string $str, string $token | string','strtolower(':'string $str | string','strtoupper(':'string $string | string','strtr(':'string $str, string $from, string $to | string','substr_compare(':'string $main_str, string $str, int $offset [, int $length [, bool $case_insensitivity = false]] | int','substr_count(':'string $haystack, string $needle [, int $offset = 0 [, int $length]] | int','substr_replace(':'mixed $string, mixed $replacement, mixed $start [, mixed $length] | mixed','substr(':'string $string, int $start [, int $length] | string','trim(':'string $str [, string $character_mask = " \t\n\r\0\x0B"] | string','ucfirst(':'string $str | string','ucwords(':'string $str | string','vfprintf(':'resource $handle, string $format, array $args | int','vprintf(':'string $format, array $args | int','vsprintf(':'string $format, array $args | string','wordwrap(':'string $str [, int $width = 75 [, string $break = "\n" [, bool $cut = false]]] | string',}
+let php_builtin['functions']['apache']={'apache_child_terminate(':'void | bool','apache_get_modules(':'void | array','apache_get_version(':'void | string','apache_getenv(':'string $variable [, bool $walk_to_top = false] | string','apache_lookup_uri(':'string $filename | object','apache_note(':'string $note_name [, string $note_value = ""] | string','apache_request_headers(':'void | array','apache_reset_timeout(':'void | bool','apache_response_headers(':'void | array','apache_setenv(':'string $variable, string $value [, bool $walk_to_top = false] | bool','getallheaders(':'void | array','virtual(':'string $filename | bool',}
+let php_builtin['functions']['arrays']={'array_change_key_case(':'array $array [, int $case = CASE_LOWER] | array','array_chunk(':'array $array, int $size [, bool $preserve_keys = false] | array','array_column(':'array $array, mixed $column_key [, mixed $index_key = null] | array','array_combine(':'array $keys, array $values | array','array_count_values(':'array $array | array','array_diff_assoc(':'array $array1, array $array2 [, array $...] | array','array_diff_key(':'array $array1, array $array2 [, array $...] | array','array_diff_uassoc(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_diff_ukey(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_diff(':'array $array1, array $array2 [, array $...] | array','array_fill_keys(':'array $keys, mixed $value | array','array_fill(':'int $start_index, int $num, mixed $value | array','array_filter(':'array $array [, callable $callback] | array','array_flip(':'array $array | array','array_intersect_assoc(':'array $array1, array $array2 [, array $...] | array','array_intersect_key(':'array $array1, array $array2 [, array $...] | array','array_intersect_uassoc(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_intersect_ukey(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_intersect(':'array $array1, array $array2 [, array $...] | array','array_key_exists(':'mixed $key, array $array | bool','array_keys(':'array $array [, mixed $search_value [, bool $strict = false]] | array','array_map(':'callable $callback, array $array1 [, array $...] | array','array_merge_recursive(':'array $array1 [, array $...] | array','array_merge(':'array $array1 [, array $...] | array','array_multisort(':'array &$array1 [, mixed $array1_sort_order = SORT_ASC [, mixed $array1_sort_flags = SORT_REGULAR [, mixed $...]]] | bool','array_pad(':'array $array, int $size, mixed $value | array','array_pop(':'array &$array | mixed','array_product(':'array $array | number','array_push(':'array &$array, mixed $value1 [, mixed $...] | int','array_rand(':'array $array [, int $num = 1] | mixed','array_reduce(':'array $array, callable $callback [, mixed $initial = NULL] | mixed','array_replace_recursive(':'array $array1, array $array2 [, array $...] | array','array_replace(':'array $array1, array $array2 [, array $...] | array','array_reverse(':'array $array [, bool $preserve_keys = false] | array','array_search(':'mixed $needle, array $haystack [, bool $strict = false] | mixed','array_shift(':'array &$array | mixed','array_slice(':'array $array, int $offset [, int $length = NULL [, bool $preserve_keys = false]] | array','array_splice(':'array &$input, int $offset [, int $length [, mixed $replacement = array()]] | array','array_sum(':'array $array | number','array_udiff_assoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_udiff_uassoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func [, callable $key_compare_func]]] | array','array_udiff(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_uintersect_assoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_uintersect_uassoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func [, callable $key_compare_func]]] | array','array_uintersect(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_unique(':'array $array [, int $sort_flags = SORT_STRING] | array','array_unshift(':'array &$array, mixed $value1 [, mixed $...] | int','array_values(':'array $array | array','array_walk_recursive(':'array &$array, callable $callback [, mixed $userdata = NULL] | bool','array_walk(':'array &$array, callable $callback [, mixed $userdata = NULL] | bool','array(':'[ mixed $...] | array','arsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','asort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','compact(':'mixed $varname1 [, mixed $...] | array','count(':'mixed $array_or_countable [, int $mode = COUNT_NORMAL] | int','current(':'array &$array | mixed','each(':'array &$array | array','end(':'array &$array | mixed','extract(':'array &$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL]] | int','in_array(':'mixed $needle, array $haystack [, bool $strict = FALSE] | bool','key_exists(':'key_exists  Alias of array_key_exists()','key(':'array &$array | mixed','krsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','ksort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','list(':'mixed $var1 [, mixed $...] | array','natcasesort(':'array &$array | bool','natsort(':'array &$array | bool','next(':'array &$array | mixed','pos(':'pos  Alias of current()','prev(':'array &$array | mixed','range(':'mixed $start, mixed $end [, number $step = 1] | array','reset(':'array &$array | mixed','rsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','shuffle(':'array &$array | bool','sizeof(':'sizeof  Alias of count()','sort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','uasort(':'array &$array, callable $value_compare_func | bool','uksort(':'array &$array, callable $key_compare_func | bool','usort(':'array &$array, callable $value_compare_func | bool',}
+let php_builtin['functions']['php_options_info']={'assert_options(':'int $what [, mixed $value] | mixed','assert(':'mixed $assertion [, string $description] | bool','cli_get_process_title(':'void | string','cli_set_process_title(':'string $title | bool','dl(':'string $library | bool','extension_loaded(':'string $name | bool','gc_collect_cycles(':'void | int','gc_disable(':'void | void','gc_enable(':'void | void','gc_enabled(':'void | bool','get_cfg_var(':'string $option | string','get_current_user(':'void | string','get_defined_constants(':'[ bool $categorize = false] | array','get_extension_funcs(':'string $module_name | array','get_include_path(':'void | string','get_included_files(':'void | array','get_loaded_extensions(':'[ bool $zend_extensions = false] | array','get_magic_quotes_gpc(':'void | bool','get_magic_quotes_runtime(':'void | bool','get_required_files(':'get_required_files  Alias of get_included_files()','getenv(':'string $varname | string','getlastmod(':'void | int','getmygid(':'void | int','getmyinode(':'void | int','getmypid(':'void | int','getmyuid(':'void | int','getopt(':'string $options [, array $longopts] | array','getrusage(':'[ int $who = 0] | array','ini_alter(':'ini_alter  Alias of ini_set()','ini_get_all(':'[ string $extension [, bool $details = true]] | array','ini_get(':'string $varname | string','ini_restore(':'string $varname | void','ini_set(':'string $varname, string $newvalue | string','magic_quotes_runtime(':'magic_quotes_runtime  Alias of set_magic_quotes_runtime()','memory_get_peak_usage(':'[ bool $real_usage = false] | int','memory_get_usage(':'[ bool $real_usage = false] | int','php_ini_loaded_file(':'void | string','php_ini_scanned_files(':'void | string','php_logo_guid(':'void | string','php_sapi_name(':'void | string','php_uname(':'[ string $mode = "a"] | string','phpcredits(':'[ int $flag = CREDITS_ALL] | bool','phpinfo(':'[ int $what = INFO_ALL] | bool','phpversion(':'[ string $extension] | string','putenv(':'string $setting | bool','restore_include_path(':'void | void','set_include_path(':'string $new_include_path | string','set_magic_quotes_runtime(':'bool $new_setting | bool','set_time_limit(':'int $seconds | void','sys_get_temp_dir(':'void | string','version_compare(':'string $version1, string $version2 [, string $operator] | mixed','zend_logo_guid(':'void | string','zend_thread_id(':'void | int','zend_version(':'void | string',}
+let php_builtin['functions']['classes_objects']={'__autoload(':'string $class | void','call_user_method_array(':'string $method_name, object &$obj, array $params | mixed','call_user_method(':'string $method_name, object &$obj [, mixed $parameter [, mixed $...]] | mixed','class_alias(':'string $original, string $alias [, bool $autoload = TRUE] | bool','class_exists(':'string $class_name [, bool $autoload = true] | bool','get_called_class(':'void | string','get_class_methods(':'mixed $class_name | array','get_class_vars(':'string $class_name | array','get_class(':'[ object $object = NULL] | string','get_declared_classes(':'void | array','get_declared_interfaces(':'void | array','get_declared_traits(':'void | array','get_object_vars(':'object $object | array','get_parent_class(':'[ mixed $object] | string','interface_exists(':'string $interface_name [, bool $autoload = true] | bool','is_a(':'object $object, string $class_name [, bool $allow_string = FALSE] | bool','is_subclass_of(':'mixed $object, string $class_name [, bool $allow_string = TRUE] | bool','method_exists(':'mixed $object, string $method_name | bool','property_exists(':'mixed $class, string $property | bool','trait_exists(':'string $traitname [, bool $autoload] | bool',}
+let php_builtin['functions']['urls']={'base64_decode(':'string $data [, bool $strict = false] | string','base64_encode(':'string $data | string','get_headers(':'string $url [, int $format = 0] | array','get_meta_tags(':'string $filename [, bool $use_include_path = false] | array','http_build_query(':'mixed $query_data [, string $numeric_prefix [, string $arg_separator [, int $enc_type = PHP_QUERY_RFC1738]]] | string','parse_url(':'string $url [, int $component = -1] | mixed','rawurldecode(':'string $str | string','rawurlencode(':'string $str | string','urldecode(':'string $str | string','urlencode(':'string $str | string',}
+let php_builtin['functions']['filesystem']={'basename(':'string $path [, string $suffix] | string','chgrp(':'string $filename, mixed $group | bool','chmod(':'string $filename, int $mode | bool','chown(':'string $filename, mixed $user | bool','clearstatcache(':'[ bool $clear_realpath_cache = false [, string $filename]] | void','copy(':'string $source, string $dest [, resource $context] | bool','dirname(':'string $path | string','disk_free_space(':'string $directory | float','disk_total_space(':'string $directory | float','diskfreespace(':'diskfreespace  Alias of disk_free_space()','fclose(':'resource $handle | bool','feof(':'resource $handle | bool','fflush(':'resource $handle | bool','fgetc(':'resource $handle | string','fgetcsv(':'resource $handle [, int $length = 0 [, string $delimiter = '','' [, string $enclosure = ''"'' [, string $escape = ''\\'']]]] | array','fgets(':'resource $handle [, int $length] | string','fgetss(':'resource $handle [, int $length [, string $allowable_tags]] | string','file_exists(':'string $filename | bool','file_get_contents(':'string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen]]]] | string','file_put_contents(':'string $filename, mixed $data [, int $flags = 0 [, resource $context]] | int','file(':'string $filename [, int $flags = 0 [, resource $context]] | array','fileatime(':'string $filename | int','filectime(':'string $filename | int','filegroup(':'string $filename | int','fileinode(':'string $filename | int','filemtime(':'string $filename | int','fileowner(':'string $filename | int','fileperms(':'string $filename | int','filesize(':'string $filename | int','filetype(':'string $filename | string','flock(':'resource $handle, int $operation [, int &$wouldblock] | bool','fnmatch(':'string $pattern, string $string [, int $flags = 0] | bool','fopen(':'string $filename, string $mode [, bool $use_include_path = false [, resource $context]] | resource','fpassthru(':'resource $handle | int','fputcsv(':'resource $handle, array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','fputs(':'fputs  Alias of fwrite()','fread(':'resource $handle, int $length | string','fscanf(':'resource $handle, string $format [, mixed &$...] | mixed','fseek(':'resource $handle, int $offset [, int $whence = SEEK_SET] | int','fstat(':'resource $handle | array','ftell(':'resource $handle | int','ftruncate(':'resource $handle, int $size | bool','fwrite(':'resource $handle, string $string [, int $length] | int','glob(':'string $pattern [, int $flags = 0] | array','is_dir(':'string $filename | bool','is_executable(':'string $filename | bool','is_file(':'string $filename | bool','is_link(':'string $filename | bool','is_readable(':'string $filename | bool','is_uploaded_file(':'string $filename | bool','is_writable(':'string $filename | bool','is_writeable(':'is_writeable  Alias of is_writable()','lchgrp(':'string $filename, mixed $group | bool','lchown(':'string $filename, mixed $user | bool','link(':'string $target, string $link | bool','linkinfo(':'string $path | int','lstat(':'string $filename | array','mkdir(':'string $pathname [, int $mode = 0777 [, bool $recursive = false [, resource $context]]] | bool','move_uploaded_file(':'string $filename, string $destination | bool','parse_ini_file(':'string $filename [, bool $process_sections = false [, int $scanner_mode = INI_SCANNER_NORMAL]] | array','parse_ini_string(':'string $ini [, bool $process_sections = false [, int $scanner_mode = INI_SCANNER_NORMAL]] | array','pathinfo(':'string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME] | mixed','pclose(':'resource $handle | int','popen(':'string $command, string $mode | resource','readfile(':'string $filename [, bool $use_include_path = false [, resource $context]] | int','readlink(':'string $path | string','realpath_cache_get(':'void | array','realpath_cache_size(':'void | int','realpath(':'string $path | string','rename(':'string $oldname, string $newname [, resource $context] | bool','rewind(':'resource $handle | bool','rmdir(':'string $dirname [, resource $context] | bool','set_file_buffer(':'set_file_buffer  Alias of stream_set_write_buffer()','stat(':'string $filename | array','symlink(':'string $target, string $link | bool','tempnam(':'string $dir, string $prefix | string','tmpfile(':'void | resource','touch(':'string $filename [, int $time = time() [, int $atime]] | bool','umask(':'[ int $mask] | int','unlink(':'string $filename [, resource $context] | bool',}
+let php_builtin['functions']['variable_handling']={'boolval(':'mixed $var | boolean','debug_zval_dump(':'mixed $variable [, mixed $...] | void','doubleval(':'doubleval  Alias of floatval()','empty(':'mixed $var | bool','floatval(':'mixed $var | float','get_defined_vars(':'void | array','get_resource_type(':'resource $handle | string','gettype(':'mixed $var | string','import_request_variables(':'string $types [, string $prefix] | bool','intval(':'mixed $var [, int $base = 10] | int','is_array(':'mixed $var | bool','is_bool(':'mixed $var | bool','is_callable(':'callable $name [, bool $syntax_only = false [, string &$callable_name]] | bool','is_double(':'is_double  Alias of is_float()','is_float(':'mixed $var | bool','is_int(':'mixed $var | bool','is_integer(':'is_integer  Alias of is_int()','is_long(':'is_long  Alias of is_int()','is_null(':'mixed $var | bool','is_numeric(':'mixed $var | bool','is_object(':'mixed $var | bool','is_real(':'is_real  Alias of is_float()','is_resource(':'mixed $var | bool','is_scalar(':'mixed $var | bool','is_string(':'mixed $var | bool','isset(':'mixed $var [, mixed $...] | bool','print_r(':'mixed $expression [, bool $return = false] | mixed','serialize(':'mixed $value | string','settype(':'mixed &$var, string $type | bool','strval(':'mixed $var | string','unserialize(':'string $str | mixed','unset(':'mixed $var [, mixed $...] | void','var_dump(':'mixed $expression [, mixed $...] | void','var_export(':'mixed $expression [, bool $return = false] | mixed',}
+let php_builtin['functions']['calendar']={'cal_days_in_month(':'int $calendar, int $month, int $year | int','cal_from_jd(':'int $jd, int $calendar | array','cal_info(':'[ int $calendar = -1] | array','cal_to_jd(':'int $calendar, int $month, int $day, int $year | int','easter_date(':'[ int $year] | int','easter_days(':'[ int $year [, int $method = CAL_EASTER_DEFAULT]] | int','frenchtojd(':'int $month, int $day, int $year | int','gregoriantojd(':'int $month, int $day, int $year | int','jddayofweek(':'int $julianday [, int $mode = CAL_DOW_DAYNO] | mixed','jdmonthname(':'int $julianday, int $mode | string','jdtofrench(':'int $juliandaycount | string','jdtogregorian(':'int $julianday | string','jdtojewish(':'int $juliandaycount [, bool $hebrew = false [, int $fl = 0]] | string','jdtojulian(':'int $julianday | string','jdtounix(':'int $jday | int','jewishtojd(':'int $month, int $day, int $year | int','juliantojd(':'int $month, int $day, int $year | int','unixtojd(':'[ int $timestamp = time()] | int',}
+let php_builtin['functions']['function_handling']={'call_user_func_array(':'callable $callback, array $param_arr | mixed','call_user_func(':'callable $callback [, mixed $parameter [, mixed $...]] | mixed','create_function(':'string $args, string $code | string','forward_static_call_array(':'callable $function, array $parameters | mixed','forward_static_call(':'callable $function [, mixed $parameter [, mixed $...]] | mixed','func_get_arg(':'int $arg_num | mixed','func_get_args(':'void | array','func_num_args(':'void | int','function_exists(':'string $function_name | bool','get_defined_functions(':'void | array','register_shutdown_function(':'callable $callback [, mixed $parameter [, mixed $...]] | void','register_tick_function(':'callable $function [, mixed $arg [, mixed $...]] | bool','unregister_tick_function(':'string $function_name | void',}
+let php_builtin['functions']['directories']={'chdir(':'string $directory | bool','chroot(':'string $directory | bool','closedir(':'[ resource $dir_handle] | void','dir(':'string $directory [, resource $context] | Directory','getcwd(':'void | string','opendir(':'string $path [, resource $context] | resource','readdir(':'[ resource $dir_handle] | string','rewinddir(':'[ resource $dir_handle] | void','scandir(':'string $directory [, int $sorting_order = SCANDIR_SORT_ASCENDING [, resource $context]] | array',}
+let php_builtin['functions']['date_time']={'checkdate(':'int $month, int $day, int $year | bool','date_default_timezone_get(':'void | string','date_default_timezone_set(':'string $timezone_identifier | bool','date_parse_from_format(':'string $format, string $date | array','date_parse(':'string $date | array','date_sun_info(':'int $time, float $latitude, float $longitude | array','date_sunrise(':'int $timestamp [, int $format = SUNFUNCS_RET_STRING [, float $latitude = ini_get("date.default_latitude") [, float $longitude = ini_get("date.default_longitude") [, float $zenith = ini_get("date.sunrise_zenith") [, float $gmt_offset = 0]]]]] | mixed','date_sunset(':'int $timestamp [, int $format = SUNFUNCS_RET_STRING [, float $latitude = ini_get("date.default_latitude") [, float $longitude = ini_get("date.default_longitude") [, float $zenith = ini_get("date.sunset_zenith") [, float $gmt_offset = 0]]]]] | mixed','date(':'string $format [, int $timestamp = time()] | string','getdate(':'[ int $timestamp = time()] | array','gettimeofday(':'[ bool $return_float = false] | mixed','gmdate(':'string $format [, int $timestamp = time()] | string','gmmktime(':'[ int $hour = gmdate("H") [, int $minute = gmdate("i") [, int $second = gmdate("s") [, int $month = gmdate("n") [, int $day = gmdate("j") [, int $year = gmdate("Y") [, int $is_dst = -1]]]]]]] | int','gmstrftime(':'string $format [, int $timestamp = time()] | string','idate(':'string $format [, int $timestamp = time()] | int','localtime(':'[ int $timestamp = time() [, bool $is_associative = false]] | array','microtime(':'[ bool $get_as_float = false] | mixed','mktime(':'[ int $hour = date("H") [, int $minute = date("i") [, int $second = date("s") [, int $month = date("n") [, int $day = date("j") [, int $year = date("Y") [, int $is_dst = -1]]]]]]] | int','strftime(':'string $format [, int $timestamp = time()] | string','strptime(':'string $date, string $format | array','strtotime(':'string $time [, int $now = time()] | int','time(':'void | int','timezone_name_from_abbr(':'string $abbr [, int $gmtOffset = -1 [, int $isdst = -1]] | string','timezone_version_get(':'void | string',}
+let php_builtin['functions']['network']={'checkdnsrr(':'string $host [, string $type = "MX"] | bool','closelog(':'void | bool','define_syslog_variables(':'void | void','dns_get_record(':'string $hostname [, int $type = DNS_ANY [, array &$authns [, array &$addtl [, bool &$raw = false]]]] | array','fsockopen(':'string $hostname [, int $port = -1 [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout")]]]] | resource','gethostbyaddr(':'string $ip_address | string','gethostbyname(':'string $hostname | string','gethostbynamel(':'string $hostname | array','gethostname(':'void | string','getmxrr(':'string $hostname, array &$mxhosts [, array &$weight] | bool','getprotobyname(':'string $name | int','getprotobynumber(':'int $number | string','getservbyname(':'string $service, string $protocol | int','getservbyport(':'int $port, string $protocol | string','header_register_callback(':'callable $callback | bool','header_remove(':'[ string $name] | void','header(':'string $string [, bool $replace = true [, int $http_response_code]] | void','headers_list(':'void | array','headers_sent(':'[ string &$file [, int &$line]] | bool','http_response_code(':'[ int $response_code] | int','inet_ntop(':'string $in_addr | string','inet_pton(':'string $address | string','ip2long(':'string $ip_address | int','long2ip(':'string $proper_address | string','openlog(':'string $ident, int $option, int $facility | bool','pfsockopen(':'string $hostname [, int $port = -1 [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout")]]]] | resource','setcookie(':'string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]]]] | bool','setrawcookie(':'string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]]]] | bool','socket_get_status(':'socket_get_status  Alias of stream_get_meta_data()','socket_set_blocking(':'socket_set_blocking  Alias of stream_set_blocking()','socket_set_timeout(':'socket_set_timeout  Alias of stream_set_timeout()','syslog(':'int $priority, string $message | bool',}
+let php_builtin['functions']['spl']={'class_implements(':'mixed $class [, bool $autoload = true] | array','class_parents(':'mixed $class [, bool $autoload = true] | array','class_uses(':'mixed $class [, bool $autoload = true] | array','iterator_apply(':'Traversable $iterator, callable $function [, array $args] | int','iterator_count(':'Traversable $iterator | int','iterator_to_array(':'Traversable $iterator [, bool $use_keys = true] | array','spl_autoload_call(':'string $class_name | void','spl_autoload_extensions(':'[ string $file_extensions] | string','spl_autoload_functions(':'void | array','spl_autoload_register(':'[ callable $autoload_function [, bool $throw = true [, bool $prepend = false]]] | bool','spl_autoload_unregister(':'mixed $autoload_function | bool','spl_autoload(':'string $class_name [, string $file_extensions = spl_autoload_extensions()] | void','spl_classes(':'void | array','spl_object_hash(':'object $obj | string',}
+let php_builtin['functions']['misc']={'connection_aborted(':'void | int','connection_status(':'void | int','connection_timeout(':'void | int','constant(':'string $name | mixed','define(':'string $name, mixed $value [, bool $case_insensitive = false] | bool','defined(':'string $name | bool','eval(':'string $code | mixed','exit(':'[ string $status] | void','get_browser(':'[ string $user_agent [, bool $return_array = false]] | mixed','__halt_compiler(':'void | void','highlight_file(':'string $filename [, bool $return = false] | mixed','highlight_string(':'string $str [, bool $return = false] | mixed','ignore_user_abort(':'[ string $value] | int','pack(':'string $format [, mixed $args [, mixed $...]] | string','php_check_syntax(':'string $filename [, string &$error_message] | bool','php_strip_whitespace(':'string $filename | string','show_source(':'show_source  Alias of highlight_file()','sleep(':'int $seconds | int','sys_getloadavg(':'void | array','time_nanosleep(':'int $seconds, int $nanoseconds | mixed','time_sleep_until(':'float $timestamp | bool','uniqid(':'[ string $prefix = "" [, bool $more_entropy = false]] | string','unpack(':'string $format, string $data | array','usleep(':'int $micro_seconds | void',}
+let php_builtin['functions']['curl']={'curl_close(':'resource $ch | void','curl_copy_handle(':'resource $ch | resource','curl_errno(':'resource $ch | int','curl_error(':'resource $ch | string','curl_escape(':'resource $ch, string $str | string','curl_exec(':'resource $ch | mixed','curl_getinfo(':'resource $ch [, int $opt = 0] | mixed','curl_init(':'[ string $url = NULL] | resource','curl_multi_add_handle(':'resource $mh, resource $ch | int','curl_multi_close(':'resource $mh | void','curl_multi_exec(':'resource $mh, int &$still_running | int','curl_multi_getcontent(':'resource $ch | string','curl_multi_info_read(':'resource $mh [, int &$msgs_in_queue = NULL] | array','curl_multi_init(':'void | resource','curl_multi_remove_handle(':'resource $mh, resource $ch | int','curl_multi_select(':'resource $mh [, float $timeout = 1.0] | int','curl_multi_setopt(':'resource $mh, int $option, mixed $value | bool','curl_multi_strerror(':'int $errornum | string','curl_pause(':'resource $ch, int $bitmask | int','curl_reset(':'resource $ch | void','curl_setopt_array(':'resource $ch, array $options | bool','curl_setopt(':'resource $ch, int $option, mixed $value | bool','curl_share_close(':'resource $sh | void','curl_share_init(':'void | resource','curl_share_setopt(':'resource $sh, int $option, string $value | bool','curl_strerror(':'int $errornum | string','curl_unescape(':'resource $ch, string $str | string','curl_version(':'[ int $age = CURLVERSION_NOW] | array',}
+let php_builtin['functions']['error_handling']={'debug_backtrace(':'[ int $options = DEBUG_BACKTRACE_PROVIDE_OBJECT [, int $limit = 0]] | array','debug_print_backtrace(':'[ int $options = 0 [, int $limit = 0]] | void','error_get_last(':'void | array','error_log(':'string $message [, int $message_type = 0 [, string $destination [, string $extra_headers]]] | bool','error_reporting(':'[ int $level] | int','restore_error_handler(':'void | bool','restore_exception_handler(':'void | bool','set_error_handler(':'callable $error_handler [, int $error_types = E_ALL | E_STRICT] | mixed','set_exception_handler(':'callable $exception_handler | callable','trigger_error(':'string $error_msg [, int $error_type = E_USER_NOTICE] | bool',}
+let php_builtin['functions']['dom']={'dom_import_simplexml(':'SimpleXMLElement $node | DOMElement',}
+let php_builtin['functions']['program_execution']={'escapeshellarg(':'string $arg | string','escapeshellcmd(':'string $command | string','exec(':'string $command [, array &$output [, int &$return_var]] | string','passthru(':'string $command [, int &$return_var] | void','proc_close(':'resource $process | int','proc_get_status(':'resource $process | array','proc_nice(':'int $increment | bool','proc_open(':'string $cmd, array $descriptorspec, array &$pipes [, string $cwd [, array $env [, array $other_options]]] | resource','proc_terminate(':'resource $process [, int $signal = 15] | bool','shell_exec(':'string $cmd | string','system(':'string $command [, int &$return_var] | string',}
+let php_builtin['functions']['mail']={'ezmlm_hash(':'string $addr | int','mail(':'string $to, string $subject, string $message [, string $additional_headers [, string $additional_parameters]] | bool',}
+let php_builtin['functions']['fastcgi_process_manager']={'fastcgi_finish_request(':'void | boolean',}
+let php_builtin['functions']['filter']={'filter_has_var(':'int $type, string $variable_name | bool','filter_id(':'string $filtername | int','filter_input_array(':'int $type [, mixed $definition [, bool $add_empty = true]] | mixed','filter_input(':'int $type, string $variable_name [, int $filter = FILTER_DEFAULT [, mixed $options]] | mixed','filter_list(':'void | array','filter_var_array(':'array $data [, mixed $definition [, bool $add_empty = true]] | mixed','filter_var(':'mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options]] | mixed',}
+let php_builtin['functions']['fileinfo']={'finfo_buffer(':'resource $finfo [, string $string = NULL [, int $options = FILEINFO_NONE [, resource $context = NULL]]] | string','finfo_close(':'resource $finfo | bool','finfo_file(':'resource $finfo [, string $file_name = NULL [, int $options = FILEINFO_NONE [, resource $context = NULL]]] | string','finfo_open(':'[ int $options = FILEINFO_NONE [, string $magic_file = NULL]] | resource','finfo_set_flags(':'resource $finfo, int $options | bool','mime_content_type(':'string $filename | string',}
+let php_builtin['functions']['output_control']={'flush(':'void | void','ob_clean(':'void | void','ob_end_clean(':'void | bool','ob_end_flush(':'void | bool','ob_flush(':'void | void','ob_get_clean(':'void | string','ob_get_contents(':'void | string','ob_get_flush(':'void | string','ob_get_length(':'void | int','ob_get_level(':'void | int','ob_get_status(':'[ bool $full_status = FALSE] | array','ob_gzhandler(':'string $buffer, int $mode | string','ob_implicit_flush(':'[ int $flag = true] | void','ob_list_handlers(':'void | array','ob_start(':'[ callable $output_callback = NULL [, int $chunk_size = 0 [, int $flags = PHP_OUTPUT_HANDLER_STDFLAGS]]] | bool','output_add_rewrite_var(':'string $name, string $value | bool','output_reset_rewrite_vars(':'void | bool',}
+let php_builtin['functions']['gd']={'gd_info(':'void | array','getimagesize(':'string $filename [, array &$imageinfo] | array','getimagesizefromstring(':'string $imagedata [, array &$imageinfo] | array','image_type_to_extension(':'int $imagetype [, bool $include_dot = TRUE] | string','image_type_to_mime_type(':'int $imagetype | string','image2wbmp(':'resource $image [, string $filename [, int $threshold]] | bool','imageaffine(':'resource $image, array $affine [, array $clip] | resource','imageaffinematrixconcat(':'array $m1, array $m2 | array','imageaffinematrixget(':'int $type [, mixed $options] | array','imagealphablending(':'resource $image, bool $blendmode | bool','imageantialias(':'resource $image, bool $enabled | bool','imagearc(':'resource $image, int $cx, int $cy, int $width, int $height, int $start, int $end, int $color | bool','imagechar(':'resource $image, int $font, int $x, int $y, string $c, int $color | bool','imagecharup(':'resource $image, int $font, int $x, int $y, string $c, int $color | bool','imagecolorallocate(':'resource $image, int $red, int $green, int $blue | int','imagecolorallocatealpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorat(':'resource $image, int $x, int $y | int','imagecolorclosest(':'resource $image, int $red, int $green, int $blue | int','imagecolorclosestalpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorclosesthwb(':'resource $image, int $red, int $green, int $blue | int','imagecolordeallocate(':'resource $image, int $color | bool','imagecolorexact(':'resource $image, int $red, int $green, int $blue | int','imagecolorexactalpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolormatch(':'resource $image1, resource $image2 | bool','imagecolorresolve(':'resource $image, int $red, int $green, int $blue | int','imagecolorresolvealpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorset(':'resource $image, int $index, int $red, int $green, int $blue [, int $alpha = 0] | void','imagecolorsforindex(':'resource $image, int $index | array','imagecolorstotal(':'resource $image | int','imagecolortransparent(':'resource $image [, int $color] | int','imageconvolution(':'resource $image, array $matrix, float $div, float $offset | bool','imagecopy(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h | bool','imagecopymerge(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h, int $pct | bool','imagecopymergegray(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h, int $pct | bool','imagecopyresampled(':'resource $dst_image, resource $src_image, int $dst_x, int $dst_y, int $src_x, int $src_y, int $dst_w, int $dst_h, int $src_w, int $src_h | bool','imagecopyresized(':'resource $dst_image, resource $src_image, int $dst_x, int $dst_y, int $src_x, int $src_y, int $dst_w, int $dst_h, int $src_w, int $src_h | bool','imagecreate(':'int $width, int $height | resource','imagecreatefromgd(':'string $filename | resource','imagecreatefromgd2(':'string $filename | resource','imagecreatefromgd2part(':'string $filename, int $srcX, int $srcY, int $width, int $height | resource','imagecreatefromgif(':'string $filename | resource','imagecreatefromjpeg(':'string $filename | resource','imagecreatefrompng(':'string $filename | resource','imagecreatefromstring(':'string $image | resource','imagecreatefromwbmp(':'string $filename | resource','imagecreatefromwebp(':'string $filename | resource','imagecreatefromxbm(':'string $filename | resource','imagecreatefromxpm(':'string $filename | resource','imagecreatetruecolor(':'int $width, int $height | resource','imagecrop(':'resource $image, array $rect | resource','imagecropauto(':'resource $image [, int $mode = -1 [, float $threshold = .5 [, int $color = -1]]] | resource','imagedashedline(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagedestroy(':'resource $image | bool','imageellipse(':'resource $image, int $cx, int $cy, int $width, int $height, int $color | bool','imagefill(':'resource $image, int $x, int $y, int $color | bool','imagefilledarc(':'resource $image, int $cx, int $cy, int $width, int $height, int $start, int $end, int $color, int $style | bool','imagefilledellipse(':'resource $image, int $cx, int $cy, int $width, int $height, int $color | bool','imagefilledpolygon(':'resource $image, array $points, int $num_points, int $color | bool','imagefilledrectangle(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagefilltoborder(':'resource $image, int $x, int $y, int $border, int $color | bool','imagefilter(':'resource $image, int $filtertype [, int $arg1 [, int $arg2 [, int $arg3 [, int $arg4]]]] | bool','imageflip(':'resource $image, int $mode | bool','imagefontheight(':'int $font | int','imagefontwidth(':'int $font | int','imageftbbox(':'float $size, float $angle, string $fontfile, string $text [, array $extrainfo] | array','imagefttext(':'resource $image, float $size, float $angle, int $x, int $y, int $color, string $fontfile, string $text [, array $extrainfo] | array','imagegammacorrect(':'resource $image, float $inputgamma, float $outputgamma | bool','imagegd(':'resource $image [, string $filename] | bool','imagegd2(':'resource $image [, string $filename [, int $chunk_size [, int $type = IMG_GD2_RAW]]] | bool','imagegif(':'resource $image [, string $filename] | bool','imagegrabscreen(':'void | resource','imagegrabwindow(':'int $window_handle [, int $client_area = 0] | resource','imageinterlace(':'resource $image [, int $interlace = 0] | int','imageistruecolor(':'resource $image | bool','imagejpeg(':'resource $image [, string $filename [, int $quality]] | bool','imagelayereffect(':'resource $image, int $effect | bool','imageline(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imageloadfont(':'string $file | int','imagepalettecopy(':'resource $destination, resource $source | void','imagepalettetotruecolor(':'resource $src | bool','imagepng(':'resource $image [, string $filename [, int $quality [, int $filters]]] | bool','imagepolygon(':'resource $image, array $points, int $num_points, int $color | bool','imagepsbbox(':'string $text, resource $font, int $size | array','imagepsencodefont(':'resource $font_index, string $encodingfile | bool','imagepsextendfont(':'resource $font_index, float $extend | bool','imagepsfreefont(':'resource $font_index | bool','imagepsloadfont(':'string $filename | resource','imagepsslantfont(':'resource $font_index, float $slant | bool','imagepstext(':'resource $image, string $text, resource $font_index, int $size, int $foreground, int $background, int $x, int $y [, int $space = 0 [, int $tightness = 0 [, float $angle = 0.0 [, int $antialias_steps = 4]]]] | array','imagerectangle(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagerotate(':'resource $image, float $angle, int $bgd_color [, int $ignore_transparent = 0] | resource','imagesavealpha(':'resource $image, bool $saveflag | bool','imagescale(':'resource $image, int $new_width [, int $new_height = -1 [, int $mode = IMG_BILINEAR_FIXED]] | resource','imagesetbrush(':'resource $image, resource $brush | bool','imagesetinterpolation(':'resource $image [, int $method = IMG_BILINEAR_FIXED] | bool','imagesetpixel(':'resource $image, int $x, int $y, int $color | bool','imagesetstyle(':'resource $image, array $style | bool','imagesetthickness(':'resource $image, int $thickness | bool','imagesettile(':'resource $image, resource $tile | bool','imagestring(':'resource $image, int $font, int $x, int $y, string $string, int $color | bool','imagestringup(':'resource $image, int $font, int $x, int $y, string $string, int $color | bool','imagesx(':'resource $image | int','imagesy(':'resource $image | int','imagetruecolortopalette(':'resource $image, bool $dither, int $ncolors | bool','imagettfbbox(':'float $size, float $angle, string $fontfile, string $text | array','imagettftext(':'resource $image, float $size, float $angle, int $x, int $y, int $color, string $fontfile, string $text | array','imagetypes(':'void | int','imagewbmp(':'resource $image [, string $filename [, int $foreground]] | bool','imagewebp(':'resource $image, string $filename | bool','imagexbm(':'resource $image, string $filename [, int $foreground] | bool','iptcembed(':'string $iptcdata, string $jpeg_file_name [, int $spool] | mixed','iptcparse(':'string $iptcblock | array','jpeg2wbmp(':'string $jpegname, string $wbmpname, int $dest_height, int $dest_width, int $threshold | bool','png2wbmp(':'string $pngname, string $wbmpname, int $dest_height, int $dest_width, int $threshold | bool',}
+let php_builtin['functions']['iconv']={'iconv_get_encoding(':'[ string $type = "all"] | mixed','iconv_mime_decode_headers(':'string $encoded_headers [, int $mode = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | array','iconv_mime_decode(':'string $encoded_header [, int $mode = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | string','iconv_mime_encode(':'string $field_name, string $field_value [, array $preferences = NULL] | string','iconv_set_encoding(':'string $type, string $charset | bool','iconv_strlen(':'string $str [, string $charset = ini_get("iconv.internal_encoding")] | int','iconv_strpos(':'string $haystack, string $needle [, int $offset = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | int','iconv_strrpos(':'string $haystack, string $needle [, string $charset = ini_get("iconv.internal_encoding")] | int','iconv_substr(':'string $str, int $offset [, int $length = iconv_strlen($str, $charset) [, string $charset = ini_get("iconv.internal_encoding")]] | string','iconv(':'string $in_charset, string $out_charset, string $str | string','ob_iconv_handler(':'string $contents, int $status | string',}
+let php_builtin['functions']['json']={'json_decode(':'string $json [, bool $assoc = false [, int $depth = 512 [, int $options = 0]]] | mixed','json_encode(':'mixed $value [, int $options = 0 [, int $depth = 512]] | string','json_last_error_msg(':'void | string','json_last_error(':'void | int',}
+let php_builtin['functions']['libxml']={'libxml_clear_errors(':'void | void','libxml_disable_entity_loader(':'[ bool $disable = true] | bool','libxml_get_errors(':'void | array','libxml_get_last_error(':'void | LibXMLError','libxml_set_external_entity_loader(':'callable $resolver_function | void','libxml_set_streams_context(':'resource $streams_context | void','libxml_use_internal_errors(':'[ bool $use_errors = false] | bool',}
+let php_builtin['functions']['multibyte_string']={'mb_check_encoding(':'[ string $var = NULL [, string $encoding = mb_internal_encoding()]] | bool','mb_convert_case(':'string $str, int $mode [, string $encoding = mb_internal_encoding()] | string','mb_convert_encoding(':'string $str, string $to_encoding [, mixed $from_encoding = mb_internal_encoding()] | string','mb_convert_kana(':'string $str [, string $option = "KV" [, string $encoding = mb_internal_encoding()]] | string','mb_convert_variables(':'string $to_encoding, mixed $from_encoding, mixed &$vars [, mixed &$...] | string','mb_decode_mimeheader(':'string $str | string','mb_decode_numericentity(':'string $str, array $convmap [, string $encoding = mb_internal_encoding()] | string','mb_detect_encoding(':'string $str [, mixed $encoding_list = mb_detect_order() [, bool $strict = false]] | string','mb_detect_order(':'[ mixed $encoding_list = mb_detect_order()] | mixed','mb_encode_mimeheader(':'string $str [, string $charset = mb_internal_encoding() [, string $transfer_encoding = "B" [, string $linefeed = "\r\n" [, int $indent = 0]]]] | string','mb_encode_numericentity(':'string $str, array $convmap [, string $encoding = mb_internal_encoding() [, bool $is_hex = FALSE]] | string','mb_encoding_aliases(':'string $encoding | array','mb_ereg_match(':'string $pattern, string $string [, string $option = "msr"] | bool','mb_ereg_replace_callback(':'string $pattern, callable $callback, string $string [, string $option = "msr"] | string','mb_ereg_replace(':'string $pattern, string $replacement, string $string [, string $option = "msr"] | string','mb_ereg_search_getpos(':'void | int','mb_ereg_search_getregs(':'void | array','mb_ereg_search_init(':'string $string [, string $pattern [, string $option = "msr"]] | bool','mb_ereg_search_pos(':'[ string $pattern [, string $option = "ms"]] | array','mb_ereg_search_regs(':'[ string $pattern [, string $option = "ms"]] | array','mb_ereg_search_setpos(':'int $position | bool','mb_ereg_search(':'[ string $pattern [, string $option = "ms"]] | bool','mb_ereg(':'string $pattern, string $string [, array $regs] | int','mb_eregi_replace(':'string $pattern, string $replace, string $string [, string $option = "msri"] | string','mb_eregi(':'string $pattern, string $string [, array $regs] | int','mb_get_info(':'[ string $type = "all"] | mixed','mb_http_input(':'[ string $type = ""] | mixed','mb_http_output(':'[ string $encoding = mb_http_output()] | mixed','mb_internal_encoding(':'[ string $encoding = mb_internal_encoding()] | mixed','mb_language(':'[ string $language = mb_language()] | mixed','mb_list_encodings(':'void | array','mb_output_handler(':'string $contents, int $status | string','mb_parse_str(':'string $encoded_string [, array &$result] | bool','mb_preferred_mime_name(':'string $encoding | string','mb_regex_encoding(':'[ string $encoding = mb_regex_encoding()] | mixed','mb_regex_set_options(':'[ string $options = mb_regex_set_options()] | string','mb_send_mail(':'string $to, string $subject, string $message [, string $additional_headers = NULL [, string $additional_parameter = NULL]] | bool','mb_split(':'string $pattern, string $string [, int $limit = -1] | array','mb_strcut(':'string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] | string','mb_strimwidth(':'string $str, int $start, int $width [, string $trimmarker = "" [, string $encoding = mb_internal_encoding()]] | string','mb_stripos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_stristr(':'string $haystack, string $needle [, bool $before_needle = false [, string $encoding = mb_internal_encoding()]] | string','mb_strlen(':'string $str [, string $encoding = mb_internal_encoding()] | mixed','mb_strpos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strrchr(':'string $haystack, string $needle [, bool $part = false [, string $encoding = mb_internal_encoding()]] | string','mb_strrichr(':'string $haystack, string $needle [, bool $part = false [, string $encoding = mb_internal_encoding()]] | string','mb_strripos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strrpos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strstr(':'string $haystack, string $needle [, bool $before_needle = false [, string $encoding = mb_internal_encoding()]] | string','mb_strtolower(':'string $str [, string $encoding = mb_internal_encoding()] | string','mb_strtoupper(':'string $str [, string $encoding = mb_internal_encoding()] | string','mb_strwidth(':'string $str [, string $encoding = mb_internal_encoding()] | int','mb_substitute_character(':'[ mixed $substrchar = mb_substitute_character()] | mixed','mb_substr_count(':'string $haystack, string $needle [, string $encoding = mb_internal_encoding()] | int','mb_substr(':'string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] | string',}
+let php_builtin['functions']['mssql']={'mssql_bind(':'resource $stmt, string $param_name, mixed &$var, int $type [, bool $is_output = false [, bool $is_null = false [, int $maxlen = -1]]] | bool','mssql_close(':'[ resource $link_identifier] | bool','mssql_connect(':'[ string $servername [, string $username [, string $password [, bool $new_link = false]]]] | resource','mssql_data_seek(':'resource $result_identifier, int $row_number | bool','mssql_execute(':'resource $stmt [, bool $skip_results = false] | mixed','mssql_fetch_array(':'resource $result [, int $result_type = MSSQL_BOTH] | array','mssql_fetch_assoc(':'resource $result_id | array','mssql_fetch_batch(':'resource $result | int','mssql_fetch_field(':'resource $result [, int $field_offset = -1] | object','mssql_fetch_object(':'resource $result | object','mssql_fetch_row(':'resource $result | array','mssql_field_length(':'resource $result [, int $offset = -1] | int','mssql_field_name(':'resource $result [, int $offset = -1] | string','mssql_field_seek(':'resource $result, int $field_offset | bool','mssql_field_type(':'resource $result [, int $offset = -1] | string','mssql_free_result(':'resource $result | bool','mssql_free_statement(':'resource $stmt | bool','mssql_get_last_message(':'void | string','mssql_guid_string(':'string $binary [, bool $short_format = false] | string','mssql_init(':'string $sp_name [, resource $link_identifier] | resource','mssql_min_error_severity(':'int $severity | void','mssql_min_message_severity(':'int $severity | void','mssql_next_result(':'resource $result_id | bool','mssql_num_fields(':'resource $result | int','mssql_num_rows(':'resource $result | int','mssql_pconnect(':'[ string $servername [, string $username [, string $password [, bool $new_link = false]]]] | resource','mssql_query(':'string $query [, resource $link_identifier [, int $batch_size = 0]] | mixed','mssql_result(':'resource $result, int $row, mixed $field | string','mssql_rows_affected(':'resource $link_identifier | int','mssql_select_db(':'string $database_name [, resource $link_identifier] | bool',}
+let php_builtin['functions']['mysql']={'mysql_affected_rows(':'[ resource $link_identifier = NULL] | int','mysql_client_encoding(':'[ resource $link_identifier = NULL] | string','mysql_close(':'[ resource $link_identifier = NULL] | bool','mysql_connect(':'[ string $server = ini_get("mysql.default_host") [, string $username = ini_get("mysql.default_user") [, string $password = ini_get("mysql.default_password") [, bool $new_link = false [, int $client_flags = 0]]]]] | resource','mysql_create_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_data_seek(':'resource $result, int $row_number | bool','mysql_db_name(':'resource $result, int $row [, mixed $field = NULL] | string','mysql_db_query(':'string $database, string $query [, resource $link_identifier = NULL] | resource','mysql_drop_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_errno(':'[ resource $link_identifier = NULL] | int','mysql_error(':'[ resource $link_identifier = NULL] | string','mysql_escape_string(':'string $unescaped_string | string','mysql_fetch_array(':'resource $result [, int $result_type = MYSQL_BOTH] | array','mysql_fetch_assoc(':'resource $result | array','mysql_fetch_field(':'resource $result [, int $field_offset = 0] | object','mysql_fetch_lengths(':'resource $result | array','mysql_fetch_object(':'resource $result [, string $class_name [, array $params]] | object','mysql_fetch_row(':'resource $result | array','mysql_field_flags(':'resource $result, int $field_offset | string','mysql_field_len(':'resource $result, int $field_offset | int','mysql_field_name(':'resource $result, int $field_offset | string','mysql_field_seek(':'resource $result, int $field_offset | bool','mysql_field_table(':'resource $result, int $field_offset | string','mysql_field_type(':'resource $result, int $field_offset | string','mysql_free_result(':'resource $result | bool','mysql_get_client_info(':'void | string','mysql_get_host_info(':'[ resource $link_identifier = NULL] | string','mysql_get_proto_info(':'[ resource $link_identifier = NULL] | int','mysql_get_server_info(':'[ resource $link_identifier = NULL] | string','mysql_info(':'[ resource $link_identifier = NULL] | string','mysql_insert_id(':'[ resource $link_identifier = NULL] | int','mysql_list_dbs(':'[ resource $link_identifier = NULL] | resource','mysql_list_fields(':'string $database_name, string $table_name [, resource $link_identifier = NULL] | resource','mysql_list_processes(':'[ resource $link_identifier = NULL] | resource','mysql_list_tables(':'string $database [, resource $link_identifier = NULL] | resource','mysql_num_fields(':'resource $result | int','mysql_num_rows(':'resource $result | int','mysql_pconnect(':'[ string $server = ini_get("mysql.default_host") [, string $username = ini_get("mysql.default_user") [, string $password = ini_get("mysql.default_password") [, int $client_flags = 0]]]] | resource','mysql_ping(':'[ resource $link_identifier = NULL] | bool','mysql_query(':'string $query [, resource $link_identifier = NULL] | mixed','mysql_real_escape_string(':'string $unescaped_string [, resource $link_identifier = NULL] | string','mysql_result(':'resource $result, int $row [, mixed $field = 0] | string','mysql_select_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_set_charset(':'string $charset [, resource $link_identifier = NULL] | bool','mysql_stat(':'[ resource $link_identifier = NULL] | string','mysql_tablename(':'resource $result, int $i | string','mysql_thread_id(':'[ resource $link_identifier = NULL] | int','mysql_unbuffered_query(':'string $query [, resource $link_identifier = NULL] | resource',}
+let php_builtin['functions']['mysqli']={'mysqli_disable_reads_from_master(':'mysqli $link | bool','mysqli_disable_rpl_parse(':'mysqli $link | bool','mysqli_enable_reads_from_master(':'mysqli $link | bool','mysqli_enable_rpl_parse(':'mysqli $link | bool','mysqli_get_cache_stats(':'void | array','mysqli_master_query(':'mysqli $link, string $query | bool','mysqli_rpl_parse_enabled(':'mysqli $link | int','mysqli_rpl_probe(':'mysqli $link | bool','mysqli_slave_query(':'mysqli $link, string $query | bool',}
+let php_builtin['functions']['password_hashing']={'password_get_info(':'string $hash | array','password_hash(':'string $password, integer $algo [, array $options] | string','password_needs_rehash(':'string $hash, string $algo [, string $options] | boolean','password_verify(':'string $password, string $hash | boolean',}
+let php_builtin['functions']['postgresql']={'pg_affected_rows(':'resource $result | int','pg_cancel_query(':'resource $connection | bool','pg_client_encoding(':'[ resource $connection] | string','pg_close(':'[ resource $connection] | bool','pg_connect(':'string $connection_string [, int $connect_type] | resource','pg_connection_busy(':'resource $connection | bool','pg_connection_reset(':'resource $connection | bool','pg_connection_status(':'resource $connection | int','pg_convert(':'resource $connection, string $table_name, array $assoc_array [, int $options = 0] | array','pg_copy_from(':'resource $connection, string $table_name, array $rows [, string $delimiter [, string $null_as]] | bool','pg_copy_to(':'resource $connection, string $table_name [, string $delimiter [, string $null_as]] | array','pg_dbname(':'[ resource $connection] | string','pg_delete(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_end_copy(':'[ resource $connection] | bool','pg_escape_bytea(':'[ resource $connection [, string $data]] | string','pg_escape_identifier(':'[ resource $connection [, string $data]] | string','pg_escape_literal(':'[ resource $connection [, string $data]] | string','pg_escape_string(':'[ resource $connection [, string $data]] | string','pg_execute(':'[ resource $connection [, string $stmtname [, array $params]]] | resource','pg_fetch_all_columns(':'resource $result [, int $column = 0] | array','pg_fetch_all(':'resource $result | array','pg_fetch_array(':'resource $result [, int $row [, int $result_type = PGSQL_BOTH]] | array','pg_fetch_assoc(':'resource $result [, int $row] | array','pg_fetch_object(':'resource $result [, int $row [, int $result_type = PGSQL_ASSOC]] | object','pg_fetch_result(':'resource $result, int $row, mixed $field | string','pg_fetch_row(':'resource $result [, int $row] | array','pg_field_is_null(':'resource $result, int $row, mixed $field | int','pg_field_name(':'resource $result, int $field_number | string','pg_field_num(':'resource $result, string $field_name | int','pg_field_prtlen(':'resource $result, int $row_number, mixed $field_name_or_number | int','pg_field_size(':'resource $result, int $field_number | int','pg_field_table(':'resource $result, int $field_number [, bool $oid_only = false] | mixed','pg_field_type_oid(':'resource $result, int $field_number | int','pg_field_type(':'resource $result, int $field_number | string','pg_free_result(':'resource $result | bool','pg_get_notify(':'resource $connection [, int $result_type] | array','pg_get_pid(':'resource $connection | int','pg_get_result(':'[ resource $connection] | resource','pg_host(':'[ resource $connection] | string','pg_insert(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_last_error(':'[ resource $connection] | string','pg_last_notice(':'resource $connection | string','pg_last_oid(':'resource $result | string','pg_lo_close(':'resource $large_object | bool','pg_lo_create(':'[ resource $connection [, mixed $object_id]] | int','pg_lo_export(':'[ resource $connection [, int $oid [, string $pathname]]] | bool','pg_lo_import(':'[ resource $connection [, string $pathname [, mixed $object_id]]] | int','pg_lo_open(':'resource $connection, int $oid, string $mode | resource','pg_lo_read_all(':'resource $large_object | int','pg_lo_read(':'resource $large_object [, int $len = 8192] | string','pg_lo_seek(':'resource $large_object, int $offset [, int $whence = PGSQL_SEEK_CUR] | bool','pg_lo_tell(':'resource $large_object | int','pg_lo_truncate(':'resource $large_object, int $size | bool','pg_lo_unlink(':'resource $connection, int $oid | bool','pg_lo_write(':'resource $large_object, string $data [, int $len] | int','pg_meta_data(':'resource $connection, string $table_name [, bool $extended] | array','pg_num_fields(':'resource $result | int','pg_num_rows(':'resource $result | int','pg_options(':'[ resource $connection] | string','pg_parameter_status(':'[ resource $connection [, string $param_name]] | string','pg_pconnect(':'string $connection_string [, int $connect_type] | resource','pg_ping(':'[ resource $connection] | bool','pg_port(':'[ resource $connection] | int','pg_prepare(':'[ resource $connection [, string $stmtname [, string $query]]] | resource','pg_put_line(':'[ resource $connection [, string $data]] | bool','pg_query_params(':'[ resource $connection [, string $query [, array $params]]] | resource','pg_query(':'[ resource $connection [, string $query]] | resource','pg_result_error_field(':'resource $result, int $fieldcode | string','pg_result_error(':'resource $result | string','pg_result_seek(':'resource $result, int $offset | bool','pg_result_status(':'resource $result [, int $type = PGSQL_STATUS_LONG] | mixed','pg_select(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_send_execute(':'resource $connection, string $stmtname, array $params | bool','pg_send_prepare(':'resource $connection, string $stmtname, string $query | bool','pg_send_query_params(':'resource $connection, string $query, array $params | bool','pg_send_query(':'resource $connection, string $query | bool','pg_set_client_encoding(':'[ resource $connection [, string $encoding]] | int','pg_set_error_verbosity(':'[ resource $connection [, int $verbosity]] | int','pg_trace(':'string $pathname [, string $mode = "w" [, resource $connection]] | bool','pg_transaction_status(':'resource $connection | int','pg_tty(':'[ resource $connection] | string','pg_unescape_bytea(':'string $data | string','pg_untrace(':'[ resource $connection] | bool','pg_update(':'resource $connection, string $table_name, array $data, array $condition [, int $options = PGSQL_DML_EXEC] | mixed','pg_version(':'[ resource $connection] | array',}
+let php_builtin['functions']['pcre']={'preg_filter(':'mixed $pattern, mixed $replacement, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_grep(':'string $pattern, array $input [, int $flags = 0] | array','preg_last_error(':'void | int','preg_match_all(':'string $pattern, string $subject [, array &$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0]]] | int','preg_match(':'string $pattern, string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0]]] | int','preg_quote(':'string $str [, string $delimiter = NULL] | string','preg_replace_callback(':'mixed $pattern, callable $callback, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_replace(':'mixed $pattern, mixed $replacement, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_split(':'string $pattern, string $subject [, int $limit = -1 [, int $flags = 0]] | array',}
+let php_builtin['functions']['sessions']={'session_cache_expire(':'[ string $new_cache_expire] | int','session_cache_limiter(':'[ string $cache_limiter] | string','session_commit(':'session_commit  Alias of session_write_close()','session_decode(':'string $data | bool','session_destroy(':'void | bool','session_encode(':'void | string','session_get_cookie_params(':'void | array','session_id(':'[ string $id] | string','session_is_registered(':'string $name | bool','session_module_name(':'[ string $module] | string','session_name(':'[ string $name] | string','session_regenerate_id(':'[ bool $delete_old_session = false] | bool','session_register_shutdown(':'void | void','session_register(':'mixed $name [, mixed $...] | bool','session_save_path(':'[ string $path] | string','session_set_cookie_params(':'int $lifetime [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]] | void','session_set_save_handler(':'callable $open, callable $close, callable $read, callable $write, callable $destroy, callable $gc | bool','session_start(':'void | bool','session_status(':'void | int','session_unregister(':'string $name | bool','session_unset(':'void | void','session_write_close(':'void | void',}
+let php_builtin['functions']['streams']={'set_socket_blocking(':'set_socket_blocking  Alias of stream_set_blocking()','stream_bucket_append(':'resource $brigade, resource $bucket | void','stream_bucket_make_writeable(':'resource $brigade | object','stream_bucket_new(':'resource $stream, string $buffer | object','stream_bucket_prepend(':'resource $brigade, resource $bucket | void','stream_context_create(':'[ array $options [, array $params]] | resource','stream_context_get_default(':'[ array $options] | resource','stream_context_get_options(':'resource $stream_or_context | array','stream_context_get_params(':'resource $stream_or_context | array','stream_context_set_default(':'array $options | resource','stream_context_set_option(':'resource $stream_or_context, string $wrapper, string $option, mixed $value | bool','stream_context_set_params(':'resource $stream_or_context, array $params | bool','stream_copy_to_stream(':'resource $source, resource $dest [, int $maxlength = -1 [, int $offset = 0]] | int','stream_encoding(':'resource $stream [, string $encoding] | bool','stream_filter_append(':'resource $stream, string $filtername [, int $read_write [, mixed $params]] | resource','stream_filter_prepend(':'resource $stream, string $filtername [, int $read_write [, mixed $params]] | resource','stream_filter_register(':'string $filtername, string $classname | bool','stream_filter_remove(':'resource $stream_filter | bool','stream_get_contents(':'resource $handle [, int $maxlength = -1 [, int $offset = -1]] | string','stream_get_filters(':'void | array','stream_get_line(':'resource $handle, int $length [, string $ending] | string','stream_get_meta_data(':'resource $stream | array','stream_get_transports(':'void | array','stream_get_wrappers(':'void | array','stream_is_local(':'mixed $stream_or_url | bool','stream_notification_callback(':'int $notification_code, int $severity, string $message, int $message_code, int $bytes_transferred, int $bytes_max | void','stream_resolve_include_path(':'string $filename | string','stream_select(':'array &$read, array &$write, array &$except, int $tv_sec [, int $tv_usec = 0] | int','stream_set_blocking(':'resource $stream, int $mode | bool','stream_set_chunk_size(':'resource $fp, int $chunk_size | int','stream_set_read_buffer(':'resource $stream, int $buffer | int','stream_set_timeout(':'resource $stream, int $seconds [, int $microseconds = 0] | bool','stream_set_write_buffer(':'resource $stream, int $buffer | int','stream_socket_accept(':'resource $server_socket [, float $timeout = ini_get("default_socket_timeout") [, string &$peername]] | resource','stream_socket_client(':'string $remote_socket [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout") [, int $flags = STREAM_CLIENT_CONNECT [, resource $context]]]]] | resource','stream_socket_enable_crypto(':'resource $stream, bool $enable [, int $crypto_type [, resource $session_stream]] | mixed','stream_socket_get_name(':'resource $handle, bool $want_peer | string','stream_socket_pair(':'int $domain, int $type, int $protocol | array','stream_socket_recvfrom(':'resource $socket, int $length [, int $flags = 0 [, string &$address]] | string','stream_socket_sendto(':'resource $socket, string $data [, int $flags = 0 [, string $address]] | int','stream_socket_server(':'string $local_socket [, int &$errno [, string &$errstr [, int $flags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN [, resource $context]]]] | resource','stream_socket_shutdown(':'resource $stream, int $how | bool','stream_supports_lock(':'resource $stream | bool','stream_wrapper_register(':'string $protocol, string $classname [, int $flags = 0] | bool','stream_wrapper_restore(':'string $protocol | bool','stream_wrapper_unregister(':'string $protocol | bool',}
+let php_builtin['functions']['simplexml']={'simplexml_import_dom(':'DOMNode $node [, string $class_name = "SimpleXMLElement"] | SimpleXMLElement','simplexml_load_file(':'string $filename [, string $class_name = "SimpleXMLElement" [, int $options = 0 [, string $ns = "" [, bool $is_prefix = false]]]] | SimpleXMLElement','simplexml_load_string(':'string $data [, string $class_name = "SimpleXMLElement" [, int $options = 0 [, string $ns = "" [, bool $is_prefix = false]]]] | SimpleXMLElement',}
+let php_builtin['functions']['xmlwriter']={'xmlwriter_end_attribute(':'resource $xmlwriter | bool','xmlwriter_end_cdata(':'resource $xmlwriter | bool','xmlwriter_end_comment(':'resource $xmlwriter | bool','xmlwriter_end_document(':'resource $xmlwriter | bool','xmlwriter_end_dtd_attlist(':'resource $xmlwriter | bool','xmlwriter_end_dtd_element(':'resource $xmlwriter | bool','xmlwriter_end_dtd_entity(':'resource $xmlwriter | bool','xmlwriter_end_dtd(':'resource $xmlwriter | bool','xmlwriter_end_element(':'resource $xmlwriter | bool','xmlwriter_end_pi(':'resource $xmlwriter | bool','xmlwriter_flush(':'resource $xmlwriter [, bool $empty = true] | mixed','xmlwriter_full_end_element(':'resource $xmlwriter | bool','xmlwriter_open_memory(':'void | resource','xmlwriter_open_uri(':'string $uri | resource','xmlwriter_output_memory(':'resource $xmlwriter [, bool $flush = true] | string','xmlwriter_set_indent_string(':'resource $xmlwriter, string $indentString | bool','xmlwriter_set_indent(':'resource $xmlwriter, bool $indent | bool','xmlwriter_start_attribute_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri | bool','xmlwriter_start_attribute(':'resource $xmlwriter, string $name | bool','xmlwriter_start_cdata(':'resource $xmlwriter | bool','xmlwriter_start_comment(':'resource $xmlwriter | bool','xmlwriter_start_document(':'resource $xmlwriter [, string $version = 1.0 [, string $encoding = NULL [, string $standalone]]] | bool','xmlwriter_start_dtd_attlist(':'resource $xmlwriter, string $name | bool','xmlwriter_start_dtd_element(':'resource $xmlwriter, string $qualifiedName | bool','xmlwriter_start_dtd_entity(':'resource $xmlwriter, string $name, bool $isparam | bool','xmlwriter_start_dtd(':'resource $xmlwriter, string $qualifiedName [, string $publicId [, string $systemId]] | bool','xmlwriter_start_element_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri | bool','xmlwriter_start_element(':'resource $xmlwriter, string $name | bool','xmlwriter_start_pi(':'resource $xmlwriter, string $target | bool','xmlwriter_text(':'resource $xmlwriter, string $content | bool','xmlwriter_write_attribute_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri, string $content | bool','xmlwriter_write_attribute(':'resource $xmlwriter, string $name, string $value | bool','xmlwriter_write_cdata(':'resource $xmlwriter, string $content | bool','xmlwriter_write_comment(':'resource $xmlwriter, string $content | bool','xmlwriter_write_dtd_attlist(':'resource $xmlwriter, string $name, string $content | bool','xmlwriter_write_dtd_element(':'resource $xmlwriter, string $name, string $content | bool','xmlwriter_write_dtd_entity(':'resource $xmlwriter, string $name, string $content, bool $pe, string $pubid, string $sysid, string $ndataid | bool','xmlwriter_write_dtd(':'resource $xmlwriter, string $name [, string $publicId [, string $systemId [, string $subset]]] | bool','xmlwriter_write_element_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri [, string $content] | bool','xmlwriter_write_element(':'resource $xmlwriter, string $name [, string $content] | bool','xmlwriter_write_pi(':'resource $xmlwriter, string $target, string $content | bool','xmlwriter_write_raw(':'resource $xmlwriter, string $content | bool',}
+let php_builtin['functions']['zip']={'zip_close(':'resource $zip | void','zip_entry_close(':'resource $zip_entry | bool','zip_entry_compressedsize(':'resource $zip_entry | int','zip_entry_compressionmethod(':'resource $zip_entry | string','zip_entry_filesize(':'resource $zip_entry | int','zip_entry_name(':'resource $zip_entry | string','zip_entry_open(':'resource $zip, resource $zip_entry [, string $mode] | bool','zip_entry_read(':'resource $zip_entry [, int $length = 1024] | string','zip_open(':'string $filename | resource','zip_read(':'resource $zip | resource',}
+let php_builtin['classes']['spl']={'appenditerator':{'name':'AppendIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'append':{'signature':'Iterator $iterator | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayIterator':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'getIteratorIndex':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'arrayiterator':{'name':'ArrayIterator','methods':{'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'__construct':{'signature':'[ mixed $array = array() [, int $flags = 0]]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | mixed','return_type':'mixed'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'string $flags | void','return_type':'void'},'uasort':{'signature':'string $cmp_function | void','return_type':'void'},'uksort':{'signature':'string $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'arrayobject':{'name':'ArrayObject','constants':{'STD_PROP_LIST':'1','ARRAY_AS_PROPS':'2',},'methods':{'__construct':{'signature':'[ mixed $input = [] [, int $flags = 0 [, string $iterator_class = "ArrayIterator"]]]','return_type':''},'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'count':{'signature':'void | int','return_type':'int'},'exchangeArray':{'signature':'mixed $input | array','return_type':'array'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getIterator':{'signature':'void | ArrayIterator','return_type':'ArrayIterator'},'getIteratorClass':{'signature':'void | string','return_type':'string'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'serialize':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setIteratorClass':{'signature':'string $iterator_class | void','return_type':'void'},'uasort':{'signature':'callable $cmp_function | void','return_type':'void'},'uksort':{'signature':'callable $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},},},'badfunctioncallexception':{'name':'BadFunctionCallException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'badmethodcallexception':{'name':'BadMethodCallException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'cachingiterator':{'name':'CachingIterator','constants':{'CALL_TOSTRING':'1','CATCH_GET_CHILD':'16','TOSTRING_USE_KEY':'2','TOSTRING_USE_CURRENT':'4','TOSTRING_USE_INNER':'8','FULL_CACHE':'256',},'methods':{'__construct':{'signature':'Iterator $iterator [, string $flags = self::CALL_TOSTRING]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | void','return_type':'void'},'getCache':{'signature':'void | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'hasNext':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | void','return_type':'void'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'bitmask $flags | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'callbackfilteriterator':{'name':'CallbackFilterIterator','methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'accept':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'directoryiterator':{'name':'DirectoryIterator','methods':{'__construct':{'signature':'string $path','return_type':''},'current':{'signature':'void | DirectoryIterator','return_type':'DirectoryIterator'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isDot':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'__toString':{'signature':'void | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'domainexception':{'name':'DomainException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'emptyiterator':{'name':'EmptyIterator','methods':{'current':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'filesystemiterator':{'name':'FilesystemIterator','constants':{'CURRENT_AS_PATHNAME':'32','CURRENT_AS_FILEINFO':'0','CURRENT_AS_SELF':'16','CURRENT_MODE_MASK':'240','KEY_AS_PATHNAME':'0','KEY_AS_FILENAME':'256','FOLLOW_SYMLINKS':'512','KEY_MODE_MASK':'3840','NEW_CURRENT_AND_KEY':'256','SKIP_DOTS':'4096','UNIX_PATHS':'8192',},'methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'current':{'signature':'void | DirectoryIterator','return_type':'DirectoryIterator'},'getFlags':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isDot':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'seek':{'signature':'int $position | void','return_type':'void'},'__toString':{'signature':'void | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'filteriterator':{'name':'FilterIterator','methods':{'accept':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Iterator $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'globiterator':{'name':'GlobIterator','methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getFlags':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},},},'infiniteiterator':{'name':'InfiniteIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'next':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'invalidargumentexception':{'name':'InvalidArgumentException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'iteratoriterator':{'name':'IteratorIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'lengthexception':{'name':'LengthException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'limititerator':{'name':'LimitIterator','methods':{'__construct':{'signature':'Iterator $iterator [, int $offset = 0 [, int $count = -1]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'getPosition':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | int','return_type':'int'},'valid':{'signature':'void | bool','return_type':'bool'},},},'logicexception':{'name':'LogicException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'multipleiterator':{'name':'MultipleIterator','constants':{'MIT_NEED_ANY':'0','MIT_NEED_ALL':'1','MIT_KEYS_NUMERIC':'0','MIT_KEYS_ASSOC':'2',},'methods':{'__construct':{'signature':'[ int $flags = MultipleIterator::MIT_NEED_ALL|MultipleIterator::MIT_KEYS_NUMERIC]','return_type':''},'attachIterator':{'signature':'Iterator $iterator [, string $infos] | void','return_type':'void'},'containsIterator':{'signature':'Iterator $iterator | void','return_type':'void'},'countIterators':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | array','return_type':'array'},'detachIterator':{'signature':'Iterator $iterator | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | array','return_type':'array'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'norewinditerator':{'name':'NoRewindIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'outofboundsexception':{'name':'OutOfBoundsException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'outofrangeexception':{'name':'OutOfRangeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'overflowexception':{'name':'OverflowException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'parentiterator':{'name':'ParentIterator','methods':{'accept':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'RecursiveIterator $iterator','return_type':''},'getChildren':{'signature':'void | ParentIterator','return_type':'ParentIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},},},'rangeexception':{'name':'RangeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'recursivearrayiterator':{'name':'RecursiveArrayIterator','methods':{'getChildren':{'signature':'void | RecursiveArrayIterator','return_type':'RecursiveArrayIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'__construct':{'signature':'[ mixed $array = array() [, int $flags = 0]]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | mixed','return_type':'mixed'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'string $flags | void','return_type':'void'},'uasort':{'signature':'string $cmp_function | void','return_type':'void'},'uksort':{'signature':'string $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursivecachingiterator':{'name':'RecursiveCachingIterator','methods':{'__construct':{'signature':'Iterator $iterator [, string $flags = self::CALL_TOSTRING]','return_type':''},'getChildren':{'signature':'void | RecursiveCachingIterator','return_type':'RecursiveCachingIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | void','return_type':'void'},'getCache':{'signature':'void | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'hasNext':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | void','return_type':'void'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'bitmask $flags | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'recursivecallbackfilteriterator':{'name':'RecursiveCallbackFilterIterator','methods':{'__construct':{'signature':'RecursiveIterator $iterator, string $callback','return_type':''},'getChildren':{'signature':'void | RecursiveCallbackFilterIterator','return_type':'RecursiveCallbackFilterIterator'},'hasChildren':{'signature':'void | void','return_type':'void'},'accept':{'signature':'void | string','return_type':'string'},},},'recursivedirectoryiterator':{'name':'RecursiveDirectoryIterator','methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'getChildren':{'signature':'void | mixed','return_type':'mixed'},'getSubPath':{'signature':'void | string','return_type':'string'},'getSubPathname':{'signature':'void | string','return_type':'string'},'hasChildren':{'signature':'[ bool $allow_links = false] | bool','return_type':'bool'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getFlags':{'signature':'void | int','return_type':'int'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},},},'recursivefilteriterator':{'name':'RecursiveFilterIterator','methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'getChildren':{'signature':'void | void','return_type':'void'},'hasChildren':{'signature':'void | void','return_type':'void'},'accept':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursiveiteratoriterator':{'name':'RecursiveIteratorIterator','constants':{'LEAVES_ONLY':'0','SELF_FIRST':'1','CHILD_FIRST':'2','CATCH_GET_CHILD':'16',},'methods':{'beginChildren':{'signature':'void | void','return_type':'void'},'beginIteration':{'signature':'void | void','return_type':'void'},'callGetChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'callHasChildren':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Traversable $iterator [, int $mode = RecursiveIteratorIterator::LEAVES_ONLY [, int $flags = 0]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'endChildren':{'signature':'void | void','return_type':'void'},'endIteration':{'signature':'void | void','return_type':'void'},'getDepth':{'signature':'void | int','return_type':'int'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'getMaxDepth':{'signature':'void | mixed','return_type':'mixed'},'getSubIterator':{'signature':'[ int $level] | RecursiveIterator','return_type':'RecursiveIterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'nextElement':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setMaxDepth':{'signature':'[ string $max_depth = -1] | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursiveregexiterator':{'name':'RecursiveRegexIterator','methods':{'__construct':{'signature':'RecursiveIterator $iterator, string $regex [, int $mode = self::MATCH [, int $flags = 0 [, int $preg_flags = 0]]]','return_type':''},'getChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'accept':{'signature':'void | bool','return_type':'bool'},'getFlags':{'signature':'void | int','return_type':'int'},'getMode':{'signature':'void | int','return_type':'int'},'getPregFlags':{'signature':'void | int','return_type':'int'},'getRegex':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMode':{'signature':'int $mode | void','return_type':'void'},'setPregFlags':{'signature':'int $preg_flags | void','return_type':'void'},},},'recursivetreeiterator':{'name':'RecursiveTreeIterator','constants':{'BYPASS_CURRENT':'4','BYPASS_KEY':'8','PREFIX_LEFT':'0','PREFIX_MID_HAS_NEXT':'1','PREFIX_MID_LAST':'2','PREFIX_END_HAS_NEXT':'3','PREFIX_END_LAST':'4','PREFIX_RIGHT':'5',},'methods':{'beginChildren':{'signature':'void | void','return_type':'void'},'beginIteration':{'signature':'void | void','return_type':'void'},'callGetChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'callHasChildren':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Traversable $iterator [, int $mode = RecursiveIteratorIterator::LEAVES_ONLY [, int $flags = 0]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'endChildren':{'signature':'void | void','return_type':'void'},'endIteration':{'signature':'void | void','return_type':'void'},'getEntry':{'signature':'void | string','return_type':'string'},'getPostfix':{'signature':'void | void','return_type':'void'},'getPrefix':{'signature':'void | string','return_type':'string'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'nextElement':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setPrefixPart':{'signature':'int $part, string $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'getDepth':{'signature':'void | int','return_type':'int'},'getInnerIterator':{'signature':'void | iterator','return_type':'iterator'},'getMaxDepth':{'signature':'void | mixed','return_type':'mixed'},'getSubIterator':{'signature':'[ int $level] | RecursiveIterator','return_type':'RecursiveIterator'},'setMaxDepth':{'signature':'[ string $max_depth = -1] | void','return_type':'void'},},},'regexiterator':{'name':'RegexIterator','constants':{'MATCH':'0','GET_MATCH':'1','ALL_MATCHES':'2','SPLIT':'3','REPLACE':'4','USE_KEY':'1',},'methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'accept':{'signature':'void | bool','return_type':'bool'},'getFlags':{'signature':'void | int','return_type':'int'},'getMode':{'signature':'void | int','return_type':'int'},'getPregFlags':{'signature':'void | int','return_type':'int'},'getRegex':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMode':{'signature':'int $mode | void','return_type':'void'},'setPregFlags':{'signature':'int $preg_flags | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'runtimeexception':{'name':'RuntimeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'spldoublylinkedlist':{'name':'SplDoublyLinkedList','methods':{'__construct':{'signature':'void','return_type':''},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splfileinfo':{'name':'SplFileInfo','methods':{'__construct':{'signature':'string $file_name','return_type':''},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFileInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getLinkTarget':{'signature':'void | string','return_type':'string'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getRealPath':{'signature':'void | string','return_type':'string'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'openFile':{'signature':'[ string $open_mode = r [, bool $use_include_path = false [, resource $context = NULL]]] | SplFileObject','return_type':'SplFileObject'},'setFileClass':{'signature':'[ string $class_name] | void','return_type':'void'},'setInfoClass':{'signature':'[ string $class_name] | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},},},'splfileobject':{'name':'SplFileObject','constants':{'DROP_NEW_LINE':'1','READ_AHEAD':'2','SKIP_EMPTY':'4','READ_CSV':'8',},'methods':{'__construct':{'signature':'string $file_name','return_type':''},'current':{'signature':'void | string|array','return_type':'string|array'},'eof':{'signature':'void | bool','return_type':'bool'},'fflush':{'signature':'void | bool','return_type':'bool'},'fgetc':{'signature':'void | string','return_type':'string'},'fgetcsv':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | array','return_type':'array'},'fgets':{'signature':'void | string','return_type':'string'},'fgetss':{'signature':'[ string $allowable_tags] | string','return_type':'string'},'flock':{'signature':'int $operation [, int &$wouldblock] | bool','return_type':'bool'},'fpassthru':{'signature':'void | int','return_type':'int'},'fputcsv':{'signature':'array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','return_type':'int'},'fscanf':{'signature':'string $format [, mixed &$...] | mixed','return_type':'mixed'},'fseek':{'signature':'int $offset [, int $whence = SEEK_SET] | int','return_type':'int'},'fstat':{'signature':'void | array','return_type':'array'},'ftell':{'signature':'void | int','return_type':'int'},'ftruncate':{'signature':'int $size | bool','return_type':'bool'},'fwrite':{'signature':'string $str [, int $length] | int','return_type':'int'},'getChildren':{'signature':'void | void','return_type':'void'},'getCsvControl':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getMaxLineLen':{'signature':'void | int','return_type':'int'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $line_pos | void','return_type':'void'},'setCsvControl':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMaxLineLen':{'signature':'int $max_len | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFileInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getLinkTarget':{'signature':'void | string','return_type':'string'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getRealPath':{'signature':'void | string','return_type':'string'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'openFile':{'signature':'[ string $open_mode = r [, bool $use_include_path = false [, resource $context = NULL]]] | SplFileObject','return_type':'SplFileObject'},'setFileClass':{'signature':'[ string $class_name] | void','return_type':'void'},'setInfoClass':{'signature':'[ string $class_name] | void','return_type':'void'},},},'splfixedarray':{'name':'SplFixedArray','methods':{'__construct':{'signature':'[ int $size = 0]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getSize':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'int $index | bool','return_type':'bool'},'offsetGet':{'signature':'int $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'int $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'int $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setSize':{'signature':'int $size | int','return_type':'int'},'toArray':{'signature':'void | array','return_type':'array'},'valid':{'signature':'void | bool','return_type':'bool'},'__wakeup':{'signature':'void | void','return_type':'void'},},'static_methods':{'fromArray':{'signature':'array $array [, bool $save_indexes = true] | SplFixedArray','return_type':'SplFixedArray'},},},'splheap':{'name':'SplHeap','methods':{'__construct':{'signature':'void','return_type':''},'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splmaxheap':{'name':'SplMaxHeap','methods':{'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splminheap':{'name':'SplMinHeap','methods':{'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splobjectstorage':{'name':'SplObjectStorage','methods':{'addAll':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'attach':{'signature':'object $object [, mixed $data = NULL] | void','return_type':'void'},'contains':{'signature':'object $object | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | object','return_type':'object'},'detach':{'signature':'object $object | void','return_type':'void'},'getHash':{'signature':'object $object | string','return_type':'string'},'getInfo':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'object $object | bool','return_type':'bool'},'offsetGet':{'signature':'object $object | mixed','return_type':'mixed'},'offsetSet':{'signature':'object $object [, mixed $data = NULL] | void','return_type':'void'},'offsetUnset':{'signature':'object $object | void','return_type':'void'},'removeAll':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'removeAllExcept':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setInfo':{'signature':'mixed $data | void','return_type':'void'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splpriorityqueue':{'name':'SplPriorityQueue','methods':{'__construct':{'signature':'void','return_type':''},'compare':{'signature':'mixed $priority1, mixed $priority2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value, mixed $priority | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setExtractFlags':{'signature':'int $flags | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splqueue':{'name':'SplQueue','methods':{'__construct':{'signature':'void','return_type':''},'dequeue':{'signature':'void | mixed','return_type':'mixed'},'enqueue':{'signature':'mixed $value | void','return_type':'void'},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splstack':{'name':'SplStack','methods':{'__construct':{'signature':'void','return_type':''},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'spltempfileobject':{'name':'SplTempFileObject','methods':{'__construct':{'signature':'string $filename [, string $open_mode = "r" [, bool $use_include_path = false [, resource $context]]]','return_type':''},'current':{'signature':'void | string|array','return_type':'string|array'},'eof':{'signature':'void | bool','return_type':'bool'},'fflush':{'signature':'void | bool','return_type':'bool'},'fgetc':{'signature':'void | string','return_type':'string'},'fgetcsv':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | array','return_type':'array'},'fgets':{'signature':'void | string','return_type':'string'},'fgetss':{'signature':'[ string $allowable_tags] | string','return_type':'string'},'flock':{'signature':'int $operation [, int &$wouldblock] | bool','return_type':'bool'},'fpassthru':{'signature':'void | int','return_type':'int'},'fputcsv':{'signature':'array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','return_type':'int'},'fscanf':{'signature':'string $format [, mixed &$...] | mixed','return_type':'mixed'},'fseek':{'signature':'int $offset [, int $whence = SEEK_SET] | int','return_type':'int'},'fstat':{'signature':'void | array','return_type':'array'},'ftell':{'signature':'void | int','return_type':'int'},'ftruncate':{'signature':'int $size | bool','return_type':'bool'},'fwrite':{'signature':'string $str [, int $length] | int','return_type':'int'},'getChildren':{'signature':'void | void','return_type':'void'},'getCsvControl':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getMaxLineLen':{'signature':'void | int','return_type':'int'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $line_pos | void','return_type':'void'},'setCsvControl':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMaxLineLen':{'signature':'int $max_len | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'underflowexception':{'name':'UnderflowException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'unexpectedvalueexception':{'name':'UnexpectedValueException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},}
+let php_builtin['classes']['predefined_interfaces_and_classes']={'closure':{'name':'Closure','methods':{'__construct':{'signature':'void','return_type':''},'bindTo':{'signature':'object $newthis [, mixed $newscope = ''static''] | Closure','return_type':'Closure'},},'static_methods':{'bind':{'signature':'Closure $closure, object $newthis [, mixed $newscope = ''static''] | Closure','return_type':'Closure'},},},'generator':{'name':'Generator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'send':{'signature':'mixed $value | mixed','return_type':'mixed'},'throw':{'signature':'Exception $exception | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},'__wakeup':{'signature':'void | void','return_type':'void'},},},}
+let php_builtin['classes']['curl']={'curlfile':{'name':'CURLFile','properties': {'name':{'initializer':'','type':''},'mime':{'initializer':'','type':''},'postname':{'initializer':'','type':''},},'methods':{'__construct':{'signature':'string $filename [, string $mimetype [, string $postname]]','return_type':''},'getFilename':{'signature':'void | string','return_type':'string'},'getMimeType':{'signature':'void | string','return_type':'string'},'getPostFilename':{'signature':'void | string','return_type':'string'},'setMimeType':{'signature':'string $mime | void','return_type':'void'},'setPostFilename':{'signature':'string $postname | void','return_type':'void'},'__wakeup':{'signature':'void | void','return_type':'void'},},},}
+let php_builtin['classes']['date_time']={'dateinterval':{'name':'DateInterval','properties': {'y':{'initializer':'','type':'integer'},'m':{'initializer':'','type':'integer'},'d':{'initializer':'','type':'integer'},'h':{'initializer':'','type':'integer'},'i':{'initializer':'','type':'integer'},'s':{'initializer':'','type':'integer'},'invert':{'initializer':'','type':'integer'},'days':{'initializer':'','type':'mixed'},},'methods':{'__construct':{'signature':'string $interval_spec','return_type':''},'format':{'signature':'string $format | string','return_type':'string'},},'static_methods':{'createFromDateString':{'signature':'string $time | DateInterval','return_type':'DateInterval'},},},'dateperiod':{'name':'DatePeriod','constants':{'EXCLUDE_START_DATE':'1',},'methods':{'__construct':{'signature':'string $isostr [, int $options]','return_type':''},},},'datetime':{'name':'DateTime','constants':{'ATOM':'"Y-m-d\TH:i:sP"','COOKIE':'"l, d-M-y H:i:s T"','ISO8601':'"Y-m-d\TH:i:sO"','RFC822':'"D, d M y H:i:s O"','RFC850':'"l, d-M-y H:i:s T"','RFC1036':'"D, d M y H:i:s O"','RFC1123':'"D, d M Y H:i:s O"','RFC2822':'"D, d M Y H:i:s O"','RFC3339':'"Y-m-d\TH:i:sP"','RSS':'"D, d M Y H:i:s O"','W3C':'"Y-m-d\TH:i:sP"',},'methods':{'__construct':{'signature':'[ string $time = "now" [, DateTimeZone $timezone = NULL]]','return_type':''},'add':{'signature':'DateInterval $interval | DateTime','return_type':'DateTime'},'modify':{'signature':'string $modify | DateTime','return_type':'DateTime'},'setDate':{'signature':'int $year, int $month, int $day | DateTime','return_type':'DateTime'},'setISODate':{'signature':'int $year, int $week [, int $day = 1] | DateTime','return_type':'DateTime'},'setTime':{'signature':'int $hour, int $minute [, int $second = 0] | DateTime','return_type':'DateTime'},'setTimestamp':{'signature':'int $unixtimestamp | DateTime','return_type':'DateTime'},'setTimezone':{'signature':'DateTimeZone $timezone | DateTime','return_type':'DateTime'},'sub':{'signature':'DateInterval $interval | DateTime','return_type':'DateTime'},'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},'static_methods':{'createFromFormat':{'signature':'string $format, string $time [, DateTimeZone $timezone] | DateTime','return_type':'DateTime'},'getLastErrors':{'signature':'void | array','return_type':'array'},'__set_state':{'signature':'array $array | DateTime','return_type':'DateTime'},},},'datetimeimmutable':{'name':'DateTimeImmutable','methods':{'__construct':{'signature':'[ string $time = "now" [, DateTimeZone $timezone = NULL]]','return_type':''},'add':{'signature':'DateInterval $interval | DateTimeImmutable','return_type':'DateTimeImmutable'},'modify':{'signature':'string $modify | DateTimeImmutable','return_type':'DateTimeImmutable'},'setDate':{'signature':'int $year, int $month, int $day | DateTimeImmutable','return_type':'DateTimeImmutable'},'setISODate':{'signature':'int $year, int $week [, int $day = 1] | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTime':{'signature':'int $hour, int $minute [, int $second = 0] | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTimestamp':{'signature':'int $unixtimestamp | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTimezone':{'signature':'DateTimeZone $timezone | DateTimeImmutable','return_type':'DateTimeImmutable'},'sub':{'signature':'DateInterval $interval | DateTimeImmutable','return_type':'DateTimeImmutable'},'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},'static_methods':{'createFromFormat':{'signature':'string $format, string $time [, DateTimeZone $timezone] | DateTimeImmutable','return_type':'DateTimeImmutable'},'getLastErrors':{'signature':'void | array','return_type':'array'},'__set_state':{'signature':'array $array | DateTimeImmutable','return_type':'DateTimeImmutable'},},},'datetimezone':{'name':'DateTimeZone','constants':{'AFRICA':'1','AMERICA':'2','ANTARCTICA':'4','ARCTIC':'8','ASIA':'16','ATLANTIC':'32','AUSTRALIA':'64','EUROPE':'128','INDIAN':'256','PACIFIC':'512','UTC':'1024','ALL':'2047','ALL_WITH_BC':'4095','PER_COUNTRY':'4096',},'methods':{'__construct':{'signature':'string $timezone','return_type':''},'getLocation':{'signature':'void | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getOffset':{'signature':'DateTime $datetime | int','return_type':'int'},'getTransitions':{'signature':'[ int $timestamp_begin [, int $timestamp_end]] | array','return_type':'array'},},'static_methods':{'listAbbreviations':{'signature':'void | array','return_type':'array'},'listIdentifiers':{'signature':'[ int $what = DateTimeZone::ALL [, string $country = NULL]] | array','return_type':'array'},},},}
+let php_builtin['classes']['directories']={'directory':{'name':'Directory','properties': {'path':{'initializer':'','type':'string'},'handle':{'initializer':'','type':'resource'},},'methods':{'close':{'signature':'[ resource $dir_handle] | void','return_type':'void'},'read':{'signature':'[ resource $dir_handle] | string','return_type':'string'},'rewind':{'signature':'[ resource $dir_handle] | void','return_type':'void'},},},}
+let php_builtin['classes']['dom']={'domattr':{'name':'DOMAttr','properties': {'name':{'initializer':'','type':'string'},'ownerElement':{'initializer':'','type':'DOMElement'},'schemaTypeInfo':{'initializer':'','type':'bool'},'specified':{'initializer':'','type':'bool'},'value':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value]','return_type':''},'isId':{'signature':'void | bool','return_type':'bool'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domcdatasection':{'name':'DOMCdataSection','methods':{'__construct':{'signature':'string $value','return_type':''},'isWhitespaceInElementContent':{'signature':'void | bool','return_type':'bool'},'splitText':{'signature':'int $offset | DOMText','return_type':'DOMText'},},},'domcharacterdata':{'name':'DOMCharacterData','properties': {'data':{'initializer':'','type':'string'},'length':{'initializer':'','type':'int'},},'methods':{'appendData':{'signature':'string $data | void','return_type':'void'},'deleteData':{'signature':'int $offset, int $count | void','return_type':'void'},'insertData':{'signature':'int $offset, string $data | void','return_type':'void'},'replaceData':{'signature':'int $offset, int $count, string $data | void','return_type':'void'},'substringData':{'signature':'int $offset, int $count | string','return_type':'string'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domcomment':{'name':'DOMComment','methods':{'__construct':{'signature':'[ string $value]','return_type':''},'appendData':{'signature':'string $data | void','return_type':'void'},'deleteData':{'signature':'int $offset, int $count | void','return_type':'void'},'insertData':{'signature':'int $offset, string $data | void','return_type':'void'},'replaceData':{'signature':'int $offset, int $count, string $data | void','return_type':'void'},'substringData':{'signature':'int $offset, int $count | string','return_type':'string'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocument':{'name':'DOMDocument','properties': {'actualEncoding':{'initializer':'','type':'string'},'config':{'initializer':'','type':'DOMConfiguration'},'doctype':{'initializer':'','type':'DOMDocumentType'},'documentElement':{'initializer':'','type':'DOMElement'},'documentURI':{'initializer':'','type':'string'},'encoding':{'initializer':'','type':'string'},'formatOutput':{'initializer':'','type':'bool'},'implementation':{'initializer':'','type':'DOMImplementation'},'preserveWhiteSpace':{'initializer':'true','type':'bool'},'recover':{'initializer':'','type':'bool'},'resolveExternals':{'initializer':'','type':'bool'},'standalone':{'initializer':'','type':'bool'},'strictErrorChecking':{'initializer':'true','type':'bool'},'substituteEntities':{'initializer':'','type':'bool'},'validateOnParse':{'initializer':'false','type':'bool'},'version':{'initializer':'','type':'string'},'xmlEncoding':{'initializer':'','type':'string'},'xmlStandalone':{'initializer':'','type':'bool'},'xmlVersion':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'[ string $version [, string $encoding]]','return_type':''},'createAttribute':{'signature':'string $name | DOMAttr','return_type':'DOMAttr'},'createAttributeNS':{'signature':'string $namespaceURI, string $qualifiedName | DOMAttr','return_type':'DOMAttr'},'createCDATASection':{'signature':'string $data | DOMCDATASection','return_type':'DOMCDATASection'},'createComment':{'signature':'string $data | DOMComment','return_type':'DOMComment'},'createDocumentFragment':{'signature':'void | DOMDocumentFragment','return_type':'DOMDocumentFragment'},'createElement':{'signature':'string $name [, string $value] | DOMElement','return_type':'DOMElement'},'createElementNS':{'signature':'string $namespaceURI, string $qualifiedName [, string $value] | DOMElement','return_type':'DOMElement'},'createEntityReference':{'signature':'string $name | DOMEntityReference','return_type':'DOMEntityReference'},'createProcessingInstruction':{'signature':'string $target [, string $data] | DOMProcessingInstruction','return_type':'DOMProcessingInstruction'},'createTextNode':{'signature':'string $content | DOMText','return_type':'DOMText'},'getElementById':{'signature':'string $elementId | DOMElement','return_type':'DOMElement'},'getElementsByTagName':{'signature':'string $name | DOMNodeList','return_type':'DOMNodeList'},'getElementsByTagNameNS':{'signature':'string $namespaceURI, string $localName | DOMNodeList','return_type':'DOMNodeList'},'importNode':{'signature':'DOMNode $importedNode [, bool $deep] | DOMNode','return_type':'DOMNode'},'load':{'signature':'string $filename [, int $options = 0] | mixed','return_type':'mixed'},'loadHTML':{'signature':'string $source [, int $options = 0] | bool','return_type':'bool'},'loadHTMLFile':{'signature':'string $filename [, int $options = 0] | bool','return_type':'bool'},'loadXML':{'signature':'string $source [, int $options = 0] | mixed','return_type':'mixed'},'normalizeDocument':{'signature':'void | void','return_type':'void'},'registerNodeClass':{'signature':'string $baseclass, string $extendedclass | bool','return_type':'bool'},'relaxNGValidate':{'signature':'string $filename | bool','return_type':'bool'},'relaxNGValidateSource':{'signature':'string $source | bool','return_type':'bool'},'save':{'signature':'string $filename [, int $options] | int','return_type':'int'},'saveHTML':{'signature':'[ DOMNode $node = NULL] | string','return_type':'string'},'saveHTMLFile':{'signature':'string $filename | int','return_type':'int'},'saveXML':{'signature':'[ DOMNode $node [, int $options]] | string','return_type':'string'},'schemaValidate':{'signature':'string $filename [, int $flags] | bool','return_type':'bool'},'schemaValidateSource':{'signature':'string $source [, int $flags] | bool','return_type':'bool'},'validate':{'signature':'void | bool','return_type':'bool'},'xinclude':{'signature':'[ int $options] | int','return_type':'int'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocumentfragment':{'name':'DOMDocumentFragment','methods':{'appendXML':{'signature':'string $data | bool','return_type':'bool'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocumenttype':{'name':'DOMDocumentType','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},'name':{'initializer':'','type':'string'},'entities':{'initializer':'','type':'DOMNamedNodeMap'},'notations':{'initializer':'','type':'DOMNamedNodeMap'},'internalSubset':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domelement':{'name':'DOMElement','properties': {'schemaTypeInfo':{'initializer':'','type':'bool'},'tagName':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value [, string $namespaceURI]]','return_type':''},'getAttribute':{'signature':'string $name | string','return_type':'string'},'getAttributeNode':{'signature':'string $name | DOMAttr','return_type':'DOMAttr'},'getAttributeNodeNS':{'signature':'string $namespaceURI, string $localName | DOMAttr','return_type':'DOMAttr'},'getAttributeNS':{'signature':'string $namespaceURI, string $localName | string','return_type':'string'},'getElementsByTagName':{'signature':'string $name | DOMNodeList','return_type':'DOMNodeList'},'getElementsByTagNameNS':{'signature':'string $namespaceURI, string $localName | DOMNodeList','return_type':'DOMNodeList'},'hasAttribute':{'signature':'string $name | bool','return_type':'bool'},'hasAttributeNS':{'signature':'string $namespaceURI, string $localName | bool','return_type':'bool'},'removeAttribute':{'signature':'string $name | bool','return_type':'bool'},'removeAttributeNode':{'signature':'DOMAttr $oldnode | bool','return_type':'bool'},'removeAttributeNS':{'signature':'string $namespaceURI, string $localName | bool','return_type':'bool'},'setAttribute':{'signature':'string $name, string $value | DOMAttr','return_type':'DOMAttr'},'setAttributeNode':{'signature':'DOMAttr $attr | DOMAttr','return_type':'DOMAttr'},'setAttributeNodeNS':{'signature':'DOMAttr $attr | DOMAttr','return_type':'DOMAttr'},'setAttributeNS':{'signature':'string $namespaceURI, string $qualifiedName, string $value | void','return_type':'void'},'setIdAttribute':{'signature':'string $name, bool $isId | void','return_type':'void'},'setIdAttributeNode':{'signature':'DOMAttr $attr, bool $isId | void','return_type':'void'},'setIdAttributeNS':{'signature':'string $namespaceURI, string $localName, bool $isId | void','return_type':'void'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domentity':{'name':'DOMEntity','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},'notationName':{'initializer':'','type':'string'},'actualEncoding':{'initializer':'','type':'string'},'encoding':{'initializer':'','type':'string'},'version':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domentityreference':{'name':'DOMEntityReference','methods':{'__construct':{'signature':'string $name','return_type':''},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domexception':{'name':'DOMException','properties': {'code':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'domimplementation':{'name':'DOMImplementation','methods':{'__construct':{'signature':'void','return_type':''},'createDocument':{'signature':'[ string $namespaceURI = NULL [, string $qualifiedName = NULL [, DOMDocumentType $doctype = NULL]]] | DOMDocument','return_type':'DOMDocument'},'createDocumentType':{'signature':'[ string $qualifiedName = NULL [, string $publicId = NULL [, string $systemId = NULL]]] | DOMDocumentType','return_type':'DOMDocumentType'},'hasFeature':{'signature':'string $feature, string $version | bool','return_type':'bool'},},},'domnamednodemap':{'name':'DOMNamedNodeMap','properties': {'length':{'initializer':'','type':'int'},},'methods':{'getNamedItem':{'signature':'string $name | DOMNode','return_type':'DOMNode'},'getNamedItemNS':{'signature':'string $namespaceURI, string $localName | DOMNode','return_type':'DOMNode'},'item':{'signature':'int $index | DOMNode','return_type':'DOMNode'},},},'domnode':{'name':'DOMNode','properties': {'nodeName':{'initializer':'','type':'string'},'nodeValue':{'initializer':'','type':'string'},'nodeType':{'initializer':'','type':'int'},'parentNode':{'initializer':'','type':'DOMNode'},'childNodes':{'initializer':'','type':'DOMNodeList'},'firstChild':{'initializer':'','type':'DOMNode'},'lastChild':{'initializer':'','type':'DOMNode'},'previousSibling':{'initializer':'','type':'DOMNode'},'nextSibling':{'initializer':'','type':'DOMNode'},'attributes':{'initializer':'','type':'DOMNamedNodeMap'},'ownerDocument':{'initializer':'','type':'DOMDocument'},'namespaceURI':{'initializer':'','type':'string'},'prefix':{'initializer':'','type':'string'},'localName':{'initializer':'','type':'string'},'baseURI':{'initializer':'','type':'string'},'textContent':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domnodelist':{'name':'DOMNodeList','properties': {'length':{'initializer':'','type':'int'},},'methods':{'item':{'signature':'int $index | DOMNode','return_type':'DOMNode'},},},'domnotation':{'name':'DOMNotation','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domprocessinginstruction':{'name':'DOMProcessingInstruction','properties': {'target':{'initializer':'','type':'string'},'data':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value]','return_type':''},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domtext':{'name':'DOMText','properties': {'wholeText':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'[ string $value]','return_type':''},'isWhitespaceInElementContent':{'signature':'void | bool','return_type':'bool'},'splitText':{'signature':'int $offset | DOMText','return_type':'DOMText'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domxpath':{'name':'DOMXPath','properties': {'document':{'initializer':'','type':'DOMDocument'},},'methods':{'__construct':{'signature':'DOMDocument $doc','return_type':''},'evaluate':{'signature':'string $expression [, DOMNode $contextnode [, bool $registerNodeNS = true]] | mixed','return_type':'mixed'},'query':{'signature':'string $expression [, DOMNode $contextnode [, bool $registerNodeNS = true]] | DOMNodeList','return_type':'DOMNodeList'},'registerNamespace':{'signature':'string $prefix, string $namespaceURI | bool','return_type':'bool'},'registerPhpFunctions':{'signature':'[ mixed $restrict] | void','return_type':'void'},},},}
+let php_builtin['classes']['predefined_exceptions']={'errorexception':{'name':'ErrorException','properties': {'severity':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $message = "" [, int $code = 0 [, int $severity = 1 [, string $filename = __FILE__ [, int $lineno = __LINE__ [, Exception $previous = NULL]]]]]]','return_type':''},'getSeverity':{'signature':'void | int','return_type':'int'},'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'exception':{'name':'Exception','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $message = "" [, int $code = 0 [, Exception $previous = NULL]]]','return_type':''},'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},}
+let php_builtin['classes']['libxml']={'libxmlerror':{'name':'libXMLError','properties': {'level':{'initializer':'','type':'int'},'code':{'initializer':'','type':'int'},'column':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},},}
+let php_builtin['classes']['mysqli']={'mysqli_driver':{'name':'mysqli_driver','properties': {'client_info':{'initializer':'','type':'string'},'client_version':{'initializer':'','type':'string'},'driver_version':{'initializer':'','type':'string'},'embedded':{'initializer':'','type':'string'},'reconnect':{'initializer':'','type':'bool'},'report_mode':{'initializer':'','type':'int'},},'methods':{'embedded_server_end':{'signature':'void | void','return_type':'void'},'embedded_server_start':{'signature':'bool $start, array $arguments, array $groups | bool','return_type':'bool'},},},'mysqli_result':{'name':'mysqli_result','properties': {'current_field':{'initializer':'','type':'int'},'field_count':{'initializer':'','type':'int'},'lengths':{'initializer':'','type':'array'},'num_rows':{'initializer':'','type':'int'},},'methods':{'data_seek':{'signature':'int $offset | bool','return_type':'bool'},'fetch_all':{'signature':'[ int $resulttype = MYSQLI_NUM] | mixed','return_type':'mixed'},'fetch_array':{'signature':'[ int $resulttype = MYSQLI_BOTH] | mixed','return_type':'mixed'},'fetch_assoc':{'signature':'void | array','return_type':'array'},'fetch_field_direct':{'signature':'int $fieldnr | object','return_type':'object'},'fetch_field':{'signature':'void | object','return_type':'object'},'fetch_fields':{'signature':'void | array','return_type':'array'},'fetch_object':{'signature':'[ string $class_name [, array $params]] | object','return_type':'object'},'fetch_row':{'signature':'void | mixed','return_type':'mixed'},'field_seek':{'signature':'int $fieldnr | bool','return_type':'bool'},'free':{'signature':'void | void','return_type':'void'},},},'mysqli_sql_exception':{'name':'mysqli_sql_exception','properties': {'sqlstate':{'initializer':'','type':'string'},'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},},'mysqli_stmt':{'name':'mysqli_stmt','properties': {'affected_rows':{'initializer':'','type':'int'},'errno':{'initializer':'','type':'int'},'error_list':{'initializer':'','type':'array'},'error':{'initializer':'','type':'string'},'field_count':{'initializer':'','type':'int'},'insert_id':{'initializer':'','type':'int'},'num_rows':{'initializer':'','type':'int'},'param_count':{'initializer':'','type':'int'},'sqlstate':{'initializer':'','type':'string'},},'methods':{'attr_get':{'signature':'int $attr | int','return_type':'int'},'attr_set':{'signature':'int $attr, int $mode | bool','return_type':'bool'},'bind_param':{'signature':'string $types, mixed &$var1 [, mixed &$...] | bool','return_type':'bool'},'bind_result':{'signature':'mixed &$var1 [, mixed &$...] | bool','return_type':'bool'},'close':{'signature':'void | bool','return_type':'bool'},'data_seek':{'signature':'int $offset | void','return_type':'void'},'execute':{'signature':'void | bool','return_type':'bool'},'fetch':{'signature':'void | bool','return_type':'bool'},'free_result':{'signature':'void | void','return_type':'void'},'get_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'get_warnings':{'signature':'mysqli_stmt $stmt | object','return_type':'object'},'prepare':{'signature':'string $query | mixed','return_type':'mixed'},'reset':{'signature':'void | bool','return_type':'bool'},'result_metadata':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'send_long_data':{'signature':'int $param_nr, string $data | bool','return_type':'bool'},'store_result':{'signature':'void | bool','return_type':'bool'},},},'mysqli_warning':{'name':'mysqli_warning','properties': {'message':{'initializer':'','type':''},'sqlstate':{'initializer':'','type':''},'errno':{'initializer':'','type':''},},'methods':{'__construct':{'signature':'void','return_type':''},'next':{'signature':'void | void','return_type':'void'},},},'mysqli':{'name':'mysqli','properties': {'affected_rows':{'initializer':'','type':'int'},'client_info':{'initializer':'','type':'string'},'client_version':{'initializer':'','type':'int'},'connect_errno':{'initializer':'','type':'string'},'connect_error':{'initializer':'','type':'string'},'errno':{'initializer':'','type':'int'},'error_list':{'initializer':'','type':'array'},'error':{'initializer':'','type':'string'},'field_count':{'initializer':'','type':'int'},'host_info':{'initializer':'','type':'string'},'protocol_version':{'initializer':'','type':'string'},'server_info':{'initializer':'','type':'string'},'server_version':{'initializer':'','type':'int'},'info':{'initializer':'','type':'string'},'insert_id':{'initializer':'','type':'mixed'},'sqlstate':{'initializer':'','type':'string'},'thread_id':{'initializer':'','type':'int'},'warning_count':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $host = ini_get("mysqli.default_host") [, string $username = ini_get("mysqli.default_user") [, string $passwd = ini_get("mysqli.default_pw") [, string $dbname = "" [, int $port = ini_get("mysqli.default_port") [, string $socket = ini_get("mysqli.default_socket")]]]]]]','return_type':''},'autocommit':{'signature':'bool $mode | bool','return_type':'bool'},'change_user':{'signature':'string $user, string $password, string $database | bool','return_type':'bool'},'character_set_name':{'signature':'void | string','return_type':'string'},'close':{'signature':'void | bool','return_type':'bool'},'commit':{'signature':'[ int $flags [, string $name]] | bool','return_type':'bool'},'debug':{'signature':'string $message | bool','return_type':'bool'},'dump_debug_info':{'signature':'void | bool','return_type':'bool'},'get_charset':{'signature':'void | object','return_type':'object'},'get_client_info':{'signature':'void | string','return_type':'string'},'get_connection_stats':{'signature':'void | bool','return_type':'bool'},'get_warnings':{'signature':'void | mysqli_warning','return_type':'mysqli_warning'},'init':{'signature':'void | mysqli','return_type':'mysqli'},'kill':{'signature':'int $processid | bool','return_type':'bool'},'more_results':{'signature':'void | bool','return_type':'bool'},'multi_query':{'signature':'string $query | bool','return_type':'bool'},'next_result':{'signature':'void | bool','return_type':'bool'},'options':{'signature':'int $option, mixed $value | bool','return_type':'bool'},'ping':{'signature':'void | bool','return_type':'bool'},'prepare':{'signature':'string $query | mysqli_stmt','return_type':'mysqli_stmt'},'query':{'signature':'string $query [, int $resultmode = MYSQLI_STORE_RESULT] | mixed','return_type':'mixed'},'real_connect':{'signature':'[ string $host [, string $username [, string $passwd [, string $dbname [, int $port [, string $socket [, int $flags]]]]]]] | bool','return_type':'bool'},'escape_string':{'signature':'string $escapestr | string','return_type':'string'},'real_query':{'signature':'string $query | bool','return_type':'bool'},'reap_async_query':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'refresh':{'signature':'int $options | bool','return_type':'bool'},'rollback':{'signature':'[ int $flags [, string $name]] | bool','return_type':'bool'},'rpl_query_type':{'signature':'string $query | int','return_type':'int'},'select_db':{'signature':'string $dbname | bool','return_type':'bool'},'send_query':{'signature':'string $query | bool','return_type':'bool'},'set_charset':{'signature':'string $charset | bool','return_type':'bool'},'set_local_infile_handler':{'signature':'mysqli $link, callable $read_func | bool','return_type':'bool'},'ssl_set':{'signature':'string $key, string $cert, string $ca, string $capath, string $cipher | bool','return_type':'bool'},'stat':{'signature':'void | string','return_type':'string'},'stmt_init':{'signature':'void | mysqli_stmt','return_type':'mysqli_stmt'},'store_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'use_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},},'static_methods':{'poll':{'signature':'array &$read, array &$error, array &$reject, int $sec [, int $usec] | int','return_type':'int'},},},}
+let php_builtin['classes']['pdo']={'pdo':{'name':'PDO','constants':{'FETCH_ORI_ABS':'','ATTR_PERSISTENT':'','CLASS_CONSTANT':'','ATTR_DEFAULT_FETCH_MODE':'','FETCH_PROPS_LATE':'','FETCH_KEY_PAIR':'','FB_ATTR_DATE_FORMAT':'','FB_ATTR_TIME_FORMAT':'','FB_ATTR_TIMESTAMP_FORMAT':'','MYSQL_ATTR_READ_DEFAULT_FILE':'','MYSQL_ATTR_READ_DEFAULT_GROUP':'','ATTR_AUTOCOMMIT':'','FOURD_ATTR_CHARSET':'','FOURD_ATTR_PREFERRED_IMAGE_TYPES':'','PARAM_LOB':'','PARAM_BOOL':'','PARAM_NULL':'','PARAM_INT':'','PARAM_STR':'','PARAM_STMT':'','PARAM_INPUT_OUTPUT':'','FETCH_LAZY':'','FETCH_ASSOC':'','FETCH_NAMED':'','FETCH_NUM':'','FETCH_BOTH':'','FETCH_OBJ':'','FETCH_BOUND':'','FETCH_COLUMN':'','FETCH_CLASS':'','FETCH_INTO':'','FETCH_FUNC':'','FETCH_GROUP':'','FETCH_UNIQUE':'','FETCH_CLASSTYPE':'','FETCH_SERIALIZE':'','ATTR_PREFETCH':'','ATTR_TIMEOUT':'','ATTR_ERRMODE':'','ATTR_SERVER_VERSION':'','ATTR_CLIENT_VERSION':'','ATTR_SERVER_INFO':'','ATTR_CONNECTION_STATUS':'','ATTR_CASE':'','ATTR_CURSOR_NAME':'','ATTR_CURSOR':'','CURSOR_FWDONLY':'','CURSOR_SCROLL':'','ATTR_DRIVER_NAME':'','ATTR_ORACLE_NULLS':'','ATTR_STATEMENT_CLASS':'','ATTR_FETCH_CATALOG_NAMES':'','ATTR_FETCH_TABLE_NAMES':'','ATTR_STRINGIFY_FETCHES':'','ATTR_MAX_COLUMN_LEN':'','ATTR_EMULATE_PREPARES':'','ERRMODE_SILENT':'','ERRMODE_WARNING':'','ERRMODE_EXCEPTION':'','CASE_NATURAL':'','CASE_LOWER':'','CASE_UPPER':'','NULL_NATURAL':'','NULL_EMPTY_STRING':'','NULL_TO_STRING':'','FETCH_ORI_NEXT':'','FETCH_ORI_PRIOR':'','FETCH_ORI_FIRST':'','FETCH_ORI_LAST':'','FETCH_ORI_REL':'','ERR_NONE':'','PARAM_EVT_ALLOC':'','PARAM_EVT_FREE':'','PARAM_EVT_EXEC_PRE':'','PARAM_EVT_EXEC_POST':'','PARAM_EVT_FETCH_PRE':'','PARAM_EVT_FETCH_POST':'','PARAM_EVT_NORMALIZE':'','MYSQL_ATTR_INIT_COMMAND':'','MYSQL_ATTR_USE_BUFFERED_QUERY':'','MYSQL_ATTR_LOCAL_INFILE':'','MYSQL_ATTR_MAX_BUFFER_SIZE':'','MYSQL_ATTR_DIRECT_QUERY':'','MYSQL_ATTR_FOUND_ROWS':'','MYSQL_ATTR_IGNORE_SPACE':'','MYSQL_ATTR_COMPRESS':'','MYSQL_ATTR_SSL_CA':'','MYSQL_ATTR_SSL_CAPATH':'','MYSQL_ATTR_SSL_CERT':'','MYSQL_ATTR_SSL_CIPHER':'','MYSQL_ATTR_SSL_KEY':'','SQLSRV_TXN_READ_UNCOMMITTED':'','SQLSRV_TXN_READ_COMMITTED':'','SQLSRV_TXN_REPEATABLE_READ':'','SQLSRV_TXN_SNAPSHOT':'','SQLSRV_TXN_SERIALIZABLE':'','SQLSRV_ENCODING_BINARY':'','SQLSRV_ENCODING_SYSTEM':'','SQLSRV_ENCODING_UTF8':'','SQLSRV_ENCODING_DEFAULT':'','SQLSRV_ATTR_QUERY_TIMEOUT':'','SQLSRV_ATTR_DIRECT_QUERY':'',},'methods':{'__construct':{'signature':'string $dsn [, string $username [, string $password [, array $driver_options]]]','return_type':''},'beginTransaction':{'signature':'void | bool','return_type':'bool'},'commit':{'signature':'void | bool','return_type':'bool'},'errorCode':{'signature':'void | mixed','return_type':'mixed'},'errorInfo':{'signature':'void | array','return_type':'array'},'exec':{'signature':'string $statement | int','return_type':'int'},'getAttribute':{'signature':'int $attribute | mixed','return_type':'mixed'},'inTransaction':{'signature':'void | bool','return_type':'bool'},'lastInsertId':{'signature':'[ string $name = NULL] | string','return_type':'string'},'prepare':{'signature':'string $statement [, array $driver_options = array()] | PDOStatement','return_type':'PDOStatement'},'query':{'signature':'string $statement | PDOStatement','return_type':'PDOStatement'},'quote':{'signature':'string $string [, int $parameter_type = PDO::PARAM_STR] | string','return_type':'string'},'rollBack':{'signature':'void | bool','return_type':'bool'},'setAttribute':{'signature':'int $attribute, mixed $value | bool','return_type':'bool'},},'static_methods':{'getAvailableDrivers':{'signature':'void | array','return_type':'array'},},},'pdoexception':{'name':'PDOException','properties': {'errorInfo':{'initializer':'','type':'array'},'code':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'pdostatement':{'name':'PDOStatement','properties': {'queryString':{'initializer':'','type':'string'},},'methods':{'bindColumn':{'signature':'mixed $column, mixed &$param [, int $type [, int $maxlen [, mixed $driverdata]]] | bool','return_type':'bool'},'bindParam':{'signature':'mixed $parameter, mixed &$variable [, int $data_type = PDO::PARAM_STR [, int $length [, mixed $driver_options]]] | bool','return_type':'bool'},'bindValue':{'signature':'mixed $parameter, mixed $value [, int $data_type = PDO::PARAM_STR] | bool','return_type':'bool'},'closeCursor':{'signature':'void | bool','return_type':'bool'},'columnCount':{'signature':'void | int','return_type':'int'},'debugDumpParams':{'signature':'void | void','return_type':'void'},'errorCode':{'signature':'void | string','return_type':'string'},'errorInfo':{'signature':'void | array','return_type':'array'},'execute':{'signature':'[ array $input_parameters] | bool','return_type':'bool'},'fetch':{'signature':'[ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0]]] | mixed','return_type':'mixed'},'fetchAll':{'signature':'[ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array()]]] | array','return_type':'array'},'fetchColumn':{'signature':'[ int $column_number = 0] | string','return_type':'string'},'fetchObject':{'signature':'[ string $class_name = "stdClass" [, array $ctor_args]] | mixed','return_type':'mixed'},'getAttribute':{'signature':'int $attribute | mixed','return_type':'mixed'},'getColumnMeta':{'signature':'int $column | array','return_type':'array'},'nextRowset':{'signature':'void | bool','return_type':'bool'},'rowCount':{'signature':'void | int','return_type':'int'},'setAttribute':{'signature':'int $attribute, mixed $value | bool','return_type':'bool'},'setFetchMode':{'signature':'int $mode | bool','return_type':'bool'},},},}
+let php_builtin['classes']['phar']={'phar':{'name':'Phar','methods':{'addEmptyDir':{'signature':'string $dirname | void','return_type':'void'},'addFile':{'signature':'string $file [, string $localname] | void','return_type':'void'},'addFromString':{'signature':'string $localname, string $contents | void','return_type':'void'},'buildFromDirectory':{'signature':'string $base_dir [, string $regex] | array','return_type':'array'},'buildFromIterator':{'signature':'Iterator $iter [, string $base_directory] | array','return_type':'array'},'compress':{'signature':'int $compression [, string $extension] | object','return_type':'object'},'compressAllFilesBZIP2':{'signature':'void | bool','return_type':'bool'},'compressAllFilesGZ':{'signature':'void | bool','return_type':'bool'},'compressFiles':{'signature':'int $compression | void','return_type':'void'},'__construct':{'signature':'string $fname [, int $flags [, string $alias]]','return_type':''},'convertToData':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | PharData','return_type':'PharData'},'convertToExecutable':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | Phar','return_type':'Phar'},'copy':{'signature':'string $oldfile, string $newfile | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'decompress':{'signature':'[ string $extension] | object','return_type':'object'},'decompressFiles':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'delete':{'signature':'string $entry | bool','return_type':'bool'},'extractTo':{'signature':'string $pathto [, string|array $files [, bool $overwrite = false]] | bool','return_type':'bool'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getModified':{'signature':'void | bool','return_type':'bool'},'getSignature':{'signature':'void | array','return_type':'array'},'getStub':{'signature':'void | string','return_type':'string'},'getVersion':{'signature':'void | string','return_type':'string'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isBuffering':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'void | mixed','return_type':'mixed'},'isFileFormat':{'signature':'int $format | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'offsetExists':{'signature':'string $offset | bool','return_type':'bool'},'offsetGet':{'signature':'string $offset | int','return_type':'int'},'offsetSet':{'signature':'string $offset, string $value | void','return_type':'void'},'offsetUnset':{'signature':'string $offset | bool','return_type':'bool'},'setAlias':{'signature':'string $alias | bool','return_type':'bool'},'setDefaultStub':{'signature':'[ string $index [, string $webindex]] | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setSignatureAlgorithm':{'signature':'int $sigtype [, string $privatekey] | void','return_type':'void'},'setStub':{'signature':'string $stub [, int $len = -1] | bool','return_type':'bool'},'startBuffering':{'signature':'void | void','return_type':'void'},'stopBuffering':{'signature':'void | void','return_type':'void'},'uncompressAllFiles':{'signature':'void | bool','return_type':'bool'},},'static_methods':{'apiVersion':{'signature':'void | string','return_type':'string'},'canCompress':{'signature':'[ int $type = 0] | bool','return_type':'bool'},'canWrite':{'signature':'void | bool','return_type':'bool'},'createDefaultStub':{'signature':'[ string $indexfile [, string $webindexfile]] | string','return_type':'string'},'getSupportedCompression':{'signature':'void | array','return_type':'array'},'getSupportedSignatures':{'signature':'void | array','return_type':'array'},'interceptFileFuncs':{'signature':'void | void','return_type':'void'},'isValidPharFilename':{'signature':'string $filename [, bool $executable = true] | bool','return_type':'bool'},'loadPhar':{'signature':'string $filename [, string $alias] | bool','return_type':'bool'},'mapPhar':{'signature':'[ string $alias [, int $dataoffset = 0]] | bool','return_type':'bool'},'mount':{'signature':'string $pharpath, string $externalpath | void','return_type':'void'},'mungServer':{'signature':'array $munglist | void','return_type':'void'},'running':{'signature':'[ bool $retphar = true] | string','return_type':'string'},'unlinkArchive':{'signature':'string $archive | bool','return_type':'bool'},'webPhar':{'signature':'[ string $alias [, string $index = "index.php" [, string $f404 [, array $mimetypes [, callable $rewrites]]]]] | void','return_type':'void'},},},'phardata':{'name':'PharData','methods':{'addEmptyDir':{'signature':'string $dirname | void','return_type':'void'},'addFile':{'signature':'string $file [, string $localname] | void','return_type':'void'},'addFromString':{'signature':'string $localname, string $contents | void','return_type':'void'},'buildFromDirectory':{'signature':'string $base_dir [, string $regex] | array','return_type':'array'},'buildFromIterator':{'signature':'Iterator $iter [, string $base_directory] | array','return_type':'array'},'compress':{'signature':'int $compression [, string $extension] | object','return_type':'object'},'compressFiles':{'signature':'int $compression | void','return_type':'void'},'__construct':{'signature':'string $fname [, int $flags [, string $alias]]','return_type':''},'convertToData':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | PharData','return_type':'PharData'},'convertToExecutable':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | Phar','return_type':'Phar'},'copy':{'signature':'string $oldfile, string $newfile | bool','return_type':'bool'},'decompress':{'signature':'[ string $extension] | object','return_type':'object'},'decompressFiles':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'delete':{'signature':'string $entry | bool','return_type':'bool'},'extractTo':{'signature':'string $pathto [, string|array $files [, bool $overwrite = false]] | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'offsetSet':{'signature':'string $offset, string $value | void','return_type':'void'},'offsetUnset':{'signature':'string $offset | bool','return_type':'bool'},'setAlias':{'signature':'string $alias | bool','return_type':'bool'},'setDefaultStub':{'signature':'[ string $index [, string $webindex]] | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setSignatureAlgorithm':{'signature':'int $sigtype [, string $privatekey] | void','return_type':'void'},'setStub':{'signature':'string $stub [, int $len = -1] | bool','return_type':'bool'},'compressAllFilesBZIP2':{'signature':'void | bool','return_type':'bool'},'compressAllFilesGZ':{'signature':'void | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getModified':{'signature':'void | bool','return_type':'bool'},'getSignature':{'signature':'void | array','return_type':'array'},'getStub':{'signature':'void | string','return_type':'string'},'getVersion':{'signature':'void | string','return_type':'string'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isBuffering':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'void | mixed','return_type':'mixed'},'isFileFormat':{'signature':'int $format | bool','return_type':'bool'},'offsetExists':{'signature':'string $offset | bool','return_type':'bool'},'offsetGet':{'signature':'string $offset | int','return_type':'int'},'startBuffering':{'signature':'void | void','return_type':'void'},'stopBuffering':{'signature':'void | void','return_type':'void'},'uncompressAllFiles':{'signature':'void | bool','return_type':'bool'},},'static_methods':{'apiVersion':{'signature':'void | string','return_type':'string'},'canCompress':{'signature':'[ int $type = 0] | bool','return_type':'bool'},'canWrite':{'signature':'void | bool','return_type':'bool'},'createDefaultStub':{'signature':'[ string $indexfile [, string $webindexfile]] | string','return_type':'string'},'getSupportedCompression':{'signature':'void | array','return_type':'array'},'getSupportedSignatures':{'signature':'void | array','return_type':'array'},'interceptFileFuncs':{'signature':'void | void','return_type':'void'},'isValidPharFilename':{'signature':'string $filename [, bool $executable = true] | bool','return_type':'bool'},'loadPhar':{'signature':'string $filename [, string $alias] | bool','return_type':'bool'},'mapPhar':{'signature':'[ string $alias [, int $dataoffset = 0]] | bool','return_type':'bool'},'mount':{'signature':'string $pharpath, string $externalpath | void','return_type':'void'},'mungServer':{'signature':'array $munglist | void','return_type':'void'},'running':{'signature':'[ bool $retphar = true] | string','return_type':'string'},'unlinkArchive':{'signature':'string $archive | bool','return_type':'bool'},'webPhar':{'signature':'[ string $alias [, string $index = "index.php" [, string $f404 [, array $mimetypes [, callable $rewrites]]]]] | void','return_type':'void'},},},'pharexception':{'name':'PharException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'pharfileinfo':{'name':'PharFileInfo','methods':{'chmod':{'signature':'int $permissions | void','return_type':'void'},'compress':{'signature':'int $compression | bool','return_type':'bool'},'__construct':{'signature':'string $entry','return_type':''},'decompress':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'getCRC32':{'signature':'void | int','return_type':'int'},'getCompressedSize':{'signature':'void | int','return_type':'int'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getPharFlags':{'signature':'void | int','return_type':'int'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isCRCChecked':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'[ int $compression_type = 9021976] | bool','return_type':'bool'},'isCompressedBZIP2':{'signature':'void | bool','return_type':'bool'},'isCompressedGZ':{'signature':'void | bool','return_type':'bool'},'setCompressedBZIP2':{'signature':'void | bool','return_type':'bool'},'setCompressedGZ':{'signature':'void | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setUncompressed':{'signature':'void | bool','return_type':'bool'},},},}
+let php_builtin['classes']['streams']={'php_user_filter':{'name':'php_user_filter','properties': {'filtername':{'initializer':'','type':''},'params':{'initializer':'','type':''},},'methods':{'filter':{'signature':'resource $in, resource $out, int &$consumed, bool $closing | int','return_type':'int'},'onClose':{'signature':'void | void','return_type':'void'},'onCreate':{'signature':'void | bool','return_type':'bool'},},},}
+let php_builtin['classes']['sessions']={'sessionhandler':{'name':'SessionHandler','methods':{'close':{'signature':'void | bool','return_type':'bool'},'destroy':{'signature':'string $session_id | bool','return_type':'bool'},'gc':{'signature':'int $maxlifetime | bool','return_type':'bool'},'open':{'signature':'string $save_path, string $session_id | bool','return_type':'bool'},'read':{'signature':'string $session_id | string','return_type':'string'},'write':{'signature':'string $session_id, string $session_data | bool','return_type':'bool'},},},'sessionhandlerinterface':{'name':'SessionHandlerInterface','methods':{'close':{'signature':'void | bool','return_type':'bool'},'destroy':{'signature':'string $session_id | bool','return_type':'bool'},'gc':{'signature':'string $maxlifetime | bool','return_type':'bool'},'open':{'signature':'string $save_path, string $name | bool','return_type':'bool'},'read':{'signature':'string $session_id | string','return_type':'string'},'write':{'signature':'string $session_id, string $session_data | bool','return_type':'bool'},},},}
+let php_builtin['classes']['simplexml']={'simplexmlelement':{'name':'SimpleXMLElement','methods':{'__construct':{'signature':'string $data [, int $options = 0 [, bool $data_is_url = false [, string $ns = "" [, bool $is_prefix = false]]]]','return_type':''},'addAttribute':{'signature':'string $name [, string $value [, string $namespace]] | void','return_type':'void'},'addChild':{'signature':'string $name [, string $value [, string $namespace]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'asXML':{'signature':'[ string $filename] | mixed','return_type':'mixed'},'attributes':{'signature':'[ string $ns = NULL [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'children':{'signature':'[ string $ns [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'count':{'signature':'void | int','return_type':'int'},'getDocNamespaces':{'signature':'[ bool $recursive = false [, bool $from_root = true]] | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getNamespaces':{'signature':'[ bool $recursive = false] | array','return_type':'array'},'registerXPathNamespace':{'signature':'string $prefix, string $ns | bool','return_type':'bool'},'__toString':{'signature':'void | string','return_type':'string'},'xpath':{'signature':'string $path | array','return_type':'array'},},},'simplexmliterator':{'name':'SimpleXMLIterator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'getChildren':{'signature':'void | SimpleXMLIterator','return_type':'SimpleXMLIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'string $data [, int $options = 0 [, bool $data_is_url = false [, string $ns = "" [, bool $is_prefix = false]]]]','return_type':''},'addAttribute':{'signature':'string $name [, string $value [, string $namespace]] | void','return_type':'void'},'addChild':{'signature':'string $name [, string $value [, string $namespace]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'asXML':{'signature':'[ string $filename] | mixed','return_type':'mixed'},'attributes':{'signature':'[ string $ns = NULL [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'children':{'signature':'[ string $ns [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'count':{'signature':'void | int','return_type':'int'},'getDocNamespaces':{'signature':'[ bool $recursive = false [, bool $from_root = true]] | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getNamespaces':{'signature':'[ bool $recursive = false] | array','return_type':'array'},'registerXPathNamespace':{'signature':'string $prefix, string $ns | bool','return_type':'bool'},'__toString':{'signature':'void | string','return_type':'string'},'xpath':{'signature':'string $path | array','return_type':'array'},},},}
+let php_builtin['classes']['spl_types']={'splbool':{'name':'SplBool','constants':{'__default':'false','false':'false','true':'true',},'methods':{'getConstList':{'signature':'[ bool $include_default = false] | array','return_type':'array'},},},'splenum':{'name':'SplEnum','constants':{'__default':'null',},'methods':{'getConstList':{'signature':'[ bool $include_default = false] | array','return_type':'array'},'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splfloat':{'name':'SplFloat','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splint':{'name':'SplInt','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splstring':{'name':'SplString','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'spltype':{'name':'SplType','constants':{'__default':'null',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},}
+let php_builtin['classes']['xmlreader']={'xmlreader':{'name':'XMLReader','constants':{'NONE':'0','ELEMENT':'1','ATTRIBUTE':'2','TEXT':'3','CDATA':'4','ENTITY_REF':'5','ENTITY':'6','PI':'7','COMMENT':'8','DOC':'9','DOC_TYPE':'10','DOC_FRAGMENT':'11','NOTATION':'12','WHITESPACE':'13','SIGNIFICANT_WHITESPACE':'14','END_ELEMENT':'15','END_ENTITY':'16','XML_DECLARATION':'17','LOADDTD':'1','DEFAULTATTRS':'2','VALIDATE':'3','SUBST_ENTITIES':'4',},'properties': {'attributeCount':{'initializer':'','type':'int'},'baseURI':{'initializer':'','type':'string'},'depth':{'initializer':'','type':'int'},'hasAttributes':{'initializer':'','type':'bool'},'hasValue':{'initializer':'','type':'bool'},'isDefault':{'initializer':'','type':'bool'},'isEmptyElement':{'initializer':'','type':'bool'},'localName':{'initializer':'','type':'string'},'name':{'initializer':'','type':'string'},'namespaceURI':{'initializer':'','type':'string'},'nodeType':{'initializer':'','type':'int'},'prefix':{'initializer':'','type':'string'},'value':{'initializer':'','type':'string'},'xmlLang':{'initializer':'','type':'string'},},'methods':{'close':{'signature':'void | bool','return_type':'bool'},'expand':{'signature':'[ DOMNode $basenode] | DOMNode','return_type':'DOMNode'},'getAttribute':{'signature':'string $name | string','return_type':'string'},'getAttributeNo':{'signature':'int $index | string','return_type':'string'},'getAttributeNs':{'signature':'string $localName, string $namespaceURI | string','return_type':'string'},'getParserProperty':{'signature':'int $property | bool','return_type':'bool'},'isValid':{'signature':'void | bool','return_type':'bool'},'lookupNamespace':{'signature':'string $prefix | bool','return_type':'bool'},'moveToAttribute':{'signature':'string $name | bool','return_type':'bool'},'moveToAttributeNo':{'signature':'int $index | bool','return_type':'bool'},'moveToAttributeNs':{'signature':'string $localName, string $namespaceURI | bool','return_type':'bool'},'moveToElement':{'signature':'void | bool','return_type':'bool'},'moveToFirstAttribute':{'signature':'void | bool','return_type':'bool'},'moveToNextAttribute':{'signature':'void | bool','return_type':'bool'},'next':{'signature':'[ string $localname] | bool','return_type':'bool'},'open':{'signature':'string $URI [, string $encoding [, int $options = 0]] | bool','return_type':'bool'},'read':{'signature':'void | bool','return_type':'bool'},'readInnerXML':{'signature':'void | string','return_type':'string'},'readOuterXML':{'signature':'void | string','return_type':'string'},'readString':{'signature':'void | string','return_type':'string'},'setParserProperty':{'signature':'int $property, bool $value | bool','return_type':'bool'},'setRelaxNGSchema':{'signature':'string $filename | bool','return_type':'bool'},'setRelaxNGSchemaSource':{'signature':'string $source | bool','return_type':'bool'},'setSchema':{'signature':'string $filename | bool','return_type':'bool'},'xml':{'signature':'string $source [, string $encoding [, int $options = 0]] | bool','return_type':'bool'},},},}
+let php_builtin['classes']['xmlwriter'] = {'xmlwriter':{'name':'XMLWriter','methods':{'endAttribute':{'signature':'void | bool','return_type':'bool'},'endCData':{'signature':'void | bool','return_type':'bool'},'endComment':{'signature':'void | bool','return_type':'bool'},'endDocument':{'signature':'void | bool','return_type':'bool'},'endDTDAttlist':{'signature':'void | bool','return_type':'bool'},'endDTDElement':{'signature':'void | bool','return_type':'bool'},'endDTDEntity':{'signature':'void | bool','return_type':'bool'},'endDTD':{'signature':'void | bool','return_type':'bool'},'endElement':{'signature':'void | bool','return_type':'bool'},'endPI':{'signature':'void | bool','return_type':'bool'},'flush':{'signature':'[bool $empty = true] | bool','return_type':'bool'},'fullEndElement':{'signature':'void | bool','return_type':'bool'},'openMemory':{'signature':'void | bool','return_type':'bool'},'openURI':{'signature':'string $uri | bool','return_type':'bool'},'outputMemory':{'signature':'[bool $flush = true] | bool','return_type':'bool'},'setIndentString':{'signature':'string $indentString | bool','return_type':'bool'},'setIndent':{'signature':'bool $indent | bool','return_type':'bool'},'startAttributeNS':{'signature':'string $prefix, string $name, string $uri | bool','return_type':'bool'},'startAttribute':{'signature':'string $name | bool','return_type':'bool'},'startCData':{'signature':'void | bool','return_type':'bool'},'startComment':{'signature':'void | bool','return_type':'bool'},'startDocument':{'signature':'[string $version = 1.0 [, string $encoding = NULL [, string $standalone ]]] | bool','return_type':'bool'},'startDTDAttlist':{'signature':'string $name | bool','return_type':'bool'},'startDTDElement':{'signature':'string $qualifiedName | bool','return_type':'bool'},'startDTDEntity':{'signature':'string $name, bool $isparam | bool','return_type':'bool'},'startDTD':{'signature':'string $qualifiedName [, string $publicId [, string $systemId ]] | bool','return_type':'bool'},'startElementNS':{'signature':'string $prefix, string $name, string $uri | bool','return_type':'bool'},'startElement':{'signature':'string $name | bool','return_type':'bool'},'startPI':{'signature':'string $target | bool','return_type':'bool'},'text':{'signature':'string $content | bool','return_type':'bool'},'writeAttributeNS':{'signature':'string $prefix, string $name, string $uri, string $content | bool','return_type':'bool'},'writeAttribute':{'signature':'string $name, string $value | bool','return_type':'bool'},'writeCData':{'signature':'string $content | bool','return_type':'bool'},'writeComment':{'signature':'string $content | bool','return_type':'bool'},'writeDTDAttlist':{'signature':'string $name, string $content | bool','return_type':'bool'},'writeDTDElement':{'signature':'string $name, string $content | bool','return_type':'bool'},'writeDTDEntity':{'signature':'string $name, string $content, bool $pe, string $pubid, string $sysid, string $ndataid | bool','return_type':'bool'},'writeDTD':{'signature':'string $name [, string $publicId [, string $systemId [, string $subset ]]] | bool','return_type':'bool'},'writeElementNS':{'signature':'string $prefix, string $name, string $uri [, string $content ] | bool','return_type':'bool'},'writeElement':{'signature':'string $name [, string $content ] | bool','return_type':'bool'},'writePI':{'signature':'string $target, string $content | bool','return_type':'bool'},'writeRaw':{'signature':'string $content | bool','return_type':'bool'},},},}
+let php_builtin['classes']['zip']={'ziparchive':{'name':'ZipArchive','properties': {'status':{'initializer':'','type':'int'},'statusSys':{'initializer':'','type':'int'},'numFiles':{'initializer':'','type':'int'},'filename':{'initializer':'','type':'string'},'comment':{'initializer':'','type':'string'},},'methods':{'addEmptyDir':{'signature':'string $dirname | bool','return_type':'bool'},'addFile':{'signature':'string $filename [, string $localname = NULL [, int $start = 0 [, int $length = 0]]] | bool','return_type':'bool'},'addFromString':{'signature':'string $localname, string $contents | bool','return_type':'bool'},'addGlob':{'signature':'string $pattern [, int $flags = 0 [, array $options = array()]] | bool','return_type':'bool'},'addPattern':{'signature':'string $pattern [, string $path = ''.'' [, array $options = array()]] | bool','return_type':'bool'},'close':{'signature':'void | bool','return_type':'bool'},'deleteIndex':{'signature':'int $index | bool','return_type':'bool'},'deleteName':{'signature':'string $name | bool','return_type':'bool'},'extractTo':{'signature':'string $destination [, mixed $entries] | bool','return_type':'bool'},'getArchiveComment':{'signature':'[ int $flags] | string','return_type':'string'},'getCommentIndex':{'signature':'int $index [, int $flags] | string','return_type':'string'},'getCommentName':{'signature':'string $name [, int $flags] | string','return_type':'string'},'getFromIndex':{'signature':'int $index [, int $length = 0 [, int $flags]] | string','return_type':'string'},'getFromName':{'signature':'string $name [, int $length = 0 [, int $flags]] | string','return_type':'string'},'getNameIndex':{'signature':'int $index [, int $flags] | string','return_type':'string'},'getStatusString':{'signature':'void | string','return_type':'string'},'getStream':{'signature':'string $name | resource','return_type':'resource'},'locateName':{'signature':'string $name [, int $flags] | int','return_type':'int'},'open':{'signature':'string $filename [, int $flags] | mixed','return_type':'mixed'},'renameIndex':{'signature':'int $index, string $newname | bool','return_type':'bool'},'renameName':{'signature':'string $name, string $newname | bool','return_type':'bool'},'setArchiveComment':{'signature':'string $comment | bool','return_type':'bool'},'setCommentIndex':{'signature':'int $index, string $comment | bool','return_type':'bool'},'setCommentName':{'signature':'string $name, string $comment | bool','return_type':'bool'},'statIndex':{'signature':'int $index [, int $flags] | array','return_type':'array'},'statName':{'signature':'string $name [, int $flags] | array','return_type':'array'},'unchangeAll':{'signature':'void | bool','return_type':'bool'},'unchangeArchive':{'signature':'void | bool','return_type':'bool'},'unchangeIndex':{'signature':'int $index | bool','return_type':'bool'},'unchangeName':{'signature':'string $name | bool','return_type':'bool'},},},}
+let php_builtin['interfaces']['predefined_interfaces_and_classes']={'arrayaccess':{'name':'ArrayAccess','methods':{'offsetExists':{'signature':'mixed $offset | boolean','return_type':'boolean'},'offsetGet':{'signature':'mixed $offset | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $offset, mixed $value | void','return_type':'void'},'offsetUnset':{'signature':'mixed $offset | void','return_type':'void'},},},'iterator':{'name':'Iterator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'iteratoraggregate':{'name':'IteratorAggregate','methods':{'getIterator':{'signature':'void | Traversable','return_type':'Traversable'},},},'serializable':{'name':'Serializable','methods':{'serialize':{'signature':'void | string','return_type':'string'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},},},'traversable':{'name':'Traversable',},}
+let php_builtin['interfaces']['spl']={'countable':{'name':'Countable','methods':{'count':{'signature':'void | int','return_type':'int'},},},'outeriterator':{'name':'OuterIterator','methods':{'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'recursiveiterator':{'name':'RecursiveIterator','methods':{'getChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'seekableiterator':{'name':'SeekableIterator','methods':{'seek':{'signature':'int $position | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'splobserver':{'name':'SplObserver','methods':{'update':{'signature':'SplSubject $subject | void','return_type':'void'},},},'splsubject':{'name':'SplSubject','methods':{'attach':{'signature':'SplObserver $observer | void','return_type':'void'},'detach':{'signature':'SplObserver $observer | void','return_type':'void'},'notify':{'signature':'void | void','return_type':'void'},},},}
+let php_builtin['interfaces']['date_time']={'datetimeinterface':{'name':'DateTimeInterface','methods':{'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},},}
+let php_builtin['interfaces']['json']={'jsonserializable':{'name':'JsonSerializable','methods':{'jsonSerialize':{'signature':'void | mixed','return_type':'mixed'},},},}
+let php_builtin['constants']['common']={'TRUE':'','FALSE':'','NULL':'','E_NOTICE':'','E_DEPRECATED':'','E_RECOVERABLE_ERROR':'','E_ALL':'','E_STRICT':'','E_WARNING':'','E_ERROR':'','E_PARSE':'','E_CORE_ERROR':'','E_CORE_WARNING':'','E_COMPILE_ERROR':'','E_COMPILE_WARNING':'','E_USER_ERROR':'','E_USER_WARNING':'','E_USER_NOTICE':'','E_USER_DEPRECATED':'','__COMPILER_HALT_OFFSET__':'','__FILE__':'','__LINE__':'','__DIR__':'','__FUNCTION__':'','__CLASS__':'','__TRAIT__':'','__METHOD__':'','__NAMESPACE__':'',}
+let php_builtin['constants']['arrays']={'CASE_LOWER':'','CASE_UPPER':'','SORT_ASC':'','SORT_DESC':'','SORT_REGULAR':'','SORT_NUMERIC':'','SORT_STRING':'','SORT_LOCALE_STRING':'','SORT_NATURAL':'','SORT_FLAG_CASE':'','COUNT_NORMAL':'','COUNT_RECURSIVE':'','EXTR_OVERWRITE':'','EXTR_SKIP':'','EXTR_PREFIX_SAME':'','EXTR_PREFIX_ALL':'','EXTR_PREFIX_INVALID':'','EXTR_PREFIX_IF_EXISTS':'','EXTR_IF_EXISTS':'','EXTR_REFS':'',}
+let php_builtin['constants']['calendar']={'CAL_GREGORIAN':'','CAL_JULIAN':'','CAL_JEWISH':'','CAL_FRENCH':'','CAL_NUM_CALS':'','CAL_DOW_DAYNO':'','CAL_DOW_SHORT':'','CAL_DOW_LONG':'','CAL_MONTH_GREGORIAN_SHORT':'','CAL_MONTH_GREGORIAN_LONG':'','CAL_MONTH_JULIAN_SHORT':'','CAL_MONTH_JULIAN_LONG':'','CAL_MONTH_JEWISH':'','CAL_MONTH_FRENCH':'','CAL_EASTER_DEFAULT':'','CAL_EASTER_ROMAN':'','CAL_EASTER_ALWAYS_GREGORIAN':'','CAL_EASTER_ALWAYS_JULIAN':'','CAL_JEWISH_ADD_ALAFIM_GERESH':'','CAL_JEWISH_ADD_ALAFIM':'','CAL_JEWISH_ADD_GERESHAYIM':'',}
+let php_builtin['constants']['curl']={'CURLOPT_POSTFIELDS':'','CURLOPT_CAINFO':'','CURLOPT_AUTOREFERER':'','CURLOPT_COOKIESESSION':'','CURLOPT_DNS_USE_GLOBAL_CACHE':'','CURLOPT_DNS_CACHE_TIMEOUT':'','CURLOPT_FTP_SSL':'','CURLFTPSSL_TRY':'','CURLFTPSSL_ALL':'','CURLFTPSSL_CONTROL':'','CURLFTPSSL_NONE':'','CURLOPT_PRIVATE':'','CURLOPT_FTPSSLAUTH':'','CURLOPT_PORT':'','CURLOPT_FILE':'','CURLOPT_INFILE':'','CURLOPT_INFILESIZE':'','CURLOPT_URL':'','CURLOPT_PROXY':'','CURLOPT_VERBOSE':'','CURLOPT_HEADER':'','CURLOPT_HTTPHEADER':'','CURLOPT_NOPROGRESS':'','CURLOPT_NOBODY':'','CURLOPT_FAILONERROR':'','CURLOPT_UPLOAD':'','CURLOPT_POST':'','CURLOPT_FTPLISTONLY':'','CURLOPT_FTPAPPEND':'','CURLOPT_FTP_CREATE_MISSING_DIRS':'','CURLOPT_NETRC':'','CURLOPT_FOLLOWLOCATION':'','CURLOPT_FTPASCII':'','CURLOPT_PUT':'','CURLOPT_MUTE':'','CURLOPT_USERPWD':'','CURLOPT_PROXYUSERPWD':'','CURLOPT_RANGE':'','CURLOPT_TIMEOUT':'','CURLOPT_TIMEOUT_MS':'','CURLOPT_TCP_NODELAY':'','CURLOPT_PROGRESSFUNCTION':'','CURLOPT_REFERER':'','CURLOPT_USERAGENT':'','CURLOPT_FTPPORT':'','CURLOPT_FTP_USE_EPSV':'','CURLOPT_LOW_SPEED_LIMIT':'','CURLOPT_LOW_SPEED_TIME':'','CURLOPT_RESUME_FROM':'','CURLOPT_COOKIE':'','CURLOPT_SSLCERT':'','CURLOPT_SSLCERTPASSWD':'','CURLOPT_WRITEHEADER':'','CURLOPT_SSL_VERIFYHOST':'','CURLOPT_COOKIEFILE':'','CURLOPT_SSLVERSION':'','CURLOPT_TIMECONDITION':'','CURLOPT_TIMEVALUE':'','CURLOPT_CUSTOMREQUEST':'','CURLOPT_STDERR':'','CURLOPT_TRANSFERTEXT':'','CURLOPT_RETURNTRANSFER':'','CURLOPT_QUOTE':'','CURLOPT_POSTQUOTE':'','CURLOPT_INTERFACE':'','CURLOPT_KRB4LEVEL':'','CURLOPT_HTTPPROXYTUNNEL':'','CURLOPT_FILETIME':'','CURLOPT_WRITEFUNCTION':'','CURLOPT_READFUNCTION':'','CURLOPT_PASSWDFUNCTION':'','CURLOPT_HEADERFUNCTION':'','CURLOPT_MAXREDIRS':'','CURLOPT_MAXCONNECTS':'','CURLOPT_CLOSEPOLICY':'','CURLOPT_FRESH_CONNECT':'','CURLOPT_FORBID_REUSE':'','CURLOPT_RANDOM_FILE':'','CURLOPT_EGDSOCKET':'','CURLOPT_CONNECTTIMEOUT':'','CURLOPT_CONNECTTIMEOUT_MS':'','CURLOPT_SSL_VERIFYPEER':'','CURLOPT_CAPATH':'','CURLOPT_COOKIEJAR':'','CURLOPT_SSL_CIPHER_LIST':'','CURLOPT_BINARYTRANSFER':'','CURLOPT_NOSIGNAL':'','CURLOPT_PROXYTYPE':'','CURLOPT_BUFFERSIZE':'','CURLOPT_HTTPGET':'','CURLOPT_HTTP_VERSION':'','CURLOPT_SSLKEY':'','CURLOPT_SSLKEYTYPE':'','CURLOPT_SSLKEYPASSWD':'','CURLOPT_SSLENGINE':'','CURLOPT_SSLENGINE_DEFAULT':'','CURLOPT_SSLCERTTYPE':'','CURLOPT_CRLF':'','CURLOPT_ENCODING':'','CURLOPT_PROXYPORT':'','CURLOPT_UNRESTRICTED_AUTH':'','CURLOPT_FTP_USE_EPRT':'','CURLOPT_HTTP200ALIASES':'','CURLOPT_HTTPAUTH':'','CURLAUTH_BASIC':'','CURLAUTH_DIGEST':'','CURLAUTH_GSSNEGOTIATE':'','CURLAUTH_NTLM':'','CURLAUTH_ANY':'','CURLAUTH_ANYSAFE':'','CURLOPT_PROXYAUTH':'','CURLOPT_MAX_RECV_SPEED_LARGE':'','CURLOPT_MAX_SEND_SPEED_LARGE':'','CURLCLOSEPOLICY_LEAST_RECENTLY_USED':'','CURLCLOSEPOLICY_LEAST_TRAFFIC':'','CURLCLOSEPOLICY_SLOWEST':'','CURLCLOSEPOLICY_CALLBACK':'','CURLCLOSEPOLICY_OLDEST':'','CURLINFO_PRIVATE':'','CURLINFO_EFFECTIVE_URL':'','CURLINFO_HTTP_CODE':'','CURLINFO_HEADER_OUT':'','CURLINFO_HEADER_SIZE':'','CURLINFO_REQUEST_SIZE':'','CURLINFO_TOTAL_TIME':'','CURLINFO_NAMELOOKUP_TIME':'','CURLINFO_CONNECT_TIME':'','CURLINFO_PRETRANSFER_TIME':'','CURLINFO_SIZE_UPLOAD':'','CURLINFO_SIZE_DOWNLOAD':'','CURLINFO_SPEED_DOWNLOAD':'','CURLINFO_SPEED_UPLOAD':'','CURLINFO_FILETIME':'','CURLINFO_SSL_VERIFYRESULT':'','CURLINFO_CONTENT_LENGTH_DOWNLOAD':'','CURLINFO_CONTENT_LENGTH_UPLOAD':'','CURLINFO_STARTTRANSFER_TIME':'','CURLINFO_CONTENT_TYPE':'','CURLINFO_REDIRECT_TIME':'','CURLINFO_REDIRECT_COUNT':'','CURL_TIMECOND_IFMODSINCE':'','CURL_TIMECOND_IFUNMODSINCE':'','CURL_TIMECOND_LASTMOD':'','CURL_VERSION_IPV6':'','CURL_VERSION_KERBEROS4':'','CURL_VERSION_SSL':'','CURL_VERSION_LIBZ':'','CURLVERSION_NOW':'','CURLE_OK':'','CURLE_UNSUPPORTED_PROTOCOL':'','CURLE_FAILED_INIT':'','CURLE_URL_MALFORMAT':'','CURLE_URL_MALFORMAT_USER':'','CURLE_COULDNT_RESOLVE_PROXY':'','CURLE_COULDNT_RESOLVE_HOST':'','CURLE_COULDNT_CONNECT':'','CURLE_FTP_WEIRD_SERVER_REPLY':'','CURLE_FTP_ACCESS_DENIED':'','CURLE_FTP_USER_PASSWORD_INCORRECT':'','CURLE_FTP_WEIRD_PASS_REPLY':'','CURLE_FTP_WEIRD_USER_REPLY':'','CURLE_FTP_WEIRD_PASV_REPLY':'','CURLE_FTP_WEIRD_227_FORMAT':'','CURLE_FTP_CANT_GET_HOST':'','CURLE_FTP_CANT_RECONNECT':'','CURLE_FTP_COULDNT_SET_BINARY':'','CURLE_PARTIAL_FILE':'','CURLE_FTP_COULDNT_RETR_FILE':'','CURLE_FTP_WRITE_ERROR':'','CURLE_FTP_QUOTE_ERROR':'','CURLE_HTTP_NOT_FOUND':'','CURLE_WRITE_ERROR':'','CURLE_MALFORMAT_USER':'','CURLE_FTP_COULDNT_STOR_FILE':'','CURLE_READ_ERROR':'','CURLE_OUT_OF_MEMORY':'','CURLE_OPERATION_TIMEOUTED':'','CURLE_FTP_COULDNT_SET_ASCII':'','CURLE_FTP_PORT_FAILED':'','CURLE_FTP_COULDNT_USE_REST':'','CURLE_FTP_COULDNT_GET_SIZE':'','CURLE_HTTP_RANGE_ERROR':'','CURLE_HTTP_POST_ERROR':'','CURLE_SSL_CONNECT_ERROR':'','CURLE_FTP_BAD_DOWNLOAD_RESUME':'','CURLE_FILE_COULDNT_READ_FILE':'','CURLE_LDAP_CANNOT_BIND':'','CURLE_LDAP_SEARCH_FAILED':'','CURLE_LIBRARY_NOT_FOUND':'','CURLE_FUNCTION_NOT_FOUND':'','CURLE_ABORTED_BY_CALLBACK':'','CURLE_BAD_FUNCTION_ARGUMENT':'','CURLE_BAD_CALLING_ORDER':'','CURLE_HTTP_PORT_FAILED':'','CURLE_BAD_PASSWORD_ENTERED':'','CURLE_TOO_MANY_REDIRECTS':'','CURLE_UNKNOWN_TELNET_OPTION':'','CURLE_TELNET_OPTION_SYNTAX':'','CURLE_OBSOLETE':'','CURLE_SSL_PEER_CERTIFICATE':'','CURLE_GOT_NOTHING':'','CURLE_SSL_ENGINE_NOTFOUND':'','CURLE_SSL_ENGINE_SETFAILED':'','CURLE_SEND_ERROR':'','CURLE_RECV_ERROR':'','CURLE_SHARE_IN_USE':'','CURLE_SSL_CERTPROBLEM':'','CURLE_SSL_CIPHER':'','CURLE_SSL_CACERT':'','CURLE_BAD_CONTENT_ENCODING':'','CURLE_LDAP_INVALID_URL':'','CURLE_FILESIZE_EXCEEDED':'','CURLE_FTP_SSL_FAILED':'','CURLFTPAUTH_DEFAULT':'','CURLFTPAUTH_SSL':'','CURLFTPAUTH_TLS':'','CURLPROXY_HTTP':'','CURLPROXY_SOCKS5':'','CURL_NETRC_OPTIONAL':'','CURL_NETRC_IGNORED':'','CURL_NETRC_REQUIRED':'','CURL_HTTP_VERSION_NONE':'','CURL_HTTP_VERSION_1_0':'','CURL_HTTP_VERSION_1_1':'','CURLM_CALL_MULTI_PERFORM':'','CURLM_OK':'','CURLM_BAD_HANDLE':'','CURLM_BAD_EASY_HANDLE':'','CURLM_OUT_OF_MEMORY':'','CURLM_INTERNAL_ERROR':'','CURLMSG_DONE':'','CURLOPT_KEYPASSWD':'','CURLOPT_SSH_AUTH_TYPES':'','CURLOPT_SSH_HOST_PUBLIC_KEY_MD5':'','CURLOPT_SSH_PRIVATE_KEYFILE':'','CURLOPT_SSH_PUBLIC_KEYFILE':'','CURLMOPT_PIPELINING':'','CURLMOPT_MAXCONNECTS':'','CURLSSH_AUTH_ANY':'','CURLSSH_AUTH_DEFAULT':'','CURLSSH_AUTH_HOST':'','CURLSSH_AUTH_KEYBOARD':'','CURLSSH_AUTH_NONE':'','CURLSSH_AUTH_PASSWORD':'','CURLSSH_AUTH_PUBLICKEY':'','CURL_WRAPPERS_ENABLED':'','CURLPAUSE_ALL':'','CURLPAUSE_CONT':'','CURLPAUSE_RECV':'','CURLPAUSE_RECV_CONT':'','CURLPAUSE_SEND':'','CURLPAUSE_SEND_CONT':'','CURLM_XXX':'','CURLOPT_CERTINFO':'','CURLOPT_CONNECT_ONLY':'','CURLINFO_':'','CURLOPT_PROTOCOLS':'','CURLOPT_REDIR_PROTOCOLS':'','CURLOPT_IPRESOLVE':'','CURL_IPRESOLVE_WHATEVER':'','CURL_IPRESOLVE_V4':'','CURL_IPRESOLVE_V6':'','CURLOPT_SHARE':'','CURLSHOPT_SHARE':'','CURLSHOPT_UNSHARE':'','CURL_LOCK_DATA_COOKIE':'','CURL_LOCK_DATA_DNS':'','CURL_LOCK_DATA_SSL_SESSION':'',}
+let php_builtin['constants']['date_time']={'DATE_ATOM':'','DATE_COOKIE':'','DATE_ISO8601':'','DATE_RFC822':'','DATE_RFC850':'','DATE_RFC1036':'','DATE_RFC1123':'','DATE_RFC2822':'','DATE_RFC3339':'','DATE_RSS':'','DATE_W3C':'','SUNFUNCS_RET_TIMESTAMP':'','SUNFUNCS_RET_STRING':'','SUNFUNCS_RET_DOUBLE':'','LC_TIME':'',}
+let php_builtin['constants']['libxml']={'LIBXML_ERR_WARNING':'','LIBXML_ERR_ERROR':'','LIBXML_ERR_FATAL':'','LIBXML_NONET':'','LIBXML_COMPACT':'','LIBXML_DTDATTR':'','LIBXML_DTDLOAD':'','LIBXML_DTDVALID':'','LIBXML_HTML_NOIMPLIED':'','LIBXML_HTML_NODEFDTD':'','LIBXML_NOBLANKS':'','LIBXML_NOCDATA':'','LIBXML_NOEMPTYTAG':'','LIBXML_NOENT':'','LIBXML_NOERROR':'','LIBXML_NOWARNING':'','LIBXML_NOXMLDECL':'','LIBXML_NSCLEAN':'','LIBXML_PARSEHUGE':'','LIBXML_PEDANTIC':'','LIBXML_XINCLUDE':'','LIBXML_ERR_NONE':'','LIBXML_VERSION':'','LIBXML_DOTTED_VERSION':'','LIBXML_SCHEMA_CREATE':'',}
+let php_builtin['constants']['mysqli']={'MYSQLI_REPORT_OFF':'','MYSQLI_REPORT_ALL':'','MYSQLI_REPORT_STRICT':'','MYSQLI_REPORT_ERROR':'','MYSQLI_REPORT_INDEX':'','MYSQLI_ASSOC':'','MYSQLI_NUM':'','MYSQLI_BOTH':'','PHP_INT_MAX':'','MYSQLI_READ_DEFAULT_GROUP':'','MYSQLI_READ_DEFAULT_FILE':'','MYSQLI_OPT_CONNECT_TIMEOUT':'','MYSQLI_OPT_LOCAL_INFILE':'','MYSQLI_INIT_COMMAND':'','MYSQLI_CLIENT_SSL':'','MYSQLI_CLIENT_COMPRESS':'','MYSQLI_CLIENT_INTERACTIVE':'','MYSQLI_CLIENT_IGNORE_SPACE':'','MYSQLI_CLIENT_NO_SCHEMA':'','MYSQLI_CLIENT_MULTI_QUERIES':'','MYSQLI_STORE_RESULT':'','MYSQLI_USE_RESULT':'','MYSQLI_NOT_NULL_FLAG':'','MYSQLI_PRI_KEY_FLAG':'','MYSQLI_UNIQUE_KEY_FLAG':'','MYSQLI_MULTIPLE_KEY_FLAG':'','MYSQLI_BLOB_FLAG':'','MYSQLI_UNSIGNED_FLAG':'','MYSQLI_ZEROFILL_FLAG':'','MYSQLI_AUTO_INCREMENT_FLAG':'','MYSQLI_TIMESTAMP_FLAG':'','MYSQLI_SET_FLAG':'','MYSQLI_NUM_FLAG':'','MYSQLI_PART_KEY_FLAG':'','MYSQLI_GROUP_FLAG':'','MYSQLI_TYPE_DECIMAL':'','MYSQLI_TYPE_NEWDECIMAL':'','MYSQLI_TYPE_BIT':'','MYSQLI_TYPE_TINY':'','MYSQLI_TYPE_SHORT':'','MYSQLI_TYPE_LONG':'','MYSQLI_TYPE_FLOAT':'','MYSQLI_TYPE_DOUBLE':'','MYSQLI_TYPE_NULL':'','MYSQLI_TYPE_TIMESTAMP':'','MYSQLI_TYPE_LONGLONG':'','MYSQLI_TYPE_INT24':'','MYSQLI_TYPE_DATE':'','MYSQLI_TYPE_TIME':'','MYSQLI_TYPE_DATETIME':'','MYSQLI_TYPE_YEAR':'','MYSQLI_TYPE_NEWDATE':'','MYSQLI_TYPE_INTERVAL':'','MYSQLI_TYPE_ENUM':'','MYSQLI_TYPE_SET':'','MYSQLI_TYPE_TINY_BLOB':'','MYSQLI_TYPE_MEDIUM_BLOB':'','MYSQLI_TYPE_LONG_BLOB':'','MYSQLI_TYPE_BLOB':'','MYSQLI_TYPE_VAR_STRING':'','MYSQLI_TYPE_STRING':'','MYSQLI_TYPE_CHAR':'','MYSQLI_TYPE_GEOMETRY':'','MYSQLI_NEED_DATA':'','MYSQLI_NO_DATA':'','MYSQLI_DATA_TRUNCATED':'','MYSQLI_ENUM_FLAG':'','MYSQLI_BINARY_FLAG':'','MYSQLI_CURSOR_TYPE_FOR_UPDATE':'','MYSQLI_CURSOR_TYPE_NO_CURSOR':'','MYSQLI_CURSOR_TYPE_READ_ONLY':'','MYSQLI_CURSOR_TYPE_SCROLLABLE':'','MYSQLI_STMT_ATTR_CURSOR_TYPE':'','MYSQLI_STMT_ATTR_PREFETCH_ROWS':'','MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH':'','MYSQLI_SET_CHARSET_NAME':'','MYSQLI_DEBUG_TRACE_ENABLED':'','MYSQLI_SERVER_QUERY_NO_GOOD_INDEX_USED':'','MYSQLI_SERVER_QUERY_NO_INDEX_USED':'','MYSQLI_REFRESH_GRANT':'','MYSQLI_REFRESH_LOG':'','MYSQLI_REFRESH_TABLES':'','MYSQLI_REFRESH_HOSTS':'','MYSQLI_REFRESH_STATUS':'','MYSQLI_REFRESH_THREADS':'','MYSQLI_REFRESH_SLAVE':'','MYSQLI_REFRESH_MASTER':'','MYSQLI_TRANS_COR_AND_CHAIN':'','MYSQLI_TRANS_COR_AND_NO_CHAIN':'','MYSQLI_TRANS_COR_RELEASE':'','MYSQLI_TRANS_COR_NO_RELEASE':'','MYSQL_READ_DEFAULT_FILE':'','MYSQLI_SERVER_PUBLIC_KEY':'','MYSQLI_NO_CHANGE_USER_ON_PCONNECT':'','MYSQLI_ASYNC':'','MYSQLI_OPT_INT_AND_FLOAT_NATIVE':'','MYSQLI_CLIENT_FOUND_ROWS':'','MULTI_STATEMENT':'','MYSQLI_RPL_MASTER':'','MYSQLI_RPL_SLAVE':'','MYSQLI_RPL_ADMIN':'',}
+let php_builtin['constants']['spl']={'READ_AHEAD':'','MIT_NEED_ALL':'','MIT_KEYS_ASSOC':'','CALL_TOSTRING':'','CATCH_GET_CHILD':'','RIT_LEAVES_ONLY':'','LOCK_SH':'','LOCK_EX':'','LOCK_UN':'','LOCK_NB':'','SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','PHP_INT_MAX':'',}
+let php_builtin['constants']['unknow']={'PHP_INI_ALL':'','PHP_INI_PERDIR':'','PHP_INI_SYSTEM':'','PHP_INI_USER':'','COUNTER_FLAG_PERSIST':'','COUNTER_FLAG_SAVE':'','COUNTER_FLAG_NO_OVERWRITE':'','COUNTER_META_NAME':'','COUNTER_META_IS_PERISTENT':'','COUNTER_RESET_NEVER':'','COUNTER_RESET_PER_LOAD':'','COUNTER_RESET_PER_REQUEST':'','PDO_PLACEHOLDER_NAMED':'','PDO_PLACEHOLDER_POSITIONAL':'','PDO_PLACEHOLDER_NONE':'','PDO_CASE_NATURAL':'','PDO_CASE_UPPER':'','PDO_CASE_LOWER':'','PDO_ATTR_CASE':'','PHP_COUNTER_API':'','PHPAPI':'','COMPILE_DL_COUNTER':'','ZEND_GET_MODULE':'','HAVE_COUNTER':'','COUNTER_G':'','TSRMLS_DC':'','TSRMLS_FETCH':'','STANDARD_MODULE_HEADER':'','STANDARD_MODULE_HEADER_EX':'','STANDARD_MODULE_PROPERTIES':'','STANDARD_MODULE_PROPERTIES_EX':'','ZEND_MODULE_API_NO':'','ZEND_DEBUG':'','USING_ZTS':'','NO_VERSION_YET':'','NO_MODULE_GLOBALS':'','PHP_MODULE_GLOBALS':'','IGNORE_PATH':'','USE_PATH':'','IGNORE_URL':'','IGNORE_URL_WIN':'','ENFORCE_SAFE_MODE':'','REPORT_ERRORS':'','STREAM_MUST_SEEK':'','STREAM_WILL_CAST':'',}
+let php_builtin['constants']['directories']={'DIRECTORY_SEPARATOR':'','PATH_SEPARATOR':'','SCANDIR_SORT_ASCENDING':'','SCANDIR_SORT_DESCENDING':'','SCANDIR_SORT_NONE':'',}
+let php_builtin['constants']['dom']={'XML_ELEMENT_NODE':'','XML_ATTRIBUTE_NODE':'','XML_TEXT_NODE':'','XML_CDATA_SECTION_NODE':'','XML_ENTITY_REF_NODE':'','XML_ENTITY_NODE':'','XML_PI_NODE':'','XML_COMMENT_NODE':'','XML_DOCUMENT_NODE':'','XML_DOCUMENT_TYPE_NODE':'','XML_DOCUMENT_FRAG_NODE':'','XML_NOTATION_NODE':'','XML_HTML_DOCUMENT_NODE':'','XML_DTD_NODE':'','XML_ELEMENT_DECL_NODE':'','XML_ATTRIBUTE_DECL_NODE':'','XML_ENTITY_DECL_NODE':'','XML_NAMESPACE_DECL_NODE':'','XML_ATTRIBUTE_CDATA':'','XML_ATTRIBUTE_ID':'','XML_ATTRIBUTE_IDREF':'','XML_ATTRIBUTE_IDREFS':'','XML_ATTRIBUTE_ENTITY':'','XML_ATTRIBUTE_NMTOKEN':'','XML_ATTRIBUTE_NMTOKENS':'','XML_ATTRIBUTE_ENUMERATION':'','XML_ATTRIBUTE_NOTATION':'','DOM_PHP_ERR':'','DOM_INDEX_SIZE_ERR':'','DOMSTRING_SIZE_ERR':'','DOM_HIERARCHY_REQUEST_ERR':'','DOM_WRONG_DOCUMENT_ERR':'','DOM_INVALID_CHARACTER_ERR':'','DOM_NO_DATA_ALLOWED_ERR':'','DOM_NO_MODIFICATION_ALLOWED_ERR':'','DOM_NOT_FOUND_ERR':'','DOM_NOT_SUPPORTED_ERR':'','DOM_INUSE_ATTRIBUTE_ERR':'','DOM_INVALID_STATE_ERR':'','DOM_SYNTAX_ERR':'','DOM_INVALID_MODIFICATION_ERR':'','DOM_NAMESPACE_ERR':'','DOM_INVALID_ACCESS_ERR':'','DOM_VALIDATION_ERR':'','DOM_NOT_FOUND_ERROR':'','DOM_NOT_FOUND':'',}
+let php_builtin['constants']['command_line_usage']={'PHP_SAPI':'','STDIN':'','STDOUT':'','STDERR':'',}
+let php_builtin['constants']['handling_file_uploads']={'UPLOAD_ERR_OK':'','UPLOAD_ERR_INI_SIZE':'','UPLOAD_ERR_FORM_SIZE':'','UPLOAD_ERR_PARTIAL':'','UPLOAD_ERR_NO_FILE':'','UPLOAD_ERR_NO_TMP_DIR':'','UPLOAD_ERR_CANT_WRITE':'','UPLOAD_ERR_EXTENSION':'',}
+let php_builtin['constants']['fileinfo']={'FILEINFO_NONE':'','FILEINFO_SYMLINK':'','FILEINFO_MIME_TYPE':'','FILEINFO_MIME_ENCODING':'','FILEINFO_MIME':'','FILEINFO_COMPRESS':'','FILEINFO_DEVICES':'','FILEINFO_CONTINUE':'','FILEINFO_PRESERVE_ATIME':'','FILEINFO_RAW':'',}
+let php_builtin['constants']['filesystem']={'SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','LOCK_SH':'','LOCK_EX':'','LOCK_UN':'','LOCK_NB':'','GLOB_BRACE':'','GLOB_ONLYDIR':'','GLOB_MARK':'','GLOB_NOSORT':'','GLOB_NOCHECK':'','GLOB_NOESCAPE':'','GLOB_AVAILABLE_FLAGS':'','PATHINFO_DIRNAME':'','PATHINFO_BASENAME':'','PATHINFO_EXTENSION':'','PATHINFO_FILENAME':'','FILE_USE_INCLUDE_PATH':'','FILE_NO_DEFAULT_CONTEXT':'','FILE_APPEND':'','FILE_IGNORE_NEW_LINES':'','FILE_SKIP_EMPTY_LINES':'','FILE_BINARY':'','FILE_TEXT':'','INI_SCANNER_NORMAL':'','INI_SCANNER_RAW':'','FNM_NOESCAPE':'','FNM_PATHNAME':'','FNM_PERIOD':'','FNM_CASEFOLD':'','GLOB_ERR':'',}
+let php_builtin['constants']['filter']={'FILTER_FLAG_NO_ENCODE_QUOTES':'','INPUT_POST':'','INPUT_GET':'','INPUT_COOKIE':'','INPUT_ENV':'','INPUT_SERVER':'','INPUT_SESSION':'','INPUT_REQUEST':'','FILTER_FLAG_NONE':'','FILTER_REQUIRE_SCALAR':'','FILTER_REQUIRE_ARRAY':'','FILTER_FORCE_ARRAY':'','FILTER_NULL_ON_FAILURE':'','FILTER_VALIDATE_INT':'','FILTER_VALIDATE_BOOLEAN':'','FILTER_VALIDATE_FLOAT':'','FILTER_VALIDATE_REGEXP':'','FILTER_VALIDATE_URL':'','FILTER_VALIDATE_EMAIL':'','FILTER_VALIDATE_IP':'','FILTER_DEFAULT':'','FILTER_UNSAFE_RAW':'','FILTER_SANITIZE_STRING':'','FILTER_SANITIZE_STRIPPED':'','FILTER_SANITIZE_ENCODED':'','FILTER_SANITIZE_SPECIAL_CHARS':'','FILTER_SANITIZE_EMAIL':'','FILTER_SANITIZE_URL':'','FILTER_SANITIZE_NUMBER_INT':'','FILTER_SANITIZE_NUMBER_FLOAT':'','FILTER_SANITIZE_MAGIC_QUOTES':'','FILTER_CALLBACK':'','FILTER_FLAG_ALLOW_OCTAL':'','FILTER_FLAG_ALLOW_HEX':'','FILTER_FLAG_STRIP_LOW':'','FILTER_FLAG_STRIP_HIGH':'','FILTER_FLAG_ENCODE_LOW':'','FILTER_FLAG_ENCODE_HIGH':'','FILTER_FLAG_ENCODE_AMP':'','FILTER_FLAG_EMPTY_STRING_NULL':'','FILTER_FLAG_ALLOW_FRACTION':'','FILTER_FLAG_ALLOW_THOUSAND':'','FILTER_FLAG_ALLOW_SCIENTIFIC':'','FILTER_FLAG_PATH_REQUIRED':'','FILTER_FLAG_QUERY_REQUIRED':'','FILTER_FLAG_IPV4':'','FILTER_FLAG_IPV6':'','FILTER_FLAG_NO_RES_RANGE':'','FILTER_FLAG_NO_PRIV_RANGE':'','FILTER_SANITIZE_RAW':'','FILTER_SANITIZE_FULL_SPECIAL_CHARS':'','ENT_QUOTES':'',}
+let php_builtin['constants']['php_options_info']={'ASSERT_CALLBACK':'','RUSAGE_CHILDREN':'','PHP_SAPI':'','PHP_OS':'','CREDITS_DOCS':'','CREDITS_GENERAL':'','CREDITS_GROUP':'','CREDITS_MODULES':'','CREDITS_FULLPAGE':'','PHP_VERSION_ID':'','PHP_VERSION':'','PATH_SEPARATOR':'','CREDITS_SAPI':'','CREDITS_QA':'','CREDITS_ALL':'','INFO_GENERAL':'','INFO_CREDITS':'','INFO_CONFIGURATION':'','INFO_MODULES':'','INFO_ENVIRONMENT':'','INFO_VARIABLES':'','INFO_LICENSE':'','INFO_ALL':'','ASSERT_ACTIVE':'','ASSERT_BAIL':'','ASSERT_WARNING':'','ASSERT_QUIET_EVAL':'','PHP_WINDOWS_VERSION_MAJOR':'','PHP_WINDOWS_VERSION_MINOR':'','PHP_WINDOWS_VERSION_BUILD':'','PHP_WINDOWS_VERSION_PLATFORM':'','PHP_WINDOWS_VERSION_SP_MAJOR':'','PHP_WINDOWS_VERSION_SP_MINOR':'','PHP_WINDOWS_VERSION_SUITEMASK':'','PHP_WINDOWS_VERSION_PRODUCTTYPE':'','PHP_WINDOWS_NT_DOMAIN_CONTROLLER':'','PHP_WINDOWS_NT_SERVER':'','PHP_WINDOWS_NT_WORKSTATION':'',}
+let php_builtin['constants']['strings']={'CRYPT_SALT_LENGTH':'','CRYPT_STD_DES':'','CRYPT_EXT_DES':'','CRYPT_MD5':'','CRYPT_BLOWFISH':'','CRYPT_SHA256':'','CRYPT_SHA512':'','HTML_ENTITIES':'','HTML_SPECIALCHARS':'','ENT_COMPAT':'','ENT_QUOTES':'','ENT_NOQUOTES':'','ENT_HTML401':'','ENT_XML1':'','ENT_XHTML':'','ENT_HTML5':'','ENT_IGNORE':'','ENT_SUBSTITUTE':'','ENT_DISALLOWED':'','CHAR_MAX':'','LC_MONETARY':'','AM_STR':'','PM_STR':'','D_T_FMT':'','D_FMT':'','T_FMT':'','T_FMT_AMPM':'','ERA':'','ERA_YEAR':'','ERA_D_T_FMT':'','ERA_D_FMT':'','ERA_T_FMT':'','INT_CURR_SYMBOL':'','CURRENCY_SYMBOL':'','CRNCYSTR':'','MON_DECIMAL_POINT':'','MON_THOUSANDS_SEP':'','MON_GROUPING':'','POSITIVE_SIGN':'','NEGATIVE_SIGN':'','INT_FRAC_DIGITS':'','FRAC_DIGITS':'','P_CS_PRECEDES':'','P_SEP_BY_SPACE':'','N_CS_PRECEDES':'','N_SEP_BY_SPACE':'','P_SIGN_POSN':'','N_SIGN_POSN':'','DECIMAL_POINT':'','RADIXCHAR':'','THOUSANDS_SEP':'','THOUSEP':'','GROUPING':'','YESEXPR':'','NOEXPR':'','YESSTR':'','NOSTR':'','CODESET':'','LC_ALL':'','LC_COLLATE':'','LC_CTYPE':'','LC_NUMERIC':'','LC_TIME':'','LC_MESSAGES':'','PHP_INT_MAX':'','STR_PAD_RIGHT':'','STR_PAD_LEFT':'','STR_PAD_BOTH':'',}
+let php_builtin['constants']['error_handling']={'DEBUG_BACKTRACE_PROVIDE_OBJECT':'','DEBUG_BACKTRACE_IGNORE_ARGS':'',}
+let php_builtin['constants']['math']={'PHP_INT_MAX':'','M_PI':'','PHP_ROUND_HALF_UP':'','PHP_ROUND_HALF_DOWN':'','PHP_ROUND_HALF_EVEN':'','PHP_ROUND_HALF_ODD':'','M_E':'','M_LOG2E':'','M_LOG10E':'','M_LN2':'','M_LN10':'','M_PI_2':'','M_PI_4':'','M_1_PI':'','M_2_PI':'','M_SQRTPI':'','M_2_SQRTPI':'','M_SQRT2':'','M_SQRT3':'','M_SQRT1_2':'','M_LNPI':'','M_EULER':'','NAN':'','INF':'',}
+let php_builtin['constants']['network']={'LOG_EMERG':'','LOG_ALERT':'','LOG_CRIT':'','LOG_ERR':'','LOG_WARNING':'','LOG_NOTICE':'','LOG_INFO':'','LOG_DEBUG':'','LOG_KERN':'','LOG_USER':'','LOG_MAIL':'','LOG_DAEMON':'','LOG_AUTH':'','LOG_SYSLOG':'','LOG_LPR':'','LOG_NEWS':'','LOG_CRON':'','LOG_AUTHPRIV':'','LOG_LOCAL0':'','LOG_LOCAL1':'','LOG_LOCAL2':'','LOG_LOCAL3':'','LOG_LOCAL4':'','LOG_LOCAL5':'','LOG_LOCAL6':'','LOG_LOCAL7':'','LOG_PID':'','LOG_CONS':'','LOG_ODELAY':'','LOG_NDELAY':'','LOG_NOWAIT':'','LOG_PERROR':'','DNS_A':'','DNS_CNAME':'','DNS_HINFO':'','DNS_MX':'','DNS_NS':'','DNS_PTR':'','DNS_SOA':'','DNS_TXT':'','DNS_AAAA':'','DNS_SRV':'','DNS_NAPTR':'','DNS_A6':'','DNS_ALL':'','DNS_ANY':'','SID':'','LOG_UUCP':'',}
+let php_builtin['constants']['urls']={'PHP_QUERY_RFC1738':'','PHP_QUERY_RFC3986':'','PHP_URL_SCHEME':'','PHP_URL_HOST':'','PHP_URL_PORT':'','PHP_URL_USER':'','PHP_URL_PASS':'','PHP_URL_PATH':'','PHP_URL_QUERY':'','PHP_URL_FRAGMENT':'',}
+let php_builtin['constants']['gd']={'IMAGETYPE_GIF':'','IMAGETYPE_JPEG':'','IMAGETYPE_PNG':'','IMAGETYPE_SWF':'','IMAGETYPE_PSD':'','IMAGETYPE_BMP':'','IMAGETYPE_TIFF_II':'','IMAGETYPE_TIFF_MM':'','IMAGETYPE_JPC':'','IMAGETYPE_JP2':'','IMAGETYPE_JPX':'','IMAGETYPE_JB2':'','IMAGETYPE_SWC':'','IMAGETYPE_IFF':'','IMAGETYPE_WBMP':'','IMAGETYPE_XBM':'','IMAGETYPE_ICO':'','IMG_CROP_THRESHOLD':'','IMG_ARC_PIE':'','IMG_ARC_CHORD':'','IMG_ARC_NOFILL':'','IMG_ARC_EDGED':'','IMG_FILTER_NEGATE':'','IMG_FILTER_GRAYSCALE':'','IMG_FILTER_BRIGHTNESS':'','IMG_FILTER_CONTRAST':'','IMG_FILTER_COLORIZE':'','IMG_FILTER_EDGEDETECT':'','IMG_FILTER_EMBOSS':'','IMG_FILTER_GAUSSIAN_BLUR':'','IMG_FILTER_SELECTIVE_BLUR':'','IMG_FILTER_MEAN_REMOVAL':'','IMG_FILTER_SMOOTH':'','IMG_FILTER_PIXELATE':'','IMG_FLIP_HORIZONTAL':'','IMG_FLIP_VERTICAL':'','IMG_FLIP_BOTH':'','IMG_GD2_RAW':'','IMG_GD2_COMPRESSED':'','IMG_EFFECT_REPLACE':'','IMG_EFFECT_ALPHABLEND':'','IMG_EFFECT_NORMAL':'','IMG_EFFECT_OVERLAY':'','PNG_NO_FILTER':'','PNG_ALL_FILTERS':'','IMG_NEAREST_NEIGHBOUR':'','IMG_BILINEAR_FIXED':'','IMG_BICUBIC':'','IMG_BICUBIC_FIXED':'','IMG_COLOR_BRUSHED':'','IMG_COLOR_STYLEDBRUSHED':'','IMG_BELL':'','IMG_BESSEL':'','IMG_BLACKMAN':'','IMG_BOX':'','IMG_BSPLINE':'','IMG_CATMULLROM':'','IMG_GAUSSIAN':'','IMG_GENERALIZED_CUBIC':'','IMG_HERMITE':'','IMG_HAMMING':'','IMG_HANNING':'','IMG_MITCHELL':'','IMG_POWER':'','IMG_QUADRATIC':'','IMG_SINC':'','IMG_WEIGHTED4':'','IMG_TRIANGLE':'','IMG_COLOR_STYLED':'','IMG_COLOR_TRANSPARENT':'','IMG_COLOR_TILED':'','IMG_GIF':'','IMG_JPG':'','IMG_PNG':'','IMG_WBMP':'','IMG_XPM':'','GD_VERSION':'','GD_MAJOR_VERSION':'','GD_MINOR_VERSION':'','GD_RELEASE_VERSION':'','GD_EXTRA_VERSION':'','GD_BUNDLED':'','IMG_JPEG':'','IMG_ARC_ROUNDED':'','IMAGETYPE_JPEG2000':'','PNG_FILTER_NONE':'','PNG_FILTER_SUB':'','PNG_FILTER_UP':'','PNG_FILTER_AVG':'','PNG_FILTER_PAETH':'',}
+let php_builtin['constants']['json']={'JSON_BIGINT_AS_STRING':'','JSON_HEX_QUOT':'','JSON_HEX_TAG':'','JSON_HEX_AMP':'','JSON_HEX_APOS':'','JSON_NUMERIC_CHECK':'','JSON_PRETTY_PRINT':'','JSON_UNESCAPED_SLASHES':'','JSON_FORCE_OBJECT':'','JSON_UNESCAPED_UNICODE':'','JSON_ERROR_NONE':'','JSON_ERROR_DEPTH':'','JSON_ERROR_STATE_MISMATCH':'','JSON_ERROR_CTRL_CHAR':'','JSON_ERROR_SYNTAX':'','JSON_ERROR_UTF8':'','JSON_ERROR_RECURSION':'','JSON_ERROR_INF_OR_NAN':'','NAN':'','INF':'','JSON_ERROR_UNSUPPORTED_TYPE':'','JSON_PARTIAL_OUTPUT_ON_ERROR':'',}
+let php_builtin['constants']['multibyte_string']={'MB_CASE_UPPER':'','MB_CASE_LOWER':'','MB_CASE_TITLE':'','MB_OVERLOAD_MAIL':'','MB_OVERLOAD_STRING':'','MB_OVERLOAD_REGEX':'',}
+let php_builtin['constants']['mssql']={'SQLTEXT':'','SQLVARCHAR':'','SQLCHAR':'','SQLINT1':'','SQLINT2':'','SQLINT4':'','SQLBIT':'','SQLFLT4':'','SQLFLT8':'','SQLFLTN':'','MSSQL_ASSOC':'','MSSQL_NUM':'','MSSQL_BOTH':'',}
+let php_builtin['constants']['mysql']={'MYSQL_CLIENT_SSL':'','MYSQL_CLIENT_COMPRESS':'','MYSQL_CLIENT_IGNORE_SPACE':'','MYSQL_CLIENT_INTERACTIVE':'','MYSQL_ASSOC':'','MYSQL_NUM':'','MYSQL_BOTH':'','MYSQL_PORT':'',}
+let php_builtin['constants']['output_control']={'PHP_OUTPUT_HANDLER_STDFLAGS':'','PHP_OUTPUT_HANDLER_CLEANABLE':'','PHP_OUTPUT_HANDLER_FLUSHABLE':'','PHP_OUTPUT_HANDLER_REMOVABLE':'','PHP_OUTPUT_HANDLER_START':'','PHP_OUTPUT_HANDLER_WRITE':'','PHP_OUTPUT_HANDLER_FLUSH':'','PHP_OUTPUT_HANDLER_CLEAN':'','PHP_OUTPUT_HANDLER_FINAL':'','PHP_OUTPUT_HANDLER_CONT':'','PHP_OUTPUT_HANDLER_END':'',}
+let php_builtin['constants']['password_hashing']={'PASSWORD_DEFAULT':'','PASSWORD_BCRYPT':'','CRYPT_BLOWFISH':'',}
+let php_builtin['constants']['postgresql']={'PGSQL_CONNECT_FORCE_NEW':'','PGSQL_CONNECTION_OK':'','PGSQL_CONNECTION_BAD':'','PGSQL_CONV_IGNORE_DEFAULT':'','PGSQL_CONV_FORCE_NULL':'','PGSQL_CONV_IGNORE_NOT_NULL':'','PGSQL_DML_NO_CONV':'','PGSQL_DML_ESCAPE':'','PGSQL_DML_EXEC':'','PGSQL_DML_ASYNC':'','PGSQL_DML_STRING':'','PGSQL_ASSOC':'','PGSQL_NUM':'','PGSQL_BOTH':'','PGSQL_CONV_OPTS':'','INV_READ':'','INV_WRITE':'','INV_ARCHIVE':'','PGSQL_SEEK_SET':'','PGSQL_SEEK_CUR':'','PGSQL_SEEK_END':'','PGSQL_DIAG_SEVERITY':'','PGSQL_DIAG_SQLSTATE':'','PGSQL_DIAG_MESSAGE_PRIMARY':'','PGSQL_DIAG_MESSAGE_DETAIL':'','PGSQL_DIAG_MESSAGE_HINT':'','PGSQL_DIAG_STATEMENT_POSITION':'','PGSQL_DIAG_INTERNAL_POSITION':'','PGSQL_DIAG_INTERNAL_QUERY':'','PGSQL_DIAG_CONTEXT':'','PGSQL_DIAG_SOURCE_FILE':'','PGSQL_DIAG_SOURCE_LINE':'','PGSQL_DIAG_SOURCE_FUNCTION':'','PGSQL_STATUS_LONG':'','PGSQL_STATUS_STRING':'','PGSQL_EMPTY_QUERY':'','PGSQL_COMMAND_OK':'','PGSQL_TUPLES_OK':'','PGSQL_COPY_OUT':'','PGSQL_COPY_IN':'','PGSQL_BAD_RESPONSE':'','PGSQL_NONFATAL_ERROR':'','PGSQL_FATAL_ERROR':'','PGSQL_ERRORS_TERSE':'','PGSQL_ERRORS_DEFAULT':'','PGSQL_ERRORS_VERBOSE':'','PGSQL_TRANSACTION_IDLE':'','PGSQL_TRANSACTION_ACTIVE':'','PGSQL_TRANSACTION_INTRANS':'','PGSQL_TRANSACTION_INERROR':'','PGSQL_TRANSACTION_UNKNOWN':'','PG_DIAG_STATEMENT_POSITION':'','PG_DIAG_INTERNAL_QUERY':'',}
+let php_builtin['constants']['pcre']={'PREG_GREP_INVERT':'','PREG_NO_ERROR':'','PREG_INTERNAL_ERROR':'','PREG_BACKTRACK_LIMIT_ERROR':'','PREG_RECURSION_LIMIT_ERROR':'','PREG_BAD_UTF8_ERROR':'','PREG_BAD_UTF8_OFFSET_ERROR':'','PREG_PATTERN_ORDER':'','PREG_SET_ORDER':'','PREG_OFFSET_CAPTURE':'','PREG_SPLIT_NO_EMPTY':'','PREG_SPLIT_DELIM_CAPTURE':'','PREG_SPLIT_OFFSET_CAPTURE':'','PCRE_VERSION':'',}
+let php_builtin['constants']['program_execution']={'STDIN':'',}
+let php_builtin['constants']['sessions']={'SID':'','PHP_SESSION_DISABLED':'','PHP_SESSION_NONE':'','PHP_SESSION_ACTIVE':'','UPLOAD_ERR_EXTENSION':'',}
+let php_builtin['constants']['variable_handling']={'PHP_INT_MAX':'',}
+let php_builtin['constants']['misc']={'WAIT_IO_COMPLETION':'','CONNECTION_ABORTED':'','CONNECTION_NORMAL':'','CONNECTION_TIMEOUT':'',}
+let php_builtin['constants']['streams']={'STREAM_FILTER_READ':'','STREAM_FILTER_WRITE':'','STREAM_FILTER_ALL':'','PHP_INT_MAX':'','STREAM_CLIENT_CONNECT':'','STREAM_CLIENT_ASYNC_CONNECT':'','STREAM_CLIENT_PERSISTENT':'','STREAM_CRYPTO_METHOD_TLS_CLIENT':'','STREAM_CRYPTO_METHOD_TLS_SERVER':'','STREAM_PF_INET':'','STREAM_PF_INET6':'','STREAM_PF_UNIX':'','STREAM_SOCK_DGRAM':'','STREAM_SOCK_RAW':'','STREAM_SOCK_RDM':'','STREAM_SOCK_SEQPACKET':'','STREAM_SOCK_STREAM':'','STREAM_IPPROTO_ICMP':'','STREAM_IPPROTO_IP':'','STREAM_IPPROTO_RAW':'','STREAM_IPPROTO_TCP':'','STREAM_IPPROTO_UDP':'','STREAM_OOB':'','STREAM_PEEK':'','AF_INET':'','STREAM_SERVER_BIND':'','STREAM_SHUT_RD':'','STREAM_SHUT_WR':'','STREAM_SHUT_RDWR':'','STREAM_IS_URL':'','PSFS_PASS_ON':'','PSFS_FEED_ME':'','PSFS_ERR_FATAL':'','PSFS_FLAG_NORMAL':'','PSFS_FLAG_FLUSH_INC':'','PSFS_FLAG_FLUSH_CLOSE':'','STREAM_USE_PATH':'','STREAM_REPORT_ERRORS':'','STREAM_SERVER_LISTEN':'','STREAM_NOTIFY_RESOLVE':'','STREAM_NOTIFY_CONNECT':'','STREAM_NOTIFY_AUTH_REQUIRED':'','STREAM_NOTIFY_SEVERITY_ERR':'','STREAM_NOTIFY_MIME_TYPE_IS':'','STREAM_NOTIFY_FILE_SIZE_IS':'','STREAM_NOTIFY_REDIRECTED':'','STREAM_NOTIFY_PROGRESS':'','STREAM_NOTIFY_COMPLETED':'','STREAM_NOTIFY_FAILURE':'','STREAM_NOTIFY_AUTH_RESULT':'','STREAM_NOTIFY_SEVERITY_INFO':'','STREAM_NOTIFY_SEVERITY_WARN':'','STREAM_CAST_FOR_SELECT':'','STREAM_CAST_AS_STREAM':'','STREAM_META_TOUCH':'','STREAM_META_OWNER':'','STREAM_META_OWNER_NAME':'','STREAM_META_GROUP':'','STREAM_META_GROUP_NAME':'','STREAM_META_ACCESS':'','STREAM_MKDIR_RECURSIVE':'','LOCK_EX':'','LOCK_UN':'','LOCK_SH':'','LOCK_NB':'','SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','STREAM_OPTION_BLOCKING':'','STREAM_OPTION_READ_TIMEOUT':'','STREAM_OPTION_WRITE_BUFFER':'','STREAM_BUFFER_NONE':'','STREAM_BUFFER_FULL':'',}
+let php_builtin['constants']['iconv']={'ICONV_IMPL':'','ICONV_VERSION':'','ICONV_MIME_DECODE_STRICT':'','ICONV_MIME_DECODE_CONTINUE_ON_ERROR':'',}
+let php_builtin['constants']['phpini_directives']={'PATH_SEPARATOR':'','PHP_INI_SYSTEM':'',}
+let php_builtin['constants']['types']={'NAN':'','PHP_INT_SIZE':'','PHP_INT_MAX':'',}
+let php_builtin['constants']['pdo']={'PDO_PARAM_BOOL':'',}
+let php_builtin['constants']['list_of_reserved_words']={'PHP_VERSION':'','PHP_MAJOR_VERSION':'','PHP_MINOR_VERSION':'','PHP_RELEASE_VERSION':'','PHP_VERSION_ID':'','PHP_EXTRA_VERSION':'','PHP_ZTS':'','PHP_DEBUG':'','PHP_MAXPATHLEN':'','PHP_OS':'','PHP_SAPI':'','PHP_EOL':'','PHP_INT_MAX':'','PHP_INT_SIZE':'','DEFAULT_INCLUDE_PATH':'','PEAR_INSTALL_DIR':'','PEAR_EXTENSION_DIR':'','PHP_EXTENSION_DIR':'','PHP_PREFIX':'','PHP_BINDIR':'','PHP_BINARY':'','PHP_MANDIR':'','PHP_LIBDIR':'','PHP_DATADIR':'','PHP_SYSCONFDIR':'','PHP_LOCALSTATEDIR':'','PHP_CONFIG_FILE_PATH':'','PHP_CONFIG_FILE_SCAN_DIR':'','PHP_SHLIB_SUFFIX':'',}
+let php_builtin['constants']['php_type_comparison_tables']={'NAN':'',}
+
+" Built in functions
+let g:php_builtin_functions = {}
+for [ext, data] in items(php_builtin['functions'])
+	call extend(g:php_builtin_functions, data)
+endfor
+
+" Built in classs
+let g:php_builtin_classes = {}
+for [ext, data] in items(php_builtin['classes'])
+	call extend(g:php_builtin_classes, data)
+endfor
+
+" Built in interfaces
+let g:php_builtin_interfaces = {}
+for [ext, data] in items(php_builtin['interfaces'])
+	call extend(g:php_builtin_interfaces, data)
+endfor
+
+" Built in constants
+let g:php_constants = {}
+for [ext, data] in items(php_builtin['constants'])
+	call extend(g:php_constants, data)
+endfor
+
+" When the classname not found or found but the tags dosen't contain that
+" class we will try to complate any method of any builtin class. To speed up
+" that lookup we compile a 'ClassName::MethodName':'info' dictionary from the
+" builtin class informations
+let g:php_builtin_object_functions = {}
+
+" When completing for 'everyting imaginable' (no class context, not a
+" variable) we need a list of built-in classes in a format of {'classname':''}
+" for performance reasons we precompile this too
+let g:php_builtin_classnames = {}
+
+" In order to reduce file size, empty keys are omitted from class structures.
+" To make the structure of in-memory hashes normalized we will add them in runtime
+let required_class_hash_keys = ['constants', 'properties', 'static_properties', 'methods', 'static_methods']
+
+for [classname, class_info] in items(g:php_builtin_classes)
+	for property_name in required_class_hash_keys
+		if !has_key(class_info, property_name)
+			let class_info[property_name] = {}
+		endif
+	endfor
+
+	let g:php_builtin_classnames[classname] = ''
+	for [method_name, method_info] in items(class_info.methods)
+		let g:php_builtin_object_functions[classname.'::'.method_name.'('] = method_info.signature
+	endfor
+	for [method_name, method_info] in items(class_info.static_methods)
+		let g:php_builtin_object_functions[classname.'::'.method_name.'('] = method_info.signature
+	endfor
+endfor
+
+let g:php_builtin_interfacenames = {}
+for [interfacename, info] in items(g:php_builtin_interfaces)
+	for property_name in required_class_hash_keys
+		if !has_key(class_info, property_name)
+			let class_info[property_name] = {}
+		endif
+	endfor
+
+	let g:php_builtin_interfacenames[interfacename] = ''
+	for [method_name, method_info] in items(class_info.methods)
+		let g:php_builtin_object_functions[interfacename.'::'.method_name.'('] = method_info.signature
+	endfor
+	for [method_name, method_info] in items(class_info.static_methods)
+		let g:php_builtin_object_functions[interfacename.'::'.method_name.'('] = method_info.signature
+	endfor
+endfor
+
+
+" Add control structures (they are outside regular pattern of PHP functions)
+let php_control = {
+			\ 'include(': 'string filename | resource',
+			\ 'include_once(': 'string filename | resource',
+			\ 'require(': 'string filename | resource',
 			\ 'require_once(': 'string filename | resource',
 			\ }
 call extend(g:php_builtin_functions, php_control)
+
+
+" Built-in variables " {{{
+let g:php_builtin_vars ={
+			\ '$GLOBALS':'',
+			\ '$_SERVER':'',
+			\ '$_GET':'',
+			\ '$_POST':'',
+			\ '$_COOKIE':'',
+			\ '$_FILES':'',
+			\ '$_ENV':'',
+			\ '$_REQUEST':'',
+			\ '$_SESSION':'',
+			\ '$HTTP_SERVER_VARS':'',
+			\ '$HTTP_ENV_VARS':'',
+			\ '$HTTP_COOKIE_VARS':'',
+			\ '$HTTP_GET_VARS':'',
+			\ '$HTTP_POST_VARS':'',
+			\ '$HTTP_POST_FILES':'',
+			\ '$HTTP_SESSION_VARS':'',
+			\ '$php_errormsg':'',
+			\ '$this':'',
+			\ }
+" }}}
 endfunction
 " }}}
-" vim:set foldmethod=marker:
+
+" vim: foldmethod=marker:noexpandtab:ts=8:sts=4
diff -Naur vim74.orig/runtime/colors/README.txt vim74/runtime/colors/README.txt
--- vim74.orig/runtime/colors/README.txt	2010-05-15 11:03:31.000000000 +0000
+++ vim74/runtime/colors/README.txt	2014-10-10 14:53:39.915391679 +0000
@@ -36,6 +36,14 @@
 removed in your color scheme.  Use something like "gui=NONE" to remove the
 attributes.
 
+In case you want to set 'background' depending on the colorscheme selected,
+this autocmd might be useful:
+     autocmd SourcePre */colors/blue_sky.vim set background=dark
+Replace "blue_sky" with the name of the colorscheme.
+
+In case you want to tweak a colorscheme after it was loaded, check out that
+ColorScheme autocmd event.
+
 To see which highlight group is used where, find the help for
 "highlight-groups" and "group-name".
 
diff -Naur vim74.orig/runtime/colors/delek.vim vim74/runtime/colors/delek.vim
--- vim74.orig/runtime/colors/delek.vim	2010-05-15 11:03:31.000000000 +0000
+++ vim74/runtime/colors/delek.vim	2014-10-10 14:53:39.922058329 +0000
@@ -1,10 +1,10 @@
 " Vim color file
-" Maintainer:	David Schweikert <dws@ee.ethz.ch>
-" Last Change:	2006 Apr 30
+" Maintainer:	David Schweikert <david@schweikert.ch>
+" Last Change:	2014 Mar 19
 
 hi clear
 
-let colors_name = "delek"
+let g:colors_name = "delek"
 
 " Normal should come first
 hi Normal     guifg=Black  guibg=White
@@ -28,7 +28,11 @@
 hi Pmenu      guibg=LightBlue
 hi PmenuSel   ctermfg=White	   ctermbg=DarkBlue  guifg=White  guibg=DarkBlue
 hi Question   ctermfg=DarkGreen    gui=bold guifg=SeaGreen
-hi Search     ctermfg=NONE	   ctermbg=Yellow guibg=Yellow guifg=NONE
+if &background == "light"
+    hi Search     ctermfg=NONE	   ctermbg=Yellow guibg=Yellow guifg=NONE
+else
+    hi Search     ctermfg=Black	   ctermbg=Yellow guibg=Yellow guifg=Black
+endif
 hi SpecialKey ctermfg=DarkBlue	   guifg=Blue
 hi StatusLine cterm=bold	   ctermbg=blue ctermfg=yellow guibg=gold guifg=blue
 hi StatusLineNC	cterm=bold	   ctermbg=blue ctermfg=black  guibg=gold guifg=blue
diff -Naur vim74.orig/runtime/colors/industry.vim vim74/runtime/colors/industry.vim
--- vim74.orig/runtime/colors/industry.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/colors/industry.vim	2014-10-10 14:53:39.928724979 +0000
@@ -0,0 +1,40 @@
+" Vim color file
+" Maintainer:	Shian Lee 
+" Last Change:	2014 Mar 6 (for vim 7.4)
+" Remark:	"industry" stands for 'industrial' color scheme. In industrial
+"		HMI (Human-Machine-Interface) programming, using a standard color
+"               scheme is mandatory in many cases (in traffic-lights for example): 
+"               LIGHT_RED is	    'Warning' 
+"               LIGHT_YELLOW is	    'Attention' 
+"               LIGHT_GREEN is	    'Normal' 
+"               LIGHT_MAGENTA is    'Warning-Attention' (light RED-YELLOW)
+"               LIGHT_CYAN is	    'Attention-Normal'  (light YELLOW-GREEN).
+"               BLACK is	    Dark-High-Contrast Background for maximum safety.
+"               BLUE is		    Shade of BLACK (not supposed to get attention).
+"
+"               Industrial color scheme is by nature clear, safe and productive. 
+"               Yet, depends on the file type's syntax, it might appear incorrect. 
+
+" Reset to dark background, then reset everything to defaults:
+set background=dark
+highlight clear
+if exists("syntax_on")
+    syntax reset
+endif
+
+let colors_name = "industry"
+
+" First set Normal to regular white on black text colors:
+hi Normal ctermfg=LightGray ctermbg=Black guifg=#dddddd	guibg=Black
+
+" Syntax highlighting (other color-groups using default, see :help group-name):
+hi Comment    cterm=NONE ctermfg=DarkCyan    	gui=NONE guifg=#00aaaa   	 
+hi Constant   cterm=NONE ctermfg=LightCyan   	gui=NONE guifg=#00ffff   	
+hi Identifier cterm=NONE ctermfg=LightMagenta   gui=NONE guifg=#ff00ff   
+hi Function   cterm=NONE ctermfg=LightGreen   	gui=NONE guifg=#00ff00   	
+hi Statement  cterm=NONE ctermfg=White	     	gui=bold guifg=#ffffff	     	
+hi PreProc    cterm=NONE ctermfg=Yellow		gui=NONE guifg=#ffff00 	
+hi Type	      cterm=NONE ctermfg=LightGreen	gui=bold guifg=#00ff00 		
+hi Special    cterm=NONE ctermfg=LightRed    	gui=NONE guifg=#ff0000    	
+hi Delimiter  cterm=NONE ctermfg=Yellow    	gui=NONE guifg=#ffff00    	
+
diff -Naur vim74.orig/runtime/compiler/gcc.vim vim74/runtime/compiler/gcc.vim
--- vim74.orig/runtime/compiler/gcc.vim	2011-12-15 20:20:22.000000000 +0000
+++ vim74/runtime/compiler/gcc.vim	2014-10-10 14:53:39.972058203 +0000
@@ -25,10 +25,10 @@
       \%f:%l:\ %tarning:\ %m,
       \%f:%l:\ %m,
       \\"%f\"\\,\ line\ %l%*\\D%c%*[^\ ]\ %m,
-      \%D%*\\a[%*\\d]:\ Entering\ directory\ `%f',
-      \%X%*\\a[%*\\d]:\ Leaving\ directory\ `%f',
-      \%D%*\\a:\ Entering\ directory\ `%f',
-      \%X%*\\a:\ Leaving\ directory\ `%f',
+      \%D%*\\a[%*\\d]:\ Entering\ directory\ [`']%f',
+      \%X%*\\a[%*\\d]:\ Leaving\ directory\ [`']%f',
+      \%D%*\\a:\ Entering\ directory\ [`']%f',
+      \%X%*\\a:\ Leaving\ directory\ [`']%f',
       \%DMaking\ %*\\a\ in\ %f
 
 if exists('g:compiler_gcc_ignore_unmatched_lines')
diff -Naur vim74.orig/runtime/compiler/go.vim vim74/runtime/compiler/go.vim
--- vim74.orig/runtime/compiler/go.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/compiler/go.vim	2014-10-10 14:53:39.985391503 +0000
@@ -0,0 +1,29 @@
+" Vim compiler file
+" Compiler:	Go
+" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
+" Last Change:	2014 Aug 16
+
+if exists('current_compiler')
+  finish
+endif
+let current_compiler = 'go'
+
+if exists(':CompilerSet') != 2
+  command -nargs=* CompilerSet setlocal <args>
+endif
+
+let s:save_cpo = &cpo
+set cpo-=C
+
+CompilerSet makeprg=go\ build
+CompilerSet errorformat=
+    \%-G#\ %.%#,
+    \%A%f:%l:%c:\ %m,
+    \%A%f:%l:\ %m,
+    \%C%*\\s%m,
+    \%-G%.%#
+
+let &cpo = s:save_cpo
+unlet s:save_cpo
+
+" vim: sw=2 sts=2 et
diff -Naur vim74.orig/runtime/compiler/msvc.vim vim74/runtime/compiler/msvc.vim
--- vim74.orig/runtime/compiler/msvc.vim	2010-05-15 11:03:29.000000000 +0000
+++ vim74/runtime/compiler/msvc.vim	2014-10-10 14:53:40.005391453 +0000
@@ -1,7 +1,7 @@
 " Vim compiler file
-" Compiler:	Miscrosoft Visual C
+" Compiler:	Microsoft Visual C
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2005 Nov 30
+" Last Change:	2014 Sep 20
 
 if exists("current_compiler")
   finish
diff -Naur vim74.orig/runtime/doc/autocmd.txt vim74/runtime/doc/autocmd.txt
--- vim74.orig/runtime/doc/autocmd.txt	2013-08-10 11:24:52.000000000 +0000
+++ vim74/runtime/doc/autocmd.txt	2014-10-10 14:53:40.048724677 +0000
@@ -1,4 +1,4 @@
-*autocmd.txt*   For Vim version 7.4.  Last change: 2013 Aug 04
+*autocmd.txt*   For Vim version 7.4.  Last change: 2014 Sep 23
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -278,6 +278,7 @@
 |ShellCmdPost|		after executing a shell command
 |ShellFilterPost|	after filtering with a shell command
 
+|CmdUndefined|		a user command is used but it isn't defined
 |FuncUndefined|		a user function is used but it isn't defined
 |SpellFileMissing|	a spell file is used but it can't be found
 |SourcePre|		before sourcing a Vim script
@@ -304,6 +305,9 @@
 |InsertCharPre|		when a character was typed in Insert mode, before
 			inserting it
 
+|TextChanged|		after a change was made to the text in Normal mode
+|TextChangedI|		after a change was made to the text in Insert mode
+
 |ColorScheme|		after loading a color scheme
 
 |RemoteReply|		a reply from a server Vim was received
@@ -462,6 +466,16 @@
 							*BufWritePost*
 BufWritePost			After writing the whole buffer to a file
 				(should undo the commands for BufWritePre).
+							*CmdUndefined*
+CmdUndefined			When a user command is used but it isn't
+				defined.  Useful for defining a command only
+				when it's used.  The pattern is matched
+				against the command name.  Both <amatch> and
+				<afile> are set to the name of the command.
+				NOTE: Autocompletion won't work until the
+				command is defined.  An alternative is to
+				always define the user command and have it
+				invoke an autoloaded function.  See |autoload|.
 							*CmdwinEnter*
 CmdwinEnter			After entering the command-line window.
 				Useful for setting options specifically for
@@ -480,6 +494,12 @@
 				|cmdwin-char|
 							*ColorScheme*
 ColorScheme			After loading a color scheme. |:colorscheme|
+				The pattern is matched against the
+				colorscheme name. <afile> can be used for the
+				name of the actual file where this option was
+				set, and <amatch> for the new colorscheme
+				name.
+
 
 							*CompleteDone*
 CompleteDone			After Insert mode completion is done.  Either
@@ -499,6 +519,11 @@
 				operator.
 				While recording the CursorHold event is not
 				triggered. |q|
+							*<CursorHold>*
+				Internally the autocommand is triggered by the
+				<CursorHold> key. In an expression mapping
+				|getchar()| may see this character.
+
 				Note: Interactive commands cannot be used for
 				this event.  There is no hit-enter prompt,
 				the screen is updated directly (when needed).
@@ -553,11 +578,15 @@
 				It is not allowed to change to another buffer
 				here.  You can reload the buffer but not edit
 				another one.
+							*E881*
+				If the number of lines changes saving for undo
+				may fail and the change will be aborted.
 							*FileChangedShell*
 FileChangedShell		When Vim notices that the modification time of
 				a file has changed since editing started.
 				Also when the file attributes of the file
-				change. |timestamp|
+				change or when the size of the file changes.
+				|timestamp|
 				Mostly triggered after executing a shell
 				command, but also with a |:checktime| command
 				or when Gvim regains input focus.
@@ -657,6 +686,8 @@
 				when it's used.  The pattern is matched
 				against the function name.  Both <amatch> and
 				<afile> are set to the name of the function.
+				NOTE: When writing Vim scripts a better
+				alternative is to use an autoloaded function.
 				See |autoload-functions|.
 							*GUIEnter*
 GUIEnter			After starting the GUI successfully, and after
@@ -731,7 +762,7 @@
 				command is run, before jumping to the first
 				location. For |:cfile| and |:lfile| commands
 				it is run after error file is read and before
-				moving to the first error. 
+				moving to the first error.
 				See |QuickFixCmdPost-example|.
 							*QuitPre*
 QuitPre				When using `:quit`, `:wq` or `:qall`, before
diff -Naur vim74.orig/runtime/doc/change.txt vim74/runtime/doc/change.txt
--- vim74.orig/runtime/doc/change.txt	2013-08-10 11:24:52.000000000 +0000
+++ vim74/runtime/doc/change.txt	2014-10-10 14:53:40.058724652 +0000
@@ -1,4 +1,4 @@
-*change.txt*    For Vim version 7.4.  Last change: 2013 Jul 17
+*change.txt*    For Vim version 7.4.  Last change: 2014 Jun 26
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -156,6 +156,9 @@
 The 'B' and 'M' flags in 'formatoptions' change the behavior for inserting
 spaces before and after a multi-byte character |fo-table|.
 
+The '[ mark is set at the end of the first line that was joined, '] at the end
+of the resulting line.
+
 
 ==============================================================================
 2. Delete and insert				*delete-insert* *replacing*
@@ -475,8 +478,8 @@
 'shiftwidth'.
 
 If the 'smartindent' option is on, or 'cindent' is on and 'cinkeys' contains
-'#', shift right does not affect lines starting with '#' (these are supposed
-to be C preprocessor lines that must stay in column 1).
+'#' with a zero value, shift right does not affect lines starting with '#'
+(these are supposed to be C preprocessor lines that must stay in column 1).
 
 When the 'expandtab' option is off (this is the default) Vim uses <Tab>s as
 much as possible to make the indent.  You can use ">><<" to replace an indent
@@ -824,7 +827,7 @@
 <
 
 Substitute with an expression			*sub-replace-expression*
-						*sub-replace-\=*
+						*sub-replace-\=* *s/\=*
 When the substitute string starts with "\=" the remainder is interpreted as an
 expression.  This does not work recursively: a |substitute()| function inside
 the expression cannot use "\=" for the substitute string.
@@ -1069,6 +1072,11 @@
 replace and use "0p .  You can repeat this as many times as you like, the
 unnamed register will be changed each time.
 
+When you use a blockwise Visual mode command and yank only a single line into
+a register, a paste on a visual selected area will paste that single line on
+each of the selected lines (thus replacing the blockwise selected region by a
+block of the pasted line).
+
 							*blockwise-register*
 If you use a blockwise Visual mode command to get the text into the register,
 the block of text will be inserted before ("P") or after ("p") the cursor
@@ -1126,6 +1134,8 @@
 made for the delete operator with these movement commands: |%|, |(|, |)|, |`|,
 |/|, |?|, |n|, |N|, |{| and |}|.  Register "1 is always used then (this is Vi
 compatible).  The "- register is used as well if the delete is within a line.
+Note that these characters may be mapped.  E.g. |%| is mapped by the matchit
+plugin.
    With each successive deletion or change, Vim shifts the previous contents
 of register 1 into register 2, 2 into 3, and so forth, losing the previous
 contents of register 9.
@@ -1640,7 +1650,7 @@
 7. Sorting text						*sorting*
 
 Vim has a sorting function and a sorting command.  The sorting function can be
-found here: |sort()|.
+found here: |sort()|, |uniq()|.
 
 							*:sor* *:sort*
 :[range]sor[t][!] [i][u][r][n][x][o] [/{pattern}/]
@@ -1707,8 +1717,8 @@
 quite useless.
 
 The details about sorting depend on the library function used.  There is no
-guarantee that sorting is "stable" or obeys the current locale.  You will have
-to try it out.
+guarantee that sorting obeys the current locale.  You will have to try it out.
+Vim does do a "stable" sort.
 
 The sorting can be interrupted, but if you interrupt it too late in the
 process you may end up with duplicated lines.  This also depends on the system
diff -Naur vim74.orig/runtime/doc/cmdline.txt vim74/runtime/doc/cmdline.txt
--- vim74.orig/runtime/doc/cmdline.txt	2013-08-10 11:24:52.000000000 +0000
+++ vim74/runtime/doc/cmdline.txt	2014-10-10 14:53:40.068724627 +0000
@@ -1,4 +1,4 @@
-*cmdline.txt*   For Vim version 7.4.  Last change: 2013 Mar 16
+*cmdline.txt*   For Vim version 7.4.  Last change: 2014 Sep 06
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -56,7 +56,7 @@
 These are completely separate.  Each history can only be accessed when
 entering the same type of line.
 Use the 'history' option to set the number of lines that are remembered
-(default: 20).
+(default: 50).
 Notes:
 - When you enter a command-line that is exactly the same as an older one, the
   old one is removed (to avoid repeated commands moving older commands out of
@@ -356,6 +356,10 @@
 		List the recent five entries from all histories: >
 			:history all -5,
 
+:keepp[atterns] {command}			*:keepp* *:keeppatterns*
+		Execute {command}, without adding anything to the search
+		history
+
 ==============================================================================
 2. Command-line completion				*cmdline-completion*
 
@@ -754,6 +758,7 @@
 function expand() |expand()|.
 	%	Is replaced with the current file name.		  *:_%* *c_%*
 	#	Is replaced with the alternate file name.	  *:_#* *c_#*
+		This is remembered for every window.
 	#n	(where n is a number) is replaced with		  *:_#0* *:_#n*
 		the file name of buffer n.  "#0" is the same as "#".     *c_#n*
 	##	Is replaced with all names in the argument list	  *:_##* *c_##*
@@ -819,8 +824,8 @@
 		   the start of the function.
 
 							 *filename-modifiers*
-	 *:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs*
-	        *%:8* *%:p* *%:.* *%:~* *%:h* *%:t* *%:r* *%:e* *%:s* *%:gs*
+*:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs* *::S*
+     *%:8* *%:p* *%:.* *%:~* *%:h* *%:t* *%:r* *%:e* *%:s* *%:gs* *%:S*
 The file name modifiers can be used after "%", "#", "#n", "<cfile>", "<sfile>",
 "<afile>" or "<abuf>".  They are also used with the |fnamemodify()| function.
 These are not available when Vim has been compiled without the |+modify_fname|
@@ -875,6 +880,10 @@
 	:gs?pat?sub?
 		Substitute all occurrences of "pat" with "sub".  Otherwise
 		this works like ":s".
+	:S	Escape special characters for use with a shell command (see 
+		|shellescape()|). Must be the last one. Examples: >
+		    :!dir <cfile>:S
+		    :call system('chmod +w -- ' . expand('%:S'))
 
 Examples, when the file name is "src/version.c", current dir
 "/home/mool/vim": >
@@ -1075,6 +1084,9 @@
 statusline of the command-line window itself and the statusline above it.
 Thus you can resize the command-line window, but not others.
 
+The |getcmdwintype()| function returns the type of the command-line being
+edited as described in |cmdwin-char|.
+
 
 AUTOCOMMANDS
 
diff -Naur vim74.orig/runtime/doc/develop.txt vim74/runtime/doc/develop.txt
--- vim74.orig/runtime/doc/develop.txt	2013-08-10 11:24:52.000000000 +0000
+++ vim74/runtime/doc/develop.txt	2014-10-10 14:53:40.075391277 +0000
@@ -1,4 +1,4 @@
-*develop.txt*   For Vim version 7.4.  Last change: 2013 Apr 27
+*develop.txt*   For Vim version 7.4.  Last change: 2014 Mar 27
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -19,7 +19,6 @@
 
 Vim is open source software.  Everybody is encouraged to contribute to help
 improving Vim.  For sending patches a context diff "diff -c" is preferred.
-Also see http://www.vim.org/tips/tip.php?tip_id=618.
 Also see http://vim.wikia.com/wiki/How_to_make_and_submit_a_patch.
 
 ==============================================================================
diff -Naur vim74.orig/runtime/doc/diff.txt vim74/runtime/doc/diff.txt
--- vim74.orig/runtime/doc/diff.txt	2013-08-10 11:24:52.000000000 +0000
+++ vim74/runtime/doc/diff.txt	2014-10-10 14:53:40.078724602 +0000
@@ -1,4 +1,4 @@
-*diff.txt*      For Vim version 7.4.  Last change: 2013 Jul 07
+*diff.txt*      For Vim version 7.4.  Last change: 2014 May 20
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -95,7 +95,7 @@
 :difft[his]	Make the current window part of the diff windows.  This sets
 		the options like for "vimdiff".
 
-:diffp[atch] {patchfile}				 *E816* *:diffp* *:diffpatch*
+:diffp[atch] {patchfile}			 *E816* *:diffp* *:diffpatch*
 		Use the current buffer, patch it with the diff found in
 		{patchfile} and open a buffer on the result.  The options are
 		set as for "vimdiff".
@@ -123,10 +123,14 @@
 file for a moment and come back to the same file and be in diff mode again.
 
 							*:diffo* *:diffoff*
-:diffo[ff]	Switch off diff mode for the current window.
+:diffo[ff]	Switch off diff mode for the current window.  Resets related
+		options also when 'diff' was not set.
 
 :diffo[ff]!	Switch off diff mode for the current window and in all windows
-		in the current tab page where 'diff' is set.
+		in the current tab page where 'diff' is set.  Resetting
+		related options only happens in a window that has 'diff' set,
+		if the current window does not have 'diff' set then no options
+		in it are changed.
 
 The ":diffoff" command resets the relevant options to the values they had when
 using |:diffsplit|, |:diffpatch| , |:diffthis|. or starting Vim in diff mode.
diff -Naur vim74.orig/runtime/doc/digraph.txt vim74/runtime/doc/digraph.txt
--- vim74.orig/runtime/doc/digraph.txt	2013-08-10 11:24:52.000000000 +0000
+++ vim74/runtime/doc/digraph.txt	2014-10-10 14:53:40.082057927 +0000
@@ -1,4 +1,4 @@
-*digraph.txt*   For Vim version 7.4.  Last change: 2011 Jan 15
+*digraph.txt*   For Vim version 7.4.  Last change: 2014 Jun 19
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -147,7 +147,7 @@
 	Two			2	Hook
 	Nine			9	Horn
 
-	Equals			=	Cyrillic
+	Equals			=	Cyrillic (= used as second char) 
 	Asterisk		*	Greek
 	Percent sign		%	Greek/Cyrillic special
 	Plus			+	smalls: Arabic, capitals: Hebrew
@@ -170,6 +170,11 @@
 used for the euro sign, while both of them are the character 164, 0xa4.  For
 compatibility with zsh Eu can also be used for the euro sign.
 
+ROUBLE
+
+The rouble sign was added in 2014 as 0x20bd.  Vim supports the digraphs =R and
+=P for this.  Note that R= and P= are other characters.
+
 							*digraph-table*
 char  digraph	hex	dec	official name ~
 ^@	NU	0x00	  0	NULL (NUL)
@@ -966,6 +971,8 @@
 	Pt	20A7	8359	PESETA SIGN
 	W=	20A9	8361	WON SIGN
 	Eu	20AC	8364	EURO SIGN
+	=R	20BD	8381	ROUBLE SIGN
+	=P	20BD	8381	ROUBLE SIGN
 	oC	2103	8451	DEGREE CELSIUS
 	co	2105	8453	CARE OF
 	oF	2109	8457	DEGREE FAHRENHEIT
@@ -1077,7 +1084,7 @@
 	-T	22A5	8869	UP TACK
 	.P	22C5	8901	DOT OPERATOR
 	:3	22EE	8942	VERTICAL ELLIPSIS
-       .3      22EF    8943    MIDLINE HORIZONTAL ELLIPSIS
+	.3	22EF	8943	MIDLINE HORIZONTAL ELLIPSIS
 	Eh	2302	8962	HOUSE
 	<7	2308	8968	LEFT CEILING
 	>7	2309	8969	RIGHT CEILING
diff -Naur vim74.orig/runtime/doc/editing.txt vim74/runtime/doc/editing.txt
--- vim74.orig/runtime/doc/editing.txt	2013-08-10 11:24:53.000000000 +0000
+++ vim74/runtime/doc/editing.txt	2014-10-10 14:53:40.088724577 +0000
@@ -1,4 +1,4 @@
-*editing.txt*   For Vim version 7.4.  Last change: 2013 Aug 03
+*editing.txt*   For Vim version 7.4.  Last change: 2014 Sep 19
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -38,6 +38,7 @@
 file name.  It can be used with "#" on the command line |:_#| and you can use
 the |CTRL-^| command to toggle between the current and the alternate file.
 However, the alternate file name is not changed when |:keepalt| is used.
+An alternate file name is remembered for each window.
 
 							*:keepalt* *:keepa*
 :keepalt {cmd}		Execute {cmd} while keeping the current alternate file
@@ -608,7 +609,10 @@
 			{not in Vi}
 
 :[count]arga[dd] {name} ..			*:arga* *:argadd* *E479*
-			Add the {name}s to the argument list.
+:[count]arga[dd]
+			Add the {name}s to the argument list.  When {name} is
+			omitted at the current buffer name to the argument
+			list.
 			If [count] is omitted, the {name}s are added just
 			after the current entry in the argument list.
 			Otherwise they are added after the [count]'th file.
@@ -1361,11 +1365,21 @@
 {only available when compiled with the |+cryptv| feature}  *E833*
 
 The text in the swap file and the undo file is also encrypted.  *E843*
+However, this is done block-by-block and may reduce the time needed to crack a
+password.  You can disable the swap file, but then a crash will cause you to
+lose your work.  The undo file can be disabled without much disadvantage. >
+	:set noundofile
+	:noswapfile edit secrets
 
 Note: The text in memory is not encrypted.  A system administrator may be able
 to see your text while you are editing it.  When filtering text with
-":!filter" or using ":w !command" the text is not encrypted, this may reveal
-it to others.  The 'viminfo' file is not encrypted.
+":!filter" or using ":w !command" the text is also not encrypted, this may
+reveal it to others.  The 'viminfo' file is not encrypted.
+
+You could do this to edit very secret text: >
+	:set noundofile viminfo=
+	:noswapfile edit secrets.txt
+Keep in mind that without a swap file you risk loosing your work in a crash.
 
 WARNING: If you make a typo when entering the key and then write the file and
 exit, the text will be lost!
@@ -1392,18 +1406,25 @@
 	:set key=
 
 You can use the 'cryptmethod' option to select the type of encryption, use one
-of these two: >
-	:setlocal cm=zip       " weak method, backwards compatible
-	:setlocal cm=blowfish  " strong method
+of these: >
+	:setlocal cm=zip        " weak method, backwards compatible
+	:setlocal cm=blowfish   " method with flaws
+	:setlocal cm=blowfish2  " medium strong method
+
 Do this before writing the file.  When reading an encrypted file it will be
 set automatically to the method used when that file was written.  You can
 change 'cryptmethod' before writing that file to change the method.
+
 To set the default method, used for new files, use one of these in your
 |vimrc| file: >
 	set cm=zip
-	set cm=blowfish
+	set cm=blowfish2
+Use the first one if you need to be compatible with Vim 7.2 and older.  Using
+"blowfish2" is highly recommended if you can use a Vim version that supports
+it.
+
 The message given for reading and writing a file will show "[crypted]" when
-using zip, "[blowfish]" when using blowfish.
+using zip, "[blowfish]" when using blowfish, etc.
 
 When writing an undo file, the same key and method will be used for the text
 in the undo file. |persistent-undo|.
@@ -1438,7 +1459,7 @@
      0	string	VimCrypt~	Vim encrypted file
      >9	string	01	- "zip" cryptmethod
      >9	string	02	- "blowfish" cryptmethod
-
+     >9	string	03	- "blowfish2" cryptmethod
 
 Notes:
 - Encryption is not possible when doing conversion with 'charconvert'.
@@ -1462,20 +1483,25 @@
 - Pkzip uses the same encryption as 'cryptmethod' "zip", and US Govt has no
   objection to its export.  Pkzip's public file APPNOTE.TXT describes this
   algorithm in detail.
+- The implementation of 'cryptmethod' "blowfish" has a flaw.  It is possible
+  to crack the first 64 bytes of a file and in some circumstances more of the
+  file. Use of it is not recommended, but it's still the strongest method
+  supported by Vim 7.3 and 7.4.  The "zip" method is even weaker.
 - Vim originates from the Netherlands.  That is where the sources come from.
   Thus the encryption code is not exported from the USA.
 
 ==============================================================================
 10. Timestamps					*timestamp* *timestamps*
 
-Vim remembers the modification timestamp of a file when you begin editing it.
-This is used to avoid that you have two different versions of the same file
-(without you knowing this).
-
-After a shell command is run (|:!cmd| |suspend| |:read!| |K|) timestamps are
-compared for all buffers in a window.   Vim will run any associated
-|FileChangedShell| autocommands or display a warning for any files that have
-changed.  In the GUI this happens when Vim regains input focus.
+Vim remembers the modification timestamp, mode and size of a file when you
+begin editing it.  This is used to avoid that you have two different versions
+of the same file (without you knowing this).
+
+After a shell command is run (|:!cmd| |suspend| |:read!| |K|) timestamps,
+file modes and file sizes are compared for all buffers in a window.   Vim will
+run any associated |FileChangedShell| autocommands or display a warning for
+any files that have changed.  In the GUI this happens when Vim regains input
+focus.
 
 							*E321* *E462*
 If you want to automatically reload a file when it has been changed outside of
diff -Naur vim74.orig/runtime/doc/eval.txt vim74/runtime/doc/eval.txt
--- vim74.orig/runtime/doc/eval.txt	2013-08-10 11:24:53.000000000 +0000
+++ vim74/runtime/doc/eval.txt	2014-10-10 14:53:40.105391202 +0000
@@ -1,4 +1,4 @@
-*eval.txt*	For Vim version 7.4.  Last change: 2013 Aug 03
+*eval.txt*	For Vim version 7.4.  Last change: 2014 Sep 27
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -123,6 +123,7 @@
 	:echo Fn()
 <							*E704* *E705* *E707*
 A Funcref variable must start with a capital, "s:", "w:", "t:" or "b:".  You
+can use "g:" but the following name must still start with a capital.  You
 cannot have both a Funcref variable and a function with the same name.
 
 A special case is defining a function and directly assigning its Funcref to a
@@ -147,7 +148,7 @@
 
 
 1.3 Lists ~
-							*List* *Lists* *E686*
+						*list* *List* *Lists* *E686*
 A List is an ordered sequence of items.  An item can be of any type.  Items
 can be accessed by their index number.	Items can be added and removed at any
 position in the sequence.
@@ -326,6 +327,7 @@
 Changing the order of items in a list: >
 	:call sort(list)		" sort a list alphabetically
 	:call reverse(list)		" reverse the order of items
+	:call uniq(sort(list))		" sort and remove duplicates
 
 
 For loop ~
@@ -392,7 +394,7 @@
 
 
 1.4 Dictionaries ~
-						*Dictionaries* *Dictionary*
+					*dict* *Dictionaries* *Dictionary*
 A Dictionary is an associative array: Each entry has a key and a value.  The
 entry can be located with the key.  The entries are stored without a specific
 ordering.
@@ -1003,7 +1005,7 @@
 
 
 
-string							*expr-string* *E114*
+string						*string* *expr-string* *E114*
 ------
 "string"		string constant		*expr-quote*
 
@@ -1100,9 +1102,9 @@
 the environment variables known inside the current Vim session.  If that
 fails, a shell will be used to expand the variable.  This can be slow, but it
 does expand all variables that the shell knows about.  Example: >
-	:echo $version
-	:echo expand("$version")
-The first one probably doesn't echo anything, the second echoes the $version
+	:echo $shell
+	:echo expand("$shell")
+The first one probably doesn't echo anything, the second echoes the $shell
 variable (if your shell supports it).
 
 
@@ -1142,7 +1144,7 @@
 |local-variable|     l:	  Local to a function.
 |script-variable|    s:	  Local to a |:source|'ed Vim script.
 |function-argument|  a:	  Function argument (only inside a function).
-|vim-variable|	     v:	  Global, predefined by Vim.
+|vim-variable|       v:	  Global, predefined by Vim.
 
 The scope name by itself can be used as a |Dictionary|.  For example, to
 delete all script-local variables: >
@@ -1454,6 +1456,13 @@
 v:foldstart	Used for 'foldtext': first line of closed fold.
 		Read-only in the |sandbox|. |fold-foldtext|
 
+					*v:hlsearch* *hlsearch-variable*
+v:hlsearch	Variable that determines whether search highlighting is on. 
+		Makes sense only if 'hlsearch' is enabled which requires 
+		|+extra_search|. Setting this variable to zero acts the like 
+		|:nohlsearch| command, setting it to one acts like >
+			let &hlsearch = &hlsearch
+<
 					*v:insertmode* *insertmode-variable*
 v:insertmode	Used for the |InsertEnter| and |InsertChange| autocommand
 		events.  Values:
@@ -1511,6 +1520,7 @@
 		startup.  These are the files that Vim remembers marks for.
 		The length of the List is limited by the ' argument of the
 		'viminfo' option (default is 100).
+		When the |viminfo| file is not used the List is empty.
 		Also see |:oldfiles| and |c_#<|.
 		The List can be modified, but this has no effect on what is
 		stored in the |viminfo| file later.  If you use values other
@@ -1548,6 +1558,16 @@
 		|evim| etc., or any other name you might symlink to Vim.
 		Read-only.
 
+					*v:progpath* *progpath-variable*
+v:progpath	Contains the command with which Vim was invoked, including the
+		path.  Useful if you want to message a Vim server using a
+		|--remote-expr|.
+		To get the full path use: >
+			echo exepath(v:progpath)
+<		NOTE: This does not work when the command is a relative path
+		and the current directory has changed.
+		Read-only.
+
 					*v:register* *register-variable*
 v:register	The name of the register in effect for the current normal mode
 		command (regardless of whether that command actually used a
@@ -1662,7 +1682,7 @@
 		is 501.  Read-only.  "version" also works, for backwards
 		compatibility.
 		Use |has()| to check if a certain patch was included, e.g.: >
-			if has("patch123")
+			if has("patch-7.4.123")
 <		Note that patch numbers are specific to the version, thus both
 		version 5.0 and 5.1 may have a patch 123, but these are
 		completely different.
@@ -1696,6 +1716,8 @@
 append( {lnum}, {list})		Number	append lines {list} below line {lnum}
 argc()				Number	number of files in the argument list
 argidx()			Number	current index in the argument list
+arglistid( [{winnr}, [ {tabnr}]])
+				Number	argument list id
 argv( {nr})			String	{nr} entry of the argument list
 argv( )				List	the argument list
 asin( {expr})			Float	arc sine of {expr}
@@ -1712,6 +1734,7 @@
 bufwinnr( {expr})		Number	window number of buffer {expr}
 byte2line( {byte})		Number	line number at byte count {byte}
 byteidx( {expr}, {nr})		Number	byte index of {nr}'th char in {expr}
+byteidxcomp( {expr}, {nr})	Number	byte index of {nr}'th char in {expr}
 call( {func}, {arglist} [, {dict}])
 				any	call {func} with arguments {arglist}
 ceil( {expr})			Float	round {expr} up
@@ -1728,14 +1751,14 @@
 copy( {expr})			any	make a shallow copy of {expr}
 cos( {expr})			Float	cosine of {expr}
 cosh( {expr})			Float	hyperbolic cosine of {expr}
-count( {list}, {expr} [, {start} [, {ic}]])
+count( {list}, {expr} [, {ic} [, {start}]])
 				Number	 count how many {expr} are in {list}
 cscope_connection( [{num} , {dbpath} [, {prepend}]])
 				Number	checks existence of cscope connection
 cursor( {lnum}, {col} [, {coladd}])
 				Number	move cursor to {lnum}, {col}, {coladd}
 cursor( {list})			Number	move cursor to position in {list}
-deepcopy( {expr})		any	make a full copy of {expr}
+deepcopy( {expr} [, {noref}])	any	make a full copy of {expr}
 delete( {fname})		Number	delete file {fname}
 did_filetype()			Number	TRUE if FileType autocommand event used
 diff_filler( {lnum})		Number	diff filler lines about {lnum}
@@ -1745,6 +1768,7 @@
 eval( {string})			any	evaluate {string} into its value
 eventhandler( )			Number	TRUE if inside an event handler
 executable( {expr})		Number	1 if executable {expr} exists
+exepath( {expr})		String  full path of the command {expr}
 exists( {expr})			Number	TRUE if {expr} exists
 extend( {expr1}, {expr2} [, {expr3}])
 				List/Dict insert items of {expr2} into {expr1}
@@ -1783,11 +1807,13 @@
 getcharmod( )			Number	modifiers for the last typed character
 getcmdline()			String	return the current command-line
 getcmdpos()			Number	return cursor position in command-line
-getcmdtype()			String	return the current command-line type
+getcmdtype()			String	return current command-line type
+getcmdwintype()			String	return current command-line window type
+getcurpos()			List	position of the cursor
 getcwd()			String	the current working directory
+getfontname( [{name}])		String	name of font being used
 getfperm( {fname})		String	file permissions of file {fname}
 getfsize( {fname})		Number	size in bytes of file {fname}
-getfontname( [{name}])		String	name of font being used
 getftime( {fname})		Number	last modification time of file
 getftype( {fname})		String	description of type of file {fname}
 getline( {lnum})		String	line {lnum} of current buffer
@@ -1797,7 +1823,8 @@
 getpid()			Number	process ID of Vim
 getpos( {expr})			List	position of cursor, mark, etc.
 getqflist()			List	list of quickfix items
-getreg( [{regname} [, 1]])	String	contents of register
+getreg( [{regname} [, 1 [, {list}]]])
+				String or List   contents of register
 getregtype( [{regname}])	String	type of register
 gettabvar( {nr}, {varname} [, {def}])
 				any	variable {varname} in tab {nr} or {def}
@@ -1809,7 +1836,7 @@
 				any	variable {varname} in window {nr}
 glob( {expr} [, {nosuf} [, {list}]])
 				any	expand file wildcards in {expr}
-globpath( {path}, {expr} [, {flag}])
+globpath( {path}, {expr} [, {nosuf} [, {list}]])
 				String	do glob({expr}) for all dirs in {path}
 has( {feature})			Number	TRUE if feature {feature} supported
 has_key( {dict}, {key})		Number	TRUE if {dict} has entry {key}
@@ -1861,6 +1888,8 @@
 				Number	position where {pat} matches in {expr}
 matchadd( {group}, {pattern}[, {priority}[, {id}]])
 				Number	highlight {pattern} with {group}
+matchaddpos( {group}, {list}[, {priority}[, {id}]])
+				Number	highlight positions with {group}
 matcharg( {nr})			List	arguments of |:match|
 matchdelete( {id})		Number	delete match identified by {id}
 matchend( {expr}, {pat}[, {start}[, {count}]])
@@ -1968,7 +1997,8 @@
 				Number	last index of {needle} in {haystack}
 strtrans( {expr})		String	translate string to make it printable
 strwidth( {expr})		Number	display cell length of the String {expr}
-submatch( {nr})			String	specific match in ":s" or substitute()
+submatch( {nr}[, {list}])	String or List
+					specific match in ":s" or substitute()
 substitute( {expr}, {pat}, {sub}, {flags})
 				String	all {pat} in {expr} replaced with {sub}
 synID( {lnum}, {col}, {trans})	Number	syntax ID at {lnum} and {col}
@@ -1978,6 +2008,7 @@
 synconcealed( {lnum}, {col})	List    info about concealing
 synstack( {lnum}, {col})	List	stack of syntax IDs at {lnum} and {col}
 system( {expr} [, {input}])	String	output of shell command/filter {expr}
+systemlist( {expr} [, {input}])	List	output of shell command/filter {expr}
 tabpagebuflist( [{arg}])	List	list of buffer numbers in tab page
 tabpagenr( [{arg}])		Number	number of current or last tab page
 tabpagewinnr( {tabarg}[, {arg}])
@@ -1995,6 +2026,8 @@
 type( {name})			Number	type of variable {name}
 undofile( {name})		String	undo file name for {name}
 undotree()			List	undo file tree
+uniq( {list} [, {func} [, {dict}]])
+				List	remove adjacent duplicates from a list
 values( {dict})			List	values in {dict}
 virtcol( {expr})		Number	screen column of cursor or mark
 visualmode( [expr])		String	last visual mode used
@@ -2076,6 +2109,18 @@
 argidx()	The result is the current index in the argument list.  0 is
 		the first file.  argc() - 1 is the last one.  See |arglist|.
 
+							*arglistid()*
+arglistid([{winnr}, [ {tabnr} ]])
+		Return the argument list ID.  This is a number which
+		identifies the argument list being used.  Zero is used for the
+		global argument list.  See |arglist|.
+		Return -1 if the arguments are invalid.
+
+		Without arguments use the current window.
+		With {winnr} only use this window in the current tab page.
+		With {winnr} and {tabnr} use the window in the specified tab
+		page.
+
 							*argv()*
 argv([{nr}])	The result is the {nr}th file in the argument list of the
 		current window.  See |arglist|.  "argv(0)" is the first one.
@@ -2260,7 +2305,10 @@
 		{expr}.  Use zero for the first character, it returns zero.
 		This function is only useful when there are multibyte
 		characters, otherwise the returned value is equal to {nr}.
-		Composing characters are counted as a separate character.
+		Composing characters are not counted separately, their byte
+		length is added to the preceding base character.  See
+		|byteidxcomp()| below for counting composing characters
+		separately.
 		Example : >
 			echo matchstr(str, ".", byteidx(str, 3))
 <		will display the fourth character.  Another way to do the
@@ -2269,7 +2317,20 @@
 			echo strpart(s, 0, byteidx(s, 1))
 <		If there are less than {nr} characters -1 is returned.
 		If there are exactly {nr} characters the length of the string
-		is returned.
+		in bytes is returned.
+
+byteidxcomp({expr}, {nr})					*byteidxcomp()*
+		Like byteidx(), except that a composing character is counted
+		as a separate character.  Example: >
+			let s = 'e' . nr2char(0x301)
+			echo byteidx(s, 1)
+			echo byteidxcomp(s, 1)
+			echo byteidxcomp(s, 2)
+<		The first and third echo result in 3 ('e' plus composing
+		character is 3 bytes), the second echo results in 1 ('e' is
+		one byte).
+		Only works different from byteidx() when 'encoding' is set to
+		a Unicode encoding.
 
 call({func}, {arglist} [, {dict}])			*call()* *E699*
 		Call function {func} with the items in |List| {arglist} as
@@ -2544,9 +2605,14 @@
 cursor({list})
 		Positions the cursor at the column (byte count) {col} in the
 		line {lnum}.  The first column is one.
+
 		When there is one argument {list} this is used as a |List|
-		with two or three items {lnum}, {col} and {off}.  This is like
-		the return value of |getpos()|, but without the first item.
+		with two, three or four item:
+			[{lnum}, {col}, {off}]
+			[{lnum}, {col}, {off}, {curswant}]
+		This is like the return value of |getpos()| or |getcurpos()|,
+		but without the first item.
+
 		Does not change the jumplist.
 		If {lnum} is greater than the number of lines in the buffer,
 		the cursor will be positioned at the last line in the buffer.
@@ -2555,6 +2621,8 @@
 		the cursor will be positioned at the last character in the
 		line.
 		If {col} is zero, the cursor will stay in the current column.
+		If {curswant} is given it is used to set the preferred column
+		for vertical movement.  Otherwise {col} is used.
 		When 'virtualedit' is used {off} specifies the offset in
 		screen columns from the start of the character.  E.g., a
 		position within a <Tab> or after the last character.
@@ -2671,6 +2739,15 @@
 			0	does not exist
 			-1	not implemented on this system
 
+exepath({expr})						*exepath()*
+		If {expr} is an executable and is either an absolute path, a
+		relative path or found in $PATH, return the full path.
+		Note that the current directory is used when {expr} starts
+		with "./", which may be a problem for Vim: >
+			echo exepath(v:progpath)
+<		If {expr} cannot be found in $PATH or is not executable then
+		an empty string is returned.
+
 							*exists()*
 exists({expr})	The result is a Number, which is non-zero if {expr} is
 		defined, zero otherwise.  The {expr} argument is a string,
@@ -2683,7 +2760,8 @@
 					string)
 			*funcname	built-in function (see |functions|)
 					or user defined function (see
-					|user-functions|).
+					|user-functions|). Also works for a
+					variable that is a Funcref.
 			varname		internal variable (see
 					|internal-variables|).	Also works
 					for |curly-braces-names|, |Dictionary|
@@ -2789,7 +2867,7 @@
 			<afile>		autocmd file name
 			<abuf>		autocmd buffer number (as a String!)
 			<amatch>	autocmd matched name
-			<sfile>		sourced script file name
+			<sfile>		sourced script file or function name
 			<slnum>		sourced script file line number
 			<cword>		word under the cursor
 			<cWORD>		WORD under the cursor
@@ -2835,7 +2913,8 @@
 <
 		Expand() can also be used to expand variables and environment
 		variables that are only known in a shell.  But this can be
-		slow, because a shell must be started.	See |expr-env-expand|.
+		slow, because a shell may be used to do the expansion.  See
+		|expr-env-expand|.
 		The expanded variable is still handled like a list of file
 		names.	When an environment variable cannot be expanded, it is
 		left unchanged.  Thus ":echo expand('$FOOBAR')" results in
@@ -3175,7 +3254,7 @@
 		If [expr] is 1, only check if a character is available, it is
 			not consumed.  Return zero if no character available.
 
-		Without {expr} and when {expr} is 0 a whole character or
+		Without [expr] and when [expr] is 0 a whole character or
 		special key is returned.  If it is an 8-bit character, the
 		result is a number.  Use nr2char() to convert it to a String.
 		Otherwise a String is returned with the encoded character.
@@ -3185,7 +3264,11 @@
 		String when a modifier (shift, control, alt) was used that is
 		not included in the character.
 
-		When {expr} is 1 only the first byte is returned.  For a
+		When [expr] is 0 and Esc is typed, there will be a short delay
+		while Vim waits to see if this is the start of an escape
+		sequence.
+
+		When [expr] is 1 only the first byte is returned.  For a
 		one-byte character it is the character itself as a number.
 		Use nr2char() to convert it to a String.
 
@@ -3263,11 +3346,28 @@
 		    ?	backward search command
 		    @	|input()| command
 		    -	|:insert| or |:append| command
+		    =	|i_CTRL-R_=|
 		Only works when editing the command line, thus requires use of
 		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
 		Returns an empty string otherwise.
 		Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.
 
+getcmdwintype()						*getcmdwintype()*
+		Return the current |command-line-window| type. Possible return
+		values are the same as |getcmdtype()|. Returns an empty string
+		when not in the command-line window.
+
+							*getcurpos()*
+getcurpos()	Get the position of the cursor.  This is like getpos('.'), but
+		includes an extra item in the list:
+		    [bufnum, lnum, col, off, curswant]
+		The "curswant" number is the preferred column when moving the
+		cursor vertically.
+		This can be used to save and restore the cursor position: >
+			let save_cursor = getcurpos()
+			MoveTheCursorAround
+			call setpos('.', save_cursor)
+<
 							*getcwd()*
 getcwd()	The result is a String, which is the name of the current
 		working directory.
@@ -3389,6 +3489,34 @@
 			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
 			:unlet m
 <
+							*getpid()*
+getpid()	Return a Number which is the process ID of the Vim process.
+		On Unix and MS-Windows this is a unique number, until Vim
+		exits.	On MS-DOS it's always zero.
+
+							*getpos()*
+getpos({expr})	Get the position for {expr}.  For possible values of {expr}
+		see |line()|.  For getting the cursor position see
+		|getcurpos()|.
+		The result is a |List| with four numbers:
+		    [bufnum, lnum, col, off]
+		"bufnum" is zero, unless a mark like '0 or 'A is used, then it
+		is the buffer number of the mark.
+		"lnum" and "col" are the position in the buffer.  The first
+		column is 1.
+		The "off" number is zero, unless 'virtualedit' is used.  Then
+		it is the offset in screen columns from the start of the
+		character.  E.g., a position within a <Tab> or after the last
+		character.
+		Note that for '< and '> Visual mode matters: when it is "V"
+		(visual line mode) the column of '< is zero and the column of
+		'> is a large number.
+		This can be used to save and restore the position of a mark: >
+			let save_a_mark = getpos("'a")
+			...
+			call setpos(''a', save_a_mark
+<		Also see |getcurpos()| and |setpos()|.
+
 
 getqflist()						*getqflist()*
 		Returns a list with all the current quickfix errors.  Each
@@ -3417,7 +3545,7 @@
 			:endfor
 
 
-getreg([{regname} [, 1]])				*getreg()*
+getreg([{regname} [, 1 [, {list}]]])			*getreg()*
 		The result is a String, which is the contents of register
 		{regname}.  Example: >
 			:let cliptext = getreg('*')
@@ -3426,6 +3554,11 @@
 		getreg('=', 1) returns the expression itself, so that it can
 		be restored with |setreg()|.  For other registers the extra
 		argument is ignored, thus you can always give it.
+		If {list} is present and non-zero result type is changed to 
+		|List|. Each list item is one text line. Use it if you care
+		about zero bytes possibly present inside register: without
+		third argument both NLs and zero bytes are represented as NLs
+		(see |NL-used-for-Nul|).
 		If {regname} is not specified, |v:register| is used.
 
 
@@ -3435,7 +3568,7 @@
 		    "v"			for |characterwise| text
 		    "V"			for |linewise| text
 		    "<CTRL-V>{width}"	for |blockwise-visual| text
-		    0			for an empty or unknown register
+		    ""			for an empty or unknown register
 		<CTRL-V> is one character with value 0x16.
 		If {regname} is not specified, |v:register| is used.
 
@@ -3443,6 +3576,8 @@
 		Get the value of a tab-local variable {varname} in tab page
 		{tabnr}. |t:var|
 		Tabs are numbered starting with one.
+		When {varname} is empty a dictionary with all tab-local
+		variables is returned.
 		Note that the name without "t:" must be used.
 		When the tab or variable doesn't exist {def} or an empty
 		string is returned, there is no error message.
@@ -3513,11 +3648,12 @@
 		See |expand()| for expanding special Vim variables.  See
 		|system()| for getting the raw output of an external command.
 
-globpath({path}, {expr} [, {flag}])			*globpath()*
+globpath({path}, {expr} [, {nosuf} [, {list}]])			*globpath()*
 		Perform glob() on all directories in {path} and concatenate
 		the results.  Example: >
 			:echo globpath(&rtp, "syntax/c.vim")
-<		{path} is a comma-separated list of directory names.  Each
+<
+		{path} is a comma-separated list of directory names.  Each
 		directory name is prepended to {expr} and expanded like with
 		|glob()|.  A path separator is inserted when needed.
 		To add a comma inside a directory name escape it with a
@@ -3525,11 +3661,19 @@
 		trailing backslash, remove it if you put a comma after it.
 		If the expansion fails for one of the directories, there is no
 		error message.
-		Unless the optional {flag} argument is given and is non-zero,
+
+		Unless the optional {nosuf} argument is given and is non-zero,
 		the 'suffixes' and 'wildignore' options apply: Names matching
 		one of the patterns in 'wildignore' will be skipped and
 		'suffixes' affect the ordering of matches.
 
+		When {list} is present and it is non-zero the result is a List
+		with all matching files. The advantage of using a List is, you
+		also get filenames containing newlines correctly. Otherwise
+		the result is a String and when there are several matches,
+		they are separated by <NL> characters.  Example: >
+			:echo globpath(&rtp, "syntax/c.vim", 0, 1)
+<
 		The "**" item can be used to search in a directory tree.
 		For example, to find all "README.txt" files in the directories
 		in 'runtimepath' and below: >
@@ -4109,6 +4253,8 @@
 				     (|mapmode-ic|)
 		  "sid"	     The script local ID, used for <sid> mappings
 			     (|<SID>|).
+		  "nowait"   Do not wait for other, longer mappings.
+			     (|:map-<nowait>|).
 
 		The mappings local to the current buffer are checked first,
 		then the global mappings.
@@ -4210,6 +4356,9 @@
 		"match").  It will be highlighted with {group}.  Returns an
 		identification number (ID), which can be used to delete the
 		match using |matchdelete()|.
+		Matching is case sensitive and magic, unless case sensitivity
+		or magicness are explicitly overridden in {pattern}.  The
+		'magic', 'smartcase' and 'ignorecase' options are not used.
 
 		The optional {priority} argument assigns a priority to the
 		match.	A match with a high priority will have its
@@ -4243,6 +4392,41 @@
 		available from |getmatches()|.	All matches can be deleted in
 		one operation by |clearmatches()|.
 
+matchaddpos({group}, {pos}[, {priority}[, {id}]])		*matchaddpos()*
+		Same as |matchadd()|, but requires a list of positions {pos}
+		instead of a pattern. This command is faster than |matchadd()|
+		because it does not require to handle regular expressions and
+		sets buffer line boundaries to redraw screen. It is supposed
+		to be used when fast match additions and deletions are
+		required, for example to highlight matching parentheses.
+
+		The list {pos} can contain one of these items:
+		- A number.  This whole line will be highlighted.  The first
+		  line has number 1.
+		- A list with one number, e.g., [23]. The whole line with this
+		  number will be highlighted.
+		- A list with two numbers, e.g., [23, 11]. The first number is
+		  the line number, the second one is the column number (first
+		  column is 1, the value must correspond to the byte index as
+		  |col()| would return).  The character at this position will
+		  be highlighted.
+		- A list with three numbers, e.g., [23, 11, 3]. As above, but
+		  the third number gives the length of the highlight in bytes.
+		
+		The maximum number of positions is 8.
+
+		Example: >
+			:highlight MyGroup ctermbg=green guibg=green
+			:let m = matchaddpos("MyGroup", [[23, 24], 34])
+<		Deletion of the pattern: >
+			:call matchdelete(m)
+
+<		Matches added by |matchaddpos()| are returned by
+		|getmatches()| with an entry "pos1", "pos2", etc., with the
+		value a list like the {pos} item.
+		These matches cannot be set via |setmatches()|, however they
+		can still be deleted by |clearmatches()|.
+
 matcharg({nr})							*matcharg()*
 		Selects the {nr} match item, as set with a |:match|,
 		|:2match| or |:3match| command.
@@ -4401,30 +4585,6 @@
 		characters.  nr2char(0) is a real NUL and terminates the
 		string, thus results in an empty string.
 
-							*getpid()*
-getpid()	Return a Number which is the process ID of the Vim process.
-		On Unix and MS-Windows this is a unique number, until Vim
-		exits.	On MS-DOS it's always zero.
-
-							*getpos()*
-getpos({expr})	Get the position for {expr}.  For possible values of {expr}
-		see |line()|.
-		The result is a |List| with four numbers:
-		    [bufnum, lnum, col, off]
-		"bufnum" is zero, unless a mark like '0 or 'A is used, then it
-		is the buffer number of the mark.
-		"lnum" and "col" are the position in the buffer.  The first
-		column is 1.
-		The "off" number is zero, unless 'virtualedit' is used.  Then
-		it is the offset in screen columns from the start of the
-		character.  E.g., a position within a <Tab> or after the last
-		character.
-		This can be used to save and restore the cursor position: >
-			let save_cursor = getpos(".")
-			MoveTheCursorAround
-			call setpos('.', save_cursor)
-<		Also see |setpos()|.
-
 or({expr}, {expr})					*or()*
 		Bitwise OR on the two arguments.  The arguments are converted
 		to a number.  A List, Dict or Float argument causes an error.
@@ -5223,8 +5383,9 @@
 			.	the cursor
 			'x	mark x
 
-		{list} must be a |List| with four numbers:
+		{list} must be a |List| with four or five numbers:
 		    [bufnum, lnum, col, off]
+		    [bufnum, lnum, col, off, curswant]
 
 		"bufnum" is the buffer number.	Zero can be used for the
 		current buffer.  Setting the cursor is only possible for
@@ -5242,13 +5403,26 @@
 		character.  E.g., a position within a <Tab> or after the last
 		character.
 
+		The "curswant" number is only used when setting the cursor
+		position.  It sets the preferred column for when moving the
+		cursor vertically.  When the "curswant" number is missing the
+		preferred column is not set.  When it is present and setting a
+		mark position it is not used.
+
+		Note that for '< and '> changing the line number may result in
+		the marks to be effectively be swapped, so that '< is always
+		before '>.
+
 		Returns 0 when the position could be set, -1 otherwise.
 		An error message is given if {expr} is invalid.
 
-		Also see |getpos()|
+		Also see |getpos()| and |getcurpos()|.
 
 		This does not restore the preferred column for moving
-		vertically.  See |winrestview()| for that.
+		vertically; if you set the cursor position with this, |j| and
+		|k| motions will jump to previous columns!  Use |cursor()| to
+		also set the preferred column.  Also see the "curswant" key in
+		|winrestview()|.
 
 
 setqflist({list} [, {action}])				*setqflist()*
@@ -5300,6 +5474,8 @@
 							*setreg()*
 setreg({regname}, {value} [,{options}])
 		Set the register {regname} to {value}.
+		{value} may be any value returned by |getreg()|, including 
+		a |List|.
 		If {options} contains "a" or {regname} is upper case,
 		then the value is appended.
 		{options} can also contain a register type specification:
@@ -5312,10 +5488,15 @@
 		in the longest line (counting a <Tab> as 1 character).
 
 		If {options} contains no register settings, then the default
-		is to use character mode unless {value} ends in a <NL>.
-		Setting the '=' register is not possible, but you can use >
-			:let @= = var_expr
-<		Returns zero for success, non-zero for failure.
+		is to use character mode unless {value} ends in a <NL> for 
+		string {value} and linewise mode for list {value}. Blockwise 
+		mode is never selected automatically.
+		Returns zero for success, non-zero for failure.
+
+							*E883*
+		Note: you may not use |List| containing more than one item to 
+		      set search and expression registers. Lists containing no 
+		      items act like empty strings.
 
 		Examples: >
 			:call setreg(v:register, @*)
@@ -5323,8 +5504,11 @@
 			:call setreg('a', "1\n2\n3", 'b5')
 
 <		This example shows using the functions to save and restore a
-		register. >
-			:let var_a = getreg('a', 1)
+		register (note: you may not reliably restore register value 
+		without using the third argument to |getreg()| as without it 
+		newlines are represented as newlines AND Nul bytes are 
+		represented as newlines as well, see |NL-used-for-Nul|). >
+			:let var_a = getreg('a', 1, 1)
 			:let var_amode = getregtype('a')
 			    ....
 			:call setreg('a', var_a, var_amode)
@@ -5390,6 +5574,7 @@
 <		This results in a directory listing for the file under the
 		cursor.  Example of use with |system()|: >
 		    :call system("chmod +w -- " . shellescape(expand("%")))
+<		See also |::S|.
 
 
 shiftwidth()						*shiftwidth()*
@@ -5449,20 +5634,40 @@
 
 
 sort({list} [, {func} [, {dict}]])			*sort()* *E702*
-		Sort the items in {list} in-place.  Returns {list}.  If you
-		want a list to remain unmodified make a copy first: >
+		Sort the items in {list} in-place.  Returns {list}.
+		
+		If you want a list to remain unmodified make a copy first: >
 			:let sortedlist = sort(copy(mylist))
-<		Uses the string representation of each item to sort on.
-		Numbers sort after Strings, |Lists| after Numbers.
-		For sorting text in the current buffer use |:sort|.
-		When {func} is given and it is one then case is ignored.
-		{dict} is for functions with the "dict" attribute.  It will be
-		used to set the local variable "self". |Dictionary-function|
+
+<		When {func} is omitted, is empty or zero, then sort() uses the
+		string representation of each item to sort on.  Numbers sort
+		after Strings, |Lists| after Numbers.  For sorting text in the
+		current buffer use |:sort|.
+
+		When {func} is given and it is '1' or 'i' then case is
+		ignored.
+		
+		When {func} is given and it is 'n' then all items will be
+		sorted numerical (Implementation detail: This uses the
+		strtod() function to parse numbers, Strings, Lists, Dicts and
+		Funcrefs will be considered as being 0).
+
 		When {func} is a |Funcref| or a function name, this function
 		is called to compare items.  The function is invoked with two
 		items as argument and must return zero if they are equal, 1 or
 		bigger if the first one sorts after the second one, -1 or
 		smaller if the first one sorts before the second one.
+
+		{dict} is for functions with the "dict" attribute.  It will be
+		used to set the local variable "self". |Dictionary-function|
+
+		The sort is stable, items which compare equal (as number or as
+		string) will keep their relative position. E.g., when sorting
+		on numbers, text strings will sort next to each other, in the
+		same order as they were originally.
+
+		Also see |uniq()|.
+
 		Example: >
 			func MyCompare(i1, i2)
 			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
@@ -5604,7 +5809,7 @@
 
 strdisplaywidth({expr}[, {col}])			*strdisplaywidth()*
 		The result is a Number, which is the number of display cells
-		String {expr} occupies on the screen.
+		String {expr} occupies on the screen when it starts a {col}.
 		When {col} is omitted zero is used.  Otherwise it is the
 		screen column where to start.  This matters for Tab
 		characters.
@@ -5729,12 +5934,23 @@
 		Ambiguous, this function's return value depends on 'ambiwidth'.
 		Also see |strlen()|, |strdisplaywidth()| and |strchars()|.
 
-submatch({nr})						*submatch()*
+submatch({nr}[, {list}])				*submatch()*
 		Only for an expression in a |:substitute| command or
 		substitute() function.
 		Returns the {nr}'th submatch of the matched text.  When {nr}
 		is 0 the whole matched text is returned.
+		Note that a NL in the string can stand for a line break of a
+		multi-line match or a NUL character in the text.
 		Also see |sub-replace-expression|.
+
+		If {list} is present and non-zero then submatch() returns 
+		a list of strings, similar to |getline()| with two arguments. 
+		NL characters in the text represent NUL characters in the
+		text.
+		Only returns more than one item for |:substitute|, inside
+		|substitute()| this list will always contain one or zero
+		items, since there are no real line breaks.
+
 		Example: >
 			:s/\d\+/\=submatch(0) + 1/
 <		This finds the first number in the line and adds one to it.
@@ -5867,19 +6083,35 @@
 		valid positions.
 
 system({expr} [, {input}])				*system()* *E677*
-		Get the output of the shell command {expr}.
-		When {input} is given, this string is written to a file and
-		passed as stdin to the command.  The string is written as-is,
-		you need to take care of using the correct line separators
-		yourself.  Pipes are not used.
-		Note: Use |shellescape()| to escape special characters in a
-		command argument.  Newlines in {expr} may cause the command to
-		fail.  The characters in 'shellquote' and 'shellxquote' may
-		also cause trouble.
+		Get the output of the shell command {expr} as a string.  See
+		|systemlist()| to get the output as a List.
+
+		When {input} is given and is a string this string is written 
+		to a file and passed as stdin to the command.  The string is 
+		written as-is, you need to take care of using the correct line 
+		separators yourself.
+		If {input} is given and is a |List| it is written to the file
+		in a way |writefile()| does with {binary} set to "b" (i.e.
+		with a newline between each list item with newlines inside
+		list items converted to NULs).  
+		Pipes are not used.
+
+		When prepended by |:silent| the shell will not be set to
+		cooked mode.  This is meant to be used for commands that do
+		not need the user to type.  It avoids stray characters showing
+		up on the screen which require |CTRL-L| to remove. >
+			:silent let f = system('ls *.vim')
+<
+		Note: Use |shellescape()| or |::S| with |expand()| or 
+		|fnamemodify()| to escape special characters in a command 
+		argument.  Newlines in {expr} may cause the command to fail.  
+		The characters in 'shellquote' and 'shellxquote' may also 
+		cause trouble.
 		This is not to be used for interactive commands.
 
 		The result is a String.  Example: >
 		    :let files = system("ls " .  shellescape(expand('%:h')))
+		    :let files = system('ls ' . expand('%:h:S'))
 
 <		To make the result more system-independent, the shell output
 		is filtered to replace <CR> with <NL> for Macintosh, and
@@ -5906,6 +6138,16 @@
 		Use |:checktime| to force a check.
 
 
+systemlist({expr} [, {input}])				*systemlist()*
+		Same as |system()|, but returns a |List| with lines (parts of 
+		output separated by NL) with NULs transformed into NLs. Output 
+		is the same as |readfile()| will output with {binary} argument 
+		set to "b".
+
+		Returns an empty string on error, so be careful not to run 
+		into |E706|.
+
+
 tabpagebuflist([{arg}])					*tabpagebuflist()*
 		The result is a |List|, where each item is the number of the
 		buffer associated with each window in the current tab page.
@@ -5928,7 +6170,7 @@
 		The number can be used with the |:tab| command.
 
 
-tabpagewinnr({tabarg}, [{arg}])				*tabpagewinnr()*
+tabpagewinnr({tabarg} [, {arg}])			*tabpagewinnr()*
 		Like |winnr()| but for tab page {tabarg}.
 		{tabarg} specifies the number of tab page to be used.
 		{arg} is used like with |winnr()|:
@@ -6128,6 +6370,14 @@
 				blocks.  Each item may again have an "alt"
 				item.
 
+uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
+		Remove second and succeeding copies of repeated adjacent
+		{list} items in-place.  Returns {list}.  If you want a list
+		to remain unmodified make a copy first: >
+			:let newlist = uniq(copy(mylist))
+<		The default compare function uses the string representation of
+		each item.  For the use of {func} and {dict} see |sort()|.
+
 values({dict})						*values()*
 		Return a |List| with all the values of {dict}.	The |List| is
 		in arbitrary order.
@@ -6257,6 +6507,16 @@
 winrestview({dict})
 		Uses the |Dictionary| returned by |winsaveview()| to restore
 		the view of the current window.
+		Note: The {dict} does not have to contain all values, that are
+		returned by |winsaveview()|. If values are missing, those
+		settings won't be restored. So you can use: >
+		    :call winrestview({'curswant': 4})
+<
+		This will only set the curswant value (the column the cursor
+		wants to move on vertical movements) of the cursor to column 5
+		(yes, that is 5), while all other settings will remain the
+		same. This is useful, if you set the cursor position manually.
+
 		If you have changed the values the result is unpredictable.
 		If the window size changed the result won't be the same.
 
@@ -6268,10 +6528,12 @@
 		buffer and you want to go back to the original view.
 		This does not save fold information.  Use the 'foldenable'
 		option to temporarily switch off folding, so that folds are
-		not opened when moving around.
+		not opened when moving around. This may have side effects.
 		The return value includes:
 			lnum		cursor line number
-			col		cursor column
+			col		cursor column (Note: the first column
+					zero, as opposed to what getpos()
+					returns)
 			coladd		cursor column offset for 'virtualedit'
 			curswant	column for vertical movement
 			topline		first line in the window
@@ -6322,7 +6584,7 @@
 
 
 							*feature-list*
-There are three types of features:
+There are four types of features:
 1.  Features that are only supported when they have been enabled when Vim
     was compiled |+feature-list|.  Example: >
 	:if has("cindent")
@@ -6330,13 +6592,24 @@
     Example: >
 	:if has("gui_running")
 <							*has-patch*
-3.  Included patches.  First check |v:version| for the version of Vim.
-    Then the "patch123" feature means that patch 123 has been included for
-    this version.  Example (checking version 6.2.148 or later): >
+3.  Included patches.  The "patch123" feature means that patch 123 has been
+    included.  Note that this form does not check the version of Vim, you need
+    to inspect |v:version| for that.
+    Example (checking version 6.2.148 or later): >
 	:if v:version > 602 || v:version == 602 && has("patch148")
-<   Note that it's possible for patch 147 to be omitted even though 148 is
+<    Note that it's possible for patch 147 to be omitted even though 148 is
+    included.
+
+4.  Beyond a certain version or at a certain version and including a specific
+    patch.  The "patch-7.4.237" feature means that the Vim version is 7.5 or
+    later, or it is version 7.4 and patch 237 was included.
+    Note that this only works for patch 7.4.237 and later, before that you
+    need to use the example above that checks v:version.  Example: >
+	:if has("patch-7.4.248")
+<    Note that it's possible for patch 147 to be omitted even though 148 is
     included.
 
+acl			Compiled with |ACL| support.
 all_builtin_terms	Compiled with all builtin terminals enabled.
 amiga			Amiga version of Vim.
 arabic			Compiled with Arabic support |Arabic|.
@@ -6365,6 +6638,7 @@
 dialog_gui		Compiled with GUI dialog support.
 diff			Compiled with |vimdiff| and 'diff' support.
 digraphs		Compiled with support for digraphs.
+directx			Compiled with support for Direct-X and 'renderoptions'.
 dnd			Compiled with support for the "~ register |quote_~|.
 dos16			16 bits DOS version of Vim.
 dos32			32 bits DOS (DJGPP) version of Vim.
@@ -6407,8 +6681,8 @@
 keymap			Compiled with 'keymap' support.
 langmap			Compiled with 'langmap' support.
 libcall			Compiled with |libcall()| support.
-linebreak		Compiled with 'linebreak', 'breakat' and 'showbreak'
-			support.
+linebreak		Compiled with 'linebreak', 'breakat', 'showbreak' and
+			'breakindent' support.
 lispindent		Compiled with support for lisp indenting.
 listcmds		Compiled with commands for the buffer list |:files|
 			and the argument list |arglist|.
@@ -6503,7 +6777,9 @@
 writebackup		Compiled with 'writebackup' default on.
 xfontset		Compiled with X fontset support |xfontset|.
 xim			Compiled with X input method support |xim|.
-xpm_w32			Compiled with pixmap support for Win32.
+xpm			Compiled with pixmap support.
+xpm_w32			Compiled with pixmap support for Win32. (Only for
+			backward compatibility. Use "xpm" instead.)
 xsmp			Compiled with X session management support.
 xsmp_interact		Compiled with interactive X session management support.
 xterm_clipboard		Compiled with support for xterm clipboard.
@@ -6553,6 +6829,8 @@
 and autocommands defined in the script.  It is also possible to call the
 function from a mapping defined in the script, but then |<SID>| must be used
 instead of "s:" when the mapping is expanded outside of the script.
+There are only script-local functions, no buffer-local or window-local
+functions.
 
 					*:fu* *:function* *E128* *E129* *E123*
 :fu[nction]		List all functions and their arguments.
@@ -6576,11 +6854,15 @@
 <
 See |:verbose-cmd| for more information.
 
-							*E124* *E125* *E853*
+						*E124* *E125* *E853* *E884*
 :fu[nction][!] {name}([arguments]) [range] [abort] [dict]
 			Define a new function by the name {name}.  The name
 			must be made of alphanumeric characters and '_', and
-			must start with a capital or "s:" (see above).
+			must start with a capital or "s:" (see above).  Note
+			that using "b:" or "g:" is not allowed. (since patch
+			7.4.260 E884 is given if the function name has a colon
+			in the name, e.g. for "foo:bar()".  Before that patch
+			no error was given).
 
 			{name} can also be a |Dictionary| entry that is a
 			|Funcref|: >
@@ -6599,7 +6881,7 @@
 
 			For the {arguments} see |function-argument|.
 
-						*a:firstline* *a:lastline*
+					*:func-range* *a:firstline* *a:lastline*
 			When the [range] argument is added, the function is
 			expected to take care of a range itself.  The range is
 			passed as "a:firstline" and "a:lastline".  If [range]
@@ -6608,10 +6890,10 @@
 			of each line.  See |function-range-example|.
 			The cursor is still moved to the first line of the
 			range, as is the case with all Ex commands.
-
+								*:func-abort*
 			When the [abort] argument is added, the function will
 			abort as soon as an error is detected.
-
+								*:func-dict*
 			When the [dict] argument is added, the function must
 			be invoked through an entry in a |Dictionary|.	The
 			local variable "self" will then be set to the
@@ -7273,6 +7555,8 @@
 			{pattern}, so long as it does not have a special
 			meaning (e.g., '|' or '"') and doesn't occur inside
 			{pattern}.
+			Information about the exception is available in
+			|v:exception|.  Also see |throw-variables|.
 			NOTE: It is not reliable to ":catch" the TEXT of
 			an error message because it may vary in different
 			locales.
@@ -7416,13 +7700,22 @@
 			for Vim commands, |shellescape()| for |:!| commands.
 			Examples: >
 		:execute "e " . fnameescape(filename)
-		:execute "!ls " . shellescape(expand('%:h'), 1)
+		:execute "!ls " . shellescape(filename, 1)
 <
 			Note: The executed string may be any command-line, but
-			you cannot start or end a "while", "for" or "if"
-			command.  Thus this is illegal: >
-		:execute 'while i > 5'
-		:execute 'echo "test" | break'
+			starting or ending "if", "while" and "for" does not
+			always work, because when commands are skipped the
+			":execute" is not evaluated and Vim loses track of
+			where blocks start and end.  Also "break" and
+			"continue" should not be inside ":execute".
+			This example does not work, because the ":execute" is
+			not evaluated and Vim does not see the "while", and
+			gives an error for finding an ":endwhile": >
+		:if 0
+		: execute 'while i > 5'
+		:  echo "test"
+		: endwhile
+		:endif
 <
 			It is allowed to have a "while" or "if" command
 			completely in the executed string: >
diff -Naur vim74.orig/runtime/doc/filetype.txt vim74/runtime/doc/filetype.txt
--- vim74.orig/runtime/doc/filetype.txt	2013-08-10 11:24:53.000000000 +0000
+++ vim74/runtime/doc/filetype.txt	2014-10-10 14:53:40.128724476 +0000
@@ -1,4 +1,4 @@
-*filetype.txt*  For Vim version 7.4.  Last change: 2013 May 25
+*filetype.txt*  For Vim version 7.4.  Last change: 2013 Dec 15
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -447,23 +447,25 @@
 				%%	insert a single '%' character
 				%d	insert the date from above
 				%u	insert the user from above
+                                %p	insert result of b:changelog_entry_prefix
 				%c	where to position cursor when done
-			The default is "%d  %u\n\n\t* %c\n\n", which produces
+			The default is "%d  %u\n\n\t* %p%c\n\n", which produces
 			something like (| is where cursor will be, unless at
 			the start of the line where it denotes the beginning
 			of the line) >
 				|2003-01-14  Full Name  <user@host>
 				|
-				|        * |
+				|        * prefix|
 <
 g:changelog_new_entry_format
 			The format used when creating a new entry.
 			The following table describes special tokens in the
 			string:
+                                %p	insert result of b:changelog_entry_prefix
 				%c	where to position cursor when done
 			The default is "\t*%c", which produces something
 			similar to >
-				|        * |
+				|        * prefix|
 <
 g:changelog_date_entry_search
 			The search pattern to use when searching for a
diff -Naur vim74.orig/runtime/doc/fold.txt vim74/runtime/doc/fold.txt
--- vim74.orig/runtime/doc/fold.txt	2013-08-10 11:24:53.000000000 +0000
+++ vim74/runtime/doc/fold.txt	2014-10-10 14:53:40.128724476 +0000
@@ -1,4 +1,4 @@
-*fold.txt*      For Vim version 7.4.  Last change: 2010 May 13
+*fold.txt*      For Vim version 7.4.  Last change: 2013 Dec 04
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -285,9 +285,10 @@
 							*zd* *E351*
 zd		Delete one fold at the cursor.  When the cursor is on a folded
 		line, that fold is deleted.  Nested folds are moved one level
-		up.  In Visual mode all folds (partially) in the selected area
-		are deleted.  Careful: This easily deletes more folds than you
-		expect and there is no undo.
+		up.  In Visual mode one level of all folds (partially) in the
+		selected area are deleted.
+		Careful: This easily deletes more folds than you expect and
+		there is no undo for manual folding.
 		This only works when 'foldmethod' is "manual" or "marker".
 		Also see |fold-delete-marker|.
 
diff -Naur vim74.orig/runtime/doc/gui.txt vim74/runtime/doc/gui.txt
--- vim74.orig/runtime/doc/gui.txt	2013-08-10 11:24:53.000000000 +0000
+++ vim74/runtime/doc/gui.txt	2014-10-10 14:53:40.138724451 +0000
@@ -1,4 +1,4 @@
-*gui.txt*       For Vim version 7.4.  Last change: 2013 Jun 12
+*gui.txt*       For Vim version 7.4.  Last change: 2014 Mar 08
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -133,6 +133,7 @@
 :winp[os]
 		Display current position of the top left corner of the GUI vim
 		window in pixels.  Does not work in all versions.
+		Also see |getwinposx()| and |getwinposy()|.
 
 :winp[os] {X} {Y}							*E466*
 		Put the GUI vim window at the given {X} and {Y} coordinates.
@@ -151,8 +152,11 @@
 		option.
 
 If you are running the X Window System, you can get information about the
-window Vim is running in with this command: >
+window Vim is running in with these commands: >
 	:!xwininfo -id $WINDOWID
+	:!xprop -id $WINDOWID
+	:execute '!xwininfo -id ' . v:windowid
+	:execute '!xprop -id ' . v:windowid
 <
 							*gui-IME* *iBus*
 Input methods for international characters in X that rely on the XIM
diff -Naur vim74.orig/runtime/doc/gui_x11.txt vim74/runtime/doc/gui_x11.txt
--- vim74.orig/runtime/doc/gui_x11.txt	2013-08-10 11:24:54.000000000 +0000
+++ vim74/runtime/doc/gui_x11.txt	2014-10-10 14:53:40.145391101 +0000
@@ -1,4 +1,4 @@
-*gui_x11.txt*   For Vim version 7.4.  Last change: 2011 Sep 14
+*gui_x11.txt*   For Vim version 7.4.  Last change: 2014 Mar 08
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -442,7 +442,7 @@
 							*gui-x11-kde*
 There is no KDE version of Vim.  There has been some work on a port using the
 Qt toolkit, but it never worked properly and it has been abandoned.  Work
-continues on Yzis: www.yzis.org.
+continues on Yzis: https://github.com/chrizel/Yzis.
 
 ==============================================================================
 8. Compiling						*gui-x11-compiling*
diff -Naur vim74.orig/runtime/doc/helphelp.txt vim74/runtime/doc/helphelp.txt
--- vim74.orig/runtime/doc/helphelp.txt	2013-08-10 11:24:54.000000000 +0000
+++ vim74/runtime/doc/helphelp.txt	2014-10-10 14:53:40.155391076 +0000
@@ -1,4 +1,4 @@
-*helphelp.txt*	For Vim version 7.4.  Last change: 2012 Nov 28
+*helphelp.txt*	For Vim version 7.4.  Last change: 2014 Sep 19
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -96,6 +96,9 @@
 			find a tag in a file with the same language as the
 			current file.  See |help-translated|.
 
+						 	*:helpc* *:helpclose*
+:helpc[lose]            Close one help window, if there is one.
+
 							*:helpg* *:helpgrep*
 :helpg[rep] {pattern}[@xx]
 			Search all help text files and make a list of lines
diff -Naur vim74.orig/runtime/doc/if_lua.txt vim74/runtime/doc/if_lua.txt
--- vim74.orig/runtime/doc/if_lua.txt	2013-08-10 11:24:55.000000000 +0000
+++ vim74/runtime/doc/if_lua.txt	2014-10-10 14:53:40.162057726 +0000
@@ -1,4 +1,4 @@
-*if_lua.txt*    For Vim version 7.4.  Last change: 2012 Jun 29
+*if_lua.txt*    For Vim version 7.4.  Last change: 2013 Sep 04
 
 
 		  VIM REFERENCE MANUAL    by Luis Carvalho
@@ -135,7 +135,7 @@
 <
 	vim.funcref({name})	Returns a Funcref to function {name} (see
 				|Funcref|). It is equivalent to Vim's
-				"function".
+				"function". NOT IMPLEMENTED YET
 
 	vim.buffer([arg])	If "arg" is a number, returns buffer with
 				number "arg" in the buffer list or, if "arg"
diff -Naur vim74.orig/runtime/doc/if_perl.txt vim74/runtime/doc/if_perl.txt
--- vim74.orig/runtime/doc/if_perl.txt	2013-08-10 11:24:55.000000000 +0000
+++ vim74/runtime/doc/if_perl.txt	2014-10-10 14:53:40.168724376 +0000
@@ -1,4 +1,4 @@
-*if_perl.txt*   For Vim version 7.4.  Last change: 2012 Oct 25
+*if_perl.txt*   For Vim version 7.4.  Last change: 2013 Oct 05
 
 
 		  VIM REFERENCE MANUAL    by Sven Verdoolaege
diff -Naur vim74.orig/runtime/doc/if_pyth.txt vim74/runtime/doc/if_pyth.txt
--- vim74.orig/runtime/doc/if_pyth.txt	2013-08-10 11:24:55.000000000 +0000
+++ vim74/runtime/doc/if_pyth.txt	2014-10-10 14:53:40.172057701 +0000
@@ -1,4 +1,4 @@
-*if_pyth.txt*   For Vim version 7.4.  Last change: 2013 Jul 10
+*if_pyth.txt*   For Vim version 7.4.  Last change: 2014 Jul 23
 
 
 		  VIM REFERENCE MANUAL    by Paul Moore
@@ -28,7 +28,7 @@
 ==============================================================================
 1. Commands						*python-commands*
 
-					*:python* *:py* *E205* *E263* *E264*
+					*:python* *:py* *E263* *E264* *E887*
 :[range]py[thon] {stmt}
 			Execute Python statement {stmt}.  A simple check if
 			the `:python` command is working: >
diff -Naur vim74.orig/runtime/doc/indent.txt vim74/runtime/doc/indent.txt
--- vim74.orig/runtime/doc/indent.txt	2013-08-10 11:24:56.000000000 +0000
+++ vim74/runtime/doc/indent.txt	2014-10-10 14:53:40.185391001 +0000
@@ -1,4 +1,4 @@
-*indent.txt*    For Vim version 7.4.  Last change: 2013 Aug 03
+*indent.txt*    For Vim version 7.4.  Last change: 2014 Apr 23
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -545,10 +545,12 @@
 	      (default 70 lines).
 
 								*cino-#*
-	#N    When N is non-zero recognize shell/Perl comments, starting with
-	      '#'.  Default N is zero: don't recognize '#' comments.  Note
-	      that lines starting with # will still be seen as preprocessor
-	      lines.
+	#N    When N is non-zero recognize shell/Perl comments starting with
+	      '#', do not recognize preprocessor lines; allow right-shifting
+	      lines that start with "#".
+	      When N is zero (default): don't recognize '#' comments, do
+	      recognize preprocessor lines; right-shifting lines that start
+	      with "#" does not work.
 
 
 The defaults, spelled out in full, are:
@@ -556,7 +558,7 @@
 			c3,C0,/0,(2s,us,U0,w0,W0,k0,m0,j0,J0,)20,*70,#0
 
 Vim puts a line in column 1 if:
-- It starts with '#' (preprocessor directives), if 'cinkeys' contains '#'.
+- It starts with '#' (preprocessor directives), if 'cinkeys' contains '#0'.
 - It starts with a label (a keyword followed by ':', other than "case" and
   "default") and 'cinoptions' does not contain an 'L' entry with a positive
   value.
@@ -581,8 +583,8 @@
 
 Clojure indentation differs somewhat from traditional Lisps, due in part to
 the use of square and curly brackets, and otherwise by community convention.
-These conventions are not always universally followed, so the Clojure indent
-script offers a few configurable options, listed below.
+These conventions are not universally followed, so the Clojure indent script
+offers a few configurable options, listed below.
 
 If the current vim does not include searchpairpos(), the indent script falls
 back to normal 'lisp' indenting, and the following options are ignored.
@@ -596,7 +598,6 @@
 	" Default
 	let g:clojure_maxlines = 100
 <
-
 						*g:clojure_fuzzy_indent*
 					*g:clojure_fuzzy_indent_patterns*
 					*g:clojure_fuzzy_indent_blacklist*
@@ -650,7 +651,6 @@
 	let g:clojure_special_indent_words =
 	   \ 'deftype,defrecord,reify,proxy,extend-type,extend-protocol,letfn'
 <
-
 					*g:clojure_align_multiline_strings*
 
 Align subsequent lines in multiline strings to the column after the opening
@@ -675,7 +675,28 @@
 	" Default
 	let g:clojure_align_multiline_strings = 0
 <
+						*g:clojure_align_subforms*
 
+By default, parenthesized compound forms that look like function calls and
+whose head subform is on its own line have subsequent subforms indented by
+two spaces relative to the opening paren:
+>
+	(foo
+	  bar
+	  baz)
+<
+Setting this option changes this behavior so that all subforms are aligned to
+the same column, emulating the default behavior of clojure-mode.el:
+>
+	(foo
+	 bar
+	 baz)
+<
+This option is off by default.
+>
+	" Default
+	let g:clojure_align_subforms = 0
+<
 
 FORTRAN							*ft-fortran-indent*
 
@@ -791,7 +812,7 @@
 PHP indenting can be altered in several ways by modifying the values of some
 global variables:
 
-								*php-comment*
+					*php-comment* *PHP_autoformatcomment*
 To not enable auto-formating of comments by default (if you want to use your
 own 'formatoptions'): >
     :let g:PHP_autoformatcomment = 0
@@ -800,6 +821,7 @@
 added, see |fo-table| for more information.
 -------------
 
+							*PHP_outdentSLComments*
 To add extra indentation to single-line comments: >
     :let g:PHP_outdentSLComments = N
 
@@ -811,6 +833,7 @@
     /* Comment */
 -------------
 
+							*PHP_default_indenting*
 To add extra indentation to every PHP lines with N being the number of
 'shiftwidth' to add: >
     :let g:PHP_default_indenting = N
@@ -830,14 +853,18 @@
 (Notice the extra indentation between the PHP container markers and the code)
 -------------
 
-To indent PHP tags as the surrounding code: >
-    :let g:PHP_outdentphpescape = 0
+							*PHP_outdentphpescape*
+To indent PHP escape tags as the surrounding non-PHP code (only affects the
+PHP escape tags): >
+:let g:PHP_outdentphpescape = 0
 -------------
 
+							*PHP_removeCRwhenUnix*
 To automatically remove '\r' characters when the 'fileformat' is set to Unix: >
     :let g:PHP_removeCRwhenUnix = 1
 -------------
 
+							*PHP_BracesAtCodeLevel*
 To indent braces at the same level than the code they contain: >
     :let g:PHP_BracesAtCodeLevel = 1
     
@@ -856,6 +883,7 @@
 	optimizations won't be available.
 -------------
 
+							*PHP_vintage_case_default_indent*
 To indent 'case:' and 'default:' statements in switch() blocks: >
     :let g:PHP_vintage_case_default_indent = 1
 
diff -Naur vim74.orig/runtime/doc/index.txt vim74/runtime/doc/index.txt
--- vim74.orig/runtime/doc/index.txt	2013-08-10 11:24:56.000000000 +0000
+++ vim74/runtime/doc/index.txt	2014-10-10 14:53:40.202057625 +0000
@@ -1,4 +1,4 @@
-*index.txt*     For Vim version 7.4.  Last change: 2013 Jul 17
+*index.txt*     For Vim version 7.4.  Last change: 2014 Sep 19
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -1124,8 +1124,8 @@
 |:cNfile|	:cNf[ile]	go to last error in previous file
 |:cabbrev|	:ca[bbrev]	like ":abbreviate" but for Command-line mode
 |:cabclear|	:cabc[lear]	clear all abbreviations for Command-line mode
-|:caddbuffer|	:caddb[uffer]	add errors from buffer
-|:caddexpr|	:cad[dexpr]	add errors from expr
+|:caddbuffer|	:cad[dbuffer]	add errors from buffer
+|:caddexpr|	:cadde[xpr]	add errors from expr
 |:caddfile|	:caddf[ile]	add error message to current quickfix list
 |:call|		:cal[l]		call a function
 |:catch|	:cat[ch]	part of a :try command
@@ -1191,12 +1191,12 @@
 |:digraphs|	:dig[raphs]	show or enter digraphs
 |:display|	:di[splay]	display registers
 |:djump|	:dj[ump]	jump to #define
-|:dl|		:dl		short for |:delete|
-|:dl|		:del[ete]l	short for |:delete|
+|:dl|		:dl		short for |:delete| with the 'l' flag
+|:dl|		:del[ete]l	short for |:delete| with the 'l' flag
 |:dlist|	:dli[st]	list #defines
 |:doautocmd|	:do[autocmd]	apply autocommands to current buffer
 |:doautoall|	:doautoa[ll]	apply autocommands for all loaded buffers
-|:dp|		:d[elete]p	short for |:delete|
+|:dp|		:d[elete]p	short for |:delete| with the 'p' flag
 |:drop|		:dr[op]		jump to window editing file or edit file in
 				current window
 |:dsearch|	:ds[earch]	list one #define
@@ -1244,6 +1244,7 @@
 |:gvim|		:gv[im]		start the GUI
 |:hardcopy|	:ha[rdcopy]	send text to the printer
 |:help|		:h[elp]		open a help window
+|:helpclose|	:helpc[lose]	close one help window
 |:helpfind|	:helpf[ind]	dialog to open a help window
 |:helpgrep|	:helpg[rep]	like ":grep" but searches help files
 |:helptags|	:helpt[ags]	generate help tags for a directory
@@ -1275,6 +1276,7 @@
 |:keepalt|	:keepa[lt]	following command keeps the alternate file
 |:keepmarks|	:kee[pmarks]	following command keeps marks where they are
 |:keepjumps|	:keepj[umps]	following command keeps jumplist and marks
+|:keeppatterns|	:keepp[atterns]	following command keeps search pattern history
 |:lNext|	:lN[ext]	go to previous entry in location list
 |:lNfile|	:lNf[ile]	go to last entry in previous file
 |:list|		:l[ist]		print lines
@@ -1360,13 +1362,14 @@
 |:nmenu|	:nme[nu]	add menu for Normal mode
 |:nnoremap|	:nn[oremap]	like ":noremap" but for Normal mode
 |:nnoremenu|	:nnoreme[nu]	like ":noremenu" but for Normal mode
-|:noautocmd|	:noa[utocmd]	following command don't trigger autocommands
+|:noautocmd|	:noa[utocmd]	following commands don't trigger autocommands
 |:noremap|	:no[remap]	enter a mapping that will not be remapped
 |:nohlsearch|	:noh[lsearch]	suspend 'hlsearch' highlighting
 |:noreabbrev|	:norea[bbrev]	enter an abbreviation that will not be
 				remapped
 |:noremenu|	:noreme[nu]	enter a menu that will not be remapped
 |:normal|	:norm[al]	execute Normal mode commands
+|:noswapfile|	:nos[wapfile]	following commands don't create a swap file
 |:number|	:nu[mber]	print lines with line number
 |:nunmap|	:nun[map]	like ":unmap" but for Normal mode
 |:nunmenu|	:nunme[nu]	remove menu for Normal mode
diff -Naur vim74.orig/runtime/doc/insert.txt vim74/runtime/doc/insert.txt
--- vim74.orig/runtime/doc/insert.txt	2013-08-10 11:24:56.000000000 +0000
+++ vim74/runtime/doc/insert.txt	2014-10-10 14:53:40.208724275 +0000
@@ -1,4 +1,4 @@
-*insert.txt*    For Vim version 7.4.  Last change: 2013 Jul 12
+*insert.txt*    For Vim version 7.4.  Last change: 2014 Aug 04
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -51,6 +51,8 @@
 		abbreviation.
 		Note: If your <Esc> key is hard to hit on your keyboard, train
 		yourself to use CTRL-[.
+		If Esc doesn't work and you are using a Mac, try CTRL-Esc.
+		Or disable Listening under Accessibility preferences.
 						*i_CTRL-C*
 CTRL-C		Quit insert mode, go back to Normal mode.  Do not check for
 		abbreviations.  Does not trigger the |InsertLeave| autocommand
@@ -1302,7 +1304,7 @@
 XHTML							*ft-xhtml-omni*
 
 CTRL-X CTRL-O provides completion of various elements of (X)HTML files.  It is
-designed to support writing of XHTML 1.0 Strict files but will also works for
+designed to support writing of XHTML 1.0 Strict files but will also work for
 other versions of HTML. Features:
 
 - after "<" complete tag name depending on context (no div suggestion inside
diff -Naur vim74.orig/runtime/doc/intro.txt vim74/runtime/doc/intro.txt
--- vim74.orig/runtime/doc/intro.txt	2013-08-10 11:24:56.000000000 +0000
+++ vim74/runtime/doc/intro.txt	2014-10-10 14:53:40.222057575 +0000
@@ -1,4 +1,4 @@
-*intro.txt*     For Vim version 7.4.  Last change: 2013 Jun 17
+*intro.txt*     For Vim version 7.4.  Last change: 2014 May 24
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -136,9 +136,10 @@
 Bug reports:				*bugs* *bug-reports* *bugreport.vim*
 
 Send bug reports to: Vim Developers <vim_dev@vim.org>
-This is a maillist, many people will see the message.  If you don't want that,
-e.g. because it is a security issue, send it to <bugs@vim.org>, this only goes
-to the Vim maintainer (that's Bram).
+This is a maillist, you need to become a member first and many people will see
+the message.  If you don't want that, e.g. because it is a security issue,
+send it to <bugs@vim.org>, this only goes to the Vim maintainer (that's Bram).
+
 Please be brief; all the time that is spent on answering mail is subtracted
 from the time that is spent on improving Vim!  Always give a reproducible
 example and try to find out which settings or other things influence the
diff -Naur vim74.orig/runtime/doc/map.txt vim74/runtime/doc/map.txt
--- vim74.orig/runtime/doc/map.txt	2013-08-10 11:24:56.000000000 +0000
+++ vim74/runtime/doc/map.txt	2014-10-10 14:53:40.232057550 +0000
@@ -1,4 +1,4 @@
-*map.txt*       For Vim version 7.4.  Last change: 2013 Aug 03
+*map.txt*       For Vim version 7.4.  Last change: 2014 Sep 30
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -60,17 +60,17 @@
 			{rhs}, is then further scanned for mappings.  This
 			allows for nested and recursive use of mappings.
 
-
-:no[remap]  {lhs} {rhs}		|mapmode-nvo|		*:no*  *:noremap*
-:nn[oremap] {lhs} {rhs}		|mapmode-n|		*:nn*  *:nnoremap*
-:vn[oremap] {lhs} {rhs}		|mapmode-v|		*:vn*  *:vnoremap*
-:xn[oremap] {lhs} {rhs}		|mapmode-x|		*:xn*  *:xnoremap*
-:snor[emap] {lhs} {rhs}		|mapmode-s|		*:snor* *:snoremap*
-:ono[remap] {lhs} {rhs}		|mapmode-o|		*:ono* *:onoremap*
-:no[remap]! {lhs} {rhs}		|mapmode-ic|		*:no!* *:noremap!*
-:ino[remap] {lhs} {rhs}		|mapmode-i|		*:ino* *:inoremap*
-:ln[oremap] {lhs} {rhs}		|mapmode-l|		*:ln*  *:lnoremap*
-:cno[remap] {lhs} {rhs}		|mapmode-c|		*:cno* *:cnoremap*
+						*:nore* *:norem*
+:no[remap]  {lhs} {rhs}		|mapmode-nvo|	*:no*  *:noremap* *:nor*
+:nn[oremap] {lhs} {rhs}		|mapmode-n|	*:nn*  *:nnoremap*
+:vn[oremap] {lhs} {rhs}		|mapmode-v|	*:vn*  *:vnoremap*
+:xn[oremap] {lhs} {rhs}		|mapmode-x|	*:xn*  *:xnoremap*
+:snor[emap] {lhs} {rhs}		|mapmode-s|	*:snor* *:snoremap*
+:ono[remap] {lhs} {rhs}		|mapmode-o|	*:ono* *:onoremap*
+:no[remap]! {lhs} {rhs}		|mapmode-ic|	*:no!* *:noremap!*
+:ino[remap] {lhs} {rhs}		|mapmode-i|	*:ino* *:inoremap*
+:ln[oremap] {lhs} {rhs}		|mapmode-l|	*:ln*  *:lnoremap*
+:cno[remap] {lhs} {rhs}		|mapmode-c|	*:cno* *:cnoremap*
 			Map the key sequence {lhs} to {rhs} for the modes
 			where the map command applies.  Disallow mapping of
 			{rhs}, to avoid nested and recursive mappings.  Often
@@ -306,9 +306,21 @@
 to type a count with a zero.
 
 						*map-overview* *map-modes*
-Overview of which map command works in which mode:
+Overview of which map command works in which mode.  More details below.
+     COMMANDS                    MODES ~
+:map   :noremap  :unmap     Normal, Visual, Select, Operator-pending
+:nmap  :nnoremap :nunmap    Normal
+:vmap  :vnoremap :vunmap    Visual and Select
+:smap  :snoremap :sunmap    Select
+:xmap  :xnoremap :xunmap    Visual
+:omap  :onoremap :ounmap    Operator-pending
+:map!  :noremap! :unmap!    Insert and Command-line
+:imap  :inoremap :iunmap    Insert
+:lmap  :lnoremap :lunmap    Insert, Command-line, Lang-Arg
+:cmap  :cnoremap :cunmap    Command-line
+
 
-    commands:				      modes: ~
+    COMMANDS				      MODES ~
 				       Normal  Visual+Select  Operator-pending ~
 :map   :noremap   :unmap   :mapclear	 yes	    yes		   yes
 :nmap  :nnoremap  :nunmap  :nmapclear	 yes	     -		    -
@@ -324,7 +336,7 @@
 better to explicitly use :xmap and :smap for printable characters.  Or use
 :sunmap after defining the mapping.
 
-    commands:				      modes: ~
+    COMMANDS				      MODES ~
 					  Visual    Select ~
 :vmap  :vnoremap  :vunmap  :vmapclear	    yes      yes
 :xmap  :xnoremap  :xunmap  :xmapclear	    yes       -
@@ -333,7 +345,7 @@
 			*mapmode-ic* *mapmode-i* *mapmode-c* *mapmode-l*
 Some commands work both in Insert mode and Command-line mode, some not:
 
-    commands:				      modes: ~
+    COMMANDS				      MODES ~
 					  Insert  Command-line	Lang-Arg ~
 :map!  :noremap!  :unmap!  :mapclear!	    yes	       yes	   -
 :imap  :inoremap  :iunmap  :imapclear	    yes		-	   -
@@ -380,7 +392,7 @@
    The simplest way to load a set of related language mappings is by using the
 'keymap' option.  See |45.5|.
    In Insert mode and in Command-line mode the mappings can be disabled with
-the CTRL-^ command |i_CTRL-^| |c_CTRL-^| These commands change the value of
+the CTRL-^ command |i_CTRL-^| |c_CTRL-^|. These commands change the value of
 the 'iminsert' option.  When starting to enter a normal command line (not a
 search pattern) the mappings are disabled until a CTRL-^ is typed.  The state
 last used is remembered for Insert mode and Search patterns separately.  The
@@ -593,7 +605,7 @@
 When you have a mapping that contains an Ex command, you need to put a line
 terminator after it to have it executed.  The use of <CR> is recommended for
 this (see |<>|).  Example: >
-   :map  _ls  :!ls -l %<CR>:echo "the end"<CR>
+   :map  _ls  :!ls -l %:S<CR>:echo "the end"<CR>
 
 To avoid mapping of the characters you type in insert or Command-line mode,
 type a CTRL-V first.  The mapping in Insert mode is disabled if the 'paste'
@@ -816,12 +828,10 @@
 	  let &selection = "inclusive"
 	  let reg_save = @@
 
-	  if a:0  " Invoked from Visual mode, use '< and '> marks.
-	    silent exe "normal! `<" . a:type . "`>y"
+	  if a:0  " Invoked from Visual mode, use gv command.
+	    silent exe "normal! gvy"
 	  elseif a:type == 'line'
 	    silent exe "normal! '[V']y"
-	  elseif a:type == 'block'
-	    silent exe "normal! `[\<C-V>`]y"
 	  else
 	    silent exe "normal! `[v`]y"
 	  endif
@@ -1273,6 +1283,8 @@
 	-complete=custom,{func} custom completion, defined via {func}
 	-complete=customlist,{func} custom completion, defined via {func}
 
+Note: That some completion methods might expand environment variables.
+
 
 Custom completion			*:command-completion-custom*
 					*:command-completion-customlist*
@@ -1359,6 +1371,8 @@
 In the cases of the -count and -register attributes, if the optional argument
 is supplied, it is removed from the argument list and is available to the
 replacement text separately.
+Note that these arguments can be abbreviated, but that is a deprecated
+feature.  Use the full name for new scripts.
 
 Replacement text
 
diff -Naur vim74.orig/runtime/doc/motion.txt vim74/runtime/doc/motion.txt
--- vim74.orig/runtime/doc/motion.txt	2013-08-10 11:24:57.000000000 +0000
+++ vim74/runtime/doc/motion.txt	2014-10-10 14:53:40.248724175 +0000
@@ -1,4 +1,4 @@
-*motion.txt*    For Vim version 7.4.  Last change: 2013 Jul 17
+*motion.txt*    For Vim version 7.4.  Last change: 2014 Feb 11
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -343,7 +343,7 @@
 			See also 'startofline' option.  {not in Vi}
 
 :[range]go[to] [count]					*:go* *:goto* *go*
-[count]go		Go to {count} byte in the buffer.  Default [count] is
+[count]go		Go to [count] byte in the buffer.  Default [count] is
 			one, start of the file.  When giving [range], the
 			last number in it used as the byte count.  End-of-line
 			characters are counted depending on the current
diff -Naur vim74.orig/runtime/doc/netbeans.txt vim74/runtime/doc/netbeans.txt
--- vim74.orig/runtime/doc/netbeans.txt	2013-08-10 11:24:57.000000000 +0000
+++ vim74/runtime/doc/netbeans.txt	2014-10-10 14:53:40.248724175 +0000
@@ -470,7 +470,7 @@
 		New in version 2.1.
 
 removeAnno serNum
-		Remove a previously place annotation for this buffer.
+		Remove a previously placed annotation for this buffer.
 		"serNum" is the same number used in addAnno.
 
 save		Save the buffer when it was modified.  The other side of the
diff -Naur vim74.orig/runtime/doc/options.txt vim74/runtime/doc/options.txt
--- vim74.orig/runtime/doc/options.txt	2013-08-10 11:24:57.000000000 +0000
+++ vim74/runtime/doc/options.txt	2014-10-10 14:53:40.265390800 +0000
@@ -1,4 +1,4 @@
-*options.txt*	For Vim version 7.4.  Last change: 2013 Jul 09
+*options.txt*	For Vim version 7.4.  Last change: 2014 Sep 23
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -921,7 +921,7 @@
 
 						*'backupcopy'* *'bkc'*
 'backupcopy' 'bkc'	string	(Vi default for Unix: "yes", otherwise: "auto")
-			global
+			global or local to buffer |global-local|
 			{not in Vi}
 	When writing a file and a backup is made, this option tells how it's
 	done.  This is a comma separated list of words.
@@ -987,7 +987,7 @@
 
 						*'backupdir'* *'bdir'*
 'backupdir' 'bdir'	string	(default for Amiga: ".,t:",
-				 for MS-DOS and Win32: ".,c:/tmp,c:/temp"
+				 for MS-DOS and Win32: ".,$TEMP,c:/tmp,c:/temp"
 				 for Unix: ".,~/tmp,~/")
 			global
 			{not in Vi}
@@ -1200,6 +1200,38 @@
 	break if 'linebreak' is on.  Only works for ASCII and also for 8-bit
 	characters when 'encoding' is an 8-bit encoding.
 
+						*'breakindent'* *'bri'*
+'breakindent' 'bri'	boolean (default off)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	Every wrapped line will continue visually indented (same amount of
+	space as the beginning of that line), thus preserving horizontal blocks
+	of text.
+
+						*'breakindentopt'* *'briopt'*
+'breakindentopt' 'briopt' string (default empty)
+			local to window
+			{not in Vi}
+			{not available when compiled without the |+linebreak|
+			feature}
+	Settings for 'breakindent'. It can consist of the following optional
+	items and must be separated by a comma:
+		min:{n}	    Minimum text width that will be kept after
+			    applying 'breakindent', even if the resulting
+			    text should normally be narrower. This prevents
+			    text indented almost to the right window border
+			    occupying lot of vertical space when broken.
+		shift:{n}   After applying 'breakindent', the wrapped line's
+			    beginning will be shifted by the given number of
+			    characters.  It permits dynamic French paragraph
+			    indentation (negative) or emphasizing the line
+			    continuation (positive).
+		sbr	    Display the 'showbreak' value before applying the 
+			    additional indent.
+	The default value for min is 20 and shift is 0.
+
 						*'browsedir'* *'bsdir'*
 'browsedir' 'bsdir'	string	(default: "last")
 			global
@@ -1884,8 +1916,8 @@
 			global
 			{not in Vi}
 	A sequence of single character flags.  When a character is present
-	this indicates vi-compatible behavior.  This is used for things where
-	not being vi-compatible is mostly or sometimes preferred.
+	this indicates Vi-compatible behavior.  This is used for things where
+	not being Vi-compatible is mostly or sometimes preferred.
 	'cpoptions' stands for "compatible-options".
 	Commas can be added for readability.
 	To avoid problems with flags that are added in the future, use the
@@ -2197,10 +2229,18 @@
 	   zip		PkZip compatible method.  A weak kind of encryption.
 			Backwards compatible with Vim 7.2 and older.
 							*blowfish*
-	   blowfish	Blowfish method.  Strong encryption.  Requires Vim 7.3
-			or later, files can NOT be read by Vim 7.2 and older.
-			This adds a "seed" to the file, every time you write
-			the file the encrypted bytes will be different.
+	   blowfish	Blowfish method.  Medium strong encryption but it has
+			an implementation flaw.  Requires Vim 7.3 or later,
+			files can NOT be read by Vim 7.2 and older.  This adds
+			a "seed" to the file, every time you write the file
+			the encrypted bytes will be different.
+							*blowfish2*
+	   blowfish2	Blowfish method.  Medium strong encryption.  Requires
+			Vim 7.4.399 or later, files can NOT be read by Vim 7.3
+			and older.  This adds a "seed" to the file, every time
+			you write the file the encrypted bytes will be
+			different.  The whole undo file is encrypted, not just
+			the pieces of text.
 
 	When reading an encrypted file 'cryptmethod' will be set automatically
 	to the detected method of the file being read.  Thus if you write it
@@ -2477,7 +2517,7 @@
 
 						*'directory'* *'dir'*
 'directory' 'dir'	string	(default for Amiga: ".,t:",
-				 for MS-DOS and Win32: ".,c:\tmp,c:\temp"
+				 for MS-DOS and Win32: ".,$TEMP,c:\tmp,c:\temp"
 				 for Unix: ".,~/tmp,/var/tmp,/tmp")
 			global
 	List of directory names for the swap file, separated with commas.
@@ -3329,7 +3369,7 @@
 	NOTE: This option is reset when 'compatible' is set.
 
 						*'grepformat'* *'gfm'*
-'grepformat' 'gfm'	string	(default "%f:%l%m,%f  %l%m")
+'grepformat' 'gfm'	string	(default "%f:%l:%m,%f:%l%m,%f  %l%m")
 			global
 			{not in Vi}
 	Format to recognize for the ":grep" command output.
@@ -3920,12 +3960,13 @@
 	NOTE: This option is reset when 'compatible' is set.
 
 						*'history'* *'hi'*
-'history' 'hi'		number	(Vim default: 20, Vi default: 0)
+'history' 'hi'		number	(Vim default: 50, Vi default: 0)
 			global
 			{not in Vi}
 	A history of ":" commands, and a history of previous search patterns
-	are remembered.  This option decides how many entries may be stored in
+	is remembered.  This option decides how many entries may be stored in
 	each of these histories (see |cmdline-editing|).
+	The maximum value is 10000.
 	NOTE: This option is set to the Vi default value when 'compatible' is
 	set and to the Vim default value when 'compatible' is reset.
 
@@ -3968,6 +4009,7 @@
 	When Vim was compiled with HAVE_X11 defined, the original icon will be
 	restored if possible |X11|.  See |X11-icon| for changing the icon on
 	X11.
+	For MS-Windows the icon can be changed, see |windows-icon|.
 
 						*'iconstring'*
 'iconstring'		string	(default "")
@@ -4492,6 +4534,8 @@
 	be able to execute Normal mode commands.
 	This is the opposite of the 'keymap' option, where characters are
 	mapped in Insert mode.
+	This option cannot be set from a |modeline| or in the |sandbox|, for
+	security reasons.
 
 	Example (for Greek, in UTF-8):				*greek*  >
 	    :set langmap=A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,QQ,R,S,T,U,V,WW,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,qq,r,s,t,u,v,w,x,y,z
@@ -4572,12 +4616,13 @@
 			{not in Vi}
 			{not available when compiled without the |+linebreak|
 			feature}
-	If on Vim will wrap long lines at a character in 'breakat' rather
+	If on, Vim will wrap long lines at a character in 'breakat' rather
 	than at the last character that fits on the screen.  Unlike
 	'wrapmargin' and 'textwidth', this does not insert <EOL>s in the file,
-	it only affects the way the file is displayed, not its contents.  The
-	value of 'showbreak' is used to put in front of wrapped lines.
-	This option is not used when the 'wrap' option is off or 'list' is on.
+	it only affects the way the file is displayed, not its contents.
+	If 'breakindent' is set, line is visually indented. Then, the value
+	of 'showbreak' is used to put in front of wrapped lines. This option
+	is not used when the 'wrap' option is off.
 	Note that <Tab> characters after an <EOL> are mostly not displayed
 	with the right amount of white space.
 
@@ -4629,7 +4674,7 @@
 
 						*'lispwords'* *'lw'*
 'lispwords' 'lw'	string	(default is very long)
-			global
+			global or local to buffer |global-local|
 			{not in Vi}
 			{not available when compiled without the |+lispindent|
 			feature}
@@ -4757,8 +4802,9 @@
 			global or local to buffer |global-local|
 			{not in Vi}
 	Program to use for the ":make" command.  See |:make_makeprg|.
-	This option may contain '%' and '#' characters, which are expanded to
-	the current and alternate file name. |:_%| |:_#|
+	This option may contain '%' and '#' characters (see  |:_%| and |:_#|), 
+	which are expanded to the current and alternate file name.  Use |::S| 
+	to escape file names in case they contain special characters.
 	Environment variables are expanded |:set_env|.  See |option-backslash|
 	about including spaces and backslashes.
 	Note that a '|' must be escaped twice: once for ":set" and once for
@@ -5332,7 +5378,7 @@
 	Expression which is evaluated to apply a patch to a file and generate
 	the resulting new version of the file.  See |diff-patchexpr|.
 
-						*'patchmode'* *'pm'* *E206*
+					*'patchmode'* *'pm'* *E205* *E206*
 'patchmode' 'pm'	string	(default "")
 			global
 			{not in Vi}
@@ -5613,6 +5659,77 @@
 	this option at the default "on".  Only switch it off when working with
 	old Vi scripts.
 
+                                               *'renderoptions'* *'rop'*
+'renderoptions' 'rop'	string  (default: empty)
+			global
+			{not in Vi}
+			{only available when compiled with GUI and DIRECTX on
+			MS-Windows}
+	Select a text renderer and set its options.  The options depend on the
+	renderer.
+
+	Syntax: >
+		set rop=type:{renderer}(,{name}:{value})*
+<
+	Currently, only one optional renderer is available.
+
+	render	behavior    ~
+	directx	Vim will draw text using DirectX (DirectWrite).  It makes
+		drawn glyphs more beautiful than default GDI.
+		It requires 'encoding' is "utf-8", and only works on
+		MS-Windows Vista or newer version.
+
+		Options:
+		  name	    meaning		type	value       ~
+		  gamma	    gamma		float	1.0 - 2.2 (maybe)
+		  contrast  enhancedContrast	float	(unknown)
+		  level	    clearTypeLevel	float	(unknown)
+		  geom	    pixelGeometry	int	0 - 2 (see below)
+		  renmode   renderingMode	int	0 - 6 (see below)
+		  taamode   textAntialiasMode	int	0 - 3 (see below)
+
+		See this URL for detail:
+		  http://msdn.microsoft.com/en-us/library/dd368190.aspx
+
+		For geom: structure of a device pixel.
+		  0 - DWRITE_PIXEL_GEOMETRY_FLAT
+		  1 - DWRITE_PIXEL_GEOMETRY_RGB
+		  2 - DWRITE_PIXEL_GEOMETRY_BGR
+
+		See this URL for detail:
+		  http://msdn.microsoft.com/en-us/library/dd368114.aspx
+
+		For renmode: method of rendering glyphs.
+		  0 - DWRITE_RENDERING_MODE_DEFAULT
+		  1 - DWRITE_RENDERING_MODE_ALIASED
+		  2 - DWRITE_RENDERING_MODE_GDI_CLASSIC
+		  3 - DWRITE_RENDERING_MODE_GDI_NATURAL
+		  4 - DWRITE_RENDERING_MODE_NATURAL
+		  5 - DWRITE_RENDERING_MODE_NATURAL_SYMMETRIC
+		  6 - DWRITE_RENDERING_MODE_OUTLINE
+
+		See this URL for detail:
+		  http://msdn.microsoft.com/en-us/library/dd368118.aspx
+
+		For taamode: antialiasing mode used for drawing text.
+		  0 - D2D1_TEXT_ANTIALIAS_MODE_DEFAULT
+		  1 - D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE
+		  2 - D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE
+		  3 - D2D1_TEXT_ANTIALIAS_MODE_ALIASED
+
+		See this URL for detail:
+		  http://msdn.microsoft.com/en-us/library/dd368170.aspx
+
+		Example: >
+		  set encoding=utf-8
+		  set gfn=Ricty_Diminished:h12:cSHIFTJIS
+		  set rop=type:directx
+<
+		If select a raster font (Courier, Terminal or FixedSys) to
+		'guifont', it fallbacks to be drawn by GDI automatically.
+
+	Other render types are currently not supported.
+
 						*'report'*
 'report'		number	(default 2)
 			global
@@ -6251,6 +6368,9 @@
 	  A	don't give the "ATTENTION" message when an existing swap file
 		is found.
 	  I	don't give the intro message when starting Vim |:intro|.
+	  c	don't give |ins-completion-menu| messages.  For example,
+		"-- XXX completion (YYY)", "match 1 of 2", "The only match",
+		"Pattern not found", "Back at original", etc.
 
 	This gives you the opportunity to avoid that a change between buffers
 	requires you to hit <Enter>, but still gives as useful a message as
@@ -6555,6 +6675,9 @@
 	region by listing them: "en_us,en_ca" supports both US and Canadian
 	English, but not words specific for Australia, New Zealand or Great
 	Britain.
+	If the name "cjk" is included East Asian characters are excluded from
+	spell checking.  This is useful when editing text that also has Asian
+	words.
 							*E757*
 	As a special case the name of a .spl file can be given as-is.  The
 	first "_xx" in the name is removed and used as the region name
@@ -6615,6 +6738,10 @@
 			top of the suggestion list with the internal methods.
 			Lines without a slash are ignored, use this for
 			comments.
+			The word in the second column must be correct,
+			otherwise it will not be used.  Add the word to an
+			".add" file if it is currently flagged as a spelling
+			mistake.
 			The file is used for all languages.
 
 	expr:{expr}	Evaluate expression {expr}.  Use a function to avoid
@@ -6878,6 +7005,8 @@
 	immediately deleted.  When 'swapfile' is set, and 'updatecount' is
 	non-zero, a swap file is immediately created.
 	Also see |swap-file| and |'swapsync'|.
+	If you want to open a new buffer without creating a swap file for it,
+	use the |:noswapfile| modifier.
 
 	This option is used together with 'bufhidden' and 'buftype' to
 	specify special kinds of buffers.   See |special-buffers|.
@@ -7498,8 +7627,8 @@
 				"s"  = button state
 				"c"  = column plus 33
 				"r"  = row plus 33
-			This only works up to 223 columns!  See "dec" for a
-			solution.
+			This only works up to 223 columns!  See "dec",
+			"urxvt", and "sgr" for solutions.
 	   xterm2	Works like "xterm", but with the xterm reporting the
 			mouse position while the mouse is dragged.  This works
 			much faster and more precise.  Your xterm must at
@@ -7521,29 +7650,35 @@
 	   pterm	QNX pterm mouse handling.
 							*urxvt-mouse*
 	   urxvt	Mouse handling for the urxvt (rxvt-unicode) terminal.
+			The mouse works only if the terminal supports this
+			encoding style, but it does not have 223 columns limit
+			unlike "xterm" or "xterm2".
 							*sgr-mouse*
 	   sgr		Mouse handling for the terminal that emits SGR-styled
-			mouse reporting. Works with xterm version 277 or
-			later.
+			mouse reporting.  The mouse works even in columns
+			beyond 223.  This option is backward compatible with
+			"xterm2" because it can also decode "xterm2" style
+			mouse codes.
 
 	The mouse handling must be enabled at compile time |+mouse_xterm|
-	|+mouse_dec| |+mouse_netterm|.
+	|+mouse_dec| |+mouse_netterm| |+mouse_jsbterm| |+mouse_urxvt|
+	|+mouse_sgr|.
 	Only "xterm"(2) is really recognized.  NetTerm mouse codes are always
 	recognized, if enabled at compile time.  DEC terminal mouse codes
 	are recognized if enabled at compile time, and 'ttymouse' is not
-	"xterm" (because the xterm and dec mouse codes conflict).
+	"xterm", "xterm2", "urxvt" or "sgr" (because dec mouse codes conflict
+	with them).
 	This option is automatically set to "xterm", when the 'term' option is
-	set to a name that starts with "xterm", and 'ttymouse' is not "xterm"
-	or "xterm2" already.  The main use of this option is to set it to
-	"xterm", when the terminal name doesn't start with "xterm", but it can
-	handle xterm mouse codes.
-	The "sgr" value will be set if the xterm version is 277 or later.
+	set to a name that starts with "xterm", "mlterm", or "screen", and
+	'ttymouse' is not set already.
+	Additionally, if vim is compiled with the |+termresponse| feature and
+	|t_RV| is set to the escape sequence to request the xterm version
+	number, more intelligent detection process runs.
 	The "xterm2" value will be set if the xterm version is reported to be
-	95 or higher.  This only works when compiled with the |+termresponse|
-	feature and if |t_RV| is set to the escape sequence to request the
-	xterm version number.  Otherwise "xterm2" must be set explicitly.
-	If you do not want 'ttymouse' to be set to "xterm2" automatically, set
-	t_RV to an empty string: >
+	from 95 to 276.  The "sgr" value will be set if the xterm version is
+	277 or highter.
+	If you do not want 'ttymouse' to be set to "xterm2" or "sgr"
+	automatically, set t_RV to an empty string: >
 		:set t_RV=
 <
 						*'ttyscroll'* *'tsl'*
@@ -7594,7 +7729,7 @@
 						*'undolevels'* *'ul'*
 'undolevels' 'ul'	number	(default 100, 1000 for Unix, VMS,
 						Win32 and OS/2)
-			global
+			global or local to buffer |global-local|
 			{not in Vi}
 	Maximum number of changes that can be undone.  Since undo information
 	is kept in memory, higher numbers will cause more memory to be used
@@ -7605,8 +7740,9 @@
 <	But you can also get Vi compatibility by including the 'u' flag in
 	'cpoptions', and still be able to use CTRL-R to repeat undo.
 	Also see |undo-two-ways|.
-	Set to a negative number for no undo at all: >
-		set ul=-1
+	Set to -1 for no undo at all.  You might want to do this only for the
+	current buffer: >
+		setlocal ul=-1
 <	This helps when you run out of memory for a single change.
 	Also see |clear-undo|.
 
@@ -7715,6 +7851,7 @@
 			fold options
 	   options	options and mappings local to a window or buffer (not
 			global values for local options)
+	   localoptions same as "options"
 	   slash	backslashes in file names replaced with forward
 			slashes
 	   unix		with Unix end-of-line format (single <NL>), even when
diff -Naur vim74.orig/runtime/doc/os_vms.txt vim74/runtime/doc/os_vms.txt
--- vim74.orig/runtime/doc/os_vms.txt	2013-08-10 11:24:59.000000000 +0000
+++ vim74/runtime/doc/os_vms.txt	2014-10-10 14:53:40.292057399 +0000
@@ -1,4 +1,4 @@
-*os_vms.txt*    For Vim version 7.4.  Last change: 2011 Aug 14
+*os_vms.txt*    For Vim version 7.4.  Last change: 2014 Aug 29
 
 
 		  VIM REFERENCE MANUAL
@@ -24,7 +24,7 @@
 
 1. Getting started					*vms-started*
 
-Vim (Vi IMproved) is a vi-compatible text editor that runs on nearly every
+Vim (Vi IMproved) is a Vi-compatible text editor that runs on nearly every
 operating system known to humanity.  Now use Vim on OpenVMS too, in character
 or X/Motif environment.  It is fully featured and absolutely compatible with
 Vim on other operating systems.
@@ -764,6 +764,22 @@
 
 9. VMS related changes					*vms-changes*
 
+Version 7.4 
+- Undo: VMS can not handle more than one dot in the filenames use "dir/name" -> "dir/_un_name" 
+  add _un_ at the beginning to keep the extension
+- correct swap file name wildcard handling
+- handle iconv usage correctly
+- do not optimize on vax - otherwise it hangs compiling crypto files
+- fileio.c fix the comment
+- correct RealWaitForChar 
+- after 7.4-119 use different functions lib$cvtf_to_internal_time because Alpha and VAX have
+  G_FLOAT but IA64 uses IEEE float otherwise Vim crashes
+- guard against crashes that are caused by mixed filenames
+- [TESTDIR]make_vms.mms changed to see the output files
+- Improve tests, update known issues
+- minor compiler warnings fixed
+- CTAGS 5.8 +regex included
+
 Version 7.3
 - CTAGS 5.8 included
 - VMS compile warnings fixed - floating-point overflow warning corrected on VAX
diff -Naur vim74.orig/runtime/doc/os_win32.txt vim74/runtime/doc/os_win32.txt
--- vim74.orig/runtime/doc/os_win32.txt	2013-08-10 11:24:59.000000000 +0000
+++ vim74/runtime/doc/os_win32.txt	2014-10-10 14:53:40.295390724 +0000
@@ -1,4 +1,4 @@
-*os_win32.txt*  For Vim version 7.4.  Last change: 2012 May 18
+*os_win32.txt*  For Vim version 7.4.  Last change: 2014 Sep 25
 
 
 		  VIM REFERENCE MANUAL    by George Reilly
@@ -93,7 +93,7 @@
 $PATH							*win32-PATH*
 
 The directory of the Vim executable is appended to $PATH.  This is mostly to
-make "!xxd' work, as it is in the Tools menu.  And it also means that when
+make "!xxd" work, as it is in the Tools menu.  And it also means that when
 executable() returns 1 the executable can actually be executed.
 
 ==============================================================================
@@ -334,7 +334,7 @@
         :!start /min ctags -R .
 <  When it has finished you should see file named "tags" in your current
    directory.  You should notice the window title blinking on your taskbar.
-   This is more noticable for commands that take longer.
+   This is more noticeable for commands that take longer.
    Now delete the "tags" file and run this command: >
         :!start /b ctags -R .
 <  You should have the same "tags" file, but this time there will be no
@@ -367,4 +367,10 @@
 A. Edit SYSTEM.INI and add 'ScreenLines=50' to the [NonWindowsApp] section.  DOS
    prompts and external DOS commands will now run in a 50-line window.
 
+						*windows-icon*
+Q. I don't like the Vim icon, can I change it?
+A. Yes, place your favorite icon in bitmaps/vim.ico in a directory of
+   'runtimepath'.  For example ~/vimfiles/bitmaps/vim.ico.
+
+
  vim:tw=78:fo=tcq2:ts=8:ft=help:norl:
diff -Naur vim74.orig/runtime/doc/pattern.txt vim74/runtime/doc/pattern.txt
--- vim74.orig/runtime/doc/pattern.txt	2013-08-10 11:24:59.000000000 +0000
+++ vim74/runtime/doc/pattern.txt	2014-10-10 14:53:40.308724024 +0000
@@ -1,4 +1,4 @@
-*pattern.txt*   For Vim version 7.4.  Last change: 2013 Jul 06
+*pattern.txt*   For Vim version 7.4.  Last change: 2014 Sep 06
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -192,10 +192,10 @@
 An example of how to search for matches with a pattern and change the match
 with another word: >
 	/foo<CR>	find "foo"
-	c//e		change until end of match
+	c//e<CR>	change until end of match
 	bar<Esc>	type replacement
 	//<CR>		go to start of next match
-	c//e		change until end of match
+	c//e<CR>	change until end of match
 	beep<Esc>	type another replacement
 			etc.
 <
@@ -545,6 +545,7 @@
 |/\%u|	\%u	\%u	match specified multibyte character (eg \%u20ac)
 |/\%U|	\%U	\%U	match specified large multibyte character (eg
 			\%U12345678)
+|/\%C|	\%C	\%C	match any composing characters
 
 Example			matches ~
 \<\I\i*		or
@@ -705,11 +706,18 @@
 	But to limit the time needed, only the line where what follows matches
 	is searched, and one line before that (if there is one).  This should
 	be sufficient to match most things and not be too slow.
-	The part of the pattern after "\@<=" and "\@<!" are checked for a
-	match first, thus things like "\1" don't work to reference \(\) inside
-	the preceding atom.  It does work the other way around:
-	Example			matches ~
-	\1\@<=,\([a-z]\+\)	",abc" in "abc,abc"
+
+	In the old regexp engine the part of the pattern after "\@<=" and
+	"\@<!" are checked for a match first, thus things like "\1" don't work
+	to reference \(\) inside the preceding atom.  It does work the other
+	way around:
+	Bad example			matches ~
+	\%#=1\1\@<=,\([a-z]\+\)		",abc" in "abc,abc"
+
+	However, the new regexp engine works differently, it is better to not
+	rely on this behavior, do not use \@<= if it can be avoided:
+	Example				matches ~
+	\([a-z]\+\)\zs,\1		",abc" in "abc,abc"
 
 \@123<=
 	Like "\@<=" but only look back 123 bytes. This avoids trying lots
@@ -821,6 +829,7 @@
 	branch is used.  Example: >
 		/\(.\{-}\zsFab\)\{3}
 <	Finds the third occurrence of "Fab".
+	This cannot be followed by a multi. *E888*
 	{not in Vi} {not available when compiled without the |+syntax| feature}
 							*/\ze*
 \ze	Matches at any position, and sets the end of the match there: The
@@ -829,6 +838,7 @@
 	branch is used.
 	Example: "end\ze\(if\|for\)" matches the "end" in "endif" and
 	"endfor".
+	This cannot be followed by a multi. |E888|
 	{not in Vi} {not available when compiled without the |+syntax| feature}
 
 						*/\%^* *start-of-file*
@@ -1207,12 +1217,18 @@
 8. Composing characters					*patterns-composing*
 
 							*/\Z*
-When "\Z" appears anywhere in the pattern, composing characters are ignored.
-Thus only the base characters need to match, the composing characters may be
-different and the number of composing characters may differ.  Only relevant
-when 'encoding' is "utf-8".
+When "\Z" appears anywhere in the pattern, all composing characters are
+ignored.  Thus only the base characters need to match, the composing
+characters may be different and the number of composing characters may differ.
+Only relevant when 'encoding' is "utf-8".
 Exception: If the pattern starts with one or more composing characters, these
 must match.
+							*/\%C*
+Use "\%C" to skip any composing characters.  For example, the pattern "a" does
+not match in "cat" (where the a has the composing character 0x0300), but
+"a\%C" does.  Note that this does not match "ct" (where the  is character
+0xe1, it does not have a compositing character).  It does match "cat" (where
+the a is just an a).
 
 When a composing character appears at the start of the pattern of after an
 item that doesn't include the composing character, a match is found at any
@@ -1325,7 +1341,7 @@
 		patterns defined by both |matchadd()| and |:match|.
 
 		Highlighting matches using |:match| are limited to three
-		matches (aside from |:match|, |:2match| and |:3match|are
+		matches (aside from |:match|, |:2match| and |:3match| are
 		available). |matchadd()| does not have this limitation and in
 		addition makes it possible to prioritize matches.
 
diff -Naur vim74.orig/runtime/doc/pi_getscript.txt vim74/runtime/doc/pi_getscript.txt
--- vim74.orig/runtime/doc/pi_getscript.txt	2013-08-10 11:24:59.000000000 +0000
+++ vim74/runtime/doc/pi_getscript.txt	2014-10-10 14:53:40.312057349 +0000
@@ -1,4 +1,4 @@
-*pi_getscript.txt*  For Vim version 7.4.  Last change: 2012 Apr 07
+*pi_getscript.txt*  For Vim version 7.0.  Last change: 2013 Nov 29
 >
 		GETSCRIPT REFERENCE MANUAL  by Charles E. Campbell
 <
@@ -385,6 +385,10 @@
 ==============================================================================
 9. GetLatestVimScripts History		*getscript-history* *glvs-hist* {{{1
 
+v36 Apr 22, 2013 : * (glts) suggested use of plugin/**/*.vim instead of
+		     plugin/*.vim in globpath() call.
+		   * (Andy Wokula) got warning message when setting
+		     g:loaded_getscriptPlugin
 v35 Apr 07, 2012 : * (MengHuan Yu) pointed out that the script url has
 		     changed (somewhat).  However, it doesn't work, and
 		     the original one does (under Linux). I'll make it
diff -Naur vim74.orig/runtime/doc/pi_netrw.txt vim74/runtime/doc/pi_netrw.txt
--- vim74.orig/runtime/doc/pi_netrw.txt	2013-08-10 11:24:59.000000000 +0000
+++ vim74/runtime/doc/pi_netrw.txt	2014-10-10 14:53:40.325390649 +0000
@@ -1,4 +1,4 @@
-*pi_netrw.txt*  For Vim version 7.4.  Last change: 2013 May 18
+*pi_netrw.txt*  For Vim version 7.4.  Last change: 2014 May 13
 
 	    ------------------------------------------------
 	    NETRW REFERENCE MANUAL    by Charles E. Campbell
@@ -6,7 +6,7 @@
 Author:  Charles E. Campbell  <NdrOchip@ScampbellPfamily.AbizM>
 	  (remove NOSPAM from Campbell's email first)
 
-Copyright: Copyright (C) 1999-2013 Charles E Campbell    *netrw-copyright*
+Copyright: Copyright (C) 1999-2014 Charles E Campbell    *netrw-copyright*
 	The VIM LICENSE applies to the files in this package, including
 	netrw.vim, pi_netrw.txt, netrwFileHandlers.vim, netrwSettings.vim, and
 	syntax/netrw.vim.  Like anything else that's free, netrw.vim and its
@@ -49,6 +49,7 @@
       Quick Reference: Commands...........................|netrw-browse-cmds|
       Bookmarking A Directory.............................|netrw-mb|
       Browsing............................................|netrw-cr|
+        Squeezing the Current Tree-Listing Directory......|:netrw-s-cr|
       Browsing With A Horizontally Split Window...........|netrw-o|
       Browsing With A New Tab.............................|netrw-t|
       Browsing With A Vertically Split Window.............|netrw-v|
@@ -172,7 +173,7 @@
 next section, |netrw-externapp|, on how to use these external applications with
 netrw and vim.
 
-PREVENTING LOADING						*netrw-noload*
+PREVENTING LOADING					*netrw-noload*
 
 If you want to use plugins, but for some reason don't wish to use netrw, then
 you need to avoid loading both the plugin and the autoload portions of netrw.
@@ -183,7 +184,7 @@
 <
 
 ==============================================================================
-3. Netrw Reference						*netrw-ref* {{{1
+3. Netrw Reference					*netrw-ref* {{{1
 
    Netrw supports several protocols in addition to scp and ftp as mentioned
    in |netrw-start|.  These include dav, fetch, http,... well, just look
@@ -192,21 +193,22 @@
 
 EXTERNAL APPLICATIONS AND PROTOCOLS			*netrw-externapp* {{{2
 
-	Protocol  Variable	    Default Value
-	--------  ----------------  -------------
-	   dav:   *g:netrw_dav_cmd*    = "cadaver"    if cadaver is executable
-	   dav:   g:netrw_dav_cmd    = "curl -o"    elseif curl is available
-	 fetch:   *g:netrw_fetch_cmd*  = "fetch -o"   if fetch is available
-	   ftp:   *g:netrw_ftp_cmd*    = "ftp"
-	  http:   *g:netrw_http_cmd*   = "elinks"     if   elinks  is available
-	  http:   g:netrw_http_cmd   = "links"      elseif links is available
-	  http:   g:netrw_http_cmd   = "curl"       elseif curl  is available
-	  http:   g:netrw_http_cmd   = "wget"       elseif wget  is available
-          http:   g:netrw_http_cmd   = "fetch"      elseif fetch is available
-	   rcp:   *g:netrw_rcp_cmd*    = "rcp"
-	 rsync:   *g:netrw_rsync_cmd*  = "rsync -a"
-	   scp:   *g:netrw_scp_cmd*    = "scp -q"
-	  sftp:   *g:netrw_sftp_cmd*   = "sftp"
+	Protocol  Variable	       Default Value
+	--------  ----------------     -------------
+	   dav:   *g:netrw_dav_cmd*      = "cadaver"    if cadaver is executable
+	   dav:   g:netrw_dav_cmd      = "curl -o"    elseif curl is available
+	 fetch:   *g:netrw_fetch_cmd*    = "fetch -o"   if fetch is available
+	   ftp:   *g:netrw_ftp_cmd*      = "ftp"
+	  http:   *g:netrw_http_cmd*     = "elinks"     if   elinks  is available
+	  http:   g:netrw_http_cmd     = "links"      elseif links is available
+	  http:   g:netrw_http_cmd     = "curl"       elseif curl  is available
+	  http:   g:netrw_http_cmd     = "wget"       elseif wget  is available
+          http:   g:netrw_http_cmd     = "fetch"      elseif fetch is available
+	  http:   *g:netrw_http_put_cmd* = "curl -T"
+	   rcp:   *g:netrw_rcp_cmd*      = "rcp"
+	 rsync:   *g:netrw_rsync_cmd*    = "rsync -a"
+	   scp:   *g:netrw_scp_cmd*      = "scp -q"
+	  sftp:   *g:netrw_sftp_cmd*     = "sftp"
 
 	*g:netrw_http_xcmd* : the option string for http://... protocols are
 	specified via this variable and may be independently overridden.  By
@@ -223,6 +225,9 @@
 		let g:netrw_http_xcmd= "-dump >"
 <	in your .vimrc.
 
+	g:netrw_http_put_cmd: this option specifies both the executable and
+	any needed options.  This command does a PUT operation to the url.
+
 
 READING						*netrw-read* *netrw-nread* {{{2
 
@@ -286,7 +291,7 @@
 	:Nsource "scp://[user@]machine[[:#]port]/path"	uses scp
 	:Nsource "sftp://[user@]machine/path"		uses sftp
 
-DIRECTORY LISTING			*netrw-trailingslash* *netrw-dirlist* {{{2
+DIRECTORY LISTING		*netrw-trailingslash* *netrw-dirlist* {{{2
 
 	One may browse a directory to get a listing by simply attempting to
 	edit the directory: >
@@ -343,9 +348,9 @@
  *g:netrw_bufsettings*	the settings that netrw buffers have
  			(default) noma nomod nonu nowrap ro nobl
 
- *g:netrw_chgwin*	specifies a window number where file edits will take
-			place.  (also see |netrw-C|)
-			(default) not defined
+ *g:netrw_chgwin*	specifies a window number where subsequent file edits
+			will take place.  (also see |netrw-C|)
+			(default) -1
 
  *g:Netrw_funcref*	specifies a function (or functions) to be called when
 			netrw edits a file.  The file is first edited, and
@@ -366,9 +371,9 @@
 			   value of this variable to see if the alternate ftp
 			   method works for your setup.
 
- *g:netrw_ftp_options*     Chosen by default, these options are supposed to turn
-			 interactive prompting off and to restrain ftp from
-			 attempting auto-login upon initial connection.
+ *g:netrw_ftp_options*     Chosen by default, these options are supposed to
+			 turn interactive prompting off and to restrain ftp
+			 from attempting auto-login upon initial connection.
 			 However, it appears that not all ftp implementations
 			 support this (ex. ncftp).
 		        ="-i -n"
@@ -399,8 +404,8 @@
  *g:netrw_preview*	=0 (default) preview window shown in a horizontally
 			   split window
 			=1 preview window shown in a vertically split window.
-			   Also affects the "previous window" (see |netrw-P|) in
-			   the same way.
+			   Also affects the "previous window" (see |netrw-P|)
+			   in the same way.
 
  *g:netrw_scpport*	= "-P" : option to use to set port for scp
  *g:netrw_sshport*	= "-p" : option to use to set port for ssh
@@ -538,15 +543,17 @@
 starts.  You may use this feature to enter a user and password for one site: >
 	userid
 	password
-<					*netrw-windows-netrc*  *netrw-windows-s*
-If |g:netrw_ftp_cmd| contains -s:[path/]MACHINE, then (on Windows machines only)
-netrw will substitute the current machine name requested for ftp connections
-for MACHINE.  Hence one can have multiple machine.ftp files containing login
-and password for ftp.  Example: >
+<				*netrw-windows-netrc*  *netrw-windows-s*
+If |g:netrw_ftp_cmd| contains -s:[path/]MACHINE, then (on Windows machines
+only) netrw will substitute the current machine name requested for ftp
+connections for MACHINE.  Hence one can have multiple machine.ftp files
+containing login and password for ftp.  Example: >
 
     let g:netrw_ftp_cmd= 'c:\Windows\System32\ftp -s:C:\Users\Myself\MACHINE'
     vim ftp://myhost.somewhere.net/
+
 will use a file >
+
 	C:\Users\Myself\myhost.ftp
 <
 Often, ftp will need to query the user for the userid and password.
@@ -676,7 +683,7 @@
 <
 
 ==============================================================================
-6. Transparent Remote File Editing			*netrw-transparent* {{{1
+6. Transparent Remote File Editing		*netrw-transparent* {{{1
 
 Transparent file transfers occur whenever a regular file read or write
 (invoked via an |:autocmd| for |BufReadCmd|, |BufWriteCmd|, or |SourceCmd|
@@ -750,7 +757,7 @@
 
 
 ==============================================================================
-8. Variables and Options			*netrw-var* *netrw-settings* {{{1
+8. Variables and Options		*netrw-var* *netrw-settings* {{{1
 
 (also see: |netrw-options| |netrw-variables| |netrw-protocol|
            |netrw-browser-settings| |netrw-browser-options| )
@@ -790,7 +797,7 @@
                                 =1 use default method to do ftp >
 	-----------------------------------------------------------------------
 <
-							*netrw-internal-variables*
+						*netrw-internal-variables*
 The script will also make use of the following variables internally, albeit
 temporarily.
 >
@@ -816,8 +823,7 @@
 			   ------------------------
     Option            Type        Setting         Meaning
     ---------         --------    --------------  ---------------------------
-<
-    netrw_ftp         variable    =doesn't exist  userid set by "user userid"
+<    netrw_ftp         variable    =doesn't exist  userid set by "user userid"
                                   =0              userid set by "user userid"
                                   =1              userid set by "userid"
     NetReadFixup      function    =doesn't exist  no change
@@ -825,17 +831,18 @@
                                                   read via ftp automatically
                                                   transformed however they wish
                                                   by NetReadFixup()
-    g:netrw_dav_cmd    variable   ="cadaver"      if cadaver  is executable
-    g:netrw_dav_cmd    variable   ="curl -o"      elseif curl is executable
-    g:netrw_fetch_cmd  variable   ="fetch -o"     if fetch is available
-    g:netrw_ftp_cmd    variable   ="ftp"
-    g:netrw_http_cmd   variable   ="fetch -o"     if      fetch is available
-    g:netrw_http_cmd   variable   ="wget -O"      else if wget  is available
-    g:netrw_list_cmd   variable   ="ssh USEPORT HOSTNAME ls -Fa"
-    g:netrw_rcp_cmd    variable   ="rcp"
-    g:netrw_rsync_cmd  variable   ="rsync -a"
-    g:netrw_scp_cmd    variable   ="scp -q"
-    g:netrw_sftp_cmd   variable   ="sftp" >
+    g:netrw_dav_cmd      var   ="cadaver"      if cadaver  is executable
+    g:netrw_dav_cmd      var   ="curl -o"      elseif curl is executable
+    g:netrw_fetch_cmd    var   ="fetch -o"     if fetch is available
+    g:netrw_ftp_cmd      var   ="ftp"
+    g:netrw_http_cmd     var   ="fetch -o"     if      fetch is available
+    g:netrw_http_cmd     var   ="wget -O"      else if wget  is available
+    g:netrw_http_put_cmd var   ="curl -T"
+    g:netrw_list_cmd     var   ="ssh USEPORT HOSTNAME ls -Fa"
+    g:netrw_rcp_cmd      var   ="rcp"
+    g:netrw_rsync_cmd    var   ="rsync -a"
+    g:netrw_scp_cmd      var   ="scp -q"
+    g:netrw_sftp_cmd     var   ="sftp" >
     -------------------------------------------------------------------------
 <
 								*netrw-ftp*
@@ -1037,8 +1044,8 @@
 	 <del>	Netrw will attempt to remove the file/directory      |netrw-del|
 	   -	Makes Netrw go up one directory                      |netrw--|
 	   a	Toggles between normal display,                      |netrw-a|
-		hiding (suppress display of files matching g:netrw_list_hide)
-		showing (display only files which match g:netrw_list_hide)
+	    	hiding (suppress display of files matching g:netrw_list_hide)
+	    	showing (display only files which match g:netrw_list_hide)
 	   c	Make browsing directory the current directory        |netrw-c|
 	   C	Setting the editing window                           |netrw-C|
 	   d	Make a directory                                     |netrw-d|
@@ -1063,7 +1070,7 @@
 	   mx	Apply arbitrary shell command to marked files        |netrw-mx|
 	   mz	Compress/decompress marked files                     |netrw-mz|
 	   o	Enter the file/directory under the cursor in a new   |netrw-o|
-		browser window.  A horizontal split is used.
+	    	browser window.  A horizontal split is used.
 	   O	Obtain a file specified by cursor                    |netrw-O|
 	   p	Preview the file                                     |netrw-p|
 	   P	Browse in the previously used window                 |netrw-P|
@@ -1077,7 +1084,7 @@
 	   u	Change to recently-visited directory                 |netrw-u|
 	   U	Change to subsequently-visited directory             |netrw-U|
 	   v	Enter the file/directory under the cursor in a new   |netrw-v|
-		browser window.  A vertical split is used.
+	    	browser window.  A vertical split is used.
 	   x	View file with an associated program                 |netrw-x|
 	   X	Execute filename under cursor via |system()|           |netrw-X|
 
@@ -1091,22 +1098,26 @@
 	<rightmouse>	(gvim only) delete file/directory using word under
 			mouse
 	<2-leftmouse>	(gvim only) when:
-	                 * in a netrw-selected file, AND
-		         * |g:netrw_retmap| == 1     AND
-		         * the user doesn't already have a <2-leftmouse>
+			 * in a netrw-selected file, AND
+			 * |g:netrw_retmap| == 1     AND
+			 * the user doesn't already have a <2-leftmouse>
 			   mapping defined before netrw is autoloaded,
 			then a double clicked leftmouse button will return
 			to the netrw browser window.  See |g:netrw_retmap|.
-	<s-leftmouse>	(gvim only) like mf, will mark files
+	<s-leftmouse>	(gvim only) like mf, will mark files.  Dragging
+			the shifted leftmouse will mark multiple files.
+			(see |netrw-mf|)
 
 	(to disable mouse buttons while browsing: |g:netrw_mousemaps|)
 
 				*netrw-quickcom* *netrw-quickcoms*
 QUICK REFERENCE: COMMANDS	*netrw-explore-cmds* *netrw-browse-cmds* {{{2
-     :NetrwClean[!] ...........................................|netrw-clean|
-     :NetrwSettings ...........................................|netrw-settings|
+     :NetrwClean[!]............................................|netrw-clean|
+     :NetrwSettings............................................|netrw-settings|
+     :Ntree....................................................|netrw-ntree|
      :Explore[!]  [dir] Explore directory of current file......|netrw-explore|
      :Hexplore[!] [dir] Horizontal Split & Explore.............|netrw-explore|
+     :Lexplore    [dir] Left Explorer Toggle...................|netrw-explore|
      :Nexplore[!] [dir] Vertical Split & Explore...............|netrw-explore|
      :Pexplore[!] [dir] Vertical Split & Explore...............|netrw-explore|
      :Rexplore          Return to Explorer.....................|netrw-explore|
@@ -1171,6 +1182,12 @@
 always refresh directory listing buffers by pressing ctrl-L (see
 |netrw-ctrl-l|).
 
+								*:netrw-s-cr*
+    Squeezing the Current Tree-Listing Directory~
+    When the tree listing style is enabled (see |netrw-i|) and one is using
+    gvim, then the <s-cr> mapping may be used to squeeze (close) the
+    directory currently containing the cursor.
+
 
 Related topics: |netrw-o| |netrw-p| |netrw-P| |netrw-t| |netrw-v|
 Associated setting variables: |g:netrw_browse_split|      |g:netrw_fastbrowse|
@@ -1219,9 +1236,7 @@
 There is only one tree listing buffer; using "v" on a displayed subdirectory
 will split the screen, but the same buffer will be shown twice.
 
-Associated setting variable: |g:netrw_altv| |g:netrw_winsize|
-
-Related Actions |netrw-cr| |netrw-o| |netrw-t| |netrw-v|
+Related Actions: |netrw-cr| |netrw-o| |netrw-t| |netrw-v|
 Associated setting variables:
    |g:netrw_altv|    control right/left splitting
    |g:netrw_winsize| control initial sizing
@@ -1243,11 +1258,12 @@
 filenames; when using that format, netrw won't be able to recognize or use
 filenames which have two or more contiguous spaces embedded in the name or any
 trailing spaces.  The thin listing format will, however, work with such files.
-This listing format is the most compact.
+The wide listing format is the most compact.
 
 The tree listing format has a top directory followed by files and directories
-preceded by a "|".  One may open and close directories by pressing the <cr>
-key while atop the directory name.
+preceded by one or more "|"s, which indicate the directory depth.  One may
+open and close directories by pressing the <cr> key while atop the directory
+name.
 
 One may make a preferred listing style your default; see |g:netrw_liststyle|.
 As an example, by putting the following line in your .vimrc, >
@@ -1321,6 +1337,17 @@
 slots.
 
 
+CHANGING TREE TOP				*netrw-ntree* *:Ntree*
+
+One may specify a new tree top for tree listings using >
+
+	:Ntree [dirname]
+
+Without a "dirname", the current line is used (and any leading depth
+information is elided).
+With a "dirname", the specified directory name is used.
+
+
 NETRW CLEAN					*netrw-clean* *:NetrwClean*
 
 With :NetrwClean one may easily remove netrw from one's home directory;
@@ -1436,8 +1463,16 @@
     Marked files (and empty directories) will be deleted; again, you'll be
     asked to confirm the deletion before it actually takes place.
 
+A further approach is to delete files which match a pattern.
+
+    * use  :MF pattern  (see |netrw-:MF|); then press "D".
+
+    * use mr (see |netrw-mr|) which will prompt you for pattern.
+      This will cause the matching files to be marked.  Then,
+      press "D".
+
 The |g:netrw_rm_cmd|, |g:netrw_rmf_cmd|, and |g:netrw_rmdir_cmd| variables are
-used to control the attempts to remove files and directories.  The
+used to control the attempts to remove remote files and directories.  The
 g:netrw_rm_cmd is used with files, and its default value is:
 
 	g:netrw_rm_cmd: ssh HOSTNAME rm
@@ -1445,12 +1480,12 @@
 The g:netrw_rmdir_cmd variable is used to support the removal of directories.
 Its default value is:
 
-	g:netrw_rmdir_cmd: ssh HOSTNAME rmdir
+	|g:netrw_rmdir_cmd|: ssh HOSTNAME rmdir
 
 If removing a directory fails with g:netrw_rmdir_cmd, netrw then will attempt
 to remove it again using the g:netrw_rmf_cmd variable.  Its default value is:
 
-	g:netrw_rmf_cmd: ssh HOSTNAME rm -f
+	|g:netrw_rmf_cmd|: ssh HOSTNAME rm -f
 
 Related topics: |netrw-d|
 Associated setting variable: |g:netrw_localrmdir| |g:netrw_rm_cmd|
@@ -1458,35 +1493,52 @@
 
 
 *netrw-explore*  *netrw-hexplore* *netrw-nexplore* *netrw-pexplore*
-*netrw-rexplore* *netrw-sexplore* *netrw-texplore* *netrw-vexplore*
+*netrw-rexplore* *netrw-sexplore* *netrw-texplore* *netrw-vexplore* *netrw-lexplore*
 DIRECTORY EXPLORATION COMMANDS  {{{2
 
      :[N]Explore[!]  [dir]... Explore directory of current file      *:Explore*
      :[N]Hexplore[!] [dir]... Horizontal Split & Explore             *:Hexplore*
-     :Rexplore            ... Return to Explorer                     *:Rexplore*
+     :Rexplore            ... Return to/from Explorer                *:Rexplore*
      :[N]Sexplore[!] [dir]... Split&Explore current file's directory *:Sexplore*
      :Texplore       [dir]... Tab              & Explore             *:Texplore*
      :[N]Vexplore[!] [dir]... Vertical   Split & Explore             *:Vexplore*
+     :Lexplore       [dir]... Left Explorer Toggle                   *:Lexplore*
 
      Used with :Explore **/pattern : (also see |netrw-starstar|)
      :Nexplore............. go to next matching file                *:Nexplore*
      :Pexplore............. go to previous matching file            *:Pexplore*
 
+						*netrw-:Explore*
 :Explore  will open the local-directory browser on the current file's
           directory (or on directory [dir] if specified).  The window will be
 	  split only if the file has been modified, otherwise the browsing
 	  window will take over that window.  Normally the splitting is taken
 	  horizontally.
+	  Also see: |netrw-:Rexplore|
 :Explore! is like :Explore, but will use vertical splitting.
+						*netrw-:Lexplore*
+:Lexplore [dir] toggles an Explorer window on the left hand side
+          of the current tab  It will open a netrw window on the current
+	  directory if [dir] is omitted; a :Lexplore [dir] will show
+	  the specified directory in the left-hand side browser display
+	  no matter from which window the command is issued.  By default,
+	  :Lexplore will change an uninitialized |g:netrw_chgwin| to 2;
+	  edits will thus be preferentially made in window#2.
+	  Also see: |netrw-C|| |g:netrw_chgwin| |g:netrw_winsize|
+	  	    |netrw-p| |netrw-P|| |g:netrw_browse_split|
+						*netrw-:Sexplore*
 :Sexplore will always split the window before invoking the local-directory
           browser.  As with Explore, the splitting is normally done
 	  horizontally.
 :Sexplore! [dir] is like :Sexplore, but the splitting will be done vertically.
+						*netrw-:Hexplore*
 :Hexplore  [dir] does an :Explore with |:belowright| horizontal splitting.
 :Hexplore! [dir] does an :Explore with |:aboveleft|  horizontal splitting.
+						*netrw-:Vexplore*
 :Vexplore  [dir] does an :Explore with |:leftabove|  vertical splitting.
 :Vexplore! [dir] does an :Explore with |:rightbelow| vertical splitting.
-:Texplore  [dir] does a tabnew before generating the browser window
+						*netrw-:Texplore*
+:Texplore  [dir] does a |:tabnew| before generating the browser window
 
 By default, these commands use the current file's directory.  However, one may
 explicitly provide a directory (path) to use.
@@ -1498,12 +1550,25 @@
 user, is used to control the quantity of rows and/or columns new explorer
 windows should have.
 
-:Rexplore  This command is a little different from the others.  When one
-           edits a file, for example by pressing <cr> when atop a file in
-	   a netrw browser window, :Rexplore will return the display to
-	   that of the last netrw browser window.  It is a command version
-	   of the <2-leftmouse> map (which is only available under gvim and
-	   cooperative terms).
+						*netrw-:Rexplore*
+:Rexplore  This command is a little different from the others as it doesn't
+	   necessarily open an Explorer window.
+
+	   Return to Explorer~
+	   When one edits a file, for example by pressing <cr> when the
+	   cursor is atop a file in a netrw browser window, :Rexplore will
+	   return the display to that of the last netrw browser display
+	   in that window.
+
+	   Return from Explorer~
+	   Conversely, when one is editing a directory, issuing a :Rexplore
+	   will return to editing the file that was last edited in that
+	   window.
+
+	   The <2-leftmouse> map (which is only available under gvim and
+	   cooperative terms) does the same as :Rexplore.
+
+Also see: |g:netrw_alto| |g:netrw_altv| |g:netrw_winsize|
 
 
 *netrw-star* *netrw-starpat* *netrw-starstar* *netrw-starstarpat*
@@ -1547,11 +1612,12 @@
 The status line will show, on the right hand side of the status line, a
 message like "Match 3 of 20".
 
-Associated setting variables: |g:netrw_keepdir|      |g:netrw_browse_split|
-                              |g:netrw_fastbrowse|   |g:netrw_ftp_browse_reject|
-			      |g:netrw_ftp_list_cmd| |g:netrw_ftp_sizelist_cmd|
-			      |g:netrw_ftp_timelist_cmd| |g:netrw_list_cmd|
-			      |g:netrw_liststyle|
+Associated setting variables:
+	|g:netrw_keepdir|          |g:netrw_browse_split|
+	|g:netrw_fastbrowse|       |g:netrw_ftp_browse_reject|
+	|g:netrw_ftp_list_cmd|     |g:netrw_ftp_sizelist_cmd|
+	|g:netrw_ftp_timelist_cmd| |g:netrw_list_cmd|
+	|g:netrw_liststyle|
 
 
 DISPLAYING INFORMATION ABOUT FILE				*netrw-qf* {{{2
@@ -1641,10 +1707,10 @@
 
 Netrw will use the command in |g:netrw_list_cmd| to perform the directory
 listing operation after changing HOSTNAME to the host specified by the
-user-provided url.  By default netrw provides the command as:
+user-prpvided url.  By default netrw provides the command as: >
 
 	ssh HOSTNAME ls -FLa
-
+<
 where the HOSTNAME becomes the [user@]hostname as requested by the attempt to
 read.  Naturally, the user may override this command with whatever is
 preferred.  The NetList function which implements remote browsing
@@ -1696,9 +1762,36 @@
 to toggle between hiding files which begin with a period (dot) and not hiding
 them.
 
-Associated setting variable: |g:netrw_list_hide|  |g:netrw_hide|
+Associated setting variables: |g:netrw_list_hide|  |g:netrw_hide|
 Associated topics: |netrw-a| |netrw-ctrl-h| |netrw-mh|
 
+					*netrw-gitignore*
+Netrw provides a helper function 'netrw_gitignore#Hide()' that, when used with
+|g:netrw_list_hide| automatically hides all git-ignored files.
+
+'netrw_gitignore#Hide' searches for patterns in the following files:
+	'./.gitignore'
+	'./.git/info/exclude'
+	global gitignore file: `git config --global core.excludesfile`
+	system gitignore file: `git config --system core.excludesfile`
+
+Files that do not exist, are ignored.
+Git-ignore patterns are taken from existing files, and converted to patterns for
+hiding files. For example, if you had '*.log' in your '.gitignore' file, it
+would be converted to '.*\.log'.
+
+To use this function, simply assign it's output to |g:netrw_list_hide| option.
+
+	Example: let g:netrw_list_hide= netrw_gitignore#Hide()
+		Git-ignored files are hidden in Netrw.
+
+	Example: let g:netrw_list_hide= netrw_gitignore#Hide('my_gitignore_file')
+		Function can take additional files with git-ignore patterns.
+
+	Example: g:netrw_list_hide= netrw_gitignore#Hide() . '.*\.swp$'
+		Combining 'netrw_gitignore#Hide' with custom patterns.
+
+
 IMPROVING BROWSING			*netrw-listhack* *netrw-ssh-hack* {{{2
 
 Especially with the remote directory browser, constantly entering the password
@@ -1778,6 +1871,15 @@
     http://sial.org/howto/openssh/publickey-auth/
 
 
+    Ssh hints:
+
+	Thomer Gil has provided a hint on how to speed up netrw+ssh:
+	    http://thomer.com/howtos/netrw_ssh.html
+
+	Alex Young has several hints on speeding ssh up:
+	    http://usevim.com/2012/03/16/editing-remote-files/
+
+
 LISTING BOOKMARKS AND HISTORY		*netrw-qb* *netrw-listbookmark* {{{2
 
 Pressing "qb" (query bookmarks) will list both the bookmarked directories and
@@ -1800,8 +1902,8 @@
 a file or a directory) will be detected, reported on, and ignored.
 
 Related topics: |netrw-D|
-Associated setting variables:	|g:netrw_localmkdir|  |g:netrw_mkdir_cmd|
-				|g:netrw_remote_mkdir|
+Associated setting variables:	|g:netrw_localmkdir|   |g:netrw_mkdir_cmd|
+				|g:netrw_remote_mkdir| |netrw-%|
 
 
 MAKING THE BROWSING DIRECTORY THE CURRENT DIRECTORY	*netrw-c* {{{2
@@ -1821,12 +1923,29 @@
 
 Associated setting variable: |g:netrw_keepdir|
 
-MARKING FILES							*netrw-mf* {{{2
+MARKING FILES					*netrw-:MF*	*netrw-mf* {{{2
 	(also see |netrw-mr|)
 
-One may mark files with the cursor atop a filename and then pressing "mf".
-With gvim, one may also mark files with <s-leftmouse>.  The following netrw
-maps make use of marked files:
+Netrw has several ways of marking files:
+
+	* One may mark files with the cursor atop a filename and
+	  then pressing "mf".
+
+	* With gvim, in addition one may mark files with
+	  <s-leftmouse>. (see |netrw-mouse|)
+
+	* One may use the :MF command, which takes a list of
+	  files (for local directories, the list may include
+	  wildcards -- see |glob()|) >
+
+		:MF *.c
+<
+	* Note that :MF uses |<f-args>| to break the line
+	  at spaces.
+
+	* Mark files based upon the quickfix list (|netrw-qF|)
+
+The following netrw maps make use of marked files:
 
     |netrw-a|	Hide marked files/directories
     |netrw-D|	Delete marked files/directories
@@ -1835,13 +1954,12 @@
     |netrw-me|	Edit marked files
     |netrw-mF|	Unmark marked files
     |netrw-mg|	Apply vimgrep to marked files
-    |netrw-mm|	Move marked files
+    |netrw-mm|	Move marked files to target
     |netrw-mp|	Print marked files
     |netrw-mt|	Set target for |netrw-mm| and |netrw-mc|
     |netrw-mT|	Generate tags using marked files
     |netrw-mx|	Apply shell command to marked files
     |netrw-mz|	Compress/Decompress marked files
-    |netrw-qF|	Mark files using quickfix list
     |netrw-O|	Obtain marked files
     |netrw-R|	Rename marked files
 
@@ -1860,6 +1978,10 @@
 <
 into $HOME/.vim/after/syntax/netrw.vim .
 
+If the mouse is enabled and works with your vim, you may use <s-leftmouse> to
+mark one or more files.  You may mark multiple files by dragging the shifted
+leftmouse.  (see |netrw-mouse|)
+
 *markfilelist* *global_markfilelist* *local_markfilelist*
 All marked files are entered onto the global marked file list; there is only
 one such list.  In addition, every netrw buffer also has its own local marked
@@ -1868,6 +1990,12 @@
 commands which operate on marked files use one or the other of the marked file
 lists.
 
+Known Problem: if one is using tree mode (|g:netrw_liststyle|) and several
+directories have files with the same name,  then marking such a file will
+result in all such files being highlighted as if they were all marked.  The
+|markfilelist|, however, will only have the selected file in it.  This problem
+is unlikely to be fixed.
+
 
 UNMARKING FILES							*netrw-mF* {{{2
 	(also see |netrw-mf|)
@@ -2025,6 +2153,10 @@
   * However, if the cursor is atop a directory name, then that directory is
     used for the copy/move-to target
 
+  * One may use the :MT [directory] command to set the target	*netrw-:MT*
+    This command uses |<q-args>|, so spaces in the directory name are
+    permitted without escaping.
+
 There is only one copy/move-to target per vim session; ie. the target is a
 script variable (see |s:var|) and is shared between all netrw windows (in an
 instance of vim).
@@ -2055,9 +2187,9 @@
 in my <.vimrc>.
 
 When a remote set of files are tagged, the resulting tags file is "obtained";
-ie. a copy is transferred to the local system's directory.  The local tags
+ie. a copy is transferred to the local system's directory.  The now local tags
 file is then modified so that one may use it through the network.  The
-modification is concerns the names of the files in the tags; each filename is
+modification made concerns the names of the files in the tags; each filename is
 preceded by the netrw-compatible url used to obtain it.  When one subsequently
 uses one of the go to tag actions (|tags|), the url will be used by netrw to
 edit the desired file and go to the tag.
@@ -2066,34 +2198,38 @@
 
 MARKED FILES: TARGET DIRECTORY USING BOOKMARKS  		*netrw-Tb* {{{2
 
-Sets the marked file copy/move-to target (see |netrw-mc| and |netrw-mm|).
+Sets the marked file copy/move-to target.
 
 The |netrw-qb| map will give you a list of bookmarks (and history).
 One may choose one of the bookmarks to become your marked file
 target by using [count]Tb (default count: 1).
 
 Related topics:
+      Copying files to target............................|netrw-mc|
       Listing Bookmarks and History......................|netrw-qb|
       Marked Files: Setting The Target Directory.........|netrw-mt|
       Marked Files: Target Directory Using History.......|netrw-Th|
       Marking Files......................................|netrw-mf|
       Marking Files by Regular Expression................|netrw-mr|
+      Moving files to target.............................|netrw-mm|
 
 
 MARKED FILES: TARGET DIRECTORY USING HISTORY	  		*netrw-Th* {{{2
 
-Sets the marked file copy/move-to target (see |netrw-mc| and |netrw-mm|).
+Sets the marked file copy/move-to target.
 
 The |netrw-qb| map will give you a list of history (and bookmarks).
 One may choose one of the history entries to become your marked file
 target by using [count]Th (default count: 0; ie. the current directory).
 
 Related topics:
+      Copying files to target............................|netrw-mc|
       Listing Bookmarks and History......................|netrw-qb|
       Marked Files: Setting The Target Directory.........|netrw-mt|
       Marked Files: Target Directory Using Bookmarks.....|netrw-Tb|
       Marking Files......................................|netrw-mf|
       Marking Files by Regular Expression................|netrw-mr|
+      Moving files to target.............................|netrw-mm|
 
 
 MARKED FILES: UNMARKING						*netrw-mu* {{{2
@@ -2114,7 +2250,15 @@
    ---				-----------
    Var				Explanation
    ---				-----------
-< *g:netrw_alto*		change from above splitting to below splitting
+<  *g:netrw_altfile*		some like |CTRL-^| to return to the last
+				edited file.  Choose that by setting this
+				parameter to 1.
+				Others like |CTRL-^| to return to the
+				netrw browsing buffer.  Choose that by setting
+				this parameter to 0.
+				 default: =0
+
+  *g:netrw_alto*		change from above splitting to below splitting
 				by setting this variable (see |netrw-o|)
 				 default: =&sb           (see |'sb'|)
 
@@ -2142,6 +2286,10 @@
 				    to get vertical splitting instead of
 				    horizontal splitting.
 
+				Related topics:
+					|netrw-cr|	|netrw-C|
+					|g:netrw_alto|	|g:netrw_altv|
+
   *g:netrw_browsex_viewer*	specify user's preference for a viewer: >
 					"kfmclient exec"
 					"gnome-open"
@@ -2205,6 +2353,7 @@
   *g:netrw_dynamic_maxfilenamelen* =32: enables dynamic determination of
 				    |g:netrw_maxfilenamelen|, which affects
 				    local file long listing.
+
   *g:netrw_errorlvl*		=0: error levels greater than or equal to
 				    this are permitted to be displayed
 				    0: notes
@@ -2212,7 +2361,7 @@
 				    2: errors
 
   *g:netrw_fastbrowse*		=0: slow speed directory browsing;
-				    never re-uses directory listings,
+				    never re-uses directory listings;
 				    always obtains directory listings.
 				=1: medium speed directory browsing;
 				    re-use directory listings only
@@ -2235,6 +2384,11 @@
 				trading off accuracy (ie. up-to-date listing)
 				versus speed.
 
+  *g:netrw_ffkeep*		(default: doesn't exist)
+  				If this variable exists and is zero, then
+				netrw will not do a save and restore for
+				|'fileformat'|.
+
   *g:netrw_fname_escape*	=' ?&;%'
 				Used on filenames before remote reading/writing
 
@@ -2303,10 +2457,19 @@
 				     stamp information and file size)
 				= 2: wide listing (multiple files in columns)
 				= 3: tree style listing
+
   *g:netrw_list_hide*		comma separated pattern list for hiding files
 				Patterns are regular expressions (see |regexp|)
-				Example: let g:netrw_list_hide= '.*\.swp$'
-				 default: ""
+				There's some special support for git-ignore
+				files: you may add the output from the helper
+				function 'netrw_gitignore#Hide() automatically
+				hiding all gitignored files.
+				For more details see |netrw-gitignore|.
+
+				Examples:
+				 let g:netrw_list_hide= '.*\.swp$'
+         			 let g:netrw_list_hide= netrw_gitignore#Hide().'.*\.swp$'
+				default: ""
 
   *g:netrw_localcopycmd*	="cp" Linux/Unix/MacOS/Cygwin
 				="copy" Windows
@@ -2348,7 +2511,7 @@
 				evaluation will be suppressed
 				(see |'ballooneval'|)
 
-  *g:netrw_remote_mkdir*	command for making a local directory
+  *g:netrw_remote_mkdir*	command for making a remote directory
 				via ftp  (also see |g:netrw_mkdir_cmd|)
 				 default: "mkdir"
 
@@ -2371,13 +2534,13 @@
 
 				  default: =0
 
-  *g:netrw_rm_cmd*		command for removing files
+  *g:netrw_rm_cmd*		command for removing remote files
 				 default: "ssh USEPORT HOSTNAME rm"
 
-  *g:netrw_rmdir_cmd*		command for removing directories
+  *g:netrw_rmdir_cmd*		command for removing remote directories
 				 default: "ssh USEPORT HOSTNAME rmdir"
 
-  *g:netrw_rmf_cmd*		command for removing softlinks
+  *g:netrw_rmf_cmd*		command for removing remote softlinks
 				 default: "ssh USEPORT HOSTNAME rm -f"
 
   *g:netrw_sort_by*		sort by "name", "time", or "size"
@@ -2396,7 +2559,7 @@
 
   *g:netrw_sort_sequence*	when sorting by name, first sort by the
 				comma-separated pattern sequence.  Note that
-				the filigree added to indicate filetypes
+				any filigree added to indicate filetypes
 				should be accounted for in your pattern.
 				 default: '[\/]$,*,\.bak$,\.o$,\.h$,
 				           \.info$,\.swp$,\.obj$'
@@ -2412,7 +2575,7 @@
 					netrwMakefile: [mM]akefile *.mak
 					netrwObj     : *.o *.obj
 					netrwTags    : tags ANmenu ANtags
-					netrwTilde   : *~
+					netrwTilde   : *
 					netrwTmp     : tmp* *tmp
 
 				These syntax highlighting groups are linked
@@ -2421,8 +2584,27 @@
 				one may put lines like >
 					hi link netrwCompress Visual
 <				into one's <.vimrc> to use one's own
-				preferences.
-
+				preferences.  Alternatively, one may
+				put such specifications into
+				.vim/after/syntax/netrw.vim.
+
+				As an example, I myself use a dark-background
+				colorscheme with the following in
+				.vim/after/syntax/netrw.vim: >
+
+ hi netrwCompress term=NONE cterm=NONE gui=NONE ctermfg=10 guifg=green  ctermbg=0 guibg=black
+ hi netrwData	  term=NONE cterm=NONE gui=NONE ctermfg=9 guifg=blue ctermbg=0 guibg=black
+ hi netrwHdr	  term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
+ hi netrwLex	  term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
+ hi netrwYacc	  term=NONE cterm=NONE,italic gui=NONE guifg=SeaGreen1
+ hi netrwLib	  term=NONE cterm=NONE gui=NONE ctermfg=14 guifg=yellow
+ hi netrwObj	  term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
+ hi netrwTilde	  term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
+ hi netrwTmp	  term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
+ hi netrwTags	  term=NONE cterm=NONE gui=NONE ctermfg=12 guifg=red
+ hi netrwDoc	  term=NONE cterm=NONE gui=NONE ctermfg=220 ctermbg=27 guifg=yellow2 guibg=Blue3
+ hi netrwSymLink  term=NONE cterm=NONE gui=NONE ctermfg=220 ctermbg=27 guifg=grey60
+<
   *g:netrw_ssh_browse_reject*	ssh can sometimes produce unwanted lines,
 				messages, banners, and whatnot that one doesn't
 				want masquerading as "directories" and "files".
@@ -2457,6 +2639,7 @@
 				ml_get errors, try putting
 				  let g:netrw_use_noswf= 0
 				in your .vimrc.
+				  default: 1
 
   *g:netrw_winsize*		specify initial size of new windows made with
 				"o" (see |netrw-o|), "v" (see |netrw-v|),
@@ -2467,6 +2650,9 @@
 				 If g:netrw_winsize is less than zero, then
 				the absolute value of g:netrw_winsize lines
 				or columns will be used for the new window.
+				 If g:netrw_winsize is zero, then a normal
+				split will be made (ie. |'equalalways'| will
+				take effect, for example).
 				 default: 50  (for 50%)
 
   *g:netrw_xstrlen*		Controls how netrw computes string lengths,
@@ -2496,7 +2682,7 @@
 options to something that's compatible with netrw's needs, and then restoring
 them.  However, the autochdir option: >
 	:set acd
-is problematical.  Autochdir sets the current directory to that containing the
+is problematic.  Autochdir sets the current directory to that containing the
 file you edit; this apparently also applies to directories.  In other words,
 autochdir sets the current directory to that containing the "file" (even if
 that "file" is itself a directory).
@@ -2547,9 +2733,11 @@
 							*netrw-createfile*
 OPEN A NEW FILE IN NETRW'S CURRENT DIRECTORY		*netrw-%*
 
-To open a file in netrw's current directory, press "%".  This map will
-query the user for a new filename; an empty file by that name will be
-placed in the netrw's current directory (ie. b:netrw_curdir).
+To open a new file in netrw's current directory, press "%".  This map
+will query the user for a new filename; an empty file by that name will
+be placed in the netrw's current directory (ie. b:netrw_curdir).
+
+Related topics:               |netrw-d|
 
 
 PREVIEW WINDOW				*netrw-p* *netrw-preview* {{{2
@@ -2573,6 +2761,9 @@
 	   will use only 30% of the columns available; the rest of the window
 	   is used for the preview window.
 
+Also see: |g:netrw_chgwin| |netrw-P|
+
+
 PREVIOUS WINDOW				*netrw-P* *netrw-prvwin* {{{2
 
 To edit a file or directory in the previously used (last accessed) window (see
@@ -2592,6 +2783,8 @@
    |g:netrw_preview| control horizontal vs vertical splitting
    |g:netrw_winsize| control initial sizing
 
+Also see: |g:netrw_chgwin| |netrw-p|
+
 
 REFRESHING THE LISTING			*netrw-ctrl-l* *netrw-ctrl_l* {{{2
 
@@ -2629,6 +2822,7 @@
     Note that moving files is a dangerous operation; copies are safer.  That's
     because a "move" for remote files is actually a copy + delete -- and if
     the copy fails and the delete does not, you may lose the file.
+    Use at your own risk.
 
 The g:netrw_rename_cmd variable is used to implement renaming.  By default its
 value is:
@@ -2655,7 +2849,16 @@
 g:netrw_chgwin to the selected window number.  Subsequent selection of a file
 to edit (|netrw-cr|) will use that window.
 
-Related topics:			|netrw-cr|
+	* C  by itself, will select the current window for editing via
+	  |netrw-cr|
+
+	* [count]C the count will be used as the window number to be used
+	  for editing via |netrw-cr|.
+Using >
+	let g:netrw_chgwin= -1
+will restore the default editing behavior (ie. use the current window).
+
+Related topics:			|netrw-cr| |g:netrw_browse_split|
 Associated setting variables:	|g:netrw_chgwin|
 
 
@@ -2742,7 +2945,7 @@
 
 		(taken from an answer provided by Wu Yongwei on the vim
 		mailing list)
-		I now see the problem. You code page is not 936, right? Vim
+		I now see the problem. Your code page is not 936, right? Vim
 		seems only able to open files with names that are valid in the
 		current code page, as are many other applications that do not
 		use the Unicode version of Windows APIs. This is an OS-related
@@ -2943,6 +3146,15 @@
 	     all netrw's mouse mappings, not just the <leftmouse> one.
 	     (see |g:netrw_mousemaps|)
 
+								*netrw-p16*
+	P16. When editing remote files (ex. :e ftp://hostname/path/file),
+	     under Windows I get an |E303| message complaining that its unable
+	     to open a swap file.
+
+	     (romainl) It looks like you are starting Vim from a protected
+	     directory.  Start if from your $HOME or another writable
+	     directory.
+
 ==============================================================================
 11. Debugging Netrw Itself				*netrw-debug* {{{1
 
@@ -2950,9 +3162,6 @@
 >
 	/usr/local/share/vim/vim7x/plugin/netrwPlugin.vim
 	/usr/local/share/vim/vim7x/autoload/netrw.vim
-< -or- >
-	/usr/local/share/vim/vim6x/plugin/netrwPlugin.vim
-	/usr/local/share/vim/vim6x/autoload/netrw.vim
 <
 which is loaded automatically at startup (assuming :set nocp).
 
@@ -2962,9 +3171,7 @@
 	   or
 	     http://vim.sourceforge.net/scripts/script.php?script_id=120
 
-	  It now comes as a "vimball"; if you're using vim 7.0 or earlier,
-	  you'll need to update vimball, too.  See
-	     http://www.drchip.org/astronaut/vim/index.html#VIMBALL
+	  Decho.vim is provided as a "vimball"; see |vimball-intro|.
 
 	2. Edit the <netrw.vim> file by typing: >
 
@@ -2988,15 +3195,153 @@
 	   read/write your file over the network in a separate tab.
 
 	   To save the file, use >
+
 		:tabnext
 		:set bt=
 		:w! DBG
-<	   Please send that information to <netrw.vim>'s maintainer, >
+
+<	   Furthermore, it'd be helpful if you would type >
+		:Dsep <command>
+<	   where <command> is the command you're about to type next,
+	   thereby making it easier to associate which part of the
+	   debugging trace is due to which command.
+
+	   Please send that information to <netrw.vim>'s maintainer along
+	   with the o/s you're using and vim version you're using
+	   (see |:version|) >
 		NdrOchip at ScampbellPfamily.AbizM - NOSPAM
 <
 ==============================================================================
 12. History						*netrw-history* {{{1
 
+	v152:	Apr 08, 2014   	* uses the |'noswapfile'| option (requires
+				  vim 7.4 with patch 213)
+				* (Enno Nagel) turn |'rnu'| off in netrw
+				  buffers.
+				* (Quinn Strahl) suggested that netrw
+				  allow regular window splitting to occur,
+				  thereby allowing |'equalalways'| to take
+				  effect.
+				* (qingtian zhao) normally, netrw will
+				  save and restore the |'fileformat'|;
+				  however, sometimes that isn't wanted
+		Apr 14, 2014	* whenever netrw marks a buffer as ro,
+				  it will also mark it as nomod.
+		Apr 16, 2014	* sftp protocol now supported by
+				  netrw#Obtain(); this means that one
+				  may use "mc" to copy a remote file
+				  to a local file using sftp, and that
+				  the |netrw-O| command can obtain remote
+				  files via sftp.
+				* added [count]C support (see |netrw-C|)
+		Apr 18, 2014	* when |g:netrw_chgwin| is one more than
+				  the last window, then vertically split
+				  the last window and use it as the
+				  chgwin window.
+		May 09, 2014	* SavePosn was "saving filename under cursor"
+				  from a non-netrw window when using :Rex.
+	v151:	Jan 22, 2014	* extended :Rexplore to return to buffer
+				  prior to Explore or editing a directory
+				* (Ken Takata) netrw gave error when
+				  clipboard was disabled.  Sol'n: Placed
+				  several if has("clipboard") tests in.
+				* Fixed ftp://X@Y@Z// problem; X@Y now
+				  part of user id, and only Z is part of
+				  hostname.
+				* (A Loumiotis) reported that completion
+				  using a directory name containing spaces
+				  did not work.  Fixed with a retry in
+				  netrw#Explore() which removes the
+				  backslashes vim inserted.
+		Feb 26, 2014	* :Rexplore now records the current file
+				   using w:netrw_rexfile when returning via
+				  |:Rexplore|
+		Mar 08, 2014	* (David Kotchan) provided some patches
+				  allowing netrw to work properly with
+				  windows shares.
+				* Multiple one-liner help messages available
+				  by pressing <cr> while atop the "Quick
+				  Help" line
+				* worked on ShellCmdPost, FocusGained event
+				  handling.
+				* |:Lexplore| path: will be used to update
+				  a left-side netrw browsing directory.
+		Mar 12, 2014	* |:netrw-s-cr|: use <s-cr>  to close
+				  tree directory implemented
+		Mar 13, 2014	* (Tony Mechylynck) reported that using
+				  the browser with ftp on a directory,
+				  and selecting a gzipped txt file, that
+				  an E19 occurred (which was issued by
+				  gzip.vim).  Fixed.
+		Mar 14, 2014	* Implemented :MF and :MT (see |netrw-:MF|
+				  and |netrw-:MT|, respectively)
+		Mar 17, 2014	* |:Ntree| [dir] wasn't working properly; fixed
+		Mar 18, 2014	* Changed all uses of set to setl
+		Mar 18, 2014	* Commented the netrw_btkeep line in
+				  s:NetrwOptionSave(); the effect is that
+				  netrw buffers will remain as |'bt'|=nofile.
+				  This should prevent swapfiles being created
+				  for netrw buffers.
+		Mar 20, 2014	* Changed all uses of lcd to use s:NetrwLcd()
+				  instead.  Consistent error handling results
+				  and it also handles Window's shares
+				* Fixed |netrw-d| command when applied with ftp
+				* https: support included for netrw#NetRead()
+	v150:	Jul 12, 2013	* removed a "keepalt" to allow ":e #" to
+				  return to the netrw directory listing
+		Jul 13, 2013	* (Jonas Diemer) suggested changing
+				  a <cWORD> to <cfile>.
+		Jul 21, 2013	* (Yuri Kanivetsky) reported that netrw's
+				  use of mkdir did not produce directories
+				  following the user's umask.
+		Aug 27, 2013	* introduced |g:netrw_altfile| option
+		Sep 05, 2013	* s:Strlen() now uses |strdisplaywidth()|
+				  when available, by default
+		Sep 12, 2013	* (Selyano Baldo) reported that netrw wasn't
+				  opening some directories properly from the
+				  command line.
+		Nov 09, 2013	* |:Lexplore| introduced
+				* (Ondrej Platek) reported an issue with
+				  netrw's trees (P15).  Fixed.
+				* (Jorge Solis) reported that "t" in
+				  tree mode caused netrw to forget its
+				  line position.
+		Dec 05, 2013	* Added <s-leftmouse> file marking
+				  (see |netrw-mf|)
+		Dec 05, 2013	* (Yasuhiro Matsumoto) Explore should use
+				  strlen() instead s:Strlen() when handling
+				  multibyte chars with strpart()
+				  (ie. strpart() is byte oriented, not
+				  display-width oriented).
+		Dec 09, 2013	* (Ken Takata) Provided a patch; File sizes
+				  and a portion of timestamps were wrongly
+				  highlighted with the directory color when
+				  setting `:let g:netrw_liststyle=1` on Windows.
+				* (Paul Domaskis) noted that sometimes
+				  cursorline was activating in non-netrw
+				  windows.  All but one setting of cursorline
+				  was done via setl; there was one that was
+				  overlooked.  Fixed.
+		Dec 24, 2013	* (esquifit) asked that netrw allow the
+				  /cygdrive prefix be a user-alterable
+				  parameter.
+		Jan 02, 2014	* Fixed a problem with netrw-based ballon
+				  evaluation (ie. netrw#NetrwBaloonHelp()
+				  not having been loaded error messages)
+		Jan 03, 2014	* Fixed a problem with tree listings
+				* New command installed: |:Ntree|
+		Jan 06, 2014	* (Ivan Brennan) reported a problem with
+				  |netrw-P|.  Fixed.
+		Jan 06, 2014	* Fixed a problem with |netrw-P| when the
+				  modified file was to be abandoned.
+		Jan 15, 2014	* (Matteo Cavalleri) reported that when the
+				  banner is suppressed and tree listing is
+				  used, a blank line was left at the top of
+				  the display.  Fixed.
+		Jan 20, 2014	* (Gideon Go) reported that, in tree listing
+				  style, with a previous window open, that
+				  the wrong directory was being used to open
+				  a file.  Fixed. (P21)
 	v149:	Apr 18, 2013	* in wide listing format, now have maps for
 				  w and b to move to next/previous file
 		Apr 26, 2013	* one may now copy files in the same
@@ -3009,7 +3354,8 @@
 		May 01, 2013	* :Explore ftp://... wasn't working.  Fixed.
 		May 02, 2013	* introduced |g:netrw_bannerbackslash| as
 				  requested by Paul Domaskis.
-		May 18, 2013	* More fixes for windows (not cygwin)
+		Jul 03, 2013	* Explore now avoids splitting when a buffer
+				  will be hidden.
 	v148:	Apr 16, 2013	* changed Netrw's Style menu to allow direct
 				  choice of listing style, hiding style, and
 				  sorting style
diff -Naur vim74.orig/runtime/doc/pi_vimball.txt vim74/runtime/doc/pi_vimball.txt
--- vim74.orig/runtime/doc/pi_vimball.txt	2013-08-10 11:25:00.000000000 +0000
+++ vim74/runtime/doc/pi_vimball.txt	2014-10-10 14:53:40.335390624 +0000
@@ -188,7 +188,7 @@
 			  * Changed silent! to sil! (shorter)
 			  * Safed |'swf'| setting (during vimball extraction,
 			    its now turned off)
-	32 : May 19, 2010 * (Christian Brabrandt) :so someplugin.vba and
+	32 : May 19, 2010 * (Christian Brabandt) :so someplugin.vba and
 			    :so someplugin.vba.gz (and the other supported
 			    compression types) now works
 			  * (Jan Steffens) added support for xz compression
diff -Naur vim74.orig/runtime/doc/quickfix.txt vim74/runtime/doc/quickfix.txt
--- vim74.orig/runtime/doc/quickfix.txt	2013-08-10 11:25:00.000000000 +0000
+++ vim74/runtime/doc/quickfix.txt	2014-10-10 14:53:40.345390598 +0000
@@ -1,4 +1,4 @@
-*quickfix.txt*  For Vim version 7.4.  Last change: 2013 Aug 03
+*quickfix.txt*  For Vim version 7.4.  Last change: 2014 Mar 27
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -202,8 +202,8 @@
 			the current window is used instead of the quickfix
 			list.
 
-							*:caddb* *:caddbuffer*
-:caddb[uffer] [bufnr]	Read the error list from the current buffer and add
+							*:cad* *:caddbuffer*
+:cad[dbuffer] [bufnr]	Read the error list from the current buffer and add
 			the errors to the current quickfix list.  If a
 			quickfix list is not present, then a new list is
 			created. Otherwise, same as ":cbuffer".
@@ -240,8 +240,8 @@
 :lgete[xpr] {expr}	Same as |:cgetexpr|, except the location list for the
 			current window is used instead of the quickfix list.
 
-							*:cad* *:caddexpr*
-:cad[dexpr] {expr}	Evaluate {expr} and add the resulting lines to the
+							*:cadde* *:caddexpr*
+:cadde[xpr] {expr}	Evaluate {expr} and add the resulting lines to the
 			current quickfix list. If a quickfix list is not
 			present, then a new list is created. The current
 			cursor position will not be changed. See |:cexpr| for
@@ -304,18 +304,23 @@
 
 					    *:cope* *:copen* *w:quickfix_title*
 :cope[n] [height]	Open a window to show the current list of errors.
+
 			When [height] is given, the window becomes that high
-			(if there is room).  Otherwise the window is made ten
-			lines high.
-			The window will contain a special buffer, with
-			'buftype' equal to "quickfix".  Don't change this!
+			(if there is room).  When [height] is omitted the
+			window is made ten lines high.
+
 			If there already is a quickfix window, it will be made
 			the current window.  It is not possible to open a
-			second quickfix window. The window will have the
-			w:quickfix_title variable set which will indicate the
-			command that produced the quickfix list. This can be
-			used to compose a custom status line if the value of
-			'statusline' is adjusted properly.
+			second quickfix window.  If [height] is given the
+			existing window will be resized to it.
+
+			The window will contain a special buffer, with
+			'buftype' equal to "quickfix".  Don't change this!
+			The window will have the w:quickfix_title variable set
+			which will indicate the command that produced the
+			quickfix list. This can be used to compose a custom
+			status line if the value of 'statusline' is adjusted
+			properly.
 
 							*:lop* *:lopen*
 :lop[en] [height]	Open a window to show the location list for the
@@ -838,7 +843,7 @@
 The alltests.py script seems to be used quite often, that's all.
 Useful values for the 'makeprg' options therefore are:
  setlocal makeprg=./alltests.py " Run a testsuite
- setlocal makeprg=python %      " Run a single testcase
+ setlocal makeprg=python\ %:S   " Run a single testcase
 
 Also see http://vim.sourceforge.net/tip_view.php?tip_id=280.
 
@@ -1332,7 +1337,7 @@
 Here is an alternative from Michael F. Lamb for Unix that filters the errors
 first: >
   :setl errorformat=%Z%f:%l:\ %m,%A%p^,%-G%*[^sl]%.%#
-  :setl makeprg=javac\ %\ 2>&1\ \\\|\ vim-javac-filter
+  :setl makeprg=javac\ %:S\ 2>&1\ \\\|\ vim-javac-filter
 
 You need to put the following in "vim-javac-filter" somewhere in your path
 (e.g., in ~/bin) and make it executable: >
diff -Naur vim74.orig/runtime/doc/quickref.txt vim74/runtime/doc/quickref.txt
--- vim74.orig/runtime/doc/quickref.txt	2013-08-10 11:25:00.000000000 +0000
+++ vim74/runtime/doc/quickref.txt	2014-10-10 14:53:40.348723923 +0000
@@ -1,4 +1,4 @@
-*quickref.txt*  For Vim version 7.4.  Last change: 2013 Jun 29
+*quickref.txt*  For Vim version 7.4.  Last change: 2014 Aug 06
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -624,6 +624,8 @@
 'bioskey'	  'biosk'   MS-DOS: use bios calls for input characters
 'bomb'			    prepend a Byte Order Mark to the file
 'breakat'	  'brk'     characters that may cause a line break
+'breakindent'	  'bri'     wrapped line repeats indent 
+'breakindentopt'  'briopt'  settings for 'breakindent'
 'browsedir'	  'bsdir'   which directory to start browsing in
 'bufhidden'	  'bh'	    what to do when buffer is no longer in window
 'buflisted'	  'bl'	    whether the buffer shows up in the buffer list
@@ -829,6 +831,7 @@
 'regexpengine'	  're'	    default regexp engine to use
 'relativenumber'  'rnu'	    show relative line number in front of each line
 'remap'			    allow mappings to work recursively
+'renderoptions'	  'rop'	    options for text rendering on Windows
 'report'		    threshold for reporting nr. of lines changed
 'restorescreen'   'rs'	    Win32: restore screen when exiting
 'revins'	  'ri'	    inserting characters will work backwards
diff -Naur vim74.orig/runtime/doc/recover.txt vim74/runtime/doc/recover.txt
--- vim74.orig/runtime/doc/recover.txt	2013-08-10 11:25:00.000000000 +0000
+++ vim74/runtime/doc/recover.txt	2014-10-10 14:53:40.358723898 +0000
@@ -1,4 +1,4 @@
-*recover.txt*   For Vim version 7.4.  Last change: 2010 Jul 20
+*recover.txt*   For Vim version 7.4.  Last change: 2014 Mar 27
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -81,7 +81,14 @@
 'maxmemtot'.  And when making a change to a read-only file, the swap file is
 created anyway.
 
-The 'swapfile' option can be reset to avoid creating a swapfile.
+The 'swapfile' option can be reset to avoid creating a swapfile.  And the
+|:noswapfile| modifier can be used to not create a swapfile for a new buffer.
+
+:nos[wapfile]   {command}			*:nos* *:noswapfile*
+		Execute {command}. If it contains a command that loads a new
+		buffer, it will be loaded without creating a swapfile and the
+		'swapfile' option will be reset.  If a buffer already had a
+		swapfile it is not removed and 'swapfile' is not reset.
 
 
 Detecting an existing swap file ~
diff -Naur vim74.orig/runtime/doc/repeat.txt vim74/runtime/doc/repeat.txt
--- vim74.orig/runtime/doc/repeat.txt	2013-08-10 11:25:00.000000000 +0000
+++ vim74/runtime/doc/repeat.txt	2014-10-10 14:53:40.365390548 +0000
@@ -1,4 +1,4 @@
-*repeat.txt*    For Vim version 7.4.  Last change: 2013 Jul 25
+*repeat.txt*    For Vim version 7.4.  Last change: 2014 Mar 25
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -26,10 +26,14 @@
 
 Simple changes can be repeated with the "." command.  Without a count, the
 count of the last change is used.  If you enter a count, it will replace the
-last one.  If the last change included a specification of a numbered register,
-the register number will be incremented.  See |redo-register| for an example
-how to use this.  Note that when repeating a command that used a Visual
-selection, the same SIZE of area is used, see |visual-repeat|.
+last one.  |v:count| and |v:count1| will be set.
+
+If the last change included a specification of a numbered register, the
+register number will be incremented.  See |redo-register| for an example how
+to use this.
+
+Note that when repeating a command that used a Visual selection, the same SIZE
+of area is used, see |visual-repeat|.
 
 							*@:*
 @:			Repeat last command-line [count] times.
@@ -584,6 +588,12 @@
 
 For profiling syntax highlighting see |:syntime|.
 
+For example, to profile the one_script.vim script file: >
+	:profile start /tmp/one_script_profile
+	:profile file one_script.vim
+	:source one_script.vim
+	:exit
+
 
 :prof[ile] start {fname}			*:prof* *:profile* *E750*
 		Start profiling, write the output in {fname} upon exit.
@@ -608,8 +618,10 @@
 		This only profiles the script itself, not the functions
 		defined in it.
 		When the [!] is added then all functions defined in the script
-		will also be profiled.  But only if the script is loaded after
-		this command.
+		will also be profiled.
+		Note that profiling only starts when the script is loaded
+		after this command.  A :profile command in the script itself
+		won't work.
 
 
 :profd[el] ...						*:profd* *:profdel*
diff -Naur vim74.orig/runtime/doc/sign.txt vim74/runtime/doc/sign.txt
--- vim74.orig/runtime/doc/sign.txt	2013-08-10 11:25:01.000000000 +0000
+++ vim74/runtime/doc/sign.txt	2014-10-10 14:53:40.372057198 +0000
@@ -1,4 +1,4 @@
-*sign.txt*      For Vim version 7.4.  Last change: 2012 Jul 10
+*sign.txt*      For Vim version 7.4.  Last change: 2014 May 07
 
 
 		  VIM REFERENCE MANUAL    by Gordon Prieur
@@ -137,6 +137,7 @@
 :sign place {id} line={lnum} name={name} buffer={nr}
 		Same, but use buffer {nr}.
 
+							*E885*
 :sign place {id} name={name} file={fname}
 		Change the placed sign {id} in file {fname} to use the defined
 		sign {name}.  See remark above about {fname} |:sign-fname|.
@@ -173,7 +174,7 @@
 		Remove the placed sign at the cursor position.
 
 
-LISTING PLACED SIGNS
+LISTING PLACED SIGNS					*:sign-place-list*
 
 :sign place file={fname}
 		List signs placed in file {fname}.
diff -Naur vim74.orig/runtime/doc/spell.txt vim74/runtime/doc/spell.txt
--- vim74.orig/runtime/doc/spell.txt	2013-08-10 11:25:01.000000000 +0000
+++ vim74/runtime/doc/spell.txt	2014-10-10 14:53:40.378723848 +0000
@@ -1,4 +1,4 @@
-*spell.txt*	For Vim version 7.4.  Last change: 2013 Jul 17
+*spell.txt*	For Vim version 7.4.  Last change: 2014 Sep 19
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -269,6 +269,13 @@
 	latin1		yi		transliterated Yiddish
 	utf-8		yi-tr		transliterated Yiddish
 
+							*spell-cjk*
+Chinese, Japanese and other East Asian characters are normally marked as
+errors, because spell checking of these characters is not supported. If
+'spelllang' includes "cjk", these characters are not marked as errors.  This
+is useful when editing text with spell checking while some Asian words are
+present.
+
 
 SPELL FILES						*spell-load*
 
@@ -932,9 +939,10 @@
 
 If you get an E763 warning that the word tables differ you need to update your
 ".spl" spell files.  If you downloaded the files, get the latest version of
-all spell files you use.  Otherwise generate the .spl file again with
-|:mkspell|.  If you still get errors check the FOL, LOW and UPP lines in the
-used .aff files.
+all spell files you use.  If you are only using one, e.g., German, then also
+download the recent English spell files.  Otherwise generate the .spl file
+again with |:mkspell|.  If you still get errors check the FOL, LOW and UPP
+lines in the used .aff files.
 
 The XX.ascii.spl spell file generated with the "-ascii" argument will not
 contain the table with characters, so that it can be combine with spell files
@@ -1050,6 +1058,9 @@
 	SFX F 0 in   [^i]n      # Spion > Spionin  ~
 	SFX F 0 nen  in		# Bauerin > Bauerinnen ~
 
+However, to avoid lots of errors in affix files written for Myspell, you can
+add the IGNOREEXTRA flag.
+
 Apparently Myspell allows an affix name to appear more than once.  Since this
 might also be a mistake, Vim checks for an extra "S".  The affix files for
 Myspell that use this feature apparently have this flag.  Example:
@@ -1103,6 +1114,14 @@
 - CIRCUMFIX, as explained just below.
 
 
+IGNOREEXTRA						*spell-IGNOREEXTRA*
+
+Normally Vim gives an error for an extra field that does not start with '#'.
+This avoids errors going unnoticed.  However, some files created for Myspell
+or Hunspell may contain many entries with an extra field.  Use the IGNOREEXTRA
+flag to avoid lots of errors.
+
+
 CIRCUMFIX						*spell-CIRCUMFIX*
 
 The CIRCUMFIX flag means a prefix and suffix must be added at the same time.
diff -Naur vim74.orig/runtime/doc/starting.txt vim74/runtime/doc/starting.txt
--- vim74.orig/runtime/doc/starting.txt	2013-08-10 11:25:01.000000000 +0000
+++ vim74/runtime/doc/starting.txt	2014-10-10 14:53:40.385390498 +0000
@@ -1,4 +1,4 @@
-*starting.txt*  For Vim version 7.4.  Last change: 2013 Jul 20
+*starting.txt*  For Vim version 7.4.  Last change: 2014 Jul 09
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -167,7 +167,10 @@
 							*-+/*
 +/{pat}		The cursor will be positioned on the first line containing
 		"pat" in the first file being edited (see |pattern| for the
-		available search patterns).
+		available search patterns).  The search starts at the cursor
+		position, which can be the first line or the cursor position
+		last used from |viminfo|. To force a search from the first
+		line use "+1 +/pat".
 
 +{command}						*-+c* *-c*
 -c {command}	{command} will be executed after the first file has been
@@ -1276,8 +1279,10 @@
 			When [!] is included an existing file is overwritten.
 			When [file] is omitted or is a number from 1 to 9, a
 			name is generated and 'viewdir' prepended.  When the
-			last directory name in 'viewdir' does not exist, this
-			directory is created.
+			last path part of 'viewdir' does not exist, this
+			directory is created.  E.g., when 'viewdir' is
+			"$VIM/vimfiles/view" then "view" is created in
+			"$VIM/vimfiles".
 			An existing file is always overwritten then.  Use
 			|:loadview| to load this view again.
 			When [file] is the name of a file ('viewdir' is not
@@ -1501,7 +1506,7 @@
 			already set (registers, marks, |v:oldfiles|, etc.)
 			will be overwritten   {not in Vi}
 
-					*:wv* *:wviminfo* *E137* *E138* *E574*
+				*:wv* *:wviminfo* *E137* *E138* *E574* *E886*
 :wv[iminfo][!] [file]	Write to viminfo file [file] (default: see above).
 			The information in the file is first read in to make
 			a merge between old and new info.  When [!] is used,
diff -Naur vim74.orig/runtime/doc/syntax.txt vim74/runtime/doc/syntax.txt
--- vim74.orig/runtime/doc/syntax.txt	2013-08-10 11:25:01.000000000 +0000
+++ vim74/runtime/doc/syntax.txt	2014-10-10 14:53:40.395390473 +0000
@@ -1,4 +1,4 @@
-*syntax.txt*	For Vim version 7.4.  Last change: 2013 Jul 05
+*syntax.txt*	For Vim version 7.4.  Last change: 2014 Sep 27
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -501,7 +501,7 @@
 takes the form of L123 for single-buffer HTML pages, or W2L123 for diff-view
 pages, and is used to jump to a specific line (in a specific window of a diff
 view). Javascript is inserted to open any closed dynamic folds
-(|g:html_dynamic_folds|) containing the specificed line before jumping. The
+(|g:html_dynamic_folds|) containing the specified line before jumping. The
 javascript also allows omitting the window ID in the url, and the leading L.
 For example: >
 
@@ -1022,6 +1022,21 @@
 This works immediately.
 
 
+CLOJURE							*ft-clojure-syntax*
+
+Setting *g:clojure_fold* enables folding Clojure code via the syntax engine.
+Any list, vector, or map that extends over more than one line can be folded
+using the standard Vim |fold-commands|.
+
+Please note that this option does not work with scripts that redefine the
+bracket syntax regions, such as rainbow-parentheses plugins.
+
+This option is off by default.
+>
+	" Default
+	let g:clojure_fold = 0
+<
+
 COBOL						*cobol.vim* *ft-cobol-syntax*
 
 COBOL highlighting has different needs for legacy code than it does for fresh
@@ -1281,6 +1296,32 @@
 to your startup file.
 
 
+EUPHORIA	    *euphoria3.vim* *euphoria4.vim* *ft-euphoria-syntax*
+
+Two syntax highlighting files exists for Euphoria. One for Euphoria 
+version 3.1.1, which is the default syntax highlighting file, and one for 
+Euphoria version 4.0.5 or later.
+
+Euphoria version 3.1.1 (http://www.rapideuphoria.com/) is still necessary 
+for developing applications for the DOS platform, which Euphoria version 4 
+(http://www.openeuphoria.org/) does not support.
+
+The following file extensions are auto-detected as Euphoria file type: 
+    
+	*.e, *.eu, *.ew, *.ex, *.exu, *.exw
+	*.E, *.EU, *.EW, *.EX, *.EXU, *.EXW
+
+To select syntax highlighting file for Euphoria, as well as for 
+auto-detecting the *.e and *.E file extensions as Euphoria file type,
+add the following line to your startup file: >
+
+	:let filetype_euphoria="euphoria3"
+
+	or 
+
+	:let filetype_euphoria="euphoria4"
+
+
 ERLANG						*erlang.vim* *ft-erlang-syntax*
 
 Erlang is a functional programming language developed by Ericsson.  Files with
@@ -1647,7 +1688,7 @@
 HTML comments are rather special (see an HTML reference document for the
 details), and the syntax coloring scheme will highlight all errors.
 However, if you prefer to use the wrong style (starts with <!-- and
-ends with --!>) you can define >
+ends with -->) you can define >
 	:let html_wrong_comments=1
 
 JavaScript and Visual Basic embedded inside HTML documents are highlighted as
@@ -1918,7 +1959,7 @@
 There are several implementations for LPC, we intend to support most widely
 used ones.  Here the default LPC syntax is for MudOS series, for MudOS v22
 and before, you should turn off the sensible modifiers, and this will also
-asserts the new efuns after v22 to be invalid, don't set this variable when
+assert the new efuns after v22 to be invalid, don't set this variable when
 you are using the latest version of MudOS: >
 
 	:let lpc_pre_v22 = 1
@@ -2238,7 +2279,7 @@
 
 	:let perl_include_pod = 0
 
-The reduce the complexity of parsing (and increase performance) you can switch
+To reduce the complexity of parsing (and increase performance) you can switch
 off two elements in the parsing of variable names and contents. >
 
 To handle package references in variable and function names not differently
@@ -2934,6 +2975,7 @@
 	Tex: Taking Advantage of Conceal Mode		|tex-conceal|
 	Tex: Selective Conceal Mode			|g:tex_conceal|
 	Tex: Controlling iskeyword			|g:tex_isk|
+	Tex: Fine Subscript and Superscript Control	|tex-supersub|
 
 				*tex-folding* *g:tex_fold_enabled*
  Tex: Want Syntax Folding? ~
@@ -3027,6 +3069,7 @@
 <
 As an example, let g:tex_fast= "M" will allow math-associated highlighting
 but suppress all the other region-based syntax highlighting.
+(also see: |g:tex_conceal| and |tex-supersub|)
 
 					*tex-morecommands* *tex-package*
  Tex: Want To Highlight More Commands? ~
@@ -3128,6 +3171,28 @@
 	* If g:tex_isk exists, then it will be used for the local 'iskeyword'
 	* Else the local 'iskeyword' will be set to 48-57,a-z,A-Z,192-255
 
+			*tex-supersub* *g:tex_superscripts* *g:tex_subscripts*
+ Tex: Fine Subscript and Superscript Control~
+
+	See |tex-conceal| for how to enable concealed character replacement.
+
+	See |g:tex_conceal| for selectively concealing accents, bold/italic,
+	math, Greek, and superscripts/subscripts.
+
+	One may exert fine control over which superscripts and subscripts one
+	wants syntax-based concealment for (see |:syn-cchar|).  Since not all
+	fonts support all characters, one may override the
+	concealed-replacement lists; by default these lists are given by: >
+
+	    let g:tex_superscripts= "[0-9a-zA-W.,:;+-<>/()=]"
+	    let g:tex_subscripts= "[0-9aehijklmnoprstuvx,+-/().]"
+<
+	For example, I use Luxi Mono Bold; it doesn't support subscript
+	characters for "hklmnpst", so I put >
+		let g:tex_subscripts= "[0-9aeijoruvx,+-/().]"
+<	in ~/.vim/ftplugin/tex/tex.vim in order to avoid having inscrutable
+	utf-8 glyphs appear.
+
 
 TF						*tf.vim* *ft-tf-syntax*
 
@@ -3156,18 +3221,16 @@
 embedded script highlighting they wish to have. >
 
    g:vimsyn_embed == 0   : don't embed any scripts
-   g:vimsyn_embed =~ 'm' : embed mzscheme (but only if vim supports it)
-   g:vimsyn_embed =~ 'p' : embed perl     (but only if vim supports it)
-   g:vimsyn_embed =~ 'P' : embed python   (but only if vim supports it)
-   g:vimsyn_embed =~ 'r' : embed ruby     (but only if vim supports it)
-   g:vimsyn_embed =~ 't' : embed tcl      (but only if vim supports it)
-<
-By default, g:vimsyn_embed is "mpPr"; ie. syntax/vim.vim will support
-highlighting mzscheme, perl, python, and ruby by default.  Vim's has("tcl")
-test appears to hang vim when tcl is not truly available.  Thus, by default,
-tcl is not supported for embedding (but those of you who like tcl embedded in
-their vim syntax highlighting can simply include it in the g:vimembedscript
-option).
+   g:vimsyn_embed =~ 'm' : support embedded mzscheme
+   g:vimsyn_embed =~ 'p' : support embedded perl
+   g:vimsyn_embed =~ 'P' : support embedded python
+   g:vimsyn_embed =~ 'r' : support embedded ruby
+   g:vimsyn_embed =~ 't' : support embedded tcl
+<
+By default, g:vimsyn_embed is a string supporting interpreters that your vim
+itself supports.  Concatenate multiple characters to support multiple types
+of embedded interpreters; ie. g:vimsyn_embed= "mp" supports embedded mzscheme
+and embedded perl.
 						*g:vimsyn_folding*
 
 Some folding is now supported with syntax/vim.vim: >
@@ -3736,7 +3799,7 @@
 
 
 			*:syn-contains* *E405* *E406* *E407* *E408* *E409*
-contains={groupname},..
+contains={group-name},..
 
 The "contains" argument is followed by a list of syntax group names.  These
 groups will be allowed to begin inside the item (they may extend past the
@@ -3789,13 +3852,13 @@
 area that is highlighted
 
 
-containedin={groupname}...				*:syn-containedin*
+containedin={group-name}...				*:syn-containedin*
 
 The "containedin" argument is followed by a list of syntax group names.  The
 item will be allowed to begin inside these groups.  This works as if the
 containing item has a "contains=" argument that includes this item.
 
-The {groupname}... can be used just like for "contains", as explained above.
+The {group-name}... can be used just like for "contains", as explained above.
 
 This is useful when adding a syntax item afterwards.  An item can be told to
 be included inside an already existing item, without changing the definition
@@ -3811,7 +3874,7 @@
 work.
 
 
-nextgroup={groupname},..				*:syn-nextgroup*
+nextgroup={group-name},..				*:syn-nextgroup*
 
 The "nextgroup" argument is followed by a list of syntax group names,
 separated by commas (just like with "contains", so you can also use patterns).
diff -Naur vim74.orig/runtime/doc/tags vim74/runtime/doc/tags
--- vim74.orig/runtime/doc/tags	2013-08-10 12:23:34.000000000 +0000
+++ vim74/runtime/doc/tags	2014-10-10 14:53:40.408723773 +0000
@@ -12,6 +12,7 @@
 %	motion.txt	/*%*
 %:.	cmdline.txt	/*%:.*
 %:8	cmdline.txt	/*%:8*
+%:S	cmdline.txt	/*%:S*
 %:e	cmdline.txt	/*%:e*
 %:gs	cmdline.txt	/*%:gs*
 %:h	cmdline.txt	/*%:h*
@@ -90,6 +91,10 @@
 'bl'	options.txt	/*'bl'*
 'bomb'	options.txt	/*'bomb'*
 'breakat'	options.txt	/*'breakat'*
+'breakindent'	options.txt	/*'breakindent'*
+'breakindentopt'	options.txt	/*'breakindentopt'*
+'bri'	options.txt	/*'bri'*
+'briopt'	options.txt	/*'briopt'*
 'brk'	options.txt	/*'brk'*
 'browsedir'	options.txt	/*'browsedir'*
 'bs'	options.txt	/*'bs'*
@@ -751,6 +756,7 @@
 'regexpengine'	options.txt	/*'regexpengine'*
 'relativenumber'	options.txt	/*'relativenumber'*
 'remap'	options.txt	/*'remap'*
+'renderoptions'	options.txt	/*'renderoptions'*
 'report'	options.txt	/*'report'*
 'restorescreen'	options.txt	/*'restorescreen'*
 'revins'	options.txt	/*'revins'*
@@ -761,6 +767,7 @@
 'rlc'	options.txt	/*'rlc'*
 'rnu'	options.txt	/*'rnu'*
 'ro'	options.txt	/*'ro'*
+'rop'	options.txt	/*'rop'*
 'rs'	options.txt	/*'rs'*
 'rtp'	options.txt	/*'rtp'*
 'ru'	options.txt	/*'ru'*
@@ -1140,6 +1147,7 @@
 +GUI_Photon	various.txt	/*+GUI_Photon*
 +GUI_neXtaw	various.txt	/*+GUI_neXtaw*
 +X11	various.txt	/*+X11*
++acl	various.txt	/*+acl*
 +arabic	various.txt	/*+arabic*
 +autocmd	various.txt	/*+autocmd*
 +balloon_eval	various.txt	/*+balloon_eval*
@@ -1165,6 +1173,7 @@
 +dialog_gui	various.txt	/*+dialog_gui*
 +diff	various.txt	/*+diff*
 +digraphs	various.txt	/*+digraphs*
++directx	various.txt	/*+directx*
 +dnd	various.txt	/*+dnd*
 +emacs_tags	various.txt	/*+emacs_tags*
 +eval	various.txt	/*+eval*
@@ -1199,6 +1208,7 @@
 +mouse	various.txt	/*+mouse*
 +mouse_dec	various.txt	/*+mouse_dec*
 +mouse_gpm	various.txt	/*+mouse_gpm*
++mouse_jsbterm	various.txt	/*+mouse_jsbterm*
 +mouse_netterm	various.txt	/*+mouse_netterm*
 +mouse_pterm	various.txt	/*+mouse_pterm*
 +mouse_sgr	various.txt	/*+mouse_sgr*
@@ -1262,6 +1272,7 @@
 +writebackup	various.txt	/*+writebackup*
 +xfontset	various.txt	/*+xfontset*
 +xim	various.txt	/*+xim*
++xpm	various.txt	/*+xpm*
 +xpm_w32	various.txt	/*+xpm_w32*
 +xsmp	various.txt	/*+xsmp*
 +xsmp_interact	various.txt	/*+xsmp_interact*
@@ -1412,6 +1423,7 @@
 /\%>c	pattern.txt	/*\/\\%>c*
 /\%>l	pattern.txt	/*\/\\%>l*
 /\%>v	pattern.txt	/*\/\\%>v*
+/\%C	pattern.txt	/*\/\\%C*
 /\%U	pattern.txt	/*\/\\%U*
 /\%V	pattern.txt	/*\/\\%V*
 /\%[]	pattern.txt	/*\/\\%[]*
@@ -1786,6 +1798,7 @@
 :3match	pattern.txt	/*:3match*
 ::.	cmdline.txt	/*::.*
 ::8	cmdline.txt	/*::8*
+::S	cmdline.txt	/*::S*
 ::e	cmdline.txt	/*::e*
 ::gs	cmdline.txt	/*::gs*
 ::h	cmdline.txt	/*::h*
@@ -1825,6 +1838,7 @@
 :GnatPretty	ft_ada.txt	/*:GnatPretty*
 :GnatTags	ft_ada.txt	/*:GnatTags*
 :Hexplore	pi_netrw.txt	/*:Hexplore*
+:Lexplore	pi_netrw.txt	/*:Lexplore*
 :Man	filetype.txt	/*:Man*
 :MkVimball	pi_vimball.txt	/*:MkVimball*
 :N	editing.txt	/*:N*
@@ -1836,6 +1850,7 @@
 :Nread	pi_netrw.txt	/*:Nread*
 :Ns	pi_netrw.txt	/*:Ns*
 :Nsource	pi_netrw.txt	/*:Nsource*
+:Ntree	pi_netrw.txt	/*:Ntree*
 :Nw	pi_netrw.txt	/*:Nw*
 :Nwrite	pi_netrw.txt	/*:Nwrite*
 :P	various.txt	/*:P*
@@ -1967,8 +1982,8 @@
 :cabc	map.txt	/*:cabc*
 :cabclear	map.txt	/*:cabclear*
 :cad	quickfix.txt	/*:cad*
-:caddb	quickfix.txt	/*:caddb*
 :caddbuffer	quickfix.txt	/*:caddbuffer*
+:cadde	quickfix.txt	/*:cadde*
 :caddexpr	quickfix.txt	/*:caddexpr*
 :caddf	quickfix.txt	/*:caddf*
 :caddfile	quickfix.txt	/*:caddfile*
@@ -2212,6 +2227,9 @@
 :foldopen	fold.txt	/*:foldopen*
 :for	eval.txt	/*:for*
 :fu	eval.txt	/*:fu*
+:func-abort	eval.txt	/*:func-abort*
+:func-dict	eval.txt	/*:func-dict*
+:func-range	eval.txt	/*:func-range*
 :function	eval.txt	/*:function*
 :function-verbose	eval.txt	/*:function-verbose*
 :g	repeat.txt	/*:g*
@@ -2230,6 +2248,8 @@
 :ha	print.txt	/*:ha*
 :hardcopy	print.txt	/*:hardcopy*
 :help	helphelp.txt	/*:help*
+:helpc	helphelp.txt	/*:helpc*
+:helpclose	helphelp.txt	/*:helpclose*
 :helpf	helphelp.txt	/*:helpf*
 :helpfind	helphelp.txt	/*:helpfind*
 :helpg	helphelp.txt	/*:helpg*
@@ -2298,6 +2318,8 @@
 :keepj	motion.txt	/*:keepj*
 :keepjumps	motion.txt	/*:keepjumps*
 :keepmarks	motion.txt	/*:keepmarks*
+:keepp	cmdline.txt	/*:keepp*
+:keeppatterns	cmdline.txt	/*:keeppatterns*
 :l	various.txt	/*:l*
 :lN	quickfix.txt	/*:lN*
 :lNext	quickfix.txt	/*:lNext*
@@ -2489,6 +2511,7 @@
 :nbkey	netbeans.txt	/*:nbkey*
 :nbstart	netbeans.txt	/*:nbstart*
 :ne	editing.txt	/*:ne*
+:netrw-s-cr	pi_netrw.txt	/*:netrw-s-cr*
 :new	windows.txt	/*:new*
 :next	editing.txt	/*:next*
 :next_f	editing.txt	/*:next_f*
@@ -2509,8 +2532,11 @@
 :noautocmd	autocmd.txt	/*:noautocmd*
 :noh	pattern.txt	/*:noh*
 :nohlsearch	pattern.txt	/*:nohlsearch*
+:nor	map.txt	/*:nor*
+:nore	map.txt	/*:nore*
 :norea	map.txt	/*:norea*
 :noreabbrev	map.txt	/*:noreabbrev*
+:norem	map.txt	/*:norem*
 :noremap	map.txt	/*:noremap*
 :noremap!	map.txt	/*:noremap!*
 :noreme	gui.txt	/*:noreme*
@@ -2518,6 +2544,8 @@
 :norm	various.txt	/*:norm*
 :normal	various.txt	/*:normal*
 :normal-range	various.txt	/*:normal-range*
+:nos	recover.txt	/*:nos*
+:noswapfile	recover.txt	/*:noswapfile*
 :nu	various.txt	/*:nu*
 :number	various.txt	/*:number*
 :nun	map.txt	/*:nun*
@@ -2738,6 +2766,7 @@
 :sign-jump	sign.txt	/*:sign-jump*
 :sign-list	sign.txt	/*:sign-list*
 :sign-place	sign.txt	/*:sign-place*
+:sign-place-list	sign.txt	/*:sign-place-list*
 :sign-undefine	sign.txt	/*:sign-undefine*
 :sign-unplace	sign.txt	/*:sign-unplace*
 :sil	various.txt	/*:sil*
@@ -3105,6 +3134,7 @@
 <CSI>	intro.txt	/*<CSI>*
 <Char->	map.txt	/*<Char->*
 <Char>	map.txt	/*<Char>*
+<CursorHold>	autocmd.txt	/*<CursorHold>*
 <D-	intro.txt	/*<D-*
 <Del>	change.txt	/*<Del>*
 <Down>	motion.txt	/*<Down>*
@@ -3427,6 +3457,7 @@
 CTRL-{char}	intro.txt	/*CTRL-{char}*
 Chinese	mbyte.txt	/*Chinese*
 Cmd-event	autocmd.txt	/*Cmd-event*
+CmdUndefined	autocmd.txt	/*CmdUndefined*
 Cmdline	cmdline.txt	/*Cmdline*
 Cmdline-mode	cmdline.txt	/*Cmdline-mode*
 CmdwinEnter	autocmd.txt	/*CmdwinEnter*
@@ -3568,7 +3599,7 @@
 E202	options.txt	/*E202*
 E203	autocmd.txt	/*E203*
 E204	autocmd.txt	/*E204*
-E205	if_pyth.txt	/*E205*
+E205	options.txt	/*E205*
 E206	options.txt	/*E206*
 E207	editing.txt	/*E207*
 E208	message.txt	/*E208*
@@ -4294,6 +4325,14 @@
 E879	syntax.txt	/*E879*
 E88	windows.txt	/*E88*
 E880	if_pyth.txt	/*E880*
+E881	autocmd.txt	/*E881*
+E882	eval.txt	/*E882*
+E883	eval.txt	/*E883*
+E884	eval.txt	/*E884*
+E885	sign.txt	/*E885*
+E886	starting.txt	/*E886*
+E887	if_pyth.txt	/*E887*
+E888	pattern.txt	/*E888*
 E89	message.txt	/*E89*
 E90	message.txt	/*E90*
 E91	options.txt	/*E91*
@@ -4423,6 +4462,13 @@
 OverTheSpot	mbyte.txt	/*OverTheSpot*
 P	change.txt	/*P*
 PATHEXT	eval.txt	/*PATHEXT*
+PHP_BracesAtCodeLevel	indent.txt	/*PHP_BracesAtCodeLevel*
+PHP_autoformatcomment	indent.txt	/*PHP_autoformatcomment*
+PHP_default_indenting	indent.txt	/*PHP_default_indenting*
+PHP_outdentSLComments	indent.txt	/*PHP_outdentSLComments*
+PHP_outdentphpescape	indent.txt	/*PHP_outdentphpescape*
+PHP_removeCRwhenUnix	indent.txt	/*PHP_removeCRwhenUnix*
+PHP_vintage_case_default_indent	indent.txt	/*PHP_vintage_case_default_indent*
 Pattern	pattern.txt	/*Pattern*
 Perl	if_perl.txt	/*Perl*
 Posix	intro.txt	/*Posix*
@@ -4766,6 +4812,7 @@
 arglist	editing.txt	/*arglist*
 arglist-position	editing.txt	/*arglist-position*
 arglist-quit	usr_07.txt	/*arglist-quit*
+arglistid()	eval.txt	/*arglistid()*
 argument-list	editing.txt	/*argument-list*
 argv()	eval.txt	/*argv()*
 as	motion.txt	/*as*
@@ -4863,6 +4910,7 @@
 blockwise-register	change.txt	/*blockwise-register*
 blockwise-visual	visual.txt	/*blockwise-visual*
 blowfish	options.txt	/*blowfish*
+blowfish2	options.txt	/*blowfish2*
 bold	syntax.txt	/*bold*
 bom-bytes	mbyte.txt	/*bom-bytes*
 book	intro.txt	/*book*
@@ -4900,6 +4948,7 @@
 byte-count	editing.txt	/*byte-count*
 byte2line()	eval.txt	/*byte2line()*
 byteidx()	eval.txt	/*byteidx()*
+byteidxcomp()	eval.txt	/*byteidxcomp()*
 bzip2	pi_gzip.txt	/*bzip2*
 c	change.txt	/*c*
 c.vim	syntax.txt	/*c.vim*
@@ -5350,6 +5399,7 @@
 dialog	gui_w32.txt	/*dialog*
 dialogs-added	version5.txt	/*dialogs-added*
 dib	motion.txt	/*dib*
+dict	eval.txt	/*dict*
 dict-functions	usr_41.txt	/*dict-functions*
 dict-identity	eval.txt	/*dict-identity*
 dict-modification	eval.txt	/*dict-modification*
@@ -5458,6 +5508,8 @@
 escape	intro.txt	/*escape*
 escape()	eval.txt	/*escape()*
 escape-bar	version4.txt	/*escape-bar*
+euphoria3.vim	syntax.txt	/*euphoria3.vim*
+euphoria4.vim	syntax.txt	/*euphoria4.vim*
 eval	eval.txt	/*eval*
 eval()	eval.txt	/*eval()*
 eval-examples	eval.txt	/*eval-examples*
@@ -5492,6 +5544,7 @@
 exclusive-linewise	motion.txt	/*exclusive-linewise*
 executable()	eval.txt	/*executable()*
 execute-menus	gui.txt	/*execute-menus*
+exepath()	eval.txt	/*exepath()*
 exim	starting.txt	/*exim*
 exists()	eval.txt	/*exists()*
 exp()	eval.txt	/*exp()*
@@ -5708,6 +5761,7 @@
 ft-changelog-syntax	syntax.txt	/*ft-changelog-syntax*
 ft-chill-syntax	syntax.txt	/*ft-chill-syntax*
 ft-clojure-indent	indent.txt	/*ft-clojure-indent*
+ft-clojure-syntax	syntax.txt	/*ft-clojure-syntax*
 ft-cobol-syntax	syntax.txt	/*ft-cobol-syntax*
 ft-coldfusion-syntax	syntax.txt	/*ft-coldfusion-syntax*
 ft-cpp-syntax	syntax.txt	/*ft-cpp-syntax*
@@ -5724,6 +5778,7 @@
 ft-dtd-syntax	syntax.txt	/*ft-dtd-syntax*
 ft-eiffel-syntax	syntax.txt	/*ft-eiffel-syntax*
 ft-erlang-syntax	syntax.txt	/*ft-erlang-syntax*
+ft-euphoria-syntax	syntax.txt	/*ft-euphoria-syntax*
 ft-flexwiki-syntax	syntax.txt	/*ft-flexwiki-syntax*
 ft-form-syntax	syntax.txt	/*ft-form-syntax*
 ft-fortran-indent	indent.txt	/*ft-fortran-indent*
@@ -5876,6 +5931,8 @@
 g:ada_with_gnat_project_files	ft_ada.txt	/*g:ada_with_gnat_project_files*
 g:ada_withuse_ordinary	ft_ada.txt	/*g:ada_withuse_ordinary*
 g:clojure_align_multiline_strings	indent.txt	/*g:clojure_align_multiline_strings*
+g:clojure_align_subforms	indent.txt	/*g:clojure_align_subforms*
+g:clojure_fold	syntax.txt	/*g:clojure_fold*
 g:clojure_fuzzy_indent	indent.txt	/*g:clojure_fuzzy_indent*
 g:clojure_fuzzy_indent_blacklist	indent.txt	/*g:clojure_fuzzy_indent_blacklist*
 g:clojure_fuzzy_indent_patterns	indent.txt	/*g:clojure_fuzzy_indent_patterns*
@@ -5924,6 +5981,7 @@
 g:html_use_encoding	syntax.txt	/*g:html_use_encoding*
 g:html_use_xhtml	syntax.txt	/*g:html_use_xhtml*
 g:html_whole_filler	syntax.txt	/*g:html_whole_filler*
+g:netrw_altfile	pi_netrw.txt	/*g:netrw_altfile*
 g:netrw_alto	pi_netrw.txt	/*g:netrw_alto*
 g:netrw_altv	pi_netrw.txt	/*g:netrw_altv*
 g:netrw_banner	pi_netrw.txt	/*g:netrw_banner*
@@ -5944,6 +6002,7 @@
 g:netrw_errorlvl	pi_netrw.txt	/*g:netrw_errorlvl*
 g:netrw_fastbrowse	pi_netrw.txt	/*g:netrw_fastbrowse*
 g:netrw_fetch_cmd	pi_netrw.txt	/*g:netrw_fetch_cmd*
+g:netrw_ffkeep	pi_netrw.txt	/*g:netrw_ffkeep*
 g:netrw_fname_escape	pi_netrw.txt	/*g:netrw_fname_escape*
 g:netrw_ftp	pi_netrw.txt	/*g:netrw_ftp*
 g:netrw_ftp_browse_reject	pi_netrw.txt	/*g:netrw_ftp_browse_reject*
@@ -5958,6 +6017,7 @@
 g:netrw_hide	pi_netrw.txt	/*g:netrw_hide*
 g:netrw_home	pi_netrw.txt	/*g:netrw_home*
 g:netrw_http_cmd	pi_netrw.txt	/*g:netrw_http_cmd*
+g:netrw_http_put_cmd	pi_netrw.txt	/*g:netrw_http_put_cmd*
 g:netrw_http_xcmd	pi_netrw.txt	/*g:netrw_http_xcmd*
 g:netrw_ignorenetrc	pi_netrw.txt	/*g:netrw_ignorenetrc*
 g:netrw_keepdir	pi_netrw.txt	/*g:netrw_keepdir*
@@ -6024,6 +6084,8 @@
 g:tex_no_error	syntax.txt	/*g:tex_no_error*
 g:tex_nospell	syntax.txt	/*g:tex_nospell*
 g:tex_stylish	syntax.txt	/*g:tex_stylish*
+g:tex_subscripts	syntax.txt	/*g:tex_subscripts*
+g:tex_superscripts	syntax.txt	/*g:tex_superscripts*
 g:tex_verbspell	syntax.txt	/*g:tex_verbspell*
 g:var	eval.txt	/*g:var*
 g:vimball_home	pi_vimball.txt	/*g:vimball_home*
@@ -6087,6 +6149,8 @@
 getcmdline()	eval.txt	/*getcmdline()*
 getcmdpos()	eval.txt	/*getcmdpos()*
 getcmdtype()	eval.txt	/*getcmdtype()*
+getcmdwintype()	eval.txt	/*getcmdwintype()*
+getcurpos()	eval.txt	/*getcurpos()*
 getcwd()	eval.txt	/*getcwd()*
 getfontname()	eval.txt	/*getfontname()*
 getfperm()	eval.txt	/*getfperm()*
@@ -6358,6 +6422,7 @@
 hl-WildMenu	syntax.txt	/*hl-WildMenu*
 hlID()	eval.txt	/*hlID()*
 hlexists()	eval.txt	/*hlexists()*
+hlsearch-variable	eval.txt	/*hlsearch-variable*
 holy-grail	index.txt	/*holy-grail*
 home	intro.txt	/*home*
 home-replace	editing.txt	/*home-replace*
@@ -6669,6 +6734,7 @@
 linewise-visual	visual.txt	/*linewise-visual*
 lisp.vim	syntax.txt	/*lisp.vim*
 lispindent()	eval.txt	/*lispindent()*
+list	eval.txt	/*list*
 list-functions	usr_41.txt	/*list-functions*
 list-identity	eval.txt	/*list-identity*
 list-index	eval.txt	/*list-index*
@@ -6780,6 +6846,7 @@
 match-highlight	pattern.txt	/*match-highlight*
 match-parens	tips.txt	/*match-parens*
 matchadd()	eval.txt	/*matchadd()*
+matchaddpos()	eval.txt	/*matchaddpos()*
 matcharg()	eval.txt	/*matcharg()*
 matchdelete()	eval.txt	/*matchdelete()*
 matchend()	eval.txt	/*matchend()*
@@ -6921,6 +6988,15 @@
 netrw	pi_netrw.txt	/*netrw*
 netrw-%	pi_netrw.txt	/*netrw-%*
 netrw--	pi_netrw.txt	/*netrw--*
+netrw-:Explore	pi_netrw.txt	/*netrw-:Explore*
+netrw-:Hexplore	pi_netrw.txt	/*netrw-:Hexplore*
+netrw-:Lexplore	pi_netrw.txt	/*netrw-:Lexplore*
+netrw-:MF	pi_netrw.txt	/*netrw-:MF*
+netrw-:MT	pi_netrw.txt	/*netrw-:MT*
+netrw-:Rexplore	pi_netrw.txt	/*netrw-:Rexplore*
+netrw-:Sexplore	pi_netrw.txt	/*netrw-:Sexplore*
+netrw-:Texplore	pi_netrw.txt	/*netrw-:Texplore*
+netrw-:Vexplore	pi_netrw.txt	/*netrw-:Vexplore*
 netrw-C	pi_netrw.txt	/*netrw-C*
 netrw-D	pi_netrw.txt	/*netrw-D*
 netrw-O	pi_netrw.txt	/*netrw-O*
@@ -6978,6 +7054,7 @@
 netrw-getftype	pi_netrw.txt	/*netrw-getftype*
 netrw-gf	pi_netrw.txt	/*netrw-gf*
 netrw-gh	pi_netrw.txt	/*netrw-gh*
+netrw-gitignore	pi_netrw.txt	/*netrw-gitignore*
 netrw-gp	pi_netrw.txt	/*netrw-gp*
 netrw-gx	pi_netrw.txt	/*netrw-gx*
 netrw-handler	pi_netrw.txt	/*netrw-handler*
@@ -6992,6 +7069,7 @@
 netrw-internal-variables	pi_netrw.txt	/*netrw-internal-variables*
 netrw-intro-browse	pi_netrw.txt	/*netrw-intro-browse*
 netrw-leftmouse	pi_netrw.txt	/*netrw-leftmouse*
+netrw-lexplore	pi_netrw.txt	/*netrw-lexplore*
 netrw-list	pi_netrw.txt	/*netrw-list*
 netrw-listbookmark	pi_netrw.txt	/*netrw-listbookmark*
 netrw-listhack	pi_netrw.txt	/*netrw-listhack*
@@ -7022,6 +7100,7 @@
 netrw-nexplore	pi_netrw.txt	/*netrw-nexplore*
 netrw-noload	pi_netrw.txt	/*netrw-noload*
 netrw-nread	pi_netrw.txt	/*netrw-nread*
+netrw-ntree	pi_netrw.txt	/*netrw-ntree*
 netrw-nwrite	pi_netrw.txt	/*netrw-nwrite*
 netrw-o	pi_netrw.txt	/*netrw-o*
 netrw-options	pi_netrw.txt	/*netrw-options*
@@ -7033,6 +7112,7 @@
 netrw-p13	pi_netrw.txt	/*netrw-p13*
 netrw-p14	pi_netrw.txt	/*netrw-p14*
 netrw-p15	pi_netrw.txt	/*netrw-p15*
+netrw-p16	pi_netrw.txt	/*netrw-p16*
 netrw-p2	pi_netrw.txt	/*netrw-p2*
 netrw-p3	pi_netrw.txt	/*netrw-p3*
 netrw-p4	pi_netrw.txt	/*netrw-p4*
@@ -7374,6 +7454,7 @@
 profiling	repeat.txt	/*profiling*
 profiling-variable	eval.txt	/*profiling-variable*
 progname-variable	eval.txt	/*progname-variable*
+progpath-variable	eval.txt	/*progpath-variable*
 progress.vim	syntax.txt	/*progress.vim*
 pronounce	intro.txt	/*pronounce*
 psql	ft_sql.txt	/*psql*
@@ -7577,6 +7658,7 @@
 s/\3	change.txt	/*s\/\\3*
 s/\9	change.txt	/*s\/\\9*
 s/\<CR>	change.txt	/*s\/\\<CR>*
+s/\=	change.txt	/*s\/\\=*
 s/\E	change.txt	/*s\/\\E*
 s/\L	change.txt	/*s\/\\L*
 s/\U	change.txt	/*s\/\\U*
@@ -7746,6 +7828,7 @@
 spell-FOL	spell.txt	/*spell-FOL*
 spell-FORBIDDENWORD	spell.txt	/*spell-FORBIDDENWORD*
 spell-HOME	spell.txt	/*spell-HOME*
+spell-IGNOREEXTRA	spell.txt	/*spell-IGNOREEXTRA*
 spell-KEEPCASE	spell.txt	/*spell-KEEPCASE*
 spell-KEY	spell.txt	/*spell-KEY*
 spell-LANG	spell.txt	/*spell-LANG*
@@ -7787,6 +7870,7 @@
 spell-affix-mbyte	spell.txt	/*spell-affix-mbyte*
 spell-affix-not-supported	spell.txt	/*spell-affix-not-supported*
 spell-affix-vim	spell.txt	/*spell-affix-vim*
+spell-cjk	spell.txt	/*spell-cjk*
 spell-compound	spell.txt	/*spell-compound*
 spell-dic-format	spell.txt	/*spell-dic-format*
 spell-double-scoring	spell.txt	/*spell-double-scoring*
@@ -7872,6 +7956,7 @@
 strdisplaywidth()	eval.txt	/*strdisplaywidth()*
 strftime()	eval.txt	/*strftime()*
 stridx()	eval.txt	/*stridx()*
+string	eval.txt	/*string*
 string()	eval.txt	/*string()*
 string-functions	usr_41.txt	/*string-functions*
 string-match	eval.txt	/*string-match*
@@ -7936,6 +8021,7 @@
 system()	eval.txt	/*system()*
 system-functions	usr_41.txt	/*system-functions*
 system-vimrc	starting.txt	/*system-vimrc*
+systemlist()	eval.txt	/*systemlist()*
 s~	change.txt	/*s~*
 t	motion.txt	/*t*
 t:	eval.txt	/*t:*
@@ -8220,6 +8306,7 @@
 tex-slow	syntax.txt	/*tex-slow*
 tex-stopzone	syntax.txt	/*tex-stopzone*
 tex-style	syntax.txt	/*tex-style*
+tex-supersub	syntax.txt	/*tex-supersub*
 tex-sync	syntax.txt	/*tex-sync*
 tex-verb	syntax.txt	/*tex-verb*
 tex.vim	syntax.txt	/*tex.vim*
@@ -8280,6 +8367,7 @@
 undofile()	eval.txt	/*undofile()*
 undotree()	eval.txt	/*undotree()*
 unicode	mbyte.txt	/*unicode*
+uniq()	eval.txt	/*uniq()*
 unix	os_unix.txt	/*unix*
 unlisted-buffer	windows.txt	/*unlisted-buffer*
 up-down-motions	motion.txt	/*up-down-motions*
@@ -8364,6 +8452,7 @@
 v:foldend	eval.txt	/*v:foldend*
 v:foldlevel	eval.txt	/*v:foldlevel*
 v:foldstart	eval.txt	/*v:foldstart*
+v:hlsearch	eval.txt	/*v:hlsearch*
 v:insertmode	eval.txt	/*v:insertmode*
 v:key	eval.txt	/*v:key*
 v:lang	eval.txt	/*v:lang*
@@ -8377,6 +8466,7 @@
 v:prevcount	eval.txt	/*v:prevcount*
 v:profiling	eval.txt	/*v:profiling*
 v:progname	eval.txt	/*v:progname*
+v:progpath	eval.txt	/*v:progpath*
 v:register	eval.txt	/*v:register*
 v:scrollstart	eval.txt	/*v:scrollstart*
 v:searchforward	eval.txt	/*v:searchforward*
@@ -8692,6 +8782,7 @@
 windowid-variable	eval.txt	/*windowid-variable*
 windows	windows.txt	/*windows*
 windows-3.1	os_win32.txt	/*windows-3.1*
+windows-icon	os_win32.txt	/*windows-icon*
 windows-intro	windows.txt	/*windows-intro*
 windows-starting	windows.txt	/*windows-starting*
 windows.txt	windows.txt	/*windows.txt*
diff -Naur vim74.orig/runtime/doc/tagsrch.txt vim74/runtime/doc/tagsrch.txt
--- vim74.orig/runtime/doc/tagsrch.txt	2013-08-10 11:25:02.000000000 +0000
+++ vim74/runtime/doc/tagsrch.txt	2014-10-10 14:53:40.415390423 +0000
@@ -1,4 +1,4 @@
-*tagsrch.txt*   For Vim version 7.4.  Last change: 2013 Jul 28
+*tagsrch.txt*   For Vim version 7.4.  Last change: 2013 Oct 01
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -771,11 +771,11 @@
 
 							*:dli* *:dlist*
 :[range]dli[st][!] [/]string[/]
-			Like "[D"  and "]D", but search in [range] lines
+			Like `[D`  and `]D`, but search in [range] lines
 			(default: whole file).
 			See |:search-args| for [/] and [!].  {not in Vi}
-			Note that ":dl" works like ":delete" with the "l"
-			register.
+			Note that `:dl` works like `:delete` with the "l"
+			flag, not `:dlist`.
 
 							*[_CTRL-D*
 [ CTRL-D		Jump to the first macro definition that contains the
diff -Naur vim74.orig/runtime/doc/term.txt vim74/runtime/doc/term.txt
--- vim74.orig/runtime/doc/term.txt	2013-08-10 11:25:02.000000000 +0000
+++ vim74/runtime/doc/term.txt	2014-10-10 14:53:40.418723748 +0000
@@ -1,4 +1,4 @@
-*term.txt*      For Vim version 7.4.  Last change: 2013 Mar 13
+*term.txt*      For Vim version 7.4.  Last change: 2014 May 13
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -666,8 +666,8 @@
 
 							*xterm-copy-paste*
 NOTE: In some (older) xterms, it's not possible to move the cursor past column
-95.  This is an xterm problem, not Vim's.  Get a newer xterm |color-xterm|.
-Now the limit is 223 columns.
+95 or 223.  This is an xterm problem, not Vim's.  Get a newer xterm
+|color-xterm|.  Also see |'ttymouse'|.
 
 Copy/paste in xterm with (current mode NOT included in 'mouse'):
 1. Press left mouse button on first letter of text, move mouse pointer to last
diff -Naur vim74.orig/runtime/doc/todo.txt vim74/runtime/doc/todo.txt
--- vim74.orig/runtime/doc/todo.txt	2013-08-10 11:25:02.000000000 +0000
+++ vim74/runtime/doc/todo.txt	2014-10-10 14:53:40.445390347 +0000
@@ -1,4 +1,4 @@
-*todo.txt*      For Vim version 7.4.  Last change: 2013 Aug 10
+*todo.txt*      For Vim version 7.4.  Last change: 2014 Oct 02
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -34,38 +34,319 @@
 							*known-bugs*
 -------------------- Known bugs and current work -----------------------
 
+Regexp problems:
+- Bug with pattern: '\vblock (\d+)\.\n.*\d+%(\1)@<!\.$'
+  (Lech Lorens, 2014 Feb 3)
+- Issue 164: freeze on regexp search.
+- Ignorecase not handled properly for multi-byte characters. (Axel Bender,
+  2013 Dec 11)
+- Using \@> and \?. (Brett Stahlman, 2013 Dec 21) Remark from Marcin Szamotulski
+  Remark from Brett 2014 Jan 6 and 7.
+- Bug when using \>. (Ramel, 2014 Feb 2) (Aaron Bohannon, 2014 Feb 13)
+- NFA regexp doesn't handle \%<v correctly. (Ingo Karkat, 2014 May 12)
+- Does not work with NFA regexp engine:
+  \%u, \%x, \%o, \%d followed by a composing character
+- Bug relating to back references. (Ingo Karkat, 2014 Jul 24)
+- Using back reference before the capturing group sometimes works with the old
+  engine, can we do this with the new engine?  E.g. with
+  "/\%(<\1>\)\@<=.*\%(<\/\(\w\+\)>\)\@=" matching text inside HTML tags.
+
+Still using freed memory after using setloclist(). (lcd, 2014 Jul 23)
+More info Jul 24.  Not clear why.
+
+Patch to make getregtype() return the right size for non-linux systems.
+(Yasuhiro Matsumoto, 2014 Jul 8)
+Breaks test_eval.  Inefficient, can we only compute y_width when needed?
+
+Patch to fix 'linebreak' when applying an operator.  And fix the test not
+actually testing. (Christian Brabandt, 2014 Sep 23)
+
+patch to fix issue 26. (Christian)
+
+Test 11 and 100 do not work properly on Windows.
+Patch by Ken Takata (2014 Sep 25)
+Alternative patch Oct 1.
+
+Problem that a previous silent ":throw" causes a following try/catch not to
+work. (ZyX, 2013 Sep 28)
+
+Patch to avoid problems with encoding conversion with diff.vim.
+(Yasuhiro Matsumoto, 2014 Sep 1.
+Depends on current language, language of file can be different.
+
+Add books from Steve Oualline to Vim website. (2014 Sep 25)
+
+":cd C:\Windows\System32\drivers\etc*" does not work, even though the
+directory exists. (Sergio Gallelli, 2013 Dec 29)
+
+Patch to have the fold and sign column and at the last line of the buffer.
+(Marco Hinz, 2014 Sep 25)
+Alternate suggestion: let all columns continue, also number column.
+
+Patch by Marcin Szamotulski to add count to :close (2014 Aug 10, update Aug
+14, Aug 30)
+    Make ":1close" close the first window.
+    Make ":+1close" close the next window.
+    Make ":-1close" close the previous window.
+Doesn't look right, asked for updates.
+
+Patch to handle multi-byte printer name on MS-Windows. (Yasuhiro Matsumoto,
+2014 Sept 28)
+
+Two patches by Christian, 2014 Sep 29:
+- Combination of precedes listchar and 'showbreak' doesn't work well.
+- Moving cursor is off when 'nu' and 'sbr' are set.
+
+The entries added by matchaddpos() are returned by getmatches() but can't be
+set with setmatches(). (lcd47, 2014 Jun 29)
+
+Patch to fix window title for a command window on MS-Windows. (Yasuhiro
+Matsumoto, 2014 Sep 28)
+
+Patch to fix that 0x80 in abbreviation isn't handled correctly.
+(Christian Brabandt, 2014 Oct 1)
+
+Patch to fix issue 57, on the issue.
+
+Patch for issue 101, maintainer unreachable.
+
+Remove restriction in NSIS installer that the end of the path must be "Vim".
+(Tim Lebedkov, 2014 Sep 24)
+
+Problem using ":try" inside ":execute". (ZyX, 2013 Sep 15)
+
 Python: ":py raw_input('prompt')" doesn't work. (Manu Hack)
 
-Patch to add "acl" and "xpm" as a feature. (Ken Takata, 2013 Jul 8)
+'foldexpr' applies to help. (Paul Marshall, 2014 Sep 24)
+
+Value returned by virtcol() changes depending on how lines wrap.  This is
+inconsistent with the documentation.
+
+On MS-Windows running tests with Mercurial has problems when the input files
+are changed. (Ken Takata, Taro Muraoka, 2014 Sep 25)
+
+MS-Windows: Crash opening very long file name starting with "\\".
+(Christian Brock, 2012 Jun 29)
+
+ml_updatechunk() is slow when retrying for another encoding. (John Little,
+2014 Sep 11)
+
+Make comments in the test Makefile silent. (Kartik Agaram, 2014 Sep 24)
+
+When in 'comments' "n:x" follows after three-part comment directly it repeats
+any one-character from the previous line. (Kartik Agaram, 2014 Sep 19)
+
+Syntax highlighting slow (hangs) in SASS file. (Niek Bosch, 2013 Aug 21)
+
+Adding "~" to 'cdpath' doesn't work for completion?  (Davido, 2013 Aug 19)
+
+Patch to make closed folds line up. (Charles Campbell, 2014 Sep 12)
+
+"hi link" does not respect groups with GUI settings only. (Mark Lodato, 2014
+Jun 8)
+
+No error for missing endwhile. (ZyX, 2014 Mar 20)
+
+start_global_changes() plus end_global_changes() causes problem for
+clip_unnamed_plus. (Jason Pleau, 2014 Sep 12)
+
+Patch to add :arglocal and :arglists. (Marcin Szamotulski, 2014 Aug 6)
+
+PHP syntax is extremely slow. (Anhad Jai Singh, 2014 Jan 19)
+
+Spell files use a latin single quote. Unicode also has another single quote:
+0x2019.  (Ron Aaron, 2014 Apr 4)
+New OpenOffice spell files support this with ICONV.  But they are not
+compatible with Vim spell files.  The old files can no longer be downloaded.
+
+Win32: patch to use 64 bit stat() if possible. (Ken Takata, 2014 May 12)
+More tests May 14. Update May 29.  Update Aug 10.
+
+The garbage collector may use too much stack.  Make set_ref_in_item()
+iterative instead of recursive.   Test program by Marc Weber (2013 Dec 10)
+Patch by Ben Fritz, 2014 Jun 22.
+Related: Vim hangs when freeing a lot of objects.  Patch by Yasuhiro
+Matsumoto, 2014 Aug 26.
+
+Idea: For a window in the middle (has window above and below it), use
+right-mouse-drag on the status line to move a window up/down without changing
+its height?  It's like dragging the status bar above it at the same time.
+
+Can we make ":unlet $VAR" use unsetenv() to delete the env var?
+What for systems that don't have unsetenv()?
+
+This does not give an error: (Andre Sihera, 2014 Mar 21)
+    vim -u NONE 1 2 3 -c 'bufdo if 1 | echo 1'
+This neither: (ZyX)
+    vim -u NONE 1 2 3 -c 'bufdo while 1 | echo 1'
+
+'viewdir' default on MS-Windows is not a good choice, it's a system directory.
+Change 'viewdir' to "$HOME/vimfiles/view" and use 'viewdiralt' to also read
+from?
+
+Problem with upwards search on Windows (works OK on Linux). (Brett Stahlman,
+2014 Jun 8)
+
+Patch to load TCL dynamically. (Ken Takata, 2014 Sep 20)
+
+Include a plugin manager with Vim? Neobundle seems to be the best currently.
+Long message about this from ZyX, 2014 Mar 23.  And following replies.
+Also see http://vim-wiki.mawercer.de/wiki/topic/vim%20plugin%20managment.html
+User view:
+- Support multiple sources, basically any http:// URL.  Be able to look into
+  the files before deciding to install.
+- Be able to try out a plugin and remove it again with (almost) no traces.
+- Each plugin needs a "manifest" file that has the version, dependencies
+  (including Vim version and features), conflicts, list of files, etc.
+  Updater uses that to decide what/how to update.
+  Dependencies can use a URL for specific versions, or short name for scripts
+  on vim.org.
+- Once a plugin is installed it remembers where it came from, updater checks
+  there.  Can manually update when really needed.
+- Must be possible to install for one user.  Also system wide?
+- Can edit plugin config with Vim. Can temporarily disable a plugin.
+- Run the update manually, find latest version and install.
+- Be able to download without special tools, must work for 95% of users.
+Implementation:
+- Avoid the 'runtimepath' getting long.  Need some other way to keep each
+  plugin separate.
+- When installing or updating, first figure out what needs to be done. This
+  may involve recursively fetching manifest files for dependencies.  Then show
+  the user what's going to change and ask for OK.
+- Scripts on Vim.org must be able to consist of several files.  Is zip format
+  sufficient?  Upload the manifest?  Or refer to a site that has the manifest?
+- Best is to fetch individual files or use a Vimball. Reduces dependency on
+  tools that might be missing and allows inspection of the files before
+  installing.
+Out of scope:
+- Overview of plugins, ratings, comments, etc.  That's another world.
+- Development work on plugins (although diff with distributed version would be
+  useful).
+
+Setting the spell file in a session only reads the local additions, not the
+normal spell file. (Enno Nagel, 2014 Mar 29)
+
+CTRL-] in Visual mode uses the selected text as a tag.  This does not work
+when preceded with CTRL-W. (Patrick Hemmer, 2014 Jun 28)
+
+When typing the first character of a command, e.g. "f", then using a menu, the
+menu item doesn't work.  Clear typeahead when using a menu?
+
+Editing an ascii file as ucs-2 or ucs-4 causes display errors.
+(ZyX, 2014 Mar 30)
+
+":Next 1 some-arg" does not complain about trailing argument.  Also for
+various other commands.  (ZyX, 2014 Mar 30)
+
+patch to skip sort if no line matches the expression.
+(Christian Brabandt, 2014 Jun 25)
+
+Patch to add sortuniq(). (Cade Forester, 2014 Mar 19)
+Or add uniq() instead?  Patch by lcd47, but it has problems.
+
+Patch to support sorting on floating point number.  (Alex Jakushev, 2010 Oct
+30)
+
+Patch to support expression argument to sort() instead of a function name.
+Yasuhiro Matsumoto, 2013 May 31.
+Or should we add a more general mechanism, like a lambda() function?
+Patch by Yasuhiro Matsumoto, 2014 Sep 16.
+
+VMS: Select() doesn't work properly, typing ESC may hang Vim.  Use sys$qiow
+instead. (Samuel Ferencik, 2013 Sep 28)
+
+Patch for XDG base directory support. (Jean Franois Bignolles, 2014 Mar 4)
+Remark on the docs.  Should not be a compile time feature.  But then what?
+
+Completion of ":e" is ":earlier", should be ":edit".  Complete to the matching
+command instead of doing this alphabetically. (Mikel Jorgensen)
+
+Patch to add v:completed_item. (Shougo Matsu, 2013 Nov 29).
+
+Patch to get MSVC version in a nicer way. (Ken Takata, 2014 Jul 24)
 
-Patch to make has() check for Vim version and patch at the same time.
-(Marc Weber, 2013 Jun 7)
+Patch to make test 100 work on MS-Windows. (Taro Muraoka, 2013 Dec 12)
+
+Patch to define macros for hardcoded values. (Elias Diem, 2013 Dec 14)
+
+Perl: support for Activestate perl 5.18: Issue 170.
 
 Several syntax file match "^\s*" which may get underlined if that's in the
 highlight group.  Add a "\zs" after it?
 
+Patch to fix temp directories for Windows, so that it works without tweaking.
+Issue 28.
+
 Go through more coverity reports.
 
-"gUgn" cannot be repeated, while "dgn" can.
+Patch to add ":undorecover", get as much text out of the undo file as
+possible. (Christian Brabandt, 2014 Mar 12, update Aug 22)
+
+Include Haiku port? (Adrien Destugues, Siarzhuk Zharski, 2013 Oct 24)
+
+Updated spec ftplugin. (Matj Cepl, 2013 Oct 16)
+
+Patch to right-align signs. (James Kolb (email james), 2013 Sep 23)
+
+Patch to handle integer overflow. (Aaron Burrow, 2013 Dec 12)
 
-Several Win32 functions are not using Unicode.
-Patches to fix this. (Ken Takata, 2013 Aug 9)
+With "$" in 'cpoptions' the popup menu isn't fully drawn. (Matti Niemenmaa,
+2013 Sep 5)
+
+Patch to add "ntab" item in 'listchars' to repeat first character. (Nathaniel
+Braun, pragm, 2013 Oct 13)  A better solution 2014 Mar 5.
+
+Undo message is not always properly displayed.  Patch by Ken Takata, 2013 oct
+3.  Doesn't work properly according to Yukihiro Nakadaira.
 
 /[b-a] gives error E16, should probably be E769.
 
-Discussion about canonicalization of Hebrew. (Ron Aaron, 2011 April 10)
+7   Windows XP: When using "ClearType" for text smoothing, a column of yellow
+    pixels remains when typing spaces in front of a "D" ('guifont' set to
+    "lucida_console:h8").
+Patch by Thomas Tuegel, also for GTK, 2013 Nov 24
+
+:help gives example for z?, but it does not work.  m? and t? do work.
 
-Patch to make external commands work with multi-byte characters on Win32 when
-'encoding' differs from the active codepage. (Yasuhiro Matsumoto, 2013 Aug 5)
+Python: Extended funcrefs: use func_T* structure in place of char_u* function
+names.
+(ZyX, 2013 Jul 15, update Sep 22, 24, 28; Update 2013 Dec 15, 2014 Jan 6)
+Also fixes Bug: E685 error for func_unref(). (ZyX, 2010 Aug 5)
+
+Patch to add funcref to Lua.  (Luis Carvalho, 2013 Sep 4)
+With tests: Sep 5.
+
+Patch to fix that on suckless Terminal mousewheel up does not work.
+(Ralph Eastwood, 2013 Nov 25)
+
+Discussion about canonicalization of Hebrew. (Ron Aaron, 2011 April 10)
 
 Checking runtime scripts: Thilo Six, 2012 Jun 6.
 
+When evaluating expression in backticks, autoload doesn't work.
+(Andy Wokula, 2013 Dec 14)
+
+Using <nr>ifoobar<esc> can slow down Vim.  Patch by Christian Brabandt, 2013
+Dec 13.
+
 Fold can't be opened after ":move". (Ein Brown)
 Patch from Christian Brabandt doesn't fix it completely.
 
+Patch from Christian Brabandt to preserve upper case marks when wiping out a
+buffer. (2013 Dec 9)
+
+Patch for drag&drop reordering of GUI tab pages reordering.
+(Ken Takata, 2013 Nov 22, second one, also by Masamichi Abe)
+
+":sign-jump" uses first window in buffer instead of current window.
+Patch by James McCoy, 2013 Nov 22.
+
 GTK: problem with 'L' in 'guioptions' changing the window width.
 (Aaron Cornelius, 2012 Feb 6)
 
+Patch to add option that tells whether small deletes go into the numbered
+registers. (Aryeh Leib Taurog, 2013 Nov 18)
+
 Javascript file where indent gets stuck on: GalaxyMaster, 2012 May 3.
 
 The BufUnload event is triggered when re-using the empty buffer.
@@ -76,6 +357,10 @@
 - The word that was selected (empty if abandoned complete)
 - Type of completion: tag, omnifunc, user func.
 
+Patch to allow more types in remote_expr(). (Lech Lorens, 2014 Jan 5)
+Doesn't work for string in list.  Other way to pass all types of variables
+reliably?
+
 Using ":call foo#d.f()" doesn't autoload the "foo.vim" file.
 That is, calling a dictionary function on an autoloaded dict.
 Works OK for echo, just not for  ":call" and ":call call()". (Ted, 2011 Mar
@@ -83,17 +368,19 @@
 Patch by Christian Brabandt, 2013 Mar 23.
 Not 100% sure this is the right solution.
 
-Win32: When a directory name contains an exclamation mark, completion doesn't
-complete the contents of the directory.  No escaping for the "!"? (Jan
-Stocker, 2012 Jan 5)
-
-Patch to support expression argument to sort() instead of a function name.
-Yasuhiro Matsumoto, 2013 May 31.
-Or should we add a more general mechanism, like lambda functions?
-
 Problem caused by patch 7.3.638: window->open does not update window
 correctly. Issue 91.
 
+Patch to add {lhs} to :mapclear: clear all maps starting with {lhs}.
+(Christian Brabandt, 2013 Dec 9)
+
+Exception caused by argument of return is not caught by try/catch.
+(David Barnett, 2013 Nov 19)
+
+8   'backupdir' and 'directory' should use $TMPDIR, $TMP and/or $TEMP when
+    defined.
+Issue 28.
+
 Patch to fix that 'cedit' is recognized after :normal. (Christian Brabandt,
 2013 Mar 19, later message)
 
@@ -108,6 +395,8 @@
 Bug with 'cursorline' in diff mode.  Line being scrolled into view gets
 highlighted as the cursor line.  (Alessandro Ivaldi, 2013 Jun 4)
 
+Two highlighting bugs. (ZyX, 2013 Aug 18)
+
 Patch to add the bufferlist() function. (Yegappan Lakshmanan, 2013 May 5)
 May 17: with winlist() and tabpagelist().
 May 19: with local variables.
@@ -119,10 +408,13 @@
 Patch from Christian Brabandt to make the "buffer" argument for ":sign place"
 optional. (2013 Jul 12)
 
+Dialog is too big on Linux too. (David Fishburn, 2013 Sep 2)
+
 Patch to allow setting w:quickfix_title via setqflist() and setloclist()
 functions. (Christian Brabandt, 2013 May 8, update May 21)
 Patch to add getlocstack() / setlocstack(). (Christian Brabandt, 2013 May 14)
 Second one. Update May 22.
+Update by Daniel Hahler, 2014 Jul 4, Aug 14.
 
 Patch to make fold updates much faster. (Christian Brabandt, 2012 Dec)
 
@@ -137,9 +429,6 @@
 
 Bug: findfile("any", "file:///tmp;") does not work.
 
-v:register is not directly reset to " after a delete command that specifies a
-register.  It is reset after the next command. (Steve Vermeulen, 2013 Mar 16)
-
 'ff' is wrong for one-line file without EOL. (Issue 77)
 
 Patch to set antialiasing style on Windows. (Ondrej Balaz, 2013 Mar 14)
@@ -149,11 +438,19 @@
 process that is running.  It might actually be some other program, e.g. after
 a reboot.
 
-MS-Windows: Crash opening very long file name starting with "\\".
-(Christian Brock, 2012 Jun 29)
+Patch to have text objects defined by arbitrary single characters. (Daniel
+Thau, 2013 Nov 20, 2014 Jan 29, 2014 Jan 31)
+Ben Fritz: problem with 'selection' set to "exclusive".
+Updated to current Vim, not quite right yet. (Ben Fritz, 2014 Mar 27)
+
+Patch to select the next or previous text object if there isn't one under the
+cursor. (Daniel Thau, 2013 Nov 20)
 
 patch to add "combine" flag to  syntax commands. (so8res, 2012 Dec 6)
 
+Bug caused by patch 7.3.1288?  Issue 183.
+I can't reproduce it.
+
 Syntax update problem in one buffer opened in two windows, bottom window is
 not correctly updated. (Paul Harris, 2012 Feb 27)
 
@@ -167,8 +464,10 @@
 
 Patch to add functions for signs. (Christian Brabandt, 2013 Jan 27)
 
-Patch to use directX to draw text on Windows.  Adds the 'renderoptions'
-option.  (Taro Muraoka, 2013 Jan 25, update 2013 Apr 3, May 14)
+Do we need some way (option) to show the sign column even when there are no
+signs?  Patch by Christian Brabandt, 2013 Aug 22.
+
+Patch to remove flicker from popup menu. (Yasuhiro Matsumoto, 2013 Aug 15)
 
 Patch to add 'completeselect' option.  Specifies how to select a candidate in
 insert completion. (Shougo, 2013 May 29)
@@ -182,9 +481,6 @@
 Win32: The Python interface only works with one version of Python, selected at
 compile time.  Can this be made to work with version 2.1 and 2.2 dynamically?
 
-Python: Extended funcrefs: use func_T* structure in place of char_u* function
-names. (ZyX, 2013 Jul 15 and later)
-
 Python: Be able to define a Python function that can be called directly from
 Vim script.  Requires converting the arguments and return value, like with
 vim.bindeval().
@@ -205,9 +501,6 @@
 Add a check for b:no_match_paren in Highlight_matching_Pair() (Marcin
 Szamotulski, 2012 Nov 8)
 
-Crash in autocmd that unloads buffers in a BufUnload event. (Andrew Pimlott,
-2012 Aug 11)  Disallow :new when BufUnload is being handled?
-
 Issue 72: 'autochdir' causes problems for :vimgrep.
 
 Session file creation: 'autochdir' causes trouble.  Keep it off until after
@@ -240,10 +533,6 @@
 Help for 'b:undo_indent'. (Thilo Six, 2012 May 28)
 Also question if examples are correct.
 
-It should be possible to make globpath() return a list instead of a string,
-like with glob(). (Greg Novack, 2012 Nov 2)
-Patch by Adnan Zafar, 2013 Jul 15.
-
 The input map for CTRL-O in mswin.vim causes problems after CTRL-X CTRL-O.
 Suggestion for another map. (Philip Mat, 2012 Jun 18)
 But use "gi" instead of "a".  Or use CTRL-\ CTRL-O.
@@ -251,13 +540,12 @@
 Patch to support user name completion on MS-Windows. (Yasuhiro Matsumoto, 2012
 Aug 16)
 
-Have an option for spell checking to not mark any Chinese, Japanese or other
-double-width characters as error.  Or perhaps all characters above 256.
-(Bill Sun)  Helps a lot for mixed Asian and latin text.
-
 When there are no command line arguments ":next" and ":argu" give E163, which
 is confusing.  Should say "the argument list is empty".
 
+xterm supports escape sequences to mark a paste operation.  Need to be
+enabled. (Bruno Sutic, 2014 Jul 11)  How to know the terminal supports this?
+
 URXVT:
 - will get stuck if byte sequence does not contain the expected semicolon.
 - Use urxvt mouse support also in xterm.  Explanations:
@@ -272,27 +560,23 @@
 
 Patch to list user digraphs. (Christian Brabandt, 2012 Apr 14)
 
+Patch to add digraph() function. (Christian Brabandt, 2013 Aug 22, update Aug
+24)
+
 Patch for input method status. (Hirohito Higashi, 2012 Apr 18)
 
+Update Vim app icon (for Gnome). (Jakub Steiner, 2013 Dec 6)
+
 Patch to use .png icons for the toolbar on MS-Windows. (Martin Gieseking, 2013
 Apr 18)
 
 Patch for has('unnamedplus') docs. (Tony Mechelynck, 2011 Sep 27)
 And one for gui_x11.txt.
 
--   Patch for 'breakindent' option: repeat indent for wrapped line. (Vaclav
-    Smilauer, 2004 Sep 13, fix Oct 31, update 2007 May 30)
-    Version for latest MacVim: Tobia Conforto, 2009 Nov 23
-    More recent version: https://retracile.net/wiki/VimBreakIndent
-    Posted to vim-dev by Taylor Hedberg, 2011 Nov 25
-    Update by Taylor Hedberg, 2013 May 30.
-
 ":cd" doesn't work when current directory path contains "**".
 finddir() has the same problem.  (Yukihiro Nakadaira, 2012 Jan 10)
 Requires a rewrite of the file_file_in_path code.
 
-Problem with l: dictionary being locked in a function. (ZyX, 2011 Jul 21)
-
 Should use has("browsefilter") in ftplugins.  Requires patch 7.3.593.
 
 Update for vim2html.pl. (Tyru, 2013 Feb 22)
@@ -374,8 +658,6 @@
 Setting $HOME on MS-Windows is not very well documented.  Suggestion by Ben
 Fritz (2011 Oct 27).
 
-Bug: E685 error for func_unref(). (ZyX, 2010 Aug 5)
-
 Bug: Windows 7 64 bit system freezes  when 'clipboard' set to "unnamed" and
 doing ":g/test/d".  Putting every delete on the clipboard? (Robert Chan, 2011
 Jun 17)
@@ -396,10 +678,11 @@
 Changes to manpage plugin. (Elias Toivanen, 2011 Jul 25)
 
 Patch to make "z=" work when 'spell' is off.  Does this have nasty side
-effects?  (Christian Brabandt, 2012 Aug 5)
+effects?  (Christian Brabandt, 2012 Aug 5, Update 2013 Aug 12)
 Would also need to do this for spellbadword() and spellsuggest().
 
-Patch for variable tabstops.
+Patch for variable tabstops.  On github (Christian Brabandt, 2014 May 15)
+Update Aug 16 (email).
 
 On 64 bit MS-Windows "long" is only 32 bits, but we sometimes need to store a
 64 bits value.  Change all number options to use nropt_T and define it to the
@@ -419,6 +702,8 @@
 When setqflist() uses a filename that triggers a BufReadCmd autocommand Vim
 doesn't jump to the correct line with :cfirst. (ZyX,  2011 Sep 18)
 
+Behavior of i" and a" text objects isn't logical. (Ben Fritz, 2013 Nov 19)
+
 7   Make "ga" show the digraph for a character, if it exists.
 Patch from Christian Brabandt, 2011 Aug 19.
 
@@ -439,9 +724,6 @@
 
 "0g@$" puts '] on last byte of multi-byte. (ZyX, 2011 Jan 22)
 
-Patch to support sorting on floating point number.  (Alex Jakushev, 2010 Oct
-30)
-
 Patch to addd TextDeletePost and TextYankPost events. (Philippe Vaucher, 2011
 May 24)  Update May 26.
 
@@ -456,6 +738,9 @@
 number, but it is in the sign column.  Doesn't look right. (ZyX 2011 Jun 5)
 Patch by Christian Brabandt, 2011 Jun 5.  Introduces new problems.
 
+Add jump() function. (Marcin Szamotulski, 2013 Aug 29)
+Is this needed?  CTRL-O and CTRL-I do the same, just more difficult to use.
+
 8   Add a command to jump to the next character highlighted with "Error".
 Patch by Christian Brabandt, uses ]e [e ]t and [t. 2011 Aug 9.
 
@@ -524,9 +809,6 @@
 Patch to add FoldedLineNr highlighting: different highlighting for the line
 number of a closed fold. (eXerigumo Clanjor, 2013 Jul 15)
 
-Does not work with NFA regexp engine:
-- \%u, \%x, \%o, \%d followed by a composing character
-
 Regexp engine performance:
 - Profiling:
 	./vim -u NONE -s ~/vim/test/ruby.vim
@@ -556,7 +838,7 @@
 the system encoding (usually utf-8).
 
 Patch to add GUI colors to the terminal, when it supports it. (ZyX, 2013 Jan
-26)
+26, update 2013 Dec 14)
 
 Problem producing tags file when hebrew.frx is present.  It has a BOM.
 Results in E670. (Tony Mechelynck, 2010 May 2)
@@ -571,11 +853,6 @@
     file names unique, also support this for 'backupdir'. (Mikolaj Machowski)
     Patch by Christian Brabandt, 2010 Oct 21.
 
-getpos()/setpos() don't include curswant.  getpos() could return a fifth
-element.  setpos() could accept an optional fifth element.
-Patch by Christian Brabandt, 2010 Sep 6.  Check that new argument is optional
-and that it's documented.
-
 With "tw=55 fo+=a" typing space before ) doesn't work well. (Scott Mcdermott,
 2010 Oct 24)
 
@@ -595,9 +872,6 @@
 checked to be in a comment.  Implement FM_SKIPCOMM flag of findmatchlimit().
 Issue 46.
 
-When 'paste' is changed with 'pastetoggle', the ruler doesn't reflect this
-right away. (Samuel Ferencik, 2010 Dec 7)
-
 Mac with X11: clipboard doesn't work properly. (Raf, 2010 Aug 16)
 
 Using CompilerSet doesn't record where an option was set from.  E.g., in the
@@ -620,8 +894,6 @@
 When 'lines' is 25 and 'scrolloff' is 12, "j" scrolls zero or two lines
 instead of one. (Constantin Pan, 2010 Sep 10)
 
-Crash in setqflist(). (Benoit Mortgat, 2010 Nov 18)
-
 Gui menu edit/paste in block mode insert only inserts in one line (Bjorn
 Winckler, 2011 May 11)
 Requires a map mode for Insert mode started from blockwise Visual mode.
@@ -629,10 +901,6 @@
 Writing nested List and Dict in viminfo gives error message and can't be read
 back. (Yukihiro Nakadaira, 2010 Nov 13)
 
-Can 'undolevels' be a buffer-local option?  Helps for making big changes in
-one file only, set 'ul' to -1 only for that buffer.
-Patch by Christian Brabandt, 2010 Dec 17.  Needs test.
-
 Problem with cursor in the wrong column. (SungHyun Nam, 2010 Mar 11)
 Additional info by Dominique Pelle. (also on 2010 Apr 10)
 
@@ -759,6 +1027,7 @@
 
 Patch to add farsi handling to arabic.c (Ali Gholami Rudi, 2009 May 2)
 Added test, updates, June 23.
+Updated for 7.4: http://litcave.rudi.ir/farsi_vim.diff
 
 Patch to add "focusonly" to 'scrollopt', so that scrollbind also applies in
 window that doesn't have focus. (Jonathon Mah, 2009 Jan 12)
@@ -838,8 +1107,6 @@
 Win32 GUI: last message from startup doesn't show up when there is an echoerr
 command. (Cyril Slobin, 2009 Mar 13)
 
-Win32: use different args for SearchPath()? (Yasuhiro Matsumoto, 2009 Jan 30)
-
 Win32: completion of file name ":e c:\!test" results in ":e c:\\!test", which
 does not work. (Nieko Maatjes, 2009 Jan 8, Ingo Karkat, 2009 Jan 22)
 
@@ -856,7 +1123,12 @@
 Using ~ works OK on 'a' with composing char, but not on 0x0418  with composing
 char 0x0301. (Tony Mechelynck, 2009 Mar 4)
 
-A function on a dictionary is not profiled. (Zyx, 2010 Dec 25)
+Searching for composing char works, but not when inside []. (ZyX, Benjamin R.
+Haskell, 2010 Aug 24)
+
+This does not work yet: "a\(%C\)" (get composing characters into a submatch).
+
+A function on a dictionary is not profiled. (ZyX, 2010 Dec 25)
 
 Inconsistent: starting with $LANG set to es_ES.utf-8 gives Spanish
 messages, even though locale is not supported.  But ":lang messages
@@ -885,7 +1157,7 @@
 Completion for ":buf" doesn't work properly on Win32 when 'shellslash' is off.
 (Henrik Ohman, 2009, Jan 29)
 
-shellescape() depends on 'shellshash' for quoting.  That doesn't work when
+shellescape() depends on 'shellslash' for quoting.  That doesn't work when
 'shellslash' is set but using cmd.exe. (Ben Fritz)
 Use a different option or let it depend on whether 'shell' looks like a
 unix-like shell?
@@ -918,8 +1190,6 @@
 Add v:motion_force. (Kana Natsuno, 2008 Dec 6)
 Maybe call it v:motiontype.
 
-Runtime files for Clojure. (Toralf Wittner, 2008 Jun 25)
-
 MS-Windows: editing the first, empty buffer, 'ffs' set to "unix,dos", ":enew"
 doesn't set 'ff' to "unix".  (Ben Fritz, 2008 Dec 5) Reusing the old buffer
 probably causes this.
@@ -928,7 +1198,7 @@
 2009 Jan 16)
 
 Patch to support strikethrough next to bold and italic. (Christian Brabandt,
-2013 Jul 30)
+2013 Jul 30)  Update from Ken Takata, 2013 Oct 12.
 
 Document that default font in Athena can be set with resources:
    XtDefaultFont: "9x15"
@@ -942,6 +1212,7 @@
 
 ":pedit %" with a BufReadPre autocommand causes the cursor to move to the
 first line. (Ingo Karkat, 2008 Jul 1)  Ian Kelling is working on this.
+Similar problem with ":e". (Marc Montu, 2014 Apr 22)
 
 Wildmenu not deleted: "gvim -u NONE", ":set nocp wildmenu cmdheight=3
 laststatus=2", CTRL-D CTRL-H CTRL-H CTRL-H. (A.Politz, 2008 April 1)
@@ -1085,9 +1356,6 @@
 result in no matches.  Convert chars to lower case? (Erik Wognsen, 2009 Apr
 16)
 
-Searching for composing char works, but not when inside []. (ZyX, Benjamin R.
-Haskell, 2010 Aug 24)
-
 Fail to edit file after failed register access.  Error flag remains set?
 (Lech Lorens, 2010 Aug 30)
 
@@ -1122,10 +1390,6 @@
 C syntax: {} inside () causes following {} to be highlighted as error.
 (Michalis Giannakidis, 2006 Jun 1)
 
-Can't easily close the help window, like ":pc" closes the preview window and
-":ccl" closes the quickfix window.  Add ":hclose". (Chris Gaal)
-Patch for :helpclose, Christian Brabandt, 2010 Sep 6.
-
 When 'diffopt' has "context:0" a single deleted line causes two folds to merge
 and mess up syncing. (Austin Jennings, 2008 Jan 31)
 
@@ -1199,8 +1463,8 @@
 Additional info: When using the |wildcards| ** globing, vim hangs
 indefinitely on lots of directories. The |file-searching| globing, like in
 ":set path=/**" does not hang as often as with globing with |wildcards|, like
-in ":1find /**/file".  This is for a files that unix "find" can find very
-quick. Merging the 2 kinds of globing might make this an easier fix. (Ian
+in ":1find /**/file".  This is for files that unix "find" can find very
+quickly. Merging the 2 kinds of globing might make this an easier fix. (Ian
 Kelling, 2008 July 4)
 
 When the file name has parenthesis, e.g., "foo (bar).txt", ":!ls '%'" has the
@@ -1289,6 +1553,7 @@
 
 Win64: Seek error in swap file for a very big file (3 Gbyte).  Check storing
 pointer in long and seek offset in 64 bit var.
+Patches from Ken Takata might help (2014 Apr 17)
 
 Win32: patch for fullscreen mode. (Liushaolin, 2008 April 17)
 
@@ -1296,14 +1561,17 @@
 Depends on 'shellslash', 'shellquote' and 'shellxquote', but shellescape()
 only takes 'shellslash' into account.
 
-Pressing the 'pastetoggle' key doesn't update the statusline. (Jan Christoph
-Ebersbach, 2008 Feb 1)
-
 Menu item that does "xxd -r" doesn't work when 'fileencoding' is utf-16.
 Check for this and use iconv?  (Edward L. Fox, 2007 Sep 12)
-Does the conversion in the other direction work when 'filenecodings' is set
+Does the conversion in the other direction work when 'fileencodings' is set
 properly?
 
+Add a few features to xxd. (Vadim Vygonets, 2013 Nov 11)
+Patches: 2013 Nov 19
+1: Add -e: little endian hexdump
+2: Add -o: add offset to displayed position
+3: Change displayed file position width to 8 chars
+
 Cursor displayed in the wrong position when using 'numberwidth'. (James Vega,
 2007 Jun 21)
 
@@ -1459,6 +1727,9 @@
 tree stops unexpectedly when using ":cd " and entering a directory that
 doesn't contain other directories.
 
+Default for 'background' is wrong when using xterm with 256 colors.
+Table with estimates from Matteo Cavalleri, 2014 Jan 10.
+
 Setting 'background' resets the Normal background color:
    highlight Normal ctermbg=DarkGray
    set background=dark
@@ -1647,6 +1918,10 @@
 Patch to support horizontal scroll wheel in GTK. Untested. (Bjorn Winckler,
 2010 Jun 30)
 
+Add an option for a minimal text length before inserting a line break for
+'textwidth'.  Avoids very short lines when a very long word follows.
+(Kartik Agaram)
+
 
 At next release:
 -   Build a huge version by default.
@@ -1685,7 +1960,7 @@
 -   testdir/Make_dos_sh.mak for running tests with MingW. (Bill Mccarthy, 2008
     Sep 13)
 -   Patch for adding "space" item in 'listchars'. (Jrmie Roquet, 2009 Oct 29,
-    Docs patch Oct 30)
+    Docs patch Oct 30, update David Burgin (glts) 2013 Aug 24)
 -   Replace ccomplete.vim by cppcomplete.vim from www.vim.org?  script 1520 by
     Vissale Neang.  (Martin Stubenschrott) Asked Vissale to make the scripts
     more friendly for the Vim distribution.
@@ -1715,7 +1990,7 @@
     How does this work?  Missing comments.
 8   Add a few more command names to the menus.  Patch from Jiri Brezina
     (28 feb 2002).  Will mess the translations...
-7   ATTENTION dialog choices are more logical when "Delete it' appears
+7   ATTENTION dialog choices are more logical when "Delete it" appears
     before "Quit".  Patch by Robert Webb, 2004 May 3.
 -   Include flipcase patch: ~/vim/patches/wall.flipcase2 ?  Make it work
     for multi-byte characters.
@@ -1864,8 +2139,6 @@
 Win32 GUI known bugs:
 -   Win32: tearoff menu window should have a scrollbar when it's taller than
     the screen.
-8   non-ASCII font names don't work.  Need to convert from 'encoding' and use
-    the wide functions.
 8   On Windows 98 the unicows library is needed to support functions with UCS2
     file names.  Can we load unicows.dll dynamically?
 8   The -P argument doesn't work very well with many MDI applications.
@@ -1873,9 +2146,6 @@
     Tutorial: http://win32assembly.online.fr/tut32.html
 8   In eval.c, io.h is included when MSWIN32 is defined.  Shouldn't this be
     WIN32?  Or can including io.h be moved to vim.h? (Dan Sharp)
-7   Windows XP: When using "ClearType" for text smoothing, a column of yellow
-    pixels remains when typing spaces in front of a "D" ('guifont' set to
-    "lucida_console:h8").
 6   Win32 GUI: With "-u NONE -U NONE" and doing "CTRL-W v" "CTRL-W o", the ":"
     of ":only" is highlighted like the cursor.  (Lipelis)
 8   When 'encoding' is "utf-8", should use 'guifont' for both normal and wide
@@ -1887,9 +2157,6 @@
 8   Use another default for 'termencoding': the active codepage.  Means that
     when 'encoding' is changed typing characters still works properly.
     Alternative: use the Unicode functions to obtain typed characters.
-8   Win32: Multi-byte characters are not displayed, even though the same font
-    in Notepad can display them. (Srinath Avadhanula)  Try with the
-    UTF-8-demo.txt page with Andale Mono.
 7   The cursor color indicating IME mode doesn't work properly. (Shizhu Pan,
     2004 May 9)
 8   Win32: When clicking on the gvim title bar, which gives it focus, produces
@@ -2272,8 +2539,6 @@
     character. (Yasuhiro Matsumoto)  It should return 1 when used on a tail
     byte, like for utf-8.  Store second byte of double-byte in ScreenLines2[]
     (like for DBCS_JPNU) and put a zero in the second byte (like for UTF-8).
-8   'backupdir' and 'directory' should use $TMPDIR, $TMP and/or $TEMP when
-    defined.
 7   Inside a function with "perl <<EOF" a line with "$i++" is recognized as an
     ":insert" command, causing the following "endfunction" not to be found.
     Add skipping this perl construction inside function definitions.
@@ -2566,8 +2831,6 @@
     input method called from GDK code.  Without Perl it doesn't crash.
 -   VMS: Vimdiff doesn't work with the VMS diff, because the output looks
     different.  This makes test 47 fail.  Install a Unix-compatible diff.
--   VMS v7.1 and older: Tests 21 and 32 fail.  From VMS v7.1-2 and newer Vim
-    does not have this behavior. (Zoltan Arpadffy)
 -   Win32 GUI: mouse wheel always scrolls rightmost window.  The events arrive
     in Vim as if the rightmost scrollbar was used.
 -   GTK with Gnome: Produces an error message when starting up:
@@ -2736,10 +2999,6 @@
 
 
 Spell checking:
--   have some way not to give spelling errors for a range of characters.
-    E.g. for Chinese and other languages with specific characters for which we
-    don't have a spell file.  Useful when there is also text in other
-    languages in the file.
 -   Support more regions? Caolan McNamara argues it's needed for es_XX.
     https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=219777    
 -   Unicode defines another quote character: 0x2019.  Use it as an equivalent
@@ -2830,6 +3089,8 @@
 
 
 Diff mode:
+9   When making small changes, e.g. deleting a character, update the diff.
+    Possibly without running diff.
 9   Instead invoking an external diff program, use builtin code.  One can be
     found here: http://www.ioplex.com/~miallen/libmba/dl/src/diff.c
     It's quite big and badly documented though.
@@ -2925,12 +3186,8 @@
 8   toupper() function doesn't handle byte count changes.
 7   Searching and composing characters:
     When searching, should order of composing characters be ignored?
-    Add special item to match with a composing character, zero-width, so that
-    one can replace a base character and keep the composing characters.
     Add a special item to match with a composing character, so that composing
     characters can be manipulated.
-    Add a modifier to ignore composing characters, only compare base
-    characters.  Useful for Hebrew (Ron Aaron)
 8   Should implement 'delcombine' for command line editing.
 8   Detect overlong UTF-8 sequences and handle them like illegal bytes.
 8   ":s/x/\u\1/" doesn't work, making uppercase isn't done for multi-byte
@@ -3153,6 +3410,7 @@
 Built-in script language:
 8   Make the filename and line number available to script functions, so that
     they can give useful debugging info.  The whole call stack would be ideal.
+    At least use this for error messages.
 7   Execute a function with standard option values.  No need to save and
     restore option values.  Especially useful for new options.  Problem: how
     to avoid a performance penalty (esp. for string options)?
@@ -3727,7 +3985,6 @@
 		      when exiting isn't a good idea.
     CursorHoldC     - CursorHold while command-line editing
     WinMoved	    - when windows have been moved around, e.g, ":wincmd J"
-    CmdUndefined    - Like FuncUndefined but for user commands.
     SearchPost	    - After doing a search command (e.g. to do "M")
     PreDirChanged/PostDirChanged
 		    - Before/after ":cd" has been used (for changing the
@@ -4035,8 +4292,7 @@
 7   Use Tabs for the indent of starting lines, pad with spaces for
     continuation lines.  Allows changing 'tabstop' without messing up the
     indents.
-    'keeptabs': when set don't change the tabs and spaces used for indent,
-    when the indent remains the same or increases.
+    Patch by Lech Lorens, 2010 Mar.  Update by James McCoy, 2014 Mar 15.
 
 
 Java:
@@ -4655,7 +4911,7 @@
 
 Digraphs:
 7   Make "ga" show the keymap for a character, if it exists.
-    Also show the code of the character after conversion to 'filenecoding'.
+    Also show the code of the character after conversion to 'fileencoding'.
 -   Use digraph table to tell Vim about the collating sequence of special
     characters?
 8   Add command to remove one or more (all) digraphs. (Brown)
@@ -4852,6 +5108,7 @@
 6   Add ":timer" command, to set a command to be executed at a certain
     interval, or once after some time has elapsed. (Aaron)
     Perhaps an autocommand event like CursorHold is better?
+    Patch to add async functionality. (Geoff Greer, 2013 Sep 1 and later)
 8   Add ":confirm" handling in open_exfile(), for when file already exists.
 8   When quitting with changed files, make the dialog list the changed file
     and allow "write all", "discard all", "write some".  The last one would
diff -Naur vim74.orig/runtime/doc/undo.txt vim74/runtime/doc/undo.txt
--- vim74.orig/runtime/doc/undo.txt	2013-08-10 11:25:02.000000000 +0000
+++ vim74/runtime/doc/undo.txt	2014-10-10 14:53:40.452056997 +0000
@@ -1,4 +1,4 @@
-*undo.txt*      For Vim version 7.4.  Last change: 2012 Mar 04
+*undo.txt*      For Vim version 7.4.  Last change: 2014 May 24
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -57,7 +57,7 @@
 2. Two ways of undo					*undo-two-ways*
 
 How undo and redo commands work depends on the 'u' flag in 'cpoptions'.
-There is the Vim way ('u' excluded) and the vi-compatible way ('u' included).
+There is the Vim way ('u' excluded) and the Vi-compatible way ('u' included).
 In the Vim way, "uu" undoes two changes.  In the Vi-compatible way, "uu" does
 nothing (undoes an undo).
 
@@ -97,9 +97,9 @@
 			or redo.
 			{not in Vi}
 
-This is most useful when you need to prompt the user halfway a change.  For
-example in a function that calls |getchar()|.  Do make sure that there was a
-related change before this that you must join with.
+This is most useful when you need to prompt the user halfway through a change.
+For example in a function that calls |getchar()|.  Do make sure that there was
+a related change before this that you must join with.
 
 This doesn't work by itself, because the next key press will start a new
 change again.  But you can do something like this: >
@@ -249,8 +249,9 @@
 detect if an undo file is no longer synchronized with the file it was written
 for (with a hash of the file contents) and ignore it when the file was changed
 after the undo file was written, to prevent corruption.  An undo file is also
-ignored if its owner differs from the owner of the edited file.  Set 'verbose'
-to get a message about that when opening a file.
+ignored if its owner differs from the owner of the edited file, except when
+the owner of the undo file is the current user.  Set 'verbose' to get a
+message about that when opening a file.
 
 Undo files are normally saved in the same directory as the file.  This can be
 changed with the 'undodir' option.
diff -Naur vim74.orig/runtime/doc/usr_04.txt vim74/runtime/doc/usr_04.txt
--- vim74.orig/runtime/doc/usr_04.txt	2013-08-10 11:25:03.000000000 +0000
+++ vim74/runtime/doc/usr_04.txt	2014-10-10 14:53:40.462056972 +0000
@@ -1,4 +1,4 @@
-*usr_04.txt*	For Vim version 7.4.  Last change: 2008 Sep 06
+*usr_04.txt*	For Vim version 7.4.  Last change: 2014 Aug 29
 
 		     VIM USER MANUAL - by Bram Moolenaar
 
@@ -186,7 +186,7 @@
 	/four<Enter>	find the first string "four"
 	cwfive<Esc>	change the word to "five"
 	n		find the next "four"
-	.		repeat the change to "five'
+	.		repeat the change to "five"
 	n		find the next "four"
 	.		repeat the change
 			etc.
diff -Naur vim74.orig/runtime/doc/usr_08.txt vim74/runtime/doc/usr_08.txt
--- vim74.orig/runtime/doc/usr_08.txt	2013-08-10 11:25:03.000000000 +0000
+++ vim74/runtime/doc/usr_08.txt	2014-10-10 14:53:40.472056947 +0000
@@ -1,4 +1,4 @@
-*usr_08.txt*	For Vim version 7.4.  Last change: 2006 Jul 18
+*usr_08.txt*	For Vim version 7.4.  Last change: 2014 Jul 06
 
 		     VIM USER MANUAL - by Bram Moolenaar
 
@@ -532,7 +532,7 @@
 
 You now have two tab pages.  The first one has a window for "thisfile" and the
 second one a window for "thatfile".  It's like two pages that are on top of
-eachother, with a tab sticking out of each page showing the file name.
+each other, with a tab sticking out of each page showing the file name.
 
 Now use the mouse to click on "thisfile" in the top line.  The result is
 
diff -Naur vim74.orig/runtime/doc/usr_25.txt vim74/runtime/doc/usr_25.txt
--- vim74.orig/runtime/doc/usr_25.txt	2013-08-10 11:25:05.000000000 +0000
+++ vim74/runtime/doc/usr_25.txt	2014-10-10 14:53:40.492056897 +0000
@@ -86,7 +86,7 @@
 
 	v4jgq
 
-"v" to start Visual mode, "4j' to move to the end of the paragraph and then
+"v" to start Visual mode, "4j" to move to the end of the paragraph and then
 the "gq" operator.  The result is:
 
 		 1	   2	     3
diff -Naur vim74.orig/runtime/doc/usr_30.txt vim74/runtime/doc/usr_30.txt
--- vim74.orig/runtime/doc/usr_30.txt	2013-08-10 11:25:05.000000000 +0000
+++ vim74/runtime/doc/usr_30.txt	2014-10-10 14:53:40.502056871 +0000
@@ -128,7 +128,7 @@
 You can include special Vim keywords in the command specification.  The %
 character expands to the name of the current file.  So if you execute the
 command: >
-	:set makeprg=make\ %
+	:set makeprg=make\ %:S
 
 When you are editing main.c, then ":make" executes the following command: >
 
@@ -137,7 +137,7 @@
 This is not too useful, so you will refine the command a little and use the :r
 (root) modifier: >
 
-	:set makeprg=make\ %:r.o
+	:set makeprg=make\ %:r:S.o
 
 Now the command executed is as follows: >
 
diff -Naur vim74.orig/runtime/doc/usr_40.txt vim74/runtime/doc/usr_40.txt
--- vim74.orig/runtime/doc/usr_40.txt	2013-08-10 11:25:05.000000000 +0000
+++ vim74/runtime/doc/usr_40.txt	2014-10-10 14:53:40.508723521 +0000
@@ -209,7 +209,7 @@
 separates the two commands.  This also means that a | character can't be used
 inside a map command.  To include one, use <Bar> (five characters).  Example:
 >
-	:map <F8> :write <Bar> !checkin %<CR>
+	:map <F8> :write <Bar> !checkin %:S<CR>
 
 The same problem applies to the ":unmap" command, with the addition that you
 have to watch out for trailing white space.  These two commands are different:
diff -Naur vim74.orig/runtime/doc/usr_41.txt vim74/runtime/doc/usr_41.txt
--- vim74.orig/runtime/doc/usr_41.txt	2013-08-10 11:25:05.000000000 +0000
+++ vim74/runtime/doc/usr_41.txt	2014-10-10 14:53:40.512056846 +0000
@@ -1,4 +1,4 @@
-*usr_41.txt*	For Vim version 7.4.  Last change: 2013 Feb 20
+*usr_41.txt*	For Vim version 7.4.  Last change: 2014 Aug 16
 
 		     VIM USER MANUAL - by Bram Moolenaar
 
@@ -595,13 +595,17 @@
 	matchlist()		like matchstr() and also return submatches
 	stridx()		first index of a short string in a long string
 	strridx()		last index of a short string in a long string
-	strlen()		length of a string
+	strlen()		length of a string in bytes
+	strchars()		length of a string in characters
+	strwidth()		size of string when displayed
+	strdisplaywidth()	size of string when displayed, deals with tabs
 	substitute()		substitute a pattern match with a string
 	submatch()		get a specific match in ":s" and substitute()
 	strpart()		get part of a string
 	expand()		expand special keywords
 	iconv()			convert text from one encoding to another
 	byteidx()		byte index of a character in a string
+	byteidxcomp()		like byteidx() but count composing characters
 	repeat()		repeat a string multiple times
 	eval()			evaluate a string expression
 
@@ -619,6 +623,7 @@
 	map()			change each List item
 	sort()			sort a List
 	reverse()		reverse the order of a List
+	uniq()			remove copies of repeated adjacent items
 	split()			split a String into a List
 	join()			join List items into a String
 	range()			return a List with a sequence of numbers
@@ -656,6 +661,9 @@
 	ceil()			round up
 	floor()			round down
 	trunc()			remove value after decimal point
+	fmod()			remainder of division
+	exp()			exponential
+	log()			natural logarithm (logarithm to base e)
 	log10()			logarithm to base 10
 	pow()			value of x to the exponent y
 	sqrt()			square root
@@ -675,6 +683,7 @@
 	invert()		bitwise invert
 	or()			bitwise OR
 	xor()			bitwise XOR
+	sha256()		SHA-256 hash
 
 Variables:						*var-functions*
 	type()			type of a variable
@@ -697,11 +706,16 @@
 	wincol()		window column number of the cursor
 	winline()		window line number of the cursor
 	cursor()		position the cursor at a line/column
+	screencol()		get screen column of the cursor
+	screenrow()		get screen row of the cursor
+	getcurpos()		get position of the cursor
 	getpos()		get position of cursor, mark, etc.
 	setpos()		set position of cursor, mark, etc.
 	byte2line()		get line number at a specific byte count
 	line2byte()		byte count at a specific line
 	diff_filler()		get the number of filler lines above a line
+	screenattr()		get attribute at a screen line/row
+	screenchar()		get character code at a screen line/row
 
 Working with text in the current buffer:		*text-functions*
 	getline()		get a line or list of lines from the buffer
@@ -729,6 +743,7 @@
 	pathshorten()		shorten directory names in a path
 	simplify()		simplify a path without changing its meaning
 	executable()		check if an executable program exists
+	exepath()		full path of an executable program
 	filereadable()		check if a file can be read
 	filewritable()		check if a file can be written to
 	getfperm()		get the permissions of a file
@@ -741,7 +756,8 @@
 	mkdir()			create a new directory
 	delete()		delete a file
 	rename()		rename a file
-	system()		get the result of a shell command
+	system()		get the result of a shell command as a string
+	systemlist()		get the result of a shell command as a list
 	hostname()		name of the system
 	readfile()		read a file into a List of lines
 	writefile()		write a List of lines into a file
@@ -757,6 +773,7 @@
 Buffers, windows and the argument list:
 	argc()			number of entries in the argument list
 	argidx()		current position in the argument list
+	arglistid()		get id of the argument list
 	argv()			get one entry from the argument list
 	bufexists()		check if a buffer exists
 	buflisted()		check if a buffer exists and is listed
@@ -776,6 +793,7 @@
 	getcmdpos()		get position of the cursor in the command line
 	setcmdpos()		set position of the cursor in the command line
 	getcmdtype()		return the current command-line type
+	getcmdwintype()		return the current command-line window type
 
 Quickfix and location lists:			*quickfix-functions*
 	getqflist()		list of quickfix errors
@@ -810,6 +828,7 @@
 	synconcealed()		get info about concealing
 	diff_hlID()		get highlight ID for diff mode at a position
 	matchadd()		define a pattern to highlight (a "match")
+	matchaddpos()		define a list of positions to highlight
 	matcharg()		get info about |:match| arguments
 	matchdelete()		delete a match defined by |matchadd()| or a
 				|:match| command
@@ -883,14 +902,22 @@
 	libcall()		call a function in an external library
 	libcallnr()		idem, returning a number
 
+	undofile()		get the name of the undo file
+	undotree()		return the state of the undo tree
+
 	getreg()		get contents of a register
 	getregtype()		get type of a register
 	setreg()		set contents and type of a register
 
+	shiftwidth()		effective value of 'shiftwidth'
+
 	taglist()		get list of matching tags
 	tagfiles()		get a list of tags files
 
+	luaeval()		evaluate Lua expression
 	mzeval()		evaluate |MzScheme| expression
+	py3eval()		evaluate Python expression (|+python3|)
+	pyeval()		evaluate Python expression (|+python|)
 
 ==============================================================================
 *41.7*	Defining a function
diff -Naur vim74.orig/runtime/doc/usr_42.txt vim74/runtime/doc/usr_42.txt
--- vim74.orig/runtime/doc/usr_42.txt	2013-08-10 11:25:05.000000000 +0000
+++ vim74/runtime/doc/usr_42.txt	2014-10-10 14:53:40.518723496 +0000
@@ -311,7 +311,7 @@
 item with a bitmap.  For example, define a new toolbar item with: >
 
 	:tmenu ToolBar.Compile  Compile the current file
-	:amenu ToolBar.Compile  :!cc % -o %:r<CR>
+	:amenu ToolBar.Compile  :!cc %:S -o %:r:S<CR>
 
 Now you need to create the icon.  For MS-Windows it must be in bitmap format,
 with the name "Compile.bmp".  For Unix XPM format is used, the file name is
diff -Naur vim74.orig/runtime/doc/usr_45.txt vim74/runtime/doc/usr_45.txt
--- vim74.orig/runtime/doc/usr_45.txt	2013-08-10 11:25:06.000000000 +0000
+++ vim74/runtime/doc/usr_45.txt	2014-10-10 14:53:40.525390146 +0000
@@ -328,8 +328,8 @@
 *45.5*	Entering language text
 
 Computer keyboards don't have much more than a hundred keys.  Some languages
-have thousands of characters, Unicode has ten thousands.  So how do you type
-these characters?
+have thousands of characters, Unicode has over hundred thousand.  So how do
+you type these characters?
    First of all, when you don't use too many of the special characters, you
 can use digraphs.  This was already explained in |24.9|.
    When you use a language that uses many more characters than keys on your
diff -Naur vim74.orig/runtime/doc/various.txt vim74/runtime/doc/various.txt
--- vim74.orig/runtime/doc/various.txt	2013-08-10 11:25:06.000000000 +0000
+++ vim74/runtime/doc/various.txt	2014-10-10 14:53:40.532056796 +0000
@@ -1,4 +1,4 @@
-*various.txt*   For Vim version 7.4.  Last change: 2013 May 18
+*various.txt*   For Vim version 7.4.  Last change: 2014 Aug 06
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -234,25 +234,41 @@
 							*:!cmd* *:!* *E34*
 :!{cmd}			Execute {cmd} with the shell.  See also the 'shell'
 			and 'shelltype' option.
+
 			Any '!' in {cmd} is replaced with the previous
 			external command (see also 'cpoptions').  But not when
 			there is a backslash before the '!', then that
 			backslash is removed.  Example: ":!ls" followed by
 			":!echo ! \! \\!" executes "echo ls ! \!".
-			After the command has been executed, the timestamp of
-			the current file is checked |timestamp|.
+
 			A '|' in {cmd} is passed to the shell, you cannot use
 			it to append a Vim command.  See |:bar|.
+
+			If {cmd} contains "%" it is expanded to the current
+			file name.  Special characters are not escaped, use
+			quotes to avoid their special meaning: >
+				:!ls "%"
+<			If the file name contains a "$" single quotes might
+			work better (but a single quote causes trouble): >
+				:!ls '%'
+<			This should always work, but it's more typing: >
+				:exe "!ls " . shellescape(expand("%"))
+<
 			A newline character ends {cmd}, what follows is
 			interpreted as a following ":" command.  However, if
 			there is a backslash before the newline it is removed
 			and {cmd} continues.  It doesn't matter how many
 			backslashes are before the newline, only one is
 			removed.
+
 			On Unix the command normally runs in a non-interactive
 			shell.  If you want an interactive shell to be used
 			(to use aliases) set 'shellcmdflag' to "-ic".
 			For Win32 also see |:!start|.
+
+			After the command has been executed, the timestamp and
+			size of the current file is checked |timestamp|.
+
 			Vim redraws the screen after the command is finished,
 			because it may have printed any text.  This requires a
 			hit-enter prompt, so that you can read any messages.
@@ -291,6 +307,7 @@
 			in the normal, big and huge versions of Vim.
 
 							*+feature-list*
+   *+acl*		|ACL| support included
    *+ARP*		Amiga only: ARP support included
 B  *+arabic*		|Arabic| language support
 N  *+autocmd*		|:autocmd|, automatic commands
@@ -320,6 +337,7 @@
 N  *+dialog_con_gui*	Support for |:confirm| with GUI and console dialog.
 N  *+diff*		|vimdiff| and 'diff'
 N  *+digraphs*		|digraphs| *E196*
+m  *+directx*		Win32 GUI only: DirectX and |'renderoptions'|
    *+dnd*		Support for DnD into the "~ register |quote_~|.
 B  *+emacs_tags*	|emacs-tags| files
 N  *+eval*		expression evaluation |eval.txt|
@@ -362,6 +380,7 @@
 N  *+mouseshape*	|'mouseshape'|
 B  *+mouse_dec*		Unix only: Dec terminal mouse handling |dec-mouse|
 N  *+mouse_gpm*		Unix only: Linux console mouse handling |gpm-mouse|
+N  *+mouse_jsbterm*	JSB mouse handling |jsbterm-mouse|
 B  *+mouse_netterm*	Unix only: netterm mouse handling |netterm-mouse|
 N  *+mouse_pterm*	QNX only: pterm mouse handling |qnx-terminal|
 N  *+mouse_sysmouse*	Unix only: *BSD console mouse handling |sysmouse|
@@ -417,7 +436,7 @@
 N  *+viminfo*		|'viminfo'|
 N  *+vertsplit*		Vertically split windows |:vsplit|
 N  *+virtualedit*	|'virtualedit'|
-S  *+visual*		Visual mode |Visual-mode|
+S  *+visual*		Visual mode |Visual-mode| Always enabled since 7.4.200.
 N  *+visualextra*	extra Visual mode commands |blockwise-operators|
 N  *+vreplace*		|gR| and |gr|
 N  *+wildignore*	|'wildignore'|
@@ -426,6 +445,7 @@
 m  *+writebackup*	|'writebackup'| is default on
 m  *+xim*		X input method |xim|
    *+xfontset*		X fontset support |xfontset|
+   *+xpm*		pixmap support
 m  *+xpm_w32*		Win32 GUI only: pixmap support |w32-xpm-support|
    *+xsmp*		XSMP (X session management) support
    *+xsmp_interact*	interactive XSMP (X session management) support
diff -Naur vim74.orig/runtime/doc/version5.txt vim74/runtime/doc/version5.txt
--- vim74.orig/runtime/doc/version5.txt	2013-08-10 11:25:07.000000000 +0000
+++ vim74/runtime/doc/version5.txt	2014-10-10 14:53:40.545390096 +0000
@@ -2020,7 +2020,7 @@
 
 The Win32, Athena and Motif GUI bring up a file requester if the user asks to
 ":browse" for the ":e", ":w", ":r", ":so", ":redirect" and
-":mkexrc/vimrc/vsess" commands.  ::browse e /foo/bar" opens the requester in
+":mkexrc/vimrc/vsess" commands.  ":browse e /foo/bar" opens the requester in
 the /foo/bar directory, so you can have nice mapping rhs's like ":browse so
 $vim/macros".  If no initial dir specified for ":browse e", can be compiled to
 either begin in the current directory, or that of the current buffer. (Negri
diff -Naur vim74.orig/runtime/doc/version6.txt vim74/runtime/doc/version6.txt
--- vim74.orig/runtime/doc/version6.txt	2013-08-10 11:25:07.000000000 +0000
+++ vim74/runtime/doc/version6.txt	2014-10-10 14:53:40.558723396 +0000
@@ -1,4 +1,4 @@
-*version6.txt*  For Vim version 7.4.  Last change: 2013 Jul 28
+*version6.txt*  For Vim version 7.4.  Last change: 2014 Aug 29
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -7816,7 +7816,7 @@
 Patch 6.1.212
 Problem:    When Vim was started with "-R" ":new" creates a buffer
 	    'noreadonly' while ":enew" has 'readonly' set. (Preben Guldberg)
-Solution:   Don't set 'readonly in a new empty buffer for ":enew".
+Solution:   Don't set 'readonly' in a new empty buffer for ":enew".
 Files:	    src/ex_docmd.c
 
 Patch 6.1.213
diff -Naur vim74.orig/runtime/doc/version7.txt vim74/runtime/doc/version7.txt
--- vim74.orig/runtime/doc/version7.txt	2013-08-10 12:23:06.000000000 +0000
+++ vim74/runtime/doc/version7.txt	2014-10-10 14:53:40.578723345 +0000
@@ -1,4 +1,4 @@
-*version7.txt*  For Vim version 7.4.  Last change: 2013 Aug 10
+*version7.txt*  For Vim version 7.4.  Last change: 2014 Aug 29
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -942,6 +942,7 @@
 |tagfiles()|		List with tags file names
 |taglist()|		get list of matching tags (Yegappan Lakshmanan)
 |tr()|			translate characters (Ron Aaron)
+|uniq()|		remove copies of repeated adjacent list items
 |values()|		get List of Dictionary values
 |winnr()|		takes an argument: what window to use
 |winrestview()|		restore the view of the current window
@@ -1625,10 +1626,10 @@
 When running the tests and one of them fails to produce "test.out" the
 following tests are still executed.  This helps when running out of memory.
 
-When compiling with EXITFREE defined and the ccmalloc library it is possible
-to detect memory leaks.  Some memory will always reported as leaked, such as
-allocated by X11 library functions and the memory allocated in alloc_cmdbuff()
-to store the ":quit" command.
+When compiling with EXITFREE defined and the ccmalloc library, it is possible
+to detect memory leaks.  Some memory will always be reported as leaked, such
+as allocated by X11 library functions and the memory allocated in
+alloc_cmdbuff() to store the ":quit" command.
 
 Moved the code for printing to src/hardcopy.c.
 
@@ -2037,8 +2038,8 @@
 
 Avoid that $LANG is used for the menus when LC_MESSAGES is "en_US".
 
-Added backslashes before dashes in the vim.1 manual page to make the appear as
-real dashes. (Pierr Habouzit)
+Added backslashes before dashes in the vim.1 manual page to make them appear
+as real dashes. (Pierre Habouzit)
 
 Where "gq" left the cursor depended on the value of 'formatprg'.  Now "gq"
 always leaves the cursor at the last line of the formatted text.
@@ -2048,7 +2049,7 @@
 compressed.  Skip setting 'filetype' for compressed files until they have been
 decompressed.  Required for patterns that end in a "*".
 
-Starting with an argument "+cmd" or "-S script" causes the cursor the be moved
+Starting with an argument "+cmd" or "-S script" causes the cursor to be moved
 to the first line.  That breaks a BufReadPost autocommand that uses g`".
 Don't move the cursor if it's somewhere past the first line.
 
@@ -2395,7 +2396,7 @@
 actually are bold.  Speeds up displaying considerably.
 
 When only highlighting changes and the text is scrolled at the same time
-everything is redraw instead of using a scroll and updating the changed text.
+everything is redrawn instead of using a scroll and updating the changed text.
 E.g., when using ":match" to highlight a paren that the cursor landed on.
 Added SOME_VALID: Redraw the whole window but also try to scroll to minimize
 redrawing.
@@ -6484,7 +6485,7 @@
 Problem:    Win64: Edit with Vim context menu isn't installed correctly.
 	    Compiler warnings and a few other things.
 Solution:   Add [ and ] to entry of class name.  Use UINT_PTR instead of UINT.
-	    And a fixes for the other things. (George V.  Reilly)
+	    And fixes for other things. (George V.  Reilly)
 Files:	    src/GvimExt/Makefile, src/dosinst.c, src/if_ole.cpp, src/if_ole.h,
 	    src/if_ole.idl, src/INSTALLpc.txt,  src/Make_mvc.mak,
 	    src/os_win32.c,
@@ -7188,7 +7189,7 @@
 ---------------
 
 Support for Blowfish encryption.  Added the 'cryptmethod' option.
-Mostly by Moshin Ahmed.
+Mostly by Mohsin Ahmed.
 
 Also encrypt the text in the swap file and the undo file.
 
@@ -10293,7 +10294,7 @@
 	Added special |expand()| argument that expands to the current line 
 	number.
 
-	Made it possible to force |char2nr()| always give unicode codepoints 
+	Made it possible to force |char2nr()| to always give unicode codepoints 
 	regardless of current encoding. (Yasuhiro Matsumoto)
 
 	Made it possible for functions generating file list generate |List| 
@@ -15782,7 +15783,7 @@
 	    src/testdir/test87.ok
 
 Patch 7.3.944
-Problem:    External program receives the termrespone.
+Problem:    External program receives the termresponse.
 Solution:   Insert a delay and discard input. (Hayaki Saito)
 Files:	    src/term.c
 
diff -Naur vim74.orig/runtime/doc/vi_diff.txt vim74/runtime/doc/vi_diff.txt
--- vim74.orig/runtime/doc/vi_diff.txt	2013-08-10 11:25:07.000000000 +0000
+++ vim74/runtime/doc/vi_diff.txt	2014-10-10 14:53:40.585389995 +0000
@@ -1,4 +1,4 @@
-*vi_diff.txt*   For Vim version 7.4.  Last change: 2012 Aug 08
+*vi_diff.txt*   For Vim version 7.4.  Last change: 2013 Aug 22
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -150,7 +150,7 @@
 Multi level undo.					|undo|
 	'u' goes backward in time, 'CTRL-R' goes forward again.  Set option
 	'undolevels' to the number of changes to be remembered (default 1000).
-	Set 'undolevels' to 0 for a vi-compatible one level undo.  Set it to
+	Set 'undolevels' to 0 for a Vi-compatible one level undo.  Set it to
 	-1 for no undo at all.
 	When all changes in a buffer have been undone, the buffer is not
 	considered changed anymore.  You can exit it with :q, without <!>.
@@ -540,7 +540,7 @@
 Added :wnext command.  Same as ":write" followed by ":next".
 
 The ":w!" command always writes, also when the file is write protected.  In Vi
-you would have to do ":!chmod +w %" and ":set noro".
+you would have to do ":!chmod +w %:S" and ":set noro".
 
 When 'tildeop' has been set, "~" is an operator (must be followed by a
 movement command).
diff -Naur vim74.orig/runtime/doc/visual.txt vim74/runtime/doc/visual.txt
--- vim74.orig/runtime/doc/visual.txt	2013-08-10 11:25:08.000000000 +0000
+++ vim74/runtime/doc/visual.txt	2014-10-10 14:53:40.648723170 +0000
@@ -1,4 +1,4 @@
-*visual.txt*    For Vim version 7.4.  Last change: 2012 Aug 15
+*visual.txt*    For Vim version 7.4.  Last change: 2014 Mar 23
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -22,7 +22,7 @@
 
 {Vi has no Visual mode, the name "visual" is used for Normal mode, to
 distinguish it from Ex mode}
-{not available when the |+visual| feature was disabled when compiling}
+{Since Vim 7.4.200 the |+visual| feature is always included}
 
 ==============================================================================
 1. Using Visual mode					*visual-use*
@@ -75,7 +75,11 @@
 
 						*V* *linewise-visual*
 [count]V		Start Visual mode linewise.
-			With [count] select that many lines.
+			With [count] select the same number of lines as used
+			for the last Visual operation, but at the current
+			cursor position, multiplied by [count].  When there
+			was no previous Visual operation [count] lines are
+			selected.
 
 						*CTRL-V* *blockwise-visual*
 [count]CTRL-V		Start Visual mode blockwise.  Note: Under Windows
diff -Naur vim74.orig/runtime/doc/windows.txt vim74/runtime/doc/windows.txt
--- vim74.orig/runtime/doc/windows.txt	2013-08-10 11:25:08.000000000 +0000
+++ vim74/runtime/doc/windows.txt	2014-10-10 14:53:40.652056495 +0000
@@ -1,4 +1,4 @@
-*windows.txt*   For Vim version 7.4.  Last change: 2012 Nov 15
+*windows.txt*   For Vim version 7.4.  Last change: 2014 Sep 23
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -132,13 +132,20 @@
 CTRL-W s						*CTRL-W_s*
 CTRL-W S						*CTRL-W_S*
 CTRL-W CTRL-S						*CTRL-W_CTRL-S*
-:[N]sp[lit] [++opt] [+cmd]				*:sp* *:split*
+:[N]sp[lit] [++opt] [+cmd] [file]			*:sp* *:split*
 		Split current window in two.  The result is two viewports on
-		the same file.  Make new window N high (default is to use half
-		the height of the current window).  Reduces the current window
-		height to create room (and others, if the 'equalalways' option
-		is set, 'eadirection' isn't "hor", and one of them is higher
-		than the current or the new window).
+		the same file.
+		
+		Make the new window N high (default is to use half the height
+		of the current window).  Reduces the current window height to
+		create room (and others, if the 'equalalways' option is set,
+		'eadirection' isn't "hor", and one of them is higher than the
+		current or the new window).
+
+		If [file] is given it will be edited in the new window.  If it
+		is not loaded in any buffer, it will be read.  Else the new
+		window will use the already loaded buffer.
+
 		Note: CTRL-S does not work on all terminals and might block
 		further input, use CTRL-Q to get going again.
 		Also see |++opt| and |+cmd|.
@@ -719,18 +726,21 @@
 
 CTRL-W ]					*CTRL-W_]* *CTRL-W_CTRL-]*
 CTRL-W CTRL-]	Split current window in two.  Use identifier under cursor as a
-		tag and jump to it in the new upper window.  Make new window N
-		high.
+		tag and jump to it in the new upper window.
+		In Visual mode uses the Visually selected text as a tag.
+		Make new window N high.
 
 							*CTRL-W_g]*
 CTRL-W g ]	Split current window in two.  Use identifier under cursor as a
 		tag and perform ":tselect" on it in the new upper window.
+		In Visual mode uses the Visually selected text as a tag.
 		Make new window N high.
 
 							*CTRL-W_g_CTRL-]*
 CTRL-W g CTRL-]	Split current window in two.  Use identifier under cursor as a
-		tag and perform ":tjump" on it in the new upper window.  Make
-		new window N high.
+		tag and perform ":tjump" on it in the new upper window.
+		In Visual mode uses the Visually selected text as a tag.
+		Make new window N high.
 
 CTRL-W f					*CTRL-W_f* *CTRL-W_CTRL-F*
 CTRL-W CTRL-F	Split current window in two.  Edit file name under cursor.
@@ -1035,36 +1045,41 @@
 		a number).  Insert a backslash before a space in a buffer
 		name.
 
-:[N]b[uffer][!] [N]			*:b* *:bu* *:buf* *:buffer* *E86*
+:[N]b[uffer][!] [+cmd] [N]		*:b* *:bu* *:buf* *:buffer* *E86*
 		Edit buffer [N] from the buffer list.  If [N] is not given,
 		the current buffer remains being edited.  See |:buffer-!| for
 		[!].  This will also edit a buffer that is not in the buffer
 		list, without setting the 'buflisted' flag.
+		Also see ||+cmd|.
 
-:[N]b[uffer][!] {bufname}
+:[N]b[uffer][!] [+cmd] {bufname}
 		Edit buffer for {bufname} from the buffer list.  See
 		|:buffer-!| for [!].  This will also edit a buffer that is not
 		in the buffer list, without setting the 'buflisted' flag.
+		Also see ||+cmd|.
 
-:[N]sb[uffer] [N]					*:sb* *:sbuffer*
+:[N]sb[uffer] [+cmd] [N]				*:sb* *:sbuffer*
 		Split window and edit buffer [N] from the buffer list.  If [N]
 		is not given, the current buffer is edited.  Respects the
 		"useopen" setting of 'switchbuf' when splitting.  This will
 		also edit a buffer that is not in the buffer list, without
 		setting the 'buflisted' flag.
+		Also see ||+cmd|.
 
-:[N]sb[uffer] {bufname}
+:[N]sb[uffer] [+cmd] {bufname}
 		Split window and edit buffer for {bufname} from the buffer
 		list.  This will also edit a buffer that is not in the buffer
 		list, without setting the 'buflisted' flag.
 		Note: If what you want to do is split the buffer, make a copy
 		under another name, you can do it this way: >
 			:w foobar | sp #
+<		Also see ||+cmd|.
 
-:[N]bn[ext][!] [N]					*:bn* *:bnext* *E87*
+:[N]bn[ext][!] [+cmd] [N]				*:bn* *:bnext* *E87*
 		Go to [N]th next buffer in buffer list.  [N] defaults to one.
 		Wraps around the end of the buffer list.
 		See |:buffer-!| for [!].
+		Also see ||+cmd|.
 		If you are in a help buffer, this takes you to the next help
 		buffer (if there is one).  Similarly, if you are in a normal
 		(non-help) buffer, this takes you to the next normal buffer.
@@ -1072,55 +1087,61 @@
 		the way when you're browsing code/text buffers.  The next three
 		commands also work like this.
 
+
 							*:sbn* *:sbnext*
-:[N]sbn[ext] [N]
+:[N]sbn[ext] [+cmd] [N]
 		Split window and go to [N]th next buffer in buffer list.
 		Wraps around the end of the buffer list.  Uses 'switchbuf'
+		Also see ||+cmd|.
 
-:[N]bN[ext][!] [N]			*:bN* *:bNext* *:bp* *:bprevious* *E88*
-:[N]bp[revious][!] [N]
+:[N]bN[ext][!] [+cmd] [N]		*:bN* *:bNext* *:bp* *:bprevious* *E88*
+:[N]bp[revious][!] [+cmd] [N]
 		Go to [N]th previous buffer in buffer list.  [N] defaults to
 		one.  Wraps around the start of the buffer list.
 		See |:buffer-!| for [!] and 'switchbuf'.
+		Also see ||+cmd|.
 
-:[N]sbN[ext] [N]			*:sbN* *:sbNext* *:sbp* *:sbprevious*
-:[N]sbp[revious] [N]
+:[N]sbN[ext] [+cmd] [N]			*:sbN* *:sbNext* *:sbp* *:sbprevious*
+:[N]sbp[revious] [+cmd] [N]
 		Split window and go to [N]th previous buffer in buffer list.
 		Wraps around the start of the buffer list.
 		Uses 'switchbuf'.
+		Also see ||+cmd|.
 
-							*:br* *:brewind*
-:br[ewind][!]	Go to first buffer in buffer list.  If the buffer list is
+:br[ewind][!] [+cmd]					*:br* *:brewind*
+		Go to first buffer in buffer list.  If the buffer list is
 		empty, go to the first unlisted buffer.
 		See |:buffer-!| for [!].
 
-							*:bf* *:bfirst*
-:bf[irst]	Same as ":brewind".
+:bf[irst] [+cmd]					*:bf* *:bfirst*
+		Same as |:brewind|.
+		Also see |+cmd|.
 
-							*:sbr* *:sbrewind*
-:sbr[ewind]	Split window and go to first buffer in buffer list.  If the
+:sbr[ewind] [+cmd]					*:sbr* *:sbrewind*
+		Split window and go to first buffer in buffer list.  If the
 		buffer list is empty, go to the first unlisted buffer.
 		Respects the 'switchbuf' option.
+		Also see |+cmd|.
 
-							*:sbf* *:sbfirst*
-:sbf[irst]	Same as ":sbrewind".
+:sbf[irst] [+cmd]					*:sbf* *:sbfirst*
+		Same as ":sbrewind".
 
-							*:bl* *:blast*
-:bl[ast][!]	Go to last buffer in buffer list.  If the buffer list is
+:bl[ast][!] [+cmd]					*:bl* *:blast*
+		Go to last buffer in buffer list.  If the buffer list is
 		empty, go to the last unlisted buffer.
 		See |:buffer-!| for [!].
 
-							*:sbl* *:sblast*
-:sbl[ast]	Split window and go to last buffer in buffer list.  If the
+:sbl[ast] [+cmd]					*:sbl* *:sblast*
+		Split window and go to last buffer in buffer list.  If the
 		buffer list is empty, go to the last unlisted buffer.
 		Respects 'switchbuf' option.
 
-:[N]bm[odified][!] [N]				*:bm* *:bmodified* *E84*
+:[N]bm[odified][!] [+cmd] [N]			*:bm* *:bmodified* *E84*
 		Go to [N]th next modified buffer.  Note: this command also
 		finds unlisted buffers.  If there is no modified buffer the
 		command fails.
 
-:[N]sbm[odified] [N]					*:sbm* *:sbmodified*
+:[N]sbm[odified] [+cmd] [N]				*:sbm* *:sbmodified*
 		Split window and go to [N]th next modified buffer.
 		Respects 'switchbuf' option.
 		Note: this command also finds buffers not in the buffer list.
diff -Naur vim74.orig/runtime/filetype.vim vim74/runtime/filetype.vim
--- vim74.orig/runtime/filetype.vim	2013-08-03 15:50:05.000000000 +0000
+++ vim74/runtime/filetype.vim	2014-10-10 14:53:40.688723069 +0000
@@ -1,7 +1,7 @@
 " Vim support file to detect file types
 "
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2013 Aug 03
+" Last Change:	2014 Sep 05
 
 " Listen very carefully, I will say this only once
 if exists("did_load_filetypes")
@@ -106,6 +106,9 @@
 " Ant
 au BufNewFile,BufRead build.xml			setf ant
 
+" Arduino
+au BufNewFile,BufRead *.ino,*.pde		setf arduino
+
 " Apache style config file
 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
 
@@ -129,7 +132,7 @@
 au BufNewFile,BufRead *.aml			setf aml
 
 " APT config file
-au BufNewFile,BufRead apt.conf                 setf aptconf
+au BufNewFile,BufRead apt.conf		       setf aptconf
 au BufNewFile,BufRead */.aptitude/config       setf aptconf
 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
 
@@ -527,6 +530,9 @@
 " CUDA  Cumpute Unified Device Architecture
 au BufNewFile,BufRead *.cu			setf cuda
 
+" Dockerfile
+au BufNewFile,BufRead Dockerfile		setf dockerfile
+
 " WildPackets EtherPeek Decoder
 au BufNewFile,BufRead *.dcd			setf dcd
 
@@ -536,6 +542,20 @@
 " Eterm
 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
 
+" Euphoria 3 or 4
+au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
+if has("fname_case")
+   au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
+endif
+
+func! s:EuphoriaCheck()
+  if exists('g:filetype_euphoria')
+    exe 'setf ' . g:filetype_euphoria
+  else
+    setf euphoria3
+  endif
+endfunc
+
 " Lynx config files
 au BufNewFile,BufRead lynx.cfg			setf lynx
 
@@ -656,22 +676,26 @@
 " Embedix Component Description
 au BufNewFile,BufRead *.ecd			setf ecd
 
-" Eiffel or Specman
+" Eiffel or Specman or Euphoria
 au BufNewFile,BufRead *.e,*.E			call s:FTe()
 
 " Elinks configuration
 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
 
 func! s:FTe()
-  let n = 1
-  while n < 100 && n < line("$")
-    if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
-      setf specman
-      return
-    endif
-    let n = n + 1
-  endwhile
-  setf eiffel
+  if exists('g:filetype_euphoria')
+    exe 'setf ' . g:filetype_euphoria
+  else
+    let n = 1
+    while n < 100 && n < line("$")
+      if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
+        setf specman
+        return
+      endif
+      let n = n + 1
+    endwhile
+    setf eiffel
+  endif
 endfunc
 
 " ERicsson LANGuage; Yaws is erlang too
@@ -790,6 +814,9 @@
 " Gnuplot scripts
 au BufNewFile,BufRead *.gpi			setf gnuplot
 
+" Go (Google)
+au BufNewFile,BufRead *.go			setf go
+
 " GrADS scripts
 au BufNewFile,BufRead *.gs			setf grads
 
@@ -843,7 +870,7 @@
       setf xhtml
       return
     endif
-    if getline(n) =~ '{%\s*\(extends\|block\)\>'
+    if getline(n) =~ '{%\s*\(extends\|block\|load\)\>'
       setf htmldjango
       return
     endif
@@ -952,6 +979,9 @@
 " Inno Setup
 au BufNewFile,BufRead *.iss			setf iss
 
+" J
+au BufNewFile,BufRead *.ijs			setf j
+
 " JAL
 au BufNewFile,BufRead *.jal,*.JAL		setf jal
 
@@ -965,7 +995,7 @@
 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
 
 " JavaScript, ECMAScript
-au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.json   setf javascript
+au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript
 
 " Java Server Pages
 au BufNewFile,BufRead *.jsp			setf jsp
@@ -983,12 +1013,18 @@
 " Jovial
 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
 
+" JSON
+au BufNewFile,BufRead *.json,*.jsonp		setf json
+
 " Kixtart
 au BufNewFile,BufRead *.kix			setf kix
 
 " Kimwitu[++]
 au BufNewFile,BufRead *.k			setf kwt
 
+" Kivy
+au BufNewFile,BufRead *.kv			setf kivy
+
 " KDE script
 au BufNewFile,BufRead *.ks			setf kscript
 
@@ -1014,7 +1050,7 @@
 au BufNewFile,BufRead *.ld			setf ld
 
 " Lex
-au BufNewFile,BufRead *.lex,*.l			setf lex
+au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
 
 " Libao
 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
@@ -1068,6 +1104,9 @@
 " Lua
 au BufNewFile,BufRead *.lua			setf lua
 
+" Luarocks
+au BufNewFile,BufRead *.rockspec		setf lua
+
 " Linden Scripting Language (Second Life)
 au BufNewFile,BufRead *.lsl			setf lsl
 
@@ -1115,7 +1154,7 @@
 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,README.md  setf markdown
 
 " Mason
-au BufNewFile,BufRead *.mason,*.mhtml		setf mason
+au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
 
 " Matlab or Objective C
 au BufNewFile,BufRead *.m			call s:FTm()
@@ -1169,6 +1208,9 @@
 " MGL
 au BufNewFile,BufRead *.mgl			setf mgl
 
+" MIX - Knuth assembly
+au BufNewFile,BufRead *.mix,*.mixal		setf mix
+
 " MMIX or VMS makefile
 au BufNewFile,BufRead *.mms			call s:FTmms()
 
@@ -1619,6 +1661,20 @@
   au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
 endif
 
+" R Markdown file
+if has("fname_case")
+  au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
+else
+  au BufNewFile,BufRead *.rmd,*.smd			setf rmd
+endif
+
+" R reStructuredText file
+if has("fname_case")
+  au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
+else
+  au BufNewFile,BufRead *.rrst,*.srst			setf rrst
+endif
+
 " Rexx, Rebol or R
 au BufNewFile,BufRead *.r,*.R			call s:FTr()
 
@@ -2058,14 +2114,15 @@
 " SVG (Scalable Vector Graphics)
 au BufNewFile,BufRead *.svg			setf svg
 
-" If the file has an extension of 't' and is in a directory 't' then it is
-" almost certainly a Perl test file.
+" If the file has an extension of 't' and is in a directory 't' or 'xt' then
+" it is almost certainly a Perl test file.
 " If the first line starts with '#' and contains 'perl' it's probably a Perl
 " file.
 " (Slow test) If a file contains a 'use' statement then it is almost certainly
 " a Perl file.
 func! s:FTperl()
-  if expand("%:e") == 't' && expand("%:p:h:t") == 't'
+  let dirname = expand("%:p:h:t")
+  if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
     setf perl
     return 1
   endif
@@ -2092,7 +2149,7 @@
 
 " Task
 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
-au BufRead,BufNewFile *.task                    setf taskedit
+au BufRead,BufNewFile *.task			setf taskedit
 
 " Tcl (JACL too)
 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
@@ -2217,12 +2274,12 @@
 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
 
 " Upstart (init(8)) config files
-au BufNewFile,BufRead */usr/share/upstart/*.conf               setf upstart
-au BufNewFile,BufRead */usr/share/upstart/*.override           setf upstart
+au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
+au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
-au BufNewFile,BufRead */.config/upstart/*.conf                 setf upstart
-au BufNewFile,BufRead */.config/upstart/*.override             setf upstart
+au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
+au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
 
 " Vera
 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
@@ -2233,6 +2290,9 @@
 " Verilog-AMS HDL
 au BufNewFile,BufRead *.va,*.vams		setf verilogams
 
+" SystemVerilog
+au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
+
 " VHDL
 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
@@ -2263,6 +2323,9 @@
 " VRML V1.0c
 au BufNewFile,BufRead *.wrl			setf vrml
 
+" Vroom (vim testing and executable documentation)
+au BufNewFile,BufRead *.vroom			setf vroom
+
 " Webmacro
 au BufNewFile,BufRead *.wm			setf webmacro
 
@@ -2405,7 +2468,7 @@
 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
 
 " Yacc
-au BufNewFile,BufRead *.yy			setf yacc
+au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
 
 " Yacc or racc
 au BufNewFile,BufRead *.y			call s:FTy()
@@ -2630,7 +2693,7 @@
 
 " Plain text files, needs to be far down to not override others.  This avoids
 " the "conf" type being used if there is a line starting with '#'.
-au BufNewFile,BufRead *.txt,*.text		setf text
+au BufNewFile,BufRead *.txt,*.text,README	setf text
 
 
 " Use the filetype detect plugins.  They may overrule any of the previously
diff -Naur vim74.orig/runtime/ftplugin/changelog.vim vim74/runtime/ftplugin/changelog.vim
--- vim74.orig/runtime/ftplugin/changelog.vim	2012-08-23 20:47:22.000000000 +0000
+++ vim74/runtime/ftplugin/changelog.vim	2014-10-10 14:53:40.728722969 +0000
@@ -1,7 +1,7 @@
 " Vim filetype plugin file
 " Language:         generic Changelog file
 " Maintainer:       Nikolai Weibull <now@bitwi.se>
-" Latest Revision:  2012-08-23
+" Latest Revision:  2014-01-10
 " Variables:
 "   g:changelog_timeformat (deprecated: use g:changelog_dateformat instead) -
 "       description: the timeformat used in ChangeLog entries.
@@ -122,12 +122,12 @@
 
   " Format used for new date entries.
   if !exists('g:changelog_new_date_format')
-    let g:changelog_new_date_format = "%d  %u\n\n\t* %c\n\n"
+    let g:changelog_new_date_format = "%d  %u\n\n\t* %p%c\n\n"
   endif
 
   " Format used for new entries to current date entry.
   if !exists('g:changelog_new_entry_format')
-    let g:changelog_new_entry_format = "\t* %c"
+    let g:changelog_new_entry_format = "\t* %p%c"
   endif
 
   " Regular expression used to find a given date entry.
@@ -143,16 +143,16 @@
 
   " Substitutes specific items in new date-entry formats and search strings.
   " Can be done with substitute of course, but unclean, and need \@! then.
-  function! s:substitute_items(str, date, user)
+  function! s:substitute_items(str, date, user, prefix)
     let str = a:str
-    let middles = {'%': '%', 'd': a:date, 'u': a:user, 'c': '{cursor}'}
+    let middles = {'%': '%', 'd': a:date, 'u': a:user, 'p': a:prefix, 'c': '{cursor}'}
     let i = stridx(str, '%')
     while i != -1
       let inc = 0
       if has_key(middles, str[i + 1])
         let mid = middles[str[i + 1]]
         let str = strpart(str, 0, i) . mid . strpart(str, i + 2)
-        let inc = strlen(mid)
+        let inc = strlen(mid) - 1
       endif
       let i = stridx(str, '%', i + 1 + inc)
     endwhile
@@ -171,7 +171,7 @@
   endfunction
 
   " Internal function to create a new entry in the ChangeLog.
-  function! s:new_changelog_entry()
+  function! s:new_changelog_entry(prefix)
     " Deal with 'paste' option.
     let save_paste = &paste
     let &paste = 1
@@ -179,7 +179,7 @@
     " Look for an entry for today by our user.
     let date = strftime(g:changelog_dateformat)
     let search = s:substitute_items(g:changelog_date_entry_search, date,
-                                  \ s:username())
+                                  \ s:username(), a:prefix)
     if search(search) > 0
       " Ok, now we look for the end of the date entry, and add an entry.
       call cursor(nextnonblank(line('.') + 1), 1)
@@ -188,7 +188,7 @@
       else
         let p = line('.')
       endif
-      let ls = split(s:substitute_items(g:changelog_new_entry_format, '', ''),
+      let ls = split(s:substitute_items(g:changelog_new_entry_format, '', '', a:prefix),
                    \ '\n')
       call append(p, ls)
       call cursor(p + 1, 1)
@@ -198,7 +198,7 @@
 
       " No entry today, so create a date-user header and insert an entry.
       let todays_entry = s:substitute_items(g:changelog_new_date_format,
-                                          \ date, s:username())
+                                          \ date, s:username(), a:prefix)
       " Make sure we have a cursor positioning.
       if stridx(todays_entry, '{cursor}') == -1
         let todays_entry = todays_entry . '{cursor}'
@@ -206,7 +206,7 @@
 
       " Now do the work.
       call append(0, split(todays_entry, '\n'))
-      
+
       " Remove empty lines at end of file.
       if remove_empty
         $-/^\s*$/-1,$delete
@@ -223,8 +223,8 @@
   endfunction
 
   if exists(":NewChangelogEntry") != 2
-    noremap <buffer> <silent> <Leader>o <Esc>:call <SID>new_changelog_entry()<CR>
-    command! -nargs=0 NewChangelogEntry call s:new_changelog_entry()
+    noremap <buffer> <silent> <Leader>o <Esc>:call <SID>new_changelog_entry('')<CR>
+    command! -nargs=0 NewChangelogEntry call s:new_changelog_entry('')
   endif
 
   let b:undo_ftplugin = "setl com< fo< et< ai<"
@@ -277,10 +277,7 @@
     if exists('b:changelog_entry_prefix')
       let prefix = call(b:changelog_entry_prefix, [])
     else
-      let prefix = substitute(strpart(expand('%:p'), strlen(path)), '^/\+', "", "") . ':'
-    endif
-    if !empty(prefix)
-      let prefix = ' ' . prefix
+      let prefix = substitute(strpart(expand('%:p'), strlen(path)), '^/\+', "", "")
     endif
 
     let buf = bufnr(changelog)
diff -Naur vim74.orig/runtime/ftplugin/clojure.vim vim74/runtime/ftplugin/clojure.vim
--- vim74.orig/runtime/ftplugin/clojure.vim	2013-02-06 14:35:23.000000000 +0000
+++ vim74/runtime/ftplugin/clojure.vim	2014-10-10 14:53:40.732056294 +0000
@@ -1,44 +1,60 @@
 " Vim filetype plugin file
-" Language:     Clojure
-" Author:       Meikel Brandmeyer <mb@kotka.de>
+" Language:	Clojure
+" Author:	Meikel Brandmeyer <mb@kotka.de>
 "
-" Maintainer:   Sung Pae <self@sungpae.com>
-" URL:          https://github.com/guns/vim-clojure-static
-" License:      Same as Vim
-" Last Change:  30 January 2013
+" Maintainer:	Sung Pae <self@sungpae.com>
+" URL:		https://github.com/guns/vim-clojure-static
+" License:	Same as Vim
+" Last Change:	27 March 2014
 
-" Only do this when not done yet for this buffer
 if exists("b:did_ftplugin")
-    finish
+	finish
 endif
 let b:did_ftplugin = 1
 
 let s:cpo_save = &cpo
 set cpo&vim
 
-let b:undo_ftplugin = 'setlocal define< formatoptions< comments< commentstring<'
+let b:undo_ftplugin = 'setlocal iskeyword< define< formatoptions< comments< commentstring< lispwords<'
+
+setlocal iskeyword+=?,-,*,!,+,/,=,<,>,.,:,$
 
 " There will be false positives, but this is better than missing the whole set
 " of user-defined def* definitions.
 setlocal define=\\v[(/]def(ault)@!\\S*
 
-" Remove 't' from 'formatoptions' to avoid auto-wrapping code. The '+=croql'
-" is standard ftplugin boilerplate, although it is arguably intrusive.
-setlocal formatoptions-=t formatoptions+=croql
+" Remove 't' from 'formatoptions' to avoid auto-wrapping code.
+setlocal formatoptions-=t
 
 " Lisp comments are routinely nested (e.g. ;;; SECTION HEADING)
 setlocal comments=n:;
 setlocal commentstring=;\ %s
 
+" Specially indented symbols from clojure.core and clojure.test.
+"
+" Clojure symbols are indented in the defn style when they:
+"
+"   * Define vars and anonymous functions
+"   * Create new lexical scopes or scopes with altered environments
+"   * Create conditional branches from a predicate function or value
+"
+" The arglists for these functions are generally in the form of [x & body];
+" Functions that accept a flat list of forms do not treat the first argument
+" specially and hence are not indented specially.
+"
+" -*- LISPWORDS -*-
+" Generated from https://github.com/guns/vim-clojure-static/blob/vim-release-010/clj/src/vim_clojure_static/generate.clj
+setlocal lispwords=as->,binding,bound-fn,case,catch,cond->,cond->>,condp,def,definline,definterface,defmacro,defmethod,defmulti,defn,defn-,defonce,defprotocol,defrecord,defstruct,deftest,deftest-,deftype,doseq,dotimes,doto,extend,extend-protocol,extend-type,fn,for,if,if-let,if-not,if-some,let,letfn,locking,loop,ns,proxy,reify,set-test,testing,when,when-first,when-let,when-not,when-some,while,with-bindings,with-in-str,with-local-vars,with-open,with-precision,with-redefs,with-redefs-fn,with-test
+
 " Provide insert mode completions for special forms and clojure.core. As
 " 'omnifunc' is set by popular Clojure REPL client plugins, we also set
 " 'completefunc' so that the user has some form of completion available when
 " 'omnifunc' is set and no REPL connection exists.
 for s:setting in ['omnifunc', 'completefunc']
-    if exists('&' . s:setting) && empty(eval('&' . s:setting))
-        execute 'setlocal ' . s:setting . '=clojurecomplete#Complete'
-        let b:undo_ftplugin .= ' | setlocal ' . s:setting . '<'
-    endif
+	if exists('&' . s:setting) && empty(eval('&' . s:setting))
+		execute 'setlocal ' . s:setting . '=clojurecomplete#Complete'
+		let b:undo_ftplugin .= ' | setlocal ' . s:setting . '<'
+	endif
 endfor
 
 " Take all directories of the CLOJURE_SOURCE_DIRS environment variable
@@ -46,34 +62,34 @@
 "
 " This is a legacy option for VimClojure users.
 if exists('$CLOJURE_SOURCE_DIRS')
-    for s:dir in split($CLOJURE_SOURCE_DIRS, (has("win32") || has("win64")) ? ';' : ':')
-        let s:dir = fnameescape(s:dir)
-        " Whitespace escaping for Windows
-        let s:dir = substitute(s:dir, '\', '\\\\', 'g')
-        let s:dir = substitute(s:dir, '\ ', '\\ ', 'g')
-        execute "setlocal path+=" . s:dir . "/**"
-    endfor
-    let b:undo_ftplugin .= ' | setlocal path<'
+	for s:dir in split($CLOJURE_SOURCE_DIRS, (has("win32") || has("win64")) ? ';' : ':')
+		let s:dir = fnameescape(s:dir)
+		" Whitespace escaping for Windows
+		let s:dir = substitute(s:dir, '\', '\\\\', 'g')
+		let s:dir = substitute(s:dir, '\ ', '\\ ', 'g')
+		execute "setlocal path+=" . s:dir . "/**"
+	endfor
+	let b:undo_ftplugin .= ' | setlocal path<'
 endif
 
 " Skip brackets in ignored syntax regions when using the % command
 if exists('loaded_matchit')
-    let b:match_words = &matchpairs
-    let b:match_skip = 's:comment\|string\|regex\|character'
-    let b:undo_ftplugin .= ' | unlet! b:match_words b:match_skip'
+	let b:match_words = &matchpairs
+	let b:match_skip = 's:comment\|string\|regex\|character'
+	let b:undo_ftplugin .= ' | unlet! b:match_words b:match_skip'
 endif
 
 " Win32 can filter files in the browse dialog
 if has("gui_win32") && !exists("b:browsefilter")
-    let b:browsefilter = "Clojure Source Files (*.clj)\t*.clj\n" .
-                       \ "ClojureScript Source Files (*.cljs)\t*.cljs\n" .
-                       \ "Java Source Files (*.java)\t*.java\n" .
-                       \ "All Files (*.*)\t*.*\n"
-    let b:undo_ftplugin .= ' | unlet! b:browsefilter'
+	let b:browsefilter = "Clojure Source Files (*.clj)\t*.clj\n" .
+			   \ "ClojureScript Source Files (*.cljs)\t*.cljs\n" .
+			   \ "Java Source Files (*.java)\t*.java\n" .
+			   \ "All Files (*.*)\t*.*\n"
+	let b:undo_ftplugin .= ' | unlet! b:browsefilter'
 endif
 
 let &cpo = s:cpo_save
 
 unlet! s:cpo_save s:setting s:dir
 
-" vim:sts=4 sw=4 et:
+" vim:sts=8:sw=8:ts=8:noet
diff -Naur vim74.orig/runtime/ftplugin/cobol.vim vim74/runtime/ftplugin/cobol.vim
--- vim74.orig/runtime/ftplugin/cobol.vim	2010-05-15 11:04:03.000000000 +0000
+++ vim74/runtime/ftplugin/cobol.vim	2014-10-10 14:53:40.732056294 +0000
@@ -1,7 +1,7 @@
 " Vim filetype plugin file
 " Language:	cobol
 " Author:	Tim Pope <vimNOSPAM@tpope.info>
-" $Id: cobol.vim,v 1.1 2007/05/05 17:24:38 vimboss Exp $
+" Last Update:	By ZyX: use shiftwidth()
 
 " Insert mode mappings: <C-T> <C-D> <Tab>
 " Normal mode mappings: < > << >> [[ ]] [] ][
@@ -113,7 +113,7 @@
 
 function! s:increase(...)
     let lnum = '.'
-    let sw = &shiftwidth
+    let sw = shiftwidth()
     let i = a:0 ? a:1 : indent(lnum)
     if i >= 11
         return sw - (i - 11) % sw
@@ -128,7 +128,7 @@
 
 function! s:decrease(...)
     let lnum = '.'
-    let sw = &shiftwidth
+    let sw = shiftwidth()
     let i = indent(a:0 ? a:1 : lnum)
     if i >= 11 + sw
         return 1 + (i + 12) % sw
@@ -147,7 +147,7 @@
     let head = strpart(getline('.'),0,7)
     let tail = strpart(getline('.'),7)
     let indent = match(tail,'[^ ]')
-    let sw = &shiftwidth
+    let sw = shiftwidth()
     let shift = a:shift
     if shift > 0
         if indent < 4
@@ -221,7 +221,8 @@
 function! s:Tab()
     if (strpart(getline('.'),0,col('.')-1) =~ '^\s*$' && &sta)
         return s:IncreaseIndent()
-    elseif &sts == &sw && &sts != 8 && &et
+    " &softtabstop < 0: &softtabstop follows &shiftwidth
+    elseif (&sts < 0 || &sts == shiftwidth()) && &sts != 8 && &et
         return s:repeat(" ",s:increase(col('.')-1))
     else
         return "\<Tab>"
diff -Naur vim74.orig/runtime/ftplugin/debchangelog.vim vim74/runtime/ftplugin/debchangelog.vim
--- vim74.orig/runtime/ftplugin/debchangelog.vim	2012-02-04 19:59:23.000000000 +0000
+++ vim74/runtime/ftplugin/debchangelog.vim	2014-10-10 14:53:40.755389568 +0000
@@ -3,7 +3,7 @@
 " Maintainer:   Debian Vim Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
 " Former Maintainers:   Michael Piefel <piefel@informatik.hu-berlin.de>
 "                       Stefano Zacchiroli <zack@debian.org>
-" Last Change:  2012-01-31
+" Last Change:  2014-01-31
 " License:      Vim License
 " URL:          http://hg.debian.org/hg/pkg-vim/vim/file/unstable/runtime/ftplugin/debchangelog.vim
 
@@ -152,7 +152,7 @@
 endfunction
 
 function Distribution(dist)
-    call setline(1, substitute(getline(1), ") [[:lower:] ]*;", ") " . a:dist . ";", ""))
+    call setline(1, substitute(getline(1), ')  *\%(UNRELEASED\|\l\+\);', ") " . a:dist . ";", ""))
 endfunction
 
 function Urgency(urg)
diff -Naur vim74.orig/runtime/ftplugin/dockerfile.vim vim74/runtime/ftplugin/dockerfile.vim
--- vim74.orig/runtime/ftplugin/dockerfile.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/dockerfile.vim	2014-10-10 14:53:40.775389518 +0000
@@ -0,0 +1,16 @@
+" Vim filetype plugin
+" Language:	Dockerfile
+" Maintainer:   Honza Pokorny <http://honza.ca>
+" Last Change:	2014 Aug 29
+
+" Only do this when not done yet for this buffer
+if exists("b:did_ftplugin")
+  finish
+endif
+
+" Don't load another plugin for this buffer
+let b:did_ftplugin = 1
+
+let b:undo_ftplugin = "setl commentstring<"
+
+setlocal commentstring=#\ %s
diff -Naur vim74.orig/runtime/ftplugin/fortran.vim vim74/runtime/ftplugin/fortran.vim
--- vim74.orig/runtime/ftplugin/fortran.vim	2012-04-18 07:32:40.000000000 +0000
+++ vim74/runtime/ftplugin/fortran.vim	2014-10-10 14:53:40.792056143 +0000
@@ -1,12 +1,12 @@
 " Vim settings file
 " Language:	Fortran 2008 (and older: Fortran 2003, 95, 90, 77, 66)
-" Version:	0.48
-" Last Change:	2012 Apr. 18
-" Maintainer:	Ajit J. Thakkar <ajit@unb.ca>; <http://www.unb.ca/chem/ajit/>
+" Version:	0.49
+" Last Change:	2013 Oct. 01
+" Maintainer:	Ajit J. Thakkar <ajit@unb.ca>; <http://www2.unb.ca/~ajit/>
 " Usage:	Do :help fortran-plugin from Vim
 " Credits:
-" Useful suggestions were made by Stefano Zacchiroli, Hendrik Merx, and Ben
-" Fritz.
+" Useful suggestions were made by Stefano Zacchiroli, Hendrik Merx, Ben
+" Fritz, and David Barnett.
 
 " Only do these settings when not done yet for this buffer
 if exists("b:did_ftplugin")
@@ -64,8 +64,8 @@
   " setlocal tw=73
 else
   setlocal comments=:!
-  " Free format allows a textwidth of 132 for code but 80 is more usual
-  setlocal tw=80
+  " Free format allows a textwidth of 132
+  setlocal tw=132
 endif
 
 " Set commentstring for foldmethod=marker
@@ -76,8 +76,8 @@
   setlocal expandtab
 endif
 
-" Set 'formatoptions' to break comment and text lines but allow long lines
-setlocal fo+=tcql
+" Set 'formatoptions' to break text lines
+setlocal fo+=t
 
 setlocal include=^\\c#\\=\\s*include\\s\\+
 setlocal suffixesadd+=.f08,.f03,.f95,.f90,.for,.f,.F,.f77,.ftn,.fpp
@@ -114,7 +114,7 @@
     \ "All Files (*.*)\t*.*\n"
 endif
 
-let b:undo_ftplugin = "setl fo< com< tw< cms< et< inc<"
+let b:undo_ftplugin = "setl fo< com< tw< cms< et< inc< sua<"
 	\ . "| unlet! b:match_ignorecase b:match_words b:browsefilter"
 
 let &cpoptions=s:cposet
diff -Naur vim74.orig/runtime/ftplugin/go.vim vim74/runtime/ftplugin/go.vim
--- vim74.orig/runtime/ftplugin/go.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/go.vim	2014-10-10 14:53:40.802056118 +0000
@@ -0,0 +1,18 @@
+" Vim filetype plugin file
+" Language:	Go
+" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
+" Last Change:	2014 Aug 16
+
+if exists('b:did_ftplugin')
+  finish
+endif
+let b:did_ftplugin = 1
+
+setlocal formatoptions-=t
+
+setlocal comments=s1:/*,mb:*,ex:*/,://
+setlocal commentstring=//\ %s
+
+let b:undo_ftplugin = 'setl fo< com< cms<'
+
+" vim: sw=2 sts=2 et
diff -Naur vim74.orig/runtime/ftplugin/html.vim vim74/runtime/ftplugin/html.vim
--- vim74.orig/runtime/ftplugin/html.vim	2012-03-11 13:50:46.000000000 +0000
+++ vim74/runtime/ftplugin/html.vim	2014-10-10 14:53:40.818722742 +0000
@@ -20,49 +20,9 @@
     setlocal formatoptions-=t formatoptions+=croql
 endif
 
-
 if exists('&omnifunc')
-    " Distinguish between HTML versions
-    " To use with other HTML versions add another
-    " elseif condition to match proper DOCTYPE
-    setlocal omnifunc=htmlcomplete#CompleteTags
-
-    if &filetype == 'xhtml'
-            let b:html_omni_flavor = 'xhtml10s'
-    else
-            let b:html_omni_flavor = 'html401t'
-    endif
-    let i = 1
-    let line = ""
-    while i < 10 && i < line("$")
-        let line = getline(i)
-        if line =~ '<!DOCTYPE.*\<DTD '
-            break
-        endif
-        let i += 1
-    endwhile
-    if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
-        if line =~ ' HTML 3\.2'
-            let b:html_omni_flavor = 'html32'
-        elseif line =~ ' XHTML 1\.1'
-            let b:html_omni_flavor = 'xhtml11'
-        else    " two-step detection with strict/frameset/transitional
-            if line =~ ' XHTML 1\.0'
-                let b:html_omni_flavor = 'xhtml10'
-            elseif line =~ ' HTML 4\.01'
-                let b:html_omni_flavor = 'html401'
-            elseif line =~ ' HTML 4.0\>'
-                let b:html_omni_flavor = 'html40'
-            endif
-            if line =~ '\<Transitional\>'
-                let b:html_omni_flavor .= 't'
-            elseif line =~ '\<Frameset\>'
-                let b:html_omni_flavor .= 'f'
-            else
-                let b:html_omni_flavor .= 's'
-            endif
-        endif
-    endif
+  setlocal omnifunc=htmlcomplete#CompleteTags
+  call htmlcomplete#DetectOmniFlavor()
 endif
 
 " HTML:  thanks to Johannes Zellner and Benji Fisher.
diff -Naur vim74.orig/runtime/ftplugin/j.vim vim74/runtime/ftplugin/j.vim
--- vim74.orig/runtime/ftplugin/j.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/j.vim	2014-10-10 14:53:40.825389392 +0000
@@ -0,0 +1,75 @@
+" Vim filetype plugin
+" Language:	J
+" Maintainer:	David Brgin <676c7473@gmail.com>
+" URL:		https://github.com/glts/vim-j
+" Last Change:	2014-04-05
+
+if exists('b:did_ftplugin')
+  finish
+endif
+let b:did_ftplugin = 1
+
+let s:save_cpo = &cpo
+set cpo&vim
+
+setlocal iskeyword=48-57,A-Z,_,a-z
+setlocal comments=:NB.
+setlocal commentstring=NB.\ %s
+setlocal formatoptions-=t
+setlocal shiftwidth=2 softtabstop=2 expandtab
+setlocal matchpairs=(:)
+
+let b:undo_ftplugin = 'setlocal matchpairs< expandtab< softtabstop< shiftwidth< formatoptions< commentstring< comments< iskeyword<'
+
+" Section movement with ]] ][ [[ []. The start/end patterns below are amended
+" inside the function in order to avoid matching on the current cursor line.
+let s:sectionstart = '.\{-}\<\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\>.*'
+let s:sectionend = '\s*)\s*'
+
+function! s:SearchSection(end, backwards, visualmode) abort
+  if a:visualmode !=# ''
+    normal! gv
+  endif
+  let flags = a:backwards ? 'bsW' : 'sW'
+  if a:end
+    call search('^' . s:sectionend . (a:backwards ? '\n\_.\{-}\%#' : '$'), flags)
+  else
+    call search('^' . s:sectionstart . (a:backwards ? '\n\_.\{-}\%#' : '$'), flags)
+  endif
+endfunction
+
+noremap <script> <buffer> <silent> ]] :<C-U>call <SID>SearchSection(0, 0, '')<CR>
+xnoremap <script> <buffer> <silent> ]] :<C-U>call <SID>SearchSection(0, 0, visualmode())<CR>
+sunmap <buffer> ]]
+noremap <script> <buffer> <silent> ][ :<C-U>call <SID>SearchSection(1, 0, '')<CR>
+xnoremap <script> <buffer> <silent> ][ :<C-U>call <SID>SearchSection(1, 0, visualmode())<CR>
+sunmap <buffer> ][
+noremap <script> <buffer> <silent> [[ :<C-U>call <SID>SearchSection(0, 1, '')<CR>
+xnoremap <script> <buffer> <silent> [[ :<C-U>call <SID>SearchSection(0, 1, visualmode())<CR>
+sunmap <buffer> [[
+noremap <script> <buffer> <silent> [] :<C-U>call <SID>SearchSection(1, 1, '')<CR>
+xnoremap <script> <buffer> <silent> [] :<C-U>call <SID>SearchSection(1, 1, visualmode())<CR>
+sunmap <buffer> []
+
+let b:undo_ftplugin .= ' | silent! execute "unmap <buffer> ]]"'
+                   \ . ' | silent! execute "unmap <buffer> ]["'
+                   \ . ' | silent! execute "unmap <buffer> [["'
+                   \ . ' | silent! execute "unmap <buffer> []"'
+
+" Browse dialog filter on Windows (see ":help browsefilter")
+if has('gui_win32') && !exists('b:browsefilter')
+  let b:browsefilter = "J Script Files (*.ijs)\t*.ijs\n"
+                   \ . "All Files (*.*)\t*.*\n"
+  let b:undo_ftplugin .= ' | unlet! b:browsefilter'
+endif
+
+" Enhanced "%" matching (see ":help matchit")
+if exists('loaded_matchit') && !exists('b:match_words')
+  let b:match_ignorecase = 0
+  let b:match_words = '^.\{-}\<\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(\:\s*0\|def\s\+0\|define\)\>:^\s*\:\s*$:^\s*)\s*$'
+                  \ . ',\<\%(for\%(_\a\k*\)\=\|if\|select\|try\|whil\%(e\|st\)\)\.:\<\%(case\|catch[dt]\=\|else\%(if\)\=\|fcase\)\.:\<end\.'
+  let b:undo_ftplugin .= ' | unlet! b:match_ignorecase b:match_words'
+endif
+
+let &cpo = s:save_cpo
+unlet s:save_cpo
diff -Naur vim74.orig/runtime/ftplugin/jproperties.vim vim74/runtime/ftplugin/jproperties.vim
--- vim74.orig/runtime/ftplugin/jproperties.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/jproperties.vim	2014-10-10 14:53:40.828722717 +0000
@@ -0,0 +1,15 @@
+" Vim filetype plugin
+" Language:	Java properties file
+" Maintainer:	David Brgin <676c7473@gmail.com>
+" Last Change:	2013-11-19
+
+if exists("b:did_ftplugin")
+  finish
+endif
+let b:did_ftplugin = 1
+
+setlocal formatoptions-=t
+setlocal comments=:#,:!
+setlocal commentstring=#\ %s
+
+let b:undo_ftplugin = "setl cms< com< fo<"
diff -Naur vim74.orig/runtime/ftplugin/json.vim vim74/runtime/ftplugin/json.vim
--- vim74.orig/runtime/ftplugin/json.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/json.vim	2014-10-10 14:53:40.832056042 +0000
@@ -0,0 +1,17 @@
+" Vim filetype plugin
+" Language:		JSON
+" Maintainer:		David Barnett <daviebdawg+vim@gmail.com>
+" Last Change:		2014 Jul 16
+
+if exists('b:did_ftplugin')
+  finish
+endif
+let b:did_ftplugin = 1
+
+let b:undo_ftplugin = 'setlocal formatoptions< comments< commentstring<'
+
+setlocal formatoptions-=t
+
+" JSON has no comments.
+setlocal comments=
+setlocal commentstring=
diff -Naur vim74.orig/runtime/ftplugin/lisp.vim vim74/runtime/ftplugin/lisp.vim
--- vim74.orig/runtime/ftplugin/lisp.vim	2013-02-13 11:35:55.000000000 +0000
+++ vim74/runtime/ftplugin/lisp.vim	2014-10-10 14:53:40.845389342 +0000
@@ -4,7 +4,7 @@
 " URL:		 http://sites.google.com/site/khorser/opensource/vim
 " Original author:    Dorai Sitaram <ds26@gte.com>
 " Original URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
-" Last Change:   Feb 12, 2013
+" Last Change:   Oct 23, 2013
 
 " Only do this when not done yet for this buffer
 if exists("b:did_ftplugin")
@@ -21,9 +21,6 @@
 setl lisp
 setl commentstring=;%s
 
-" make comments behaviour like in c.vim
-" e.g. insertion of ;;; and ;; on normal "O" or "o" when staying in comment
 setl comments^=:;;;,:;;,sr:#\|,mb:\|,ex:\|#
-setl formatoptions+=croql
 
 let b:undo_ftplugin = "setlocal comments< define< formatoptions< iskeyword< lisp< commentstring<"
diff -Naur vim74.orig/runtime/ftplugin/python.vim vim74/runtime/ftplugin/python.vim
--- vim74.orig/runtime/ftplugin/python.vim	2012-04-30 11:49:26.000000000 +0000
+++ vim74/runtime/ftplugin/python.vim	2014-10-10 14:53:40.912055841 +0000
@@ -1,7 +1,8 @@
 " Vim filetype plugin file
 " Language:	python
 " Maintainer:	Johannes Zellner <johannes@zellner.org>
-" Last Change:	Wed, 21 Apr 2004 13:13:08 CEST
+" Last Change:	2014 Feb 09
+" Last Change By Johannes: Wed, 21 Apr 2004 13:13:08 CEST
 
 if exists("b:did_ftplugin") | finish | endif
 let b:did_ftplugin = 1
@@ -10,11 +11,11 @@
 
 setlocal cinkeys-=0#
 setlocal indentkeys-=0#
-setlocal include=\s*\\(from\\\|import\\)
+setlocal include=^\\s*\\(from\\\|import\\)
 setlocal includeexpr=substitute(v:fname,'\\.','/','g')
 setlocal suffixesadd=.py
-setlocal comments-=:%
-setlocal commentstring=#%s
+setlocal comments=b:#,fb:-
+setlocal commentstring=#\ %s
 
 setlocal omnifunc=pythoncomplete#Complete
 
@@ -25,24 +26,40 @@
 nnoremap <silent> <buffer> ]m :call <SID>Python_jump('/^\s*\(class\\|def\)')<cr>
 nnoremap <silent> <buffer> [m :call <SID>Python_jump('?^\s*\(class\\|def\)')<cr>
 
-if exists('*<SID>Python_jump') | finish | endif
-
-fun! <SID>Python_jump(motion) range
-    let cnt = v:count1
-    let save = @/    " save last search pattern
-    mark '
-    while cnt > 0
-	silent! exe a:motion
-	let cnt = cnt - 1
-    endwhile
-    call histdel('/', -1)
-    let @/ = save    " restore last search pattern
-endfun
+if !exists('*<SID>Python_jump')
+  fun! <SID>Python_jump(motion) range
+      let cnt = v:count1
+      let save = @/    " save last search pattern
+      mark '
+      while cnt > 0
+	  silent! exe a:motion
+	  let cnt = cnt - 1
+      endwhile
+      call histdel('/', -1)
+      let @/ = save    " restore last search pattern
+  endfun
+endif
 
-if has("gui_win32") && !exists("b:browsefilter")
+if has("browsefilter") && !exists("b:browsefilter")
     let b:browsefilter = "Python Files (*.py)\t*.py\n" .
 		       \ "All Files (*.*)\t*.*\n"
 endif
 
+" As suggested by PEP8.
+setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=8
+
+" First time: try finding "pydoc".
+if !exists('g:pydoc_executable')
+    if executable('pydoc')
+        let g:pydoc_executable = 1
+    else
+        let g:pydoc_executable = 0
+    endif
+endif
+" If "pydoc" was found use it for keywordprg.
+if g:pydoc_executable
+    setlocal keywordprg=pydoc
+endif
+
 let &cpo = s:keepcpo
 unlet s:keepcpo
diff -Naur vim74.orig/runtime/ftplugin/r.vim vim74/runtime/ftplugin/r.vim
--- vim74.orig/runtime/ftplugin/r.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/r.vim	2014-10-10 14:53:40.915389166 +0000
@@ -0,0 +1,31 @@
+" Vim filetype plugin file
+" Language: R
+" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Sun Feb 23, 2014  04:07PM
+
+" Only do this when not yet done for this buffer
+if exists("b:did_ftplugin")
+  finish
+endif
+
+" Don't load another plugin for this buffer
+let b:did_ftplugin = 1
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+setlocal iskeyword=@,48-57,_,.
+setlocal formatoptions-=t
+setlocal commentstring=#\ %s
+setlocal comments=:#',:###,:##,:#
+
+if has("gui_win32") && !exists("b:browsefilter")
+  let b:browsefilter = "R Source Files (*.R)\t*.R\n" .
+        \ "Files that include R (*.Rnw *.Rd *.Rmd *.Rrst)\t*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
+        \ "All Files (*.*)\t*.*\n"
+endif
+
+let b:undo_ftplugin = "setl cms< com< fo< isk< | unlet! b:browsefilter"
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
diff -Naur vim74.orig/runtime/ftplugin/registry.vim vim74/runtime/ftplugin/registry.vim
--- vim74.orig/runtime/ftplugin/registry.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/registry.vim	2014-10-10 14:53:40.918722491 +0000
@@ -0,0 +1,36 @@
+" Vim filetype plugin file
+" Language:         Windows Registry export with regedit (*.reg)
+" Maintainer:       Cade Forester <ahx2323@gmail.com>
+" Latest Revision:  2014-01-09
+
+if exists("b:did_ftplugin")
+  finish
+endif
+let b:did_ftplugin = 1
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+let b:undo_ftplugin =
+  \ 'let b:browsefilter = "" | ' .
+  \ 'setlocal ' .
+  \    'comments< '.
+  \    'commentstring< ' .
+  \    'formatoptions< '
+
+
+if has( 'gui_win32' )
+\ && !exists( 'b:browsefilter' )
+   let b:browsefilter =
+      \ 'registry files (*.reg)\t*.reg\n' .
+      \ 'All files (*.*)\t*.*\n'
+endif
+
+setlocal comments=:;
+setlocal commentstring=;\ %s
+
+setlocal formatoptions-=t
+setlocal formatoptions+=croql
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
diff -Naur vim74.orig/runtime/ftplugin/rhelp.vim vim74/runtime/ftplugin/rhelp.vim
--- vim74.orig/runtime/ftplugin/rhelp.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/rhelp.vim	2014-10-10 14:53:40.922055816 +0000
@@ -0,0 +1,29 @@
+" Vim filetype plugin file
+" Language: R help file
+" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Wed Jul 09, 2014  06:23PM
+
+" Only do this when not yet done for this buffer
+if exists("b:did_ftplugin")
+  finish
+endif
+
+" Don't load another plugin for this buffer
+let b:did_ftplugin = 1
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+setlocal iskeyword=@,48-57,_,.
+
+if has("gui_win32") && !exists("b:browsefilter")
+  let b:browsefilter = "R Source Files (*.R *.Rnw *.Rd *.Rmd *.Rrst)\t*.R;*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
+        \ "All Files (*.*)\t*.*\n"
+endif
+
+let b:undo_ftplugin = "setl isk< | unlet! b:browsefilter"
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim: sw=2
diff -Naur vim74.orig/runtime/ftplugin/rmd.vim vim74/runtime/ftplugin/rmd.vim
--- vim74.orig/runtime/ftplugin/rmd.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/rmd.vim	2014-10-10 14:53:40.925389141 +0000
@@ -0,0 +1,43 @@
+" Vim filetype plugin file
+" Language: R help file
+" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Wed Jul 09, 2014  06:23PM
+" Original work by Alex Zvoleff (adjusted for rmd by Michel Kuhlmann)
+
+" Only do this when not yet done for this buffer
+if exists("b:did_ftplugin")
+  finish
+endif
+
+runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
+
+setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=>\ %s
+setlocal formatoptions+=tcqln
+setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^\\s*[-*+]\\s\\+
+setlocal iskeyword=@,48-57,_,.
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+" Enables pandoc if it is installed
+unlet! b:did_ftplugin
+runtime ftplugin/pandoc.vim
+
+" Don't load another plugin for this buffer
+let b:did_ftplugin = 1
+
+if has("gui_win32") && !exists("b:browsefilter")
+  let b:browsefilter = "R Source Files (*.R *.Rnw *.Rd *.Rmd *.Rrst)\t*.R;*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
+        \ "All Files (*.*)\t*.*\n"
+endif
+
+if exists('b:undo_ftplugin')
+  let b:undo_ftplugin .= " | setl cms< com< fo< flp< isk< | unlet! b:browsefilter"
+else
+  let b:undo_ftplugin = "setl cms< com< fo< flp< isk< | unlet! b:browsefilter"
+endif
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim: sw=2
diff -Naur vim74.orig/runtime/ftplugin/rnoweb.vim vim74/runtime/ftplugin/rnoweb.vim
--- vim74.orig/runtime/ftplugin/rnoweb.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/rnoweb.vim	2014-10-10 14:53:40.925389141 +0000
@@ -0,0 +1,40 @@
+" Vim filetype plugin file
+" Language: Rnoweb
+" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Wed Jul 09, 2014  06:23PM
+
+" Only do this when not yet done for this buffer
+if exists("b:did_ftplugin")
+  finish
+endif
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+runtime! ftplugin/tex.vim
+
+" Don't load another plugin for this buffer
+let b:did_ftplugin = 1
+
+" Enables Vim-Latex-Suite, LaTeX-Box if installed
+runtime ftplugin/tex_*.vim
+
+setlocal iskeyword=@,48-57,_,.
+setlocal suffixesadd=.bib,.tex
+setlocal comments=b:%,b:#,b:##,b:###,b:#'
+
+if has("gui_win32") && !exists("b:browsefilter")
+  let b:browsefilter = "R Source Files (*.R *.Rnw *.Rd *.Rmd *.Rrst)\t*.R;*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
+        \ "All Files (*.*)\t*.*\n"
+endif
+
+if exists('b:undo_ftplugin')
+  let b:undo_ftplugin .= " | setl isk< sua< com< | unlet! b:browsefilter"
+else
+  let b:undo_ftplugin = "setl isk< sua< com< | unlet! b:browsefilter"
+endif
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim: sw=2
diff -Naur vim74.orig/runtime/ftplugin/rrst.vim vim74/runtime/ftplugin/rrst.vim
--- vim74.orig/runtime/ftplugin/rrst.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/rrst.vim	2014-10-10 14:53:40.928722466 +0000
@@ -0,0 +1,37 @@
+" Vim filetype plugin file
+" Language: reStructuredText documentation format with R code
+" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Wed Jul 09, 2014  06:23PM
+" Original work by Alex Zvoleff
+
+" Only do this when not yet done for this buffer
+if exists("b:did_ftplugin")
+  finish
+endif
+
+" Don't load another plugin for this buffer
+let b:did_ftplugin = 1
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=>\ %s
+setlocal formatoptions+=tcqln
+setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^\\s*[-*+]\\s\\+
+setlocal iskeyword=@,48-57,_,.
+
+if has("gui_win32") && !exists("b:browsefilter")
+  let b:browsefilter = "R Source Files (*.R *.Rnw *.Rd *.Rmd *.Rrst)\t*.R;*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
+        \ "All Files (*.*)\t*.*\n"
+endif
+
+if exists('b:undo_ftplugin')
+  let b:undo_ftplugin .= " | setl cms< com< fo< flp< isk< | unlet! b:browsefilter"
+else
+  let b:undo_ftplugin = "setl cms< com< fo< flp< isk< | unlet! b:browsefilter"
+endif
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim: sw=2
diff -Naur vim74.orig/runtime/ftplugin/scheme.vim vim74/runtime/ftplugin/scheme.vim
--- vim74.orig/runtime/ftplugin/scheme.vim	2013-02-13 11:35:55.000000000 +0000
+++ vim74/runtime/ftplugin/scheme.vim	2014-10-10 14:53:40.935389116 +0000
@@ -4,7 +4,7 @@
 " URL:		 http://sites.google.com/site/khorser/opensource/vim
 " Original author:    Dorai Sitaram <ds26@gte.com>
 " Original URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
-" Last Change:   Feb 12, 2013
+" Last Change:   Oct 23, 2013
 
 " Only do this when not done yet for this buffer
 if exists("b:did_ftplugin")
@@ -22,10 +22,7 @@
 setl lisp
 setl commentstring=;%s
 
-" make comments behaviour like in c.vim
-" e.g. insertion of ;;; and ;; on normal "O" or "o" when staying in comment
 setl comments^=:;;;,:;;,sr:#\|,mb:\|,ex:\|#
-setl formatoptions+=croql
 
 " Scheme-specific settings
 if exists("b:is_mzscheme") || exists("is_mzscheme")
diff -Naur vim74.orig/runtime/ftplugin/spec.vim vim74/runtime/ftplugin/spec.vim
--- vim74.orig/runtime/ftplugin/spec.vim	2012-03-07 12:16:03.000000000 +0000
+++ vim74/runtime/ftplugin/spec.vim	2014-10-10 14:53:40.952055741 +0000
@@ -1,7 +1,8 @@
 " Plugin to update the %changelog section of RPM spec files
 " Filename: spec.vim
-" Maintainer: Gustavo Niemeyer <niemeyer@conectiva.com>
-" Last Change: 2012 Mar 07
+" Maintainer: Igor Gnatenko i.gnatenko.brain@gmail.com
+" Former Maintainer: Gustavo Niemeyer <niemeyer@conectiva.com> (until March 2014)
+" Last Change: Sun Mar 2 11:24 MSK 2014 Igor Gnatenko
 
 if exists("b:did_ftplugin")
 	finish
@@ -150,6 +151,10 @@
 		execute a:strline
 		let definestr = "^[ \t]*%define[ \t]\\+" . varname . "[ \t]\\+\\(.*\\)$"
 		let linenum = search(definestr, "bW")
+		if (linenum == 0)
+			let definestr = substitute(definestr, "%define", "%global", "")
+			let linenum = search(definestr, "bW")
+		endif
 		if (linenum != -1)
 			let ret = ret .  substitute(getline(linenum), definestr, "\\1", "")
 		else
diff -Naur vim74.orig/runtime/ftplugin/systemverilog.vim vim74/runtime/ftplugin/systemverilog.vim
--- vim74.orig/runtime/ftplugin/systemverilog.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/systemverilog.vim	2014-10-10 14:53:40.962055716 +0000
@@ -0,0 +1,11 @@
+" Vim filetype plugin file
+" Language:    SystemVerilog
+" Maintainer:  kocha <kocha.lsifrontend@gmail.com>
+" Last Change: 12-Aug-2013. 
+
+if exists("b:did_ftplugin")
+  finish
+endif
+
+" Behaves just like Verilog
+runtime! ftplugin/verilog.vim
diff -Naur vim74.orig/runtime/ftplugin/text.vim vim74/runtime/ftplugin/text.vim
--- vim74.orig/runtime/ftplugin/text.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/text.vim	2014-10-10 14:53:40.968722365 +0000
@@ -0,0 +1,17 @@
+" Vim filetype plugin
+" Language:		Text
+" Maintainer:		David Barnett <daviebdawg+vim@gmail.com>
+" Last Change:		2014 Jul 09
+
+if exists('b:did_ftplugin')
+  finish
+endif
+let b:did_ftplugin = 1
+
+let b:undo_ftplugin = 'setlocal comments< commentstring<'
+
+" We intentionally don't set formatoptions-=t since text should wrap as text.
+
+" Pseudo comment leaders to indent bulleted lists.
+setlocal comments=fb:-,fb:*
+setlocal commentstring=
diff -Naur vim74.orig/runtime/ftplugin/vim.vim vim74/runtime/ftplugin/vim.vim
--- vim74.orig/runtime/ftplugin/vim.vim	2013-06-26 17:15:13.000000000 +0000
+++ vim74/runtime/ftplugin/vim.vim	2014-10-10 14:53:40.982055665 +0000
@@ -1,7 +1,7 @@
 " Vim filetype plugin
 " Language:	Vim
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2013 Jun 26
+" Last Change:	2014 Sep 07
 
 " Only do this when not done yet for this buffer
 if exists("b:did_ftplugin")
@@ -62,9 +62,12 @@
 	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
 	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' .
 	\ '(:)'
-  " Ignore ":syntax region" commands, the 'end' argument clobbers if-endif
-  let b:match_skip = 'getline(".") =~ "^\\s*sy\\%[ntax]\\s\\+region" ||
-	\ synIDattr(synID(line("."),col("."),1),"name") =~? "comment\\|string"'
+  " Ignore syntax region commands and settings, any 'en*' would clobber
+  " if-endif.
+  " - set spl=de,en
+  " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ 
+  let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
+        \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
 endif
 
 let &cpo = s:cpo_save
diff -Naur vim74.orig/runtime/ftplugin/vroom.vim vim74/runtime/ftplugin/vroom.vim
--- vim74.orig/runtime/ftplugin/vroom.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/ftplugin/vroom.vim	2014-10-10 14:53:40.985388990 +0000
@@ -0,0 +1,35 @@
+" Vim filetype plugin file
+" Language:	Vroom (vim testing and executable documentation)
+" Maintainer:	David Barnett (https://github.com/google/vim-ft-vroom)
+" Last Change:	2014 Jul 23
+
+if exists('b:did_ftplugin')
+  finish
+endif
+let b:did_ftplugin = 1
+
+let s:cpo_save = &cpo
+set cpo-=C
+
+
+let b:undo_ftplugin = 'setlocal formatoptions< shiftwidth< softtabstop<' .
+    \ ' expandtab< iskeyword< comments< commentstring<'
+
+setlocal formatoptions-=t
+
+" The vroom interpreter doesn't accept anything but 2-space indent.
+setlocal shiftwidth=2
+setlocal softtabstop=2
+setlocal expandtab
+
+" To allow tag lookup and autocomplete for whole autoload functions, '#' must be
+" a keyword character. This also conforms to the behavior of ftplugin/vim.vim.
+setlocal iskeyword+=#
+
+" Vroom files have no comments (text is inert documentation unless indented).
+setlocal comments=
+setlocal commentstring=
+
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
diff -Naur vim74.orig/runtime/indent/ada.vim vim74/runtime/indent/ada.vim
--- vim74.orig/runtime/indent/ada.vim	2012-05-01 18:54:18.000000000 +0000
+++ vim74/runtime/indent/ada.vim	2014-10-10 14:53:41.025388890 +0000
@@ -148,7 +148,7 @@
       " Get previous non-blank/non-comment-only line
       while 1
 	 let line = substitute( getline(lnum), g:ada#Comment, '', '' )
-	 
+
 	 if line !~ '^\s*$' && line !~ '^\s*#'
 	    break
 	 endif
diff -Naur vim74.orig/runtime/indent/clojure.vim vim74/runtime/indent/clojure.vim
--- vim74.orig/runtime/indent/clojure.vim	2013-02-06 14:35:23.000000000 +0000
+++ vim74/runtime/indent/clojure.vim	2014-10-10 14:53:41.042055515 +0000
@@ -1,23 +1,27 @@
 " Vim indent file
-" Language:     Clojure
-" Author:       Meikel Brandmeyer <mb@kotka.de>
-" URL:          http://kotka.de/projects/clojure/vimclojure.html
+" Language:	Clojure
+" Author:	Meikel Brandmeyer <mb@kotka.de>
+" URL:		http://kotka.de/projects/clojure/vimclojure.html
 "
-" Maintainer:   Sung Pae <self@sungpae.com>
-" URL:          https://github.com/guns/vim-clojure-static
-" License:      Same as Vim
-" Last Change:  30 January 2013
+" Maintainer:	Sung Pae <self@sungpae.com>
+" URL:		https://github.com/guns/vim-clojure-static
+" License:	Same as Vim
+" Last Change:	27 March 2014
+
+" TODO: Indenting after multibyte characters is broken:
+"       (let [ (if foo
+"                bar    ; Indent error
+"                baz)])
 
-" Only load this indent file when no other was loaded.
 if exists("b:did_indent")
-    finish
+	finish
 endif
 let b:did_indent = 1
 
 let s:save_cpo = &cpo
 set cpo&vim
 
-let b:undo_indent = 'setlocal autoindent< smartindent< lispwords< expandtab< softtabstop< shiftwidth< indentexpr< indentkeys<'
+let b:undo_indent = 'setlocal autoindent< smartindent< expandtab< softtabstop< shiftwidth< indentexpr< indentkeys<'
 
 setlocal noautoindent nosmartindent
 setlocal softtabstop=2 shiftwidth=2 expandtab
@@ -25,374 +29,290 @@
 
 if exists("*searchpairpos")
 
-    if !exists('g:clojure_maxlines')
-        let g:clojure_maxlines = 100
-    endif
-
-    if !exists('g:clojure_fuzzy_indent')
-        let g:clojure_fuzzy_indent = 1
-    endif
-
-    if !exists('g:clojure_fuzzy_indent_patterns')
-        let g:clojure_fuzzy_indent_patterns = ['^with', '^def', '^let']
-    endif
-
-    if !exists('g:clojure_fuzzy_indent_blacklist')
-        let g:clojure_fuzzy_indent_blacklist = ['-fn$', '\v^with-%(meta|out-str|loading-context)$']
-    endif
-
-    if !exists('g:clojure_special_indent_words')
-        let g:clojure_special_indent_words = 'deftype,defrecord,reify,proxy,extend-type,extend-protocol,letfn'
-    endif
-
-    if !exists('g:clojure_align_multiline_strings')
-        let g:clojure_align_multiline_strings = 0
-    endif
-
-    function! s:SynIdName()
-        return synIDattr(synID(line("."), col("."), 0), "name")
-    endfunction
-
-    function! s:CurrentChar()
-        return getline('.')[col('.')-1]
-    endfunction
-
-    function! s:CurrentWord()
-        return getline('.')[col('.')-1 : searchpos('\v>', 'n', line('.'))[1]-2]
-    endfunction
-
-    function! s:IsParen()
-        return s:CurrentChar() =~ '\v[\(\)\[\]\{\}]' &&
-             \ s:SynIdName() !~? '\vstring|comment'
-    endfunction
-
-    " Returns 1 if string matches a pattern in 'patterns', which may be a
-    " list of patterns, or a comma-delimited string of implicitly anchored
-    " patterns.
-    function! s:MatchesOne(patterns, string)
-        let list = type(a:patterns) == type([])
-                   \ ? a:patterns
-                   \ : map(split(a:patterns, ','), '"^" . v:val . "$"')
-        for pat in list
-            if a:string =~ pat | return 1 | endif
-        endfor
-    endfunction
-
-    function! s:SavePosition()
-        let [ _b, l, c, _o ] = getpos(".")
-        let b = bufnr("%")
-        return [b, l, c]
-    endfunction
-
-    function! s:RestorePosition(value)
-        let [b, l, c] = a:value
-        if bufnr("%") != b
-            execute b "buffer!"
-        endif
-        call setpos(".", [0, l, c, 0])
-    endfunction
-
-    function! s:MatchPairs(open, close, stopat)
-        " Stop only on vector and map [ resp. {. Ignore the ones in strings and
-        " comments.
-        if a:stopat == 0
-            let stopat = max([line(".") - g:clojure_maxlines, 0])
-        else
-            let stopat = a:stopat
-        endif
-
-        let pos = searchpairpos(a:open, '', a:close, 'bWn', "!s:IsParen()", stopat)
-        return [pos[0], virtcol(pos)]
-    endfunction
-
-    function! s:ClojureCheckForStringWorker()
-        " Check whether there is the last character of the previous line is
-        " highlighted as a string. If so, we check whether it's a ". In this
-        " case we have to check also the previous character. The " might be the
-        " closing one. In case the we are still in the string, we search for the
-        " opening ". If this is not found we take the indent of the line.
-        let nb = prevnonblank(v:lnum - 1)
-
-        if nb == 0
-            return -1
-        endif
-
-        call cursor(nb, 0)
-        call cursor(0, col("$") - 1)
-        if s:SynIdName() !~? "string"
-            return -1
-        endif
-
-        " This will not work for a " in the first column...
-        if s:CurrentChar() == '"'
-            call cursor(0, col("$") - 2)
-            if s:SynIdName() !~? "string"
-                return -1
-            endif
-            if s:CurrentChar() != '\\'
-                return -1
-            endif
-            call cursor(0, col("$") - 1)
-        endif
-
-        let p = searchpos('\(^\|[^\\]\)\zs"', 'bW')
-
-        if p != [0, 0]
-            return p[1] - 1
-        endif
-
-        return indent(".")
-    endfunction
-
-    function! s:CheckForString()
-        let pos = s:SavePosition()
-        try
-            let val = s:ClojureCheckForStringWorker()
-        finally
-            call s:RestorePosition(pos)
-        endtry
-        return val
-    endfunction
-
-    function! s:ClojureIsMethodSpecialCaseWorker(position)
-        " Find the next enclosing form.
-        call search('\S', 'Wb')
-
-        " Special case: we are at a '(('.
-        if s:CurrentChar() == '('
-            return 0
-        endif
-        call cursor(a:position)
-
-        let nextParen = s:MatchPairs('(', ')', 0)
-
-        " Special case: we are now at toplevel.
-        if nextParen == [0, 0]
-            return 0
-        endif
-        call cursor(nextParen)
-
-        call search('\S', 'W')
-        if g:clojure_special_indent_words =~ '\<' . s:CurrentWord() . '\>'
-            return 1
-        endif
-
-        return 0
-    endfunction
-
-    function! s:IsMethodSpecialCase(position)
-        let pos = s:SavePosition()
-        try
-            let val = s:ClojureIsMethodSpecialCaseWorker(a:position)
-        finally
-            call s:RestorePosition(pos)
-        endtry
-        return val
-    endfunction
-
-    function! GetClojureIndent()
-        " Get rid of special case.
-        if line(".") == 1
-            return 0
-        endif
-
-        " We have to apply some heuristics here to figure out, whether to use
-        " normal lisp indenting or not.
-        let i = s:CheckForString()
-        if i > -1
-            return i + !!g:clojure_align_multiline_strings
-        endif
-
-        call cursor(0, 1)
-
-        " Find the next enclosing [ or {. We can limit the second search
-        " to the line, where the [ was found. If no [ was there this is
-        " zero and we search for an enclosing {.
-        let paren = s:MatchPairs('(', ')', 0)
-        let bracket = s:MatchPairs('\[', '\]', paren[0])
-        let curly = s:MatchPairs('{', '}', bracket[0])
-
-        " In case the curly brace is on a line later then the [ or - in
-        " case they are on the same line - in a higher column, we take the
-        " curly indent.
-        if curly[0] > bracket[0] || curly[1] > bracket[1]
-            if curly[0] > paren[0] || curly[1] > paren[1]
-                return curly[1]
-            endif
-        endif
-
-        " If the curly was not chosen, we take the bracket indent - if
-        " there was one.
-        if bracket[0] > paren[0] || bracket[1] > paren[1]
-            return bracket[1]
-        endif
-
-        " There are neither { nor [ nor (, ie. we are at the toplevel.
-        if paren == [0, 0]
-            return 0
-        endif
-
-        " Now we have to reimplement lispindent. This is surprisingly easy, as
-        " soon as one has access to syntax items.
-        "
-        " - Check whether we are in a special position after a word in
-        "   g:clojure_special_indent_words. These are special cases.
-        " - Get the next keyword after the (.
-        " - If its first character is also a (, we have another sexp and align
-        "   one column to the right of the unmatched (.
-        " - In case it is in lispwords, we indent the next line to the column of
-        "   the ( + sw.
-        " - If not, we check whether it is last word in the line. In that case
-        "   we again use ( + sw for indent.
-        " - In any other case we use the column of the end of the word + 2.
-        call cursor(paren)
-
-        if s:IsMethodSpecialCase(paren)
-            return paren[1] + &shiftwidth - 1
-        endif
-
-        " In case we are at the last character, we use the paren position.
-        if col("$") - 1 == paren[1]
-            return paren[1]
-        endif
-
-        " In case after the paren is a whitespace, we search for the next word.
-        normal! l
-        if s:CurrentChar() == ' '
-            normal! w
-        endif
-
-        " If we moved to another line, there is no word after the (. We
-        " use the ( position for indent.
-        if line(".") > paren[0]
-            return paren[1]
-        endif
-
-        " We still have to check, whether the keyword starts with a (, [ or {.
-        " In that case we use the ( position for indent.
-        let w = s:CurrentWord()
-        if stridx('([{', w[0]) > -1
-            return paren[1]
-        endif
-
-        " Test words without namespace qualifiers and leading reader macro
-        " metacharacters.
-        "
-        " e.g. clojure.core/defn and #'defn should both indent like defn.
-        let ww = substitute(w, "\\v%(.*/|[#'`~@^,]*)(.*)", '\1', '')
-
-        if &lispwords =~ '\V\<' . ww . '\>'
-            return paren[1] + &shiftwidth - 1
-        endif
-
-        if g:clojure_fuzzy_indent
-            \ && !s:MatchesOne(g:clojure_fuzzy_indent_blacklist, ww)
-            \ && s:MatchesOne(g:clojure_fuzzy_indent_patterns, ww)
-            return paren[1] + &shiftwidth - 1
-        endif
-
-        normal! W
-        if paren[0] < line(".")
-            return paren[1] + &shiftwidth - 1
-        endif
-
-        normal! ge
-        return virtcol(".") + 1
-    endfunction
+	if !exists('g:clojure_maxlines')
+		let g:clojure_maxlines = 100
+	endif
+
+	if !exists('g:clojure_fuzzy_indent')
+		let g:clojure_fuzzy_indent = 1
+	endif
+
+	if !exists('g:clojure_fuzzy_indent_patterns')
+		let g:clojure_fuzzy_indent_patterns = ['^with', '^def', '^let']
+	endif
+
+	if !exists('g:clojure_fuzzy_indent_blacklist')
+		let g:clojure_fuzzy_indent_blacklist = ['-fn$', '\v^with-%(meta|out-str|loading-context)$']
+	endif
+
+	if !exists('g:clojure_special_indent_words')
+		let g:clojure_special_indent_words = 'deftype,defrecord,reify,proxy,extend-type,extend-protocol,letfn'
+	endif
+
+	if !exists('g:clojure_align_multiline_strings')
+		let g:clojure_align_multiline_strings = 0
+	endif
+
+	if !exists('g:clojure_align_subforms')
+		let g:clojure_align_subforms = 0
+	endif
+
+	function! s:SynIdName()
+		return synIDattr(synID(line("."), col("."), 0), "name")
+	endfunction
+
+	function! s:CurrentChar()
+		return getline('.')[col('.')-1]
+	endfunction
+
+	function! s:CurrentWord()
+		return getline('.')[col('.')-1 : searchpos('\v>', 'n', line('.'))[1]-2]
+	endfunction
+
+	function! s:IsParen()
+		return s:CurrentChar() =~# '\v[\(\)\[\]\{\}]' &&
+		     \ s:SynIdName() !~? '\vstring|regex|comment|character'
+	endfunction
+
+	" Returns 1 if string matches a pattern in 'patterns', which may be a
+	" list of patterns, or a comma-delimited string of implicitly anchored
+	" patterns.
+	function! s:MatchesOne(patterns, string)
+		let list = type(a:patterns) == type([])
+			   \ ? a:patterns
+			   \ : map(split(a:patterns, ','), '"^" . v:val . "$"')
+		for pat in list
+			if a:string =~# pat | return 1 | endif
+		endfor
+	endfunction
+
+	function! s:MatchPairs(open, close, stopat)
+		" Stop only on vector and map [ resp. {. Ignore the ones in strings and
+		" comments.
+		if a:stopat == 0
+			let stopat = max([line(".") - g:clojure_maxlines, 0])
+		else
+			let stopat = a:stopat
+		endif
+
+		let pos = searchpairpos(a:open, '', a:close, 'bWn', "!s:IsParen()", stopat)
+		return [pos[0], virtcol(pos)]
+	endfunction
+
+	function! s:ClojureCheckForStringWorker()
+		" Check whether there is the last character of the previous line is
+		" highlighted as a string. If so, we check whether it's a ". In this
+		" case we have to check also the previous character. The " might be the
+		" closing one. In case the we are still in the string, we search for the
+		" opening ". If this is not found we take the indent of the line.
+		let nb = prevnonblank(v:lnum - 1)
+
+		if nb == 0
+			return -1
+		endif
+
+		call cursor(nb, 0)
+		call cursor(0, col("$") - 1)
+		if s:SynIdName() !~? "string"
+			return -1
+		endif
+
+		" This will not work for a " in the first column...
+		if s:CurrentChar() == '"'
+			call cursor(0, col("$") - 2)
+			if s:SynIdName() !~? "string"
+				return -1
+			endif
+			if s:CurrentChar() != '\\'
+				return -1
+			endif
+			call cursor(0, col("$") - 1)
+		endif
+
+		let p = searchpos('\(^\|[^\\]\)\zs"', 'bW')
+
+		if p != [0, 0]
+			return p[1] - 1
+		endif
+
+		return indent(".")
+	endfunction
+
+	function! s:CheckForString()
+		let pos = getpos('.')
+		try
+			let val = s:ClojureCheckForStringWorker()
+		finally
+			call setpos('.', pos)
+		endtry
+		return val
+	endfunction
+
+	function! s:StripNamespaceAndMacroChars(word)
+		return substitute(a:word, "\\v%(.*/|[#'`~@^,]*)(.*)", '\1', '')
+	endfunction
+
+	function! s:ClojureIsMethodSpecialCaseWorker(position)
+		" Find the next enclosing form.
+		call search('\S', 'Wb')
+
+		" Special case: we are at a '(('.
+		if s:CurrentChar() == '('
+			return 0
+		endif
+		call cursor(a:position)
+
+		let nextParen = s:MatchPairs('(', ')', 0)
+
+		" Special case: we are now at toplevel.
+		if nextParen == [0, 0]
+			return 0
+		endif
+		call cursor(nextParen)
+
+		call search('\S', 'W')
+		let w = s:StripNamespaceAndMacroChars(s:CurrentWord())
+		if g:clojure_special_indent_words =~# '\V\<' . w . '\>'
+			return 1
+		endif
+
+		return 0
+	endfunction
+
+	function! s:IsMethodSpecialCase(position)
+		let pos = getpos('.')
+		try
+			let val = s:ClojureIsMethodSpecialCaseWorker(a:position)
+		finally
+			call setpos('.', pos)
+		endtry
+		return val
+	endfunction
+
+	function! GetClojureIndent()
+		" Get rid of special case.
+		if line(".") == 1
+			return 0
+		endif
+
+		" We have to apply some heuristics here to figure out, whether to use
+		" normal lisp indenting or not.
+		let i = s:CheckForString()
+		if i > -1
+			return i + !!g:clojure_align_multiline_strings
+		endif
+
+		call cursor(0, 1)
+
+		" Find the next enclosing [ or {. We can limit the second search
+		" to the line, where the [ was found. If no [ was there this is
+		" zero and we search for an enclosing {.
+		let paren = s:MatchPairs('(', ')', 0)
+		let bracket = s:MatchPairs('\[', '\]', paren[0])
+		let curly = s:MatchPairs('{', '}', bracket[0])
+
+		" In case the curly brace is on a line later then the [ or - in
+		" case they are on the same line - in a higher column, we take the
+		" curly indent.
+		if curly[0] > bracket[0] || curly[1] > bracket[1]
+			if curly[0] > paren[0] || curly[1] > paren[1]
+				return curly[1]
+			endif
+		endif
+
+		" If the curly was not chosen, we take the bracket indent - if
+		" there was one.
+		if bracket[0] > paren[0] || bracket[1] > paren[1]
+			return bracket[1]
+		endif
+
+		" There are neither { nor [ nor (, ie. we are at the toplevel.
+		if paren == [0, 0]
+			return 0
+		endif
+
+		" Now we have to reimplement lispindent. This is surprisingly easy, as
+		" soon as one has access to syntax items.
+		"
+		" - Check whether we are in a special position after a word in
+		"   g:clojure_special_indent_words. These are special cases.
+		" - Get the next keyword after the (.
+		" - If its first character is also a (, we have another sexp and align
+		"   one column to the right of the unmatched (.
+		" - In case it is in lispwords, we indent the next line to the column of
+		"   the ( + sw.
+		" - If not, we check whether it is last word in the line. In that case
+		"   we again use ( + sw for indent.
+		" - In any other case we use the column of the end of the word + 2.
+		call cursor(paren)
+
+		if s:IsMethodSpecialCase(paren)
+			return paren[1] + &shiftwidth - 1
+		endif
+
+		" In case we are at the last character, we use the paren position.
+		if col("$") - 1 == paren[1]
+			return paren[1]
+		endif
+
+		" In case after the paren is a whitespace, we search for the next word.
+		call cursor(0, col('.') + 1)
+		if s:CurrentChar() == ' '
+			call search('\v\S', 'W')
+		endif
+
+		" If we moved to another line, there is no word after the (. We
+		" use the ( position for indent.
+		if line(".") > paren[0]
+			return paren[1]
+		endif
+
+		" We still have to check, whether the keyword starts with a (, [ or {.
+		" In that case we use the ( position for indent.
+		let w = s:CurrentWord()
+		if stridx('([{', w[0]) > -1
+			return paren[1]
+		endif
+
+		" Test words without namespace qualifiers and leading reader macro
+		" metacharacters.
+		"
+		" e.g. clojure.core/defn and #'defn should both indent like defn.
+		let ww = s:StripNamespaceAndMacroChars(w)
+
+		if &lispwords =~# '\V\<' . ww . '\>'
+			return paren[1] + &shiftwidth - 1
+		endif
+
+		if g:clojure_fuzzy_indent
+			\ && !s:MatchesOne(g:clojure_fuzzy_indent_blacklist, ww)
+			\ && s:MatchesOne(g:clojure_fuzzy_indent_patterns, ww)
+			return paren[1] + &shiftwidth - 1
+		endif
+
+		call search('\v\_s', 'cW')
+		call search('\v\S', 'W')
+		if paren[0] < line(".")
+			return paren[1] + (g:clojure_align_subforms ? 0 : &shiftwidth - 1)
+		endif
+
+		call search('\v\S', 'bW')
+		return virtcol(".") + 1
+	endfunction
 
-    setlocal indentexpr=GetClojureIndent()
+	setlocal indentexpr=GetClojureIndent()
 
 else
 
-    " In case we have searchpairpos not available we fall back to
-    " normal lisp indenting.
-    setlocal indentexpr=
-    setlocal lisp
-    let b:undo_indent .= '| setlocal lisp<'
+	" In case we have searchpairpos not available we fall back to
+	" normal lisp indenting.
+	setlocal indentexpr=
+	setlocal lisp
+	let b:undo_indent .= '| setlocal lisp<'
 
 endif
 
-" Specially indented symbols from clojure.core and clojure.test.
-"
-" Clojure symbols are indented in the defn style when they:
-"
-"   * Define vars and anonymous functions
-"   * Create new lexical scopes or scopes with altered environments
-"   * Create conditional branches from a predicate function or value
-"
-" The arglists for these functions are generally in the form of [x & body];
-" Functions that accept a flat list of forms do not treat the first argument
-" specially and hence are not indented specially.
-
-" Definitions
-setlocal lispwords=
-setlocal lispwords+=bound-fn
-setlocal lispwords+=def
-setlocal lispwords+=definline
-setlocal lispwords+=definterface
-setlocal lispwords+=defmacro
-setlocal lispwords+=defmethod
-setlocal lispwords+=defmulti
-setlocal lispwords+=defn
-setlocal lispwords+=defn-
-setlocal lispwords+=defonce
-setlocal lispwords+=defprotocol
-setlocal lispwords+=defrecord
-setlocal lispwords+=defstruct
-setlocal lispwords+=deftest " clojure.test
-setlocal lispwords+=deftest- " clojure.test
-setlocal lispwords+=deftype
-setlocal lispwords+=extend
-setlocal lispwords+=extend-protocol
-setlocal lispwords+=extend-type
-setlocal lispwords+=fn
-setlocal lispwords+=ns
-setlocal lispwords+=proxy
-setlocal lispwords+=reify
-setlocal lispwords+=set-test " clojure.test
-
-" Binding forms
-setlocal lispwords+=as->
-setlocal lispwords+=binding
-setlocal lispwords+=doall
-setlocal lispwords+=dorun
-setlocal lispwords+=doseq
-setlocal lispwords+=dotimes
-setlocal lispwords+=doto
-setlocal lispwords+=for
-setlocal lispwords+=if-let
-setlocal lispwords+=let
-setlocal lispwords+=letfn
-setlocal lispwords+=locking
-setlocal lispwords+=loop
-setlocal lispwords+=testing " clojure.test
-setlocal lispwords+=when-first
-setlocal lispwords+=when-let
-setlocal lispwords+=with-bindings
-setlocal lispwords+=with-in-str
-setlocal lispwords+=with-local-vars
-setlocal lispwords+=with-open
-setlocal lispwords+=with-precision
-setlocal lispwords+=with-redefs
-setlocal lispwords+=with-redefs-fn
-setlocal lispwords+=with-test " clojure.test
-
-" Conditional branching
-setlocal lispwords+=case
-setlocal lispwords+=cond->
-setlocal lispwords+=cond->>
-setlocal lispwords+=condp
-setlocal lispwords+=if
-setlocal lispwords+=if-not
-setlocal lispwords+=when
-setlocal lispwords+=when-not
-setlocal lispwords+=while
-
-" Exception handling
-setlocal lispwords+=catch
-setlocal lispwords+=try " For aesthetics when enclosing single line
-
 let &cpo = s:save_cpo
 unlet! s:save_cpo
 
-" vim:sts=4 sw=4 et:
+" vim:sts=8:sw=8:ts=8:noet
diff -Naur vim74.orig/runtime/indent/go.vim vim74/runtime/indent/go.vim
--- vim74.orig/runtime/indent/go.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/go.vim	2014-10-10 14:53:41.082055414 +0000
@@ -0,0 +1,78 @@
+" Vim indent file
+" Language:	Go
+" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
+" Last Change:	2014 Aug 16
+"
+" TODO:
+" - function invocations split across lines
+" - general line splits (line ends in an operator)
+
+if exists('b:did_indent')
+  finish
+endif
+let b:did_indent = 1
+
+" C indentation is too far off useful, mainly due to Go's := operator.
+" Let's just define our own.
+setlocal nolisp
+setlocal autoindent
+setlocal indentexpr=GoIndent(v:lnum)
+setlocal indentkeys+=<:>,0=},0=)
+
+if exists('*GoIndent')
+  finish
+endif
+
+" The shiftwidth() function is relatively new.
+" Don't require it to exist.
+if exists('*shiftwidth')
+  function s:sw() abort
+    return shiftwidth()
+  endfunction
+else
+  function s:sw() abort
+    return &shiftwidth
+  endfunction
+endif
+
+function! GoIndent(lnum)
+  let l:prevlnum = prevnonblank(a:lnum-1)
+  if l:prevlnum == 0
+    " top of file
+    return 0
+  endif
+
+  " grab the previous and current line, stripping comments.
+  let l:prevl = substitute(getline(l:prevlnum), '//.*$', '', '')
+  let l:thisl = substitute(getline(a:lnum), '//.*$', '', '')
+  let l:previ = indent(l:prevlnum)
+
+  let l:ind = l:previ
+
+  if l:prevl =~ '[({]\s*$'
+    " previous line opened a block
+    let l:ind += s:sw()
+  endif
+  if l:prevl =~# '^\s*\(case .*\|default\):$'
+    " previous line is part of a switch statement
+    let l:ind += s:sw()
+  endif
+  " TODO: handle if the previous line is a label.
+
+  if l:thisl =~ '^\s*[)}]'
+    " this line closed a block
+    let l:ind -= s:sw()
+  endif
+
+  " Colons are tricky.
+  " We want to outdent if it's part of a switch ("case foo:" or "default:").
+  " We ignore trying to deal with jump labels because (a) they're rare, and
+  " (b) they're hard to disambiguate from a composite literal key.
+  if l:thisl =~# '^\s*\(case .*\|default\):$'
+    let l:ind -= s:sw()
+  endif
+
+  return l:ind
+endfunction
+
+" vim: sw=2 sts=2 et
diff -Naur vim74.orig/runtime/indent/html.vim vim74/runtime/indent/html.vim
--- vim74.orig/runtime/indent/html.vim	2013-06-13 17:50:24.000000000 +0000
+++ vim74/runtime/indent/html.vim	2014-10-10 14:53:41.085388739 +0000
@@ -1,505 +1,1003 @@
 " Vim indent script for HTML
-" General: "{{{
-" File:		html.vim (Vimscript #2075)
-" Author:	Andy Wokula <anwoku@yahoo.de>
-" Last Change:	2013 Jun 12
-" Rev Days:     13
-" Version:	0.9
-" Vim Version:	Vim7
-" Description:
-"   Improved version of the distributed html indent script, faster on a
-"   range of lines.
+" Header: "{{{
+" Maintainer:	Bram Moolenaar
+" Original Author: Andy Wokula <anwoku@yahoo.de>
+" Last Change:	2014 Aug 23
+" Version:	1.0
+" Description:	HTML indent script with cached state for faster indenting on a
+"		range of lines.
+"		Supports template systems through hooks.
+"		Supports Closure stylesheets.
 "
 " Credits:
 "	indent/html.vim (2006 Jun 05) from J. Zellner
 "	indent/css.vim (2006 Dec 20) from N. Weibull
 "
 " History:
+" 2014 June	(v1.0) overhaul (Bram)
 " 2012 Oct 21	(v0.9) added support for shiftwidth()
 " 2011 Sep 09	(v0.8) added HTML5 tags (thx to J. Zuckerman)
 " 2008 Apr 28	(v0.6) revised customization
 " 2008 Mar 09	(v0.5) fixed 'indk' issue (thx to C.J. Robinson)
-" }}}
+"}}}
 
-" Init Folklore, check user settings (2nd time ++) "{{{
-if exists("b:did_indent")
-    finish
+" Init Folklore, check user settings (2nd time ++)
+if exists("b:did_indent") "{{{
+  finish
 endif
 let b:did_indent = 1
 
 setlocal indentexpr=HtmlIndent()
 setlocal indentkeys=o,O,<Return>,<>>,{,},!^F
 
-let b:indent = {"lnum": -1}
-let b:undo_indent = "set inde< indk<| unlet b:indent"
+" "j1" is included to make cindent() work better with Javascript.
+setlocal cino=j1
+" "J1" should be included, but it doen't work properly before 7.4.355.
+if has("patch-7.4.355")
+  setlocal cino+=J1
+endif
+" Before patch 7.4.355 indenting after "(function() {" does not work well, add
+" )2 to limit paren search.
+if !has("patch-7.4.355")
+  setlocal cino+=)2
+endif
+
+" Needed for % to work when finding start/end of a tag.
+setlocal matchpairs+=<:>
 
-" Load Once:
-if exists("*HtmlIndent")
-    call HtmlIndent_CheckUserSettings()
-    finish
+let b:undo_indent = "setlocal inde< indk< cino<"
+
+" b:hi_indent keeps state to speed up indenting consecutive lines.
+let b:hi_indent = {"lnum": -1}
+
+"""""" Code below this is loaded only once. """""
+if exists("*HtmlIndent") && !exists('g:force_reload_html')
+  call HtmlIndent_CheckUserSettings()
+  finish
 endif
 
-" Patch 7.3.694
+" shiftwidth() exists since patch 7.3.694
 if exists('*shiftwidth')
-    let s:ShiftWidth = function('shiftwidth')
+  let s:ShiftWidth = function('shiftwidth')
 else
-    func! s:ShiftWidth()
-	return &shiftwidth
-    endfunc
+  func! s:ShiftWidth()
+    return &shiftwidth
+  endfunc
 endif
 
+" Allow for line continuation below.
 let s:cpo_save = &cpo
 set cpo-=C
 "}}}
 
-func! HtmlIndent_CheckUserSettings() "{{{
-    if exists("g:html_indent_inctags")
-	call s:AddITags(split(g:html_indent_inctags, ","))
-    endif
-    if exists("g:html_indent_autotags")
-	call s:RemoveITags(split(g:html_indent_autotags, ","))
-    endif
+" Check and process settings from b:html_indent and g:html_indent... variables.
+" Prefer using buffer-local settings over global settings, so that there can
+" be defaults for all HTML files and exceptions for specific types of HTML
+" files.
+func! HtmlIndent_CheckUserSettings()
+  "{{{
+  let inctags = ''
+  if exists("b:html_indent_inctags")
+    let inctags = b:html_indent_inctags
+  elseif exists("g:html_indent_inctags")
+    let inctags = g:html_indent_inctags
+  endif
+  let b:hi_tags = {}
+  if len(inctags) > 0
+    call s:AddITags(b:hi_tags, split(inctags, ","))
+  endif
+
+  let autotags = ''
+  if exists("b:html_indent_autotags")
+    let autotags = b:html_indent_autotags
+  elseif exists("g:html_indent_autotags")
+    let autotags = g:html_indent_autotags
+  endif
+  let b:hi_removed_tags = {}
+  if autotags
+    call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
+  endif
+
+  " Syntax names indicating being inside a string of an attribute value.
+  let string_names = []
+  if exists("b:html_indent_string_names")
+    let string_names = b:html_indent_string_names
+  elseif exists("g:html_indent_string_names")
+    let string_names = g:html_indent_string_names
+  endif
+  let b:hi_insideStringNames = ['htmlString']
+  if len(string_names) > 0
+    for s in string_names
+      call add(b:hi_insideStringNames, s)
+    endfor
+  endif
 
-    let indone = {"zero": 0
-		\,"auto": "indent(prevnonblank(v:lnum-1))"
-		\,"inc": "b:indent.blocktagind + s:ShiftWidth()"}
-    if exists("g:html_indent_script1")
-	let s:js1indent = get(indone, g:html_indent_script1, indone.zero)
-    endif
-    if exists("g:html_indent_style1")
-	let s:css1indent = get(indone, g:html_indent_style1, indone.zero)
+  " Syntax names indicating being inside a tag.
+  let tag_names = []
+  if exists("b:html_indent_tag_names")
+    let tag_names = b:html_indent_tag_names
+  elseif exists("g:html_indent_tag_names")
+    let tag_names = g:html_indent_tag_names
+  endif
+  let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
+  if len(tag_names) > 0
+    for s in tag_names
+      call add(b:hi_insideTagNames, s)
+    endfor
+  endif
+
+  let indone = {"zero": 0
+              \,"auto": "indent(prevnonblank(v:lnum-1))"
+              \,"inc": "b:hi_indent.blocktagind + s:ShiftWidth()"}
+
+  let script1 = ''
+  if exists("b:html_indent_script1")
+    let script1 = b:html_indent_script1
+  elseif exists("g:html_indent_script1")
+    let script1 = g:html_indent_script1
+  endif
+  if len(script1) > 0
+    let b:hi_js1indent = get(indone, script1, indone.zero)
+  else
+    let b:hi_js1indent = 0
+  endif
+
+  let style1 = ''
+  if exists("b:html_indent_style1")
+    let style1 = b:html_indent_style1
+  elseif exists("g:html_indent_style1")
+    let style1 = g:html_indent_style1
+  endif
+  if len(style1) > 0
+    let b:hi_css1indent = get(indone, style1, indone.zero)
+  else
+    let b:hi_css1indent = 0
+  endif
+
+  if !exists('b:html_indent_line_limit')
+    if exists('g:html_indent_line_limit')
+      let b:html_indent_line_limit = g:html_indent_line_limit
+    else
+      let b:html_indent_line_limit = 200
     endif
+  endif
 endfunc "}}}
 
-" Init Script Vars  "{{{
-let s:usestate = 1
-let s:css1indent = 0
-let s:js1indent = 0
-" not to be changed:
-let s:endtags = [0,0,0,0,0,0,0,0]   " some places unused
-let s:newstate = {}
+" Init Script Vars
+"{{{
+let b:hi_lasttick = 0
+let b:hi_newstate = {}
 let s:countonly = 0
  "}}}
-func! s:AddITags(taglist) "{{{
-    for itag in a:taglist
-	let s:indent_tags[itag] = 1
-	let s:indent_tags['/'.itag] = -1
-    endfor
-endfunc "}}}
-func! s:AddBlockTag(tag, id, ...) "{{{
-    if !(a:id >= 2 && a:id < 2+len(s:endtags))
-	return
-    endif
-    let s:indent_tags[a:tag] = a:id
-    if a:0 == 0
-	let s:indent_tags['/'.a:tag] = -a:id
-	let s:endtags[a:id-2] = "</".a:tag.">"
-    else
-	let s:indent_tags[a:1] = -a:id
-	let s:endtags[a:id-2] = a:1
-    endif
-endfunc "}}}
-func! s:RemoveITags(taglist) "{{{
-    " remove itags (protect blocktags from being removed)
-    for itag in a:taglist
-	if !has_key(s:indent_tags, itag) || s:indent_tags[itag] != 1
-	    continue
-	endif
-	unlet s:indent_tags[itag]
-	if itag =~ '^\w\+$'
-	    unlet s:indent_tags["/".itag]
-	endif
-    endfor
-endfunc "}}}
-" Add Indent Tags: {{{
-if !exists("s:indent_tags")
-    let s:indent_tags = {}
-endif
 
-" old tags:
-call s:AddITags(['a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big',
-    \ 'blockquote', 'button', 'caption', 'center', 'cite', 'code', 'colgroup',
-    \ 'del', 'dfn', 'dir', 'div', 'dl', 'em', 'fieldset', 'font', 'form',
-    \ 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'i', 'iframe', 'ins', 'kbd',
-    \ 'label', 'legend', 'map', 'menu', 'noframes', 'noscript', 'object', 'ol',
+" Fill the s:indent_tags dict with known tags.
+" The key is "tagname" or "/tagname".  {{{
+" The value is:
+" 1   opening tag
+" 2   "pre"
+" 3   "script"
+" 4   "style"
+" 5   comment start
+" -1  closing tag
+" -2  "/pre"
+" -3  "/script"
+" -4  "/style"
+" -5  comment end
+let s:indent_tags = {}
+let s:endtags = [0,0,0,0,0,0]   " long enough for the highest index
+"}}}
+
+" Add a list of tag names for a pair of <tag> </tag> to "tags".
+func! s:AddITags(tags, taglist)
+  "{{{
+  for itag in a:taglist
+    let a:tags[itag] = 1
+    let a:tags['/' . itag] = -1
+  endfor
+endfunc "}}}
+
+" Take a list of tag name pairs that are not to be used as tag pairs.
+func! s:RemoveITags(tags, taglist)
+  "{{{
+  for itag in a:taglist
+    let a:tags[itag] = 1
+    let a:tags['/' . itag] = 1
+  endfor
+endfunc "}}}
+
+" Add a block tag, that is a tag with a different kind of indenting.
+func! s:AddBlockTag(tag, id, ...)
+  "{{{
+  if !(a:id >= 2 && a:id < len(s:endtags))
+    echoerr 'AddBlockTag ' . a:id
+    return
+  endif
+  let s:indent_tags[a:tag] = a:id
+  if a:0 == 0
+    let s:indent_tags['/' . a:tag] = -a:id
+    let s:endtags[a:id] = "</" . a:tag . ">"
+  else
+    let s:indent_tags[a:1] = -a:id
+    let s:endtags[a:id] = a:1
+  endif
+endfunc "}}}
+
+" Add known tag pairs.
+" Self-closing tags and tags that are sometimes {{{
+" self-closing (e.g., <p>) are not here (when encountering </p> we can find
+" the matching <p>, but not the other way around).
+" Old HTML tags:
+call s:AddITags(s:indent_tags, [
+    \ 'a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big',
+    \ 'blockquote', 'body', 'button', 'caption', 'center', 'cite', 'code',
+    \ 'colgroup', 'del', 'dfn', 'dir', 'div', 'dl', 'em', 'fieldset', 'font',
+    \ 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'html',
+    \ 'i', 'iframe', 'ins', 'kbd', 'label', 'legend', 'li',
+    \ 'map', 'menu', 'noframes', 'noscript', 'object', 'ol',
     \ 'optgroup', 'q', 's', 'samp', 'select', 'small', 'span', 'strong', 'sub',
     \ 'sup', 'table', 'textarea', 'title', 'tt', 'u', 'ul', 'var', 'th', 'td',
-    \ 'tr', 'tfoot', 'thead'])
+    \ 'tr', 'tbody', 'tfoot', 'thead'])
 
-" tags added 2011 Sep 09 (especially HTML5 tags):
-call s:AddITags(['area', 'article', 'aside', 'audio', 'bdi', 'canvas',
+" Tags added 2011 Sep 09 (especially HTML5 tags):
+call s:AddITags(s:indent_tags, [
+    \ 'area', 'article', 'aside', 'audio', 'bdi', 'canvas',
     \ 'command', 'datalist', 'details', 'embed', 'figure', 'footer',
     \ 'header', 'group', 'keygen', 'mark', 'math', 'meter', 'nav', 'output',
     \ 'progress', 'ruby', 'section', 'svg', 'texture', 'time', 'video',
     \ 'wbr', 'text'])
-
 "}}}
-" Add Block Tags: contain alien content "{{{
+
+" Add Block Tags: these contain alien content
+"{{{
 call s:AddBlockTag('pre', 2)
 call s:AddBlockTag('script', 3)
 call s:AddBlockTag('style', 4)
 call s:AddBlockTag('<!--', 5, '-->')
 "}}}
 
-func! s:CountITags(...) "{{{
-
-    " relative indent steps for current line [unit &sw]:
-    let s:curind = 0
-    " relative indent steps for next line [unit &sw]:
-    let s:nextrel = 0
-
-    if a:0==0
-	let s:block = s:newstate.block
-	let tmpline = substitute(s:curline, '<\zs\/\=\w\+\>\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
-	if s:block == 3
-	    let s:newstate.scripttype = s:GetScriptType(matchstr(tmpline, '\C.*<SCRIPT\>\zs[^>]*'))
-	endif
-	let s:newstate.block = s:block
-    else
-	let s:block = 0		" assume starting outside of a block
-	let s:countonly = 1	" don't change state
-	let tmpline = substitute(s:altline, '<\zs\/\=\w\+\>\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
-	let s:countonly = 0
-    endif
-endfunc "}}}
-func! s:CheckTag(itag) "{{{
-    " "tag" or "/tag" or "<!--" or "-->"
-    let ind = get(s:indent_tags, a:itag)
-    if ind == -1
-	" closing tag
-	if s:block != 0
-	    " ignore itag within a block
-	    return "foo"
-	endif
-	if s:nextrel == 0
-	    let s:curind -= 1
-	else
-	    let s:nextrel -= 1
-	endif
-	" if s:curind >= 1
-	"     let s:curind -= 1
-	" else
-	"     let s:nextrel -= 1
-	" endif
-    elseif ind == 1
-	" opening tag
-	if s:block != 0
-	    return "foo"
-	endif
-	let s:nextrel += 1
-    elseif ind != 0
-	" block-tag (opening or closing)
-	return s:Blocktag(a:itag, ind)
-    endif
-    " else ind==0 (other tag found): keep indent
-    return "foo"   " no matter
-endfunc "}}}
-func! s:Blocktag(blocktag, ind) "{{{
-    if a:ind > 0
-	" a block starts here
-	if s:block != 0
-	    " already in a block (nesting) - ignore
-	    " especially ignore comments after other blocktags
-	    return "foo"
-	endif
-	let s:block = a:ind		" block type
-	if s:countonly
-	    return "foo"
-	endif
-	let s:newstate.blocklnr = v:lnum
-	" save allover indent for the endtag
-	let s:newstate.blocktagind = b:indent.baseindent + (s:nextrel + s:curind) * s:ShiftWidth()
-	if a:ind == 3
-	    return "SCRIPT"    " all except this must be lowercase
-	    " line is to be checked again for the type attribute
-	endif
-    else
-	let s:block = 0
-	" we get here if starting and closing block-tag on same line
+" Return non-zero when "tagname" is an opening tag, not being a block tag, for
+" which there should be a closing tag.  Can be used by scripts that include
+" HTML indenting.
+func! HtmlIndent_IsOpenTag(tagname)
+  "{{{
+  if get(s:indent_tags, a:tagname) == 1
+    return 1
+  endif
+  return get(b:hi_tags, a:tagname) == 1
+endfunc "}}}
+
+" Get the value for "tagname", taking care of buffer-local tags.
+func! s:get_tag(tagname)
+  "{{{
+  let i = get(s:indent_tags, a:tagname)
+  if (i == 1 || i == -1) && get(b:hi_removed_tags, a:tagname) != 0
+    return 0
+  endif
+  if i == 0
+    let i = get(b:hi_tags, a:tagname)
+  endif
+  return i
+endfunc "}}}
+
+" Count the number of start and end tags in "text".
+func! s:CountITags(text)
+  "{{{
+  " Store the result in s:curind and s:nextrel.
+  let s:curind = 0  " relative indent steps for current line [unit &sw]:
+  let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
+  let s:block = 0		" assume starting outside of a block
+  let s:countonly = 1	" don't change state
+  call substitute(a:text, '<\zs/\=\w\+\>\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
+  let s:countonly = 0
+endfunc "}}}
+
+" Count the number of start and end tags in text.
+func! s:CountTagsAndState(text)
+  "{{{
+  " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
+  let s:curind = 0  " relative indent steps for current line [unit &sw]:
+  let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
+
+  let s:block = b:hi_newstate.block
+  let tmp = substitute(a:text, '<\zs/\=\w\+\>\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
+  if s:block == 3
+    let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
+  endif
+  let b:hi_newstate.block = s:block
+endfunc "}}}
+
+" Used by s:CountITags() and s:CountTagsAndState().
+func! s:CheckTag(itag)
+  "{{{
+  " Returns an empty string or "SCRIPT".
+  " a:itag can be "tag" or "/tag" or "<!--" or "-->"
+  let ind = s:get_tag(a:itag)
+  if ind == -1
+    " closing tag
+    if s:block != 0
+      " ignore itag within a block
+      return ""
     endif
-    return "foo"
-endfunc "}}}
-func! s:GetScriptType(str) "{{{
-    if a:str == "" || a:str =~ "java"
-	return "javascript"
+    if s:nextrel == 0
+      let s:curind -= 1
     else
-	return ""
+      let s:nextrel -= 1
     endif
-endfunc "}}}
+  elseif ind == 1
+    " opening tag
+    if s:block != 0
+      return ""
+    endif
+    let s:nextrel += 1
+  elseif ind != 0
+    " block-tag (opening or closing)
+    return s:CheckBlockTag(a:itag, ind)
+  " else ind==0 (other tag found): keep indent
+  endif
+  return ""
+endfunc "}}}
+
+" Used by s:CheckTag(). Returns an empty string or "SCRIPT".
+func! s:CheckBlockTag(blocktag, ind)
+  "{{{
+  if a:ind > 0
+    " a block starts here
+    if s:block != 0
+      " already in a block (nesting) - ignore
+      " especially ignore comments after other blocktags
+      return ""
+    endif
+    let s:block = a:ind		" block type
+    if s:countonly
+      return ""
+    endif
+    let b:hi_newstate.blocklnr = v:lnum
+    " save allover indent for the endtag
+    let b:hi_newstate.blocktagind = b:hi_indent.baseindent + (s:nextrel + s:curind) * s:ShiftWidth()
+    if a:ind == 3
+      return "SCRIPT"    " all except this must be lowercase
+      " line is to be checked again for the type attribute
+    endif
+  else
+    let s:block = 0
+    " we get here if starting and closing a block-tag on the same line
+  endif
+  return ""
+endfunc "}}}
+
+" Return the <script> type: either "javascript" or ""
+func! s:GetScriptType(str)
+  "{{{
+  if a:str == "" || a:str =~ "java"
+    return "javascript"
+  else
+    return ""
+  endif
+endfunc "}}}
+
+" Look back in the file, starting at a:lnum - 1, to compute a state for the
+" start of line a:lnum.  Return the new state.
+func! s:FreshState(lnum)
+  "{{{
+  " A state is to know ALL relevant details about the
+  " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
+  " fast (incremental).
+  " TODO: this should be split up in detecting the block type and computing the
+  " indent for the block type, so that when we do not know the indent we do
+  " not need to clear the whole state and re-detect the block type again.
+  " State:
+  "	lnum		last indented line == prevnonblank(a:lnum - 1)
+  "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
+  "			3:<script>, 4:<style>, 5:<!--
+  "	baseindent	use this indent for line a:lnum as a start - kind of
+  "			autoindent (if block==0)
+  "	scripttype = ''	type attribute of a script tag (if block==3)
+  "	blocktagind	indent for current opening (get) and closing (set)
+  "			blocktag (if block!=0)
+  "	blocklnr	lnum of starting blocktag (if block!=0)
+  "	inattr		line {lnum} starts with attributes of a tag
+  let state = {}
+  let state.lnum = prevnonblank(a:lnum - 1)
+  let state.scripttype = ""
+  let state.blocktagind = -1
+  let state.block = 0
+  let state.baseindent = 0
+  let state.blocklnr = 0
+  let state.inattr = 0
+
+  if state.lnum == 0
+    return state
+  endif
 
-func! s:FreshState(lnum) "{{{
-    " Look back in the file (lines 1 to a:lnum-1) to calc a state for line
-    " a:lnum.  A state is to know ALL relevant details about the lines
-    " 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
-    " fast (incremental).
-    " State:
-    "	lnum		last indented line == prevnonblank(a:lnum - 1)
-    "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
-    "			3:<script>, 4:<style>, 5:<!--
-    "	baseindent	use this indent for line a:lnum as a start - kind of
-    "			autoindent (if block==0)
-    "	scripttype = ''	type attribute of a script tag (if block==3)
-    "	blocktagind	indent for current opening (get) and closing (set)
-    "			blocktag (if block!=0)
-    "	blocklnr	lnum of starting blocktag (if block!=0)
-    "	inattr		line {lnum} starts with attributes of a tag
-    let state = {}
-    let state.lnum = prevnonblank(a:lnum - 1)
-    let state.scripttype = ""
-    let state.blocktagind = -1
-    let state.block = 0
-    let state.baseindent = 0
-    let state.blocklnr = 0
-    let state.inattr = 0
-
-    if state.lnum == 0
-	return state
-    endif
-
-    " Heuristic:
-    " remember startline state.lnum
-    " look back for <pre, </pre, <script, </script, <style, </style tags
-    " remember stopline
-    " if opening tag found,
-    "	assume a:lnum within block
-    " else
-    "	look back in result range (stopline, startline) for comment
-    "	    \ delimiters (<!--, -->)
-    "	if comment opener found,
-    "	    assume a:lnum within comment
-    "	else
-    "	    assume usual html for a:lnum
-    "	    if a:lnum-1 has a closing comment
-    "		look back to get indent of comment opener
-    " FI
-
-    " look back for blocktag
-    call cursor(a:lnum, 1)
-    let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bW")
+  " Heuristic:
+  " remember startline state.lnum
+  " look back for <pre, </pre, <script, </script, <style, </style tags
+  " remember stopline
+  " if opening tag found,
+  "	assume a:lnum within block
+  " else
+  "	look back in result range (stopline, startline) for comment
+  "	    \ delimiters (<!--, -->)
+  "	if comment opener found,
+  "	    assume a:lnum within comment
+  "	else
+  "	    assume usual html for a:lnum
+  "	    if a:lnum-1 has a closing comment
+  "		look back to get indent of comment opener
+  " FI
+
+  " look back for a blocktag
+  call cursor(a:lnum, 1)
+  let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bW")
+  if stopline > 0
     " fugly ... why isn't there searchstr()
     let tagline = tolower(getline(stopline))
-    let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol-1)
-    if stopline > 0 && blocktag[0] != "/"
-	" opening tag found, assume a:lnum within block
-	let state.block = s:indent_tags[blocktag]
-	if state.block == 3
-	    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
-	endif
-	let state.blocklnr = stopline
-	" check preceding tags in the line:
-	let s:altline = tagline[: stopcol-2]
-	call s:CountITags(1)
-	let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * s:ShiftWidth()
-	return state
+    let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
+    if blocktag[0] != "/"
+      " opening tag found, assume a:lnum within block
+      let state.block = s:indent_tags[blocktag]
+      if state.block == 3
+        let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
+      endif
+      let state.blocklnr = stopline
+      " check preceding tags in the line:
+      call s:CountITags(tagline[: stopcol-2])
+      let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * s:ShiftWidth()
+      return state
     elseif stopline == state.lnum
-	" handle special case: previous line (= state.lnum) contains a
-	" closing blocktag which is preceded by line-noise;
-	" blocktag == "/..."
-	let swendtag = match(tagline, '^\s*</') >= 0
-	if !swendtag
-	    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bW")
-	    let s:altline = tolower(getline(bline)[: bcol-2])
-	    call s:CountITags(1)
-	    let state.baseindent = indent(bline) + (s:nextrel+s:curline) * s:ShiftWidth()
-	    return state
-	endif
-    endif
-
-    " else look back for comment
-    call cursor(a:lnum, 1)
-    let [comline, comcol, found] = searchpos('\(<!--\)\|-->', 'bpW', stopline)
-    if found == 2
-	" comment opener found, assume a:lnum within comment
-	let state.block = 5
-	let state.blocklnr = comline
-	" check preceding tags in the line:
-	let s:altline = tolower(getline(comline)[: comcol-2])
-	call s:CountITags(1)
-	let state.blocktagind = indent(comline) + (s:curind + s:nextrel) * s:ShiftWidth()
-	return state
-    endif
-
-    " else within usual html
-    let s:altline = tolower(getline(state.lnum))
-    " check a:lnum-1 for closing comment (we need indent from the opening line)
-    let comcol = stridx(s:altline, '-->')
-    if comcol >= 0
-	call cursor(state.lnum, comcol+1)
-	let [comline, comcol] = searchpos('<!--', 'bW')
-	if comline == state.lnum
-	    let s:altline = s:altline[: comcol-2]
-	else
-	    let s:altline = tolower(getline(comline)[: comcol-2])
-	endif
-	call s:CountITags(1)
-	let state.baseindent = indent(comline) + (s:nextrel+s:curline) * s:ShiftWidth()
-	return state
-	" TODO check tags that follow "-->"
-    endif
-
-    " else no comments
-    call s:CountITags(1)
-    let state.baseindent = indent(state.lnum) + s:nextrel * s:ShiftWidth()
-    " line starts with end tag
-    let swendtag = match(s:altline, '^\s*</') >= 0
-    if !swendtag
-	let state.baseindent += s:curind * s:ShiftWidth()
+      " handle special case: previous line (= state.lnum) contains a
+      " closing blocktag which is preceded by line-noise;
+      " blocktag == "/..."
+      let swendtag = match(tagline, '^\s*</') >= 0
+      if !swendtag
+        let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bW")
+        call s:CountITags(tolower(getline(bline)[: bcol-2]))
+        let state.baseindent = indent(bline) + (s:curind + s:nextrel) * s:ShiftWidth()
+        return state
+      endif
+    endif
+  endif
+
+  " else look back for comment
+  call cursor(a:lnum, 1)
+  let [comlnum, comcol, found] = searchpos('\(<!--\)\|-->', 'bpW', stopline)
+  if found == 2
+    " comment opener found, assume a:lnum within comment
+    let state.block = 5
+    let state.blocklnr = comlnum
+    " check preceding tags in the line:
+    call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
+    let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * s:ShiftWidth()
+    return state
+  endif
+
+  " else within usual HTML
+  let text = tolower(getline(state.lnum))
+
+  " Check a:lnum-1 for closing comment (we need indent from the opening line).
+  " Not when other tags follow (might be --> inside a string).
+  let comcol = stridx(text, '-->')
+  if comcol >= 0 && match(text, '[<>]', comcol) <= 0
+    call cursor(state.lnum, comcol + 1)
+    let [comlnum, comcol] = searchpos('<!--', 'bW')
+    if comlnum == state.lnum
+      let text = text[: comcol-2]
+    else
+      let text = tolower(getline(comlnum)[: comcol-2])
     endif
+    call s:CountITags(text)
+    let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * s:ShiftWidth()
+    " TODO check tags that follow "-->"
     return state
-endfunc "}}}
+  endif
+
+  " Check if the previous line starts with end tag.
+  let swendtag = match(text, '^\s*</') >= 0
 
-func! s:Alien2() "{{{
-    " <pre> block
+  " If previous line ended in a closing tag, line up with the opening tag.
+  if !swendtag && text =~ '</\w\+\s*>\s*$'
+    call cursor(state.lnum, 99999)
+    normal! F<
+    let start_lnum = HtmlIndent_FindStartTag()
+    if start_lnum > 0
+      let state.baseindent = indent(start_lnum)
+      if col('.') > 2
+        " check for tags before the matching opening tag.
+        let text = getline(start_lnum)
+        let swendtag = match(text, '^\s*</') >= 0
+        call s:CountITags(text[: col('.') - 2])
+        let state.baseindent += s:nextrel * s:ShiftWidth()
+        if !swendtag
+          let state.baseindent += s:curind * s:ShiftWidth()
+        endif
+      endif
+      return state
+    endif
+  endif
+
+  " Else: no comments. Skip backwards to find the tag we're inside.
+  let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
+  " Check if that line starts with end tag.
+  let text = getline(state.lnum)
+  let swendtag = match(text, '^\s*</') >= 0
+  call s:CountITags(tolower(text))
+  let state.baseindent = indent(state.lnum) + s:nextrel * s:ShiftWidth()
+  if !swendtag
+    let state.baseindent += s:curind * s:ShiftWidth()
+  endif
+  return state
+endfunc "}}}
+
+" Indent inside a <pre> block: Keep indent as-is.
+func! s:Alien2()
+  "{{{
+  return -1
+endfunc "}}}
+
+" Return the indent inside a <script> block for javascript.
+func! s:Alien3()
+  "{{{
+  let lnum = prevnonblank(v:lnum - 1)
+  while lnum > 1 && getline(lnum) =~ '^\s*/[/*]'
+    " Skip over comments to avoid that cindent() aligns with the <script> tag
+    let lnum = prevnonblank(lnum - 1)
+  endwhile
+  if lnum == b:hi_indent.blocklnr
+    " indent for the first line after <script>
+    return eval(b:hi_js1indent)
+  endif
+  if b:hi_indent.scripttype == "javascript"
+    return cindent(v:lnum)
+  else
     return -1
+  endif
 endfunc "}}}
-func! s:Alien3() "{{{
-    " <script> javascript
-    if prevnonblank(v:lnum-1) == b:indent.blocklnr
-	" indent for the first line after <script>
-	return eval(s:js1indent)
-    endif
-    if b:indent.scripttype == "javascript"
-	return cindent(v:lnum)
+
+" Return the indent inside a <style> block.
+func! s:Alien4()
+  "{{{
+  if prevnonblank(v:lnum-1) == b:hi_indent.blocklnr
+    " indent for first content line
+    return eval(b:hi_css1indent)
+  endif
+  return s:CSSIndent()
+endfunc "}}}
+
+" Indending inside a <style> block.  Returns the indent.
+func! s:CSSIndent()
+  "{{{
+  " This handles standard CSS and also Closure stylesheets where special lines
+  " start with @.
+  " When the line starts with '*' or the previous line starts with "/*"
+  " and does not end in "*/", use C indenting to format the comment.
+  " Adopted $VIMRUNTIME/indent/css.vim
+  let curtext = getline(v:lnum)
+  if curtext =~ '^\s*[*]'
+        \ || (v:lnum > 1 && getline(v:lnum - 1) =~ '\s*/\*'
+        \     && getline(v:lnum - 1) !~ '\*/\s*$')
+    return cindent(v:lnum)
+  endif
+
+  let min_lnum = b:hi_indent.blocklnr
+  let prev_lnum = s:CssPrevNonComment(v:lnum - 1, min_lnum)
+  let [prev_lnum, found] = HtmlIndent_FindTagStart(prev_lnum)
+  if prev_lnum <= min_lnum
+    " Just below the <style> tag, indent for first content line after comments.
+    return eval(b:hi_css1indent)
+  endif
+
+  " If the current line starts with "}" align with it's match.
+  if curtext =~ '^\s*}'
+    call cursor(v:lnum, 1)
+    try
+      normal! %
+      " Found the matching "{", align with it after skipping unfinished lines.
+      let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
+      return indent(align_lnum)
+    catch
+      " can't find it, try something else, but it's most likely going to be
+      " wrong
+    endtry
+  endif
+
+  " add indent after {
+  let brace_counts = HtmlIndent_CountBraces(prev_lnum)
+  let extra = brace_counts.c_open * s:ShiftWidth()
+
+  let prev_text = getline(prev_lnum)
+  let below_end_brace = prev_text =~ '}\s*$'
+
+  " Search back to align with the first line that's unfinished.
+  let align_lnum = s:CssFirstUnfinished(prev_lnum, min_lnum)
+
+  " Handle continuation lines if aligning with previous line and not after a
+  " "}".
+  if extra == 0 && align_lnum == prev_lnum && !below_end_brace
+    let prev_hasfield = prev_text =~ '^\s*[a-zA-Z0-9-]\+:'
+    let prev_special = prev_text =~ '^\s*\(/\*\|@\)'
+    if curtext =~ '^\s*\(/\*\|@\)'
+      " if the current line is not a comment or starts with @ (used by template
+      " systems) reduce indent if previous line is a continuation line
+      if !prev_hasfield && !prev_special
+        let extra = -s:ShiftWidth()
+      endif
     else
-	return -1
+      let cur_hasfield = curtext =~ '^\s*[a-zA-Z0-9-]\+:'
+      let prev_unfinished = s:CssUnfinished(prev_text)
+      if !cur_hasfield && (prev_hasfield || prev_unfinished)
+        " Continuation line has extra indent if the previous line was not a
+        " continuation line.
+        let extra = s:ShiftWidth()
+        " Align with @if
+        if prev_text =~ '^\s*@if '
+          let extra = 4
+        endif
+      elseif cur_hasfield && !prev_hasfield && !prev_special
+        " less indent below a continuation line
+        let extra = -s:ShiftWidth()
+      endif
+    endif
+  endif
+
+  if below_end_brace
+    " find matching {, if that line starts with @ it's not the start of a rule
+    " but something else from a template system
+    call cursor(prev_lnum, 1)
+    call search('}\s*$')
+    try
+      normal! %
+      " Found the matching "{", align with it.
+      let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
+      let special = getline(align_lnum) =~ '^\s*@'
+    catch
+      let special = 0
+    endtry
+    if special
+      " do not reduce indent below @{ ... }
+      if extra < 0
+        let extra += s:ShiftWidth()
+      endif
+    else
+      let extra -= (brace_counts.c_close - (prev_text =~ '^\s*}')) * s:ShiftWidth()
     endif
-endfunc "}}}
-func! s:Alien4() "{{{
-    " <style>
-    if prevnonblank(v:lnum-1) == b:indent.blocklnr
-	" indent for first content line
-	return eval(s:css1indent)
-    endif
-    return s:CSSIndent()
-endfunc
-
-func! s:CSSIndent() "{{{
-    " adopted $VIMRUNTIME/indent/css.vim
-    if getline(v:lnum) =~ '^\s*[*}]'
-	return cindent(v:lnum)
-    endif
-    let minline = b:indent.blocklnr
-    let pnum = s:css_prevnoncomment(v:lnum - 1, minline)
-    if pnum <= minline
-	" < is to catch errors
-	" indent for first content line after comments
-	return eval(s:css1indent)
-    endif
-    let ind = indent(pnum) + s:css_countbraces(pnum, 1) * s:ShiftWidth()
-    let pline = getline(pnum)
-    if pline =~ '}\s*$'
-	let ind -= (s:css_countbraces(pnum, 0) - (pline =~ '^\s*}')) * s:ShiftWidth()
-    endif
-    return ind
-endfunc "}}}
-func! s:css_prevnoncomment(lnum, stopline) "{{{
-    " caller starts from a line a:lnum-1 that is not a comment
-    let lnum = prevnonblank(a:lnum)
+  endif
+
+  " if no extra indent yet...
+  if extra == 0
+    if brace_counts.p_open > brace_counts.p_close
+      " previous line has more ( than ): add a shiftwidth
+      let extra = s:ShiftWidth()
+    elseif brace_counts.p_open < brace_counts.p_close
+      " previous line has more ) than (: subtract a shiftwidth
+      let extra = -s:ShiftWidth()
+    endif
+  endif
+
+  return indent(align_lnum) + extra
+endfunc "}}}
+
+" Inside <style>: Whether a line is unfinished.
+func! s:CssUnfinished(text)
+  "{{{
+  return a:text =~ '\s\(||\|&&\|:\)\s*$'
+endfunc "}}}
+
+" Search back for the first unfinished line above "lnum".
+func! s:CssFirstUnfinished(lnum, min_lnum)
+  "{{{
+  let align_lnum = a:lnum
+  while align_lnum > a:min_lnum && s:CssUnfinished(getline(align_lnum - 1))
+    let align_lnum -= 1
+  endwhile
+  return align_lnum
+endfunc "}}}
+
+" Find the non-empty line at or before "lnum" that is not a comment.
+func! s:CssPrevNonComment(lnum, stopline)
+  "{{{
+  " caller starts from a line a:lnum + 1 that is not a comment
+  let lnum = prevnonblank(a:lnum)
+  while 1
     let ccol = match(getline(lnum), '\*/')
     if ccol < 0
-	return lnum
+      " No comment end thus its something else.
+      return lnum
     endif
-    call cursor(lnum, ccol+1)
+    call cursor(lnum, ccol + 1)
+    " Search back for the /* that starts the comment
     let lnum = search('/\*', 'bW', a:stopline)
-    if indent(".") == virtcol(".")-1
-	return prevnonblank(lnum-1)
+    if indent(".") == virtcol(".") - 1
+      " The  found /* is at the start of the line. Now go back to the line
+      " above it and again check if it is a comment.
+      let lnum = prevnonblank(lnum - 1)
     else
-	return lnum
+      " /* is after something else, thus it's not a comment line.
+      return lnum
     endif
+  endwhile
 endfunc "}}}
-func! s:css_countbraces(lnum, count_open) "{{{
-    let brs = substitute(getline(a:lnum),'[''"].\{-}[''"]\|/\*.\{-}\*/\|/\*.*$\|[^{}]','','g')
-    let n_open = 0
-    let n_close = 0
-    for brace in split(brs, '\zs')
-	if brace == "{"
-	    let n_open += 1
-	elseif brace == "}"
-	    if n_open > 0
-		let n_open -= 1
-	    else
-		let n_close += 1
-	    endif
-	endif
-    endfor
-    return a:count_open ? n_open : n_close
-endfunc "}}}
-
-"}}}
-func! s:Alien5() "{{{
-    " <!-- -->
-    return -1
-endfunc "}}}
-
-func! HtmlIndent() "{{{
-    let s:curline = tolower(getline(v:lnum))
-    let indentunit = s:ShiftWidth()
 
-    let s:newstate = {}
-    let s:newstate.lnum = v:lnum
+" Check the number of {} and () in line "lnum". Return a dict with the counts.
+func! HtmlIndent_CountBraces(lnum)
+  "{{{
+  let brs = substitute(getline(a:lnum), '[''"].\{-}[''"]\|/\*.\{-}\*/\|/\*.*$\|[^{}()]', '', 'g')
+  let c_open = 0
+  let c_close = 0
+  let p_open = 0
+  let p_close = 0
+  for brace in split(brs, '\zs')
+    if brace == "{"
+      let c_open += 1
+    elseif brace == "}"
+      if c_open > 0
+        let c_open -= 1
+      else
+        let c_close += 1
+      endif
+    elseif brace == '('
+      let p_open += 1
+    elseif brace == ')'
+      if p_open > 0
+        let p_open -= 1
+      else
+        let p_close += 1
+      endif
+    endif
+  endfor
+  return {'c_open': c_open,
+        \ 'c_close': c_close,
+        \ 'p_open': p_open,
+        \ 'p_close': p_close}
+endfunc "}}}
+
+" Return the indent for a comment: <!-- -->
+func! s:Alien5()
+  "{{{
+  let curtext = getline(v:lnum)
+  if curtext =~ '^\s*\zs-->'
+    " current line starts with end of comment, line up with comment start.
+    call cursor(v:lnum, 0)
+    let lnum = search('<!--', 'b')
+    if lnum > 0
+      " TODO: what if <!-- is not at the start of the line?
+      return indent(lnum)
+    endif
 
-    " does the line start with a closing tag?
-    let swendtag = match(s:curline, '^\s*</') >= 0
+    " Strange, can't find it.
+    return -1
+  endif
 
-    if prevnonblank(v:lnum-1) == b:indent.lnum && s:usestate
-	" use state (continue from previous line)
+  let prevlnum = prevnonblank(v:lnum - 1)
+  let prevtext = getline(prevlnum)
+  let idx = match(prevtext, '^\s*\zs<!--')
+  if idx >= 0
+    " just below comment start, add a shiftwidth
+    return idx + s:ShiftWidth()
+  endif
+
+  " Some files add 4 spaces just below a TODO line.  It's difficult to detect
+  " the end of the TODO, so let's not do that.
+
+  " Align with the previous non-blank line.
+  return indent(prevlnum)
+endfunc "}}}
+
+" When the "lnum" line ends in ">" find the line containing the matching "<".
+func! HtmlIndent_FindTagStart(lnum)
+  "{{{
+  " Avoids using the indent of a continuation line.
+  " Moves the cursor.
+  " Return two values:
+  " - the matching line number or "lnum".
+  " - a flag indicating whether we found the end of a tag.
+  " This method is global so that HTML-like indenters can use it.
+  " To avoid matching " > " or " < " inside a string require that the opening
+  " "<" is followed by a word character and the closing ">" comes after a
+  " non-white character.
+  let idx = match(getline(a:lnum), '\S>\s*$')
+  if idx > 0
+    call cursor(a:lnum, idx)
+    let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
+    if lnum > 0
+      return [lnum, 1]
+    endif
+  endif
+  return [a:lnum, 0]
+endfunc "}}}
+
+" Find the unclosed start tag from the current cursor position.
+func! HtmlIndent_FindStartTag()
+  "{{{
+  " The cursor must be on or before a closing tag.
+  " If found, positions the cursor at the match and returns the line number.
+  " Otherwise returns 0.
+  let tagname = matchstr(getline('.')[col('.') - 1:], '</\zs\w\+\ze')
+  let start_lnum = searchpair('<' . tagname . '\>', '', '</' . tagname . '\>', 'bW')
+  if start_lnum > 0
+    return start_lnum
+  endif
+  return 0
+endfunc "}}}
+
+" Moves the cursor from a "<" to the matching ">".
+func! HtmlIndent_FindTagEnd()
+  "{{{
+  " Call this with the cursor on the "<" of a start tag.
+  " This will move the cursor to the ">" of the matching end tag or, when it's
+  " a self-closing tag, to the matching ">".
+  " Limited to look up to b:html_indent_line_limit lines away.
+  let text = getline('.')
+  let tagname = matchstr(text, '\w\+\|!--', col('.'))
+  if tagname == '!--'
+    call search('--\zs>')
+  elseif s:get_tag('/' . tagname) != 0
+    " tag with a closing tag, find matching "</tag>"
+    call searchpair('<' . tagname, '', '</' . tagname . '\zs>', 'W', '', line('.') + b:html_indent_line_limit)
+  else
+    " self-closing tag, find the ">"
+    call search('\S\zs>')
+  endif
+endfunc "}}}
+
+" Indenting inside a start tag. Return the correct indent or -1 if unknown.
+func! s:InsideTag(foundHtmlString)
+  "{{{
+  if a:foundHtmlString
+    " Inside an attribute string.
+    " Align with the previous line or use an external function.
+    let lnum = v:lnum - 1
+    if lnum > 1
+      if exists('b:html_indent_tag_string_func')
+        return b:html_indent_tag_string_func(lnum)
+      endif
+      return indent(lnum)
+    endif
+  endif
+
+  " Should be another attribute: " attr="val".  Align with the previous
+  " attribute start.
+  let lnum = v:lnum
+  while lnum > 1
+    let lnum -= 1
+    let text = getline(lnum)
+    " Find a match with one of these, align with "attr":
+    "       attr=
+    "  <tag attr=
+    "  text<tag attr=
+    "  <tag>text</tag>text<tag attr=
+    " For long lines search for the first match, finding the last match
+    " gets very slow.
+    if len(text) < 300
+      let idx = match(text, '.*\s\zs[_a-zA-Z0-9-]\+="')
     else
-	" start over (know nothing)
-	let b:indent = s:FreshState(v:lnum)
+      let idx = match(text, '\s\zs[_a-zA-Z0-9-]\+="')
     endif
+    if idx > 0
+      " Found the attribute.  TODO: assumes spaces, no Tabs.
+      return idx
+    endif
+  endwhile
+  return -1
+endfunc "}}}
+
+" THE MAIN INDENT FUNCTION. Return the amount of indent for v:lnum.
+func! HtmlIndent()
+  "{{{
+  if prevnonblank(v:lnum - 1) <= 1
+    " First non-blank line has no indent.
+    return 0
+  endif
+
+  let curtext = tolower(getline(v:lnum))
+  let indentunit = s:ShiftWidth()
+
+  let b:hi_newstate = {}
+  let b:hi_newstate.lnum = v:lnum
+
+  " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
+  " a tag works very differently. Do not do this when the line starts with
+  " "<", it gets the "htmlTag" ID but we are not inside a tag then.
+  if curtext !~ '^\s*<'
+    normal! ^
+    let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
+    let foundHtmlString = 0
+    for synid in reverse(stack)
+      let name = synIDattr(synid, "name")
+      if index(b:hi_insideStringNames, name) >= 0
+        let foundHtmlString = 1
+      elseif index(b:hi_insideTagNames, name) >= 0
+        " Yes, we are inside a tag.
+        let indent = s:InsideTag(foundHtmlString)
+        if indent >= 0
+          " Do not keep the state. TODO: could keep the block type.
+          let b:hi_indent.lnum = 0
+          return indent
+        endif
+      endif
+    endfor
+  endif
+
+  " does the line start with a closing tag?
+  let swendtag = match(curtext, '^\s*</') >= 0
 
-    if b:indent.block >= 2
-	" within block
-	let endtag = s:endtags[b:indent.block-2]
-	let blockend = stridx(s:curline, endtag)
-	if blockend >= 0
-	    " block ends here
-	    let s:newstate.block = 0
-	    " calc indent for REST OF LINE (may start more blocks):
-	    let s:curline = strpart(s:curline, blockend+strlen(endtag))
-	    call s:CountITags()
-	    if swendtag && b:indent.block != 5
-		let indent = b:indent.blocktagind + s:curind * indentunit
-		let s:newstate.baseindent = indent + s:nextrel * indentunit
-	    else
-		let indent = s:Alien{b:indent.block}()
-		let s:newstate.baseindent = b:indent.blocktagind + s:nextrel * indentunit
-	    endif
-	    call extend(b:indent, s:newstate, "force")
-	    return indent
-	else
-	    " block continues
-	    " indent this line with alien method
-	    let indent = s:Alien{b:indent.block}()
-	    call extend(b:indent, s:newstate, "force")
-	    return indent
-	endif
+  if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
+    " use state (continue from previous line)
+  else
+    " start over (know nothing)
+    let b:hi_indent = s:FreshState(v:lnum)
+  endif
+
+  if b:hi_indent.block >= 2
+    " within block
+    let endtag = s:endtags[b:hi_indent.block]
+    let blockend = stridx(curtext, endtag)
+    if blockend >= 0
+      " block ends here
+      let b:hi_newstate.block = 0
+      " calc indent for REST OF LINE (may start more blocks):
+      call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
+      if swendtag && b:hi_indent.block != 5
+        let indent = b:hi_indent.blocktagind + s:curind * indentunit
+        let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
+      else
+        let indent = s:Alien{b:hi_indent.block}()
+        let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
+      endif
     else
-	" not within a block - within usual html
-	" if < 2 then always 0
-	let s:newstate.block = b:indent.block
-	call s:CountITags()
-	if swendtag
-	    let indent = b:indent.baseindent + s:curind * indentunit
-	    let s:newstate.baseindent = indent + s:nextrel * indentunit
-	else
-	    let indent = b:indent.baseindent
-	    let s:newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
-	endif
-	call extend(b:indent, s:newstate, "force")
-	return indent
+      " block continues
+      " indent this line with alien method
+      let indent = s:Alien{b:hi_indent.block}()
+    endif
+  else
+    " not within a block - within usual html
+    let b:hi_newstate.block = b:hi_indent.block
+    if swendtag
+      " The current line starts with an end tag, align with its start tag.
+      call cursor(v:lnum, 1)
+      let start_lnum = HtmlIndent_FindStartTag()
+      if start_lnum > 0
+        " check for the line starting with something inside a tag:
+        " <sometag               <- align here
+        "    attr=val><open>     not here
+        let text = getline(start_lnum)
+        let angle = matchstr(text, '[<>]')
+        if angle == '>'
+          call cursor(start_lnum, 1)
+          normal! f>%
+          let start_lnum = line('.')
+          let text = getline(start_lnum)
+        endif
+
+        let indent = indent(start_lnum)
+        if col('.') > 2
+          let swendtag = match(text, '^\s*</') >= 0
+          call s:CountITags(text[: col('.') - 2])
+          let indent += s:nextrel * s:ShiftWidth()
+          if !swendtag
+            let indent += s:curind * s:ShiftWidth()
+          endif
+        endif
+      else
+        " not sure what to do
+        let indent = b:hi_indent.baseindent
+      endif
+      let b:hi_newstate.baseindent = indent
+    else
+      call s:CountTagsAndState(curtext)
+      let indent = b:hi_indent.baseindent
+      let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
     endif
+  endif
 
+  let b:hi_lasttick = b:changedtick
+  call extend(b:hi_indent, b:hi_newstate, "force")
+  return indent
 endfunc "}}}
 
-" check user settings (first time), clear cpo, Modeline: {{{1
-
-" DEBUG:
-com! -nargs=* IndHtmlLocal <args>
-
+" Check user settings when loading this script the first time.
 call HtmlIndent_CheckUserSettings()
 
 let &cpo = s:cpo_save
 unlet s:cpo_save
 
-" vim:set fdm=marker ts=8:
+" vim: fdm=marker ts=8 sw=2 tw=78
diff -Naur vim74.orig/runtime/indent/j.vim vim74/runtime/indent/j.vim
--- vim74.orig/runtime/indent/j.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/j.vim	2014-10-10 14:53:41.092055389 +0000
@@ -0,0 +1,50 @@
+" Vim indent file
+" Language:	J
+" Maintainer:	David Brgin <676c7473@gmail.com>
+" URL:		https://github.com/glts/vim-j
+" Last Change:	2014-04-05
+
+if exists('b:did_indent')
+  finish
+endif
+let b:did_indent = 1
+
+setlocal indentexpr=GetJIndent()
+setlocal indentkeys-=0{,0},:,0#
+setlocal indentkeys+=0),0<:>,=case.,=catch.,=catchd.,=catcht.,=do.,=else.,=elseif.,=end.,=fcase.
+
+let b:undo_indent = 'setlocal indentkeys< indentexpr<'
+
+if exists('*GetJIndent')
+  finish
+endif
+
+" If g:j_indent_definitions is true, the bodies of explicit definitions of
+" adverbs, conjunctions, and verbs will be indented. Default is false (0).
+if !exists('g:j_indent_definitions')
+  let g:j_indent_definitions = 0
+endif
+
+function GetJIndent() abort
+  let prevlnum = prevnonblank(v:lnum-1)
+  if prevlnum == 0
+    return 0
+  endif
+  let indent = indent(prevlnum)
+  let prevline = getline(prevlnum)
+  if prevline =~# '^\s*\%(case\|catch[dt]\=\|do\|else\%(if\)\=\|fcase\|for\%(_\a\k*\)\=\|if\|select\|try\|whil\%(e\|st\)\)\.\%(\%(\<end\.\)\@!.\)*$'
+    " Increase indentation after an initial control word that starts or
+    " continues a block and is not terminated by "end."
+    let indent += shiftwidth()
+  elseif g:j_indent_definitions && (prevline =~# '\<\%([1-4]\|13\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\>' || prevline =~# '^\s*:\s*$')
+    " Increase indentation in explicit definitions of adverbs, conjunctions,
+    " and verbs
+    let indent += shiftwidth()
+  endif
+  " Decrease indentation in lines that start with either control words that
+  " continue or end a block, or the special items ")" and ":"
+  if getline(v:lnum) =~# '^\s*\%()\|:\|\%(case\|catch[dt]\=\|do\|else\%(if\)\=\|end\|fcase\)\.\)'
+    let indent -= shiftwidth()
+  endif
+  return indent
+endfunction
diff -Naur vim74.orig/runtime/indent/json.vim vim74/runtime/indent/json.vim
--- vim74.orig/runtime/indent/json.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/json.vim	2014-10-10 14:53:41.098722039 +0000
@@ -0,0 +1,168 @@
+" Vim indent file
+" Language:		JSON
+" Mantainer:		Eli Parra <eli@elzr.com> https://github.com/elzr/vim-json
+" Last Change:          2014 Aug 29
+"   https://github.com/jakar/vim-json/commit/20b650e22aa750c4ab6a66aa646bdd95d7cd548a#diff-e81fc111b2052e306d126bd9989f7b7c
+" Original Author:	Rogerz Zhang <rogerz.zhang at gmail.com> http://github.com/rogerz/vim-json
+" Acknowledgement:      Based off of vim-javascript maintained by Darrick Wiebe 
+"                       http://www.vim.org/scripts/script.php?script_id=2765
+
+" 0. Initialization {{{1
+" =================
+
+" Only load this indent file when no other was loaded.
+if exists("b:did_indent")
+  finish
+endif
+let b:did_indent = 1
+
+setlocal nosmartindent
+
+" Now, set up our indentation expression and keys that trigger it.
+setlocal indentexpr=GetJSONIndent()
+setlocal indentkeys=0{,0},0),0[,0],!^F,o,O,e
+
+" Only define the function once.
+if exists("*GetJSONIndent")
+  finish
+endif
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+" 1. Variables {{{1
+" ============
+
+let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'
+" Regex that defines blocks.
+let s:block_regex = '\%({\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term
+
+" 2. Auxiliary Functions {{{1
+" ======================
+
+" Check if the character at lnum:col is inside a string.
+function s:IsInString(lnum, col)
+  return synIDattr(synID(a:lnum, a:col, 1), 'name') == 'jsonString'
+endfunction
+
+" Find line above 'lnum' that isn't empty, or in a string.
+function s:PrevNonBlankNonString(lnum)
+  let lnum = prevnonblank(a:lnum)
+  while lnum > 0
+    " If the line isn't empty or in a string, end search.
+    let line = getline(lnum)
+    if !(s:IsInString(lnum, 1) && s:IsInString(lnum, strlen(line)))
+      break
+    endif
+    let lnum = prevnonblank(lnum - 1)
+  endwhile
+  return lnum
+endfunction
+
+" Check if line 'lnum' has more opening brackets than closing ones.
+function s:LineHasOpeningBrackets(lnum)
+  let open_0 = 0
+  let open_2 = 0
+  let open_4 = 0
+  let line = getline(a:lnum)
+  let pos = match(line, '[][(){}]', 0)
+  while pos != -1
+    let idx = stridx('(){}[]', line[pos])
+    if idx % 2 == 0
+      let open_{idx} = open_{idx} + 1
+    else
+      let open_{idx - 1} = open_{idx - 1} - 1
+    endif
+    let pos = match(line, '[][(){}]', pos + 1)
+  endwhile
+  return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
+endfunction
+
+function s:Match(lnum, regex)
+  let col = match(getline(a:lnum), a:regex) + 1
+  return col > 0 && !s:IsInString(a:lnum, col) ? col : 0
+endfunction
+
+" 3. GetJSONIndent Function {{{1
+" =========================
+
+function GetJSONIndent()
+  " 3.1. Setup {{{2
+  " ----------
+
+  " Set up variables for restoring position in file.  Could use v:lnum here.
+  let vcol = col('.')
+
+  " 3.2. Work on the current line {{{2
+  " -----------------------------
+
+  " Get the current line.
+  let line = getline(v:lnum)
+  let ind = -1
+
+  " If we got a closing bracket on an empty line, find its match and indent
+  " according to it.
+  let col = matchend(line, '^\s*[]}]')
+
+  if col > 0 && !s:IsInString(v:lnum, col)
+    call cursor(v:lnum, col)
+    let bs = strpart('{}[]', stridx('}]', line[col - 1]) * 2, 2)
+
+    let pairstart = escape(bs[0], '[')
+    let pairend = escape(bs[1], ']')
+    let pairline = searchpair(pairstart, '', pairend, 'bW')
+
+    if pairline > 0 
+      let ind = indent(pairline)
+    else
+      let ind = virtcol('.') - 1
+    endif
+
+    return ind
+  endif
+
+  " If we are in a multi-line string, don't do anything to it.
+  if s:IsInString(v:lnum, matchend(line, '^\s*') + 1)
+    return indent('.')
+  endif
+
+  " 3.3. Work on the previous line. {{{2
+  " -------------------------------
+
+  let lnum = prevnonblank(v:lnum - 1)
+
+  if lnum == 0
+    return 0
+  endif
+
+  " Set up variables for current line.
+  let line = getline(lnum)
+  let ind = indent(lnum)
+
+  " If the previous line ended with a block opening, add a level of indent.
+  " if s:Match(lnum, s:block_regex)
+    " return indent(lnum) + &sw
+  " endif
+
+  " If the previous line contained an opening bracket, and we are still in it,
+  " add indent depending on the bracket type.
+  if line =~ '[[({]'
+    let counts = s:LineHasOpeningBrackets(lnum)
+    if counts[0] == '1' || counts[1] == '1' || counts[2] == '1'
+      return ind + &sw
+    else
+      call cursor(v:lnum, vcol)
+    end
+  endif
+
+  " }}}2
+
+  return ind
+endfunction
+
+" }}}1
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim:set sw=2 sts=2 ts=8 noet:
diff -Naur vim74.orig/runtime/indent/php.vim vim74/runtime/indent/php.vim
--- vim74.orig/runtime/indent/php.vim	2013-08-07 09:36:56.000000000 +0000
+++ vim74/runtime/indent/php.vim	2014-10-10 14:53:41.128721963 +0000
@@ -3,8 +3,8 @@
 " Author:	John Wellesz <John.wellesz (AT) teaser (DOT) fr>
 " URL:		http://www.2072productions.com/vim/indent/php.vim
 " Home:		https://github.com/2072/PHP-Indenting-for-VIm
-" Last Change:	2013 August 7th
-" Version:	1.39
+" Last Change:	2014 April 3rd
+" Version:	1.49
 "
 "
 "	Type :help php-indent for available options
@@ -39,7 +39,8 @@
 "
 "	or simply 'let' the option PHP_removeCRwhenUnix to 1 and the script will
 "	silently remove them when VIM load this script (at each bufread).
-"
+
+
 
 if exists("b:did_indent")
     finish
@@ -126,14 +127,26 @@
     finish " XXX -- comment this line for easy dev
 endif
 
+
+let s:notPhpHereDoc = '\%(break\|return\|continue\|exit\|die\|else\)'
+let s:blockstart = '\%(\%(\%(}\s*\)\=else\%(\s\+\)\=\)\=if\>\|\%(}\s*\)\?else\>\|do\>\|while\>\|switch\>\|case\>\|default\>\|for\%(each\)\=\>\|declare\>\|class\>\|trait\>\|use\>\|interface\>\|abstract\>\|final\>\|try\>\|\%(}\s*\)\=catch\>\|\%(}\s*\)\=finally\>\)'
+let s:functionDecl = '\<function\>\%(\s\+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*\)\=\s*(.*'
 let s:endline= '\s*\%(//.*\|#.*\|/\*.*\*/\s*\)\=$'
+let s:terminated = '\%(\%(;\%(\s*\%(?>\|}\)\)\=\|<<<''\=\a\w*''\=$\|^\s*}\)'.s:endline.'\)\|^[^''"`]*[''"`]$'
 let s:PHP_startindenttag = '<?\%(.*?>\)\@!\|<script[^>]*>\%(.*<\/script>\)\@!'
 
 
+
+let s:escapeDebugStops = 0
 function! DebugPrintReturn(scriptLine)
 
-    echo "debug:" . a:scriptLine
-    call getchar()
+    if ! s:escapeDebugStops 
+	echo "debug:" . a:scriptLine
+	let c = getchar()
+	if c == "\<Del>"
+	    let s:escapeDebugStops = 1
+	end
+    endif
 
 endfunction
 
@@ -190,6 +203,11 @@
 	    while getline(lnum) !~? tofind && lnum > 1
 		let lnum = lnum - 1
 	    endwhile
+	elseif lastline =~ '^[^''"`]*[''"`][;,]'.s:endline
+	    let tofind=substitute( lastline, '^.*\([''"`]\)[;,].*$', '^[^\1]\\+[\1]$', '')
+	    while getline(lnum) !~? tofind && lnum > 1
+		let lnum = lnum - 1
+	    endwhile
 	else
 	    break
 	endif
@@ -211,9 +229,9 @@
     let line = getline(".")
 
     if line =~ "\\([\"']\\).*/\\*.*\\1" || line =~ '\%(//\|#\).*/\*'
-        return 1
+	return 1
     else
-        return 0
+	return 0
     endif
 endfun
 
@@ -226,9 +244,23 @@
     endif
 endfun " }}}
 
-function! FindOpenBracket(lnum) " {{{
+function! FindOpenBracket(lnum, blockStarter) " {{{
     call cursor(a:lnum, 1)
-    return searchpair('{', '', '}', 'bW', 'Skippmatch()')
+    let line = searchpair('{', '', '}', 'bW', 'Skippmatch()')
+
+    if a:blockStarter == 1
+	while line > 1 
+	    let linec = getline(line)
+
+	    if linec =~ s:terminated || linec =~ '^\s*\%(' . s:blockstart . '\)\|'. s:functionDecl . s:endline
+		break
+	    endif
+
+	    let line = GetLastRealCodeLNum(line - 1)
+	endwhile
+    endif
+
+    return line
 endfun " }}}
 
 function! FindTheIfOfAnElse (lnum, StopAfterFirstPrevElse) " {{{
@@ -248,7 +280,7 @@
     endif
 
     if getline(beforeelse) =~ '^\s*}'
-	let beforeelse = FindOpenBracket(beforeelse)
+	let beforeelse = FindOpenBracket(beforeelse, 0)
 
 	if getline(beforeelse) =~ '^\s*{'
 	    let beforeelse = GetLastRealCodeLNum(beforeelse - 1)
@@ -285,13 +317,13 @@
 	return indent(1) - &sw * b:PHP_vintage_case_default_indent
     end
 
-    if getline(test) =~ '^\s*}'
-	let test = FindOpenBracket(test)
+    while getline(test) =~ '^\s*}' && test > 1
+	let test = GetLastRealCodeLNum(FindOpenBracket(test, 0) - 1)
 
-	if getline(test) =~ '^\s*{'
-	    let test = GetLastRealCodeLNum(GetLastRealCodeLNum(test - 1) - 1)
+	if getline(test) =~ '^\s*switch\>'
+	    let test = GetLastRealCodeLNum(test - 1)
 	endif
-    endif
+    endwhile
 
     if getline(test) =~# '^\s*switch\>'
 	return indent(test)
@@ -308,7 +340,7 @@
     let cline = getline(a:lnum)
 
     if a:tofind==""
-	let tofind = "^\\s*[\"']*\\s*\\zs\\S"
+	let tofind = "^\\s*[\"'`]*\\s*\\zs\\S"
     else
 	let tofind = a:tofind
     endif
@@ -319,6 +351,14 @@
 
     let synname = synIDattr(synID(a:lnum, coltotest, 0), "name")
 
+    if synname == 'phpStringSingle' || synname == 'phpStringDouble' || synname == 'phpBacktick'
+	if cline !~ '^\s*[''"`]'
+	    return ""
+	else
+	    return synname
+	end
+    end
+
     if get(s:SynPHPMatchGroups, synname) || synname =~ '^php' ||  synname =~? '^javaScript'
 	return synname
     else
@@ -326,9 +366,6 @@
     endif
 endfunction " }}}
 
-let s:notPhpHereDoc = '\%(break\|return\|continue\|exit\|die\|else\)'
-let s:blockstart = '\%(\%(\%(}\s*\)\=else\%(\s\+\)\=\)\=if\>\|else\>\|while\>\|switch\>\|case\>\|default\>\|for\%(each\)\=\>\|declare\>\|class\>\|interface\>\|abstract\>\|try\>\|catch\>\)'
-
 let s:autoresetoptions = 0
 if ! s:autoresetoptions
     let s:autoresetoptions = 1
@@ -344,7 +381,6 @@
 	    setlocal formatoptions+=q
 	    setlocal formatoptions+=r
 	    setlocal formatoptions+=o
-	    setlocal formatoptions+=w
 	    setlocal formatoptions+=c
 	    setlocal formatoptions+=b
 	endif
@@ -443,6 +479,7 @@
     " Test if we are indenting PHP code {{{
     let lnum = prevnonblank(v:lnum - 1)
     let last_line = getline(lnum)
+    let endline= s:endline
 
     if b:InPHPcode_tofind!=""
 	if cline =~? b:InPHPcode_tofind
@@ -483,6 +520,9 @@
 		let b:InPHPcode_and_script = 1
 	    endif
 
+	elseif last_line =~ '^[^''"`]\+[''"`]$' " a string identifier with nothing after it and no other string identifier before
+	    let b:InPHPcode = 0
+	    let b:InPHPcode_tofind = substitute( last_line, '^.*\([''"`]\).*$', '^[^\1]*\1[;,]$', '')
 	elseif last_line =~? '<<<''\=\a\w*''\=$'
 	    let b:InPHPcode = 0
 	    let b:InPHPcode_tofind = substitute( last_line, '^.*<<<''\=\(\a\w*\)''\=$', '^\\s*\1;\\=$', '')
@@ -545,7 +585,7 @@
 	return 0
     endif
 
-    if cline =~? '^\s*\a\w*;$\|^\a\w*$' && cline !~? s:notPhpHereDoc
+    if cline =~? '^\s*\a\w*;$\|^\a\w*$\|^\s*[''"`][;,]' && cline !~? s:notPhpHereDoc
 	return 0
     endif " }}}
 
@@ -555,7 +595,6 @@
 
     let last_line = getline(lnum)
     let ind = indent(lnum)
-    let endline= s:endline
 
     if ind==0 && b:PHP_default_indenting
 	let ind = b:PHP_default_indenting
@@ -567,7 +606,7 @@
 
 
     if cline =~ '^\s*}\%(}}\)\@!'
-	let ind = indent(FindOpenBracket(v:lnum))
+	let ind = indent(FindOpenBracket(v:lnum, 1))
 	let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
 	return ind
     endif
@@ -599,7 +638,7 @@
 
     let LastLineClosed = 0
 
-    let terminated = '\%(;\%(\s*\%(?>\|}\)\)\=\|<<<''\=\a\w*''\=$\|^\s*}\)'.endline
+    let terminated = s:terminated
 
     let unstated   = '\%(^\s*'.s:blockstart.'.*)\|\%(//.*\)\@<!\<e'.'lse\>\)'.endline
 
@@ -614,7 +653,7 @@
 
 	while last_line_num > 1
 
-	    if previous_line =~ '^\s*\%(' . s:blockstart . '\|\%([a-zA-Z]\s*\)*function\)'
+	    if previous_line =~ terminated || previous_line =~ '^\s*\%(' . s:blockstart . '\)\|'. s:functionDecl . endline
 
 		let ind = indent(last_line_num)
 
@@ -625,7 +664,7 @@
 		return ind
 	    endif
 
-	    let last_line_num = last_line_num - 1
+	    let last_line_num = GetLastRealCodeLNum(last_line_num - 1)
 	    let previous_line = getline(last_line_num)
 	endwhile
 
@@ -638,22 +677,29 @@
 	let last_line_num = lnum
 	let LastLineClosed = 1
 
+	let isSingleLineBlock = 0
 	while 1
-	    if previous_line =~ '^\s*}\|;\s*}'.endline " XXX
+	    if ! isSingleLineBlock && previous_line =~ '^\s*}\|;\s*}'.endline " XXX
 
 		call cursor(last_line_num, 1)
-		call search('}\|;\s*}'.endline, 'W')
+		if previous_line !~ '^}'
+		    call search('}\|;\s*}'.endline, 'W')
+		end
 		let oldLastLine = last_line_num
 		let last_line_num = searchpair('{', '', '}', 'bW', 'Skippmatch()')
 
-		if oldLastLine == last_line_num || getline(last_line_num) =~ '^\s*{'
+		if getline(last_line_num) =~ '^\s*{'
 		    let last_line_num = GetLastRealCodeLNum(last_line_num - 1)
+		elseif oldLastLine == last_line_num
+		    let isSingleLineBlock = 1
+		    continue
 		endif
 
 		let previous_line = getline(last_line_num)
 
 		continue
 	    else
+		let isSingleLineBlock = 0
 
 		if getline(last_line_num) =~# '^\s*else\%(if\)\=\>'
 		    let last_line_num = FindTheIfOfAnElse(last_line_num, 0)
@@ -711,7 +757,12 @@
 
 	if last_line =~# '[{(\[]'.endline || last_line =~? '\h\w*\s*(.*,$' && AntepenultimateLine !~ '[,(]'.endline
 
-	    if !b:PHP_BracesAtCodeLevel || last_line !~# '^\s*{'
+	    let dontIndent = 0
+	    if last_line =~ '\S\+\s*{'.endline && last_line !~ '^\s*\%(' . s:blockstart . '\)\|'. s:functionDecl . s:endline
+		let dontIndent = 1
+	    endif
+
+	    if !dontIndent && (!b:PHP_BracesAtCodeLevel || last_line !~# '^\s*{')
 		let ind = ind + &sw
 	    endif
 
@@ -723,7 +774,7 @@
 
 	elseif last_line =~ '\S\+\s*),'.endline
 	    call cursor(lnum, 1)
-	    call search('),'.endline, 'W')
+	    call search('),'.endline, 'W') " line never begins with ) so no need for 'c' flag
 	    let openedparent = searchpair('(', '', ')', 'bW', 'Skippmatch()')
 	    if openedparent != lnum
 		let ind = indent(openedparent)
diff -Naur vim74.orig/runtime/indent/rhelp.vim vim74/runtime/indent/rhelp.vim
--- vim74.orig/runtime/indent/rhelp.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/rhelp.vim	2014-10-10 14:53:41.142055263 +0000
@@ -0,0 +1,111 @@
+" Vim indent file
+" Language:	R Documentation (Help), *.Rd
+" Author:	Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Wed Jul 09, 2014  07:34PM
+
+
+" Only load this indent file when no other was loaded.
+if exists("b:did_indent")
+  finish
+endif
+runtime indent/r.vim
+let s:RIndent = function(substitute(&indentexpr, "()", "", ""))
+let b:did_indent = 1
+
+setlocal indentkeys=0{,0},:,!^F,o,O,e
+setlocal indentexpr=GetRHelpIndent()
+
+" Only define the function once.
+if exists("*GetRHelpIndent")
+  finish
+endif
+
+setlocal noautoindent
+setlocal nocindent
+setlocal nosmartindent
+setlocal nolisp
+
+setlocal indentkeys=0{,0},:,!^F,o,O,e
+setlocal indentexpr=GetCorrectRHelpIndent()
+
+function s:SanitizeRHelpLine(line)
+  let newline = substitute(a:line, '\\\\', "x", "g")
+  let newline = substitute(newline, '\\{', "x", "g")
+  let newline = substitute(newline, '\\}', "x", "g")
+  let newline = substitute(newline, '\\%', "x", "g")
+  let newline = substitute(newline, '%.*', "", "")
+  let newline = substitute(newline, '\s*$', "", "")
+  return newline
+endfunction
+
+function GetRHelpIndent()
+
+  let clnum = line(".")    " current line
+  if clnum == 1
+    return 0
+  endif
+  let cline = getline(clnum)
+
+  if cline =~ '^\s*}\s*$'
+    let i = clnum
+    let bb = -1
+    while bb != 0 && i > 1
+      let i -= 1
+      let line = s:SanitizeRHelpLine(getline(i))
+      let line2 = substitute(line, "{", "", "g")
+      let openb = strlen(line) - strlen(line2)
+      let line3 = substitute(line2, "}", "", "g")
+      let closeb = strlen(line2) - strlen(line3)
+      let bb += openb - closeb
+    endwhile
+    return indent(i)
+  endif
+
+  if cline =~ '^\s*#ifdef\>' || cline =~ '^\s*#endif\>'
+    return 0
+  endif
+
+  let lnum = clnum - 1
+  let line = getline(lnum)
+  if line =~ '^\s*#ifdef\>' || line =~ '^\s*#endif\>'
+    let lnum -= 1
+    let line = getline(lnum)
+  endif
+  while lnum > 1 && (line =~ '^\s*$' || line =~ '^#ifdef' || line =~ '^#endif')
+    let lnum -= 1
+    let line = getline(lnum)
+  endwhile
+  if lnum == 1
+    return 0
+  endif
+  let line = s:SanitizeRHelpLine(line)
+  let line2 = substitute(line, "{", "", "g")
+  let openb = strlen(line) - strlen(line2)
+  let line3 = substitute(line2, "}", "", "g")
+  let closeb = strlen(line2) - strlen(line3)
+  let bb = openb - closeb
+
+  let ind = indent(lnum) + (bb * &sw)
+
+  if line =~ '^\s*}\s*$'
+    let ind = indent(lnum)
+  endif
+
+  if ind < 0
+    return 0
+  endif
+
+  return ind
+endfunction
+
+function GetCorrectRHelpIndent()
+  let lastsection = search('^\\[a-z]*{', "bncW")
+  let secname = getline(lastsection)
+  if secname =~ '^\\usage{' || secname =~ '^\\examples{' || secname =~ '^\\dontshow{' || secname =~ '^\\dontrun{' || secname =~ '^\\donttest{' || secname =~ '^\\testonly{' || secname =~ '^\\method{.*}{.*}('
+    return s:RIndent()
+  else
+    return GetRHelpIndent()
+  endif
+endfunction
+
+" vim: sw=2
diff -Naur vim74.orig/runtime/indent/rmd.vim vim74/runtime/indent/rmd.vim
--- vim74.orig/runtime/indent/rmd.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/rmd.vim	2014-10-10 14:53:41.142055263 +0000
@@ -0,0 +1,46 @@
+" Vim indent file
+" Language:	Rmd
+" Author:	Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Wed Jul 09, 2014  07:33PM
+
+
+" Only load this indent file when no other was loaded.
+if exists("b:did_indent")
+  finish
+endif
+runtime indent/r.vim
+let s:RIndent = function(substitute(&indentexpr, "()", "", ""))
+let b:did_indent = 1
+
+setlocal indentkeys=0{,0},:,!^F,o,O,e
+setlocal indentexpr=GetRmdIndent()
+
+if exists("*GetRmdIndent")
+  finish
+endif
+
+function GetMdIndent()
+  let pline = getline(v:lnum - 1)
+  let cline = getline(v:lnum)
+  if prevnonblank(v:lnum - 1) < v:lnum - 1 || cline =~ '^\s*[-\+\*]\s' || cline =~ '^\s*\d\+\.\s\+'
+    return indent(v:lnum)
+  elseif pline =~ '^\s*[-\+\*]\s'
+    return indent(v:lnum - 1) + 2
+  elseif pline =~ '^\s*\d\+\.\s\+'
+    return indent(v:lnum - 1) + 3
+  endif
+  return indent(prevnonblank(v:lnum - 1))
+endfunction
+
+function GetRmdIndent()
+  if getline(".") =~ '^```{r .*}$' || getline(".") =~ '^```$'
+    return 0
+  endif
+  if search('^```{r', "bncW") > search('^```$', "bncW")
+    return s:RIndent()
+  else
+    return GetMdIndent()
+  endif
+endfunction
+
+" vim: sw=2
diff -Naur vim74.orig/runtime/indent/rnoweb.vim vim74/runtime/indent/rnoweb.vim
--- vim74.orig/runtime/indent/rnoweb.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/rnoweb.vim	2014-10-10 14:53:41.142055263 +0000
@@ -0,0 +1,35 @@
+" Vim indent file
+" Language:	Rnoweb
+" Author:	Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Wed Jul 09, 2014  07:28PM
+
+
+" Only load this indent file when no other was loaded.
+if exists("b:did_indent")
+  finish
+endif
+runtime indent/tex.vim
+let s:TeXIndent = function(substitute(&indentexpr, "()", "", ""))
+unlet b:did_indent
+runtime indent/r.vim
+let s:RIndent = function(substitute(&indentexpr, "()", "", ""))
+let b:did_indent = 1
+
+setlocal indentkeys=0{,0},!^F,o,O,e,},=\bibitem,=\item
+setlocal indentexpr=GetRnowebIndent()
+
+if exists("*GetRnowebIndent")
+  finish
+endif
+
+function GetRnowebIndent()
+  if getline(".") =~ "^<<.*>>=$"
+    return 0
+  endif
+  if search("^<<", "bncW") > search("^@", "bncW")
+    return s:RIndent()
+  endif
+  return s:TeXIndent()
+endfunction
+
+" vim: sw=2
diff -Naur vim74.orig/runtime/indent/rrst.vim vim74/runtime/indent/rrst.vim
--- vim74.orig/runtime/indent/rrst.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/rrst.vim	2014-10-10 14:53:41.145388588 +0000
@@ -0,0 +1,46 @@
+" Vim indent file
+" Language:	Rrst
+" Author:	Jakson Alves de Aquino <jalvesaq@gmail.com>
+" Last Change:	Wed Jul 09, 2014  07:33PM
+
+
+" Only load this indent file when no other was loaded.
+if exists("b:did_indent")
+  finish
+endif
+runtime indent/r.vim
+let s:RIndent = function(substitute(&indentexpr, "()", "", ""))
+let b:did_indent = 1
+
+setlocal indentkeys=0{,0},:,!^F,o,O,e
+setlocal indentexpr=GetRrstIndent()
+
+if exists("*GetRrstIndent")
+  finish
+endif
+
+function GetRstIndent()
+  let pline = getline(v:lnum - 1)
+  let cline = getline(v:lnum)
+  if prevnonblank(v:lnum - 1) < v:lnum - 1 || cline =~ '^\s*[-\+\*]\s' || cline =~ '^\s*\d\+\.\s\+'
+    return indent(v:lnum)
+  elseif pline =~ '^\s*[-\+\*]\s'
+    return indent(v:lnum - 1) + 2
+  elseif pline =~ '^\s*\d\+\.\s\+'
+    return indent(v:lnum - 1) + 3
+  endif
+  return indent(prevnonblank(v:lnum - 1))
+endfunction
+
+function GetRrstIndent()
+  if getline(".") =~ '^\.\. {r .*}$' || getline(".") =~ '^\.\. \.\.$'
+    return 0
+  endif
+  if search('^\.\. {r', "bncW") > search('^\.\. \.\.$', "bncW")
+    return s:RIndent()
+  else
+    return GetRstIndent()
+  endif
+endfunction
+
+" vim: sw=2
diff -Naur vim74.orig/runtime/indent/sh.vim vim74/runtime/indent/sh.vim
--- vim74.orig/runtime/indent/sh.vim	2010-05-15 11:03:29.000000000 +0000
+++ vim74/runtime/indent/sh.vim	2014-10-10 14:53:41.162055213 +0000
@@ -1,7 +1,8 @@
 " Vim indent file
 " Language:         Shell Script
-" Maintainer:       Nikolai Weibull <now@bitwi.se>
-" Latest Revision:  2010-01-06
+" Maintainer:       Peter Aronoff <telemachus@arpinum.org>
+" Original Author:  Nikolai Weibull <now@bitwi.se>
+" Latest Revision:  2014-08-22
 
 if exists("b:did_indent")
   finish
@@ -77,6 +78,8 @@
   let line = getline(v:lnum)
   if line =~ '^\s*\%(then\|do\|else\|elif\|fi\|done\)\>' || line =~ '^\s*}'
     let ind -= s:indent_value('default')
+  elseif line =~ '^\s*esac\>' && s:is_case_empty(getline(v:lnum - 1))
+    let ind -= s:indent_value('default')
   elseif line =~ '^\s*esac\>'
     let ind -= (s:is_case_label(pine, lnum) && s:is_case_ended(pine) ?
              \ 0 : s:indent_value('case-statements')) +
@@ -88,7 +91,9 @@
     if s:is_case(pine)
       let ind = indent(lnum) + s:indent_value('case-labels')
     else
-      let ind -= s:indent_value('case-statements') - s:indent_value('case-breaks')
+      let ind -= (s:is_case_label(pine, lnum) && s:is_case_ended(pine) ?
+                  \ 0 : s:indent_value('case-statements')) -
+                  \ s:indent_value('case-breaks')
     endif
   elseif s:is_case_break(line)
     let ind -= s:indent_value('case-breaks')
@@ -154,5 +159,13 @@
   return s:is_case_break(a:line) || a:line =~ ';[;&]\s*\%(#.*\)\=$'
 endfunction
 
+function! s:is_case_empty(line)
+  if a:line =~ '^\s*$' || a:line =~ '^\s*#'
+    return s:is_case_empty(getline(v:lnum - 1))
+  else
+    return a:line =~ '^\s*case\>'
+  endif
+endfunction
+
 let &cpo = s:cpo_save
 unlet s:cpo_save
diff -Naur vim74.orig/runtime/indent/systemverilog.vim vim74/runtime/indent/systemverilog.vim
--- vim74.orig/runtime/indent/systemverilog.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/systemverilog.vim	2014-10-10 14:53:41.168721863 +0000
@@ -0,0 +1,230 @@
+" Vim indent file
+" Language:    SystemVerilog
+" Maintainer:  kocha <kocha.lsifrontend@gmail.com>
+" Last Change: 12-Aug-2013. 
+
+" Only load this indent file when no other was loaded.
+if exists("b:did_indent")
+  finish
+endif
+let b:did_indent = 1
+
+setlocal indentexpr=SystemVerilogIndent()
+setlocal indentkeys=!^F,o,O,0),0},=begin,=end,=join,=endcase,=join_any,=join_none
+setlocal indentkeys+==endmodule,=endfunction,=endtask,=endspecify
+setlocal indentkeys+==endclass,=endpackage,=endsequence,=endclocking
+setlocal indentkeys+==endinterface,=endgroup,=endprogram,=endproperty,=endchecker
+setlocal indentkeys+==`else,=`endif
+
+" Only define the function once.
+if exists("*SystemVerilogIndent")
+  finish
+endif
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+function SystemVerilogIndent()
+
+  if exists('b:systemverilog_indent_width')
+    let offset = b:systemverilog_indent_width
+  else
+    let offset = &sw
+  endif
+  if exists('b:systemverilog_indent_modules')
+    let indent_modules = offset
+  else
+    let indent_modules = 0
+  endif
+
+  " Find a non-blank line above the current line.
+  let lnum = prevnonblank(v:lnum - 1)
+
+  " At the start of the file use zero indent.
+  if lnum == 0
+    return 0
+  endif
+
+  let lnum2 = prevnonblank(lnum - 1)
+  let curr_line  = getline(v:lnum)
+  let last_line  = getline(lnum)
+  let last_line2 = getline(lnum2)
+  let ind  = indent(lnum)
+  let ind2 = indent(lnum - 1)
+  let offset_comment1 = 1
+  " Define the condition of an open statement
+  "   Exclude the match of //, /* or */
+  let sv_openstat = '\(\<or\>\|\([*/]\)\@<![*(,{><+-/%^&|!=?:]\([*/]\)\@!\)'
+  " Define the condition when the statement ends with a one-line comment
+  let sv_comment = '\(//.*\|/\*.*\*/\s*\)'
+  if exists('b:verilog_indent_verbose')
+    let vverb_str = 'INDENT VERBOSE:'
+    let vverb = 1
+  else
+    let vverb = 0
+  endif
+
+  " Indent accoding to last line
+  " End of multiple-line comment
+  if last_line =~ '\*/\s*$' && last_line !~ '/\*.\{-}\*/'
+    let ind = ind - offset_comment1
+    if vverb
+      echo vverb_str "De-indent after a multiple-line comment."
+    endif
+
+  " Indent after if/else/for/case/always/initial/specify/fork blocks
+  elseif last_line =~ '`\@<!\<\(if\|else\)\>' ||
+    \ last_line =~ '^\s*\<\(for\|case\%[[zx]]\|do\|foreach\|randcase\)\>' ||
+    \ last_line =~ '^\s*\<\(always\|always_comb\|always_ff\|always_latch\)\>' ||
+    \ last_line =~ '^\s*\<\(initial\|specify\|fork\|final\)\>'
+    if last_line !~ '\(;\|\<end\>\)\s*' . sv_comment . '*$' ||
+      \ last_line =~ '\(//\|/\*\).*\(;\|\<end\>\)\s*' . sv_comment . '*$'
+      let ind = ind + offset
+      if vverb | echo vverb_str "Indent after a block statement." | endif
+    endif
+  " Indent after function/task/class/package/sequence/clocking/
+  " interface/covergroup/property/checkerprogram blocks
+  elseif last_line =~ '^\s*\<\(function\|task\|class\|package\)\>' ||
+    \ last_line =~ '^\s*\<\(sequence\|clocking\|interface\)\>' ||
+    \ last_line =~ '^\s*\(\w\+\s*:\)\=\s*\<covergroup\>' ||
+    \ last_line =~ '^\s*\<\(property\|checker\|program\)\>'
+    if last_line !~ '\<end\>\s*' . sv_comment . '*$' ||
+      \ last_line =~ '\(//\|/\*\).*\(;\|\<end\>\)\s*' . sv_comment . '*$'
+      let ind = ind + offset
+      if vverb
+	echo vverb_str "Indent after function/task/class block statement."
+      endif
+    endif
+
+  " Indent after module/function/task/specify/fork blocks
+  elseif last_line =~ '^\s*\(\<extern\>\s*\)\=\<module\>'
+    let ind = ind + indent_modules
+    if vverb && indent_modules
+      echo vverb_str "Indent after module statement."
+    endif
+    if last_line =~ '[(,]\s*' . sv_comment . '*$' &&
+      \ last_line !~ '\(//\|/\*\).*[(,]\s*' . sv_comment . '*$'
+      let ind = ind + offset
+      if vverb
+	echo vverb_str "Indent after a multiple-line module statement."
+      endif
+    endif
+
+  " Indent after a 'begin' statement
+  elseif last_line =~ '\(\<begin\>\)\(\s*:\s*\w\+\)*' . sv_comment . '*$' &&
+    \ last_line !~ '\(//\|/\*\).*\(\<begin\>\)' &&
+    \ ( last_line2 !~ sv_openstat . '\s*' . sv_comment . '*$' ||
+    \ last_line2 =~ '^\s*[^=!]\+\s*:\s*' . sv_comment . '*$' )
+    let ind = ind + offset
+    if vverb | echo vverb_str "Indent after begin statement." | endif
+
+  " Indent after a '{' or a '('
+  elseif last_line =~ '[{(]' . sv_comment . '*$' &&
+    \ last_line !~ '\(//\|/\*\).*[{(]' &&
+    \ ( last_line2 !~ sv_openstat . '\s*' . sv_comment . '*$' ||
+    \ last_line2 =~ '^\s*[^=!]\+\s*:\s*' . sv_comment . '*$' )
+    let ind = ind + offset
+    if vverb | echo vverb_str "Indent after begin statement." | endif
+
+  " De-indent for the end of one-line block
+  elseif ( last_line !~ '\<begin\>' ||
+    \ last_line =~ '\(//\|/\*\).*\<begin\>' ) &&
+    \ last_line2 =~ '\<\(`\@<!if\|`\@<!else\|for\|always\|initial\|do\|foreach\|final\)\>.*' .
+      \ sv_comment . '*$' &&
+    \ last_line2 !~ '\(//\|/\*\).*\<\(`\@<!if\|`\@<!else\|for\|always\|initial\|do\|foreach\|final\)\>' &&
+    \ last_line2 !~ sv_openstat . '\s*' . sv_comment . '*$' &&
+    \ ( last_line2 !~ '\<begin\>' ||
+    \ last_line2 =~ '\(//\|/\*\).*\<begin\>' )
+    let ind = ind - offset
+    if vverb
+      echo vverb_str "De-indent after the end of one-line statement."
+    endif
+
+    " Multiple-line statement (including case statement)
+    " Open statement
+    "   Ident the first open line
+    elseif  last_line =~ sv_openstat . '\s*' . sv_comment . '*$' &&
+      \ last_line !~ '\(//\|/\*\).*' . sv_openstat . '\s*$' &&
+      \ last_line2 !~ sv_openstat . '\s*' . sv_comment . '*$'
+      let ind = ind + offset
+      if vverb | echo vverb_str "Indent after an open statement." | endif
+
+    " Close statement
+    "   De-indent for an optional close parenthesis and a semicolon, and only
+    "   if there exists precedent non-whitespace char
+    elseif last_line =~ ')*\s*;\s*' . sv_comment . '*$' &&
+      \ last_line !~ '^\s*)*\s*;\s*' . sv_comment . '*$' &&
+      \ last_line !~ '\(//\|/\*\).*\S)*\s*;\s*' . sv_comment . '*$' &&
+      \ ( last_line2 =~ sv_openstat . '\s*' . sv_comment . '*$' &&
+      \ last_line2 !~ ';\s*//.*$') &&
+      \ last_line2 !~ '^\s*' . sv_comment . '$'
+      let ind = ind - offset
+      if vverb | echo vverb_str "De-indent after a close statement." | endif
+
+  " `ifdef and `else
+  elseif last_line =~ '^\s*`\<\(ifdef\|else\)\>'
+    let ind = ind + offset
+    if vverb
+      echo vverb_str "Indent after a `ifdef or `else statement."
+    endif
+
+  endif
+
+  " Re-indent current line
+
+  " De-indent on the end of the block
+  " join/end/endcase/endfunction/endtask/endspecify
+  if curr_line =~ '^\s*\<\(join\|join_any\|join_none\|\|end\|endcase\|while\)\>' ||
+      \ curr_line =~ '^\s*\<\(endfunction\|endtask\|endspecify\|endclass\)\>' ||
+      \ curr_line =~ '^\s*\<\(endpackage\|endsequence\|endclocking\|endinterface\)\>' ||
+      \ curr_line =~ '^\s*\<\(endgroup\|endproperty\|endchecker\|endprogram\)\>' ||
+      \ curr_line =~ '^\s*}'
+    let ind = ind - offset
+    if vverb | echo vverb_str "De-indent the end of a block." | endif
+  elseif curr_line =~ '^\s*\<endmodule\>'
+    let ind = ind - indent_modules
+    if vverb && indent_modules
+      echo vverb_str "De-indent the end of a module."
+    endif
+
+  " De-indent on a stand-alone 'begin'
+  elseif curr_line =~ '^\s*\<begin\>'
+    if last_line !~ '^\s*\<\(function\|task\|specify\|module\|class\|package\)\>' ||
+      \ last_line !~ '^\s*\<\(sequence\|clocking\|interface\|covergroup\)\>' ||
+      \ last_line !~ '^\s*\<\(property\|checker\|program\)\>' &&
+      \ last_line !~ '^\s*\()*\s*;\|)\+\)\s*' . sv_comment . '*$' &&
+      \ ( last_line =~
+      \ '\<\(`\@<!if\|`\@<!else\|for\|case\%[[zx]]\|always\|initial\|do\|foreach\|randcase\|final\)\>' ||
+      \ last_line =~ ')\s*' . sv_comment . '*$' ||
+      \ last_line =~ sv_openstat . '\s*' . sv_comment . '*$' )
+      let ind = ind - offset
+      if vverb
+	echo vverb_str "De-indent a stand alone begin statement."
+      endif
+    endif
+
+  " De-indent after the end of multiple-line statement
+  elseif curr_line =~ '^\s*)' &&
+    \ ( last_line =~ sv_openstat . '\s*' . sv_comment . '*$' ||
+    \ last_line !~ sv_openstat . '\s*' . sv_comment . '*$' &&
+    \ last_line2 =~ sv_openstat . '\s*' . sv_comment . '*$' )
+    let ind = ind - offset
+    if vverb
+      echo vverb_str "De-indent the end of a multiple statement."
+    endif
+
+  " De-indent `else and `endif
+  elseif curr_line =~ '^\s*`\<\(else\|endif\)\>'
+    let ind = ind - offset
+    if vverb | echo vverb_str "De-indent `else and `endif statement." | endif
+
+  endif
+
+  " Return the indention
+  return ind
+endfunction
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim:sw=2
diff -Naur vim74.orig/runtime/indent/vim.vim vim74/runtime/indent/vim.vim
--- vim74.orig/runtime/indent/vim.vim	2012-08-02 20:02:41.000000000 +0000
+++ vim74/runtime/indent/vim.vim	2014-10-10 14:53:41.185388488 +0000
@@ -1,7 +1,7 @@
 " Vim indent file
 " Language:	Vim script
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2012 Aug 02
+" Last Change:	2014 Sep 19
 
 " Only load this indent file when no other was loaded.
 if exists("b:did_indent")
@@ -37,7 +37,8 @@
 
   " If the current line doesn't start with '\' and below a line that starts
   " with '\', use the indent of the line above it.
-  if getline(v:lnum) !~ '^\s*\\'
+  let cur_text = getline(v:lnum)
+  if cur_text !~ '^\s*\\'
     while lnum > 0 && getline(lnum) =~ '^\s*\\'
       let lnum = lnum - 1
     endwhile
@@ -47,27 +48,30 @@
   if lnum == 0
     return 0
   endif
+  let prev_text = getline(lnum)
 
   " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
   " and :else.  Add it three times for a line that starts with '\' after
   " a line that doesn't (or g:vim_indent_cont if it exists).
   let ind = indent(lnum)
-  if getline(v:lnum) =~ '^\s*\\' && v:lnum > 1 && getline(lnum) !~ '^\s*\\'
+  if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
     if exists("g:vim_indent_cont")
       let ind = ind + g:vim_indent_cont
     else
       let ind = ind + &sw * 3
     endif
-  elseif getline(lnum) =~ '^\s*aug\%[roup]' && getline(lnum) !~ '^\s*aug\%[roup]\s*!\=\s\+END'
+  elseif prev_text =~ '^\s*aug\%[roup]' && prev_text !~ '^\s*aug\%[roup]\s*!\=\s\+END'
     let ind = ind + &sw
   else
-    let line = getline(lnum)
-    let i = match(line, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
-    if i >= 0
-      let ind += &sw
-      if strpart(line, i, 1) == '|' && has('syntax_items')
-            \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
-        let ind -= &sw
+    " A line starting with :au does not increment/decrement indent.
+    if prev_text !~ '^\s*au\%[tocmd]'
+      let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
+      if i >= 0
+	let ind += &sw
+	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
+	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
+	  let ind -= &sw
+	endif
       endif
     endif
   endif
@@ -75,9 +79,8 @@
   " If the previous line contains an "end" after a pipe, but not in an ":au"
   " command.  And not when there is a backslash before the pipe.
   " And when syntax HL is enabled avoid a match inside a string.
-  let line = getline(lnum)
-  let i = match(line, '[^\\]|\s*\(ene\@!\)')
-  if i > 0 && line !~ '^\s*au\%[tocmd]'
+  let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
+  if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
     if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
       let ind = ind - &sw
     endif
@@ -86,7 +89,7 @@
 
   " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
   " :endfun, :else and :augroup END.
-  if getline(v:lnum) =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s*!\=\s\+END\)'
+  if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s*!\=\s\+END\)'
     let ind = ind - &sw
   endif
 
diff -Naur vim74.orig/runtime/indent/vroom.vim vim74/runtime/indent/vroom.vim
--- vim74.orig/runtime/indent/vroom.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/indent/vroom.vim	2014-10-10 14:53:41.198721788 +0000
@@ -0,0 +1,21 @@
+" Vim indent file
+" Language:	Vroom (vim testing and executable documentation)
+" Maintainer:	David Barnett (https://github.com/google/vim-ft-vroom)
+" Last Change:	2014 Jul 23
+
+if exists('b:did_indent')
+  finish
+endif
+let b:did_indent = 1
+
+let s:cpo_save = &cpo
+set cpo-=C
+
+
+let b:undo_indent = 'setlocal autoindent<'
+
+setlocal autoindent
+
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
diff -Naur vim74.orig/runtime/macros/less.vim vim74/runtime/macros/less.vim
--- vim74.orig/runtime/macros/less.vim	2012-05-18 18:58:54.000000000 +0000
+++ vim74/runtime/macros/less.vim	2014-10-10 14:53:41.545387583 +0000
@@ -1,6 +1,6 @@
 " Vim script to work like "less"
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2012 May 18
+" Last Change:	2014 May 13
 
 " Avoid loading this file twice, allow the user to define his own script.
 if exists("loaded_less")
@@ -87,6 +87,9 @@
 map <C-V> <Space>
 map f <Space>
 map <C-F> <Space>
+map <PageDown> <Space>
+map <kPageDown> <Space>
+map <S-Down> <Space>
 map z <Space>
 map <Esc><Space> <Space>
 fun! s:NextPage()
@@ -116,10 +119,14 @@
 map <C-E> <CR>
 map j <CR>
 map <C-J> <CR>
+map <Down> <CR>
 
 " Scroll one page backward
 noremap <script> b <C-B><SID>L
 map <C-B> b
+map <PageUp> b
+map <kPageUp> b
+map <S-Up> b
 map w b
 map <Esc>v b
 
@@ -133,6 +140,7 @@
 map <C-Y> k
 map <C-P> k
 map <C-K> k
+map <Up> k
 
 " Redraw
 noremap <script> r <C-L><SID>L
@@ -143,11 +151,15 @@
 noremap <script> g gg<SID>L
 map < g
 map <Esc>< g
+map <Home> g
+map <kHome> g
 
 " End of file
 noremap <script> G G<SID>L
 map > G
 map <Esc>> G
+map <End> G
+map <kEnd> G
 
 " Go to percentage
 noremap <script> % %<SID>L
@@ -184,6 +196,7 @@
 endfun
 
 call s:Forward()
+cunmap <CR>
 
 " Quitting
 noremap q :q<CR>
@@ -240,6 +253,18 @@
   unmap v
   unmap /
   unmap ?
+  unmap <Up>
+  unmap <Down>
+  unmap <PageDown>
+  unmap <kPageDown>
+  unmap <PageUp>
+  unmap <kPageUp>
+  unmap <S-Down>
+  unmap <S-Up>
+  unmap <Home>
+  unmap <kHome>
+  unmap <End>
+  unmap <kEnd>
 endfun
 
 " vim: sw=2
diff -Naur vim74.orig/runtime/menu.vim vim74/runtime/menu.vim
--- vim74.orig/runtime/menu.vim	2013-05-17 11:01:55.000000000 +0000
+++ vim74/runtime/menu.vim	2014-10-10 14:53:41.598720782 +0000
@@ -2,7 +2,7 @@
 " You can also use this as a start for your own set of menus.
 "
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2013 May 17
+" Last Change:	2014 May 22
 
 " Note that ":an" (short for ":anoremenu") is often used to make a menu work
 " in all modes and avoid side effects from mappings defined by the user.
@@ -477,6 +477,7 @@
   an 40.340.110 &Tools.&Folding.&Enable/Disable\ folds<Tab>zi		zi
   an 40.340.120 &Tools.&Folding.&View\ Cursor\ Line<Tab>zv		zv
   an 40.340.120 &Tools.&Folding.Vie&w\ Cursor\ Line\ only<Tab>zMzx	zMzx
+  inoremenu 40.340.120 &Tools.&Folding.Vie&w\ Cursor\ Line\ only<Tab>zMzx  <C-O>zM<C-O>zx
   an 40.340.130 &Tools.&Folding.C&lose\ more\ folds<Tab>zm		zm
   an 40.340.140 &Tools.&Folding.&Close\ all\ folds<Tab>zM		zM
   an 40.340.150 &Tools.&Folding.O&pen\ more\ folds<Tab>zr		zr
diff -Naur vim74.orig/runtime/optwin.vim vim74/runtime/optwin.vim
--- vim74.orig/runtime/optwin.vim	2013-06-29 12:32:06.000000000 +0000
+++ vim74/runtime/optwin.vim	2014-10-10 14:53:41.602054107 +0000
@@ -1,7 +1,7 @@
 " These commands create the option window.
 "
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2013 Jun 29
+" Last Change:	2014 Aug 06
 
 " If there already is an option window, jump to that one.
 if bufwinnr("option-window") > 0
@@ -324,6 +324,12 @@
 call append("$", "linebreak\twrap long lines at a character in 'breakat'")
 call append("$", "\t(local to window)")
 call <SID>BinOptionL("lbr")
+call append("$", "breakindent\tpreserve indentation in wrapped text")
+call append("$", "\t(local to window)")
+call <SID>BinOptionL("bri")
+call append("$", "breakindentopt\tadjust breakindent behaviour")
+call append("$", "\t(local to window)")
+call <SID>OptionL("briopt")
 call append("$", "breakat\twhich characters might cause a line break")
 call <SID>OptionG("brk", &brk)
 call append("$", "showbreak\tstring to put before wrapped screen lines")
@@ -600,6 +606,10 @@
     call append("$", "guiheadroom\troom (in pixels) left above/below the window")
     call append("$", " \tset ghr=" . &ghr)
   endif
+  if has("directx")
+    call append("$", "renderoptions\toptions for text rendering")
+    call <SID>OptionG("rop", &rop)
+  endif
   call append("$", "guipty\tuse a pseudo-tty for I/O to external commands")
   call <SID>BinOptionG("guipty", &guipty)
   if has("browse")
@@ -855,7 +865,7 @@
   call append("$", "\t(local to buffer)")
   call <SID>BinOptionL("lisp")
   call append("$", "lispwords\twords that change how lisp indenting works")
-  call <SID>OptionG("lw", &lw)
+  call <SID>OptionL("lw")
 endif
 
 
diff -Naur vim74.orig/runtime/plugin/getscriptPlugin.vim vim74/runtime/plugin/getscriptPlugin.vim
--- vim74.orig/runtime/plugin/getscriptPlugin.vim	2013-04-17 13:40:44.000000000 +0000
+++ vim74/runtime/plugin/getscriptPlugin.vim	2014-10-10 14:53:41.605387432 +0000
@@ -1,7 +1,7 @@
 " ---------------------------------------------------------------------
 " getscriptPlugin.vim
 "  Author:	Charles E. Campbell
-"  Date:	Jan 07, 2008
+"  Date:	Nov 29, 2013
 "  Installing:	:help glvs-install
 "  Usage:	:help glvs
 "
@@ -13,13 +13,16 @@
 " Initialization:	{{{1
 " if you're sourcing this file, surely you can't be
 " expecting vim to be in its vi-compatible mode
-if &cp || exists("g:loaded_getscriptPlugin")
+if exists("g:loaded_getscriptPlugin")
+ finish
+endif
+if &cp
  if &verbose
   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
  endif
  finish
 endif
-let g:loaded_getscriptPlugin = "v35"
+let g:loaded_getscriptPlugin = "v36"
 let s:keepcpo                = &cpo
 set cpo&vim
 
diff -Naur vim74.orig/runtime/plugin/matchparen.vim vim74/runtime/plugin/matchparen.vim
--- vim74.orig/runtime/plugin/matchparen.vim	2013-05-08 03:15:53.000000000 +0000
+++ vim74/runtime/plugin/matchparen.vim	2014-10-10 14:53:41.612054082 +0000
@@ -1,6 +1,6 @@
 " Vim plugin for showing matching parens
 " Maintainer:  Bram Moolenaar <Bram@vim.org>
-" Last Change: 2013 May 08
+" Last Change: 2014 Jul 19
 
 " Exit quickly when:
 " - this plugin was already loaded (or disabled)
@@ -39,7 +39,7 @@
 function! s:Highlight_Matching_Pair()
   " Remove any previous match.
   if exists('w:paren_hl_on') && w:paren_hl_on
-    3match none
+    silent! call matchdelete(3)
     let w:paren_hl_on = 0
   endif
 
@@ -54,14 +54,15 @@
   let c_col = col('.')
   let before = 0
 
-  let c = getline(c_lnum)[c_col - 1]
+  let text = getline(c_lnum)
+  let c = text[c_col - 1]
   let plist = split(&matchpairs, '.\zs[:,]')
   let i = index(plist, c)
   if i < 0
     " not found, in Insert mode try character before the cursor
     if c_col > 1 && (mode() == 'i' || mode() == 'R')
       let before = 1
-      let c = getline(c_lnum)[c_col - 2]
+      let c = text[c_col - 2]
       let i = index(plist, c)
     endif
     if i < 0
@@ -87,14 +88,27 @@
   " Find the match.  When it was just before the cursor move it there for a
   " moment.
   if before > 0
-    let save_cursor = winsaveview()
+    let has_getcurpos = exists("*getcurpos")
+    if has_getcurpos
+      " getcurpos() is more efficient but doesn't exist before 7.4.313.
+      let save_cursor = getcurpos()
+    else
+      let save_cursor = winsaveview()
+    endif
     call cursor(c_lnum, c_col - before)
   endif
 
-  " When not in a string or comment ignore matches inside them.
+  " Build an expression that detects whether the current cursor position is in
+  " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
+  " skip argument.
   " We match "escape" for special items, such as lispEscapeSpecial.
-  let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
-	\ '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
+  let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
+	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
+  " If executing the expression determines that the cursor is currently in
+  " one of the syntax types, then we want searchpairpos() to find the pair
+  " within those syntax types (i.e., not skip).  Otherwise, the cursor is
+  " outside of the syntax types and s_skip should keep its value so we skip any
+  " matching pair inside the syntax types.
   execute 'if' s_skip '| let s_skip = 0 | endif'
 
   " Limit the search to lines visible in the window.
@@ -147,19 +161,27 @@
   endtry
 
   if before > 0
-    call winrestview(save_cursor)
+    if has_getcurpos
+      call setpos('.', save_cursor)
+    else
+      call winrestview(save_cursor)
+    endif
   endif
 
   " If a match is found setup match highlighting.
   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
-    exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
-	  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
+    if exists('*matchaddpos')
+      call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
+    else
+      exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
+	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
+    endif
     let w:paren_hl_on = 1
   endif
 endfunction
 
 " Define commands that will disable and enable the plugin.
-command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen |
+command! NoMatchParen windo silent! call matchdelete(3) | unlet! g:loaded_matchparen |
 	  \ au! matchparen
 command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
 
diff -Naur vim74.orig/runtime/plugin/netrwPlugin.vim vim74/runtime/plugin/netrwPlugin.vim
--- vim74.orig/runtime/plugin/netrwPlugin.vim	2013-05-19 03:28:33.000000000 +0000
+++ vim74/runtime/plugin/netrwPlugin.vim	2014-10-10 14:53:41.615387407 +0000
@@ -1,9 +1,9 @@
 " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
 "            PLUGIN SECTION
-" Date:		Apr 30, 2013
+" Date:		Jan 22, 2014
 " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
 " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
-" Copyright:    Copyright (C) 1999-2012 Charles E. Campbell {{{1
+" Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
 "               Permission is hereby granted to use and distribute this code,
 "               with or without modifications, provided that this copyright
 "               notice is copied with it. Like anything else that's free,
@@ -20,27 +20,34 @@
 if &cp || exists("g:loaded_netrwPlugin")
  finish
 endif
-"DechoTabOn
-let g:loaded_netrwPlugin = "v149"
+let g:loaded_netrwPlugin = "v152"
 if v:version < 702
- echohl WarningMsg | echo "***netrw*** you need vim version 7.2 for this version of netrw" | echohl None
+ echohl WarningMsg
+ echo "***warning*** you need vim version 7.2 for this version of netrw"
+ echohl None
+ finish
+endif
+if v:version < 703 || (v:version == 703 && !has("patch465"))
+ echohl WarningMsg
+ echo "***warning*** this version of netrw needs vim 7.3.465 or later"
+ echohl Normal
  finish
 endif
 let s:keepcpo = &cpo
 set cpo&vim
-"DechoTabOn
+"DechoRemOn
 
 " ---------------------------------------------------------------------
 " Public Interface: {{{1
 
-" Local Browsing: {{{2
+" Local Browsing Autocmds: {{{2
 augroup FileExplorer
  au!
- " SEE Benzinger problem...
- au BufEnter *	sil! call s:LocalBrowse(expand("<amatch>"))
- au VimEnter *	sil! call s:VimEnter(expand("<amatch>"))
+ au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
+ au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
+ au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
  if has("win32") || has("win95") || has("win64") || has("win16")
-  au BufEnter .* sil! call s:LocalBrowse(expand("<amatch>"))
+  au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
  endif
 augroup END
 
@@ -50,8 +57,8 @@
  au BufReadCmd   file://*									call netrw#FileUrlRead(expand("<amatch>"))
  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
- au BufWriteCmd  ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
- au FileWriteCmd ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
+ au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*		exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
+ au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*		exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
  try
   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
  catch /^Vim\%((\a\+)\)\=:E216/
@@ -60,12 +67,13 @@
 augroup END
 
 " Commands: :Nread, :Nwrite, :NetUserPass {{{2
-com! -count=1 -nargs=*	Nread		call netrw#NetrwSavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#NetrwRestorePosn()
-com! -range=% -nargs=*	Nwrite		call netrw#NetrwSavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#NetrwRestorePosn()
+com! -count=1 -nargs=*	Nread		call netrw#SavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#RestorePosn()
+com! -range=% -nargs=*	Nwrite		call netrw#SavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#RestorePosn()
 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
-com! -nargs=*	        Nsource		call netrw#NetrwSavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#NetrwRestorePosn()
+com! -nargs=*	        Nsource		call netrw#SavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#RestorePosn()
+com! -nargs=?		Ntree		call netrw#SetTreetop(<q-args>)
 
-" Commands: :Explore, :Sexplore, Hexplore, Vexplore {{{2
+" Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
@@ -73,56 +81,79 @@
 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
+com! -nargs=* -bar       	  -complete=dir Lexplore	call netrw#Lexplore(<q-args>)
 
 " Commands: NetrwSettings {{{2
 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
-com! -bang	NetrwClean	call netrw#NetrwClean(<bang>0)
+com! -bang	NetrwClean	call netrw#Clean(<bang>0)
 
 " Maps:
 if !exists("g:netrw_nogx") && maparg('gx','n') == ""
  if !hasmapto('<Plug>NetrwBrowseX')
   nmap <unique> gx <Plug>NetrwBrowseX
  endif
- nno <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)<cr>
+ nno <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cfile>"),0)<cr>
 endif
 
 " ---------------------------------------------------------------------
-" LocalBrowse: {{{2
+" LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
 fun! s:LocalBrowse(dirname)
-  " unfortunate interaction -- debugging calls can't be used here;
-  " the BufEnter event causes triggering when attempts to write to
+  " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
+  " Otherwise, the BufEnter event gets triggered when attempts to write to
   " the DBG buffer are made.
+  
   if !exists("s:vimentered")
+   " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
+   " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
+"   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
+"   call Dret("s:LocalBrowse")
    return
   endif
-"  call Decho("s:LocalBrowse(dirname<".a:dirname.">){")
-"  echomsg "dirname<".a:dirname.">"
+
+"  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
+
   if has("amiga")
    " The check against '' is made for the Amiga, where the empty
    " string is the current directory and not checking would break
    " things such as the help command.
-"   call Decho("(LocalBrowse) dirname<".a:dirname.">  (amiga)")
+"   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
    if a:dirname != '' && isdirectory(a:dirname)
     sil! call netrw#LocalBrowseCheck(a:dirname)
+    if exists("w:netrw_bannercnt")
+     exe w:netrw_bannercnt
+    endif
    endif
+
   elseif isdirectory(a:dirname)
-"   echomsg "dirname<".dirname."> isdir"
-"   call Decho("(LocalBrowse) dirname<".a:dirname.">  (not amiga)")
+"   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
+"   call Dredir("LocalBrowse ft last set: ","verbose set ft")
    sil! call netrw#LocalBrowseCheck(a:dirname)
+   if exists("w:netrw_bannercnt")
+    exe w:netrw_bannercnt
+   endif
+
+  else
+   " not a directory, ignore it
+"   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
   endif
-  " not a directory, ignore it
-"  call Decho("|return s:LocalBrowse }")
+
+"  call Dret("s:LocalBrowse")
 endfun
 
 " ---------------------------------------------------------------------
-" s:VimEnter: {{{2
+" s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
+"             Its purpose: to look over all windows and run s:LocalBrowse() on
+"             them, which checks if they're directories and will create a directory
+"             listing when appropriate.
+"             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
+"             has already been called.
 fun! s:VimEnter(dirname)
-"  call Decho("VimEnter(dirname<".a:dirname.">){")
+"  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
   let curwin       = winnr()
   let s:vimentered = 1
-  windo if a:dirname != expand("%")|call s:LocalBrowse(expand("%:p"))|endif
+  windo call s:LocalBrowse(expand("%:p"))
   exe curwin."wincmd w"
-"  call Decho("|return VimEnter }")
+"  call Dret("s:VimEnter")
 endfun
 
 " ---------------------------------------------------------------------
diff -Naur vim74.orig/runtime/scripts.vim vim74/runtime/scripts.vim
--- vim74.orig/runtime/scripts.vim	2013-06-02 14:49:18.000000000 +0000
+++ vim74/runtime/scripts.vim	2014-10-10 14:53:41.692053881 +0000
@@ -1,7 +1,7 @@
 " Vim support file to detect file types in scripts
 "
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last change:	2013 May 24
+" Last change:	2014 Aug 24
 
 " This file is called by an autocommand for every file that has just been
 " loaded into a buffer.  It checks if the type of file can be recognized by
@@ -319,6 +319,10 @@
   elseif s:line1 =~ '^==\d\+== valgrind' || s:line3 =~ '^==\d\+== Using valgrind'
     set ft=valgrind
 
+  " Go docs
+  elseif s:line1 =~ '^PACKAGE DOCUMENTATION$'
+    set ft=godoc
+
   " Renderman Interface Bytestream
   elseif s:line1 =~ '^##RenderMan'
     set ft=rib
diff -Naur vim74.orig/runtime/spell/ro/main.aap vim74/runtime/spell/ro/main.aap
--- vim74.orig/runtime/spell/ro/main.aap	2010-05-15 11:03:35.000000000 +0000
+++ vim74/runtime/spell/ro/main.aap	2014-10-10 14:53:42.182052650 +0000
@@ -9,35 +9,43 @@
 SPELLDIR = ..
 FILES    = ro_RO.aff ro_RO.dic
 
-all: $SPELLDIR/ro.iso-8859-2.spl $SPELLDIR/ro.utf-8.spl \
-        $SPELLDIR/ro.cp1250.spl ../README_ro.txt
-
-$SPELLDIR/ro.iso-8859-2.spl : $FILES
-        :sys env LANG=ro_RO.ISO8859-2 $VIM -u NONE -e -c "mkspell! $SPELLDIR/ro ro_RO" -c q
+all: $SPELLDIR/ro.utf-8.spl \
+        $SPELLDIR/ro.iso-8859-2.spl \
+        $SPELLDIR/ro.cp1250.spl \
+        ../README_ro.txt
 
 $SPELLDIR/ro.utf-8.spl : $FILES
-        :sys env LANG=ro_RO.UTF-8 $VIM -u NONE -e -c "mkspell! $SPELLDIR/ro ro_RO" -c q
+        :sys env LANG=ro_RO.utf8 $VIM -u NONE -e -c "mkspell! $SPELLDIR/ro ro_RO" -c q
+
+# Note: this generates conversion errors, because not all characters can be
+# represented in iso-8859-2.
+$SPELLDIR/ro.iso-8859-2.spl : $FILES
+        :sys env LANG=ro_RO.iso88592 $VIM -u NONE -e -c "mkspell! $SPELLDIR/ro ro_RO" -c q
 
+# Note: this generates conversion errors, because not all characters can be
+# represented in cp1250.
 $SPELLDIR/ro.cp1250.spl : $FILES
         :sys $VIM -u NONE -e -c "set enc=cp1250" -c "mkspell! $SPELLDIR/ro ro_RO" -c q
 
-../README_ro.txt: README_ro_RO.txt
+../README_ro.txt: README
         :copy $source $target
 
 #
 # Fetching the files from OpenOffice.org.
 #
-OODIR = http://ftp.services.openoffice.org/pub/OpenOffice.org/contrib/dictionaries
-:attr {fetch = $OODIR/%file%} ro_RO.zip
+#OODIR = http://ftp.services.openoffice.org/pub/OpenOffice.org/contrib/dictionaries
+OODIR = http://sourceforge.net/projects/rospell/files/Romanian%20dictionaries/dict-3.3.10
+ZIPFILE = ro_RO.3.3.10.zip
+:attr {fetch = $OODIR/%file%} $ZIPFILE
 
 # The files don't depend on the .zip file so that we can delete it.
 # Only download the zip file if the targets don't exist.
 # This is a bit tricky, since the file name includes the date.
 ro_RO.aff ro_RO.dic: {buildcheck=}
         :assertpkg unzip patch
-        :fetch ro_RO.zip
-        :sys $UNZIP ro_RO.zip
-        :delete ro_RO.zip
+        :fetch $ZIPFILE
+        :sys $UNZIP $ZIPFILE
+        :delete $ZIPFILE
         @if not os.path.exists('ro_RO.orig.aff'):
             :copy ro_RO.aff ro_RO.orig.aff
         @if not os.path.exists('ro_RO.orig.dic'):
@@ -60,12 +68,12 @@
 
 check:
         :assertpkg unzip diff
-        :fetch ro_RO.zip
+        :fetch $ZIPFILE
         :mkdir tmp
         :cd tmp
         @try:
             @import stat
-            :sys $UNZIP ../ro_RO.zip
+            :sys $UNZIP ../$ZIPFILE
             :sys {force} diff ../ro_RO.orig.aff ro_RO.aff >d
             @if os.stat('d')[stat.ST_SIZE] > 0:
                 :copy ro_RO.aff ../ro_RO.new.aff
@@ -75,7 +83,19 @@
         @finally:
             :cd ..
             :delete {r}{f}{q} tmp
-            :delete ro_RO.zip
+            :delete $ZIPFILE
 
+# Remove all the downloaded and generated files.
+clean:
+        :delete ro_RO.aff
+        :delete ro_RO.dic
+        :delete ro_RO.orig.aff
+        :delete ro_RO.orig.dic
+        :delete ro_RO-ante1993.aff
+        :delete ro_RO-ante1993.dic
+        :delete COPYING.GPL
+        :delete COPYING.LGPL
+        :delete COPYING.MPL
+        :delete README
 
 # vim: set sts=4 sw=4 :
diff -Naur vim74.orig/runtime/spell/ro/ro_RO.diff vim74/runtime/spell/ro/ro_RO.diff
--- vim74.orig/runtime/spell/ro/ro_RO.diff	2010-05-15 11:03:35.000000000 +0000
+++ vim74/runtime/spell/ro/ro_RO.diff	2014-10-10 14:53:42.185385975 +0000
@@ -1,42 +1,34 @@
-*** ro_RO.orig.aff	Wed Aug 31 20:34:38 2005
---- ro_RO.aff	Wed Aug 31 20:39:57 2005
+*** ro_RO.orig.aff	2014-08-29 16:29:21.162457824 +0200
+--- ro_RO.aff	2014-09-19 15:29:52.354413307 +0200
 ***************
-*** 3,4 ****
---- 3,8 ----
+*** 3,5 ****
+  TRY iaertolncusmpdbgfzvhjxkwyqACDM
+! KEY qwertyuiop|asdfghjkl|zxcvbnm
   
-+ FOL 
-+ LOW 
-+ UPP 
-+ 
-  PFX E Y 1
-***************
-*** 12,15 ****
-  SFX L   0          l          u
-! SFX L   0          le         [^cg] i
-! SFX L   0          i          [cg] i
-  SFX L   0          le         e
---- 16,19 ----
-  SFX L   0          l          u
-! SFX L   0          le         [^cg]i
-! SFX L   0          i          [cg]i
-  SFX L   0          le         e
-***************
-*** 18,20 ****
-  SFX U   0          a          re
-! SFX U   0          i          [^i] ii
-  
---- 22,24 ----
-  SFX U   0          a          re
-! SFX U   0          i          [^i]ii
+--- 3,9 ----
+  TRY iaertolncusmpdbgfzvhjxkwyqACDM
+! # KEY qwertyuiop|asdfghjkl|zxcvbnm
+! 
+! # ignore extra field (specifies type of word?)
+! IGNOREEXTRA
+! 
   
 ***************
-*** 38,41 ****
-  SFX I   0          ului       [^ua]
-! SFX I   a          ii         [gc] a
-! SFX I   a          ei         [^cg] a
-  
---- 42,45 ----
-  SFX I   0          ului       [^ua]
-! SFX I   a          ii         [gc]a
-! SFX I   a          ei         [^cg]a
-  
+*** 1546,1553 ****
+  SFX q   0     ilor    .      adj. m. pl. dat.
+! SFX q   0    
+! SFX q   0    a
+! SFX q   0    ei
+! SFX q   0    e
+! SFX q   0    ele
+! SFX q   0    elor
+  PFX q Y 1
+--- 1550,1557 ----
+  SFX q   0     ilor    .      adj. m. pl. dat.
+! SFX q   0            .
+! SFX q   0    a        .
+! SFX q   0    ei       .
+! SFX q   0    e        .
+! SFX q   0    ele      .
+! SFX q   0    elor     .
+  PFX q Y 1
diff -Naur vim74.orig/runtime/synmenu.vim vim74/runtime/synmenu.vim
--- vim74.orig/runtime/synmenu.vim	2013-08-10 12:22:18.000000000 +0000
+++ vim74/runtime/synmenu.vim	2014-10-10 14:53:42.252052474 +0000
@@ -2,7 +2,7 @@
 " This file is normally sourced from menu.vim.
 "
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2013 Jun 24
+" Last Change:	2014 Aug 13
 
 " Define the SetSyn function, used for the Syntax menu entries.
 " Set 'filetype' and also 'syntax' if it is manually selected.
@@ -326,6 +326,7 @@
 an 50.70.280 &Syntax.M.Metafont :cal SetSyn("mf")<CR>
 an 50.70.290 &Syntax.M.MetaPost :cal SetSyn("mp")<CR>
 an 50.70.300 &Syntax.M.MGL :cal SetSyn("mgl")<CR>
+an 50.70.305 &Syntax.M.MIX :cal SetSyn("mix")<CR>
 an 50.70.310 &Syntax.M.MMIX :cal SetSyn("mmix")<CR>
 an 50.70.320 &Syntax.M.Modconf :cal SetSyn("modconf")<CR>
 an 50.70.330 &Syntax.M.Model :cal SetSyn("model")<CR>
diff -Naur vim74.orig/runtime/syntax/a65.vim vim74/runtime/syntax/a65.vim
--- vim74.orig/runtime/syntax/a65.vim	2010-05-15 11:03:57.000000000 +0000
+++ vim74/runtime/syntax/a65.vim	2014-10-10 14:53:42.262052449 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:	xa 6502 cross assembler
-" Maintainer:	Clemens Kirchgatterer <clemens@thf.ath.cx>
-" Last Change:	2003 May 03
+" Maintainer:	Clemens Kirchgatterer <clemens@1541.org>
+" Last Change:	2014 Jan 05
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
diff -Naur vim74.orig/runtime/syntax/apache.vim vim74/runtime/syntax/apache.vim
--- vim74.orig/runtime/syntax/apache.vim	2010-05-15 11:03:57.000000000 +0000
+++ vim74/runtime/syntax/apache.vim	2014-10-10 14:53:42.302052348 +0000
@@ -1,11 +1,9 @@
 " Vim syntax file
-" This is a GENERATED FILE. Please always refer to source file at the URI below.
 " Language: Apache configuration (httpd.conf, srm.conf, access.conf, .htaccess)
-" Maintainer: David Ne\v{c}as (Yeti) <yeti@physics.muni.cz>
+" Maintainer: David Necas (Yeti) <yeti@physics.muni.cz>
 " License: This file can be redistribued and/or modified under the same terms
 "		as Vim itself.
-" Last Change: 2006-12-13
-" URL: http://trific.ath.cx/Ftp/vim/syntax/apache.vim
+" Last Change: 2014-03-04
 " Notes: Last synced with apache-2.2.3, version 1.x is no longer supported
 " TODO: see particular FIXME's scattered through the file
 "		make it really linewise?
@@ -30,7 +28,10 @@
 syn case ignore
 syn match apacheAnything "\s[^>]*" contained
 syn match apacheError "\w\+" contained
-syn region apacheString start=+"+ end=+"+ skip=+\\\\\|\\\"+
+syn region apacheString start=+"+ end=+"+ skip=+\\\\\|\\\"+ oneline
+
+" Following is to prevent escaped quotes from being parsed as strings.
+syn match apacheSkipQuote +\\"+
 
 " Core and mpm
 syn keyword apacheDeclaration AccessFileName AddDefaultCharset AllowOverride AuthName AuthType ContentDigest DefaultType DocumentRoot ErrorDocument ErrorLog HostNameLookups IdentityCheck Include KeepAlive KeepAliveTimeout LimitRequestBody LimitRequestFields LimitRequestFieldsize LimitRequestLine LogLevel MaxKeepAliveRequests NameVirtualHost Options Require RLimitCPU RLimitMEM RLimitNPROC Satisfy ScriptInterpreterSource ServerAdmin ServerAlias ServerName ServerPath ServerRoot ServerSignature ServerTokens TimeOut UseCanonicalName
@@ -156,7 +157,7 @@
 syn keyword apacheDeclaration PerlFreshRestart PerlSendHeader
 syn keyword apacheDeclaration php_value php_flag php_admin_value php_admin_flag
 syn match apacheSection "<\/\=\(Proxy\|ProxyMatch\)[^>]*>" contains=apacheAnything
-syn keyword apacheDeclaration AllowCONNECT NoProxy ProxyBadHeader ProxyBlock ProxyDomain ProxyErrorOverride ProxyIOBufferSize ProxyMaxForwards ProxyPass ProxyPassReverse ProxyPassReverseCookieDomain ProxyPassReverseCookiePath ProxyPreserveHost ProxyReceiveBufferSize ProxyRemote ProxyRemoteMatch ProxyRequests ProxyTimeout ProxyVia
+syn keyword apacheDeclaration AllowCONNECT NoProxy ProxyBadHeader ProxyBlock ProxyDomain ProxyErrorOverride ProxyIOBufferSize ProxyMaxForwards ProxyPass ProxyPassMatch ProxyPassReverse ProxyPassReverseCookieDomain ProxyPassReverseCookiePath ProxyPreserveHost ProxyReceiveBufferSize ProxyRemote ProxyRemoteMatch ProxyRequests ProxyTimeout ProxyVia
 syn keyword apacheDeclaration RewriteBase RewriteCond RewriteEngine RewriteLock RewriteLog RewriteLogLevel RewriteMap RewriteOptions RewriteRule
 syn keyword apacheOption inherit
 syn keyword apacheDeclaration BrowserMatch BrowserMatchNoCase SetEnvIf SetEnvIfNoCase
diff -Naur vim74.orig/runtime/syntax/arduino.vim vim74/runtime/syntax/arduino.vim
--- vim74.orig/runtime/syntax/arduino.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/arduino.vim	2014-10-10 14:53:42.308718998 +0000
@@ -0,0 +1,61 @@
+" Vim syntax file
+" Language:    Arduino
+" Maintainer:  Johannes Hoff <johannes@johanneshoff.com>
+" Last Change: 2011 June 3
+" License:     VIM license (:help license, replace vim by arduino.vim)
+
+" Syntax highlighting like in the Arduino IDE
+" Keywords extracted from <arduino>/build/shared/lib/keywords.txt (arduino
+" version 0021)
+
+" Thanks to Rik, Erik Nomitch, Adam Obeng and Graeme Cross for helpful feedback!
+
+" For version 5.x: Clear all syntax items
+" For version 6.x: Quit when a syntax file was already loaded
+if version < 600
+  syntax clear
+elseif exists("b:current_syntax")
+  finish
+endif
+
+" Read the C syntax to start with
+if version < 600
+  so <sfile>:p:h/cpp.vim
+else
+  runtime! syntax/cpp.vim
+endif
+
+syn keyword arduinoConstant HIGH LOW INPUT OUTPUT
+syn keyword arduinoConstant DEC BIN HEX OCT BYTE
+syn keyword arduinoConstant PI HALF_PI TWO_PI
+syn keyword arduinoConstant LSBFIRST MSBFIRST 
+syn keyword arduinoConstant CHANGE FALLING RISING 
+syn keyword arduinoConstant SERIAL DISPLAY
+syn keyword arduinoConstant DEFAULT EXTERNAL INTERNAL INTERNAL1V1 INTERNAL2V56
+
+syn keyword arduinoStdFunc abs acos asin atan atan2 ceil constrain
+syn keyword arduinoStdFunc cos degrees exp floor log
+syn keyword arduinoStdFunc map max min pow radians 
+syn keyword arduinoStdFunc round sin sq sqrt tan
+syn keyword arduinoStdFunc randomSeed random
+
+syn keyword arduinoFunc analogReference analogRead analogWrite 
+syn keyword arduinoFunc attachInterrupt detachInterrupt interrupts noInterrupts 
+syn keyword arduinoFunc lowByte highByte bitRead bitWrite bitSet bitClear
+syn keyword arduinoFunc millis micros delay delayMicroseconds 
+syn keyword arduinoFunc pinMode digitalWrite digitalRead 
+syn keyword arduinoFunc tone noTone pulseIn shiftOut 
+
+syn keyword arduinoMethod setup loop
+syn keyword arduinoMethod begin end available read flush print println write peek
+
+syn keyword arduinoType boolean byte word String 
+
+syn keyword arduinoModule Serial Serial1 Serial2 Serial3
+
+hi def link arduinoType Type
+hi def link arduinoConstant Constant
+hi def link arduinoStdFunc Function
+hi def link arduinoFunc Function
+hi def link arduinoMethod Function
+hi def link arduinoModule Identifier
diff -Naur vim74.orig/runtime/syntax/asciidoc.vim vim74/runtime/syntax/asciidoc.vim
--- vim74.orig/runtime/syntax/asciidoc.vim	2013-03-15 17:55:10.000000000 +0000
+++ vim74/runtime/syntax/asciidoc.vim	2014-10-10 14:53:42.312052323 +0000
@@ -5,6 +5,7 @@
 " URL:          http://asciidoc.org/
 " Licence:      GPL (http://www.gnu.org)
 " Remarks:      Vim 6 or greater
+" Last Update:  2014 Aug 29 (see Issue 240)
 " Limitations:
 " 
 " - Nested quoted text formatting is highlighted according to the outer
@@ -155,7 +156,8 @@
 hi def link asciidocQuotedBold Special
 hi def link asciidocQuotedDoubleQuoted Label
 hi def link asciidocQuotedEmphasized2 Type
-hi def link asciidocQuotedEmphasized Type
+hi asciidocQuotedEmphasizedItalic term=italic cterm=italic gui=italic
+hi def link asciidocQuotedEmphasized asciidocQuotedEmphasizedItalic
 hi def link asciidocQuotedMonospaced2 Identifier
 hi def link asciidocQuotedMonospaced Identifier
 hi def link asciidocQuotedSingleQuoted Label
diff -Naur vim74.orig/runtime/syntax/asm.vim vim74/runtime/syntax/asm.vim
--- vim74.orig/runtime/syntax/asm.vim	2012-04-09 19:37:34.000000000 +0000
+++ vim74/runtime/syntax/asm.vim	2014-10-10 14:53:42.315385648 +0000
@@ -3,7 +3,7 @@
 " Maintainer:	Erik Wognsen <erik.wognsen@gmail.com>
 "		Previous maintainer:
 "		Kevin Dahlhausen <kdahlhaus@yahoo.com>
-" Last Change:	2012 Apr 09
+" Last Change:	2014 Feb 04
 
 " Thanks to Ori Avtalion for feedback on the comment markers!
 
@@ -93,7 +93,11 @@
 syn match asmMacro		"\.macro"
 syn match asmMacro		"\.endm"
 
-syn match asmDirective		"\.[a-z][a-z]\+"
+" Assembler directives start with a '.' and may contain upper case (e.g.,
+" .ABORT), numbers (e.g., .p2align), dash (e.g., .app-file) and underscore in
+" CFI directives (e.g., .cfi_startproc). This will also match labels starting
+" with '.', including the GCC auto-generated '.L' labels.
+syn match asmDirective		"\.[A-Za-z][0-9A-Za-z-_]*"
 
 
 syn case match
diff -Naur vim74.orig/runtime/syntax/bib.vim vim74/runtime/syntax/bib.vim
--- vim74.orig/runtime/syntax/bib.vim	2011-12-30 11:30:00.000000000 +0000
+++ vim74/runtime/syntax/bib.vim	2014-10-10 14:53:42.365385523 +0000
@@ -2,7 +2,7 @@
 " Language:	BibTeX (bibliographic database format for (La)TeX)
 " Maintainer:	Bernd Feige <Bernd.Feige@gmx.net>
 " Filenames:	*.bib
-" Last Change:	2011 Dec 25
+" Last Change:	2014 Mar 26
 
 " Thanks to those who pointed out problems with this file or supplied fixes!
 
@@ -28,7 +28,7 @@
 syn keyword bibType contained	incollection inproceedings manual
 syn keyword bibType contained	mastersthesis misc phdthesis
 syn keyword bibType contained	proceedings techreport unpublished
-syn keyword bibType contained	string
+syn keyword bibType contained	string preamble
 
 syn keyword bibEntryKw contained	address annote author booktitle chapter
 syn keyword bibEntryKw contained	crossref edition editor howpublished
diff -Naur vim74.orig/runtime/syntax/c.vim vim74/runtime/syntax/c.vim
--- vim74.orig/runtime/syntax/c.vim	2013-07-05 16:09:23.000000000 +0000
+++ vim74/runtime/syntax/c.vim	2014-10-10 14:53:42.378718822 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:	C
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2013 Jul 05
+" Last Change:	2014 Sep 23
 
 " Quit when a (custom) syntax file was already loaded
 if exists("b:current_syntax")
@@ -35,28 +35,37 @@
 if !exists("c_no_utf")
   syn match	cSpecial	display contained "\\\(u\x\{4}\|U\x\{8}\)"
 endif
-if exists("c_no_cformat")
-  syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
-  " cCppString: same as cString, but ends at end of line
-  if !exists("cpp_no_cpp11") " ISO C++11
-    syn region cCppString	start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
-  else
-    syn region cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
-  endif
-  syn region	cCppOut2	contained start="0" end="^\s*\(%:\|#\)\s*\(endif\>\|else\>\|elif\>\)" contains=cSpaceError,cCppSkip
-  syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
-else
+
+if !exists("c_no_cformat")
+  " Highlight % items in strings.
   if !exists("c_no_c99") " ISO C99
     syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlLjzt]\|ll\|hh\)\=\([aAbdiuoxXDOUfFeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
   else
     syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlL]\|ll\)\=\([bdiuoxXDOUfeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
   endif
   syn match	cFormat		display "%%" contained
+endif
+
+" cCppString: same as cString, but ends at end of line
+if s:ft ==# "cpp" && !exists("cpp_no_cpp11")
+  " ISO C++11
+  syn region	cString		start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
+  syn region 	cCppString	start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
+elseif s:ft ==# "c" && !exists("c_no_c11")
+  " ISO C99
+  syn region	cString		start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
+  syn region	cCppString	start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
+else
+  " older C or C++
   syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
-  " cCppString: same as cString, but ends at end of line
   syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
 endif
 
+syn region	cCppOut2	contained start="0" end="^\s*\(%:\|#\)\s*\(endif\>\|else\>\|elif\>\)" contains=cSpaceError,cCppSkip
+syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
+
+syn cluster	cStringGroup	contains=cCppString,cCppOut2,cCppSkip
+
 syn match	cCharacter	"L\='[^\\]'"
 syn match	cCharacter	"L'[^']*'" contains=cSpecial
 if exists("c_gnu")
@@ -70,12 +79,9 @@
 syn match	cSpecialCharacter display "'\\x\x\{1,2}'"
 syn match	cSpecialCharacter display "L'\\x\x\+'"
 
-if !exists("c_no_c11") " ISO C11
-  if exists("c_no_cformat")
-    syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
-  else
-    syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
-  endif
+if (s:ft ==# "c" && !exists("c_no_c11")) || (s:ft ==# "cpp" && !exists("cpp_no_cpp11"))
+  " ISO C11 or ISO C++ 11
+  syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
   syn match	cCharacter	"[Uu]'[^\\]'"
   syn match	cCharacter	"[Uu]'[^']*'" contains=cSpecial
   if exists("c_gnu")
@@ -102,24 +108,24 @@
 " This should be before cErrInParen to avoid problems with #define ({ xxx })
 if exists("c_curly_error")
   syn match cCurlyError "}"
-  syn region	cBlock		start="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,cCppString,@Spell fold
+  syn region	cBlock		start="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell fold
 else
   syn region	cBlock		start="{" end="}" transparent fold
 endif
 
-"catch errors caused by wrong parenthesis and brackets
-" also accept <% for {, %> for }, <: for [ and :> for ] (C99)
+" Catch errors caused by wrong parenthesis and brackets.
+" Also accept <% for {, %> for }, <: for [ and :> for ] (C99)
 " But avoid matching <::.
 syn cluster	cParenGroup	contains=cParenError,cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserLabel,cBitField,cOctalZero,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom
 if exists("c_no_curly_error")
   if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
-    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cCppString,@Spell
+    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
     syn match	cParenError	display ")"
     syn match	cErrInParen	display contained "^^<%\|^%>"
   else
-    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cCppString,@Spell
+    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
     syn match	cParenError	display ")"
@@ -127,13 +133,13 @@
   endif
 elseif exists("c_no_bracket_error")
   if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
-    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cCppString,@Spell
+    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
     syn match	cParenError	display ")"
     syn match	cErrInParen	display contained "<%\|%>"
   else
-    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cCppString,@Spell
+    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
     syn match	cParenError	display ")"
@@ -141,19 +147,19 @@
   endif
 else
   if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
-    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,cCppString,@Spell
+    syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
     syn match	cParenError	display "[\])]"
     syn match	cErrInParen	display contained "<%\|%>"
-    syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,cCppString,@Spell
+    syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
   else
-    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,cCppString,@Spell
+    syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
     " cCppParen: same as cParen but ends at end-of-line; used in cDefine
     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
     syn match	cParenError	display "[\])]"
     syn match	cErrInParen	display contained "[\]{}]\|<%\|%>"
-    syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,cCppString,@Spell
+    syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
   endif
   " cCppBracket: same as cParen but ends at end-of-line; used in cDefine
   syn region	cCppBracket	transparent start='\[\|<::\@!' skip='\\$' excludenl end=']\|:>' end='$' contained contains=ALLBUT,@cParenGroup,cErrInParen,cParen,cBracket,cString,@Spell
@@ -322,6 +328,9 @@
   syn keyword cConstant SEEK_CUR SEEK_END SEEK_SET
   syn keyword cConstant TMP_MAX stderr stdin stdout
   syn keyword cConstant EXIT_FAILURE EXIT_SUCCESS RAND_MAX
+  " POSIX 2001
+  syn keyword cConstant SIGBUS SIGPOLL SIGPROF SIGSYS SIGURG
+  syn keyword cConstant SIGVTALRM SIGXCPU SIGXFSZ
   " Add POSIX errors as well
   syn keyword cConstant E2BIG EACCES EAGAIN EBADF EBADMSG EBUSY
   syn keyword cConstant ECANCELED ECHILD EDEADLK EDOM EEXIST EFAULT
@@ -373,7 +382,7 @@
 " Highlight User Labels
 syn cluster	cMultiGroup	contains=cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserCont,cUserLabel,cBitField,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cCppParen,cCppBracket,cCppString
 if s:ft ==# 'c' || exists("cpp_no_cpp11")
-  syn region	cMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell
+  syn region	cMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell,@cStringGroup
 endif
 " Avoid matching foo::bar() in C++ by requiring that the next char is not ':'
 syn cluster	cLabelGroup	contains=cUserLabel
diff -Naur vim74.orig/runtime/syntax/clean.vim vim74/runtime/syntax/clean.vim
--- vim74.orig/runtime/syntax/clean.vim	2013-06-19 19:34:33.000000000 +0000
+++ vim74/runtime/syntax/clean.vim	2014-10-10 14:53:42.412052072 +0000
@@ -2,7 +2,7 @@
 " Language:		Clean
 " Author:		Pieter van Engelen <pietere@sci.kun.nl>
 " Co-Author:	Arthur van Leeuwen <arthurvl@sci.kun.nl>
-" Last Change:	2013 Jun 19 by Jurrin Stutterheim
+" Last Change:	2013 Oct 15 by Jurrin Stutterheim
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -31,11 +31,10 @@
 
 " To do some Denotation Highlighting
 syn keyword cleanBoolDenot True False
-syn region  cleanStringDenot start=+"+ end=+"+
-syn match cleanCharDenot "'.'"
-syn match cleanCharsDenot "'[^'\\]*\(\\.[^'\\]\)*'" contained
-syn match cleanIntegerDenot "[+-~]\=\<\(\d\+\|0[0-7]\+\|0x[0-9A-Fa-f]\+\)\>"
-syn match cleanRealDenot "[+-~]\=\<\d\+\.\d+\(E[+-~]\=\d+\)\="
+syn region cleanStringDenot start=+"+ skip=+\(\(\\\\\)\+\|\\"\)+ end=+"+ display
+syn match cleanCharDenot "'\(\\\\\|\\'\|[^'\\]\)\+'" display
+syn match cleanIntegerDenot "[\~+-]\?\<\(\d\+\|0[0-7]\+\|0x[0-9A-Fa-f]\+\)\>" display
+syn match cleanRealDenot "[\~+-]\?\d\+\.\d\+\(E[\~+-]\?\d\+\)\?" display
 
 " To highlight the use of lists, tuples and arrays
 syn region cleanList start="\[" end="\]" contains=ALL
@@ -44,11 +43,13 @@
 syn match cleanTuple "([^=]*,[^=]*)" contains=ALL
 
 " To do some Comment Highlighting
-syn region cleanComment start="/\*"  end="\*/" contains=cleanComment
-syn match cleanComment "//.*"
+syn region cleanComment start="/\*"  end="\*/" contains=cleanComment,cleanTodo fold
+syn region cleanComment start="//.*" end="$" display contains=cleanTodo
+syn keyword cleanTodo TODO FIXME XXX contained
+
+" Now for some useful type definition recognition
+syn match cleanFuncTypeDef "\([a-zA-Z].*\|(\=[-~@#$%^?!+*<>\/|&=:]\+)\=\)\s*\(infix[lr]\=\)\=\s*\d\=\s*::.*->.*" contains=cleanSpecial,cleanBasicType,cleanSpecialType,cleanKeyword
 
-" Now for some useful typedefinitionrecognition
-syn match cleanFuncTypeDef "\([a-zA-Z].*\|(\=[-~@#$%^?!+*<>\/|&=:]\+)\=\)[ \t]*\(infix[lr]\=\)\=[ \t]*\d\=[ \t]*::.*->.*" contains=cleanSpecial
 
 " Define the default highlighting.
 " For version 5.7 and earlier: only when not done already
@@ -64,7 +65,6 @@
    " Comments
    HiLink cleanComment      Comment
    " Constants and denotations
-   HiLink cleanCharsDenot   String
    HiLink cleanStringDenot  String
    HiLink cleanCharDenot    Character
    HiLink cleanIntegerDenot Number
@@ -91,6 +91,7 @@
    HiLink cleanTuple		Special
    " Error
    " Todo
+   HiLink cleanTodo         Todo
 
   delcommand HiLink
 endif
diff -Naur vim74.orig/runtime/syntax/clojure.vim vim74/runtime/syntax/clojure.vim
--- vim74.orig/runtime/syntax/clojure.vim	2013-02-06 14:35:23.000000000 +0000
+++ vim74/runtime/syntax/clojure.vim	2014-10-10 14:53:42.415385397 +0000
@@ -1,34 +1,37 @@
 " Vim syntax file
-" Language:     Clojure
-" Authors:      Toralf Wittner <toralf.wittner@gmail.com>
-"               modified by Meikel Brandmeyer <mb@kotka.de>
-" URL:          http://kotka.de/projects/clojure/vimclojure.html
+" Language:	Clojure
+" Authors:	Toralf Wittner <toralf.wittner@gmail.com>
+"		modified by Meikel Brandmeyer <mb@kotka.de>
+" URL:		http://kotka.de/projects/clojure/vimclojure.html
 "
-" Maintainer:   Sung Pae <self@sungpae.com>
-" URL:          https://github.com/guns/vim-clojure-static
-" License:      Same as Vim
-" Last Change:  05 February 2013
-
-if version < 600
-    syntax clear
-elseif exists("b:current_syntax")
-    finish
+" Contributors:	Joel Holdbrooks <cjholdbrooks@gmail.com> (Regexp support, bug fixes)
+"
+" Maintainer:	Sung Pae <self@sungpae.com>
+" URL:		https://github.com/guns/vim-clojure-static
+" License:	Same as Vim
+" Last Change:	27 March 2014
+
+if exists("b:current_syntax")
+	finish
 endif
 
-setlocal iskeyword+=?,-,*,!,+,/,=,<,>,.,:,$
+if has("folding") && exists("g:clojure_fold") && g:clojure_fold > 0
+	setlocal foldmethod=syntax
+endif
 
-" Generated from https://github.com/guns/vim-clojure-static/blob/vim-release-002/vim_clojure_static.clj
-" Clojure 1.5.0-RC6
+" -*- KEYWORDS -*-
+" Generated from https://github.com/guns/vim-clojure-static/blob/vim-release-010/clj/src/vim_clojure_static/generate.clj
+" Clojure version 1.6.0
 syntax keyword clojureConstant nil
 syntax keyword clojureBoolean false true
 syntax keyword clojureSpecial . catch clojure.core/fn clojure.core/let clojure.core/loop def do finally fn if let loop monitor-enter monitor-exit new quote recur set! throw try var
 syntax keyword clojureException catch finally throw try
-syntax keyword clojureCond case clojure.core/case clojure.core/cond clojure.core/cond-> clojure.core/cond->> clojure.core/condp clojure.core/if-let clojure.core/if-not clojure.core/when clojure.core/when-first clojure.core/when-let clojure.core/when-not cond cond-> cond->> condp if-let if-not when when-first when-let when-not
-syntax keyword clojureRepeat clojure.core/doall clojure.core/dorun clojure.core/doseq clojure.core/dotimes clojure.core/while doall dorun doseq dotimes while
+syntax keyword clojureCond case clojure.core/case clojure.core/cond clojure.core/cond-> clojure.core/cond->> clojure.core/condp clojure.core/if-let clojure.core/if-not clojure.core/if-some clojure.core/when clojure.core/when-first clojure.core/when-let clojure.core/when-not clojure.core/when-some cond cond-> cond->> condp if-let if-not if-some when when-first when-let when-not when-some
+syntax keyword clojureRepeat clojure.core/doseq clojure.core/dotimes clojure.core/while doseq dotimes while
 syntax keyword clojureDefine clojure.core/definline clojure.core/definterface clojure.core/defmacro clojure.core/defmethod clojure.core/defmulti clojure.core/defn clojure.core/defn- clojure.core/defonce clojure.core/defprotocol clojure.core/defrecord clojure.core/defstruct clojure.core/deftype definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol defrecord defstruct deftype
 syntax keyword clojureMacro -> ->> .. amap and areduce as-> assert binding bound-fn clojure.core/-> clojure.core/->> clojure.core/.. clojure.core/amap clojure.core/and clojure.core/areduce clojure.core/as-> clojure.core/assert clojure.core/binding clojure.core/bound-fn clojure.core/comment clojure.core/declare clojure.core/delay clojure.core/dosync clojure.core/doto clojure.core/extend-protocol clojure.core/extend-type clojure.core/for clojure.core/future clojure.core/gen-class clojure.core/gen-interface clojure.core/import clojure.core/io! clojure.core/lazy-cat clojure.core/lazy-seq clojure.core/letfn clojure.core/locking clojure.core/memfn clojure.core/ns clojure.core/or clojure.core/proxy clojure.core/proxy-super clojure.core/pvalues clojure.core/refer-clojure clojure.core/reify clojure.core/some-> clojure.core/some->> clojure.core/sync clojure.core/time clojure.core/with-bindings clojure.core/with-in-str clojure.core/with-loading-context clojure.core/with-local-vars clojure.core/with-open clojure.core/with-out-str clojure.core/with-precision clojure.core/with-redefs comment declare delay dosync doto extend-protocol extend-type for future gen-class gen-interface import io! lazy-cat lazy-seq letfn locking memfn ns or proxy proxy-super pvalues refer-clojure reify some-> some->> sync time with-bindings with-in-str with-loading-context with-local-vars with-open with-out-str with-precision with-redefs
-syntax keyword clojureFunc * *' + +' - -' ->ArrayChunk ->Vec ->VecNode ->VecSeq -cache-protocol-fn -reset-methods / < <= = == > >= accessor aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! alter-var-root ancestors apply array-map aset aset-boolean aset-byte aset-char aset-double aset-float aset-int aset-long aset-short assoc assoc! assoc-in associative? atom await await-for await1 bases bean bigdec bigint biginteger bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn* bound? butlast byte byte-array bytes cast char char-array char? chars chunk chunk-append chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors clojure-version clojure.core/* clojure.core/*' clojure.core/+ clojure.core/+' clojure.core/- clojure.core/-' clojure.core/->ArrayChunk clojure.core/->Vec clojure.core/->VecNode clojure.core/->VecSeq clojure.core/-cache-protocol-fn clojure.core/-reset-methods clojure.core// clojure.core/< clojure.core/<= clojure.core/= clojure.core/== clojure.core/> clojure.core/>= clojure.core/accessor clojure.core/aclone clojure.core/add-classpath clojure.core/add-watch clojure.core/agent clojure.core/agent-error clojure.core/agent-errors clojure.core/aget clojure.core/alength clojure.core/alias clojure.core/all-ns clojure.core/alter clojure.core/alter-meta! clojure.core/alter-var-root clojure.core/ancestors clojure.core/apply clojure.core/array-map clojure.core/aset clojure.core/aset-boolean clojure.core/aset-byte clojure.core/aset-char clojure.core/aset-double clojure.core/aset-float clojure.core/aset-int clojure.core/aset-long clojure.core/aset-short clojure.core/assoc clojure.core/assoc! clojure.core/assoc-in clojure.core/associative? clojure.core/atom clojure.core/await clojure.core/await-for clojure.core/await1 clojure.core/bases clojure.core/bean clojure.core/bigdec clojure.core/bigint clojure.core/biginteger clojure.core/bit-and clojure.core/bit-and-not clojure.core/bit-clear clojure.core/bit-flip clojure.core/bit-not clojure.core/bit-or clojure.core/bit-set clojure.core/bit-shift-left clojure.core/bit-shift-right clojure.core/bit-test clojure.core/bit-xor clojure.core/boolean clojure.core/boolean-array clojure.core/booleans clojure.core/bound-fn* clojure.core/bound? clojure.core/butlast clojure.core/byte clojure.core/byte-array clojure.core/bytes clojure.core/cast clojure.core/char clojure.core/char-array clojure.core/char? clojure.core/chars clojure.core/chunk clojure.core/chunk-append clojure.core/chunk-buffer clojure.core/chunk-cons clojure.core/chunk-first clojure.core/chunk-next clojure.core/chunk-rest clojure.core/chunked-seq? clojure.core/class clojure.core/class? clojure.core/clear-agent-errors clojure.core/clojure-version clojure.core/coll? clojure.core/commute clojure.core/comp clojure.core/comparator clojure.core/compare clojure.core/compare-and-set! clojure.core/compile clojure.core/complement clojure.core/concat clojure.core/conj clojure.core/conj! clojure.core/cons clojure.core/constantly clojure.core/construct-proxy clojure.core/contains? clojure.core/count clojure.core/counted? clojure.core/create-ns clojure.core/create-struct clojure.core/cycle clojure.core/dec clojure.core/dec' clojure.core/decimal? clojure.core/delay? clojure.core/deliver clojure.core/denominator clojure.core/deref clojure.core/derive clojure.core/descendants clojure.core/destructure clojure.core/disj clojure.core/disj! clojure.core/dissoc clojure.core/dissoc! clojure.core/distinct clojure.core/distinct? clojure.core/double clojure.core/double-array clojure.core/doubles clojure.core/drop clojure.core/drop-last clojure.core/drop-while clojure.core/empty clojure.core/empty? clojure.core/ensure clojure.core/enumeration-seq clojure.core/error-handler clojure.core/error-mode clojure.core/eval clojure.core/even? clojure.core/every-pred clojure.core/every? clojure.core/ex-data clojure.core/ex-info clojure.core/extend clojure.core/extenders clojure.core/extends? clojure.core/false? clojure.core/ffirst clojure.core/file-seq clojure.core/filter clojure.core/filterv clojure.core/find clojure.core/find-keyword clojure.core/find-ns clojure.core/find-protocol-impl clojure.core/find-protocol-method clojure.core/find-var clojure.core/first clojure.core/flatten clojure.core/float clojure.core/float-array clojure.core/float? clojure.core/floats clojure.core/flush clojure.core/fn? clojure.core/fnext clojure.core/fnil clojure.core/force clojure.core/format clojure.core/frequencies clojure.core/future-call clojure.core/future-cancel clojure.core/future-cancelled? clojure.core/future-done? clojure.core/future? clojure.core/gensym clojure.core/get clojure.core/get-in clojure.core/get-method clojure.core/get-proxy-class clojure.core/get-thread-bindings clojure.core/get-validator clojure.core/group-by clojure.core/hash clojure.core/hash-combine clojure.core/hash-map clojure.core/hash-set clojure.core/identical? clojure.core/identity clojure.core/ifn? clojure.core/in-ns clojure.core/inc clojure.core/inc' clojure.core/init-proxy clojure.core/instance? clojure.core/int clojure.core/int-array clojure.core/integer? clojure.core/interleave clojure.core/intern clojure.core/interpose clojure.core/into clojure.core/into-array clojure.core/ints clojure.core/isa? clojure.core/iterate clojure.core/iterator-seq clojure.core/juxt clojure.core/keep clojure.core/keep-indexed clojure.core/key clojure.core/keys clojure.core/keyword clojure.core/keyword? clojure.core/last clojure.core/line-seq clojure.core/list clojure.core/list* clojure.core/list? clojure.core/load clojure.core/load-file clojure.core/load-reader clojure.core/load-string clojure.core/loaded-libs clojure.core/long clojure.core/long-array clojure.core/longs clojure.core/macroexpand clojure.core/macroexpand-1 clojure.core/make-array clojure.core/make-hierarchy clojure.core/map clojure.core/map-indexed clojure.core/map? clojure.core/mapcat clojure.core/mapv clojure.core/max clojure.core/max-key clojure.core/memoize clojure.core/merge clojure.core/merge-with clojure.core/meta clojure.core/method-sig clojure.core/methods clojure.core/min clojure.core/min-key clojure.core/mod clojure.core/munge clojure.core/name clojure.core/namespace clojure.core/namespace-munge clojure.core/neg? clojure.core/newline clojure.core/next clojure.core/nfirst clojure.core/nil? clojure.core/nnext clojure.core/not clojure.core/not-any? clojure.core/not-empty clojure.core/not-every? clojure.core/not= clojure.core/ns-aliases clojure.core/ns-imports clojure.core/ns-interns clojure.core/ns-map clojure.core/ns-name clojure.core/ns-publics clojure.core/ns-refers clojure.core/ns-resolve clojure.core/ns-unalias clojure.core/ns-unmap clojure.core/nth clojure.core/nthnext clojure.core/nthrest clojure.core/num clojure.core/number? clojure.core/numerator clojure.core/object-array clojure.core/odd? clojure.core/parents clojure.core/partial clojure.core/partition clojure.core/partition-all clojure.core/partition-by clojure.core/pcalls clojure.core/peek clojure.core/persistent! clojure.core/pmap clojure.core/pop clojure.core/pop! clojure.core/pop-thread-bindings clojure.core/pos? clojure.core/pr clojure.core/pr-str clojure.core/prefer-method clojure.core/prefers clojure.core/print clojure.core/print-ctor clojure.core/print-simple clojure.core/print-str clojure.core/printf clojure.core/println clojure.core/println-str clojure.core/prn clojure.core/prn-str clojure.core/promise clojure.core/proxy-call-with-super clojure.core/proxy-mappings clojure.core/proxy-name clojure.core/push-thread-bindings clojure.core/quot clojure.core/rand clojure.core/rand-int clojure.core/rand-nth clojure.core/range clojure.core/ratio? clojure.core/rational? clojure.core/rationalize clojure.core/re-find clojure.core/re-groups clojure.core/re-matcher clojure.core/re-matches clojure.core/re-pattern clojure.core/re-seq clojure.core/read clojure.core/read-line clojure.core/read-string clojure.core/realized? clojure.core/reduce clojure.core/reduce-kv clojure.core/reduced clojure.core/reduced? clojure.core/reductions clojure.core/ref clojure.core/ref-history-count clojure.core/ref-max-history clojure.core/ref-min-history clojure.core/ref-set clojure.core/refer clojure.core/release-pending-sends clojure.core/rem clojure.core/remove clojure.core/remove-all-methods clojure.core/remove-method clojure.core/remove-ns clojure.core/remove-watch clojure.core/repeat clojure.core/repeatedly clojure.core/replace clojure.core/replicate clojure.core/require clojure.core/reset! clojure.core/reset-meta! clojure.core/resolve clojure.core/rest clojure.core/restart-agent clojure.core/resultset-seq clojure.core/reverse clojure.core/reversible? clojure.core/rseq clojure.core/rsubseq clojure.core/satisfies? clojure.core/second clojure.core/select-keys clojure.core/send clojure.core/send-off clojure.core/send-via clojure.core/seq clojure.core/seq? clojure.core/seque clojure.core/sequence clojure.core/sequential? clojure.core/set clojure.core/set-agent-send-executor! clojure.core/set-agent-send-off-executor! clojure.core/set-error-handler! clojure.core/set-error-mode! clojure.core/set-validator! clojure.core/set? clojure.core/short clojure.core/short-array clojure.core/shorts clojure.core/shuffle clojure.core/shutdown-agents clojure.core/slurp clojure.core/some clojure.core/some-fn clojure.core/sort clojure.core/sort-by clojure.core/sorted-map clojure.core/sorted-map-by clojure.core/sorted-set clojure.core/sorted-set-by clojure.core/sorted? clojure.core/special-symbol? clojure.core/spit clojure.core/split-at clojure.core/split-with clojure.core/str clojure.core/string? clojure.core/struct clojure.core/struct-map clojure.core/subs clojure.core/subseq clojure.core/subvec clojure.core/supers clojure.core/swap! clojure.core/symbol clojure.core/symbol? clojure.core/take clojure.core/take-last clojure.core/take-nth clojure.core/take-while clojure.core/test clojure.core/the-ns clojure.core/thread-bound? clojure.core/to-array clojure.core/to-array-2d clojure.core/trampoline clojure.core/transient clojure.core/tree-seq clojure.core/true? clojure.core/type clojure.core/unchecked-add clojure.core/unchecked-add-int clojure.core/unchecked-byte clojure.core/unchecked-char clojure.core/unchecked-dec clojure.core/unchecked-dec-int clojure.core/unchecked-divide-int clojure.core/unchecked-double clojure.core/unchecked-float clojure.core/unchecked-inc clojure.core/unchecked-inc-int clojure.core/unchecked-int clojure.core/unchecked-long clojure.core/unchecked-multiply clojure.core/unchecked-multiply-int clojure.core/unchecked-negate clojure.core/unchecked-negate-int clojure.core/unchecked-remainder-int clojure.core/unchecked-short clojure.core/unchecked-subtract clojure.core/unchecked-subtract-int clojure.core/underive clojure.core/update-in clojure.core/update-proxy clojure.core/use clojure.core/val clojure.core/vals clojure.core/var-get clojure.core/var-set clojure.core/var? clojure.core/vary-meta clojure.core/vec clojure.core/vector clojure.core/vector-of clojure.core/vector? clojure.core/with-bindings* clojure.core/with-meta clojure.core/with-redefs-fn clojure.core/xml-seq clojure.core/zero? clojure.core/zipmap coll? commute comp comparator compare compare-and-set! compile complement concat conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? delay? deliver denominator deref derive descendants destructure disj disj! dissoc dissoc! distinct distinct? double double-array doubles drop drop-last drop-while empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info extend extenders extends? false? ffirst file-seq filter filterv find find-keyword find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn? fnext fnil force format frequencies future-call future-cancel future-cancelled? future-done? future? gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash hash-combine hash-map hash-set identical? identity ifn? in-ns inc inc' init-proxy instance? int int-array integer? interleave intern interpose into into-array ints isa? iterate iterator-seq juxt keep keep-indexed key keys keyword keyword? last line-seq list list* list? load load-file load-reader load-string loaded-libs long long-array longs macroexpand macroexpand-1 make-array make-hierarchy map map-indexed map? mapcat mapv max max-key memoize merge merge-with meta method-sig methods min min-key mod munge name namespace namespace-munge neg? newline next nfirst nil? nnext not not-any? not-empty not-every? not= ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias ns-unmap nth nthnext nthrest num number? numerator object-array odd? parents partial partition partition-all partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers print print-ctor print-simple print-str printf println println-str prn prn-str promise proxy-call-with-super proxy-mappings proxy-name push-thread-bindings quot rand rand-int rand-nth range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern re-seq read read-line read-string realized? reduce reduce-kv reduced reduced? reductions ref ref-history-count ref-max-history ref-min-history ref-set refer release-pending-sends rem remove remove-all-methods remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest restart-agent resultset-seq reverse reversible? rseq rsubseq satisfies? second select-keys send send-off send-via seq seq? seque sequence sequential? set set-agent-send-executor! set-agent-send-off-executor! set-error-handler! set-error-mode! set-validator! set? short short-array shorts shuffle shutdown-agents slurp some some-fn sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! symbol symbol? take take-last take-nth take-while test the-ns thread-bound? to-array to-array-2d trampoline transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector-of vector? with-bindings* with-meta with-redefs-fn xml-seq zero? zipmap
-syntax keyword clojureVariable *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* *compile-path* *compiler-options* *data-readers* *default-data-reader-fn* *e *err* *file* *flush-on-newline* *fn-loader* *in* *math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* *read-whitelist* *source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* EMPTY-NODE char-escape-string char-name-string clojure.core/*1 clojure.core/*2 clojure.core/*3 clojure.core/*agent* clojure.core/*allow-unresolved-vars* clojure.core/*assert* clojure.core/*clojure-version* clojure.core/*command-line-args* clojure.core/*compile-files* clojure.core/*compile-path* clojure.core/*compiler-options* clojure.core/*data-readers* clojure.core/*default-data-reader-fn* clojure.core/*e clojure.core/*err* clojure.core/*file* clojure.core/*flush-on-newline* clojure.core/*fn-loader* clojure.core/*in* clojure.core/*math-context* clojure.core/*ns* clojure.core/*out* clojure.core/*print-dup* clojure.core/*print-length* clojure.core/*print-level* clojure.core/*print-meta* clojure.core/*print-readably* clojure.core/*read-eval* clojure.core/*read-whitelist* clojure.core/*source-path* clojure.core/*unchecked-math* clojure.core/*use-context-classloader* clojure.core/*verbose-defrecords* clojure.core/*warn-on-reflection* clojure.core/EMPTY-NODE clojure.core/char-escape-string clojure.core/char-name-string clojure.core/default-data-readers clojure.core/primitives-classnames clojure.core/print-dup clojure.core/print-method clojure.core/unquote clojure.core/unquote-splicing default-data-readers primitives-classnames print-dup print-method unquote unquote-splicing
+syntax keyword clojureFunc * *' + +' - -' ->ArrayChunk ->Vec ->VecNode ->VecSeq -cache-protocol-fn -reset-methods / < <= = == > >= accessor aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! alter-var-root ancestors apply array-map aset aset-boolean aset-byte aset-char aset-double aset-float aset-int aset-long aset-short assoc assoc! assoc-in associative? atom await await-for await1 bases bean bigdec bigint biginteger bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn* bound? butlast byte byte-array bytes cast char char-array char? chars chunk chunk-append chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors clojure-version clojure.core/* clojure.core/*' clojure.core/+ clojure.core/+' clojure.core/- clojure.core/-' clojure.core/->ArrayChunk clojure.core/->Vec clojure.core/->VecNode clojure.core/->VecSeq clojure.core/-cache-protocol-fn clojure.core/-reset-methods clojure.core// clojure.core/< clojure.core/<= clojure.core/= clojure.core/== clojure.core/> clojure.core/>= clojure.core/accessor clojure.core/aclone clojure.core/add-classpath clojure.core/add-watch clojure.core/agent clojure.core/agent-error clojure.core/agent-errors clojure.core/aget clojure.core/alength clojure.core/alias clojure.core/all-ns clojure.core/alter clojure.core/alter-meta! clojure.core/alter-var-root clojure.core/ancestors clojure.core/apply clojure.core/array-map clojure.core/aset clojure.core/aset-boolean clojure.core/aset-byte clojure.core/aset-char clojure.core/aset-double clojure.core/aset-float clojure.core/aset-int clojure.core/aset-long clojure.core/aset-short clojure.core/assoc clojure.core/assoc! clojure.core/assoc-in clojure.core/associative? clojure.core/atom clojure.core/await clojure.core/await-for clojure.core/await1 clojure.core/bases clojure.core/bean clojure.core/bigdec clojure.core/bigint clojure.core/biginteger clojure.core/bit-and clojure.core/bit-and-not clojure.core/bit-clear clojure.core/bit-flip clojure.core/bit-not clojure.core/bit-or clojure.core/bit-set clojure.core/bit-shift-left clojure.core/bit-shift-right clojure.core/bit-test clojure.core/bit-xor clojure.core/boolean clojure.core/boolean-array clojure.core/booleans clojure.core/bound-fn* clojure.core/bound? clojure.core/butlast clojure.core/byte clojure.core/byte-array clojure.core/bytes clojure.core/cast clojure.core/char clojure.core/char-array clojure.core/char? clojure.core/chars clojure.core/chunk clojure.core/chunk-append clojure.core/chunk-buffer clojure.core/chunk-cons clojure.core/chunk-first clojure.core/chunk-next clojure.core/chunk-rest clojure.core/chunked-seq? clojure.core/class clojure.core/class? clojure.core/clear-agent-errors clojure.core/clojure-version clojure.core/coll? clojure.core/commute clojure.core/comp clojure.core/comparator clojure.core/compare clojure.core/compare-and-set! clojure.core/compile clojure.core/complement clojure.core/concat clojure.core/conj clojure.core/conj! clojure.core/cons clojure.core/constantly clojure.core/construct-proxy clojure.core/contains? clojure.core/count clojure.core/counted? clojure.core/create-ns clojure.core/create-struct clojure.core/cycle clojure.core/dec clojure.core/dec' clojure.core/decimal? clojure.core/delay? clojure.core/deliver clojure.core/denominator clojure.core/deref clojure.core/derive clojure.core/descendants clojure.core/destructure clojure.core/disj clojure.core/disj! clojure.core/dissoc clojure.core/dissoc! clojure.core/distinct clojure.core/distinct? clojure.core/doall clojure.core/dorun clojure.core/double clojure.core/double-array clojure.core/doubles clojure.core/drop clojure.core/drop-last clojure.core/drop-while clojure.core/empty clojure.core/empty? clojure.core/ensure clojure.core/enumeration-seq clojure.core/error-handler clojure.core/error-mode clojure.core/eval clojure.core/even? clojure.core/every-pred clojure.core/every? clojure.core/ex-data clojure.core/ex-info clojure.core/extend clojure.core/extenders clojure.core/extends? clojure.core/false? clojure.core/ffirst clojure.core/file-seq clojure.core/filter clojure.core/filterv clojure.core/find clojure.core/find-keyword clojure.core/find-ns clojure.core/find-protocol-impl clojure.core/find-protocol-method clojure.core/find-var clojure.core/first clojure.core/flatten clojure.core/float clojure.core/float-array clojure.core/float? clojure.core/floats clojure.core/flush clojure.core/fn? clojure.core/fnext clojure.core/fnil clojure.core/force clojure.core/format clojure.core/frequencies clojure.core/future-call clojure.core/future-cancel clojure.core/future-cancelled? clojure.core/future-done? clojure.core/future? clojure.core/gensym clojure.core/get clojure.core/get-in clojure.core/get-method clojure.core/get-proxy-class clojure.core/get-thread-bindings clojure.core/get-validator clojure.core/group-by clojure.core/hash clojure.core/hash-combine clojure.core/hash-map clojure.core/hash-ordered-coll clojure.core/hash-set clojure.core/hash-unordered-coll clojure.core/identical? clojure.core/identity clojure.core/ifn? clojure.core/in-ns clojure.core/inc clojure.core/inc' clojure.core/init-proxy clojure.core/instance? clojure.core/int clojure.core/int-array clojure.core/integer? clojure.core/interleave clojure.core/intern clojure.core/interpose clojure.core/into clojure.core/into-array clojure.core/ints clojure.core/isa? clojure.core/iterate clojure.core/iterator-seq clojure.core/juxt clojure.core/keep clojure.core/keep-indexed clojure.core/key clojure.core/keys clojure.core/keyword clojure.core/keyword? clojure.core/last clojure.core/line-seq clojure.core/list clojure.core/list* clojure.core/list? clojure.core/load clojure.core/load-file clojure.core/load-reader clojure.core/load-string clojure.core/loaded-libs clojure.core/long clojure.core/long-array clojure.core/longs clojure.core/macroexpand clojure.core/macroexpand-1 clojure.core/make-array clojure.core/make-hierarchy clojure.core/map clojure.core/map-indexed clojure.core/map? clojure.core/mapcat clojure.core/mapv clojure.core/max clojure.core/max-key clojure.core/memoize clojure.core/merge clojure.core/merge-with clojure.core/meta clojure.core/method-sig clojure.core/methods clojure.core/min clojure.core/min-key clojure.core/mix-collection-hash clojure.core/mod clojure.core/munge clojure.core/name clojure.core/namespace clojure.core/namespace-munge clojure.core/neg? clojure.core/newline clojure.core/next clojure.core/nfirst clojure.core/nil? clojure.core/nnext clojure.core/not clojure.core/not-any? clojure.core/not-empty clojure.core/not-every? clojure.core/not= clojure.core/ns-aliases clojure.core/ns-imports clojure.core/ns-interns clojure.core/ns-map clojure.core/ns-name clojure.core/ns-publics clojure.core/ns-refers clojure.core/ns-resolve clojure.core/ns-unalias clojure.core/ns-unmap clojure.core/nth clojure.core/nthnext clojure.core/nthrest clojure.core/num clojure.core/number? clojure.core/numerator clojure.core/object-array clojure.core/odd? clojure.core/parents clojure.core/partial clojure.core/partition clojure.core/partition-all clojure.core/partition-by clojure.core/pcalls clojure.core/peek clojure.core/persistent! clojure.core/pmap clojure.core/pop clojure.core/pop! clojure.core/pop-thread-bindings clojure.core/pos? clojure.core/pr clojure.core/pr-str clojure.core/prefer-method clojure.core/prefers clojure.core/print clojure.core/print-ctor clojure.core/print-dup clojure.core/print-method clojure.core/print-simple clojure.core/print-str clojure.core/printf clojure.core/println clojure.core/println-str clojure.core/prn clojure.core/prn-str clojure.core/promise clojure.core/proxy-call-with-super clojure.core/proxy-mappings clojure.core/proxy-name clojure.core/push-thread-bindings clojure.core/quot clojure.core/rand clojure.core/rand-int clojure.core/rand-nth clojure.core/range clojure.core/ratio? clojure.core/rational? clojure.core/rationalize clojure.core/re-find clojure.core/re-groups clojure.core/re-matcher clojure.core/re-matches clojure.core/re-pattern clojure.core/re-seq clojure.core/read clojure.core/read-line clojure.core/read-string clojure.core/realized? clojure.core/record? clojure.core/reduce clojure.core/reduce-kv clojure.core/reduced clojure.core/reduced? clojure.core/reductions clojure.core/ref clojure.core/ref-history-count clojure.core/ref-max-history clojure.core/ref-min-history clojure.core/ref-set clojure.core/refer clojure.core/release-pending-sends clojure.core/rem clojure.core/remove clojure.core/remove-all-methods clojure.core/remove-method clojure.core/remove-ns clojure.core/remove-watch clojure.core/repeat clojure.core/repeatedly clojure.core/replace clojure.core/replicate clojure.core/require clojure.core/reset! clojure.core/reset-meta! clojure.core/resolve clojure.core/rest clojure.core/restart-agent clojure.core/resultset-seq clojure.core/reverse clojure.core/reversible? clojure.core/rseq clojure.core/rsubseq clojure.core/satisfies? clojure.core/second clojure.core/select-keys clojure.core/send clojure.core/send-off clojure.core/send-via clojure.core/seq clojure.core/seq? clojure.core/seque clojure.core/sequence clojure.core/sequential? clojure.core/set clojure.core/set-agent-send-executor! clojure.core/set-agent-send-off-executor! clojure.core/set-error-handler! clojure.core/set-error-mode! clojure.core/set-validator! clojure.core/set? clojure.core/short clojure.core/short-array clojure.core/shorts clojure.core/shuffle clojure.core/shutdown-agents clojure.core/slurp clojure.core/some clojure.core/some-fn clojure.core/some? clojure.core/sort clojure.core/sort-by clojure.core/sorted-map clojure.core/sorted-map-by clojure.core/sorted-set clojure.core/sorted-set-by clojure.core/sorted? clojure.core/special-symbol? clojure.core/spit clojure.core/split-at clojure.core/split-with clojure.core/str clojure.core/string? clojure.core/struct clojure.core/struct-map clojure.core/subs clojure.core/subseq clojure.core/subvec clojure.core/supers clojure.core/swap! clojure.core/symbol clojure.core/symbol? clojure.core/take clojure.core/take-last clojure.core/take-nth clojure.core/take-while clojure.core/test clojure.core/the-ns clojure.core/thread-bound? clojure.core/to-array clojure.core/to-array-2d clojure.core/trampoline clojure.core/transient clojure.core/tree-seq clojure.core/true? clojure.core/type clojure.core/unchecked-add clojure.core/unchecked-add-int clojure.core/unchecked-byte clojure.core/unchecked-char clojure.core/unchecked-dec clojure.core/unchecked-dec-int clojure.core/unchecked-divide-int clojure.core/unchecked-double clojure.core/unchecked-float clojure.core/unchecked-inc clojure.core/unchecked-inc-int clojure.core/unchecked-int clojure.core/unchecked-long clojure.core/unchecked-multiply clojure.core/unchecked-multiply-int clojure.core/unchecked-negate clojure.core/unchecked-negate-int clojure.core/unchecked-remainder-int clojure.core/unchecked-short clojure.core/unchecked-subtract clojure.core/unchecked-subtract-int clojure.core/underive clojure.core/unsigned-bit-shift-right clojure.core/update-in clojure.core/update-proxy clojure.core/use clojure.core/val clojure.core/vals clojure.core/var-get clojure.core/var-set clojure.core/var? clojure.core/vary-meta clojure.core/vec clojure.core/vector clojure.core/vector-of clojure.core/vector? clojure.core/with-bindings* clojure.core/with-meta clojure.core/with-redefs-fn clojure.core/xml-seq clojure.core/zero? clojure.core/zipmap coll? commute comp comparator compare compare-and-set! compile complement concat conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? delay? deliver denominator deref derive descendants destructure disj disj! dissoc dissoc! distinct distinct? doall dorun double double-array doubles drop drop-last drop-while empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info extend extenders extends? false? ffirst file-seq filter filterv find find-keyword find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn? fnext fnil force format frequencies future-call future-cancel future-cancelled? future-done? future? gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash hash-combine hash-map hash-ordered-coll hash-set hash-unordered-coll identical? identity ifn? in-ns inc inc' init-proxy instance? int int-array integer? interleave intern interpose into into-array ints isa? iterate iterator-seq juxt keep keep-indexed key keys keyword keyword? last line-seq list list* list? load load-file load-reader load-string loaded-libs long long-array longs macroexpand macroexpand-1 make-array make-hierarchy map map-indexed map? mapcat mapv max max-key memoize merge merge-with meta method-sig methods min min-key mix-collection-hash mod munge name namespace namespace-munge neg? newline next nfirst nil? nnext not not-any? not-empty not-every? not= ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias ns-unmap nth nthnext nthrest num number? numerator object-array odd? parents partial partition partition-all partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers print print-ctor print-dup print-method print-simple print-str printf println println-str prn prn-str promise proxy-call-with-super proxy-mappings proxy-name push-thread-bindings quot rand rand-int rand-nth range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern re-seq read read-line read-string realized? record? reduce reduce-kv reduced reduced? reductions ref ref-history-count ref-max-history ref-min-history ref-set refer release-pending-sends rem remove remove-all-methods remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest restart-agent resultset-seq reverse reversible? rseq rsubseq satisfies? second select-keys send send-off send-via seq seq? seque sequence sequential? set set-agent-send-executor! set-agent-send-off-executor! set-error-handler! set-error-mode! set-validator! set? short short-array shorts shuffle shutdown-agents slurp some some-fn some? sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! symbol symbol? take take-last take-nth take-while test the-ns thread-bound? to-array to-array-2d trampoline transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unsigned-bit-shift-right update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector-of vector? with-bindings* with-meta with-redefs-fn xml-seq zero? zipmap
+syntax keyword clojureVariable *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* *compile-path* *compiler-options* *data-readers* *default-data-reader-fn* *e *err* *file* *flush-on-newline* *fn-loader* *in* *math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* *source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* EMPTY-NODE char-escape-string char-name-string clojure.core/*1 clojure.core/*2 clojure.core/*3 clojure.core/*agent* clojure.core/*allow-unresolved-vars* clojure.core/*assert* clojure.core/*clojure-version* clojure.core/*command-line-args* clojure.core/*compile-files* clojure.core/*compile-path* clojure.core/*compiler-options* clojure.core/*data-readers* clojure.core/*default-data-reader-fn* clojure.core/*e clojure.core/*err* clojure.core/*file* clojure.core/*flush-on-newline* clojure.core/*fn-loader* clojure.core/*in* clojure.core/*math-context* clojure.core/*ns* clojure.core/*out* clojure.core/*print-dup* clojure.core/*print-length* clojure.core/*print-level* clojure.core/*print-meta* clojure.core/*print-readably* clojure.core/*read-eval* clojure.core/*source-path* clojure.core/*unchecked-math* clojure.core/*use-context-classloader* clojure.core/*verbose-defrecords* clojure.core/*warn-on-reflection* clojure.core/EMPTY-NODE clojure.core/char-escape-string clojure.core/char-name-string clojure.core/default-data-readers clojure.core/primitives-classnames clojure.core/unquote clojure.core/unquote-splicing default-data-readers primitives-classnames unquote unquote-splicing
 
 " Keywords are symbols:
 "   static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?([\\D&&[^/]][^/]*)");
@@ -36,13 +39,15 @@
 "   * Must not end in a : or /
 "   * Must not have two adjacent colons except at the beginning
 "   * Must not contain any reader metacharacters except for ' and #
-syntax match clojureKeyword "\v:{1,2}%([^ \n\r\t()\[\]{}";@^`~\\%/]+/)*[^ \n\r\t()\[\]{}";@^`~\\%/]+:@<!"
+syntax match clojureKeyword "\v<:{1,2}%([^ \n\r\t()\[\]{}";@^`~\\%/]+/)*[^ \n\r\t()\[\]{}";@^`~\\%/]+:@<!>"
 
-syntax region clojureString start=/L\="/ skip=/\\\\\|\\"/ end=/"/
+syntax match clojureStringEscape "\v\\%([\\btnfr"]|u\x{4}|[0-3]\o{2}|\o{1,2})" contained
+
+syntax region clojureString start=/"/ skip=/\\\\\|\\"/ end=/"/ contains=clojureStringEscape,@Spell
 
 syntax match clojureCharacter "\\."
-syntax match clojureCharacter "\\o[0-7]\{3\}"
-syntax match clojureCharacter "\\u[0-9]\{4\}"
+syntax match clojureCharacter "\\o\%([0-3]\o\{2\}\|\o\{1,2\}\)"
+syntax match clojureCharacter "\\u\x\{4\}"
 syntax match clojureCharacter "\\space"
 syntax match clojureCharacter "\\tab"
 syntax match clojureCharacter "\\newline"
@@ -50,16 +55,17 @@
 syntax match clojureCharacter "\\backspace"
 syntax match clojureCharacter "\\formfeed"
 
-let s:radixChars = "0123456789abcdefghijklmnopqrstuvwxyz"
+syntax match clojureSymbol "\v%([a-zA-Z!$&*_+=|<.>?-]|[^\x00-\x7F])+%(:?%([a-zA-Z0-9!#$%&*_+=|'<.>/?-]|[^\x00-\x7F]))*[#:]@<!"
+
+let s:radix_chars = "0123456789abcdefghijklmnopqrstuvwxyz"
 for s:radix in range(2, 36)
-    execute 'syntax match clojureNumber "\c\<-\?' . s:radix . 'r[' . strpart(s:radixChars, 0, s:radix) . ']\+\>"'
+	execute 'syntax match clojureNumber "\v\c<[-+]?' . s:radix . 'r[' . strpart(s:radix_chars, 0, s:radix) . ']+>"'
 endfor
-unlet! s:radixChars s:radix
+unlet! s:radix_chars s:radix
 
-syntax match clojureNumber "\<-\=[0-9]\+\(\.[0-9]*\)\=\(M\|\([eE][-+]\?[0-9]\+\)\)\?\>"
-syntax match clojureNumber "\<-\=[0-9]\+N\?\>"
-syntax match clojureNumber "\<-\=0x[0-9a-fA-F]\+\>"
-syntax match clojureNumber "\<-\=[0-9]\+/[0-9]\+\>"
+syntax match clojureNumber "\v<[-+]?%(0\o*|0x\x+|[1-9]\d*)N?>"
+syntax match clojureNumber "\v<[-+]?%(0|[1-9]\d*|%(0|[1-9]\d*)\.\d*)%(M|[eE][-+]?\d+)?>"
+syntax match clojureNumber "\v<[-+]?%(0|[1-9]\d*)/%(0|[1-9]\d*)>"
 
 syntax match clojureVarArg "&"
 
@@ -69,66 +75,114 @@
 syntax match clojureUnquote "\~@"
 syntax match clojureMeta "\^"
 syntax match clojureDeref "@"
-syntax match clojureAnonArg "%\(\d\|&\)\?"
-syntax match clojureDispatch "\v#[\^\'\=\<]?"
+syntax match clojureDispatch "\v#[\^'=<_]?"
 
-syntax region clojureRegexp start=/L\=\#"/ skip=/\\\\\|\\"/ end=/"/
+" Clojure permits no more than 20 params.
+syntax match clojureAnonArg "%\(20\|1\d\|[1-9]\|&\)\?"
 
-syntax match clojureComment ";.*$" contains=clojureTodo,@Spell
-syntax match clojureComment "#!.*$"
-syntax match clojureComment "#_"
+syntax match  clojureRegexpEscape "\v\\%([\\tnrfae.()\[\]{}^$*?+]|c\u|0[0-3]?\o{1,2}|x%(\x{2}|\{\x{1,6}\})|u\x{4})" contained display
+syntax region clojureRegexpQuoted start=/\\Q/ms=e+1 skip=/\\\\\|\\"/ end=/\\E/me=s-1 end=/"/me=s-1 contained
+syntax region clojureRegexpQuote  start=/\\Q/       skip=/\\\\\|\\"/ end=/\\E/       end=/"/me=s-1 contains=clojureRegexpQuoted keepend contained
+
+" -*- CHARACTER PROPERTY CLASSES -*-
+" Generated from https://github.com/guns/vim-clojure-static/blob/vim-release-010/clj/src/vim_clojure_static/generate.clj
+" Java version 1.7.0_51
+syntax match clojureRegexpPosixCharClass "\v\\[pP]\{%(Cntrl|A%(l%(pha|num)|SCII)|Space|Graph|Upper|P%(rint|unct)|Blank|XDigit|Digit|Lower)\}" contained display
+syntax match clojureRegexpJavaCharClass "\v\\[pP]\{java%(Whitespace|JavaIdentifier%(Part|Start)|SpaceChar|Mirrored|TitleCase|I%(SOControl|de%(ographic|ntifierIgnorable))|D%(efined|igit)|U%(pperCase|nicodeIdentifier%(Part|Start))|L%(etter%(OrDigit)?|owerCase)|Alphabetic)\}" contained display
+syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\cIs%(l%(owercase|etter)|hex%(digit|_digit)|w%(hite%(_space|space)|ord)|noncharacter%(_code_point|codepoint)|p%(rint|unctuation)|ideographic|graph|a%(l%(num|phabetic)|ssigned)|uppercase|titlecase|blank|digit|control)\}" contained display
+syntax match clojureRegexpUnicodeCharClass "\v\\[pP][NSCMZPL]" contained display
+syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{%(N[dlo]?|P[dcifeos]?|C[ncfos]?|M[nce]?|Z[lsp]?|S[mcko]?|L[muCDlto]?)\}" contained display
+syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{%(Is|gc\=|general_category\=)?%(N[dlo]?|P[dcifeos]?|C[ncfos]?|M[nce]?|Z[lsp]?|S[mcko]?|L[muCDlto]?)\}" contained display
+syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\c%(Is|sc\=|script\=)%(l%(epc%(ha)?|y%([dc]i%(an)?)|a%(t%(n|in)|na|oo?)|i%(n%(b|ear_b)|mbu?|su))|vaii?|d%(srt|e%(seret|va%(nagari)?))|g%(lag%(olitic)?|eor%(gian)?|oth%(ic)?|re%(k|ek)|u%(j%(arati|r)|r%(u|mukhi)))|u%(gar%(itic)?|nknown)|a%(r%(ab%(ic)?|m%([ni]|enian))|v%(st|estan))|e%(thi%(opic)?|gyp%(tian_hieroglyphs)?)|z%(inh|yyy|zzz)|r%(un%(ic|r)|ejang|jng)|m%(a%(nd%(aic)?|layalam)|lym|y%(anmar|mr)|tei|ong%(olian)?|eetei_mayek)|c%(a%(n%(adian_aboriginal|s)|ri%(an)?)|y%(priot|r%(l|illic))|prt|uneiform|o%(pt%(ic)?|mmon)|h%(er%(okee)?|am))|i%(n%(scriptional_pa%(rthian|hlavi)|herited)|mperial_aramaic|tal)|b%(eng%(ali)?|a%(t%(ak|k)|li%(nese)?|mum?)|ra%(i%(lle)?|h%(mi)?)|opo%(mofo)?|u%(gi%(nese)?|h%(d|id)))|o%(g%(am|ham)|r%(iya|kh|ya)|sma%(nya)?|l%(d_%(south_arabian|persian|italic|turkic)|ck|_chiki))|p%(rti|h%(oenician|li|ag%(s_pa)?|nx))|k%(h%(m%(r|er)|ar%(oshthi)?)|nda|a%(li|n%(a|nada)|takana|yah_li|ithi)|thi)|yi%(ii)?|t%(elu%(gu)?|i%(finagh|b%(t|etan))|ha%(i|a%(na)?)|a%(i_%(le|tham|viet)|g%(alog|b%(anwa)?)|vt|l[ue]|m%(il|l))|fng|glg)|x%(peo|sux)|n%(ew_tai_lue|koo?)|h%(ira%(gana)?|an%([io]|unoo|g%(ul)?)?|ebr%(ew)?)|java%(nese)?|s%(inh%(ala)?|ha%(vian|w)|a%(ur%(ashtra)?|m%(r|aritan)|rb)|y%(r%(c|iac)|lo%(ti_nagri)?)|und%(anese)?))\}" contained display
+syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\c%(In|blk\=|block\=)%(javanese|h%(a%(lfwidth%( and fullwidth forms|andfullwidthforms|_and_fullwidth_forms)|n%(unoo|gul%(compatibilityjamo|syllables|jamo%(extended\-[ab])?|_%(syllables|jamo%(_extended_[ab])?|compatibility_jamo)| %(syllables|compatibility jamo|jamo%( extended\-[ab])?))))|i%(ragana|gh%( %(private use surrogates|surrogates)|_%(private_use_surrogates|surrogates)|surrogates|privateusesurrogates))|ebrew)|i%(pa%([ _]extensions|extensions)|deographic%( description characters|_description_characters|descriptioncharacters)|nscriptional%(%([ _]pa%(rthian|hlavi))|pa%(rthian|hlavi))|mperial%(aramaic|[_ ]aramaic))|l%(e%(tterlike%([_ ]symbols|symbols)|pcha)|ow%([_ ]surrogates|surrogates)|i%(mbu|near%(_b_%(ideograms|syllabary)|b%(ideograms|syllabary)| b %(ideograms|syllabary))|su)|a%(tin%(extended%(additional|\-[dacb])| extended%( additional|\-[dacb])|\-1%(supplement| supplement)|_%(extended_%([dcb]|a%(dditional)?)|1_supplement))|o)|y[cd]ian)|b%(u%(ginese|hid)|ra%(hmi|ille%(patterns|[_ ]patterns))|o%(x%([ _]drawing|drawing)|pomofo%([ _]extended|extended)?)|lock%([ _]elements|elements)|yzantine%( musical symbols|musicalsymbols|_musical_symbols)|engali|a%(linese|mum%(supplement|[ _]supplement)?|tak|sic%([ _]latin|latin)))|e%(gyptian%([ _]hieroglyphs|hieroglyphs)|moticons|nclosed%( %(cjk letters and months|ideographic supplement|alphanumeric%( supplement|s))|cjklettersandmonths|_%(ideographic_supplement|alphanumeric%(_supplement|s)|cjk_letters_and_months)|alphanumerics%(upplement)?|ideographicsupplement)|thiopic%(supplement|_%(supplement|extended%(_a)?)| %(supplement|extended%(\-a)?)|extended%(\-a)?)?)|k%(h%(aroshthi|mer%([_ ]symbols|symbols)?)|a%(takana%(_phonetic_extensions|phoneticextensions| phonetic extensions)?|n%(gxi%([_ ]radicals|radicals)|a%(supplement|[ _]supplement)|bun|nada)|ithi|yah%([ _]li|li)))|r%(u%(nic|mi%(numeralsymbols| numeral symbols|_numeral_symbols))|ejang)|n%(umber%(forms|[ _]forms)|ko|ew%(_tai_lue|tailue| tai lue))|m%(iscellaneous%(technical|symbols%(and%(pictographs|arrows))?|mathematicalsymbols\-[ab]| %(technical|mathematical symbols\-[ab]|symbols%( and %(pictographs|arrows))?)|_%(technical|symbols%(_and_%(pictographs|arrows))?|mathematical_symbols_[ab]))|usical%([_ ]symbols|symbols)|eetei%(mayek|[_ ]mayek)|a%(ndaic|hjong%([ _]tiles|tiles)|layalam|thematical%(alphanumericsymbols| %(alphanumeric symbols|operators)|_%(alphanumeric_symbols|operators)|operators))|yanmar%(extended\-a|_extended_a| extended\-a)?|o%(difier%(_tone_letters| tone letters|toneletters)|ngolian))|d%(e%(seret|vanagari%([ _]extended|extended)?)|ingbats|omino%([ _]tiles|tiles))|yi%(syllables|%([_ ]%(syllables|radicals))|radicals|jing%(hexagramsymbols| hexagram symbols|_hexagram_symbols))|s%(havian|mall%( form variants|formvariants|_form_variants)|p%(acing%(_modifier_letters| modifier letters|modifierletters)|ecials)|a%(maritan|urashtra)|u%(p%(erscripts%(_and_subscripts|andsubscripts| and subscripts)|plementa%(ry%(_private_use_area_[ab]|privateusearea\-[ab]| private use area\-[ab])|l%(_%(arrows_[ab]|mathematical_operators|punctuation)| %(mathematical operators|punctuation|arrows\-[ab])|mathematicaloperators|punctuation|arrows\-[ab])))|rrogates_area|ndanese)|inhala|y%(riac|loti%([_ ]nagri|nagri)))|p%(h%(o%(enician|netic%( extensions%( supplement)?|extensions%(supplement)?|_extensions%(_supplement)?))|a%(istos%([ _]disc|disc)|gs[_\-]pa))|laying%(cards|[_ ]cards)|rivate%(usearea| use area|_use_area))|o%(smanya|l%([ _]chiki|d%( %(south arabian|persian|italic|turkic)|southarabian|_%(south_arabian|persian|italic|turkic)|persian|italic|turkic)|chiki)|riya|ptical%( character recognition|_character_recognition|characterrecognition)|gham)|g%(u%(jarati|rmukhi)|othic|lagolitic|e%(o%(rgian%(supplement|[ _]supplement)?|metric%(shapes|[ _]shapes))|neral%([_ ]punctuation|punctuation))|reek%( %(and coptic|extended)|andcoptic|_extended|extended)?)|c%(o%(ntrol%(pictures|[ _]pictures)|m%(bining%(diacriticalmarks%(supplement|forsymbols)?|halfmarks| %(diacritical marks%( %(supplement|for symbols))?|half marks|marks for symbols)|marksforsymbols|_%(marks_for_symbols|half_marks|diacritical_marks%(_supplement)?))|mon%(_indic_number_forms|indicnumberforms| indic number forms))|ptic|unting%( rod numerals|_rod_numerals|rodnumerals))|y%(rillic%(extended\-[ab]|_%(extended_[ab]|supplementary)|supplement%(ary)?| %(extended\-[ab]|supplement%(ary)?))?|priot%(syllabary|[ _]syllabary))|u%(rrency%([_ ]symbols|symbols)|neiform%(_numbers_and_punctuation|numbersandpunctuation| numbers and punctuation)?)|arian|h%(erokee|am)|jk%(s%(ymbolsandpunctuation|trokes)|compatibility%(forms|ideographs%(supplement)?)?|radicalssupplement| %(compatibility%( %(ideographs%( supplement)?|forms))?|radicals supplement|unified ideographs%( extension [dacb])?|s%(ymbols and punctuation|trokes))|_%(s%(trokes|ymbols_and_punctuation)|radicals_supplement|compatibility%(_%(forms|ideographs%(_supplement)?))?|unified_ideographs%(_extension_[dacb])?)|unifiedideographs%(extension[dacb])?))|t%(i%(betan|finagh)|elugu|a%(mil|i%(xuanjingsymbols|_%(le|xuan_jing_symbols|tham|viet)|le| %(xuan jing symbols|le|tham|viet)|tham|viet)|g%(alog|s|banwa))|ransport%( and map symbols|_and_map_symbols|andmapsymbols)|ha%(i|ana))|a%(l%(chemical%([_ ]symbols|symbols)|phabetic%( presentation forms|_presentation_forms|presentationforms))|ncient%(_%(greek_%(musical_notation|numbers)|symbols)|greek%(numbers|musicalnotation)| %(greek %(numbers|musical notation)|symbols)|symbols)|egean%(numbers|[ _]numbers)|vestan|r%(abic%( %(supplement|presentation forms\-[ab])|supplement|_%(presentation_forms_[ab]|supplement)|presentationforms\-[ab])?|menian|rows))|u%(garitic|nified%(canadianaboriginalsyllabics%(extended)?|_canadian_aboriginal_syllabics%(_extended)?| canadian aboriginal syllabics%( extended)?))|v%(a%(i|riation%( selectors%( supplement)?|selectors%(supplement)?|_selectors%(_supplement)?))|e%(rtical%(forms|[ _]forms)|dic%([ _]extensions|extensions))))\}" contained display
+
+syntax match   clojureRegexpPredefinedCharClass	"\v%(\\[dDsSwW]|\.)" contained display
+syntax cluster clojureRegexpCharPropertyClasses	contains=clojureRegexpPosixCharClass,clojureRegexpJavaCharClass,clojureRegexpUnicodeCharClass
+syntax cluster clojureRegexpCharClasses		contains=clojureRegexpPredefinedCharClass,clojureRegexpCharClass,@clojureRegexpCharPropertyClasses
+syntax region  clojureRegexpCharClass		start="\[" skip=/\\\\\|\\]/ end="]" contained contains=clojureRegexpPredefinedCharClass,@clojureRegexpCharPropertyClasses
+syntax match   clojureRegexpBoundary		"\\[bBAGZz]" contained display
+syntax match   clojureRegexpBoundary		"[$^]" contained display
+syntax match   clojureRegexpQuantifier		"[?*+][?+]\=" contained display
+syntax match   clojureRegexpQuantifier		"\v\{\d+%(,|,\d+)?}\??" contained display
+syntax match   clojureRegexpOr			"|" contained display
+syntax match   clojureRegexpBackRef		"\v\\%([1-9]\d*|k\<[a-zA-z]+\>)" contained display
+
+" Mode modifiers, mode-modified spans, lookaround, regular and atomic
+" grouping, and named-capturing.
+syntax match clojureRegexpMod "\v\(@<=\?:" contained display
+syntax match clojureRegexpMod "\v\(@<=\?[xdsmiuU]*-?[xdsmiuU]+:?" contained display
+syntax match clojureRegexpMod "\v\(@<=\?%(\<?[=!]|\>)" contained display
+syntax match clojureRegexpMod "\v\(@<=\?\<[a-zA-Z]+\>" contained display
 
-syntax keyword clojureTodo contained FIXME XXX TODO FIXME: XXX: TODO:
+syntax region clojureRegexpGroup start="(" skip=/\\\\\|\\)/ end=")" matchgroup=clojureRegexpGroup contained contains=clojureRegexpMod,clojureRegexpQuantifier,clojureRegexpBoundary,clojureRegexpEscape,@clojureRegexpCharClasses
+syntax region clojureRegexp start=/\#"/ skip=/\\\\\|\\"/ end=/"/ contains=@clojureRegexpCharClasses,clojureRegexpEscape,clojureRegexpQuote,clojureRegexpBoundary,clojureRegexpQuantifier,clojureRegexpOr,clojureRegexpBackRef,clojureRegexpGroup keepend
 
-syntax region clojureSexp   matchgroup=clojureParen start="("  matchgroup=clojureParen end=")"  contains=TOP,@Spell
-syntax region clojureVector matchgroup=clojureParen start="\[" matchgroup=clojureParen end="\]" contains=TOP,@Spell
-syntax region clojureMap    matchgroup=clojureParen start="{"  matchgroup=clojureParen end="}"  contains=TOP,@Spell
+syntax keyword clojureCommentTodo contained FIXME XXX TODO FIXME: XXX: TODO:
+
+syntax match clojureComment ";.*$" contains=clojureCommentTodo,@Spell
+syntax match clojureComment "#!.*$"
+
+" -*- TOP CLUSTER -*-
+" Generated from https://github.com/guns/vim-clojure-static/blob/vim-release-010/clj/src/vim_clojure_static/generate.clj
+syntax cluster clojureTop contains=@Spell,clojureAnonArg,clojureBoolean,clojureCharacter,clojureComment,clojureCond,clojureConstant,clojureDefine,clojureDeref,clojureDispatch,clojureError,clojureException,clojureFunc,clojureKeyword,clojureMacro,clojureMap,clojureMeta,clojureNumber,clojureQuote,clojureRegexp,clojureRepeat,clojureSexp,clojureSpecial,clojureString,clojureSymbol,clojureUnquote,clojureVarArg,clojureVariable,clojureVector
+
+syntax region clojureSexp   matchgroup=clojureParen start="("  matchgroup=clojureParen end=")" contains=@clojureTop fold
+syntax region clojureVector matchgroup=clojureParen start="\[" matchgroup=clojureParen end="]" contains=@clojureTop fold
+syntax region clojureMap    matchgroup=clojureParen start="{"  matchgroup=clojureParen end="}" contains=@clojureTop fold
 
 " Highlight superfluous closing parens, brackets and braces.
 syntax match clojureError "]\|}\|)"
 
 syntax sync fromstart
 
-if version >= 600
-    command -nargs=+ HiLink highlight default link <args>
-else
-    command -nargs=+ HiLink highlight link <args>
-endif
-
-HiLink clojureConstant  Constant
-HiLink clojureBoolean   Boolean
-HiLink clojureCharacter Character
-HiLink clojureKeyword   Keyword
-HiLink clojureNumber    Number
-HiLink clojureString    String
-HiLink clojureRegexp    Constant
-
-HiLink clojureVariable  Identifier
-HiLink clojureCond      Conditional
-HiLink clojureDefine    Define
-HiLink clojureException Exception
-HiLink clojureFunc      Function
-HiLink clojureMacro     Macro
-HiLink clojureRepeat    Repeat
-
-HiLink clojureSpecial   Special
-HiLink clojureVarArg    Special
-HiLink clojureQuote     SpecialChar
-HiLink clojureUnquote   SpecialChar
-HiLink clojureMeta      SpecialChar
-HiLink clojureDeref     SpecialChar
-HiLink clojureAnonArg   SpecialChar
-HiLink clojureDispatch  SpecialChar
-
-HiLink clojureComment   Comment
-HiLink clojureTodo      Todo
+highlight default link clojureConstant			Constant
+highlight default link clojureBoolean			Boolean
+highlight default link clojureCharacter			Character
+highlight default link clojureKeyword			Keyword
+highlight default link clojureNumber			Number
+highlight default link clojureString			String
+highlight default link clojureStringEscape		Character
+
+highlight default link clojureRegexp			Constant
+highlight default link clojureRegexpEscape		Character
+highlight default link clojureRegexpCharClass		SpecialChar
+highlight default link clojureRegexpPosixCharClass	clojureRegexpCharClass
+highlight default link clojureRegexpJavaCharClass	clojureRegexpCharClass
+highlight default link clojureRegexpUnicodeCharClass	clojureRegexpCharClass
+highlight default link clojureRegexpPredefinedCharClass	clojureRegexpCharClass
+highlight default link clojureRegexpBoundary		SpecialChar
+highlight default link clojureRegexpQuantifier		SpecialChar
+highlight default link clojureRegexpMod			SpecialChar
+highlight default link clojureRegexpOr			SpecialChar
+highlight default link clojureRegexpBackRef		SpecialChar
+highlight default link clojureRegexpGroup		clojureRegexp
+highlight default link clojureRegexpQuoted		clojureString
+highlight default link clojureRegexpQuote		clojureRegexpBoundary
+
+highlight default link clojureVariable			Identifier
+highlight default link clojureCond			Conditional
+highlight default link clojureDefine			Define
+highlight default link clojureException			Exception
+highlight default link clojureFunc			Function
+highlight default link clojureMacro			Macro
+highlight default link clojureRepeat			Repeat
+
+highlight default link clojureSpecial			Special
+highlight default link clojureVarArg			Special
+highlight default link clojureQuote			SpecialChar
+highlight default link clojureUnquote			SpecialChar
+highlight default link clojureMeta			SpecialChar
+highlight default link clojureDeref			SpecialChar
+highlight default link clojureAnonArg			SpecialChar
+highlight default link clojureDispatch			SpecialChar
 
-HiLink clojureError     Error
+highlight default link clojureComment			Comment
+highlight default link clojureCommentTodo		Todo
 
-HiLink clojureParen     Delimiter
+highlight default link clojureError			Error
 
-delcommand HiLink
+highlight default link clojureParen			Delimiter
 
 let b:current_syntax = "clojure"
 
-" vim:sts=4 sw=4 et:
+" vim:sts=8:sw=8:ts=8:noet:smc=0
diff -Naur vim74.orig/runtime/syntax/cpp.vim vim74/runtime/syntax/cpp.vim
--- vim74.orig/runtime/syntax/cpp.vim	2013-03-13 17:34:49.000000000 +0000
+++ vim74/runtime/syntax/cpp.vim	2014-10-10 14:53:42.435385347 +0000
@@ -2,7 +2,7 @@
 " Language:	C++
 " Current Maintainer:	vim-jp (https://github.com/vim-jp/cpp-vim)
 " Previous Maintainer:	Ken Shan <ccshan@post.harvard.edu>
-" Last Change:	2012 Jun 14
+" Last Change:	2014 May 14
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -39,6 +39,7 @@
   syn keyword cppExceptions	noexcept
   syn keyword cppStorageClass	constexpr decltype
   syn keyword cppConstant	nullptr
+  syn region cppRawString       matchgroup=cppRawDelimiter start=+\%(u8\|[uLU]\)\=R"\z([[:alnum:]_{}[\]#<>%:;.?*\+\-/\^&|~!=,"']\{,16}\)(+ end=+)\z1"+ contains=@Spell
 endif
 
 " The minimum and maximum operators in GNU C++
@@ -62,6 +63,8 @@
   HiLink cppStructure		Structure
   HiLink cppBoolean		Boolean
   HiLink cppConstant		Constant
+  HiLink cppRawDelimiter	Delimiter
+  HiLink cppRawString		String
   delcommand HiLink
 endif
 
diff -Naur vim74.orig/runtime/syntax/css.vim vim74/runtime/syntax/css.vim
--- vim74.orig/runtime/syntax/css.vim	2013-07-23 19:08:29.000000000 +0000
+++ vim74/runtime/syntax/css.vim	2014-10-10 14:53:42.452051971 +0000
@@ -6,7 +6,7 @@
 "               Nikolai Weibull (Add CSS2 support)
 " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
 " URL:          https://github.com/JulesWang/css.vim
-" Last Change:  2013 Jul 23
+" Last Change:  2013 Nov.27
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -37,12 +37,12 @@
 syn keyword cssTagName option p param pre q s samp script select small
 syn keyword cssTagName span strike strong style sub sup table tbody td
 syn keyword cssTagName textarea tfoot th thead title tr tt ul u var
-syn keyword cssTagName object
+syn keyword cssTagName object svg
 
-" HTML5 new tags 5*6=30
-syn keyword cssTagName article aside audio bdi canvas command
-syn keyword cssTagName datalist details embed figcaption figure footer
-syn keyword cssTagName header hgroup keygen mark meter nav
+" 34 HTML5 tags
+syn keyword cssTagName article aside audio bdi canvas command data
+syn keyword cssTagName datalist details dialog embed figcaption figure footer
+syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
 syn keyword cssTagName output progress rt rp ruby section
 syn keyword cssTagName source summary time track video wbr
 
@@ -50,17 +50,16 @@
 syn keyword cssDeprecated acronym applet basefont big center dir
 syn keyword cssDeprecated font frame frameset noframes strike tt
 
-"syn match cssTagName "\<table\>"
 syn match cssTagName "\*"
 
 " selectors
-syn match cssSelectorOp "[,>+]"
+syn match cssSelectorOp "[,>+~]"
 syn match cssSelectorOp2 "[~|^$*]\?=" contained
-" FIXME: add HTML5 attribute
-syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" transparent contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
+syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
 
 " .class and #id
-syn match cssClassName "\.[A-Za-z][A-Za-z0-9_-]\+"
+syn match cssClassName "\.[A-Za-z][A-Za-z0-9_-]\+" contains=cssClassNameDot
+syn match cssClassNameDot contained '\.'
 
 try
 syn match cssIdentifier "#[A-Za-z-_@][A-Za-z-0-9_@-]*"
@@ -68,26 +67,60 @@
 syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
 endtry
 
-syn match cssTagName "@page\>" nextgroup=cssDefinition
-" FIXME: use cssVendor here
-syn match cssTagName "@\(-\(webkit\|moz\|o\|ms\)-\)\=keyframes\>" nextgroup=cssDefinition
-
-syn match cssMedia "@media\>" nextgroup=cssMediaType skipwhite skipnl
-syn keyword cssMediaType contained screen print aural braile embosed handheld projection ty tv all nextgroup=cssMediaComma,cssMediaBlock skipwhite skipnl
-"syn match cssMediaComma "," nextgroup=cssMediaType skipwhite skipnl
-syn region cssMediaBlock transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssError,cssComment,cssDefinition,cssURL,cssUnicodeEscape,cssIdentifier
-
-syn match cssValueInteger contained "[-+]\=\d\+"
-syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\="
-syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\)"
-syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)"
-syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)"
-syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)"
+" digits
+syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
+syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
+syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\)" contains=cssUnitDecorators
+syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)" contains=cssUnitDecorators
+syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)" contains=cssUnitDecorators
+syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)" contains=cssUnitDecorators
+
+
+syn match cssIncludeKeyword /@\(-[a-z]+-\)\=\(media\|keyframes\|import\|charset\|namespace\|page\)/ contained
+" @media
+syn region cssInclude start=/@media\>/ end=/\ze{/ skipwhite skipnl contains=cssMediaProp,cssValueLength,cssMediaKeyword,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssIncludeKeyword,cssMediaComma,cssComment nextgroup=cssMediaBlock
+syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained skipwhite skipnl
+syn keyword cssMediaKeyword only not and contained
+syn region cssMediaBlock transparent matchgroup=cssBraces start='{' end='}' contains=css.*Attr,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssTagName,cssClassName,cssIdentifier,cssPseudoClass,cssSelectorOp,cssSelectorOp2,cssAttributeSelector fold
+syn match cssMediaComma "," skipwhite skipnl contained
+
+" Reference: http://www.w3.org/TR/css3-mediaqueries/
+syn keyword cssMediaProp contained width height orientation scan grid
+syn match cssMediaProp contained /\(\(device\)-\)\=aspect-ratio/
+syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
+syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
+syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
+syn keyword cssMediaAttr contained portrait landscape progressive interlace
+
+" @page
+" http://www.w3.org/TR/css3-page/
+syn match cssPage "@page\>[^{]*{\@=" contains=cssPagePseudo,cssIncludeKeyword nextgroup=cssPageWrap transparent skipwhite skipnl
+syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
+syn region cssPageWrap contained transparent matchgroup=cssBraces start="{" end="}" contains=cssPageMargin,cssPageProp,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks
+syn match cssPageMargin /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition skipwhite skipnl
+syn keyword cssPageProp contained content size
+" http://www.w3.org/TR/CSS2/page.html#break-inside
+syn keyword cssPageProp contained orphans widows
+
+" @keyframe
+" http://www.w3.org/TR/css3-animations/#keyframes
+syn match cssKeyFrame "@\(-[a-z]+-\)\=keyframes\>[^{]*{\@=" nextgroup=cssKeyFrameWrap contains=cssVendor,cssIncludeKeyword skipwhite skipnl transparent
+syn region cssKeyFrameWrap contained transparent matchgroup=cssBraces start="{" end="}" contains=cssKeyFrameSelector
+syn match cssKeyFrameSelector /\(\d*%\|from\|to\)\=/  contained skipwhite skipnl nextgroup=cssDefinition
+
+" @import
+syn region cssInclude start=/@import\>/    end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword,cssURL,cssMediaProp,cssValueLength,cssMediaKeyword,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType
+syn region cssInclude start=/@charset\>/   end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword
+syn region cssInclude start=/@namespace\>/ end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword
 
+" @font-face
+" http://www.w3.org/TR/css3-fonts/#at-font-face-rule
 syn match cssFontDescriptor "@font-face\>" nextgroup=cssFontDescriptorBlock skipwhite skipnl
 syn region cssFontDescriptorBlock contained transparent matchgroup=cssBraces start="{" end="}" contains=cssComment,cssError,cssUnicodeEscape,cssFontProp,cssFontAttr,cssCommonAttr,cssStringQ,cssStringQQ,cssFontDescriptorProp,cssValue.*,cssFontDescriptorFunction,cssUnicodeRange,cssFontDescriptorAttr
-syn match cssFontDescriptorProp contained "\<\(unicode-range\|unit-per-em\|panose-1\|cap-height\|x-height\|definition-src\)\>"
-syn keyword cssFontDescriptorProp contained src stemv stemh slope ascent descent widths bbox baseline centerline mathline topline
+"syn match cssFontDescriptorProp contained "\<\(unicode-range\|unit-per-em\|panose-1\|cap-height\|x-height\|definition-src\)\>"
+"syn keyword cssFontDescriptorProp contained src stemv stemh slope ascent descent widths bbox baseline centerline mathline topline
+syn keyword cssFontDescriptorProp contained src
+syn match cssFontDescriptorProp contained "\<unicode-range\>"
 syn keyword cssFontDescriptorAttr contained all
 syn region cssFontDescriptorFunction contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline keepend
 syn match cssUnicodeRange contained "U+[0-9A-Fa-f?]\+"
@@ -124,7 +157,7 @@
 syn keyword cssColor contained thistle tomato turquoise violet wheat
 syn keyword cssColor contained whitesmoke yellowgreen
 
-" FIXME: These are actually case-insentivie too, but (a) specs recommend using
+" FIXME: These are actually case-insensitive too, but (a) specs recommend using
 " mixed-case (b) it's hard to highlight the word `Background' correctly in
 " all situations
 syn case match
@@ -135,50 +168,75 @@
 
 syn match cssColor contained "\<transparent\>"
 syn match cssColor contained "\<white\>"
-syn match cssColor contained "#[0-9A-Fa-f]\{3\}\>"
-syn match cssColor contained "#[0-9A-Fa-f]\{6\}\>"
+syn match cssColor contained "#[0-9A-Fa-f]\{3\}\>" contains=cssUnitDecorators
+syn match cssColor contained "#[0-9A-Fa-f]\{6\}\>" contains=cssUnitDecorators
 
-syn region cssURL contained matchgroup=cssFunctionName start="\<url\s*(" end=")" oneline keepend
-syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\)\s*(" end=")" oneline keepend
-syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\)\s*(" end=")" oneline keepend
-syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear\|radial\)-gradient\s*(" end=")" oneline keepend
-syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y|\Z\)\=\|translate\(3d\|X\|Y|\Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y|\Z\)\=\|perspective\)\s*(" end=")" oneline keepend
+syn region cssURL contained matchgroup=cssFunctionName start="\<url\s*(" end=")" oneline extend
+syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
+syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
+syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
+syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
+syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
+syn match cssFunctionComma contained ","
+
+" Common Prop and Attr
+syn keyword cssCommonAttr contained auto none inherit all default normal
+syn keyword cssCommonAttr contained top bottom center stretch hidden visible
+"------------------------------------------------
+" CSS Animations
+" http://www.w3.org/TR/css3-animations/
+syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
+
+" animation-direction attributes
+syn keyword cssAnimationAttr contained alternate reverse
+syn match cssAnimationAttr contained "\<alternate-reverse\>"
+
+" animation-fill-mode attributes
+syn keyword cssAnimationAttr contained forwards backwards both
+
+" animation-play-state attributes
+syn keyword cssAnimationAttr contained running paused
+"------------------------------------------------
+"  CSS Backgrounds and Borders Module Level 3
+"  http://www.w3.org/TR/css3-background/
+syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
+" background-attachment attributes
+syn keyword cssBackgroundAttr contained scroll fixed local
 
-" Prop and Attr
-" Reference: http://www.w3schools.com/cssref/default.asp
-syn keyword cssCommonAttr contained auto none inherit all
-syn keyword cssCommonAttr contained top bottom
-syn keyword cssCommonAttr contained medium normal
+" background-position attributes
+syn keyword cssBackgroundAttr contained left center right top bottom
 
+" background-repeat attributes
+syn match cssBackgroundAttr contained "\<no-repeat\>"
+syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
+syn keyword cssBackgroundAttr contained space round
 
-syn match cssAnimationProp contained "\<animation\(-\(name\|duration\|timing-function\|delay\|iteration-cout\|play-state\)\)\=\>"
-
+" background-size attributes
+syn keyword cssBackgroundAttr contained cover contain
 
-syn keyword cssAnimationAttr contained infinite alternate paused running
-" bugfix: escape linear-gradient
-syn match cssAnimationAttr contained "\<linear\(-gradient\)\@!\>"
-syn match cssAnimationAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
+syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
+syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
+syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
+syn match cssBorderProp contained "\<box-decoration-break\>"
+syn match cssBorderProp contained "\<box-shadow\>"
 
-syn match cssBackgroundProp contained "\<background\(-\(color\|image\|attachment\|position\|clip\|origin\|size\)\)\=\>"
-syn keyword cssBackgroundAttr contained center fixed over contain
-syn match cssBackgroundAttr contained "\<no-repeat\>"
-syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
-syn match cssBackgroundAttr contained "\<\(border\|content\|padding\)-box\>"
+" border-image attributes
+syn keyword cssBorderAttr contained stretch round space fill
 
+" border-style attributes
+syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
 
-syn match cssBorderOutlineProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
-syn match cssBorderOutlineProp contained "\<outline\(-\(width\|style\|color\)\)\=\>"
-syn match cssBorderOutlineProp contained "\<border-\(top\|bottom\)-\(left\|right\)\(-radius\)\=\>"
-syn match cssBorderOutlineProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
-syn match cssBorderOutlineProp contained "\<border-radius\>"
-syn keyword cssBorderOutlineAttr contained thin thick medium
-syn keyword cssBorderOutlineAttr contained dotted dashed solid double groove ridge inset outset
-syn keyword cssBorderOutlineAttr contained hidden visible scroll collapse
-syn keyword cssBorderOutlineAttr contained stretch round
+" border-width attributes
+syn keyword cssBorderAttr contained thin thick medium
 
+" box-decoration-break attributes
+syn keyword cssBorderAttr contained clone slice
+"------------------------------------------------
 
+syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
+syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
-syn match cssBoxProp contained "\<rotation\(-point\)=\>"
+syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
 syn keyword cssBoxAttr contained visible hidden scroll auto
 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
 
@@ -193,36 +251,70 @@
 
 " shadow and sizing are in other property groups
 syn match cssFlexibleBoxProp contained "\<box-\(align\|direction\|flex\|ordinal-group\|orient\|pack\|shadow\|sizing\)\>"
-syn keyword cssFlexibleBoxAttr contained start end center baseline stretch
-syn keyword cssFlexibleBoxAttr contained normal reverse
+syn keyword cssFlexibleBoxAttr contained start end baseline
+syn keyword cssFlexibleBoxAttr contained reverse
 syn keyword cssFlexibleBoxAttr contained single mulitple
 syn keyword cssFlexibleBoxAttr contained horizontal
-" bugfix: escape vertial-align
-syn match cssFlexibleBoxAttr contained "\<vertical\(-align\)\@!\>"
+syn match cssFlexibleBoxAttr contained "\<vertical\(-align\)\@!\>" "escape vertical-align
 syn match cssFlexibleBoxAttr contained "\<\(inline\|block\)-axis\>"
 
-
-syn match cssFontProp contained "\<font\(-\(family\|style\|variant\|weight\|size\(-adjust\)\=\|stretch\)\)\=\>"
-syn match cssFontAttr contained "\<\(sans-\)\=\<serif\>"
-syn match cssFontAttr contained "\<small\(-\(caps\|caption\)\)\=\>"
-syn match cssFontAttr contained "\<x\{1,2\}-\(large\|small\)\>"
+" CSS Fonts Module Level 3
+" http://www.w3.org/TR/css-fonts-3/
+syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
+" font attributes
+syn keyword cssFontAttr contained icon menu caption
+syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
 syn match cssFontAttr contained "\<message-box\>"
 syn match cssFontAttr contained "\<status-bar\>"
-syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\|status-bar\)-\)\=\(condensed\|expanded\)\>"
-syn keyword cssFontAttr contained cursive fantasy monospace italic oblique
-syn keyword cssFontAttr contained bold bolder light lighter larger smaller
-syn keyword cssFontAttr contained icon menu caption
-syn keyword cssFontAttr contained large smaller larger narrower wider
-syn keyword cssFontAttr contained Courier Arial Georgia Times
+syn keyword cssFontAttr contained larger smaller
+syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
 
+" font-family attributes
+syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
+syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Unicode Verdana Webdings Wingdings York Zapf
+syn keyword cssFontAttr contained cursive fantasy monospace
+
+" font-feature-settings attributes
+syn keyword cssFontAttr contained on off
+
+" font-stretch attributes
+syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
+
+" font-style attributes
+syn keyword cssFontAttr contained italic oblique
+
+" font-variant-caps attributes
+syn match cssFontAttr contained "\<\(all-\)\=\(small-\|petite-\|titling-\)caps\>"
+syn keyword cssFontAttr contained unicase
+
+" font-weight attributes
+syn keyword cssFontAttr contained bold bolder lighter
+"------------------------------------------------
+
+" Webkit specific property/attributes
+syn match cssFontProp contained "\<font-smooth\>"
+syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
+
+
+" CSS Multi-column Layout Module
+" http://www.w3.org/TR/css3-multicol/
+syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
+syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
+syn keyword cssMultiColumnProp contained columns
+syn keyword cssMultiColumnAttr contained balance medium
+syn keyword cssMultiColumnAttr contained always avoid left right page column
+syn match cssMultiColumnAttr contained "\<avoid-\(page\|column\)\>"
 
-syn keyword cssGeneratedContentProp contained content quotes crop
+" http://www.w3.org/TR/css3-break/#page-break
+syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
+
+" TODO find following items in w3c docs.
+syn keyword cssGeneratedContentProp contained quotes crop
 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
 syn match cssGeneratedContentProp contained "\<move-to\>"
 syn match cssGeneratedContentProp contained "\<page-policy\>"
 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
 
-
 syn match cssGridProp contained "\<grid-\(columns\|rows\)\>"
 
 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
@@ -234,26 +326,16 @@
 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
 syn keyword cssListAttr contained inside outside
 
-
-syn match cssMarginProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
-
-syn match cssMultiColumnProp contained "\<column\(-\(\break-\(after\|before\)\|count\|gap\|rule\(-\(color\|style\|width\)\)\=\)\|span\|width\)\=\>"
-
-
-syn match cssPaddingProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
-
 syn keyword cssPositioningProp contained bottom clear clip display float left
 syn keyword cssPositioningProp contained position right top visibility
 syn match cssPositioningProp contained "\<z-index\>"
-syn keyword cssPositioningAttr contained block inline compact
-syn match cssPositioningAttr contained "\<table\(-\(row-gorup\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
+syn keyword cssPositioningAttr contained block compact
+syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
 syn keyword cssPositioningAttr contained left right both
 syn match cssPositioningAttr contained "\<list-item\>"
-syn match cssPositioningAttr contained "\<inline-\(block\|table\)\>"
+syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\)\)\=\>"
 syn keyword cssPositioningAttr contained static relative absolute fixed
 
-syn match cssPrintProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
-syn keyword cssPrintProp contained orphans widows
 syn keyword cssPrintAttr contained landscape portrait crop cross always avoid
 
 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
@@ -262,18 +344,18 @@
 
 syn keyword cssTextProp contained color direction
 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
-syn match cssTextProp contained "\<text-\(justify\|\outline\|overflow\|warp\|align-last\)\>"
+syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
 syn match cssTextProp contained "\<word-\(break\|\wrap\)\>"
 syn match cssTextProp contained "\<white-space\>"
 syn match cssTextProp contained "\<hanging-punctuation\>"
 syn match cssTextProp contained "\<punctuation-trim\>"
 syn match cssTextAttr contained "\<line-through\>"
-syn match cssTextAttr contained "\<text-indent\>"
 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
 syn keyword cssTextAttr contained ltr rtl embed nowrap
 syn keyword cssTextAttr contained underline overline blink sub super middle
 syn keyword cssTextAttr contained capitalize uppercase lowercase
-syn keyword cssTextAttr contained center justify baseline sub super
+syn keyword cssTextAttr contained justify baseline sub super
+syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed
 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
 syn keyword cssTextAttr contained start end adjacent
@@ -283,22 +365,69 @@
 syn match cssTextAttr contained "\<break-all\>"
 syn match cssTextAttr contained "\<break-word\>"
 syn keyword cssTextAttr contained hyphenate
-
+syn match cssTextAttr contained "\<bidi-override\>"
 
 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
 syn match cssTransformProp contained "\<backface-visibility\>"
 
+" CSS Transitions
+" http://www.w3.org/TR/css3-transitions/
 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
 
-syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
-syn match cssUIProp contained "\<outline-offset\>"
+" transition-time-function attributes
+syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
+syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
+syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
+"------------------------------------------------
+" CSS Basic User Interface Module Level 3 (CSS3 UI)
+" http://www.w3.org/TR/css3-ui/
 syn match cssUIProp contained "\<box-sizing\>"
-syn keyword cssUIProp contained appearance icon resize
-syn keyword cssUIAttr contained window button menu field
+syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
+
+syn keyword cssUIProp contained cursor
+syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
+syn keyword cssUIAttr contained crosshair help move pointer alias copy
+syn keyword cssUIAttr contained progress wait text cell move
+syn match cssUIAttr contained "\<context-menu\>"
+syn match cssUIAttr contained "\<no-drop\>"
+syn match cssUIAttr contained "\<not-allowed\>"
+syn match cssUIAttr contained "\<all-scroll\>"
+syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
+syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
+
+syn match cssUIProp contained "\<ime-mode\>"
+syn keyword cssUIAttr contained active inactive disabled
+
+syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
+syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
+syn keyword cssUIAttr contained invert
+
+syn keyword cssUIProp contained icon resize
+syn keyword cssUIAttr contained both horizontal vertical
+
+syn match cssUIProp contained "\<text-overflow\>"
+syn keyword cssUIAttr contained clip ellipsis
+
+" Already highlighted Props: font content
+"------------------------------------------------
+" Webkit/iOS specific attributes
+syn match cssUIAttr contained '\(preserve-3d\)'
+" IE specific attributes
+syn match cssIEUIAttr contained '\(bicubic\)'
+
+" Webkit/iOS specific properties
+syn match cssUIProp contained '\(tap-highlight-color\|user-select\|touch-callout\)'
+" IE specific properties
+syn match cssIEUIProp contained '\(interpolation-mode\|zoom\|filter\)'
+
+" Webkit/Firebox specific properties/attributes
+syn keyword cssUIProp contained appearance
+syn keyword cssUIAttr contained window button field icon document menu
+
 
 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
-syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numerals\)\)\=\)\>"
+syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
 syn keyword cssAuralAttr contained silent
@@ -307,58 +436,69 @@
 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
 syn keyword cssAuralAttr contained leftwards rightwards behind
-syn keyword cssAuralAttr contained below level above higher
-syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\)\>"
+syn keyword cssAuralAttr contained below level above lower higher
+syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
 syn keyword cssAuralAttr contained faster slower
 syn keyword cssAuralAttr contained male female child code digits continuous
-syn match cssAuralAttr contained "\<lower\>"
 
-" cursor
-syn keyword cssUIProp contained cursor
-syn match cssUIAttr contained "\<[ns]\=[ew]\=-resize\>"
-syn keyword cssUIAttr contained crosshair default help move pointer
-syn keyword cssUIAttr contained progress wait
-
-" FIXME: I could not find them in reference
-syn keyword cssUIAttr contained invert maker size zoom
-syn match cssRenderAttr contained "\<run-in\>"
-syn match cssRenderAttr contained "\<text-rendering\>"
-syn match cssRenderAttr contained "\<font-smoothing\>"
-syn match cssRenderProp contained "\<marker-offset\>"
-syn match cssRenderAttr contained "\<bidi-override\>"
+" mobile text
+syn match cssMobileTextProp contained "\<text-size-adjust\>"
+
 
 
-" FIXME: This allows cssMediaBlock before the semicolon, which is wrong.
-syn region cssInclude start="@import" end=";" contains=cssComment,cssURL,cssUnicodeEscape,cssMediaType
 syn match cssBraces contained "[{}]"
 syn match cssError contained "{@<>"
-syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=css.*Attr,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition
+syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks keepend fold
 syn match cssBraceError "}"
+syn match cssAttrComma ","
 
 " Pseudo class
-syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssPseudoClassId,cssUnicodeEscape
-syn keyword cssPseudoClassId link visited active hover focus before after left right lang
-syn match cssPseudoClassId contained "\<first\(-\(line\|letter\|child\)\)\=\>"
-" FIXME: handle functions.
-"syn region cssPseudoClassLang matchgroup=cssPseudoClassId start="lang(" end=")"
-syn match cssPseudoClassId contained "\<\(last\|only\|nth\|nth-last\)-child\>"
-syn match cssPseudoClassId contained "\<\(first\|last\|only\|nth\|nth-last\)-of-type\>"
-syn keyword cssPseudoClassId root empty target enable disabled checked not invalid
-syn match cssPseudoClassId contained  "::\(-moz-\)\=selection"
+" http://www.w3.org/TR/css3-selectors/
+syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
+syn keyword cssPseudoClassId contained link visited active hover before after left right
+syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
+syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
+syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
+syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")"
+" ------------------------------------
+" Vendor specific properties
+syn match cssPseudoClassId contained  "\<selection\>"
+syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
+syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
+
 
 " Comment
-syn region cssComment start="/\*" end="\*/" contains=@Spell
-syn region cssComment start="//" skip="\\$" end="$" keepend contains=@Spell
+syn region cssComment start="/\*" end="\*/" contains=@Spell fold
 
 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
-syn match cssSpecialCharQQ +\\"+ contained
-syn match cssSpecialCharQ +\\'+ contained
+syn match cssSpecialCharQQ +\\\\\|\\"+ contained
+syn match cssSpecialCharQ +\\\\\|\\'+ contained
 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
 
 " Vendor Prefix
 syn match cssVendor contained "\(-\(webkit\|moz\|o\|ms\)-\)"
 
+" Various CSS Hack characters
+" In earlier versions of IE (6 and 7), one can prefix property names
+" with a _ or * to isolate those definitions to particular versions of IE
+" This is purely decorative and therefore we assign to the same highlight
+" group to cssVendor, for more information:
+" http://www.paulirish.com/2009/browser-specific-css-hacks/
+syn match cssHacks contained /\(_\|*\)/
+
+" Misc highlight groups
+syntax match cssUnitDecorators /\(#\|-\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
+syntax match cssNoise contained /\(:\|;\|\/\)/
+
+" Attr Enhance
+" Some keywords are both Prop and Attr, so we have to handle them
+syn region cssAttrRegion start=/:/ end=/;/ contained keepend contains=css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
+
+" Hack for transition
+" The 'transition' Prop has Props after ':'.
+syn region cssAttrRegion start=/transition\s*:/ end=/;/ contained keepend contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
+
 
 if main_syntax == "css"
   syn sync minlines=10
@@ -377,73 +517,76 @@
 
   HiLink cssComment Comment
   HiLink cssVendor Comment
+  HiLink cssHacks Comment
   HiLink cssTagName Statement
   HiLink cssDeprecated Error
   HiLink cssSelectorOp Special
   HiLink cssSelectorOp2 Special
+  HiLink cssAttrComma Special
 
-  HiLink cssAnimationProp StorageClass
-  HiLink cssBackgroundProp StorageClass
-  HiLink cssBorderOutlineProp StorageClass
-  HiLink cssBoxProp StorageClass
-  HiLink cssColorProp StorageClass
-  HiLink cssContentForPagedMediaProp StorageClass
-  HiLink cssDimensionProp StorageClass
-  HiLink cssFlexibleBoxProp StorageClass
-  HiLink cssFontProp StorageClass
-  HiLink cssGeneratedContentProp StorageClass
-  HiLink cssGridProp StorageClass
-  HiLink cssHyerlinkProp StorageClass
-  HiLink cssLineboxProp StorageClass
-  HiLink cssListProp StorageClass
-  HiLink cssMarginProp StorageClass
-  HiLink cssMarqueeProp StorageClass
-  HiLink cssMultiColumnProp StorageClass
-  HiLink cssPaddingProp StorageClass
-  HiLink cssPagedMediaProp StorageClass
-  HiLink cssPositioningProp StorageClass
-  HiLink cssPrintProp StorageClass
-  HiLink cssRubyProp StorageClass
-  HiLink cssSpeechProp StorageClass
-  HiLink cssTableProp StorageClass
-  HiLink cssTextProp StorageClass
-  HiLink cssTransformProp StorageClass
-  HiLink cssTransitionProp StorageClass
-  HiLink cssUIProp StorageClass
-  HiLink cssAuralProp StorageClass
-  HiLink cssRenderProp StorageClass
-
-  HiLink cssAnimationAttr Type
-  HiLink cssBackgroundAttr Type
-  HiLink cssBorderOutlineAttr Type
-  HiLink cssBoxAttr Type
-  HiLink cssColorAttr Type
-  HiLink cssContentForPagedMediaAttr Type
-  HiLink cssDimensionAttr Type
-  HiLink cssFlexibleBoxAttr Type
-  HiLink cssFontAttr Type
-  HiLink cssGeneratedContentAttr Type
-  HiLink cssGridAttr Type
-  HiLink cssHyerlinkAttr Type
-  HiLink cssLineboxAttr Type
-  HiLink cssListAttr Type
-  HiLink cssMarginAttr Type
-  HiLink cssMarqueeAttr Type
-  HiLink cssMultiColumnAttr Type
-  HiLink cssPaddingAttr Type
-  HiLink cssPagedMediaAttr Type
-  HiLink cssPositioningAttr Type
-  HiLink cssPrintAttr Type
-  HiLink cssRubyAttr Type
-  HiLink cssSpeechAttr Type
-  HiLink cssTableAttr Type
-  HiLink cssTextAttr Type
-  HiLink cssTransformAttr Type
-  HiLink cssTransitionAttr Type
-  HiLink cssUIAttr Type
-  HiLink cssAuralAttr Type
-  HiLink cssRenderAttr Type
-  HiLink cssCommonAttr Type
+  HiLink cssAnimationProp cssProp
+  HiLink cssBackgroundProp cssProp
+  HiLink cssBorderProp cssProp
+  HiLink cssBoxProp cssProp
+  HiLink cssColorProp cssProp
+  HiLink cssContentForPagedMediaProp cssProp
+  HiLink cssDimensionProp cssProp
+  HiLink cssFlexibleBoxProp cssProp
+  HiLink cssFontProp cssProp
+  HiLink cssGeneratedContentProp cssProp
+  HiLink cssGridProp cssProp
+  HiLink cssHyerlinkProp cssProp
+  HiLink cssLineboxProp cssProp
+  HiLink cssListProp cssProp
+  HiLink cssMarqueeProp cssProp
+  HiLink cssMultiColumnProp cssProp
+  HiLink cssPagedMediaProp cssProp
+  HiLink cssPositioningProp cssProp
+  HiLink cssPrintProp cssProp
+  HiLink cssRubyProp cssProp
+  HiLink cssSpeechProp cssProp
+  HiLink cssTableProp cssProp
+  HiLink cssTextProp cssProp
+  HiLink cssTransformProp cssProp
+  HiLink cssTransitionProp cssProp
+  HiLink cssUIProp cssProp
+  HiLink cssIEUIProp cssProp
+  HiLink cssAuralProp cssProp
+  HiLink cssRenderProp cssProp
+  HiLink cssMobileTextProp cssProp
+
+  HiLink cssAnimationAttr cssAttr
+  HiLink cssBackgroundAttr cssAttr
+  HiLink cssBorderAttr cssAttr
+  HiLink cssBoxAttr cssAttr
+  HiLink cssContentForPagedMediaAttr cssAttr
+  HiLink cssDimensionAttr cssAttr
+  HiLink cssFlexibleBoxAttr cssAttr
+  HiLink cssFontAttr cssAttr
+  HiLink cssGeneratedContentAttr cssAttr
+  HiLink cssGridAttr cssAttr
+  HiLink cssHyerlinkAttr cssAttr
+  HiLink cssLineboxAttr cssAttr
+  HiLink cssListAttr cssAttr
+  HiLink cssMarginAttr cssAttr
+  HiLink cssMarqueeAttr cssAttr
+  HiLink cssMultiColumnAttr cssAttr
+  HiLink cssPaddingAttr cssAttr
+  HiLink cssPagedMediaAttr cssAttr
+  HiLink cssPositioningAttr cssAttr
+  HiLink cssGradientAttr cssAttr
+  HiLink cssPrintAttr cssAttr
+  HiLink cssRubyAttr cssAttr
+  HiLink cssSpeechAttr cssAttr
+  HiLink cssTableAttr cssAttr
+  HiLink cssTextAttr cssAttr
+  HiLink cssTransformAttr cssAttr
+  HiLink cssTransitionAttr cssAttr
+  HiLink cssUIAttr cssAttr
+  HiLink cssIEUIAttr cssAttr
+  HiLink cssAuralAttr cssAttr
+  HiLink cssRenderAttr cssAttr
+  HiLink cssCommonAttr cssAttr
 
   HiLink cssPseudoClassId PreProc
   HiLink cssPseudoClassLang Constant
@@ -456,26 +599,43 @@
   HiLink cssFunction Constant
   HiLink cssURL String
   HiLink cssFunctionName Function
+  HiLink cssFunctionComma Function
   HiLink cssColor Constant
   HiLink cssIdentifier Function
   HiLink cssInclude Include
+  HiLink cssIncludeKeyword atKeyword
   HiLink cssImportant Special
   HiLink cssBraces Function
   HiLink cssBraceError Error
   HiLink cssError Error
-  HiLink cssInclude Include
   HiLink cssUnicodeEscape Special
   HiLink cssStringQQ String
   HiLink cssStringQ String
-  HiLink cssMedia Special
+  HiLink cssAttributeSelector String
+  HiLink cssMedia atKeyword
   HiLink cssMediaType Special
   HiLink cssMediaComma Normal
+  HiLink cssMediaKeyword Statement
+  HiLink cssMediaProp cssProp
+  HiLink cssMediaAttr cssAttr
+  HiLink cssPage atKeyword
+  HiLink cssPagePseudo PreProc
+  HiLink cssPageMargin atKeyword
+  HiLink cssPageProp cssProp
+  HiLink cssKeyFrame atKeyword
+  HiLink cssKeyFrameSelector Constant
   HiLink cssFontDescriptor Special
   HiLink cssFontDescriptorFunction Constant
-  HiLink cssFontDescriptorProp StorageClass
-  HiLink cssFontDescriptorAttr Type
+  HiLink cssFontDescriptorProp cssProp
+  HiLink cssFontDescriptorAttr cssAttr
   HiLink cssUnicodeRange Constant
   HiLink cssClassName Function
+  HiLink cssClassNameDot Function
+  HiLink cssProp StorageClass
+  HiLink cssAttr Constant
+  HiLink cssUnitDecorators Number
+  HiLink cssNoise Noise
+  HiLink atKeyword Comment
   delcommand HiLink
 endif
 
diff -Naur vim74.orig/runtime/syntax/d.vim vim74/runtime/syntax/d.vim
--- vim74.orig/runtime/syntax/d.vim	2013-05-23 20:52:24.000000000 +0000
+++ vim74/runtime/syntax/d.vim	2014-10-10 14:53:42.475385246 +0000
@@ -2,8 +2,8 @@
 "
 " Language:     D
 " Maintainer:   Jesse Phillips <Jesse.K.Phillips+D@gmail.com>
-" Last Change:  2013 May 21
-" Version:      0.25
+" Last Change:  2013 October 5
+" Version:      0.26
 "
 " Contributors:
 "   - Jason Mills: original Maintainer
@@ -158,7 +158,7 @@
 
 " Pragma Statement
 syn match dPragma       "\<pragma\>"
-syn match dPragma       "\<pragma\s*([_a-zA-Z][_a-zA-Z0-9]*\>"he=s+8 contains=dPragmaIdentifier
+syn match dPragma       "\<pragma\s*([_a-zA-Z][_a-zA-Z0-9]*\>"he=s+6 contains=dPragmaIdentifier
 
 " Necessary to highlight C++ in extern modifiers.
 syn match dExternIdentifier "C\(++\)\?" contained
@@ -168,16 +168,18 @@
 syn match dExtern       "\<extern\s*([_a-zA-Z][_a-zA-Z0-9\+]*\>"he=s+6 contains=dExternIdentifier
 
 " Make import a region to prevent highlighting keywords
-syn region dImport start="import" end=";" contains=dExternal,@dComment
+syn region dImport start="import\_s" end=";" contains=dExternal,@dComment
 
 " Make module a region to prevent highlighting keywords
-syn region dImport start="module" end=";" contains=dExternal,@dComment
+syn region dImport start="module\_s" end=";" contains=dExternal,@dComment
 
 " dTokens is used by the token string highlighting
 syn cluster dTokens contains=dExternal,dConditional,dBranch,dRepeat,dBoolean
 syn cluster dTokens add=dConstant,dTypedef,dStructure,dOperator,dOpOverload
 syn cluster dTokens add=dType,dDebug,dExceptions,dScopeDecl,dStatement
 syn cluster dTokens add=dStorageClass,dPragma,dAssert,dAnnotation,dEnum
+syn cluster dTokens add=dParenString,dBrackString,dAngleString,dCurlyString
+syn cluster dTokens add=dTokenString,dDelimString,dHereString
 
 " Create a match for parameter lists to identify storage class
 syn region paramlist start="(" end=")" contains=@dTokens
@@ -192,6 +194,9 @@
 
 " Comments
 "
+syn match	dCommentError	display "\*/"
+syn match	dNestedCommentError	display "+/"
+
 syn keyword dTodo                                                                contained TODO FIXME TEMP REFACTOR REVIEW HACK BUG XXX
 syn match dCommentStar	contained "^\s*\*[^/]"me=e-1
 syn match dCommentStar	contained "^\s*\*$"
@@ -201,15 +206,12 @@
   syn region dBlockCommentString	contained start=+"+ end=+"+ end=+\*/+me=s-1,he=s-1 contains=dCommentStar,dUnicode,dEscSequence,@Spell
   syn region dNestedCommentString	contained start=+"+ end=+"+ end="+"me=s-1,he=s-1 contains=dCommentPlus,dUnicode,dEscSequence,@Spell
   syn region dLineCommentString		contained start=+"+ end=+$\|"+ contains=dUnicode,dEscSequence,@Spell
-  syn region dBlockComment	start="/\*"  end="\*/" contains=dBlockCommentString,dTodo,@Spell fold
-  syn region dNestedComment	start="/+"  end="+/" contains=dNestedComment,dNestedCommentString,dTodo,@Spell fold
-  syn match  dLineComment	"//.*" contains=dLineCommentString,dTodo,@Spell
-else
-  syn region dBlockComment	start="/\*"  end="\*/" contains=dBlockCommentString,dTodo,@Spell fold
-  syn region dNestedComment	start="/+"  end="+/" contains=dNestedComment,dNestedCommentString,dTodo,@Spell fold
-  syn match  dLineComment	"//.*" contains=dLineCommentString,dTodo,@Spell
 endif
 
+syn region dBlockComment	start="/\*"  end="\*/" contains=dBlockCommentString,dTodo,dCommentStartError,@Spell fold
+syn region dNestedComment	start="/+"  end="+/" contains=dNestedComment,dNestedCommentString,dTodo,@Spell fold
+syn match  dLineComment	"//.*" contains=dLineCommentString,dTodo,@Spell
+
 hi link dLineCommentString	dBlockCommentString
 hi link dBlockCommentString	dString
 hi link dNestedCommentString	dString
@@ -249,7 +251,7 @@
 syn region dRawString	start=+r"+ end=+"[cwd]\=+ contains=@Spell
 syn region dHexString	start=+x"+ end=+"[cwd]\=+ contains=@Spell
 syn region dDelimString	start=+q"\z(.\)+ end=+\z1"+ contains=@Spell
-syn region dHereString	start=+q"\z(\I\i*\)\n+ end=+\n\z1"+ contains=@Spell
+syn region dHereString	start=+q"\z(\I\i*\)\n+ end=+^\z1"+ contains=@Spell
 
 " Nesting delimited string contents
 "
@@ -368,6 +370,9 @@
 hi def link dLineComment         Comment
 hi def link dBlockComment        Comment
 hi def link dNestedComment       Comment
+hi def link dCommentError        Error
+hi def link dNestedCommentError  Error
+hi def link dCommentStartError   Error
 hi def link dExternal            Include
 hi def link dAnnotation          PreProc
 hi def link dSharpBang           PreProc
diff -Naur vim74.orig/runtime/syntax/datascript.vim vim74/runtime/syntax/datascript.vim
--- vim74.orig/runtime/syntax/datascript.vim	2012-04-30 10:59:58.000000000 +0000
+++ vim74/runtime/syntax/datascript.vim	2014-10-10 14:53:42.478718571 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:	Datascript
 " Maintainer:	Dominique Pelle <dominique.pelle@gmail.com>
-" Last Change:	2012 Apr 30
+" Last Change:	2014 Feb 26
 "
 " DataScript is a formal language for modelling binary datatypes,
 " bitstreams or file formats. For more information, see:
@@ -16,8 +16,8 @@
 set cpo&vim
 
 syn keyword dsPackage      import package
-syn keyword dsType         bit string
-syn keyword dsType         int8 int16 int32 int64
+syn keyword dsType         bit bool string
+syn keyword dsType         int int8 int16 int32 int64
 syn keyword dsType         uint8 uint16 uint32 uint64
 syn keyword dsType         leint16 leint32 leint64
 syn keyword dsType         leuint16 leuint32 leuint64
@@ -25,13 +25,14 @@
 syn keyword dsAlign        align
 syn keyword dsLabel        case default
 syn keyword dsConditional  if condition
-syn keyword dsCompound     union choice on enum bitmask subtype
+syn keyword dsBoolean      true false
+syn keyword dsCompound     union choice on enum bitmask subtype explicit
 syn keyword dsKeyword      function return
 syn keyword dsOperator     sizeof bitsizeof lengthof is sum forall in
 syn keyword dsStorageClass const
 syn keyword dsTodo         contained TODO FIXME XXX
-syn keyword dsSql          sql sql_table sql_database sql_pragma
-syn keyword dsSql          sql_integer sql_metadata sql_key
+syn keyword dsSql          sql sql_table sql_database sql_pragma sql_index
+syn keyword dsSql          sql_integer sql_metadata sql_key foreign_key
 
 " dsCommentGroup allows adding matches for special things in comments.
 syn cluster dsCommentGroup  contains=dsTodo
@@ -70,6 +71,7 @@
 hi def link dsSql               PreProc
 hi def link dsCompound          Structure
 hi def link dsConditional       Conditional
+hi def link dsBoolean           Boolean
 hi def link dsKeyword           Statement
 hi def link dsString            String
 hi def link dsNumber            Number
diff -Naur vim74.orig/runtime/syntax/debchangelog.vim vim74/runtime/syntax/debchangelog.vim
--- vim74.orig/runtime/syntax/debchangelog.vim	2013-05-17 15:25:15.000000000 +0000
+++ vim74/runtime/syntax/debchangelog.vim	2014-10-10 14:53:42.482051896 +0000
@@ -3,7 +3,7 @@
 " Maintainer:  Debian Vim Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
 " Former Maintainers: Gerfried Fuchs <alfie@ist.org>
 "                     Wichert Akkerman <wakkerma@debian.org>
-" Last Change: 2013 May 05
+" Last Change: 2014 Jul 11
 " URL: http://anonscm.debian.org/hg/pkg-vim/vim/raw-file/unstable/runtime/syntax/debchangelog.vim
 
 " Standard syntax initialization
@@ -19,7 +19,7 @@
 " Define some common expressions we can use later on
 syn match debchangelogName	contained "^[[:alnum:]][[:alnum:].+-]\+ "
 syn match debchangelogUrgency	contained "; urgency=\(low\|medium\|high\|critical\|emergency\)\( \S.*\)\="
-syn match debchangelogTarget	contained "\v %(frozen|unstable|%(testing|%(old)=stable)%(-proposed-updates|-security)=|experimental|squeeze-%(backports%(-sloppy)=|volatile)|wheezy-backports|%(lucid|precise|quantal|raring|saucy)%(-%(security|proposed|updates|backports|commercial|partner))=)+"
+syn match debchangelogTarget	contained "\v %(frozen|unstable|%(testing|%(old)=stable)%(-proposed-updates|-security)=|experimental|squeeze-%(backports%(-sloppy)=|volatile)|wheezy-backports|%(devel|lucid|precise|trusty|utopic)%(-%(security|proposed|updates|backports|commercial|partner))=)+"
 syn match debchangelogVersion	contained "(.\{-})"
 syn match debchangelogCloses	contained "closes:\_s*\(bug\)\=#\=\_s\=\d\+\(,\_s*\(bug\)\=#\=\_s\=\d\+\)*"
 syn match debchangelogLP	contained "\clp:\s\+#\d\+\(,\s*#\d\+\)*"
diff -Naur vim74.orig/runtime/syntax/debcontrol.vim vim74/runtime/syntax/debcontrol.vim
--- vim74.orig/runtime/syntax/debcontrol.vim	2013-05-21 10:54:11.000000000 +0000
+++ vim74/runtime/syntax/debcontrol.vim	2014-10-10 14:53:42.482051896 +0000
@@ -3,7 +3,7 @@
 " Maintainer:  Debian Vim Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
 " Former Maintainers: Gerfried Fuchs <alfie@ist.org>
 "                     Wichert Akkerman <wakkerma@debian.org>
-" Last Change: 2013 May 05
+" Last Change: 2014 May 01
 " URL: http://anonscm.debian.org/hg/pkg-vim/vim/raw-file/unstable/runtime/syntax/debcontrol.vim
 
 " Standard syntax initialization
@@ -13,6 +13,9 @@
   finish
 endif
 
+let s:cpo_save = &cpo
+set cpo&vim
+
 " Should match case except for the keys of each field
 syn case match
 
@@ -23,8 +26,17 @@
 syn match debControlComma ", *"
 syn match debControlSpace " "
 
+let s:kernels = '\%(linux\|hurd\|kfreebsd\|knetbsd\|kopensolaris\|netbsd\)'
+let s:archs = '\%(alpha\|amd64\|armeb\|armel\|armhf\|arm64\|avr32\|hppa\|i386'
+      \ . '\|ia64\|lpia\|m32r\|m68k\|mipsel\|mips\|powerpcspe\|powerpc\|ppc64el'
+      \ . '\|ppc64\|s390x\|s390\|sh3eb\|sh3\|sh4eb\|sh4\|sh\|sparc64\|sparc\|x32\)'
+let s:pairs = 'hurd-i386\|kfreebsd-i386\|kfreebsd-amd64\|knetbsd-i386\|kopensolaris-i386\|netbsd-alpha\|netbsd-i386'
+
 " Define some common expressions we can use later on
-syn match debcontrolArchitecture contained "\%(all\|linux-any\|\%(any-\)\=\%(alpha\|amd64\|arm\%(e[bl]\|hf\)\=\|avr32\|hppa\|i386\|ia64\|lpia\|m32r\|m68k\|mips\%(el\)\=\|powerpc\|ppc64\|s390x\=\|sh[34]\(eb\)\=\|sh\|sparc\%(64\)\=\)\|hurd-\%(i386\|any\)\|kfreebsd-\%(i386\|amd64\|any\)\|knetbsd-\%(i386\|any\)\|kopensolaris-\%(i386\|any\)\|netbsd-\%(alpha\|i386\|any\)\|any\)"
+exe 'syn match debcontrolArchitecture contained "\%(all\|'. s:kernels .'-any\|\%(any-\)\='. s:archs .'\|'. s:pairs .'\|any\)"'
+
+unlet s:kernels s:archs s:pairs
+
 syn match debcontrolMultiArch contained "\%(no\|foreign\|allowed\|same\)"
 syn match debcontrolName contained "[a-z0-9][a-z0-9+.-]\+"
 syn match debcontrolPriority contained "\(extra\|important\|optional\|required\|standard\)"
@@ -108,4 +120,7 @@
 
 let b:current_syntax = "debcontrol"
 
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
 " vim: ts=8 sw=2
diff -Naur vim74.orig/runtime/syntax/debsources.vim vim74/runtime/syntax/debsources.vim
--- vim74.orig/runtime/syntax/debsources.vim	2013-05-17 15:25:15.000000000 +0000
+++ vim74/runtime/syntax/debsources.vim	2014-10-10 14:53:42.485385221 +0000
@@ -2,7 +2,7 @@
 " Language:     Debian sources.list
 " Maintainer:   Debian Vim Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
 " Former Maintainer: Matthijs Mohlmann <matthijs@cacholong.nl>
-" Last Change: 2013 May 05
+" Last Change: 2014 Jul 11
 " URL: http://anonscm.debian.org/hg/pkg-vim/vim/raw-file/unstable/runtime/syntax/debsources.vim
 
 " Standard syntax initialization
@@ -23,7 +23,7 @@
 
 " Match uri's
 syn match debsourcesUri            +\(http://\|ftp://\|[rs]sh://\|debtorrent://\|\(cdrom\|copy\|file\):\)[^' 	<>"]\++
-syn match debsourcesDistrKeyword   +\([[:alnum:]_./]*\)\(squeeze\|wheezy\|\(old\)\=stable\|testing\|unstable\|sid\|rc-buggy\|experimental\|lucid\|precise\|quantal\|raring\|saucy\)\([-[:alnum:]_./]*\)+
+syn match debsourcesDistrKeyword   +\([[:alnum:]_./]*\)\(squeeze\|wheezy\|jessie\|\(old\)\=stable\|testing\|unstable\|sid\|rc-buggy\|experimental\|devel\|lucid\|precise\|trusty\|utopic\)\([-[:alnum:]_./]*\)+
 
 " Associate our matches and regions with pretty colours
 hi def link debsourcesLine            Error
diff -Naur vim74.orig/runtime/syntax/diff.vim vim74/runtime/syntax/diff.vim
--- vim74.orig/runtime/syntax/diff.vim	2013-07-24 09:47:50.000000000 +0000
+++ vim74/runtime/syntax/diff.vim	2014-10-10 14:53:42.498718521 +0000
@@ -2,7 +2,7 @@
 " Language:	Diff (context or unified)
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
 "               Translations by Jakson Alves de Aquino.
-" Last Change:	2013 Jul 24
+" Last Change:	2013 Oct 06
 
 " Quit when a (custom) syntax file was already loaded
 if exists("b:current_syntax")
@@ -336,7 +336,7 @@
 "Some versions of diff have lines like "#c#" and "#d#" (where # is a number)
 syn match diffLine	"^\d\+\(,\d\+\)\=[cda]\d\+\>.*"
 
-syn match diffFile	"^diff.*"
+syn match diffFile	"^diff\>.*"
 syn match diffFile	"^+++ .*"
 syn match diffFile	"^Index: .*"
 syn match diffFile	"^==== .*"
diff -Naur vim74.orig/runtime/syntax/dircolors.vim vim74/runtime/syntax/dircolors.vim
--- vim74.orig/runtime/syntax/dircolors.vim	2012-04-25 09:42:39.000000000 +0000
+++ vim74/runtime/syntax/dircolors.vim	2014-10-10 14:53:42.498718521 +0000
@@ -1,751 +1,213 @@
 " Vim syntax file
-" Language:         dircolors(1) input file
-" Maintainer:       Nikolai Weibull <now@bitwi.se>
-" Latest Revision:  2012-04-25
+" Language:        dircolors(1) input file
+" Maintainer:      Jan Larres <jan@majutsushi.net>
+" Previous Maintainer: Nikolai Weibull <now@bitwi.se>
+" Latest Revision: 2013-08-17
 
 if exists("b:current_syntax")
-  finish
+    finish
 endif
 
 let s:cpo_save = &cpo
 set cpo&vim
 
-syn keyword dircolorsTodo       contained FIXME TODO XXX NOTE
+syntax keyword dircolorsTodo    FIXME TODO XXX NOTE contained
 
-syn region  dircolorsComment    start='#' end='$' contains=dircolorsTodo,@Spell
+syntax region  dircolorsComment start='#' end='$' contains=dircolorsTodo,@Spell
 
-syn keyword dircolorsKeyword    TERM LEFT LEFTCODE RIGHT RIGHTCODE END ENDCODE
+syntax keyword dircolorsKeyword TERM LEFT LEFTCODE RIGHT RIGHTCODE END ENDCODE
 
-syn keyword dircolorsKeyword    NORMAL NORM FILE DIR LNK LINK SYMLINK ORPHAN
-                                \ RESET MULTIHARDLINK CAPABILITY SETUID SETGID
-                                \ STICKY STICKY_OTHER_WRITABLE OTHER_WRITABLE 
-                                \ MISSING FIFO PIPE SOCK BLK BLOCK CHR CHAR
-                                \ DOOR EXEC
-                                \ nextgroup=@dircolorsColors skipwhite
+syntax keyword dircolorsKeyword NORMAL NORM FILE RESET DIR LNK LINK SYMLINK
+                              \ MULTIHARDLINK FIFO SOCK DOOR BLK CHR ORPHAN
+                              \ MISSING PIPE BLOCK CHR EXEC SETUID SETGID
+                              \ CAPABILITY STICKY_OTHER_WRITABLE
+                              \ OTHER_WRITABLE STICKY
 
-if exists("dircolors_is_slackware")
-  syn keyword dircolorsKeyword  COLOR OPTIONS EIGHTBIT
+" Slackware only, ignored by GNU dircolors.
+syntax keyword dircolorsKeyword COLOR OPTIONS EIGHTBIT
+
+syntax match dircolorsExtension '^\s*\zs[.*]\S\+'
+
+syntax match dircolorsEscape '\\[abefnrtv?_\\^#]'
+syntax match dircolorsEscape '\\[0-9]\{3}'
+syntax match dircolorsEscape '\\x[0-9a-f]\{3}'
+
+if !has('gui_running') && &t_Co == ''
+    syntax match dircolorsNumber '\<\d\+\>'
+    highlight default link dircolorsNumber Number
 endif
 
-syn match   dircolorsExtension  '^\s*\zs[.*]\S\+'
-                                \ nextgroup=dircolorsColorPair skipwhite
+highlight default link dircolorsTodo      Todo
+highlight default link dircolorsComment   Comment
+highlight default link dircolorsKeyword   Keyword
+highlight default link dircolorsExtension Identifier
+highlight default link dircolorsEscape    Special
+
+function! s:set_guicolors() abort
+    let s:guicolors = {}
+
+    let s:guicolors[0]  = "Black"
+    let s:guicolors[1]  = "DarkRed"
+    let s:guicolors[2]  = "DarkGreen"
+    let s:guicolors[3]  = "DarkYellow"
+    let s:guicolors[4]  = "DarkBlue"
+    let s:guicolors[5]  = "DarkMagenta"
+    let s:guicolors[6]  = "DarkCyan"
+    let s:guicolors[7]  = "Gray"
+    let s:guicolors[8]  = "DarkGray"
+    let s:guicolors[9]  = "Red"
+    let s:guicolors[10] = "Green"
+    let s:guicolors[11] = "Yellow"
+    let s:guicolors[12] = "Blue"
+    let s:guicolors[13] = "Magenta"
+    let s:guicolors[14] = "Cyan"
+    let s:guicolors[15] = "White"
+
+    let xterm_palette = ["00", "5f", "87", "af", "d7", "ff"]
+
+    let cur_col = 16
+
+    for r in xterm_palette
+        for g in xterm_palette
+            for b in xterm_palette
+                let s:guicolors[cur_col] = '#' . r . g . b
+                let cur_col += 1
+            endfor
+        endfor
+    endfor
+
+    for i in range(24)
+        let g = i * 0xa + 8
+        let s:guicolors[i + 232] = '#' . g . g . g
+    endfor
+endfunction
+
+function! s:get_hi_str(color, place) abort
+    if a:color >= 0 && a:color <= 255
+        if has('gui_running')
+            return ' gui' . a:place . '=' . s:guicolors[a:color]
+        elseif a:color <= 7 || &t_Co == 256 || &t_Co == 88
+            return ' cterm' . a:place . '=' . a:color
+        endif
+    endif
+    return ''
+endfunction
+
+function! s:get_256color(colors) abort
+    if len(a:colors) >= 2 " May be fewer while editing
+        let [_five, color] = remove(a:colors, 0, 1)
+        if _five != '5' || color == ''
+            return -1
+        else
+            return str2nr(color)
+        endif
+    else
+        return -1
+    endif
+endfunction
+
+function! s:preview_color(linenr) abort
+    let line = getline(a:linenr)
+    let defline = matchlist(line, '^\v([A-Z_]+|[*.]\S+)\s+([0-9;]+)')
+    if empty(defline)
+        return
+    endif
+
+    let colordef = defline[2]
+
+    let colors = split(colordef, ';')
+
+    let hi_str = ''
+    let hi_attrs = []
+    while len(colors) > 0
+        let item = str2nr(remove(colors, 0))
+        if item == 1
+            call add(hi_attrs, 'bold')
+        elseif item == 3
+            call add(hi_attrs, 'italic')
+        elseif item == 4
+            call add(hi_attrs, 'underline')
+        elseif item == 7
+            call add(hi_attrs, 'inverse')
+        elseif item >= 30 && item <= 37
+            " ANSI SGR foreground color
+            let hi_str .= s:get_hi_str(item - 30, 'fg')
+        elseif item >= 40 && item <= 47
+            " ANSI SGR background color
+            let hi_str .= s:get_hi_str(item - 40, 'bg')
+        elseif item == 38
+            " Foreground for terminals with 88/256 color support
+            let color = s:get_256color(colors)
+            if color == -1
+                break
+            endif
+            let hi_str .= s:get_hi_str(color, 'fg')
+        elseif item == 48
+            " Background for terminals with 88/256 color support
+            let color = s:get_256color(colors)
+            if color == -1
+                break
+            endif
+            let hi_str .= s:get_hi_str(color, 'bg')
+        endif
+    endwhile
+
+    if hi_str == '' && empty(hi_attrs)
+        return
+    endif
+
+    " Check whether we have already defined this color
+    redir => s:currentmatch
+    silent! execute 'syntax list'
+    redir END
+
+    if s:currentmatch !~# '\/\\_s\\zs' . colordef . '\\ze\\_s\/'
+        " Append the buffer number to avoid problems with other dircolors
+        " buffers interfering
+        let bufnr = bufnr('%')
+        execute 'syntax match dircolorsColor' . b:dc_next_index . '_' . bufnr .
+              \ ' "\_s\zs' . colordef . '\ze\_s"'
+        let hi_attrs_str = ''
+        if !empty(hi_attrs)
+            if has('gui_running')
+                let hi_attrs_str = ' gui=' . join(hi_attrs, ',')
+            else
+                let hi_attrs_str = ' cterm=' . join(hi_attrs, ',')
+            endif
+        endif
+        execute 'highlight default dircolorsColor' . b:dc_next_index . '_' .
+              \ bufnr . hi_str . hi_attrs_str
+        let b:dc_next_index += 1
+    endif
+endfunction
+
+" Avoid accumulating too many definitions while editing
+function! s:reset_colors() abort
+    if b:dc_next_index > 0
+        let bufnr = bufnr('%')
+        for i in range(b:dc_next_index)
+            execute 'syntax clear dircolorsColor' . i . '_' . bufnr
+            execute 'highlight clear dircolorsColor' . i . '_' . bufnr
+        endfor
+        let b:dc_next_index = 0
+    endif
+
+    for linenr in range(1, line('$'))
+        call s:preview_color(linenr)
+    endfor
+endfunction
 
-syn match   dircolorsColorPair  contained '.*$'
-                                \ transparent contains=@dircolorsColors
+let b:dc_next_index = 0
 
-if &t_Co == 8 || &t_Co == 16
-  syn cluster dircolorsColors   contains=dircolorsBold,dircolorsUnderline,
-                                \ dircolorsBlink,dircolorsReverse,
-                                \ dircolorsInvisible,dircolorsBlack,
-                                \ dircolorsRed,dircolorsGreen,dircolorsYellow,
-                                \ dircolorsBlue,dircolorsMagenta,dircolorsCyan,
-                                \ dircolorsWhite,dircolorsBGBlack,
-                                \ dircolorsBGRed,dircolorsBGGreen,
-                                \ dircolorsBGYellow,dircolorsBGBlue,
-                                \ dircolorsBGMagenta,dircolorsBGCyan,
-                                \ dircolorsBGWhite
-
-  syn match dircolorsBold       contained '\<0\=1\>'
-  syn match dircolorsUnderline  contained '\<0\=4\>'
-  syn match dircolorsBlink      contained '\<0\=5\>'
-  syn match dircolorsReverse    contained '\<0\=7\>'
-  syn match dircolorsInvisible  contained '\<0\=8\>'
-  syn match dircolorsBlack      contained '\<30\>'
-  syn match dircolorsRed        contained '\<31\>'
-  syn match dircolorsGreen      contained '\<32\>'
-  syn match dircolorsYellow     contained '\<33\>'
-  syn match dircolorsBlue       contained '\<34\>'
-  syn match dircolorsMagenta    contained '\<35\>'
-  syn match dircolorsCyan       contained '\<36\>'
-  syn match dircolorsWhite      contained '\<37\>'
-  syn match dircolorsBGBlack    contained '\<40\>'
-  syn match dircolorsBGRed      contained '\<41\>'
-  syn match dircolorsBGGreen    contained '\<42\>'
-  syn match dircolorsBGYellow   contained '\<43\>'
-  syn match dircolorsBGBlue     contained '\<44\>'
-  syn match dircolorsBGMagenta  contained '\<45\>'
-  syn match dircolorsBGCyan     contained '\<46\>'
-  syn match dircolorsBGWhite    contained '\<47\>'
-elseif &t_Co == 256 || has("gui_running")
-  syn cluster dircolorsColors   contains=dircolorsColor0,
-                                \ dircolorsColor1,dircolorsColor2,
-                                \ dircolorsColor3,dircolorsColor4,
-                                \ dircolorsColor5,dircolorsColor6,
-                                \ dircolorsColor7,dircolorsColor8,
-                                \ dircolorsColor9,dircolorsColor10,
-                                \ dircolorsColor11,dircolorsColor12,
-                                \ dircolorsColor13,dircolorsColor14,
-                                \ dircolorsColor15,dircolorsColor16,
-                                \ dircolorsColor17,dircolorsColor18,
-                                \ dircolorsColor19,dircolorsColor20,
-                                \ dircolorsColor21,dircolorsColor22,
-                                \ dircolorsColor23,dircolorsColor24,
-                                \ dircolorsColor25,dircolorsColor26,
-                                \ dircolorsColor27,dircolorsColor28,
-                                \ dircolorsColor29,dircolorsColor30,
-                                \ dircolorsColor31,dircolorsColor32,
-                                \ dircolorsColor33,dircolorsColor34,
-                                \ dircolorsColor35,dircolorsColor36,
-                                \ dircolorsColor37,dircolorsColor38,
-                                \ dircolorsColor39,dircolorsColor40,
-                                \ dircolorsColor41,dircolorsColor42,
-                                \ dircolorsColor43,dircolorsColor44,
-                                \ dircolorsColor45,dircolorsColor46,
-                                \ dircolorsColor47,dircolorsColor48,
-                                \ dircolorsColor49,dircolorsColor50,
-                                \ dircolorsColor51,dircolorsColor52,
-                                \ dircolorsColor53,dircolorsColor54,
-                                \ dircolorsColor55,dircolorsColor56,
-                                \ dircolorsColor57,dircolorsColor58,
-                                \ dircolorsColor59,dircolorsColor60,
-                                \ dircolorsColor61,dircolorsColor62,
-                                \ dircolorsColor63,dircolorsColor64,
-                                \ dircolorsColor65,dircolorsColor66,
-                                \ dircolorsColor67,dircolorsColor68,
-                                \ dircolorsColor69,dircolorsColor70,
-                                \ dircolorsColor71,dircolorsColor72,
-                                \ dircolorsColor73,dircolorsColor74,
-                                \ dircolorsColor75,dircolorsColor76,
-                                \ dircolorsColor77,dircolorsColor78,
-                                \ dircolorsColor79,dircolorsColor80,
-                                \ dircolorsColor81,dircolorsColor82,
-                                \ dircolorsColor83,dircolorsColor84,
-                                \ dircolorsColor85,dircolorsColor86,
-                                \ dircolorsColor87,dircolorsColor88,
-                                \ dircolorsColor89,dircolorsColor90,
-                                \ dircolorsColor91,dircolorsColor92,
-                                \ dircolorsColor93,dircolorsColor94,
-                                \ dircolorsColor95,dircolorsColor96,
-                                \ dircolorsColor97,dircolorsColor98,
-                                \ dircolorsColor99,dircolorsColor100,
-                                \ dircolorsColor101,dircolorsColor102,
-                                \ dircolorsColor103,dircolorsColor104,
-                                \ dircolorsColor105,dircolorsColor106,
-                                \ dircolorsColor107,dircolorsColor108,
-                                \ dircolorsColor109,dircolorsColor110,
-                                \ dircolorsColor111,dircolorsColor112,
-                                \ dircolorsColor113,dircolorsColor114,
-                                \ dircolorsColor115,dircolorsColor116,
-                                \ dircolorsColor117,dircolorsColor118,
-                                \ dircolorsColor119,dircolorsColor120,
-                                \ dircolorsColor121,dircolorsColor122,
-                                \ dircolorsColor123,dircolorsColor124,
-                                \ dircolorsColor125,dircolorsColor126,
-                                \ dircolorsColor127,dircolorsColor128,
-                                \ dircolorsColor129,dircolorsColor130,
-                                \ dircolorsColor131,dircolorsColor132,
-                                \ dircolorsColor133,dircolorsColor134,
-                                \ dircolorsColor135,dircolorsColor136,
-                                \ dircolorsColor137,dircolorsColor138,
-                                \ dircolorsColor139,dircolorsColor140,
-                                \ dircolorsColor141,dircolorsColor142,
-                                \ dircolorsColor143,dircolorsColor144,
-                                \ dircolorsColor145,dircolorsColor146,
-                                \ dircolorsColor147,dircolorsColor148,
-                                \ dircolorsColor149,dircolorsColor150,
-                                \ dircolorsColor151,dircolorsColor152,
-                                \ dircolorsColor153,dircolorsColor154,
-                                \ dircolorsColor155,dircolorsColor156,
-                                \ dircolorsColor157,dircolorsColor158,
-                                \ dircolorsColor159,dircolorsColor160,
-                                \ dircolorsColor161,dircolorsColor162,
-                                \ dircolorsColor163,dircolorsColor164,
-                                \ dircolorsColor165,dircolorsColor166,
-                                \ dircolorsColor167,dircolorsColor168,
-                                \ dircolorsColor169,dircolorsColor170,
-                                \ dircolorsColor171,dircolorsColor172,
-                                \ dircolorsColor173,dircolorsColor174,
-                                \ dircolorsColor175,dircolorsColor176,
-                                \ dircolorsColor177,dircolorsColor178,
-                                \ dircolorsColor179,dircolorsColor180,
-                                \ dircolorsColor181,dircolorsColor182,
-                                \ dircolorsColor183,dircolorsColor184,
-                                \ dircolorsColor185,dircolorsColor186,
-                                \ dircolorsColor187,dircolorsColor188,
-                                \ dircolorsColor189,dircolorsColor190,
-                                \ dircolorsColor191,dircolorsColor192,
-                                \ dircolorsColor193,dircolorsColor194,
-                                \ dircolorsColor195,dircolorsColor196,
-                                \ dircolorsColor197,dircolorsColor198,
-                                \ dircolorsColor199,dircolorsColor200,
-                                \ dircolorsColor201,dircolorsColor202,
-                                \ dircolorsColor203,dircolorsColor204,
-                                \ dircolorsColor205,dircolorsColor206,
-                                \ dircolorsColor207,dircolorsColor208,
-                                \ dircolorsColor209,dircolorsColor210,
-                                \ dircolorsColor211,dircolorsColor212,
-                                \ dircolorsColor213,dircolorsColor214,
-                                \ dircolorsColor215,dircolorsColor216,
-                                \ dircolorsColor217,dircolorsColor218,
-                                \ dircolorsColor219,dircolorsColor220,
-                                \ dircolorsColor221,dircolorsColor222,
-                                \ dircolorsColor223,dircolorsColor224,
-                                \ dircolorsColor225,dircolorsColor226,
-                                \ dircolorsColor227,dircolorsColor228,
-                                \ dircolorsColor229,dircolorsColor230,
-                                \ dircolorsColor231,dircolorsColor232,
-                                \ dircolorsColor233,dircolorsColor234,
-                                \ dircolorsColor235,dircolorsColor236,
-                                \ dircolorsColor237,dircolorsColor238,
-                                \ dircolorsColor239,dircolorsColor240,
-                                \ dircolorsColor241,dircolorsColor242,
-                                \ dircolorsColor243,dircolorsColor244,
-                                \ dircolorsColor245,dircolorsColor246,
-                                \ dircolorsColor247,dircolorsColor248,
-                                \ dircolorsColor249,dircolorsColor250,
-                                \ dircolorsColor251,dircolorsColor252,
-                                \ dircolorsColor253,dircolorsColor254,
-                                \ dircolorsColor255
-
-  syn match dircolorsColor0     contained '\<0\=0\>'
-  syn match dircolorsColor1     contained '\<0\=1\>'
-  syn match dircolorsColor2     contained '\<0\=2\>'
-  syn match dircolorsColor3     contained '\<0\=3\>'
-  syn match dircolorsColor4     contained '\<0\=4\>'
-  syn match dircolorsColor5     contained '\<0\=5\>'
-  syn match dircolorsColor6     contained '\<0\=6\>'
-  syn match dircolorsColor7     contained '\<0\=7\>'
-  syn match dircolorsColor8     contained '\<0\=8\>'
-  syn match dircolorsColor9     contained '\<0\=9\>'
-  syn match dircolorsColor10    contained '\<10\>'
-  syn match dircolorsColor11    contained '\<11\>'
-  syn match dircolorsColor12    contained '\<12\>'
-  syn match dircolorsColor13    contained '\<13\>'
-  syn match dircolorsColor14    contained '\<14\>'
-  syn match dircolorsColor15    contained '\<15\>'
-  syn match dircolorsColor16    contained '\<16\>'
-  syn match dircolorsColor17    contained '\<17\>'
-  syn match dircolorsColor18    contained '\<18\>'
-  syn match dircolorsColor19    contained '\<19\>'
-  syn match dircolorsColor20    contained '\<20\>'
-  syn match dircolorsColor21    contained '\<21\>'
-  syn match dircolorsColor22    contained '\<22\>'
-  syn match dircolorsColor23    contained '\<23\>'
-  syn match dircolorsColor24    contained '\<24\>'
-  syn match dircolorsColor25    contained '\<25\>'
-  syn match dircolorsColor26    contained '\<26\>'
-  syn match dircolorsColor27    contained '\<27\>'
-  syn match dircolorsColor28    contained '\<28\>'
-  syn match dircolorsColor29    contained '\<29\>'
-  syn match dircolorsColor30    contained '\<30\>'
-  syn match dircolorsColor31    contained '\<31\>'
-  syn match dircolorsColor32    contained '\<32\>'
-  syn match dircolorsColor33    contained '\<33\>'
-  syn match dircolorsColor34    contained '\<34\>'
-  syn match dircolorsColor35    contained '\<35\>'
-  syn match dircolorsColor36    contained '\<36\>'
-  syn match dircolorsColor37    contained '\<37\>'
-  syn match dircolorsColor38    contained '\<38\>'
-  syn match dircolorsColor39    contained '\<39\>'
-  syn match dircolorsColor40    contained '\<40\>'
-  syn match dircolorsColor41    contained '\<41\>'
-  syn match dircolorsColor42    contained '\<42\>'
-  syn match dircolorsColor43    contained '\<43\>'
-  syn match dircolorsColor44    contained '\<44\>'
-  syn match dircolorsColor45    contained '\<45\>'
-  syn match dircolorsColor46    contained '\<46\>'
-  syn match dircolorsColor47    contained '\<47\>'
-  syn match dircolorsColor48    contained '\<48\>'
-  syn match dircolorsColor49    contained '\<49\>'
-  syn match dircolorsColor50    contained '\<50\>'
-  syn match dircolorsColor51    contained '\<51\>'
-  syn match dircolorsColor52    contained '\<52\>'
-  syn match dircolorsColor53    contained '\<53\>'
-  syn match dircolorsColor54    contained '\<54\>'
-  syn match dircolorsColor55    contained '\<55\>'
-  syn match dircolorsColor56    contained '\<56\>'
-  syn match dircolorsColor57    contained '\<57\>'
-  syn match dircolorsColor58    contained '\<58\>'
-  syn match dircolorsColor59    contained '\<59\>'
-  syn match dircolorsColor60    contained '\<60\>'
-  syn match dircolorsColor61    contained '\<61\>'
-  syn match dircolorsColor62    contained '\<62\>'
-  syn match dircolorsColor63    contained '\<63\>'
-  syn match dircolorsColor64    contained '\<64\>'
-  syn match dircolorsColor65    contained '\<65\>'
-  syn match dircolorsColor66    contained '\<66\>'
-  syn match dircolorsColor67    contained '\<67\>'
-  syn match dircolorsColor68    contained '\<68\>'
-  syn match dircolorsColor69    contained '\<69\>'
-  syn match dircolorsColor70    contained '\<70\>'
-  syn match dircolorsColor71    contained '\<71\>'
-  syn match dircolorsColor72    contained '\<72\>'
-  syn match dircolorsColor73    contained '\<73\>'
-  syn match dircolorsColor74    contained '\<74\>'
-  syn match dircolorsColor75    contained '\<75\>'
-  syn match dircolorsColor76    contained '\<76\>'
-  syn match dircolorsColor77    contained '\<77\>'
-  syn match dircolorsColor78    contained '\<78\>'
-  syn match dircolorsColor79    contained '\<79\>'
-  syn match dircolorsColor80    contained '\<80\>'
-  syn match dircolorsColor81    contained '\<81\>'
-  syn match dircolorsColor82    contained '\<82\>'
-  syn match dircolorsColor83    contained '\<83\>'
-  syn match dircolorsColor84    contained '\<84\>'
-  syn match dircolorsColor85    contained '\<85\>'
-  syn match dircolorsColor86    contained '\<86\>'
-  syn match dircolorsColor87    contained '\<87\>'
-  syn match dircolorsColor88    contained '\<88\>'
-  syn match dircolorsColor89    contained '\<89\>'
-  syn match dircolorsColor90    contained '\<90\>'
-  syn match dircolorsColor91    contained '\<91\>'
-  syn match dircolorsColor92    contained '\<92\>'
-  syn match dircolorsColor93    contained '\<93\>'
-  syn match dircolorsColor94    contained '\<94\>'
-  syn match dircolorsColor95    contained '\<95\>'
-  syn match dircolorsColor96    contained '\<96\>'
-  syn match dircolorsColor97    contained '\<97\>'
-  syn match dircolorsColor98    contained '\<98\>'
-  syn match dircolorsColor99    contained '\<99\>'
-  syn match dircolorsColor100   contained '\<100\>'
-  syn match dircolorsColor101   contained '\<101\>'
-  syn match dircolorsColor102   contained '\<102\>'
-  syn match dircolorsColor103   contained '\<103\>'
-  syn match dircolorsColor104   contained '\<104\>'
-  syn match dircolorsColor105   contained '\<105\>'
-  syn match dircolorsColor106   contained '\<106\>'
-  syn match dircolorsColor107   contained '\<107\>'
-  syn match dircolorsColor108   contained '\<108\>'
-  syn match dircolorsColor109   contained '\<109\>'
-  syn match dircolorsColor110   contained '\<110\>'
-  syn match dircolorsColor111   contained '\<111\>'
-  syn match dircolorsColor112   contained '\<112\>'
-  syn match dircolorsColor113   contained '\<113\>'
-  syn match dircolorsColor114   contained '\<114\>'
-  syn match dircolorsColor115   contained '\<115\>'
-  syn match dircolorsColor116   contained '\<116\>'
-  syn match dircolorsColor117   contained '\<117\>'
-  syn match dircolorsColor118   contained '\<118\>'
-  syn match dircolorsColor119   contained '\<119\>'
-  syn match dircolorsColor120   contained '\<120\>'
-  syn match dircolorsColor121   contained '\<121\>'
-  syn match dircolorsColor122   contained '\<122\>'
-  syn match dircolorsColor123   contained '\<123\>'
-  syn match dircolorsColor124   contained '\<124\>'
-  syn match dircolorsColor125   contained '\<125\>'
-  syn match dircolorsColor126   contained '\<126\>'
-  syn match dircolorsColor127   contained '\<127\>'
-  syn match dircolorsColor128   contained '\<128\>'
-  syn match dircolorsColor129   contained '\<129\>'
-  syn match dircolorsColor130   contained '\<130\>'
-  syn match dircolorsColor131   contained '\<131\>'
-  syn match dircolorsColor132   contained '\<132\>'
-  syn match dircolorsColor133   contained '\<133\>'
-  syn match dircolorsColor134   contained '\<134\>'
-  syn match dircolorsColor135   contained '\<135\>'
-  syn match dircolorsColor136   contained '\<136\>'
-  syn match dircolorsColor137   contained '\<137\>'
-  syn match dircolorsColor138   contained '\<138\>'
-  syn match dircolorsColor139   contained '\<139\>'
-  syn match dircolorsColor140   contained '\<140\>'
-  syn match dircolorsColor141   contained '\<141\>'
-  syn match dircolorsColor142   contained '\<142\>'
-  syn match dircolorsColor143   contained '\<143\>'
-  syn match dircolorsColor144   contained '\<144\>'
-  syn match dircolorsColor145   contained '\<145\>'
-  syn match dircolorsColor146   contained '\<146\>'
-  syn match dircolorsColor147   contained '\<147\>'
-  syn match dircolorsColor148   contained '\<148\>'
-  syn match dircolorsColor149   contained '\<149\>'
-  syn match dircolorsColor150   contained '\<150\>'
-  syn match dircolorsColor151   contained '\<151\>'
-  syn match dircolorsColor152   contained '\<152\>'
-  syn match dircolorsColor153   contained '\<153\>'
-  syn match dircolorsColor154   contained '\<154\>'
-  syn match dircolorsColor155   contained '\<155\>'
-  syn match dircolorsColor156   contained '\<156\>'
-  syn match dircolorsColor157   contained '\<157\>'
-  syn match dircolorsColor158   contained '\<158\>'
-  syn match dircolorsColor159   contained '\<159\>'
-  syn match dircolorsColor160   contained '\<160\>'
-  syn match dircolorsColor161   contained '\<161\>'
-  syn match dircolorsColor162   contained '\<162\>'
-  syn match dircolorsColor163   contained '\<163\>'
-  syn match dircolorsColor164   contained '\<164\>'
-  syn match dircolorsColor165   contained '\<165\>'
-  syn match dircolorsColor166   contained '\<166\>'
-  syn match dircolorsColor167   contained '\<167\>'
-  syn match dircolorsColor168   contained '\<168\>'
-  syn match dircolorsColor169   contained '\<169\>'
-  syn match dircolorsColor170   contained '\<170\>'
-  syn match dircolorsColor171   contained '\<171\>'
-  syn match dircolorsColor172   contained '\<172\>'
-  syn match dircolorsColor173   contained '\<173\>'
-  syn match dircolorsColor174   contained '\<174\>'
-  syn match dircolorsColor175   contained '\<175\>'
-  syn match dircolorsColor176   contained '\<176\>'
-  syn match dircolorsColor177   contained '\<177\>'
-  syn match dircolorsColor178   contained '\<178\>'
-  syn match dircolorsColor179   contained '\<179\>'
-  syn match dircolorsColor180   contained '\<180\>'
-  syn match dircolorsColor181   contained '\<181\>'
-  syn match dircolorsColor182   contained '\<182\>'
-  syn match dircolorsColor183   contained '\<183\>'
-  syn match dircolorsColor184   contained '\<184\>'
-  syn match dircolorsColor185   contained '\<185\>'
-  syn match dircolorsColor186   contained '\<186\>'
-  syn match dircolorsColor187   contained '\<187\>'
-  syn match dircolorsColor188   contained '\<188\>'
-  syn match dircolorsColor189   contained '\<189\>'
-  syn match dircolorsColor190   contained '\<190\>'
-  syn match dircolorsColor191   contained '\<191\>'
-  syn match dircolorsColor192   contained '\<192\>'
-  syn match dircolorsColor193   contained '\<193\>'
-  syn match dircolorsColor194   contained '\<194\>'
-  syn match dircolorsColor195   contained '\<195\>'
-  syn match dircolorsColor196   contained '\<196\>'
-  syn match dircolorsColor197   contained '\<197\>'
-  syn match dircolorsColor198   contained '\<198\>'
-  syn match dircolorsColor199   contained '\<199\>'
-  syn match dircolorsColor200   contained '\<200\>'
-  syn match dircolorsColor201   contained '\<201\>'
-  syn match dircolorsColor202   contained '\<202\>'
-  syn match dircolorsColor203   contained '\<203\>'
-  syn match dircolorsColor204   contained '\<204\>'
-  syn match dircolorsColor205   contained '\<205\>'
-  syn match dircolorsColor206   contained '\<206\>'
-  syn match dircolorsColor207   contained '\<207\>'
-  syn match dircolorsColor208   contained '\<208\>'
-  syn match dircolorsColor209   contained '\<209\>'
-  syn match dircolorsColor210   contained '\<210\>'
-  syn match dircolorsColor211   contained '\<211\>'
-  syn match dircolorsColor212   contained '\<212\>'
-  syn match dircolorsColor213   contained '\<213\>'
-  syn match dircolorsColor214   contained '\<214\>'
-  syn match dircolorsColor215   contained '\<215\>'
-  syn match dircolorsColor216   contained '\<216\>'
-  syn match dircolorsColor217   contained '\<217\>'
-  syn match dircolorsColor218   contained '\<218\>'
-  syn match dircolorsColor219   contained '\<219\>'
-  syn match dircolorsColor220   contained '\<220\>'
-  syn match dircolorsColor221   contained '\<221\>'
-  syn match dircolorsColor222   contained '\<222\>'
-  syn match dircolorsColor223   contained '\<223\>'
-  syn match dircolorsColor224   contained '\<224\>'
-  syn match dircolorsColor225   contained '\<225\>'
-  syn match dircolorsColor226   contained '\<226\>'
-  syn match dircolorsColor227   contained '\<227\>'
-  syn match dircolorsColor228   contained '\<228\>'
-  syn match dircolorsColor229   contained '\<229\>'
-  syn match dircolorsColor230   contained '\<230\>'
-  syn match dircolorsColor231   contained '\<231\>'
-  syn match dircolorsColor232   contained '\<232\>'
-  syn match dircolorsColor233   contained '\<233\>'
-  syn match dircolorsColor234   contained '\<234\>'
-  syn match dircolorsColor235   contained '\<235\>'
-  syn match dircolorsColor236   contained '\<236\>'
-  syn match dircolorsColor237   contained '\<237\>'
-  syn match dircolorsColor238   contained '\<238\>'
-  syn match dircolorsColor239   contained '\<239\>'
-  syn match dircolorsColor240   contained '\<240\>'
-  syn match dircolorsColor241   contained '\<241\>'
-  syn match dircolorsColor242   contained '\<242\>'
-  syn match dircolorsColor243   contained '\<243\>'
-  syn match dircolorsColor244   contained '\<244\>'
-  syn match dircolorsColor245   contained '\<245\>'
-  syn match dircolorsColor246   contained '\<246\>'
-  syn match dircolorsColor247   contained '\<247\>'
-  syn match dircolorsColor248   contained '\<248\>'
-  syn match dircolorsColor249   contained '\<249\>'
-  syn match dircolorsColor250   contained '\<250\>'
-  syn match dircolorsColor251   contained '\<251\>'
-  syn match dircolorsColor252   contained '\<252\>'
-  syn match dircolorsColor253   contained '\<253\>'
-  syn match dircolorsColor254   contained '\<254\>'
-  syn match dircolorsColor255   contained '\<255\>'
-else
-  syn cluster dircolorsColors   contains=dircolorsNumber
-  syn match   dircolorsNumber   '\<\d\+\>'
+if has('gui_running')
+    call s:set_guicolors()
 endif
 
-hi def link dircolorsTodo       Todo
-hi def link dircolorsComment    Comment
-hi def link dircolorsKeyword    Keyword
-hi def link dircolorsExtension  Keyword
-
-if &t_Co == 8 || &t_Co == 16
-  hi def      dircolorsBold       term=bold cterm=bold gui=bold
-  hi def      dircolorsUnderline  term=underline cterm=underline gui=underline
-  hi def link dircolorsBlink      Normal
-  hi def      dircolorsReverse    term=reverse cterm=reverse gui=reverse
-  hi def link dircolorsInvisible  Ignore
-  hi def      dircolorsBlack      ctermfg=Black guifg=Black
-  hi def      dircolorsRed        ctermfg=Red guifg=Red
-  hi def      dircolorsGreen      ctermfg=Green guifg=Green
-  hi def      dircolorsYellow     ctermfg=Yellow guifg=Yellow
-  hi def      dircolorsBlue       ctermfg=Blue guifg=Blue
-  hi def      dircolorsMagenta    ctermfg=Magenta guifg=Magenta
-  hi def      dircolorsCyan       ctermfg=Cyan guifg=Cyan
-  hi def      dircolorsWhite      ctermfg=White guifg=White
-  hi def      dircolorsBGBlack    ctermbg=Black ctermfg=White
-                                  \ guibg=Black guifg=White
-  hi def      dircolorsBGRed      ctermbg=DarkRed guibg=DarkRed
-  hi def      dircolorsBGGreen    ctermbg=DarkGreen guibg=DarkGreen
-  hi def      dircolorsBGYellow   ctermbg=DarkYellow guibg=DarkYellow
-  hi def      dircolorsBGBlue     ctermbg=DarkBlue guibg=DarkBlue
-  hi def      dircolorsBGMagenta  ctermbg=DarkMagenta guibg=DarkMagenta
-  hi def      dircolorsBGCyan     ctermbg=DarkCyan guibg=DarkCyan
-  hi def      dircolorsBGWhite    ctermbg=White ctermfg=Black
-                                  \ guibg=White guifg=Black
-elseif &t_Co == 256 || has("gui_running")
-  hi def    dircolorsColor0     ctermfg=0   guifg=Black
-  hi def    dircolorsColor1     ctermfg=1   guifg=DarkRed
-  hi def    dircolorsColor2     ctermfg=2   guifg=DarkGreen
-  hi def    dircolorsColor3     ctermfg=3   guifg=DarkYellow
-  hi def    dircolorsColor4     ctermfg=4   guifg=DarkBlue
-  hi def    dircolorsColor5     ctermfg=5   guifg=DarkMagenta
-  hi def    dircolorsColor6     ctermfg=6   guifg=DarkCyan
-  hi def    dircolorsColor7     ctermfg=7   guifg=Gray
-  hi def    dircolorsColor8     ctermfg=8   guifg=DarkGray
-  hi def    dircolorsColor9     ctermfg=9   guifg=Red
-  hi def    dircolorsColor10    ctermfg=10  guifg=Green
-  hi def    dircolorsColor11    ctermfg=11  guifg=Yellow
-  hi def    dircolorsColor12    ctermfg=12  guifg=Blue
-  hi def    dircolorsColor13    ctermfg=13  guifg=Magenta
-  hi def    dircolorsColor14    ctermfg=14  guifg=Cyan
-  hi def    dircolorsColor15    ctermfg=15  guifg=White
-  hi def    dircolorsColor16    ctermfg=16  guifg=#000000
-  hi def    dircolorsColor17    ctermfg=17  guifg=#00005f
-  hi def    dircolorsColor18    ctermfg=18  guifg=#000087
-  hi def    dircolorsColor19    ctermfg=19  guifg=#0000af
-  hi def    dircolorsColor20    ctermfg=20  guifg=#0000d7
-  hi def    dircolorsColor21    ctermfg=21  guifg=#0000ff
-  hi def    dircolorsColor22    ctermfg=22  guifg=#005f00
-  hi def    dircolorsColor23    ctermfg=23  guifg=#005f5f
-  hi def    dircolorsColor24    ctermfg=24  guifg=#005f87
-  hi def    dircolorsColor25    ctermfg=25  guifg=#005faf
-  hi def    dircolorsColor26    ctermfg=26  guifg=#005fd7
-  hi def    dircolorsColor27    ctermfg=27  guifg=#005fff
-  hi def    dircolorsColor28    ctermfg=28  guifg=#008700
-  hi def    dircolorsColor29    ctermfg=29  guifg=#00875f
-  hi def    dircolorsColor30    ctermfg=30  guifg=#008787
-  hi def    dircolorsColor31    ctermfg=31  guifg=#0087af
-  hi def    dircolorsColor32    ctermfg=32  guifg=#0087d7
-  hi def    dircolorsColor33    ctermfg=33  guifg=#0087ff
-  hi def    dircolorsColor34    ctermfg=34  guifg=#00af00
-  hi def    dircolorsColor35    ctermfg=35  guifg=#00af5f
-  hi def    dircolorsColor36    ctermfg=36  guifg=#00af87
-  hi def    dircolorsColor37    ctermfg=37  guifg=#00afaf
-  hi def    dircolorsColor38    ctermfg=38  guifg=#00afd7
-  hi def    dircolorsColor39    ctermfg=39  guifg=#00afff
-  hi def    dircolorsColor40    ctermfg=40  guifg=#00d700
-  hi def    dircolorsColor41    ctermfg=41  guifg=#00d75f
-  hi def    dircolorsColor42    ctermfg=42  guifg=#00d787
-  hi def    dircolorsColor43    ctermfg=43  guifg=#00d7af
-  hi def    dircolorsColor44    ctermfg=44  guifg=#00d7d7
-  hi def    dircolorsColor45    ctermfg=45  guifg=#00d7ff
-  hi def    dircolorsColor46    ctermfg=46  guifg=#00ff00
-  hi def    dircolorsColor47    ctermfg=47  guifg=#00ff5f
-  hi def    dircolorsColor48    ctermfg=48  guifg=#00ff87
-  hi def    dircolorsColor49    ctermfg=49  guifg=#00ffaf
-  hi def    dircolorsColor50    ctermfg=50  guifg=#00ffd7
-  hi def    dircolorsColor51    ctermfg=51  guifg=#00ffff
-  hi def    dircolorsColor52    ctermfg=52  guifg=#5f0000
-  hi def    dircolorsColor53    ctermfg=53  guifg=#5f005f
-  hi def    dircolorsColor54    ctermfg=54  guifg=#5f0087
-  hi def    dircolorsColor55    ctermfg=55  guifg=#5f00af
-  hi def    dircolorsColor56    ctermfg=56  guifg=#5f00d7
-  hi def    dircolorsColor57    ctermfg=57  guifg=#5f00ff
-  hi def    dircolorsColor58    ctermfg=58  guifg=#5f5f00
-  hi def    dircolorsColor59    ctermfg=59  guifg=#5f5f5f
-  hi def    dircolorsColor60    ctermfg=60  guifg=#5f5f87
-  hi def    dircolorsColor61    ctermfg=61  guifg=#5f5faf
-  hi def    dircolorsColor62    ctermfg=62  guifg=#5f5fd7
-  hi def    dircolorsColor63    ctermfg=63  guifg=#5f5fff
-  hi def    dircolorsColor64    ctermfg=64  guifg=#5f8700
-  hi def    dircolorsColor65    ctermfg=65  guifg=#5f875f
-  hi def    dircolorsColor66    ctermfg=66  guifg=#5f8787
-  hi def    dircolorsColor67    ctermfg=67  guifg=#5f87af
-  hi def    dircolorsColor68    ctermfg=68  guifg=#5f87d7
-  hi def    dircolorsColor69    ctermfg=69  guifg=#5f87ff
-  hi def    dircolorsColor70    ctermfg=70  guifg=#5faf00
-  hi def    dircolorsColor71    ctermfg=71  guifg=#5faf5f
-  hi def    dircolorsColor72    ctermfg=72  guifg=#5faf87
-  hi def    dircolorsColor73    ctermfg=73  guifg=#5fafaf
-  hi def    dircolorsColor74    ctermfg=74  guifg=#5fafd7
-  hi def    dircolorsColor75    ctermfg=75  guifg=#5fafff
-  hi def    dircolorsColor76    ctermfg=76  guifg=#5fd700
-  hi def    dircolorsColor77    ctermfg=77  guifg=#5fd75f
-  hi def    dircolorsColor78    ctermfg=78  guifg=#5fd787
-  hi def    dircolorsColor79    ctermfg=79  guifg=#5fd7af
-  hi def    dircolorsColor80    ctermfg=80  guifg=#5fd7d7
-  hi def    dircolorsColor81    ctermfg=81  guifg=#5fd7ff
-  hi def    dircolorsColor82    ctermfg=82  guifg=#5fff00
-  hi def    dircolorsColor83    ctermfg=83  guifg=#5fff5f
-  hi def    dircolorsColor84    ctermfg=84  guifg=#5fff87
-  hi def    dircolorsColor85    ctermfg=85  guifg=#5fffaf
-  hi def    dircolorsColor86    ctermfg=86  guifg=#5fffd7
-  hi def    dircolorsColor87    ctermfg=87  guifg=#5fffff
-  hi def    dircolorsColor88    ctermfg=88  guifg=#870000
-  hi def    dircolorsColor89    ctermfg=89  guifg=#87005f
-  hi def    dircolorsColor90    ctermfg=90  guifg=#870087
-  hi def    dircolorsColor91    ctermfg=91  guifg=#8700af
-  hi def    dircolorsColor92    ctermfg=92  guifg=#8700d7
-  hi def    dircolorsColor93    ctermfg=93  guifg=#8700ff
-  hi def    dircolorsColor94    ctermfg=94  guifg=#875f00
-  hi def    dircolorsColor95    ctermfg=95  guifg=#875f5f
-  hi def    dircolorsColor96    ctermfg=96  guifg=#875f87
-  hi def    dircolorsColor97    ctermfg=97  guifg=#875faf
-  hi def    dircolorsColor98    ctermfg=98  guifg=#875fd7
-  hi def    dircolorsColor99    ctermfg=99  guifg=#875fff
-  hi def    dircolorsColor100   ctermfg=100 guifg=#878700
-  hi def    dircolorsColor101   ctermfg=101 guifg=#87875f
-  hi def    dircolorsColor102   ctermfg=102 guifg=#878787
-  hi def    dircolorsColor103   ctermfg=103 guifg=#8787af
-  hi def    dircolorsColor104   ctermfg=104 guifg=#8787d7
-  hi def    dircolorsColor105   ctermfg=105 guifg=#8787ff
-  hi def    dircolorsColor106   ctermfg=106 guifg=#87af00
-  hi def    dircolorsColor107   ctermfg=107 guifg=#87af5f
-  hi def    dircolorsColor108   ctermfg=108 guifg=#87af87
-  hi def    dircolorsColor109   ctermfg=109 guifg=#87afaf
-  hi def    dircolorsColor110   ctermfg=110 guifg=#87afd7
-  hi def    dircolorsColor111   ctermfg=111 guifg=#87afff
-  hi def    dircolorsColor112   ctermfg=112 guifg=#87d700
-  hi def    dircolorsColor113   ctermfg=113 guifg=#87d75f
-  hi def    dircolorsColor114   ctermfg=114 guifg=#87d787
-  hi def    dircolorsColor115   ctermfg=115 guifg=#87d7af
-  hi def    dircolorsColor116   ctermfg=116 guifg=#87d7d7
-  hi def    dircolorsColor117   ctermfg=117 guifg=#87d7ff
-  hi def    dircolorsColor118   ctermfg=118 guifg=#87ff00
-  hi def    dircolorsColor119   ctermfg=119 guifg=#87ff5f
-  hi def    dircolorsColor120   ctermfg=120 guifg=#87ff87
-  hi def    dircolorsColor121   ctermfg=121 guifg=#87ffaf
-  hi def    dircolorsColor122   ctermfg=122 guifg=#87ffd7
-  hi def    dircolorsColor123   ctermfg=123 guifg=#87ffff
-  hi def    dircolorsColor124   ctermfg=124 guifg=#af0000
-  hi def    dircolorsColor125   ctermfg=125 guifg=#af005f
-  hi def    dircolorsColor126   ctermfg=126 guifg=#af0087
-  hi def    dircolorsColor127   ctermfg=127 guifg=#af00af
-  hi def    dircolorsColor128   ctermfg=128 guifg=#af00d7
-  hi def    dircolorsColor129   ctermfg=129 guifg=#af00ff
-  hi def    dircolorsColor130   ctermfg=130 guifg=#af5f00
-  hi def    dircolorsColor131   ctermfg=131 guifg=#af5f5f
-  hi def    dircolorsColor132   ctermfg=132 guifg=#af5f87
-  hi def    dircolorsColor133   ctermfg=133 guifg=#af5faf
-  hi def    dircolorsColor134   ctermfg=134 guifg=#af5fd7
-  hi def    dircolorsColor135   ctermfg=135 guifg=#af5fff
-  hi def    dircolorsColor136   ctermfg=136 guifg=#af8700
-  hi def    dircolorsColor137   ctermfg=137 guifg=#af875f
-  hi def    dircolorsColor138   ctermfg=138 guifg=#af8787
-  hi def    dircolorsColor139   ctermfg=139 guifg=#af87af
-  hi def    dircolorsColor140   ctermfg=140 guifg=#af87d7
-  hi def    dircolorsColor141   ctermfg=141 guifg=#af87ff
-  hi def    dircolorsColor142   ctermfg=142 guifg=#afaf00
-  hi def    dircolorsColor143   ctermfg=143 guifg=#afaf5f
-  hi def    dircolorsColor144   ctermfg=144 guifg=#afaf87
-  hi def    dircolorsColor145   ctermfg=145 guifg=#afafaf
-  hi def    dircolorsColor146   ctermfg=146 guifg=#afafd7
-  hi def    dircolorsColor147   ctermfg=147 guifg=#afafff
-  hi def    dircolorsColor148   ctermfg=148 guifg=#afd700
-  hi def    dircolorsColor149   ctermfg=149 guifg=#afd75f
-  hi def    dircolorsColor150   ctermfg=150 guifg=#afd787
-  hi def    dircolorsColor151   ctermfg=151 guifg=#afd7af
-  hi def    dircolorsColor152   ctermfg=152 guifg=#afd7d7
-  hi def    dircolorsColor153   ctermfg=153 guifg=#afd7ff
-  hi def    dircolorsColor154   ctermfg=154 guifg=#afff00
-  hi def    dircolorsColor155   ctermfg=155 guifg=#afff5f
-  hi def    dircolorsColor156   ctermfg=156 guifg=#afff87
-  hi def    dircolorsColor157   ctermfg=157 guifg=#afffaf
-  hi def    dircolorsColor158   ctermfg=158 guifg=#afffd7
-  hi def    dircolorsColor159   ctermfg=159 guifg=#afffff
-  hi def    dircolorsColor160   ctermfg=160 guifg=#d70000
-  hi def    dircolorsColor161   ctermfg=161 guifg=#d7005f
-  hi def    dircolorsColor162   ctermfg=162 guifg=#d70087
-  hi def    dircolorsColor163   ctermfg=163 guifg=#d700af
-  hi def    dircolorsColor164   ctermfg=164 guifg=#d700d7
-  hi def    dircolorsColor165   ctermfg=165 guifg=#d700ff
-  hi def    dircolorsColor166   ctermfg=166 guifg=#d75f00
-  hi def    dircolorsColor167   ctermfg=167 guifg=#d75f5f
-  hi def    dircolorsColor168   ctermfg=168 guifg=#d75f87
-  hi def    dircolorsColor169   ctermfg=169 guifg=#d75faf
-  hi def    dircolorsColor170   ctermfg=170 guifg=#d75fd7
-  hi def    dircolorsColor171   ctermfg=171 guifg=#d75fff
-  hi def    dircolorsColor172   ctermfg=172 guifg=#d78700
-  hi def    dircolorsColor173   ctermfg=173 guifg=#d7875f
-  hi def    dircolorsColor174   ctermfg=174 guifg=#d78787
-  hi def    dircolorsColor175   ctermfg=175 guifg=#d787af
-  hi def    dircolorsColor176   ctermfg=176 guifg=#d787d7
-  hi def    dircolorsColor177   ctermfg=177 guifg=#d787ff
-  hi def    dircolorsColor178   ctermfg=178 guifg=#d7af00
-  hi def    dircolorsColor179   ctermfg=179 guifg=#d7af5f
-  hi def    dircolorsColor180   ctermfg=180 guifg=#d7af87
-  hi def    dircolorsColor181   ctermfg=181 guifg=#d7afaf
-  hi def    dircolorsColor182   ctermfg=182 guifg=#d7afd7
-  hi def    dircolorsColor183   ctermfg=183 guifg=#d7afff
-  hi def    dircolorsColor184   ctermfg=184 guifg=#d7d700
-  hi def    dircolorsColor185   ctermfg=185 guifg=#d7d75f
-  hi def    dircolorsColor186   ctermfg=186 guifg=#d7d787
-  hi def    dircolorsColor187   ctermfg=187 guifg=#d7d7af
-  hi def    dircolorsColor188   ctermfg=188 guifg=#d7d7d7
-  hi def    dircolorsColor189   ctermfg=189 guifg=#d7d7ff
-  hi def    dircolorsColor190   ctermfg=190 guifg=#d7ff00
-  hi def    dircolorsColor191   ctermfg=191 guifg=#d7ff5f
-  hi def    dircolorsColor192   ctermfg=192 guifg=#d7ff87
-  hi def    dircolorsColor193   ctermfg=193 guifg=#d7ffaf
-  hi def    dircolorsColor194   ctermfg=194 guifg=#d7ffd7
-  hi def    dircolorsColor195   ctermfg=195 guifg=#d7ffff
-  hi def    dircolorsColor196   ctermfg=196 guifg=#ff0000
-  hi def    dircolorsColor197   ctermfg=197 guifg=#ff005f
-  hi def    dircolorsColor198   ctermfg=198 guifg=#ff0087
-  hi def    dircolorsColor199   ctermfg=199 guifg=#ff00af
-  hi def    dircolorsColor200   ctermfg=200 guifg=#ff00d7
-  hi def    dircolorsColor201   ctermfg=201 guifg=#ff00ff
-  hi def    dircolorsColor202   ctermfg=202 guifg=#ff5f00
-  hi def    dircolorsColor203   ctermfg=203 guifg=#ff5f5f
-  hi def    dircolorsColor204   ctermfg=204 guifg=#ff5f87
-  hi def    dircolorsColor205   ctermfg=205 guifg=#ff5faf
-  hi def    dircolorsColor206   ctermfg=206 guifg=#ff5fd7
-  hi def    dircolorsColor207   ctermfg=207 guifg=#ff5fff
-  hi def    dircolorsColor208   ctermfg=208 guifg=#ff8700
-  hi def    dircolorsColor209   ctermfg=209 guifg=#ff875f
-  hi def    dircolorsColor210   ctermfg=210 guifg=#ff8787
-  hi def    dircolorsColor211   ctermfg=211 guifg=#ff87af
-  hi def    dircolorsColor212   ctermfg=212 guifg=#ff87d7
-  hi def    dircolorsColor213   ctermfg=213 guifg=#ff87ff
-  hi def    dircolorsColor214   ctermfg=214 guifg=#ffaf00
-  hi def    dircolorsColor215   ctermfg=215 guifg=#ffaf5f
-  hi def    dircolorsColor216   ctermfg=216 guifg=#ffaf87
-  hi def    dircolorsColor217   ctermfg=217 guifg=#ffafaf
-  hi def    dircolorsColor218   ctermfg=218 guifg=#ffafd7
-  hi def    dircolorsColor219   ctermfg=219 guifg=#ffafff
-  hi def    dircolorsColor220   ctermfg=220 guifg=#ffd700
-  hi def    dircolorsColor221   ctermfg=221 guifg=#ffd75f
-  hi def    dircolorsColor222   ctermfg=222 guifg=#ffd787
-  hi def    dircolorsColor223   ctermfg=223 guifg=#ffd7af
-  hi def    dircolorsColor224   ctermfg=224 guifg=#ffd7d7
-  hi def    dircolorsColor225   ctermfg=225 guifg=#ffd7ff
-  hi def    dircolorsColor226   ctermfg=226 guifg=#ffff00
-  hi def    dircolorsColor227   ctermfg=227 guifg=#ffff5f
-  hi def    dircolorsColor228   ctermfg=228 guifg=#ffff87
-  hi def    dircolorsColor229   ctermfg=229 guifg=#ffffaf
-  hi def    dircolorsColor230   ctermfg=230 guifg=#ffffd7
-  hi def    dircolorsColor231   ctermfg=231 guifg=#ffffff
-  hi def    dircolorsColor232   ctermfg=232 guifg=#080808
-  hi def    dircolorsColor233   ctermfg=233 guifg=#121212
-  hi def    dircolorsColor234   ctermfg=234 guifg=#1c1c1c
-  hi def    dircolorsColor235   ctermfg=235 guifg=#262626
-  hi def    dircolorsColor236   ctermfg=236 guifg=#303030
-  hi def    dircolorsColor237   ctermfg=237 guifg=#3a3a3a
-  hi def    dircolorsColor238   ctermfg=238 guifg=#444444
-  hi def    dircolorsColor239   ctermfg=239 guifg=#4e4e4e
-  hi def    dircolorsColor240   ctermfg=240 guifg=#585858
-  hi def    dircolorsColor241   ctermfg=241 guifg=#626262
-  hi def    dircolorsColor242   ctermfg=242 guifg=#6c6c6c
-  hi def    dircolorsColor243   ctermfg=243 guifg=#767676
-  hi def    dircolorsColor244   ctermfg=244 guifg=#808080
-  hi def    dircolorsColor245   ctermfg=245 guifg=#8a8a8a
-  hi def    dircolorsColor246   ctermfg=246 guifg=#949494
-  hi def    dircolorsColor247   ctermfg=247 guifg=#9e9e9e
-  hi def    dircolorsColor248   ctermfg=248 guifg=#a8a8a8
-  hi def    dircolorsColor249   ctermfg=249 guifg=#b2b2b2
-  hi def    dircolorsColor250   ctermfg=250 guifg=#bcbcbc
-  hi def    dircolorsColor251   ctermfg=251 guifg=#c6c6c6
-  hi def    dircolorsColor252   ctermfg=252 guifg=#d0d0d0
-  hi def    dircolorsColor253   ctermfg=253 guifg=#dadada
-  hi def    dircolorsColor254   ctermfg=254 guifg=#e4e4e4
-  hi def    dircolorsColor255   ctermfg=255 guifg=#eeeeee
-else
-  hi def link dircolorsNumber     Number
+if has('gui_running') || &t_Co != ''
+    call s:reset_colors()
+
+    autocmd CursorMoved,CursorMovedI <buffer> call s:preview_color('.')
+    autocmd CursorHold,CursorHoldI   <buffer> call s:reset_colors()
 endif
 
 let b:current_syntax = "dircolors"
diff -Naur vim74.orig/runtime/syntax/django.vim vim74/runtime/syntax/django.vim
--- vim74.orig/runtime/syntax/django.vim	2012-04-09 18:48:12.000000000 +0000
+++ vim74/runtime/syntax/django.vim	2014-10-10 14:53:42.505385171 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:	Django template
 " Maintainer:	Dave Hodder <dmh@dmh.org.uk>
-" Last Change:	2012 Apr 09
+" Last Change:	2014 Jul 13
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -64,7 +64,7 @@
 syn region djangoVarBlock start="{{" end="}}" contains=djangoFilter,djangoArgument,djangoVarError display
 
 " Django template 'comment' tag and comment block
-syn region djangoComment start="{%\s*comment\s*%}" end="{%\s*endcomment\s*%}" contains=djangoTodo
+syn region djangoComment start="{%\s*comment\(\s\+.\{-}\)\?%}" end="{%\s*endcomment\s*%}" contains=djangoTodo
 syn region djangoComBlock start="{#" end="#}" contains=djangoTodo
 
 " Define the default highlighting.
diff -Naur vim74.orig/runtime/syntax/dnsmasq.vim vim74/runtime/syntax/dnsmasq.vim
--- vim74.orig/runtime/syntax/dnsmasq.vim	2012-05-19 12:57:09.000000000 +0000
+++ vim74/runtime/syntax/dnsmasq.vim	2014-10-10 14:53:42.508718496 +0000
@@ -1,26 +1,19 @@
 " Vim syntax file
 " Maintainer:	Thilo Six
-" Contact:	<vim-dev at vim dot org>
-"		http://www.vim.org/maillist.php#vim-dev
-"
+" Contact:	vim-foo@xk2c-foo.de
+"		:3s+-foo++g
 " Description:	highlight dnsmasq configuration files
 " File:		runtime/syntax/dnsmasq.vim
-" Version:	2.61-1
-" Last Change:	2012 May 19
+" Version:	2.70
+" Last Change:	2014 Apr 30
 " Modeline:	vim: ts=8:sw=2:sts=2:
 "
-" Credits:	Igor N. Prischepoff
-"		Doug Kearns
-"		David Ne\v{c}as
-"		Christian Brabandt
-"
 " License:	VIM License
 "		Vim is Charityware, see ":help Uganda"
 "
 " Options:	You might want to add this to your vimrc:
 "
 "		if &background == "dark"
-"		  " dnsmasq.vim
 "		    let dnsmasq_backrgound_light = 0
 "		else
 "		    let dnsmasq_backrgound_light = 1
@@ -28,8 +21,7 @@
 "
 
 " For version 5.x: Clear all syntax items
-" For version 6.x: Quit when a syntax file was already loaded
-if version < 600
+if v:version < 600
     syntax clear
 elseif exists("b:current_syntax") || &compatible
     finish
@@ -39,11 +31,11 @@
 set cpo&vim
 
 if !exists("b:dnsmasq_backrgound_light")
-	if exists("dnsmasq_backrgound_light")
-		let b:dnsmasq_backrgound_light = dnsmasq_backrgound_light
-	else
-		let b:dnsmasq_backrgound_light = 0
-	endif
+    if exists("dnsmasq_backrgound_light")
+	let b:dnsmasq_backrgound_light = dnsmasq_backrgound_light
+    else
+	let b:dnsmasq_backrgound_light = 0
+    endif
 endif
 
 
@@ -89,10 +81,13 @@
 syn match DnsmasqKeywordSpecial    "\<id\>:"me=e-1
 
 syn match DnsmasqKeyword    "^\s*add-mac\>"
+syn match DnsmasqKeyword    "^\s*add-subnet\>"
 syn match DnsmasqKeyword    "^\s*addn-hosts\>"
 syn match DnsmasqKeyword    "^\s*address\>"
 syn match DnsmasqKeyword    "^\s*alias\>"
 syn match DnsmasqKeyword    "^\s*all-servers\>"
+syn match DnsmasqKeyword    "^\s*auth-zone\>"
+syn match DnsmasqKeyword    "^\s*bind-dynamic\>"
 syn match DnsmasqKeyword    "^\s*bind-interfaces\>"
 syn match DnsmasqKeyword    "^\s*bogus-nxdomain\>"
 syn match DnsmasqKeyword    "^\s*bogus-priv\>"
@@ -128,6 +123,7 @@
 syn match DnsmasqKeyword    "^\s*dhcp-optsfile\>"
 syn match DnsmasqKeyword    "^\s*dhcp-proxy\>"
 syn match DnsmasqKeyword    "^\s*dhcp-range\>"
+syn match DnsmasqKeyword    "^\s*dhcp-relay\>"
 syn match DnsmasqKeyword    "^\s*dhcp-remoteid\>"
 syn match DnsmasqKeyword    "^\s*dhcp-script\>"
 syn match DnsmasqKeyword    "^\s*dhcp-scriptuser\>"
@@ -135,6 +131,10 @@
 syn match DnsmasqKeyword    "^\s*dhcp-subscrid\>"
 syn match DnsmasqKeyword    "^\s*dhcp-userclass\>"
 syn match DnsmasqKeyword    "^\s*dhcp-vendorclass\>"
+syn match DnsmasqKeyword    "^\s*dns-rr\>"
+syn match DnsmasqKeyword    "^\s*dnssec\>"
+syn match DnsmasqKeyword    "^\s*dnssec-check-unsigned\>"
+syn match DnsmasqKeyword    "^\s*dnssec-no-timecheck\>"
 syn match DnsmasqKeyword    "^\s*dns-forward-max\>"
 syn match DnsmasqKeyword    "^\s*domain\>"
 syn match DnsmasqKeyword    "^\s*domain-needed\>"
@@ -149,18 +149,21 @@
 syn match DnsmasqKeyword    "^\s*host-record\>"
 syn match DnsmasqKeyword    "^\s*interface\>"
 syn match DnsmasqKeyword    "^\s*interface-name\>"
+syn match DnsmasqKeyword    "^\s*ipset\>"
 syn match DnsmasqKeyword    "^\s*keep-in-foreground\>"
 syn match DnsmasqKeyword    "^\s*leasefile-ro\>"
 syn match DnsmasqKeyword    "^\s*listen-address\>"
 syn match DnsmasqKeyword    "^\s*local\>"
 syn match DnsmasqKeyword    "^\s*localmx\>"
 syn match DnsmasqKeyword    "^\s*local-ttl\>"
+syn match DnsmasqKeyword    "^\s*local-service\>"
 syn match DnsmasqKeyword    "^\s*localise-queries\>"
 syn match DnsmasqKeyword    "^\s*log-async\>"
 syn match DnsmasqKeyword    "^\s*log-dhcp\>"
 syn match DnsmasqKeyword    "^\s*log-facility\>"
 syn match DnsmasqKeyword    "^\s*log-queries\>"
 syn match DnsmasqKeyword    "^\s*max-ttl\>"
+syn match DnsmasqKeyword    "^\s*max-cache-ttl\>"
 syn match DnsmasqKeyword    "^\s*min-port\>"
 syn match DnsmasqKeyword    "^\s*mx-host\>"
 syn match DnsmasqKeyword    "^\s*mx-target\>"
@@ -180,15 +183,22 @@
 syn match DnsmasqKeyword    "^\s*pxe-prompt\>"
 syn match DnsmasqKeyword    "^\s*pxe-service\>"
 syn match DnsmasqKeyword    "^\s*query-port\>"
+syn match DnsmasqKeyword    "^\s*quiet-ra\>"
+syn match DnsmasqKeyword    "^\s*quiet-dhcp\>"
+syn match DnsmasqKeyword    "^\s*quiet-dhcp6\>"
+syn match DnsmasqKeyword    "^\s*ra-param\>"
 syn match DnsmasqKeyword    "^\s*read-ethers\>"
 syn match DnsmasqKeyword    "^\s*rebind-domain-ok\>"
 syn match DnsmasqKeyword    "^\s*rebind-localhost-ok\>"
 syn match DnsmasqKeyword    "^\s*resolv-file\>"
+syn match DnsmasqKeyword    "^\s*rev-server\>"
 syn match DnsmasqKeyword    "^\s*selfmx\>"
 syn match DnsmasqKeyword    "^\s*server\>"
+syn match DnsmasqKeyword    "^\s*servers-file\>"
 syn match DnsmasqKeyword    "^\s*srv-host\>"
 syn match DnsmasqKeyword    "^\s*stop-dns-rebind\>"
 syn match DnsmasqKeyword    "^\s*strict-order\>"
+syn match DnsmasqKeyword    "^\s*synth-domain\>"
 syn match DnsmasqKeyword    "^\s*tag-if\>"
 syn match DnsmasqKeyword    "^\s*test\>"
 syn match DnsmasqKeyword    "^\s*tftp-max\>"
diff -Naur vim74.orig/runtime/syntax/dockerfile.vim vim74/runtime/syntax/dockerfile.vim
--- vim74.orig/runtime/syntax/dockerfile.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/dockerfile.vim	2014-10-10 14:53:42.525385120 +0000
@@ -0,0 +1,24 @@
+" dockerfile.vim - Syntax highlighting for Dockerfiles
+" Maintainer:   Honza Pokorny <http://honza.ca>
+" Version:      0.5
+" Last Change:  2014 Aug 29
+" License:      BSD
+
+
+if exists("b:current_syntax")
+    finish
+endif
+
+let b:current_syntax = "dockerfile"
+
+syntax case ignore
+
+syntax match dockerfileKeyword /\v^\s*(ONBUILD\s+)?(ADD|CMD|ENTRYPOINT|ENV|EXPOSE|FROM|MAINTAINER|RUN|USER|VOLUME|WORKDIR|COPY)\s/
+
+syntax region dockerfileString start=/\v"/ skip=/\v\\./ end=/\v"/
+
+syntax match dockerfileComment "\v^\s*#.*$"
+
+hi def link dockerfileString String
+hi def link dockerfileKeyword Keyword
+hi def link dockerfileComment Comment
diff -Naur vim74.orig/runtime/syntax/dts.vim vim74/runtime/syntax/dts.vim
--- vim74.orig/runtime/syntax/dts.vim	2013-04-05 14:25:40.000000000 +0000
+++ vim74/runtime/syntax/dts.vim	2014-10-10 14:53:42.542051745 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:	dts/dtsi (device tree files)
 " Maintainer:	Daniel Mack <vim@zonque.org>
-" Last Change:	2013 Apr 05
+" Last Change:	2013 Oct 20
 
 if exists("b:current_syntax")
   finish
@@ -11,11 +11,12 @@
 syntax match  dtsReference      "&[[:alpha:][:digit:]_]\+"
 syntax region dtsBinaryProperty start="\[" end="\]" 
 syntax match  dtsStringProperty "\".*\""
-syntax match  dtsKeyword        "/.*/"
+syntax match  dtsKeyword        "/.\{-1,\}/"
 syntax match  dtsLabel          "^[[:space:]]*[[:alpha:][:digit:]_]\+:"
 syntax match  dtsNode           /[[:alpha:][:digit:]-_]\+\(@[0-9a-fA-F]\+\|\)[[:space:]]*{/he=e-1
 syntax region dtsCellProperty   start="<" end=">" contains=dtsReference,dtsBinaryProperty,dtsStringProperty,dtsComment
 syntax region dtsCommentInner   start="/\*"  end="\*/"
+syntax match  dtsCommentLine    "//.*$"
 
 hi def link dtsCellProperty     Number
 hi def link dtsBinaryProperty   Number
@@ -26,3 +27,4 @@
 hi def link dtsReference        Macro
 hi def link dtsComment          Comment
 hi def link dtsCommentInner     Comment 
+hi def link dtsCommentLine      Comment
diff -Naur vim74.orig/runtime/syntax/euphoria3.vim vim74/runtime/syntax/euphoria3.vim
--- vim74.orig/runtime/syntax/euphoria3.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/euphoria3.vim	2014-10-10 14:53:42.572051670 +0000
@@ -0,0 +1,135 @@
+" Vim syntax file
+" Language:	Euphoria 3.1.1 - supports DOS - (http://www.rapideuphoria.com/)
+" Maintainer:	Shian Lee  
+" Last Change:	2014 Feb 24 (for Vim 7.4)
+" Remark:       Euphoria has two syntax files, euphoria3.vim and euphoria4.vim; 
+"               For details see :help ft-euphoria-syntax
+
+" Quit if a (custom) syntax file was already loaded (compatible with Vim 5.8): 
+if version < 600
+  syntax clear
+elseif exists("b:current_syntax")
+  finish
+endif
+
+" Reset compatible-options to Vim default value, just in case: 
+let s:save_cpo = &cpo
+set cpo&vim
+
+" Should suffice for very long expressions:
+syn sync lines=40
+
+" Euphoria is a case-sensitive language (with only 4 builtin types):
+syntax case match 
+
+" Keywords/Builtins for Debug - from $EUDIR/bin/keywords.e:
+syn keyword euphoria3Debug	with without trace profile  
+syn keyword euphoria3Debug	profile_time warning type_check 
+
+" Keywords (Statments) - from $EUDIR/bin/keywords.e:
+syn keyword euphoria3Keyword	if end then procedure else for return 	
+syn keyword euphoria3Keyword	do elsif while type constant to and or
+syn keyword euphoria3Keyword	exit function global by not include
+syn keyword euphoria3Keyword	xor                      
+
+" Builtins (Identifiers) - from $EUDIR/bin/keywords.e:
+syn keyword euphoria3Builtin	length puts integer sequence position object
+syn keyword euphoria3Builtin	append prepend print printf 
+syn keyword euphoria3Builtin	clear_screen floor getc gets get_key
+syn keyword euphoria3Builtin	rand repeat atom compare find match
+syn keyword euphoria3Builtin	time command_line open close getenv
+syn keyword euphoria3Builtin	sqrt sin cos tan log system date remainder
+syn keyword euphoria3Builtin	power machine_func machine_proc abort peek poke 
+syn keyword euphoria3Builtin	call sprintf arctan and_bits or_bits xor_bits
+syn keyword euphoria3Builtin	not_bits pixel get_pixel mem_copy mem_set
+syn keyword euphoria3Builtin	c_proc c_func routine_id call_proc call_func 
+syn keyword euphoria3Builtin	poke4 peek4s peek4u equal system_exec
+syn keyword euphoria3Builtin	platform task_create task_schedule task_yield
+syn keyword euphoria3Builtin	task_self task_suspend task_list
+syn keyword euphoria3Builtin	task_status task_clock_stop task_clock_start 
+syn keyword euphoria3Builtin	find_from match_from  
+" Builtins (Identifiers) shortcuts for length() and print():
+syn match   euphoria3Builtin	"\$" 
+syn match   euphoria3Builtin	"?"
+
+" Library Identifiers (Function) - from $EUDIR/doc/library.doc:
+syn keyword euphoria3Library	reverse sort custom_sort lower upper
+syn keyword euphoria3Library	wildcard_match wildcard_file arcsin 
+syn keyword euphoria3Library	arccos PI flush lock_file unlock_file
+syn keyword euphoria3Library	pretty_print sprint get_bytes prompt_string 
+syn keyword euphoria3Library	wait_key get prompt_number value seek where 
+syn keyword euphoria3Library	current_dir chdir dir walk_dir allow_break 
+syn keyword euphoria3Library	check_break get_mouse mouse_events mouse_pointer
+syn keyword euphoria3Library	tick_rate sleep get_position graphics_mode 
+syn keyword euphoria3Library	video_config scroll wrap text_color bk_color 
+syn keyword euphoria3Library	palette all_palette get_all_palette read_bitmap 
+syn keyword euphoria3Library	save_bitmap get_active_page set_active_page 
+syn keyword euphoria3Library	get_display_page set_display_page sound
+syn keyword euphoria3Library	cursor text_rows get_screen_char put_screen_char
+syn keyword euphoria3Library	save_text_image display_text_image draw_line 
+syn keyword euphoria3Library	polygon ellipse save_screen save_image display_image 
+syn keyword euphoria3Library	dos_interrupt allocate free allocate_low free_low 
+syn keyword euphoria3Library	allocate_string register_block unregister_block 
+syn keyword euphoria3Library	get_vector set_vector lock_memory int_to_bytes 
+syn keyword euphoria3Library	bytes_to_int int_to_bits bits_to_int atom_to_float64 
+syn keyword euphoria3Library	atom_to_float32 float64_to_atom float32_to_atom 
+syn keyword euphoria3Library	set_rand use_vesa crash_file crash_message
+syn keyword euphoria3Library	crash_routine open_dll define_c_proc define_c_func
+syn keyword euphoria3Library	define_c_var call_back message_box free_console 
+syn keyword euphoria3Library	instance
+
+" Library Identifiers (Function) - from $EUDIR/doc/database.doc:
+syn keyword euphoria3Library 	db_create db_open db_select db_close db_create_table
+syn keyword euphoria3Library 	db_select_table db_rename_table db_delete_table
+syn keyword euphoria3Library 	db_table_list db_table_size db_find_key db_record_key
+syn keyword euphoria3Library 	db_record_data db_insert db_delete_record 
+syn keyword euphoria3Library	db_replace_data	db_compress db_dump db_fatal_id
+
+" Linux shell comment (#!...):
+syn match   euphoria3Comment	"\%^#!.*$"
+" Comment on one line:
+syn region  euphoria3Comment 	start=/--/ end=/$/
+
+" Delimiters and brackets:
+syn match   euphoria3Delimit	"[([\])]"
+syn match   euphoria3Delimit	"\.\."
+syn match   euphoria3Operator	"[{}]"
+
+" Character constant:
+syn region  euphoria3Char	start=/'/ skip=/\\'\|\\\\/ end=/'/ oneline
+
+" String constant: 
+syn region  euphoria3String	start=/"/ skip=/\\"\|\\\\/ end=/"/ oneline
+
+" Hexadecimal integer:
+syn match   euphoria3Number 	"#[0-9A-F]\+\>"
+
+" Integer/Floating point without a dot:
+syn match   euphoria3Number	"\<\d\+\>"
+" Floating point with dot:
+syn match   euphoria3Number	"\<\d\+\.\d*\>"
+" Floating point starting with a dot:
+syn match   euphoria3Number	"\.\d\+\>"
+" Boolean constants: 
+syn keyword euphoria3Boolean	true TRUE false FALSE
+
+" Define the default highlighting.
+" Only used when an item doesn't have highlighting yet:
+hi def link euphoria3Comment	Comment
+hi def link euphoria3String	String
+hi def link euphoria3Char	Character
+hi def link euphoria3Number	Number	
+hi def link euphoria3Boolean	Boolean	
+hi def link euphoria3Builtin	Identifier	
+hi def link euphoria3Library 	Function	
+hi def link euphoria3Keyword	Statement	
+hi def link euphoria3Operator	Statement	
+hi def link euphoria3Debug	Debug	
+hi def link euphoria3Delimit	Delimiter	
+ 	
+let b:current_syntax = "euphoria3"
+
+" Restore current compatible-options: 
+let &cpo = s:save_cpo
+unlet s:save_cpo
+
diff -Naur vim74.orig/runtime/syntax/euphoria4.vim vim74/runtime/syntax/euphoria4.vim
--- vim74.orig/runtime/syntax/euphoria4.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/euphoria4.vim	2014-10-10 14:53:42.575384995 +0000
@@ -0,0 +1,247 @@
+" Vim syntax file
+" Language:	Euphoria 4.0.5 (http://www.openeuphoria.org/)
+" Maintainer:	Shian Lee  
+" Last Change:	2014 Feb 26 (for Vim 7.4)
+" Remark:       Euphoria has two syntax files, euphoria3.vim and euphoria4.vim; 
+"               For details see :help ft-euphoria-syntax
+
+" Quit if a (custom) syntax file was already loaded (compatible with Vim 5.8): 
+if version < 600
+  syntax clear
+elseif exists("b:current_syntax")
+  finish
+endif
+
+" Reset compatible-options to Vim default value, just in case: 
+let s:save_cpo = &cpo
+set cpo&vim
+
+" Should suffice for very long strings and expressions:
+syn sync lines=40
+
+" Euphoria is a case-sensitive language (with only 4 builtin types):
+syntax case match 
+
+" Some keywords/Builtins for Debug - from $EUDIR/include/euphoria/keywords.e:
+syn keyword euphoria4Debug	with without trace profile batch check indirect 
+syn keyword euphoria4Debug	includes inline warning define
+
+" Keywords for conditional compilation - from $EUDIR/include/euphoria/keywords.e:
+syn keyword euphoria4PreProc	elsedef elsifdef ifdef 
+
+" Keywords (Statments) - from $EUDIR/include/euphoria/keywords.e:
+syn keyword euphoria4Keyword	and as break by case constant continue do else     
+syn keyword euphoria4Keyword	elsif end entry enum exit export
+syn keyword euphoria4Keyword	fallthru for function global goto if include
+syn keyword euphoria4Keyword	label loop namespace not or override procedure
+syn keyword euphoria4Keyword	public retry return routine switch then to type
+syn keyword euphoria4Keyword	until while xor
+
+" Builtins (Identifiers) - from $EUDIR/include/euphoria/keywords.e:
+syn keyword euphoria4Builtin	abort and_bits append arctan atom c_func c_proc 
+syn keyword euphoria4Builtin	call call_func call_proc clear_screen close 
+syn keyword euphoria4Builtin	command_line compare cos date delete delete_routine 
+syn keyword euphoria4Builtin	equal find floor get_key getc getenv gets hash 
+syn keyword euphoria4Builtin	head include_paths insert integer length log 
+syn keyword euphoria4Builtin	machine_func machine_proc match mem_copy mem_set 
+syn keyword euphoria4Builtin	not_bits object open option_switches or_bits peek 
+syn keyword euphoria4Builtin	peek2s peek2u peek4s peek4u peek_string peeks pixel 
+syn keyword euphoria4Builtin	platform poke poke2 poke4 position power prepend 
+syn keyword euphoria4Builtin	print printf puts rand remainder remove repeat 
+syn keyword euphoria4Builtin	replace routine_id sequence sin splice sprintf
+syn keyword euphoria4Builtin	sqrt system system_exec tail tan task_clock_start
+syn keyword euphoria4Builtin	task_clock_stop task_create task_list task_schedule
+syn keyword euphoria4Builtin	task_self task_status task_suspend task_yield time
+syn keyword euphoria4Builtin	xor_bits
+" Builtins (Identifiers) shortcuts for length() and print():
+syn match   euphoria4Builtin	"\$" 
+syn match   euphoria4Builtin	"?"
+
+" Library Identifiers (Function) - grep from $EUDIR/include/*:
+syn keyword euphoria4Library	DEP_on SyntaxColor abbreviate_path abs absolute_path
+syn keyword euphoria4Library 	accept add add_item all_copyrights all_matches
+syn keyword euphoria4Library	allocate allocate_code allocate_data allocate_low
+syn keyword euphoria4Library 	allocate_pointer_array allocate_protect
+syn keyword euphoria4Library 	allocate_string allocate_string_pointer_array
+syn keyword euphoria4Library	allocate_wstring allocations allow_break any_key
+syn keyword euphoria4Library	append_lines apply approx arccos arccosh arcsin
+syn keyword euphoria4Library 	arcsinh arctanh assert at atan2 atom_to_float32
+syn keyword euphoria4Library 	atom_to_float64 attr_to_colors avedev average
+syn keyword euphoria4Library 	begins binary_search bind binop_ok bits_to_int
+syn keyword euphoria4Library 	bk_color breakup build_commandline build_list
+syn keyword euphoria4Library 	bytes_to_int calc_hash calc_primes call_back
+syn keyword euphoria4Library 	canon2win canonical canonical_path ceil
+syn keyword euphoria4Library 	central_moment chance char_test chdir
+syn keyword euphoria4Library 	check_all_blocks check_break check_free_list
+syn keyword euphoria4Library 	checksum clear clear_directory cmd_parse
+syn keyword euphoria4Library 	colors_to_attr columnize combine connect
+syn keyword euphoria4Library 	console_colors copy copy_file cosh count crash
+syn keyword euphoria4Library 	crash_file crash_message crash_routine create
+syn keyword euphoria4Library 	create_directory create_file curdir current_dir
+syn keyword euphoria4Library	cursor custom_sort datetime days_in_month
+syn keyword euphoria4Library 	days_in_year db_cache_clear db_clear_table db_close
+syn keyword euphoria4Library	db_compress db_connect db_create db_create_table
+syn keyword euphoria4Library 	db_current db_current_table db_delete_record
+syn keyword euphoria4Library 	db_delete_table db_dump db_fetch_record db_find_key
+syn keyword euphoria4Library	db_get_errors db_get_recid db_insert db_open
+syn keyword euphoria4Library	db_record_data db_record_key db_record_recid
+syn keyword euphoria4Library 	db_rename_table db_replace_data db_replace_recid
+syn keyword euphoria4Library 	db_select db_select_table db_set_caching
+syn keyword euphoria4Library 	db_table_list db_table_size deallocate decanonical
+syn keyword euphoria4Library 	decode defaulted_value defaultext define_c_func
+syn keyword euphoria4Library 	define_c_proc define_c_var deg2rad delete_file
+syn keyword euphoria4Library 	dep_works dequote deserialize diff dir dir_size
+syn keyword euphoria4Library 	dirname disk_metrics disk_size display
+syn keyword euphoria4Library 	display_text_image dnsquery driveid dump dup emovavg
+syn keyword euphoria4Library 	encode ends ensure_in_list ensure_in_range
+syn keyword euphoria4Library 	error_code error_message error_no error_string
+syn keyword euphoria4Library 	error_to_string escape euphoria_copyright exec
+syn keyword euphoria4Library 	exp extract fetch fib file_exists file_length
+syn keyword euphoria4Library 	file_timestamp file_type filebase fileext filename
+syn keyword euphoria4Library	filter find_all find_all_but find_any find_each
+syn keyword euphoria4Library 	find_nested find_replace find_replace_callback
+syn keyword euphoria4Library	find_replace_limit flags_to_string flatten
+syn keyword euphoria4Library 	float32_to_atom float64_to_atom flush for_each
+syn keyword euphoria4Library 	format frac free free_code free_console free_low
+syn keyword euphoria4Library	free_pointer_array from_date from_unix gcd geomean
+syn keyword euphoria4Library	get get_bytes get_charsets get_def_lang
+syn keyword euphoria4Library 	get_display_page get_dstring get_encoding_properties
+syn keyword euphoria4Library 	get_integer16 get_integer32 get_lang_path get_lcid
+syn keyword euphoria4Library 	get_mouse get_option get_ovector_size get_pid
+syn keyword euphoria4Library 	get_position get_rand get_screen_char get_text
+syn keyword euphoria4Library 	get_vector getaddrinfo getmxrr getnsrr graphics_mode
+syn keyword euphoria4Library 	harmean has has_console has_match hex_text
+syn keyword euphoria4Library 	host_by_addr host_by_name http_get http_post iff
+syn keyword euphoria4Library 	iif info init_class init_curdir insertion_sort
+syn keyword euphoria4Library 	instance int_to_bits int_to_bytes intdiv
+syn keyword euphoria4Library 	is_DEP_supported is_empty is_even is_even_obj
+syn keyword euphoria4Library 	is_in_list is_in_range is_inetaddr is_leap_year
+syn keyword euphoria4Library 	is_match is_using_DEP is_win_nt join join_path
+syn keyword euphoria4Library 	keep_comments keep_newlines key_codes keys keyvalues
+syn keyword euphoria4Library	kill kurtosis lang_load larger_of largest last
+syn keyword euphoria4Library 	listen load load_map locate_file lock_file
+syn keyword euphoria4Library	lock_memory log10 lookup lower malloc mapping
+syn keyword euphoria4Library 	match_all match_any match_replace matches max
+syn keyword euphoria4Library 	maybe_any_key median memory_used merge message_box
+syn keyword euphoria4Library	mid min minsize mod mode money mouse_events
+syn keyword euphoria4Library	mouse_pointer movavg move_file nested_get
+syn keyword euphoria4Library 	nested_put new new_extra new_from_kvpairs
+syn keyword euphoria4Library 	new_from_string new_time next_prime now now_gmt
+syn keyword euphoria4Library 	number open_dll optimize option_spec_to_string
+syn keyword euphoria4Library 	or_all	pad_head pad_tail pairs parse
+syn keyword euphoria4Library 	parse_commandline parse_ip_address parse_querystring
+syn keyword euphoria4Library 	parse_url patch pathinfo pathname pcre_copyright
+syn keyword euphoria4Library 	peek_end peek_top peek_wstring pivot platform_name
+syn keyword euphoria4Library 	poke_string poke_wstring pop powof2 prepare_block
+syn keyword euphoria4Library 	pretty_print pretty_sprint prime_list process_lines
+syn keyword euphoria4Library 	product project prompt_number prompt_string proper
+syn keyword euphoria4Library 	push put put_integer16 put_integer32 put_screen_char
+syn keyword euphoria4Library 	quote rad2deg rand_range range raw_frequency read
+syn keyword euphoria4Library 	read_bitmap read_file read_lines receive receive_from
+syn keyword euphoria4Library	register_block rehash remove_all remove_directory
+syn keyword euphoria4Library 	remove_dups remove_item remove_subseq rename_file
+syn keyword euphoria4Library	repeat_pattern reset retain_all reverse rfind rmatch
+syn keyword euphoria4Library 	rnd rnd_1 roll rotate rotate_bits round safe_address
+syn keyword euphoria4Library 	sample save_bitmap save_map save_text_image scroll
+syn keyword euphoria4Library	seek select send send_to serialize series
+syn keyword euphoria4Library	service_by_name service_by_port set
+syn keyword euphoria4Library 	set_accumulate_summary set_charsets set_colors
+syn keyword euphoria4Library 	set_decimal_mark set_def_lang set_default_charsets
+syn keyword euphoria4Library 	set_encoding_properties set_keycodes set_lang_path
+syn keyword euphoria4Library 	set_option set_rand set_test_abort set_test_verbosity
+syn keyword euphoria4Library 	set_vector set_wait_on_summary setenv shift_bits
+syn keyword euphoria4Library 	show_block show_help show_tokens shuffle shutdown
+syn keyword euphoria4Library 	sign sim_index sinh size skewness sleep slice small
+syn keyword euphoria4Library 	smaller_of smallest sort sort_columns sound split
+syn keyword euphoria4Library 	split_any split_limit split_path sprint start_time
+syn keyword euphoria4Library 	statistics stdev store string_numbers subtract sum
+syn keyword euphoria4Library 	sum_central_moments swap tanh task_delay temp_file
+syn keyword euphoria4Library 	test_equal test_exec test_fail test_false
+syn keyword euphoria4Library 	test_not_equal test_pass test_read test_report
+syn keyword euphoria4Library	test_true test_write text_color text_rows threshold
+syn keyword euphoria4Library 	tick_rate to_integer to_number to_string to_unix
+syn keyword euphoria4Library	tokenize_file tokenize_string top transform translate
+syn keyword euphoria4Library 	transmute trim trim_head trim_tail trsprintf trunc
+syn keyword euphoria4Library 	type_of uname unlock_file unregister_block unsetenv
+syn keyword euphoria4Library	upper use_vesa valid valid_index value values version
+syn keyword euphoria4Library	version_date version_major version_minor version_node
+syn keyword euphoria4Library 	version_patch version_revision version_string
+syn keyword euphoria4Library 	version_string_long version_string_short version_type
+syn keyword euphoria4Library 	video_config vlookup vslice wait_key walk_dir
+syn keyword euphoria4Library 	warning_file weeks_day where which_bit wildcard_file
+syn keyword euphoria4Library 	wildcard_match wrap write write_file write_lines
+syn keyword euphoria4Library 	writef writefln years_day
+
+" Library Identifiers (Type) - grep from $EUDIR/include/*:
+syn keyword euphoria4Type	ascii_string boolean bordered_address byte_range
+syn keyword euphoria4Type	case_flagset_type color cstring 
+syn keyword euphoria4Type	file_number file_position graphics_point
+syn keyword euphoria4Type	integer_array lcid lock_type machine_addr map 
+syn keyword euphoria4Type	mixture number_array option_spec
+syn keyword euphoria4Type	page_aligned_address positive_int process regex
+syn keyword euphoria4Type	sequence_array socket stack std_library_address
+syn keyword euphoria4Type	string t_alnum t_alpha t_ascii t_boolean
+syn keyword euphoria4Type	t_bytearray t_cntrl t_consonant t_digit t_display
+syn keyword euphoria4Type	t_graph t_identifier t_lower t_print t_punct
+syn keyword euphoria4Type	t_space t_specword t_text t_upper t_vowel t_xdigit
+syn keyword euphoria4Type	valid_memory_protection_constant valid_wordsize
+
+" Linux shell comment (#!...):
+syn match   euphoria4Comment	"\%^#!.*$"
+" Single and multilines comments: 
+syn region  euphoria4Comment 	start=/--/ end=/$/ 
+syn region  euphoria4Comment 	start="/\*" end="\*/" 
+
+" Delimiters and brackets:
+syn match   euphoria4Delimit	"[([\])]"
+syn match   euphoria4Delimit	"\.\."
+syn match   euphoria4Delimit	":"
+syn match   euphoria4Operator	"[{}]"
+
+" Character constant:
+syn region  euphoria4Char	start=/'/ skip=/\\'\|\\\\/ end=/'/ oneline
+
+" String constant (""" must be *after* "): 
+syn region  euphoria4String	start=/"/ skip=/\\"\|\\\\/ end=/"/ oneline 
+syn region  euphoria4String	start=/b"\|x"/ end=/"/ 
+syn region  euphoria4String	start=/`/ end=/`/
+syn region  euphoria4String	start=/"""/ end=/"""/
+
+" Binary/Octal/Decimal/Hexadecimal integer:
+syn match   euphoria4Number 	"\<0b[01_]\+\>"
+syn match   euphoria4Number 	"\<0t[0-7_]\+\>"
+syn match   euphoria4Number 	"\<0d[0-9_]\+\>"
+syn match   euphoria4Number 	"\<0x[0-9A-Fa-f_]\+\>"
+syn match   euphoria4Number 	"#[0-9A-Fa-f_]\+\>"
+
+" Integer/Floating point without a dot:
+syn match   euphoria4Number	"\<\d\+\>"
+" Floating point with dot:
+syn match   euphoria4Number	"\<\d\+\.\d*\>"
+" Floating point starting with a dot:
+syn match   euphoria4Number	"\.\d\+\>"
+" Boolean constants: 
+syn keyword euphoria4Boolean	true TRUE false FALSE
+
+" Define the default highlighting.
+" Only used when an item doesn't have highlighting yet:
+hi def link euphoria4Comment	Comment
+hi def link euphoria4String	String
+hi def link euphoria4Char	Character
+hi def link euphoria4Number	Number	
+hi def link euphoria4Boolean	Boolean	
+hi def link euphoria4Builtin	Identifier	
+hi def link euphoria4Library 	Function	
+hi def link euphoria4Type 	Type	
+hi def link euphoria4Keyword	Statement	
+hi def link euphoria4Operator	Statement		
+hi def link euphoria4Debug	Debug	
+hi def link euphoria4Delimit	Delimiter	
+hi def link euphoria4PreProc	PreProc	
+	
+let b:current_syntax = "euphoria4"
+
+" Restore current compatible-options: 
+let &cpo = s:save_cpo
+unlet s:save_cpo
+
diff -Naur vim74.orig/runtime/syntax/gnuplot.vim vim74/runtime/syntax/gnuplot.vim
--- vim74.orig/runtime/syntax/gnuplot.vim	2010-05-15 11:03:56.000000000 +0000
+++ vim74/runtime/syntax/gnuplot.vim	2014-10-10 14:53:42.635384844 +0000
@@ -1,176 +1,505 @@
 " Vim syntax file
-" Language:	gnuplot 3.8i.0
-" Maintainer:	John Hoelzel johnh51@users.sourceforge.net
-" Last Change:	Mon May 26 02:33:33 UTC 2003
-" Filenames:	*.gpi  *.gih   scripts: #!*gnuplot
-" URL:		http://johnh51.get.to/vim/syntax/gnuplot.vim
-"
-
-" thanks to "David Necas (Yeti)" <yeti@physics.muni.cz> for heads up - working on more changes .
-" *.gpi      = GnuPlot Input - what I use because there is no other guideline. jeh 11/2000
-" *.gih      = makes using cut/pasting from gnuplot.gih easier ...
-" #!*gnuplot = for Linux bash shell scripts of gnuplot commands.
-"	       emacs used a suffix of '<gp?>'
-" gnuplot demo files show no preference.
-" I will post mail and newsgroup comments on a standard suffix in 'URL' directory.
+" Language:	gnuplot 4.7.0
+" Maintainer:	Andrew Rasmussen andyras@users.sourceforge.net
+" Original Maintainer:	John Hoelzel johnh51@users.sourceforge.net
+" Last Change:	2014-02-24
+" Filenames:	*.gnu *.plt *.gpi *.gih *.gp *.gnuplot scripts: #!*gnuplot
+" URL:		http://www.vim.org/scripts/script.php?script_id=4873
+" Original URL:	http://johnh51.get.to/vim/syntax/gnuplot.vim
+
+" thanks to "David Necas (Yeti)" <yeti@physics.muni.cz>
+
+" credit also to Jim Eberle <jim.eberle@fastnlight.com>
+" for the script http://www.vim.org/scripts/script.php?script_id=1737
+
+" some shortened names to make demo files look clean... jeh. 11/2000
+" demos -> 3.8i ... jeh. 5/2003 - a work in progress...
+" added current commands, keywords, variables, todos, macros... amr 2014-02-24
+
+" For vim version 5.x: Clear all syntax items
+" For vim version 6.x: Quit when a syntax file was already loaded
 
-" For version 5.x: Clear all syntax items
-" For version 6.x: Quit when a syntax file was already loaded
 if version < 600
   syntax clear
 elseif exists("b:current_syntax")
   finish
 endif
 
-" some shortened names to make demo files look clean... jeh. 11/2000
-" demos -> 3.8i ... jeh. 5/2003 - a work in progress...
-
-" commands
+" ---- Special characters ---- "
 
-syn keyword gnuplotStatement	cd call clear exit set unset plot splot help
-syn keyword gnuplotStatement	load pause quit fit rep[lot] if
-syn keyword gnuplotStatement	FIT_LIMIT FIT_MAXITER FIT_START_LAMBDA
-syn keyword gnuplotStatement	FIT_LAMBDA_FACTOR FIT_LOG FIT_SCRIPT
-syn keyword gnuplotStatement	print pwd reread reset save show test ! functions var
-syn keyword gnuplotConditional	if
-" if is cond + stmt - ok?
+" no harm in just matching any \[char] within double quotes, right?
+syn match gnuplotSpecial	"\\." contained
+" syn match gnuplotSpecial	"\\\o\o\o\|\\x\x\x\|\\c[^"]\|\\[a-z\\]" contained
+
+" measurements in the units in, cm and pt are special
+syn match gnuplotUnit		"[0-9]+in"
+syn match gnuplotUnit		"[0-9]+cm"
+syn match gnuplotUnit		"[0-9]+pt"
+
+" external (shell) commands are special
+syn region gnuplotExternal	start="!" end="$"
+
+" ---- Comments ---- "
+
+syn region gnuplotComment	start="#" end="$" contains=gnuplotTodo
+
+" ---- Constants ---- "
+
+" strings
+syn region gnuplotString	start=+"+ skip=+\\"+ end=+"+ contains=gnuplotSpecial
+syn region gnuplotString	start="'" end="'"
+
+" built-in variables
+syn keyword gnuplotNumber	GNUTERM GPVAL_TERM GPVAL_TERMOPTIONS GPVAL_SPLOT
+syn keyword gnuplotNumber	GPVAL_OUTPUT GPVAL_ENCODING GPVAL_VERSION
+syn keyword gnuplotNumber	GPVAL_PATCHLEVEL GPVAL_COMPILE_OPTIONS
+syn keyword gnuplotNumber	GPVAL_MULTIPLOT GPVAL_PLOT GPVAL_VIEW_ZSCALE
+syn keyword gnuplotNumber	GPVAL_TERMINALS GPVAL_pi GPVAL_NaN
+syn keyword gnuplotNumber	GPVAL_ERRNO GPVAL_ERRMSG GPVAL_PWD
+syn keyword gnuplotNumber	pi NaN GPVAL_LAST_PLOT GPVAL_TERM_WINDOWID
+syn keyword gnuplotNumber	GPVAL_X_MIN GPVAL_X_MAX GPVAL_X_LOG
+syn keyword gnuplotNumber	GPVAL_DATA_X_MIN GPVAL_DATA_X_MAX GPVAL_Y_MIN
+syn keyword gnuplotNumber	GPVAL_Y_MAX GPVAL_Y_LOG GPVAL_DATA_Y_MIN
+syn keyword gnuplotNumber	GPVAL_DATA_Y_MAX GPVAL_X2_MIN GPVAL_X2_MAX
+syn keyword gnuplotNumber	GPVAL_X2_LOG GPVAL_DATA_X2_MIN GPVAL_DATA_X2_MAX
+syn keyword gnuplotNumber	GPVAL_Y2_MIN GPVAL_Y2_MAX GPVAL_Y2_LOG
+syn keyword gnuplotNumber	GPVAL_DATA_Y2_MIN GPVAL_DATA_Y2_MAX GPVAL_Z_MIN
+syn keyword gnuplotNumber	GPVAL_Z_MAX GPVAL_Z_LOG GPVAL_DATA_Z_MIN
+syn keyword gnuplotNumber	GPVAL_DATA_Z_MAX GPVAL_CB_MIN GPVAL_CB_MAX
+syn keyword gnuplotNumber	GPVAL_CB_LOG GPVAL_DATA_CB_MIN GPVAL_DATA_CB_MAX
+syn keyword gnuplotNumber	GPVAL_T_MIN GPVAL_T_MAX GPVAL_T_LOG GPVAL_U_MIN
+syn keyword gnuplotNumber	GPVAL_U_MAX GPVAL_U_LOG GPVAL_V_MIN GPVAL_V_MAX
+syn keyword gnuplotNumber	GPVAL_V_LOG GPVAL_R_MIN GPVAL_R_LOG
+syn keyword gnuplotNumber	GPVAL_TERM_XMIN GPVAL_TERM_XMAX GPVAL_TERM_YMIN
+syn keyword gnuplotNumber	GPVAL_TERM_YMAX GPVAL_TERM_XSIZE
+syn keyword gnuplotNumber	GPVAL_TERM_YSIZE GPVAL_VIEW_MAP GPVAL_VIEW_ROT_X
+syn keyword gnuplotNumber	GPVAL_VIEW_ROT_Z GPVAL_VIEW_SCALE
+
+" function name variables
+syn match gnuplotNumber		"GPFUN_[a-zA-Z_]*"
+
+" stats variables
+syn keyword gnuplotNumber	STATS_records STATS_outofrange STATS_invalid
+syn keyword gnuplotNumber	STATS_blank STATS_blocks STATS_columns STATS_min
+syn keyword gnuplotNumber	STATS_max STATS_index_min STATS_index_max
+syn keyword gnuplotNumber	STATS_lo_quartile STATS_median STATS_up_quartile
+syn keyword gnuplotNumber	STATS_mean STATS_stddev STATS_sum STATS_sumsq
+syn keyword gnuplotNumber	STATS_correlation STATS_slope STATS_intercept
+syn keyword gnuplotNumber	STATS_sumxy STATS_pos_min_y STATS_pos_max_y
+syn keyword gnuplotNumber	STATS_mean STATS_stddev STATS_mean_x STATS_sum_x
+syn keyword gnuplotNumber	STATS_stddev_x STATS_sumsq_x STATS_min_x
+syn keyword gnuplotNumber	STATS_max_x STATS_median_x STATS_lo_quartile_x
+syn keyword gnuplotNumber	STATS_up_quartile_x STATS_index_min_x
+syn keyword gnuplotNumber	STATS_index_max_x STATS_mean_y STATS_stddev_y
+syn keyword gnuplotNumber	STATS_sum_y STATS_sumsq_y STATS_min_y
+syn keyword gnuplotNumber	STATS_max_y STATS_median_y STATS_lo_quartile_y
+syn keyword gnuplotNumber	STATS_up_quartile_y STATS_index_min_y
+syn keyword gnuplotNumber	STATS_index_max_y STATS_correlation STATS_sumxy
+
+" deprecated fit variables
+syn keyword gnuplotError	FIT_LIMIT FIT_MAXITER FIT_START_LAMBDA
+syn keyword gnuplotError	FIT_LAMBDA_FACTOR FIT_LOG FIT_SCRIPT
 
-" numbers fm c.vim
+" numbers, from c.vim
 
-"	integer number, or floating point number without a dot and with "f".
+" integer number, or floating point number without a dot and with "f".
 syn case    ignore
 syn match   gnuplotNumber	"\<[0-9]\+\(u\=l\=\|lu\|f\)\>"
-"	floating point number, with dot, optional exponent
+
+" floating point number, with dot, optional exponent
 syn match   gnuplotFloat	"\<[0-9]\+\.[0-9]*\(e[-+]\=[0-9]\+\)\=[fl]\=\>"
-"	floating point number, starting with a dot, optional exponent
+
+" floating point number, starting with a dot, optional exponent
 syn match   gnuplotFloat	"\.[0-9]\+\(e[-+]\=[0-9]\+\)\=[fl]\=\>"
-"	floating point number, without dot, with exponent
+
+" floating point number, without dot, with exponent
 syn match   gnuplotFloat	"\<[0-9]\+e[-+]\=[0-9]\+[fl]\=\>"
-"	hex number
+
+" hex number
 syn match   gnuplotNumber	"\<0x[0-9a-f]\+\(u\=l\=\|lu\)\>"
 syn case    match
-"	flag an octal number with wrong digits by not hilighting
+
+" flag an octal number with wrong digits by not highlighting
 syn match   gnuplotOctalError	"\<0[0-7]*[89]"
 
-" plot args
+" ---- Identifiers: Functions ---- "
 
-syn keyword gnuplotType		u[sing] tit[le] notit[le] wi[th] steps fs[teps]
-syn keyword gnuplotType		title notitle t
-syn keyword gnuplotType		with w
-syn keyword gnuplotType		li[nes] l
-" t - too much?  w - too much?  l - too much?
-syn keyword gnuplotType		linespoints via
-
-" funcs
-
-syn keyword gnuplotFunc		abs acos acosh arg asin asinh atan atanh atan2
-syn keyword gnuplotFunc		besj0 besj1 besy0 besy1
-syn keyword gnuplotFunc		ceil column cos cosh erf erfc exp floor gamma
-syn keyword gnuplotFunc		ibeta inverf igamma imag invnorm int lgamma
-syn keyword gnuplotFunc		log log10 norm rand real sgn sin sinh sqrt tan
-syn keyword gnuplotFunc		lambertw
-syn keyword gnuplotFunc		tanh valid
-syn keyword gnuplotFunc		tm_hour tm_mday tm_min tm_mon tm_sec
-syn keyword gnuplotFunc		tm_wday tm_yday tm_year
-
-" set vars
-
-syn keyword gnuplotType		xdata timefmt grid noytics ytics fs
-syn keyword gnuplotType		logscale time notime mxtics nomxtics style mcbtics
-syn keyword gnuplotType		nologscale
-syn keyword gnuplotType		axes x1y2 unique acs[plines]
-syn keyword gnuplotType		size origin multiplot xtics xr[ange] yr[ange] square nosquare ratio noratio
-syn keyword gnuplotType		binary matrix index every thru sm[ooth]
-syn keyword gnuplotType		all angles degrees radians
-syn keyword gnuplotType		arrow noarrow autoscale noautoscale arrowstyle
-" autoscale args = x y xy z t ymin ... - too much?
-" needs code to: using title vs autoscale t
-syn keyword gnuplotType		x y z zcb
-syn keyword gnuplotType		linear  cubicspline  bspline order level[s]
-syn keyword gnuplotType		auto disc[rete] incr[emental] from to head nohead
-syn keyword gnuplotType		graph base both nosurface table out[put] data
-syn keyword gnuplotType		bar border noborder boxwidth
-syn keyword gnuplotType		clabel noclabel clip noclip cntrp[aram]
-syn keyword gnuplotType		contour nocontour
-syn keyword gnuplotType		dgrid3d nodgrid3d dummy encoding format
-" set encoding args not included - yet.
-syn keyword gnuplotType		function grid nogrid hidden[3d] nohidden[3d] isosample[s] key nokey
-syn keyword gnuplotType		historysize nohistorysize
-syn keyword gnuplotType		defaults offset nooffset trianglepattern undefined noundefined altdiagonal bentover noaltdiagonal nobentover
-syn keyword gnuplotType		left right top bottom outside below samplen spacing width height box nobox linestyle ls linetype lt linewidth lw
-syn keyword gnuplotType		Left Right autotitles noautotitles enhanced noenhanced
-syn keyword gnuplotType		isosamples
-syn keyword gnuplotType		label nolabel logscale nolog[scale] missing center font locale
-syn keyword gnuplotType		mapping margin bmargin lmargin rmargin tmargin spherical cylindrical cartesian
-syn keyword gnuplotType		linestyle nolinestyle linetype lt linewidth lw pointtype pt pointsize ps
-syn keyword gnuplotType		mouse nomouse
-syn keyword gnuplotType		nooffsets data candlesticks financebars linespoints lp vector nosurface
-syn keyword gnuplotType		term[inal] linux aed767 aed512 gpic
-syn keyword gnuplotType		regis tek410x tek40 vttek kc-tek40xx
-syn keyword gnuplotType		km-tek40xx selanar bitgraph xlib x11 X11
-" x11 args
-syn keyword gnuplotType		aifm cgm dumb fig gif small large size nofontlist winword6 corel dxf emf
-syn keyword gnuplotType		hpgl
-" syn keyword gnuplotType	transparent hp2623a hp2648 hp500c pcl5				      why jeh
-syn keyword gnuplotType		hp2623a hp2648 hp500c pcl5
-syn match gnuplotType		"\<transparent\>"
-syn keyword gnuplotType		hpljii hpdj hppj imagen mif pbm png svg
-syn keyword gnuplotType		postscript enhanced_postscript qms table
-" postscript editing values?
-syn keyword gnuplotType		tgif tkcanvas epson-180dpi epson-60dpi
-syn keyword gnuplotType		epson-lx800 nec-cp6 okidata starc
-syn keyword gnuplotType		tandy-60dpi latex emtex pslatex pstex epslatex
-syn keyword gnuplotType		eepic tpic pstricks texdraw mf metafont mpost mp
-syn keyword gnuplotType		timestamp notimestamp
-syn keyword gnuplotType		variables version
-syn keyword gnuplotType		x2data y2data ydata zdata
-syn keyword gnuplotType		reverse writeback noreverse nowriteback
-syn keyword gnuplotType		axis mirror autofreq nomirror rotate autofreq norotate
-syn keyword gnuplotType		update
-syn keyword gnuplotType		multiplot nomultiplot mytics
-syn keyword gnuplotType		nomytics mztics nomztics mx2tics nomx2tics
-syn keyword gnuplotType		my2tics nomy2tics offsets origin output
-syn keyword gnuplotType		para[metric] nopara[metric] pointsize polar nopolar
-syn keyword gnuplotType		zrange x2range y2range rrange cbrange
-syn keyword gnuplotType		trange urange vrange sample[s] size
-syn keyword gnuplotType		bezier boxerrorbars boxes bargraph bar[s]
-syn keyword gnuplotType		boxxy[errorbars] csplines dots fsteps histeps impulses
-syn keyword gnuplotType		line[s] linesp[oints] points poiinttype sbezier splines steps
-" w lt lw ls	      = optional
-syn keyword gnuplotType		vectors xerr[orbars] xyerr[orbars] yerr[orbars] financebars candlesticks vector
-syn keyword gnuplotType		errorb[ars] surface
-syn keyword gnuplotType		filledcurve[s] pm3d   x1 x2 y1 y2 xy closed
-syn keyword gnuplotType		at pi front
-syn keyword gnuplotType		errorlines xerrorlines yerrorlines xyerrorlines
-syn keyword gnuplotType		tics ticslevel ticscale time timefmt view
-syn keyword gnuplotType		xdata xdtics noxdtics ydtics noydtics
-syn keyword gnuplotType		zdtics nozdtics x2dtics nox2dtics y2dtics noy2dtics
-syn keyword gnuplotType		xlab[el] ylab[el] zlab[el] cblab[el] x2label y2label xmtics
-syn keyword gnuplotType		xmtics noxmtics ymtics noymtics zmtics nozmtics
-syn keyword gnuplotType		x2mtics nox2mtics y2mtics noy2mtics
-syn keyword gnuplotType		cbdtics nocbdtics cbmtics nocbmtics cbtics nocbtics
-syn keyword gnuplotType		xtics noxtics ytics noytics
-syn keyword gnuplotType		ztics noztics x2tics nox2tics
-syn keyword gnuplotType		y2tics noy2tics zero nozero zeroaxis nozeroaxis
-syn keyword gnuplotType		xzeroaxis noxzeroaxis yzeroaxis noyzeroaxis
-syn keyword gnuplotType		x2zeroaxis nox2zeroaxis y2zeroaxis noy2zeroaxis
-syn keyword gnuplotType		angles one two fill empty solid pattern
-syn keyword gnuplotType		default
-syn keyword gnuplotType		scansautomatic flush b[egin] noftriangles implicit
-" b too much? - used in demo
-syn keyword gnuplotType		palette positive negative ps_allcF nops_allcF maxcolors
-syn keyword gnuplotType		push fontfile pop
-syn keyword gnuplotType		rgbformulae defined file color model gradient colornames
-syn keyword gnuplotType		RGB HSV CMY YIQ XYZ
-syn keyword gnuplotType		colorbox vertical horizontal user bdefault
-syn keyword gnuplotType		loadpath fontpath decimalsign in out
-
-" comments + strings
-syn region gnuplotComment	start="#" end="$"
-syn region gnuplotComment	start=+"+ skip=+\\"+ end=+"+
-syn region gnuplotComment	start=+'+	     end=+'+
+" numerical functions
+syn keyword gnuplotFunc		abs acos acosh airy arg asin asinh atan atan2
+syn keyword gnuplotFunc		atanh EllipticK EllipticE EllipticPi besj0 besj1
+syn keyword gnuplotFunc		besy0 besy1 ceil cos cosh erf erfc exp expint
+syn keyword gnuplotFunc		floor gamma ibeta inverf igamma imag invnorm int
+syn keyword gnuplotFunc		lambertw lgamma log log10 norm rand real sgn sin
+syn keyword gnuplotFunc		sin sinh sqrt tan tanh voigt
+
+" string functions
+syn keyword gnuplotFunc		gprintf sprintf strlen strstrt substr strftime
+syn keyword gnuplotFunc		strptime system word words
+
+" other functions
+syn keyword gnuplotFunc		column columnhead columnheader defined exists
+syn keyword gnuplotFunc		hsv2rgb stringcolumn timecolumn tm_hour tm_mday
+syn keyword gnuplotFunc		tm_min tm_mon tm_sec tm_wday tm_yday tm_year
+syn keyword gnuplotFunc		time valid value
+
+" ---- Statements ---- "
+
+" common (builtin) variable names
+syn keyword gnuplotKeyword	x y t u v z s
+
+" conditionals
+syn keyword gnuplotConditional	if else
+
+" repeats
+syn keyword gnuplotRepeat	do for while
+
+" operators
+syn match gnuplotOperator	"[-+*/^|&?:]"
+syn match gnuplotOperator	"\*\*"
+syn match gnuplotOperator	"&&"
+syn match gnuplotOperator	"||"
+
+" Keywords
+
+" keywords for 'fit' command
+syn keyword gnuplotKeyword	via z x:z x:z:s x:y:z:s
+syn keyword gnuplotKeyword	x:y:t:z:s x:y:t:u:z:s x:y:t:u:v:z:s
+
+" keywords for 'plot' command
+" 'axes' keyword
+syn keyword gnuplotKeyword	axes x1y1 x1y2 x2y1 x2y2
+" 'binary' keyword
+syn keyword gnuplotKeyword	binary matrix general array record format endian
+syn keyword gnuplotKeyword	filetype avs edf png scan transpose dx dy dz
+syn keyword gnuplotKeyword	flipx flipy flipz origin center rotate using
+syn keyword gnuplotKeyword	perpendicular skip every
+" datafile keywords
+syn keyword gnuplotKeyword	binary nonuniform matrix index every using
+syn keyword gnuplotKeyword	smooth volatile noautoscale every index
+" 'smooth' keywords
+syn keyword gnuplotKeyword	unique frequency cumulative cnormal kdensity
+syn keyword gnuplotKeyword	csplines acsplines bezer sbezier
+" deprecated 'thru' keyword
+syn keyword gnuplotError	thru
+" 'using' keyword
+syn keyword gnuplotKeyword	using u xticlabels yticlabels zticlabels
+syn keyword gnuplotKeyword	x2ticlabels y2ticlabels xtic ytic ztic
+" 'errorbars' keywords
+syn keyword gnuplotKeyword	errorbars xerrorbars yerrorbars xyerrorbars
+" 'errorlines' keywords
+syn keyword gnuplotKeyword	errorlines xerrorlines yerrorlines xyerrorlines
+" 'title' keywords
+syn keyword gnuplotKeyword	title t tit notitle columnheader at beginning
+syn keyword gnuplotKeyword	end
+" 'with' keywords
+syn keyword gnuplotKeyword	with w linestyle ls linetype lt linewidth
+syn keyword gnuplotKeyword	lw linecolor lc pointtype pt pointsize ps
+syn keyword gnuplotKeyword	fill fs nohidden3d nocontours nosurface palette
+" styles for 'with'
+syn keyword gnuplotKeyword	lines l points p linespoints lp surface dots
+syn keyword gnuplotKeyword	impulses labels vectors steps fsteps histeps
+syn keyword gnuplotKeyword	errorbars errorlines financebars xerrorbars
+syn keyword gnuplotKeyword	xerrorlines xyerrorbars yerrorbars yerrorlines
+syn keyword gnuplotKeyword	boxes boxerrorbars boxxyerrorbars boxplot
+syn keyword gnuplotKeyword	candlesticks circles ellipses filledcurves
+syn keyword gnuplotKeyword	histogram image rgbimage rgbalpha pm3d variable
+
+" keywords for 'save' command
+syn keyword gnuplotKeyword	save functions func variables all var terminal
+syn keyword gnuplotKeyword	term set
+
+" keywords for 'set/show' command
+" set angles
+syn keyword gnuplotKeyword	angles degrees deg radians rad
+" set arrow
+syn keyword gnuplotKeyword	arrow from to rto length angle arrowstyle as
+syn keyword gnuplotKeyword	nohead head backhead heads size filled empty
+syn keyword gnuplotKeyword	nofilled front back linestyle linetype linewidth
+" set autoscale
+" TODO regexp here
+syn keyword gnuplotKeyword	autoscale x y z cb x2 y2 zy min max fixmin
+syn keyword gnuplotKeyword	fixmax fix keepfix noextend
+" set bars
+syn keyword gnuplotKeyword	bars small large fullwidth front back
+" set bind
+syn keyword gnuplotKeyword	bind
+" set margins
+" TODO regexp
+syn keyword gnuplotKeyword	margin bmargin lmargin rmargin tmargin
+" set border
+syn keyword gnuplotKeyword	border front back
+" set boxwidth
+syn keyword gnuplotKeyword	boxwidth absolute relative
+" deprecated set clabel
+syn keyword gnuplotError	clabel
+" set clip
+syn keyword gnuplotKeyword	clip points one two
+" set cntrlabel
+syn keyword gnuplotKeyword	cntrlabel format font start interval onecolor
+" set cntrparam
+syn keyword gnuplotKeyword	cntrparam linear cubicspline bspline points
+syn keyword gnuplotKeyword	order levels auto discrete incremental
+" set colorbox
+syn keyword gnuplotKeyword	colorbox vertical horizontal default user origin
+syn keyword gnuplotKeyword	size front back noborder bdefault border
+" show colornames
+syn keyword gnuplotKeyword	colornames
+" set contour
+syn keyword gnuplotKeyword	contour base surface both
+" set datafile
+syn keyword gnuplotKeyword	datafile fortran nofpe_trap missing separator
+syn keyword gnuplotKeyword	whitespace tab comma commentschars binary
+" set decimalsign
+syn keyword gnuplotKeyword	decimalsign locale
+" set dgrid3d
+syn keyword gnuplotKeyword	dgrid3d splines qnorm gauss cauchy exp box hann
+syn keyword gnuplotKeyword	kdensity
+" set dummy
+syn keyword gnuplotKeyword	dummy
+" set encoding
+syn keyword gnuplotKeyword	encoding default iso_8859_1 iso_8859_15
+syn keyword gnuplotKeyword	iso_8859_2 iso_8859_9 koi8r koi8u cp437 cp850
+syn keyword gnuplotKeyword	cp852 cp950 cp1250 cp1251 cp1254 sjis utf8
+" set fit
+syn keyword gnuplotKeyword	fit logfile default quiet noquiet results brief
+syn keyword gnuplotKeyword	verbose errorvariables noerrorvariables
+syn keyword gnuplotKeyword	errorscaling noerrorscaling prescale noprescale
+syn keyword gnuplotKeyword	maxiter none limit limit_abs start-lambda script
+syn keyword gnuplotKeyword	lambda-factor
+" set fontpath
+syn keyword gnuplotKeyword	fontpath
+" set format
+syn keyword gnuplotKeyword	format
+" show functions
+syn keyword gnuplotKeyword	functions
+" set grid
+syn keyword gnuplotKeyword	grid polar layerdefault xtics ytics ztics x2tics
+syn keyword gnuplotKeyword	y2tics cbtics mxtics mytics mztics mx2tics
+syn keyword gnuplotKeyword	my2tics mcbtics xmtics ymtics zmtics x2mtics
+syn keyword gnuplotKeyword	y2mtics cbmtics noxtics noytics noztics nox2tics
+syn keyword gnuplotKeyword	noy2tics nocbtics nomxtics nomytics nomztics
+syn keyword gnuplotKeyword	nomx2tics nomy2tics nomcbtics
+" set hidden3d
+syn keyword gnuplotKeyword	hidden3d offset trianglepattern undefined
+syn keyword gnuplotKeyword	altdiagonal noaltdiagonal bentover nobentover
+syn keyword gnuplotKeyword	noundefined
+" set historysize
+syn keyword gnuplotKeyword	historysize
+" set isosamples
+syn keyword gnuplotKeyword	isosamples
+" set key
+syn keyword gnuplotKeyword	key on off inside outside at left right center
+syn keyword gnuplotKeyword	top bottom vertical horizontal Left Right
+syn keyword gnuplotKeyword	opaque noopaque reverse noreverse invert maxrows
+syn keyword gnuplotKeyword	noinvert samplen spacing width height autotitle
+syn keyword gnuplotKeyword	noautotitle title enhanced noenhanced font
+syn keyword gnuplotKeyword	textcolor box nobox linetype linewidth maxcols
+" set label
+syn keyword gnuplotKeyword	label left center right rotate norotate by font
+syn keyword gnuplotKeyword	front back textcolor point nopoint offset boxed
+syn keyword gnuplotKeyword	hypertext
+" set linetype
+syn keyword gnuplotKeyword	linetype
+" set link
+syn keyword gnuplotKeyword	link via inverse
+" set loadpath
+syn keyword gnuplotKeyword	loadpath
+" set locale
+syn keyword gnuplotKeyword	locale
+" set logscale
+syn keyword gnuplotKeyword	logscale log
+" set macros
+syn keyword gnuplotKeyword	macros
+" set mapping
+syn keyword gnuplotKeyword	mapping cartesian spherical cylindrical
+" set mouse
+syn keyword gnuplotKeyword	mouse doubleclick nodoubleclick zoomcoordinates
+syn keyword gnuplotKeyword	nozoomcoordinates ruler noruler at polardistance
+syn keyword gnuplotKeyword	nopolardistance deg tan format clipboardformat
+syn keyword gnuplotKeyword	mouseformat labels nolabels zoomjump nozoomjump
+syn keyword gnuplotKeyword	verbose noverbose
+" set multiplot
+syn keyword gnuplotKeyword	multiplot title font layout rowsfirst downwards
+syn keyword gnuplotKeyword	downwards upwards scale offset
+" set object
+syn keyword gnuplotKeyword	object behind fillcolor fc fs rectangle ellipse
+syn keyword gnuplotKeyword	circle polygon at center size units xy xx yy to
+syn keyword gnuplotKeyword	from
+" set offsets
+syn keyword gnuplotKeyword	offsets
+" set origin
+syn keyword gnuplotKeyword	origin
+" set output
+syn keyword gnuplotKeyword	output
+" set parametric
+syn keyword gnuplotKeyword	parametric
+" show plot
+syn keyword gnuplotKeyword	plot add2history
+" set pm3d
+syn keyword gnuplotKeyword	hidden3d interpolate scansautomatic scansforward
+syn keyword gnuplotKeyword	scansbackward depthorder flush begin center end
+syn keyword gnuplotKeyword	ftriangles noftriangles clip1in clip4in mean map
+syn keyword gnuplotKeyword	corners2color geomean harmean rms median min max
+syn keyword gnuplotKeyword	c1 c2 c3 c4 pm3d at nohidden3d implicit explicit
+" set palette
+syn keyword gnuplotKeyword	palette gray color gamma rgbformulae defined
+syn keyword gnuplotKeyword	file functions cubehelix start cycles saturation
+syn keyword gnuplotKeyword	model RGB HSV CMY YIQ XYZ positive negative
+syn keyword gnuplotKeyword	nops_allcF ps_allcF maxcolors float int gradient
+syn keyword gnuplotKeyword	fit2rgbformulae rgbformulae
+" set pointintervalbox
+syn keyword gnuplotKeyword	pointintervalbox
+" set pointsize
+syn keyword gnuplotKeyword	pointsize
+" set polar
+syn keyword gnuplotKeyword	polar
+" set print
+syn keyword gnuplotKeyword	print append
+" set psdir
+syn keyword gnuplotKeyword	psdir
+" set raxis
+syn keyword gnuplotKeyword	raxis rrange rtics
+" set samples
+syn keyword gnuplotKeyword	samples
+" set size
+syn keyword gnuplotKeyword	size square nosquare ratio noratio
+" set style
+syn keyword gnuplotKeyword	style function data noborder rectangle arrow
+syn keyword gnuplotKeyword	default nohead head heads size filled empty
+syn keyword gnuplotKeyword	nofilled front back boxplot range fraction
+syn keyword gnuplotKeyword	outliers nooutliers pointtype candlesticks
+syn keyword gnuplotKeyword	separation labels off auto x x2 sorted unsorted
+syn keyword gnuplotKeyword	fill empty transparent solid pattern border
+syn keyword gnuplotKeyword	increment userstyles financebars line default
+syn keyword gnuplotKeyword	linetype lt linecolor lc linewidth lw pointtype
+syn keyword gnuplotKeyword	pt pointsize ps pointinterval pi palette circle
+syn keyword gnuplotKeyword	radius graph screen wedge nowedge ellipse size
+syn keyword gnuplotKeyword	units xx xy yy histogram line textbox opaque
+syn keyword gnuplotKeyword	border noborder
+" set surface
+syn keyword gnuplotKeyword	surface implicit explicit
+" set table
+syn keyword gnuplotKeyword	table
+" set terminal (list of terminals)
+syn keyword gnuplotKeyword	terminal term push pop aed512 aed767 aifm aqua
+syn keyword gnuplotKeyword	be cairo cairolatex canvas cgm context corel
+syn keyword gnuplotKeyword	debug dumb dxf dxy800a eepic emf emxvga epscairo
+syn keyword gnuplotKeyword	epslatex epson_180dpi excl fig ggi gif gpic hpgl
+syn keyword gnuplotKeyword	grass hp2623a hp2648 hp500c hpljii hppj imagen
+syn keyword gnuplotKeyword	jpeg kyo latex linux lua mf mif mp next openstep
+syn keyword gnuplotKeyword	pbm pdf pdfcairo pm png pngcairo postscript
+syn keyword gnuplotKeyword	pslatex pstex pstricks qms qt regis sun svg svga
+syn keyword gnuplotKeyword	tek40 tek410x texdraw tgif tikz tkcanvas tpic
+syn keyword gnuplotKeyword	vgagl vws vx384 windows wx wxt x11 xlib
+" keywords for 'set terminal'
+syn keyword gnuplotKeyword	color monochrome dashlength dl eps pdf fontscale
+syn keyword gnuplotKeyword	standalone blacktext colortext colourtext header
+syn keyword gnuplotKeyword	noheader mono color solid dashed notransparent
+syn keyword gnuplotKeyword	crop crop background input rounded butt square
+syn keyword gnuplotKeyword	size fsize standalone name jsdir defaultsize
+syn keyword gnuplotKeyword	timestamp notimestamp colour mitered beveled
+syn keyword gnuplotKeyword	round squared palfuncparam blacktext nec_cp6
+syn keyword gnuplotKeyword	mppoints inlineimages externalimages defaultfont
+syn keyword gnuplotKeyword	aspect feed nofeed rotate small tiny standalone
+syn keyword gnuplotKeyword	oldstyle newstyle level1 leveldefault level3
+syn keyword gnuplotKeyword	background nobackground solid clip noclip
+syn keyword gnuplotKeyword	colortext colourtext epson_60dpi epson_lx800
+syn keyword gnuplotKeyword	okidata starc tandy_60dpi dpu414 nec_cp6 draft
+syn keyword gnuplotKeyword	medium large normal landscape portrait big
+syn keyword gnuplotKeyword	inches pointsmax textspecial texthidden
+syn keyword gnuplotKeyword	thickness depth version acceleration giant
+syn keyword gnuplotKeyword	delay loop optimize nooptimize pspoints
+syn keyword gnuplotKeyword	FNT9X17 FNT13X25 interlace nointerlace courier
+syn keyword gnuplotKeyword	originreset nooriginreset gparrows nogparrows
+syn keyword gnuplotKeyword	picenvironment nopicenvironment tightboundingbox
+syn keyword gnuplotKeyword	notightboundingbox charsize gppoints nogppoints
+syn keyword gnuplotKeyword	fontscale textscale fulldoc nofulldoc standalone
+syn keyword gnuplotKeyword	preamble header tikzplot tikzarrows notikzarrows
+syn keyword gnuplotKeyword	cmykimages externalimages noexternalimages
+syn keyword gnuplotKeyword	polyline vectors magnification psnfss nopsnfss
+syn keyword gnuplotKeyword	psnfss-version7 prologues a4paper amstex fname
+syn keyword gnuplotKeyword	fsize server persist widelines interlace
+syn keyword gnuplotKeyword	truecolor notruecolor defaultplex simplex duplex
+syn keyword gnuplotKeyword	nofontfiles adobeglyphnames noadobeglyphnames
+syn keyword gnuplotKeyword	nostandalone metric textrigid animate nopspoints
+syn keyword gnuplotKeyword	hpdj FNT5X9 roman emtex rgbimages bitmap
+syn keyword gnuplotKeyword	nobitmap providevars nointerlace add delete
+syn keyword gnuplotKeyword	auxfile hacktext unit raise palfuncparam
+syn keyword gnuplotKeyword	noauxfile nohacktext nounit noraise ctrl noctrl
+syn keyword gnuplotKeyword	close widget fixed dynamic tek40xx vttek
+syn keyword gnuplotKeyword	kc-tek40xx km-tek40xx bitgraph perltk
+syn keyword gnuplotKeyword	interactive red green blue interpolate mode
+syn keyword gnuplotKeyword	position ctrlq replotonresize position noctrlq
+syn keyword gnuplotKeyword	noreplotonresize
+" set termoption
+syn keyword gnuplotKeyword	termoption font fontscale solid dashed
+" set tics
+syn keyword gnuplotKeyword	tics add axis border mirror nomirror in out
+syn keyword gnuplotKeyword	scale rotate norotate by offset nooffset left
+syn keyword gnuplotKeyword	autojustify format font textcolor right center
+" deprecated set ticslevel
+syn keyword gnuplotError	ticslevel ticscale
+" set timestamp
+syn keyword gnuplotKeyword	timestamp top bottom offset font
+" set timefmt
+syn keyword gnuplotKeyword	timefmt
+" set title
+syn keyword gnuplotKeyword	title offset font textcolor tc
+" set ranges
+syn keyword gnuplotKeyword	trange urange vrange
+" show variables
+syn keyword gnuplotKeyword	variables
+" show version
+syn keyword gnuplotKeyword	version
+" set view
+syn keyword gnuplotKeyword	view map equal noequal xy xyz
+" set x2data
+syn keyword gnuplotKeyword	xdata ydata zdata x2data y2data cbdata xdtics
+syn keyword gnuplotKeyword	ydtics zdtics x2dtics y2dtics cbdtics xzeroaxis
+syn keyword gnuplotKeyword	yzeroaxis zzeroaxis x2zeroaxis y2zeroaxis
+syn keyword gnuplotKeyword	cbzeroaxis time geographic
+" set label
+syn keyword gnuplotKeyword	xlabel ylabel zlabel x2label y2label cblabel
+syn keyword gnuplotKeyword	offset font textcolor by parallel
+" set range
+syn keyword gnuplotKeyword	xrange yrange zrange x2range y2range cbrange
+" set xyplane
+syn keyword gnuplotKeyword	xyplane
+" set zeroaxis
+" set zero
+syn keyword gnuplotKeyword	zero
+" set zeroaxis
+syn keyword gnuplotKeyword	zeroaxis
+
+" keywords for 'stats' command
+syn keyword gnuplotKeyword	nooutput
+
+" keywords for 'test' command
+syn keyword gnuplotKeyword	terminal palette rgb rbg grb gbr brg bgr
+
+" ---- Macros ---- "
+
+syn region gnuplotMacro		start="@" end=" "
+
+" ---- Todos ---- "
+
+syn keyword gnuplotTodo		contained TODO FIXME XXX
+
+" ---- Types: gnuplot commands ---- "
+
+" I set the commands as Types to distinguish them visually from keywords for the
+" commands.  This comes at the end of the syntax file because some commands
+" are redundant with keywords.  It's probably too much trouble to go and
+" create special regions for each redundant keyword/command pair, which means
+" that some keywords (e.g. 'p') will be highlighted as commands.
+
+syn keyword gnuplotStatement	cd call clear evaluate exit fit help history
+syn keyword gnuplotStatement	load lower pause plot p print pwd quit raise
+syn keyword gnuplotStatement	refresh replot rep reread reset save set show
+syn keyword gnuplotStatement	shell splot spstats system test undefine unset
+syn keyword gnuplotStatement	update
 
-" Define the default highlighting.
+" ---- Define the default highlighting ---- "
 " For version 5.7 and earlier: only when not done already
 " For version 5.8 and later: only when an item doesn't have highlighting yet
 if version >= 508 || !exists("did_gnuplot_syntax_inits")
@@ -181,14 +510,41 @@
     command -nargs=+ HiLink hi def link <args>
   endif
 
-  HiLink gnuplotStatement	Statement
-  HiLink gnuplotConditional	Conditional
+  " ---- Comments ---- "
+  HiLink gnuplotComment		Comment
+
+  " ---- Constants ---- "
+  HiLink gnuplotString		String
   HiLink gnuplotNumber		Number
   HiLink gnuplotFloat		Float
+
+  " ---- Identifiers ---- "
+  HiLink gnuplotIdentifier	Identifier
+
+  " ---- Statements ---- "
+  HiLink gnuplotConditional	Conditional
+  HiLink gnuplotRepeat		Repeat
+  HiLink gnuplotKeyword		Keyword
+  HiLink gnuplotOperator	Operator
+
+  " ---- PreProcs ---- "
+  HiLink gnuplotMacro		Macro
+
+  " ---- Types ---- "
+  HiLink gnuplotStatement	Type
+  HiLink gnuplotFunc		Identifier
+
+  " ---- Specials ---- "
+  HiLink gnuplotSpecial		Special
+  HiLink gnuplotUnit		Special
+  HiLink gnuplotExternal	Special
+
+  " ---- Errors ---- "
+  HiLink gnuplotError		Error
   HiLink gnuplotOctalError	Error
-  HiLink gnuplotFunc		Type
-  HiLink gnuplotType		Type
-  HiLink gnuplotComment	Comment
+
+  " ---- Todos ---- "
+  HiLink gnuplotTodo		Todo
 
   delcommand HiLink
 endif
diff -Naur vim74.orig/runtime/syntax/go.vim vim74/runtime/syntax/go.vim
--- vim74.orig/runtime/syntax/go.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/go.vim	2014-10-10 14:53:42.638718169 +0000
@@ -0,0 +1,208 @@
+" Vim syntax file
+" Language:	Go
+" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
+" Last Change:	2014 Aug 16
+
+" Options:
+"   There are some options for customizing the highlighting; the recommended
+"   settings are the default values, but you can write:
+"     let OPTION_NAME = 0
+"   in your ~/.vimrc file to disable particular options. You can also write:
+"     let OPTION_NAME = 1
+"   to enable particular options. At present, all options default to on.
+"
+"   - g:go_highlight_array_whitespace_error
+"     Highlights white space after "[]".
+"   - g:go_highlight_chan_whitespace_error
+"     Highlights white space around the communications operator that don't
+"     follow the standard style.
+"   - g:go_highlight_extra_types
+"     Highlights commonly used library types (io.Reader, etc.).
+"   - g:go_highlight_space_tab_error
+"     Highlights instances of tabs following spaces.
+"   - g:go_highlight_trailing_whitespace_error
+"     Highlights trailing white space.
+
+" Quit when a (custom) syntax file was already loaded
+if exists('b:current_syntax')
+  finish
+endif
+
+if !exists('g:go_highlight_array_whitespace_error')
+  let g:go_highlight_array_whitespace_error = 1
+endif
+if !exists('g:go_highlight_chan_whitespace_error')
+  let g:go_highlight_chan_whitespace_error = 1
+endif
+if !exists('g:go_highlight_extra_types')
+  let g:go_highlight_extra_types = 1
+endif
+if !exists('g:go_highlight_space_tab_error')
+  let g:go_highlight_space_tab_error = 1
+endif
+if !exists('g:go_highlight_trailing_whitespace_error')
+  let g:go_highlight_trailing_whitespace_error = 1
+endif
+
+syn case match
+
+syn keyword     goDirective         package import
+syn keyword     goDeclaration       var const type
+syn keyword     goDeclType          struct interface
+
+hi def link     goDirective         Statement
+hi def link     goDeclaration       Keyword
+hi def link     goDeclType          Keyword
+
+" Keywords within functions
+syn keyword     goStatement         defer go goto return break continue fallthrough
+syn keyword     goConditional       if else switch select
+syn keyword     goLabel             case default
+syn keyword     goRepeat            for range
+
+hi def link     goStatement         Statement
+hi def link     goConditional       Conditional
+hi def link     goLabel             Label
+hi def link     goRepeat            Repeat
+
+" Predefined types
+syn keyword     goType              chan map bool string error
+syn keyword     goSignedInts        int int8 int16 int32 int64 rune
+syn keyword     goUnsignedInts      byte uint uint8 uint16 uint32 uint64 uintptr
+syn keyword     goFloats            float32 float64
+syn keyword     goComplexes         complex64 complex128
+
+hi def link     goType              Type
+hi def link     goSignedInts        Type
+hi def link     goUnsignedInts      Type
+hi def link     goFloats            Type
+hi def link     goComplexes         Type
+
+" Treat func specially: it's a declaration at the start of a line, but a type
+" elsewhere. Order matters here.
+syn match       goType              /\<func\>/
+syn match       goDeclaration       /^func\>/
+
+" Predefined functions and values
+syn keyword     goBuiltins          append cap close complex copy delete imag len
+syn keyword     goBuiltins          make new panic print println real recover
+syn keyword     goConstants         iota true false nil
+
+hi def link     goBuiltins          Keyword
+hi def link     goConstants         Keyword
+
+" Comments; their contents
+syn keyword     goTodo              contained TODO FIXME XXX BUG
+syn cluster     goCommentGroup      contains=goTodo
+syn region      goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell
+syn region      goComment           start="//" end="$" contains=@goCommentGroup,@Spell
+
+hi def link     goComment           Comment
+hi def link     goTodo              Todo
+
+" Go escapes
+syn match       goEscapeOctal       display contained "\\[0-7]\{3}"
+syn match       goEscapeC           display contained +\\[abfnrtv\\'"]+
+syn match       goEscapeX           display contained "\\x\x\{2}"
+syn match       goEscapeU           display contained "\\u\x\{4}"
+syn match       goEscapeBigU        display contained "\\U\x\{8}"
+syn match       goEscapeError       display contained +\\[^0-7xuUabfnrtv\\'"]+
+
+hi def link     goEscapeOctal       goSpecialString
+hi def link     goEscapeC           goSpecialString
+hi def link     goEscapeX           goSpecialString
+hi def link     goEscapeU           goSpecialString
+hi def link     goEscapeBigU        goSpecialString
+hi def link     goSpecialString     Special
+hi def link     goEscapeError       Error
+
+" Strings and their contents
+syn cluster     goStringGroup       contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU,goEscapeError
+syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup
+syn region      goRawString         start=+`+ end=+`+
+
+hi def link     goString            String
+hi def link     goRawString         String
+
+" Characters; their contents
+syn cluster     goCharacterGroup    contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU
+syn region      goCharacter         start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@goCharacterGroup
+
+hi def link     goCharacter         Character
+
+" Regions
+syn region      goBlock             start="{" end="}" transparent fold
+syn region      goParen             start='(' end=')' transparent
+
+" Integers
+syn match       goDecimalInt        "\<\d\+\([Ee]\d\+\)\?\>"
+syn match       goHexadecimalInt    "\<0x\x\+\>"
+syn match       goOctalInt          "\<0\o\+\>"
+syn match       goOctalError        "\<0\o*[89]\d*\>"
+
+hi def link     goDecimalInt        Integer
+hi def link     goHexadecimalInt    Integer
+hi def link     goOctalInt          Integer
+hi def link     Integer             Number
+
+" Floating point
+syn match       goFloat             "\<\d\+\.\d*\([Ee][-+]\d\+\)\?\>"
+syn match       goFloat             "\<\.\d\+\([Ee][-+]\d\+\)\?\>"
+syn match       goFloat             "\<\d\+[Ee][-+]\d\+\>"
+
+hi def link     goFloat             Float
+
+" Imaginary literals
+syn match       goImaginary         "\<\d\+i\>"
+syn match       goImaginary         "\<\d\+\.\d*\([Ee][-+]\d\+\)\?i\>"
+syn match       goImaginary         "\<\.\d\+\([Ee][-+]\d\+\)\?i\>"
+syn match       goImaginary         "\<\d\+[Ee][-+]\d\+i\>"
+
+hi def link     goImaginary         Number
+
+" Spaces after "[]"
+if go_highlight_array_whitespace_error != 0
+  syn match goSpaceError display "\(\[\]\)\@<=\s\+"
+endif
+
+" Spacing errors around the 'chan' keyword
+if go_highlight_chan_whitespace_error != 0
+  " receive-only annotation on chan type
+  syn match goSpaceError display "\(<-\)\@<=\s\+\(chan\>\)\@="
+  " send-only annotation on chan type
+  syn match goSpaceError display "\(\<chan\)\@<=\s\+\(<-\)\@="
+  " value-ignoring receives in a few contexts
+  syn match goSpaceError display "\(\(^\|[={(,;]\)\s*<-\)\@<=\s\+"
+endif
+
+" Extra types commonly seen
+if go_highlight_extra_types != 0
+  syn match goExtraType /\<bytes\.\(Buffer\)\>/
+  syn match goExtraType /\<io\.\(Reader\|Writer\|ReadWriter\|ReadWriteCloser\)\>/
+  syn match goExtraType /\<reflect\.\(Kind\|Type\|Value\)\>/
+  syn match goExtraType /\<unsafe\.Pointer\>/
+endif
+
+" Space-tab error
+if go_highlight_space_tab_error != 0
+  syn match goSpaceError display " \+\t"me=e-1
+endif
+
+" Trailing white space error
+if go_highlight_trailing_whitespace_error != 0
+  syn match goSpaceError display excludenl "\s\+$"
+endif
+
+hi def link     goExtraType         Type
+hi def link     goSpaceError        Error
+
+" Search backwards for a global declaration to start processing the syntax.
+"syn sync match goSync grouphere NONE /^\(const\|var\|type\|func\)\>/
+
+" There's a bug in the implementation of grouphere. For now, use the
+" following as a more expensive/less precise workaround.
+syn sync minlines=500
+
+let b:current_syntax = 'go'
+
+" vim: sw=2 sts=2 et
diff -Naur vim74.orig/runtime/syntax/godoc.vim vim74/runtime/syntax/godoc.vim
--- vim74.orig/runtime/syntax/godoc.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/godoc.vim	2014-10-10 14:53:42.638718169 +0000
@@ -0,0 +1,21 @@
+" Vim syntax file
+" Language:	Godoc (generated documentation for go)
+" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
+" Last Change:	2014 Aug 16
+
+if exists('b:current_syntax')
+  finish
+endif
+
+syn case match
+syn match godocTitle "^\([A-Z][A-Z ]*\)$"
+
+command -nargs=+ HiLink hi def link <args>
+
+HiLink godocTitle Title
+
+delcommand HiLink
+
+let b:current_syntax = 'godoc'
+
+" vim: sw=2 sts=2 et
diff -Naur vim74.orig/runtime/syntax/help.vim vim74/runtime/syntax/help.vim
--- vim74.orig/runtime/syntax/help.vim	2013-07-07 11:27:18.000000000 +0000
+++ vim74/runtime/syntax/help.vim	2014-10-10 14:53:42.675384744 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:	Vim help file
 " Maintainer:	Bram Moolenaar (Bram@vim.org)
-" Last Change:	2013 Jul 07
+" Last Change:	2014 Feb 12
 
 " Quit when a (custom) syntax file was already loaded
 if exists("b:current_syntax")
@@ -40,11 +40,11 @@
 syn match helpNormal		"|.*====*|"
 syn match helpNormal		"|||"
 syn match helpNormal		":|vim:|"	" for :help modeline
-syn match helpVim		"Vim version [0-9.a-z]\+"
+syn match helpVim		"\<Vim version [0-9][0-9.a-z]*"
 syn match helpVim		"VIM REFERENCE.*"
 syn match helpOption		"'[a-z]\{2,\}'"
 syn match helpOption		"'t_..'"
-syn match helpCommand		"`[^` ]\+`"hs=s+1,he=e-1 contains=helpBacktick
+syn match helpCommand		"`[^` \t]\+`"hs=s+1,he=e-1 contains=helpBacktick
 syn match helpHeader		"\s*\zs.\{-}\ze\s\=\~$" nextgroup=helpIgnore
 syn match helpGraphic		".* \ze`$" nextgroup=helpIgnore
 if has("conceal")
@@ -153,7 +153,7 @@
 " Define the default highlighting.
 " Only used when an item doesn't have highlighting yet
 hi def link helpIgnore		Ignore
-hi def link helpHyperTextJump	Subtitle
+hi def link helpHyperTextJump	Identifier
 hi def link helpBar		Ignore
 hi def link helpBacktick	Ignore
 hi def link helpStar		Ignore
@@ -168,7 +168,6 @@
 hi def link helpNotVi		Special
 hi def link helpSpecial		Special
 hi def link helpNote		Todo
-hi def link Subtitle		Identifier
 
 hi def link helpComment		Comment
 hi def link helpConstant	Constant
diff -Naur vim74.orig/runtime/syntax/htmldjango.vim vim74/runtime/syntax/htmldjango.vim
--- vim74.orig/runtime/syntax/htmldjango.vim	2010-05-15 11:03:57.000000000 +0000
+++ vim74/runtime/syntax/htmldjango.vim	2014-10-10 14:53:42.692051368 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:	Django HTML template
 " Maintainer:	Dave Hodder <dmh@dmh.org.uk>
-" Last Change:	2007 Jan 26
+" Last Change:	2014 Jul 13
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -28,7 +28,7 @@
 
 syn region djangoTagBlock start="{%" end="%}" contains=djangoStatement,djangoFilter,djangoArgument,djangoTagError display containedin=ALLBUT,@djangoBlocks
 syn region djangoVarBlock start="{{" end="}}" contains=djangoFilter,djangoArgument,djangoVarError display containedin=ALLBUT,@djangoBlocks
-syn region djangoComment start="{%\s*comment\s*%}" end="{%\s*endcomment\s*%}" contains=djangoTodo containedin=ALLBUT,@djangoBlocks
+syn region djangoComment start="{%\s*comment\(\s\+.\{-}\)\?%}" end="{%\s*endcomment\s*%}" contains=djangoTodo containedin=ALLBUT,@djangoBlocks
 syn region djangoComBlock start="{#" end="#}" contains=djangoTodo containedin=ALLBUT,@djangoBlocks
 
 let b:current_syntax = "htmldjango"
diff -Naur vim74.orig/runtime/syntax/j.vim vim74/runtime/syntax/j.vim
--- vim74.orig/runtime/syntax/j.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/j.vim	2014-10-10 14:53:42.735384593 +0000
@@ -0,0 +1,140 @@
+" Vim syntax file
+" Language:	J
+" Maintainer:	David Brgin <676c7473@gmail.com>
+" URL:		https://github.com/glts/vim-j
+" Last Change:	2014-05-25
+
+if exists('b:current_syntax')
+  finish
+endif
+
+let s:save_cpo = &cpo
+set cpo&vim
+
+syntax case match
+syntax sync minlines=50
+
+syntax cluster jStdlibItems contains=jStdlibNoun,jStdlibAdverb,jStdlibConjunction,jStdlibVerb
+syntax cluster jPrimitiveItems contains=jNoun,jAdverb,jConjunction,jVerb,jCopula
+
+syntax match jControl /\<\%(assert\|break\|case\|catch[dt]\=\|continue\|do\|else\%(if\)\=\|end\|fcase\|for\|if\|return\|select\|throw\|try\|whil\%(e\|st\)\)\./
+syntax match jControl /\<\%(for\|goto\|label\)_\a\k*\./
+
+" Standard library names. A few names need to be defined with ":syntax match"
+" because they would otherwise take precedence over the corresponding jControl
+" and jDefineExpression items.
+syntax keyword jStdlibNoun ARGV BINPATH CR CRLF DEL Debug EAV EMPTY FF FHS IF64 IFIOS IFJCDROID IFJHS IFQT IFRASPI IFUNIX IFWIN IFWINCE IFWINE IFWOW64 JB01 JBOXED JCHAR JCMPX JFL JINT JPTR JSIZES JSTR JTYPES JVERSION LF LF2 TAB UNAME UNXLIB andurl dbhelp libjqt
+syntax keyword jStdlibAdverb define each every fapplylines inv inverse items leaf rows table
+syntax keyword jStdlibConjunction bind cuts def on
+syntax keyword jStdlibVerb AND Endian IFDEF Note OR XOR alpha17 alpha27 anddf android_exec_host andunzip apply boxopen boxxopen bx calendar cd cdcb cder cderx cdf charsub chopstring clear coclass cocreate cocurrent codestroy coerase cofind cofindv cofullname coinfo coinsert coname conames conew conl conouns conounsx copath copathnl copathnlx coreset costate cut cutLF cutopen cutpara datatype dbctx dberm dberr dbg dbjmp dblocals dblxq dblxs dbnxt dbq dbr dbret dbrr dbrrx dbrun dbs dbsig dbsq dbss dbst dbstack dbstk dbstop dbstopme dbstopnext dbstops dbtrace dbview deb debc delstring detab dfh dir dircompare dircompares dirfind dirpath dirss dirssrplc dirtree dirused dlb dltb dltbs dquote drop dropafter dropto dtb dtbs echo empty endian erase evtloop exit expand f2utf8 fappend fappends fboxname fc fcopynew fdir ferase fetch fexist fexists fgets file2url fixdotdot fliprgb fmakex foldpara foldtext fpathcreate fpathname fputs fread freadblock freadr freads frename freplace fsize fss fssrplc fstamp fstringreplace ftype fview fwrite fwritenew fwrites getargs getdate getenv getqtbin hfd hostpathsep ic install iospath isatty isotimestamp isutf8 jcwdpath joinstring jpathsep jsystemdefs list ljust load loadd mema memf memr memw nameclass namelist names nc nl pick quote require rjust rplc script scriptd setbreak show sign sminfo smoutput sort split splitnostring splitstring ss startupandroid startupconsole startupide stderr stdin stdout stringreplace symdat symget symset take takeafter taketo timespacex timestamp timex tmoutput toCRLF toHOST toJ todate todayno tolower topara toupper tsdiff tsrep tstamp type ucp ucpcount unxlib usleep utf8 uucp valdate wcsize weekday weeknumber weeksinyear winpathsep
+syntax match jStdlibNoun /\<\%(adverb\|conjunction\|dyad\|monad\|noun\|verb\)\>/
+syntax match jStdlibVerb /\<\%(assert\|break\|do\)\>\.\@!/
+
+" Numbers. Matching J numbers is difficult. The regular expression used for
+" the general case roughly embodies this grammar sketch:
+"
+"     BASE     := /_?\d+(\.\d*)?([eE]_?\d+)?/
+"     RATIONAL := BASE  |  BASE r BASE
+"     COMPLEX  := BASE  |  BASE (j|a[dr]) BASE
+"     JNUMBER  := RATIONAL  |  RATIONAL [px] RATIONAL  |  COMPLEX  |  COMPLEX [px] COMPLEX
+"
+" The grammar is implemented as shown in this pseudo-regexp:
+"
+"        base         rational                       complex                       remainder
+"     /\< B  (  [r]B ([px]B([r]B)?)?  |  (j|a[dr])B ([px]B((j|a[dr])B)?)?  |  [px]B ((j|a[dr]|r)B)?  )?/
+"
+" All in all, a compromise between correctness and practicality had to be
+" made. See http://www.jsoftware.com/help/dictionary/dcons.htm for reference.
+syntax match jNumber /\<_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\%(\%(r_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\%([px]_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\%(r_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\)\=\)\=\)\|\%(\%(j\|a[dr]\)_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\%([px]_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\%(\%(j\|a[dr]\)_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\)\=\)\=\)\|\%([px]_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\%(\%(j\|a[dr]\|r\)_\=\d\+\%(\.\d*\)\=\%([eE]_\=\d\+\)\=\)\=\)\)\=/
+syntax match jNumber /\<_\=\d\+\%([eE]\d\+\)\=b_\=[0-9a-z]\+\%(\.[0-9a-z]\+\)\=/
+syntax match jNumber /\<__\=\>/
+syntax match jNumber /\<_\./
+syntax match jNumber /\<_\=\d\+x\>/
+
+syntax region jString oneline start=/'/ skip=/''/ end=/'/
+
+syntax keyword jArgument contained x y u v m n
+
+" Primitives. Order is significant both within the patterns and among
+" ":syntax match" statements. Refer to "Parts of speech" in the J dictionary.
+syntax match jNoun /\<a[.:]/
+syntax match jAdverb /[}~]\|[/\\]\.\=\|\<\%([Mbft]\.\|t:\)/
+syntax match jConjunction /"\|`:\=\|[.:@&][.:]\=\|&\.:\|\<\%([dDHT]\.\|[DLS]:\)/
+syntax match jVerb /[=!\]]\|[\^?]\.\=\|[;[]:\=\|{\.\|[_/\\]:\|[<>+*\-%$|,#][.:]\=\|[~}"][.:]\|{\%[::]\|\<\%([ACeEiIjLor]\.\|p\.\.\=\|[ipqsux]:\|0:\|_\=[1-9]:\)/
+syntax match jCopula /=[.:]/
+syntax match jConjunction /;\.\|\^:\|![.:]/
+
+" Explicit noun definition. The difficulty is that the define expression can
+" occur in the middle of a line but the jNounDefine region must only start on
+" the next line. The trick is to split the problem into two regions and link
+" them with "nextgroup=". The fold wrapper provides syntax folding.
+syntax region jNounDefineFold
+    \ matchgroup=NONE start=/\<\%(\%(0\|noun\)\s\+\%(\:\s*0\|def\s\+0\|define\)\>\)\@=/
+    \ keepend matchgroup=NONE end=/^\s*)\s*$/
+    \ contains=jNounDefineStart
+    \ fold
+syntax region jNounDefineStart
+    \ matchgroup=jDefineExpression start=/\<\%(0\|noun\)\s\+\%(\:\s*0\|def\s\+0\|define\)\>/
+    \ keepend matchgroup=NONE end=/$/
+    \ contains=@jStdlibItems,@jPrimitiveItems,jNumber,jString,jParenGroup,jParen,jComment
+    \ contained oneline skipempty nextgroup=jDefineEnd,jNounDefine
+" These two items must have "contained", which allows them to match only after
+" jNounDefineStart thanks to the "nextgroup=" above.
+syntax region jNounDefine
+    \ matchgroup=NONE start=/^/
+    \ matchgroup=jDefineEnd end=/^\s*)\s*$/
+    \ contained
+" This match is necessary in case of an empty noun definition
+syntax match jDefineEnd contained /^\s*)\s*$/
+
+" Explicit verb, adverb, and conjunction definition
+syntax region jDefine
+    \ matchgroup=jDefineExpression start=/\<\%([1-4]\|13\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\>/
+    \ matchgroup=jDefineEnd end=/^\s*)\s*$/
+    \ contains=jControl,@jStdlibItems,@jPrimitiveItems,jNumber,jString,jArgument,jParenGroup,jParen,jComment,jDefineMonadDyad
+    \ fold
+syntax match jDefineMonadDyad contained /^\s*:\s*$/
+
+" Paired parentheses. When a jDefineExpression such as "3 : 0" is
+" parenthesised it will erroneously extend jParenGroup to span over the whole
+" definition body. This situation receives a special treatment here.
+syntax match jParen /(\%(\s*\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\s*)\)\@=/
+syntax match jParen contained /\%((\s*\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\s*\)\@<=)/
+syntax region jParenGroup
+    \ matchgroup=jParen start=/(\%(\s*\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\>\)\@!/
+    \ matchgroup=jParen end=/)/
+    \ oneline transparent
+
+syntax keyword jTodo contained TODO FIXME XXX
+syntax match jComment /NB\..*$/ contains=jTodo,@Spell
+
+syntax match jSharpBang /\%^#!.*$/
+
+highlight default link jControl           Statement
+highlight default link jStdlibNoun        Identifier
+highlight default link jStdlibAdverb      Function
+highlight default link jStdlibConjunction Function
+highlight default link jStdlibVerb        Function
+highlight default link jString            String
+highlight default link jNumber            Number
+highlight default link jNoun              Constant
+highlight default link jAdverb            Normal
+highlight default link jConjunction       Normal
+highlight default link jVerb              Normal
+highlight default link jCopula            Normal
+highlight default link jArgument          Identifier
+highlight default link jParen             Delimiter
+
+highlight default link jDefineExpression  Define
+highlight default link jDefineMonadDyad   Delimiter
+highlight default link jDefineEnd         Delimiter
+highlight default link jNounDefine        Normal
+
+highlight default link jTodo              Todo
+highlight default link jComment           Comment
+highlight default link jSharpBang         PreProc
+
+let b:current_syntax = 'j'
+
+let &cpo = s:save_cpo
+unlet s:save_cpo
diff -Naur vim74.orig/runtime/syntax/json.vim vim74/runtime/syntax/json.vim
--- vim74.orig/runtime/syntax/json.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/json.vim	2014-10-10 14:53:42.755384543 +0000
@@ -0,0 +1,143 @@
+" Vim syntax file
+" Language:	JSON
+" Maintainer:	Eli Parra <eli@elzr.com>
+" Last Change:	2014 Aug 23
+" Version:      0.12
+
+if !exists("main_syntax")
+  if version < 600
+    syntax clear
+  elseif exists("b:current_syntax")
+    finish
+  endif
+  let main_syntax = 'json'
+endif
+
+syntax match   jsonNoise           /\%(:\|,\)/
+
+" NOTE that for the concealing to work your conceallevel should be set to 2
+
+" Syntax: Strings
+" Separated into a match and region because a region by itself is always greedy
+syn match  jsonStringMatch /"\([^"]\|\\\"\)\+"\ze[[:blank:]\r\n]*[,}\]]/ contains=jsonString
+if has('conceal')
+	syn region  jsonString oneline matchgroup=jsonQuote start=/"/  skip=/\\\\\|\\"/  end=/"/ concealends contains=jsonEscape contained
+else
+	syn region  jsonString oneline matchgroup=jsonQuote start=/"/  skip=/\\\\\|\\"/  end=/"/ contains=jsonEscape contained
+endif
+
+" Syntax: JSON does not allow strings with single quotes, unlike JavaScript.
+syn region  jsonStringSQError oneline  start=+'+  skip=+\\\\\|\\"+  end=+'+
+
+" Syntax: JSON Keywords
+" Separated into a match and region because a region by itself is always greedy
+syn match  jsonKeywordMatch /"\([^"]\|\\\"\)\+"[[:blank:]\r\n]*\:/ contains=jsonKeyword
+if has('conceal')
+   syn region  jsonKeyword matchgroup=jsonQuote start=/"/  end=/"\ze[[:blank:]\r\n]*\:/ concealends contained
+else
+   syn region  jsonKeyword matchgroup=jsonQuote start=/"/  end=/"\ze[[:blank:]\r\n]*\:/ contained
+endif
+
+" Syntax: Escape sequences
+syn match   jsonEscape    "\\["\\/bfnrt]" contained
+syn match   jsonEscape    "\\u\x\{4}" contained
+
+" Syntax: Numbers
+syn match   jsonNumber    "-\=\<\%(0\|[1-9]\d*\)\%(\.\d\+\)\=\%([eE][-+]\=\d\+\)\=\>\ze[[:blank:]\r\n]*[,}\]]"
+
+" ERROR WARNINGS **********************************************
+if (!exists("g:vim_json_warnings") || g:vim_json_warnings==1)
+	" Syntax: Strings should always be enclosed with quotes.
+	syn match   jsonNoQuotesError  "\<[[:alpha:]][[:alnum:]]*\>"
+	syn match   jsonTripleQuotesError  /"""/
+
+	" Syntax: An integer part of 0 followed by other digits is not allowed.
+	syn match   jsonNumError  "-\=\<0\d\.\d*\>"
+
+	" Syntax: Decimals smaller than one should begin with 0 (so .1 should be 0.1).
+	syn match   jsonNumError  "\:\@<=[[:blank:]\r\n]*\zs\.\d\+"
+
+	" Syntax: No comments in JSON, see http://stackoverflow.com/questions/244777/can-i-comment-a-json-file
+	syn match   jsonCommentError  "//.*"
+	syn match   jsonCommentError  "\(/\*\)\|\(\*/\)"
+
+	" Syntax: No semicolons in JSON
+	syn match   jsonSemicolonError  ";"
+
+	" Syntax: No trailing comma after the last element of arrays or objects
+	syn match   jsonTrailingCommaError  ",\_s*[}\]]"
+
+	" Syntax: Watch out for missing commas between elements
+	syn match   jsonMissingCommaError /\("\|\]\|\d\)\zs\_s\+\ze"/
+	syn match   jsonMissingCommaError /\(\]\|\}\)\_s\+\ze"/ "arrays/objects as values
+	syn match   jsonMissingCommaError /}\_s\+\ze{/ "objects as elements in an array
+	syn match   jsonMissingCommaError /\(true\|false\)\_s\+\ze"/ "true/false as value
+endif
+
+" ********************************************** END OF ERROR WARNINGS
+" Allowances for JSONP: function call at the beginning of the file,
+" parenthesis and semicolon at the end.
+" Function name validation based on
+" http://stackoverflow.com/questions/2008279/validate-a-javascript-function-name/2008444#2008444
+syn match  jsonPadding "\%^[[:blank:]\r\n]*[_$[:alpha:]][_$[:alnum:]]*[[:blank:]\r\n]*("
+syn match  jsonPadding ");[[:blank:]\r\n]*\%$"
+
+" Syntax: Boolean
+syn match  jsonBoolean /\(true\|false\)\(\_s\+\ze"\)\@!/
+
+" Syntax: Null
+syn keyword  jsonNull      null
+
+" Syntax: Braces
+syn region  jsonFold matchgroup=jsonBraces start="{" end=/}\(\_s\+\ze\("\|{\)\)\@!/ transparent fold
+syn region  jsonFold matchgroup=jsonBraces start="\[" end=/]\(\_s\+\ze"\)\@!/ transparent fold
+
+" Define the default highlighting.
+" For version 5.7 and earlier: only when not done already
+" For version 5.8 and later: only when an item doesn't have highlighting yet
+if version >= 508 || !exists("did_json_syn_inits")
+  if version < 508
+    let did_json_syn_inits = 1
+    command -nargs=+ HiLink hi link <args>
+  else
+    command -nargs=+ HiLink hi def link <args>
+  endif
+  HiLink jsonPadding         Operator
+  HiLink jsonString          String
+  HiLink jsonTest          Label
+  HiLink jsonEscape          Special
+  HiLink jsonNumber          Number
+  HiLink jsonBraces          Delimiter
+  HiLink jsonNull            Function
+  HiLink jsonBoolean         Boolean
+  HiLink jsonKeyword         Label
+
+	if (!exists("g:vim_json_warnings") || g:vim_json_warnings==1)
+	  HiLink jsonNumError        Error
+	  HiLink jsonCommentError    Error
+	  HiLink jsonSemicolonError  Error
+	  HiLink jsonTrailingCommaError     Error
+	  HiLink jsonMissingCommaError      Error
+	  HiLink jsonStringSQError        	Error
+	  HiLink jsonNoQuotesError        	Error
+	  HiLink jsonTripleQuotesError     	Error
+  endif
+  HiLink jsonQuote           Quote
+  HiLink jsonNoise           Noise
+  delcommand HiLink
+endif
+
+let b:current_syntax = "json"
+if main_syntax == 'json'
+  unlet main_syntax
+endif
+
+" Vim settings
+" vim: ts=8 fdm=marker
+
+" MIT License
+" Copyright (c) 2013, Jeroen Ruigrok van der Werven, Eli Parra
+"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+"THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+"See https://twitter.com/elzr/status/294964017926119424
diff -Naur vim74.orig/runtime/syntax/kivy.vim vim74/runtime/syntax/kivy.vim
--- vim74.orig/runtime/syntax/kivy.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/kivy.vim	2014-10-10 14:53:42.758717867 +0000
@@ -0,0 +1,36 @@
+" Vim syntax file
+" Language:    Kivy
+" Maintainer:  Corey Prophitt <prophitt.corey@gmail.com>
+" Last Change: May 29th, 2014
+" Version:     1
+" URL:         http://kivy.org/
+
+if exists("b:current_syntax")
+    finish
+endif
+
+" Load Python syntax first (Python can be used within Kivy)
+syn include @pyth $VIMRUNTIME/syntax/python.vim
+
+" Kivy language rules can be found here
+"   http://kivy.org/docs/guide/lang.html
+
+" Define Kivy syntax
+syn match kivyPreProc   /#:.*/
+syn match kivyComment   /#.*/
+syn match kivyRule      /<\I\i*\(,\s*\I\i*\)*>:/
+syn match kivyAttribute /\<\I\i*\>/ nextgroup=kivyValue
+
+syn region kivyValue start=":" end=/$/  contains=@pyth skipwhite
+
+syn region kivyAttribute matchgroup=kivyIdent start=/[\a_][\a\d_]*:/ end=/$/ contains=@pyth skipwhite
+
+hi def link kivyPreproc   PreProc
+hi def link kivyComment   Comment
+hi def link kivyRule      Function
+hi def link kivyIdent     Statement
+hi def link kivyAttribute Label
+
+let b:current_syntax = "kivy"
+
+" vim: ts=8
diff -Naur vim74.orig/runtime/syntax/mail.vim vim74/runtime/syntax/mail.vim
--- vim74.orig/runtime/syntax/mail.vim	2013-07-15 21:28:26.000000000 +0000
+++ vim74/runtime/syntax/mail.vim	2014-10-10 14:53:42.825384367 +0000
@@ -2,7 +2,7 @@
 " Language:		Mail file
 " Previous Maintainer:	Felix von Leitner <leitner@math.fu-berlin.de>
 " Maintainer:		GI <a@b.c>, where a='gi1242+vim', b='gmail', c='com'
-" Last Change:		Thu 02 Feb 2012 08:47:04 PM EST
+" Last Change:		Wed 14 Aug 2013 08:24:52 AM PDT
 
 " Quit when a syntax file was already loaded
 if exists("b:current_syntax")
@@ -55,7 +55,7 @@
 
 " Treat verbatim Text special.
 syn region	mailVerbatim	contains=@NoSpell keepend start="^#v+$" end="^#v-$" fold 
-syn region	mailVerbatim	contains=@mailQuoteExps,@NoSpell start="^\z(\(> \?\)\+\)#v+$" end="\z1#v-$" fold 
+syn region	mailVerbatim	contains=@mailQuoteExps,@NoSpell keepend start="^\z(\(> \?\)\+\)#v+$" end="\z1#v-$" fold 
 
 " URLs start with a known protocol or www,web,w3.
 syn match mailURL contains=@NoSpell `\v<(((https?|ftp|gopher)://|(mailto|file|news):)[^' 	<>"]+|(www|web|w3)[a-z0-9_-]*\.[a-z0-9._-]+\.[^' 	<>"]+)[a-z0-9/]`
diff -Naur vim74.orig/runtime/syntax/masm.vim vim74/runtime/syntax/masm.vim
--- vim74.orig/runtime/syntax/masm.vim	2012-02-04 19:24:10.000000000 +0000
+++ vim74/runtime/syntax/masm.vim	2014-10-10 14:53:42.842050991 +0000
@@ -2,14 +2,11 @@
 " Language:	Microsoft Macro Assembler (80x86)
 " Orig Author:	Rob Brady <robb@datatone.com>
 " Maintainer:	Wu Yongwei <wuyongwei@gmail.com>
-" Last Change:	$Date: 2012/02/04 12:45:39 $
-" $Revision: 1.46 $
+" Last Change:	$Date: 2013/11/13 11:49:24 $
+" $Revision: 1.48 $
 
-" For version 5.x: Clear all syntax items
-" For version 6.x: Quit when a syntax file was already loaded
-if version < 600
-  syntax clear
-elseif exists("b:current_syntax")
+" Quit when a syntax file was already loaded
+if exists("b:current_syntax")
   finish
 endif
 
@@ -194,6 +191,10 @@
 syn keyword masmRegister	R8W R9W R10W R11W R12W R13W R14W R15W
 syn keyword masmRegister	R8B R9B R10B R11B R12B R13B R14B R15B
 
+" SSE/AVX registers
+syn match   masmRegister	"\(X\|Y\)MM[0-9]\>"
+syn match   masmRegister	"\(X\|Y\)MM1[0-5]\>"
+
 " Instruction prefixes
 syn keyword masmOpcode		LOCK REP REPE REPNE REPNZ REPZ
 
@@ -302,50 +303,69 @@
 syn keyword masmOpcode		HADDPS HSUBPS HADDPD HSUBPD
 syn keyword masmOpcode		MOVSHDUP MOVSLDUP MOVDDUP MONITOR MWAIT
 
+" SSSE3 opcodes (Core and later)
+syn keyword masmOpcode		PSIGNB PSIGNW PSIGND PABSB PABSW PABSD
+syn keyword masmOpcode		PALIGNR PSHUFB PMULHRSW PMADDUBSW
+syn keyword masmOpcode		PHSUBW PHSUBD PHSUBSW PHADDW PHADDD PHADDSW
+
+" SSE 4.1 opcodes (Penryn and later)
+syn keyword masmOpcode		MPSADBW PHMINPOSUW PMULDQ PMULLD DPPS DPPD
+syn keyword masmOpcode		BLENDPS BLENDPD BLENDVPS BLENDVPD
+syn keyword masmOpcode		PBLENDVB PBLENDW
+syn keyword masmOpcode		PMINSB PMAXSB PMINSD PMAXSD
+syn keyword masmOpcode		PMINUW PMAXUW PMINUD PMAXUD
+syn keyword masmOpcode		ROUNDPS ROUNDSS ROUNDPD ROUNDSD
+syn keyword masmOpcode		INSERTPS PINSRB PINSRD PINSRQ
+syn keyword masmOpcode		EXTRACTPS PEXTRB PEXTRD PEXTRQ
+syn keyword masmOpcode		PMOVSXBW PMOVZXBW PMOVSXBD PMOVZXBD
+syn keyword masmOpcode		PMOVSXBQ PMOVZXBQ PMOVSXWD PMOVZXWD
+syn keyword masmOpcode		PMOVSXWQ PMOVZXWQ PMOVSXDQ PMOVZXDQ
+syn keyword masmOpcode		PTEST PCMPEQQ PACKUSDW MOVNTDQA
+
+" SSE 4.2 opcodes (Nehalem and later)
+syn keyword masmOpcode		PCMPESTRI PCMPESTRM PCMPISTRI PCMPISTRM PCMPGTQ
+syn keyword masmOpcode		CRC32 POPCNT LZCNT
+
+" AES-NI (Westmere (2010) and later)
+syn keyword masmOpcode		AESENC AESENCLAST AESDEC AESDECLAST
+syn keyword masmOpcode		AESKEYGENASSIST AESIMC PCLMULQDQ
+
+" AVX (Sandy Bridge (2011) and later)
+syn keyword masmOpcode		VBROADCASTSS VBROADCASTSD VBROADCASTF128
+syn keyword masmOpcode		VINSERTF128 VEXTRACTF128 VMASKMOVPS VMASKMOVPD
+syn keyword masmOpcode		VPERMILPS VPERMILPD VPERM2F128
+syn keyword masmOpcode		VZEROALL VZEROUPPER
+
 " Other opcodes in Pentium and later processors
 syn keyword masmOpcode		CMPXCHG8B CPUID UD2
 syn keyword masmOpcode		RSM RDMSR WRMSR RDPMC RDTSC SYSENTER SYSEXIT
 syn match   masmOpcode	   "CMOV\(P[EO]\|\(N\?\([ABGL]E\?\|[CEOPSZ]\)\)\)\>"
 
 
-" Define the default highlighting.
-" For version 5.7 and earlier: only when not done already
-" For version 5.8 and later: only when an item doesn't have highlighting yet
-if version >= 508 || !exists("did_masm_syntax_inits")
-  if version < 508
-    let did_masm_syntax_inits = 1
-    command -nargs=+ HiLink hi link <args>
-  else
-    command -nargs=+ HiLink hi def link <args>
-  endif
-
-  " The default methods for highlighting.  Can be overridden later
-  HiLink masmLabel	PreProc
-  HiLink masmComment	Comment
-  HiLink masmDirective	Statement
-  HiLink masmType	Type
-  HiLink masmOperator	Type
-  HiLink masmOption	Special
-  HiLink masmRegister	Special
-  HiLink masmString	String
-  HiLink masmText	String
-  HiLink masmTitle	Title
-  HiLink masmOpcode	Statement
-  HiLink masmOpFloat	Statement
-
-  HiLink masmHexadecimal Number
-  HiLink masmDecimal	Number
-  HiLink masmOctal	Number
-  HiLink masmBinary	Number
-  HiLink masmFloatRaw	Number
-  HiLink masmFloat	Number
+" The default highlighting
+hi def link masmLabel		PreProc
+hi def link masmComment		Comment
+hi def link masmDirective	Statement
+hi def link masmType		Type
+hi def link masmOperator	Type
+hi def link masmOption		Special
+hi def link masmRegister	Special
+hi def link masmString		String
+hi def link masmText		String
+hi def link masmTitle		Title
+hi def link masmOpcode		Statement
+hi def link masmOpFloat		Statement
+
+hi def link masmHexadecimal	Number
+hi def link masmDecimal		Number
+hi def link masmOctal		Number
+hi def link masmBinary		Number
+hi def link masmFloatRaw	Number
+hi def link masmFloat		Number
 
-  HiLink masmIdentifier Identifier
+hi def link masmIdentifier	Identifier
 
-  syntax sync minlines=50
-
-  delcommand HiLink
-endif
+syntax sync minlines=50
 
 let b:current_syntax = "masm"
 
diff -Naur vim74.orig/runtime/syntax/mix.vim vim74/runtime/syntax/mix.vim
--- vim74.orig/runtime/syntax/mix.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/mix.vim	2014-10-10 14:53:42.862050941 +0000
@@ -0,0 +1,83 @@
+" Vim syntax file
+" Language:	MIX (Donald Knuth's assembly language used in TAOCP)
+" Maintainer:	Wu Yongwei <wuyongwei@gmail.com>
+" Filenames:	*.mixal *.mix
+" Last Change:  2013 Nov 13
+
+" Quit when a syntax file was already loaded
+if exists("b:current_syntax")
+  finish
+endif
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+syn case ignore
+
+" Special processing of ALF directive: implementations vary whether quotation
+" marks are needed
+syn match mixAlfParam		#\s\{1,2\}"\?[^"]\{,5\}"\?# contains=mixAlfDirective,mixString nextgroup=mixEndComment contained
+
+" Region for parameters
+syn match mixParam		#[-+*/:=0-9a-z,()"]\+# contains=mixIdentifier,mixSpecial,mixNumber,mixString,mixLabel nextgroup=mixEndComment contained
+
+" Comment at the line end
+syn match mixEndComment		".*" contains=mixRegister contained
+
+" Identifier; must go before literals
+syn match mixIdentifier		"[a-z0-9_]\+" contained
+
+" Literals
+syn match mixSpecial		"[-+*/:=]" contained
+syn match mixNumber		"[0-9]\+\>" contained
+syn region mixString		start=+"+ skip=+\\"+ end=+"+ contained
+
+" Labels
+syn match mixLabel		"^[a-z0-9_]\{,10\}\s\+" nextgroup=mixAlfSpecial,mixOpcode,mixDirective
+syn match mixLabel		"[0-9][BF]" contained
+
+" Comments
+syn match mixComment		"^\*.*" contains=mixRegister
+
+" Directives
+syn keyword mixDirective 	ORIG EQU CON END nextgroup=mixParam contained skipwhite
+syn keyword mixDirective 	ALF nextgroup=mixAlfParam contained
+
+" Opcodes
+syn keyword mixOpcode	NOP HLT NUM CHAR FLOT FIX nextgroup=mixEndComment contained
+syn keyword mixOpcode	FADD FSUB FMUL FDIV FCMP MOVE ADD SUB MUL DIV IOC IN OUT JRED JBUS JMP JSJ JOV JNOV JL JE JG JLE JNE JGE SLA SRA SLAX SRAX SLC SRC nextgroup=mixParam contained skipwhite
+
+syn match mixOpcode	"LD[AX1-6]N\?\>" nextgroup=mixParam contained skipwhite
+syn match mixOpcode	"ST[AX1-6JZ]\>" nextgroup=mixParam contained skipwhite
+syn match mixOpcode	"EN[TN][AX1-6]\>" nextgroup=mixParam contained skipwhite
+syn match mixOpcode	"INC[AX1-6]\>" nextgroup=mixParam contained skipwhite
+syn match mixOpcode	"DEC[AX1-6]\>" nextgroup=mixParam contained skipwhite
+syn match mixOpcode	"CMP[AX1-6]\>" nextgroup=mixParam contained skipwhite
+syn match mixOpcode	"J[AX1-6]N\?[NZP]\>" nextgroup=mixParam contained skipwhite
+
+" Switch back to being case sensitive
+syn case match
+
+" Registers (only to used in comments now)
+syn keyword mixRegister	rA rX rI1 rI2 rI3 rI4 rI5 rI6 rJ contained
+
+" The default highlighting
+hi def link mixRegister		Special
+hi def link mixLabel		Define
+hi def link mixComment		Comment
+hi def link mixEndComment	Comment
+hi def link mixDirective	Keyword
+hi def link mixOpcode		Keyword
+
+hi def link mixSpecial		Special
+hi def link mixNumber		Number
+hi def link mixString		String
+hi def link mixAlfParam		String
+hi def link mixIdentifier	Identifier
+
+let b:current_syntax = "mix"
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim: ts=8
diff -Naur vim74.orig/runtime/syntax/netrw.vim vim74/runtime/syntax/netrw.vim
--- vim74.orig/runtime/syntax/netrw.vim	2013-02-25 17:23:59.000000000 +0000
+++ vim74/runtime/syntax/netrw.vim	2014-10-10 14:53:42.918717465 +0000
@@ -1,7 +1,7 @@
 " Language   : Netrw Remote-Directory Listing Syntax
 " Maintainer : Charles E. Campbell, Jr.
-" Last change: Dec 18, 2012
-" Version    : 17
+" Last change: Mar 07, 2014
+" Version    : 18
 " ---------------------------------------------------------------------
 
 " Syntax Clearing: {{{1
@@ -19,11 +19,12 @@
 syn match  netrwPlain		"\(\S\+ \)*\S\+"					contains=@NoSpell
 syn match  netrwSpecial		"\%(\S\+ \)*\S\+[*|=]\ze\%(\s\{2,}\|$\)"		contains=netrwClassify,@NoSpell
 syn match  netrwDir		"\.\{1,2}/"						contains=netrwClassify,@NoSpell
-syn match  netrwDir		"\%(\S\+ \)*\S\+/"					contains=netrwClassify,@NoSpell
+"syn match  netrwDir		"\%(\S\+ \)*\S\+/"					contains=netrwClassify,@NoSpell
+syn match  netrwDir		"\%(\S\+ \)*\S\+/\ze\%(\s\{2,}\|$\)"			contains=netrwClassify,@NoSpell
 syn match  netrwSizeDate	"\<\d\+\s\d\{1,2}/\d\{1,2}/\d\{4}\s"	skipwhite	contains=netrwDateSep,@NoSpell	nextgroup=netrwTime
 syn match  netrwSymLink		"\%(\S\+ \)*\S\+@\ze\%(\s\{2,}\|$\)"  			contains=netrwClassify,@NoSpell
 syn match  netrwExe		"\%(\S\+ \)*\S*[^~]\*\ze\%(\s\{2,}\|$\)" 		contains=netrwClassify,@NoSpell
-syn match  netrwTreeBar		"^\%([-+|] \)\+"					contains=netrwTreeBarSpace	nextgroup=@netrwTreeGroup
+syn match  netrwTreeBar		"^\%([-+|] \)\+"					contains=netrwTreeBarSpace	nextgroup=@netrwTreeGroup
 syn match  netrwTreeBarSpace	" "					contained
 
 syn match  netrwClassify	"[*=|@/]\ze\%(\s\{2,}\|$\)"		contained
@@ -41,8 +42,9 @@
 syn match  netrwCopyTgt		"Copy/Move Tgt:"		contained transparent skipwhite				nextgroup=netrwList
 syn match  netrwList		".*$"				contained		contains=netrwComma,@NoSpell
 syn match  netrwComma		","				contained
-syn region netrwQuickHelp	matchgroup=Comment start="Quick Help:\s\+" end="$"	contains=netrwHelpCmd,@NoSpell	keepend contained
-syn match  netrwHelpCmd		"\S\ze:"			contained skipwhite	contains=@NoSpell		nextgroup=netrwCmdSep
+syn region netrwQuickHelp	matchgroup=Comment start="Quick Help:\s\+" end="$"	contains=netrwHelpCmd,netrwQHTopic,@NoSpell	keepend contained
+syn match  netrwHelpCmd		"\S\+\ze:"			contained skipwhite	contains=@NoSpell		nextgroup=netrwCmdSep
+syn match  netrwQHTopic		"-\a\+-"			contained skipwhite
 syn match  netrwCmdSep		":"				contained nextgroup=netrwCmdNote
 syn match  netrwCmdNote		".\{-}\ze  "			contained		contains=@NoSpell
 syn match  netrwVersion		"(netrw.*)"			contained		contains=@NoSpell
@@ -79,6 +81,7 @@
  hi default link netrwComment	Comment
  hi default link netrwDir	Directory
  hi default link netrwHelpCmd	Function
+ hi default link netrwQHTopic	Number
  hi default link netrwHidePat	Statement
  hi default link netrwHideSep	netrwComment
  hi default link netrwList	Statement
diff -Naur vim74.orig/runtime/syntax/ninja.vim vim74/runtime/syntax/ninja.vim
--- vim74.orig/runtime/syntax/ninja.vim	2013-04-16 20:48:25.000000000 +0000
+++ vim74/runtime/syntax/ninja.vim	2014-10-10 14:53:42.918717465 +0000
@@ -1,10 +1,10 @@
 " ninja build file syntax.
 " Language: ninja build file as described at
 "           http://martine.github.com/ninja/manual.html
-" Version: 1.3
-" Last Change: 2013/04/16
+" Version: 1.4
+" Last Change: 2014/05/13
 " Maintainer: Nicolas Weber <nicolasweber@gmx.de>
-" Version 1.3 of this script is in the upstream vim repository and will be
+" Version 1.4 of this script is in the upstream vim repository and will be
 " included in the next vim release. If you change this, please send your change
 " upstream.
 
@@ -55,6 +55,7 @@
 " $simple_varname -> variable
 " ${varname} -> variable
 
+syn match   ninjaDollar "\$\$"
 syn match   ninjaWrapLineOperator "\$$"
 syn match   ninjaSimpleVar "\$[a-zA-Z0-9_-]\+"
 syn match   ninjaVar       "\${[a-zA-Z0-9_.-]\+}"
@@ -70,6 +71,7 @@
 hi def link ninjaKeyword Keyword
 hi def link ninjaRuleCommand Statement
 hi def link ninjaPoolCommand Statement
+hi def link ninjaDollar ninjaOperator
 hi def link ninjaWrapLineOperator ninjaOperator
 hi def link ninjaOperator Operator
 hi def link ninjaSimpleVar ninjaVar
diff -Naur vim74.orig/runtime/syntax/php.vim vim74/runtime/syntax/php.vim
--- vim74.orig/runtime/syntax/php.vim	2012-12-11 20:15:31.000000000 +0000
+++ vim74/runtime/syntax/php.vim	2014-10-10 14:53:42.968717340 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language: php PHP 3/4/5
 " Maintainer: Jason Woofenden <jason@jasonwoof.com>
-" Last Change: Dec 11, 2012
+" Last Change: Sep 18, 2014
 " URL: https://gitorious.org/jasonwoof/vim-syntax/blobs/master/php.vim
 " Former Maintainers: Peter Hodge <toomuchphp-vim@yahoo.com>
 "         Debian VIM Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
@@ -123,7 +123,11 @@
 syn keyword phpIntVar GLOBALS PHP_ERRMSG PHP_SELF HTTP_GET_VARS HTTP_POST_VARS HTTP_COOKIE_VARS HTTP_POST_FILES HTTP_ENV_VARS HTTP_SERVER_VARS HTTP_SESSION_VARS HTTP_RAW_POST_DATA HTTP_STATE_VARS _GET _POST _COOKIE _FILES _SERVER _ENV _SERVER _REQUEST _SESSION  contained
 
 " Constants
-syn keyword phpCoreConstant PHP_VERSION PHP_OS DEFAULT_INCLUDE_PATH PEAR_INSTALL_DIR PEAR_EXTENSION_DIR PHP_EXTENSION_DIR PHP_BINDIR PHP_LIBDIR PHP_DATADIR PHP_SYSCONFDIR PHP_LOCALSTATEDIR PHP_CONFIG_FILE_PATH PHP_OUTPUT_HANDLER_START PHP_OUTPUT_HANDLER_CONT PHP_OUTPUT_HANDLER_END E_ERROR E_WARNING E_PARSE E_NOTICE E_CORE_ERROR E_CORE_WARNING E_COMPILE_ERROR E_COMPILE_WARNING E_USER_ERROR E_USER_WARNING E_USER_NOTICE E_ALL  contained
+syn keyword phpCoreConstant PHP_VERSION PHP_OS DEFAULT_INCLUDE_PATH PEAR_INSTALL_DIR PEAR_EXTENSION_DIR PHP_EXTENSION_DIR PHP_BINDIR PHP_LIBDIR PHP_DATADIR PHP_SYSCONFDIR PHP_LOCALSTATEDIR PHP_CONFIG_FILE_PATH PHP_OUTPUT_HANDLER_START PHP_OUTPUT_HANDLER_CONT PHP_OUTPUT_HANDLER_END contained
+
+" Predefined constants
+" Generated by: curl -q http://php.net/manual/en/errorfunc.constants.php | grep -oP 'E_\w+' | sort -u
+syn keyword phpCoreConstant E_ALL E_COMPILE_ERROR E_COMPILE_WARNING E_CORE_ERROR E_CORE_WARNING E_DEPRECATED E_ERROR E_NOTICE E_PARSE E_RECOVERABLE_ERROR E_STRICT E_USER_DEPRECATED E_USER_ERROR E_USER_NOTICE E_USER_WARNING E_WARNING contained
 
 syn case ignore
 
@@ -502,11 +506,6 @@
 " Some of these changes (highlighting isset/unset/echo etc) are not so
 " critical, but they make things more colourful. :-)
 
-" highlight constant E_STRICT
-syntax case match
-syntax keyword phpCoreConstant E_STRICT contained
-syntax case ignore
-
 " different syntax highlighting for 'echo', 'print', 'switch', 'die' and 'list' keywords
 " to better indicate what they are.
 syntax keyword phpDefine echo print contained
@@ -616,6 +615,11 @@
   exec "syn sync fromstart"
 endif
 
+syntax match  phpDocCustomTags  "@[a-zA-Z]*\(\s\+\|\n\|\r\)" containedin=phpComment
+syntax region phpDocTags  start="{@\(example\|id\|internal\|inheritdoc\|link\|source\|toc\|tutorial\)" end="}" containedin=phpComment
+syntax match  phpDocTags  "@\(abstract\|access\|author\|category\|copyright\|deprecated\|example\|final\|global\|ignore\|internal\|license\|link\|method\|name\|package\|param\|property\|return\|see\|since\|static\|staticvar\|subpackage\|tutorial\|uses\|var\|version\|contributor\|modified\|filename\|description\|filesource\|throws\)\(\s\+\)\?" containedin=phpComment
+syntax match  phpDocTodo  "@\(todo\|fixme\|xxx\)\(\s\+\)\?" containedin=phpComment
+
 " Define the default highlighting.
 " For version 5.7 and earlier: only when not done already
 " For version 5.8 and later: only when an item doesn't have highlighting yet
@@ -630,6 +634,8 @@
   HiLink   phpConstant  Constant
   HiLink   phpCoreConstant  Constant
   HiLink   phpComment Comment
+  HiLink   phpDocTags PreProc
+  HiLink   phpDocCustomTags Type
   HiLink   phpException Exception
   HiLink   phpBoolean Boolean
   HiLink   phpStorageClass  StorageClass
@@ -668,6 +674,7 @@
   HiLink   phpInterpSimpleCurly Delimiter
   HiLink   phpInterpVarname Identifier
   HiLink   phpTodo  Todo
+  HiLink   phpDocTodo Todo
   HiLink   phpMemberSelector  Structure
   if exists("php_oldStyle")
   hi  phpIntVar guifg=Red ctermfg=DarkRed
diff -Naur vim74.orig/runtime/syntax/python.vim vim74/runtime/syntax/python.vim
--- vim74.orig/runtime/syntax/python.vim	2013-02-26 17:28:59.000000000 +0000
+++ vim74/runtime/syntax/python.vim	2014-10-10 14:53:43.028717189 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:	Python
 " Maintainer:	Neil Schemenauer <nas@python.ca>
-" Last Change:	2013 Feb 26
+" Last Change:	2014 Jul 16
 " Credits:	Zvezdan Petkovic <zpetkovic@acm.org>
 "		Neil Schemenauer <nas@python.ca>
 "		Dmitry Vasiliev
@@ -113,7 +113,7 @@
 syn match   pythonEscape	"\\x\x\{2}" contained
 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
 " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
-syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
+syn match   pythonEscape	"\\N{.\{-}}" contained
 syn match   pythonEscape	"\\$"
 
 if exists("python_highlight_all")
diff -Naur vim74.orig/runtime/syntax/r.vim vim74/runtime/syntax/r.vim
--- vim74.orig/runtime/syntax/r.vim	2013-06-01 21:00:21.000000000 +0000
+++ vim74/runtime/syntax/r.vim	2014-10-10 14:53:43.035383839 +0000
@@ -3,7 +3,7 @@
 " Maintainer:	      Jakson Aquino <jalvesaq@gmail.com>
 " Former Maintainers: Vaidotas Zemlys <zemlys@gmail.com>
 " 		      Tom Payne <tom@tompayne.org>
-" Last Change:	      Sun May 19, 2013  05:59PM
+" Last Change:	      Wed Jul 09, 2014  10:29PM
 " Filenames:	      *.R *.r *.Rhistory *.Rt
 " 
 " NOTE: The highlighting of R functions is defined in the
@@ -30,14 +30,16 @@
 syn case match
 
 " Comment
-syn match rComment contains=@Spell "#.*"
+syn match rCommentTodo contained "\(BUG\|FIXME\|NOTE\|TODO\):"
+syn match rComment contains=@Spell,rCommentTodo "#.*"
 
 " Roxygen
 syn match rOKeyword contained "@\(param\|return\|name\|rdname\|examples\|include\|docType\)"
 syn match rOKeyword contained "@\(S3method\|TODO\|aliases\|alias\|assignee\|author\|callGraphDepth\|callGraph\)"
 syn match rOKeyword contained "@\(callGraphPrimitives\|concept\|exportClass\|exportMethod\|exportPattern\|export\|formals\)"
 syn match rOKeyword contained "@\(format\|importClassesFrom\|importFrom\|importMethodsFrom\|import\|keywords\)"
-syn match rOKeyword contained "@\(method\|nord\|note\|references\|seealso\|setClass\|slot\|source\|title\|usage\)"
+syn match rOKeyword contained "@\(method\|noRd\|note\|references\|seealso\|setClass\|slot\|source\|title\|usage\)"
+syn match rOKeyword contained "@\(family\|template\|templateVar\|description\|details\|inheritsParams\)"
 syn match rOComment contains=@Spell,rOKeyword "#'.*"
 
 
@@ -119,7 +121,7 @@
 else
   syn match rOperator    "[|!<>^~`/:]"
 endif
-syn match rOperator    "%\{2}\|%\S*%"
+syn match rOperator    "%\{2}\|%\S\{-}%"
 syn match rOpError  '\*\{3}'
 syn match rOpError  '//'
 syn match rOpError  '&&&'
@@ -164,8 +166,8 @@
 syn keyword rPreProc     library require attach detach source
 
 if &filetype == "rhelp"
-    syn match rHelpIdent '\\method'
-    syn match rHelpIdent '\\S4method'
+  syn match rHelpIdent '\\method'
+  syn match rHelpIdent '\\S4method'
 endif
 
 " Type
@@ -187,6 +189,7 @@
 hi def link rBoolean     Boolean
 hi def link rBraceError  Error
 hi def link rComment     Comment
+hi def link rCommentTodo Todo
 hi def link rOComment    Comment
 hi def link rComplex     Number
 hi def link rConditional Conditional
diff -Naur vim74.orig/runtime/syntax/rhelp.vim vim74/runtime/syntax/rhelp.vim
--- vim74.orig/runtime/syntax/rhelp.vim	2011-10-20 14:48:41.000000000 +0000
+++ vim74/runtime/syntax/rhelp.vim	2014-10-10 14:53:43.118716963 +0000
@@ -2,9 +2,7 @@
 " Language:    R Help File
 " Maintainer: Jakson Aquino <jalvesaq@gmail.com>
 " Former Maintainer: Johannes Ranke <jranke@uni-bremen.de>
-" Last Change: Fri Oct 14, 2011  09:54PM
-" Version:     0.7.4
-" SVN:		   $Id: rhelp.vim 90 2010-11-22 10:58:11Z ranke $
+" Last Change: Wed Jul 09, 2014  10:28PM
 " Remarks:     - Includes R syntax highlighting in the appropriate
 "                sections if an r.vim file is in the same directory or in the
 "                default debian location.
@@ -23,6 +21,8 @@
   finish
 endif 
 
+setlocal iskeyword=@,48-57,_,.
+
 syn case match
 
 " R help identifiers {{{1
@@ -51,7 +51,12 @@
 syn region rhelpRcode matchgroup=Delimiter start="\\usage{" matchgroup=Delimiter transparent end="}" contains=@R,rhelpIdentifier,rhelpS4method
 syn region rhelpRcode matchgroup=Delimiter start="\\synopsis{" matchgroup=Delimiter transparent end="}" contains=@R
 syn region rhelpRcode matchgroup=Delimiter start="\\special{" matchgroup=Delimiter transparent end="}" contains=@R
-syn region rhelpRcode matchgroup=Delimiter start="\\code{" skip='\\\@<!{.\{-}\\\@<!}' transparent end="}" contains=@R,rhelpDots,rhelpString,rhelpSpecialChar,rhelpLink keepend
+
+if v:version > 703
+  syn region rhelpRcode matchgroup=Delimiter start="\\code{" skip='\\\@1<!{.\{-}\\\@1<!}' transparent end="}" contains=@R,rhelpDots,rhelpString,rhelpSpecialChar,rhelpLink keepend
+else
+  syn region rhelpRcode matchgroup=Delimiter start="\\code{" skip='\\\@<!{.\{-}\\\@<!}' transparent end="}" contains=@R,rhelpDots,rhelpString,rhelpSpecialChar,rhelpLink keepend
+endif
 syn region rhelpS4method matchgroup=Delimiter start="\\S4method{.*}(" matchgroup=Delimiter transparent end=")" contains=@R,rhelpDots
 syn region rhelpSexpr matchgroup=Delimiter start="\\Sexpr{" matchgroup=Delimiter transparent end="}" contains=@R
 
@@ -127,8 +132,13 @@
 syn region rhelpLink matchgroup=rhelpSection start="\\linkS4class{" end="}" contained keepend extend
 
 " Verbatim like {{{1
-syn region rhelpVerbatim matchgroup=rhelpType start="\\samp{" skip='\\\@<!{.\{-}\\\@<!}' end="}" contains=rhelpSpecialChar,rhelpComment
-syn region rhelpVerbatim matchgroup=rhelpType start="\\verb{" skip='\\\@<!{.\{-}\\\@<!}' end="}" contains=rhelpSpecialChar,rhelpComment
+if v:version > 703
+  syn region rhelpVerbatim matchgroup=rhelpType start="\\samp{" skip='\\\@1<!{.\{-}\\\@1<!}' end="}" contains=rhelpSpecialChar,rhelpComment
+  syn region rhelpVerbatim matchgroup=rhelpType start="\\verb{" skip='\\\@1<!{.\{-}\\\@1<!}' end="}" contains=rhelpSpecialChar,rhelpComment
+else
+  syn region rhelpVerbatim matchgroup=rhelpType start="\\samp{" skip='\\\@<!{.\{-}\\\@<!}' end="}" contains=rhelpSpecialChar,rhelpComment
+  syn region rhelpVerbatim matchgroup=rhelpType start="\\verb{" skip='\\\@<!{.\{-}\\\@<!}' end="}" contains=rhelpSpecialChar,rhelpComment
+endif
 
 " Type Styles {{{1
 syn match rhelpType		"\\emph\>"
@@ -200,6 +210,8 @@
 syn match rhelpCurlyError /[)\]]/ contained
 syn match rhelpParenError /[\]}]/ contained
 
+syntax sync match rhelpSyncRcode grouphere rhelpRcode "\\examples{"
+
 " Define the default highlighting {{{1
 " For version 5.7 and earlier: only when not done already
 " For version 5.8 and later: only when an item doesn't have highlighting yet
@@ -233,4 +245,5 @@
 endif 
 
 let   b:current_syntax = "rhelp"
-" vim: foldmethod=marker:
+
+" vim: foldmethod=marker sw=2
diff -Naur vim74.orig/runtime/syntax/rmd.vim vim74/runtime/syntax/rmd.vim
--- vim74.orig/runtime/syntax/rmd.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/rmd.vim	2014-10-10 14:53:43.125383613 +0000
@@ -0,0 +1,87 @@
+" markdown Text with R statements
+" Language: markdown with R code chunks
+" Last Change: Wed Jul 09, 2014  10:29PM
+"
+" CONFIGURATION:
+"   To highlight chunk headers as R code, put in your vimrc:
+"   let rmd_syn_hl_chunk = 1
+
+" for portability
+if version < 600
+  syntax clear
+elseif exists("b:current_syntax")
+  finish
+endif
+
+" load all of pandoc info
+runtime syntax/pandoc.vim
+if exists("b:current_syntax")
+  let rmdIsPandoc = 1
+  unlet b:current_syntax
+else
+  let rmdIsPandoc = 0
+  runtime syntax/markdown.vim
+  if exists("b:current_syntax")
+    unlet b:current_syntax
+  endif
+endif
+
+" load all of the r syntax highlighting rules into @R
+syntax include @R syntax/r.vim
+if exists("b:current_syntax")
+  unlet b:current_syntax
+endif
+
+if exists("g:rmd_syn_hl_chunk")
+  " highlight R code inside chunk header
+  syntax match rmdChunkDelim "^[ \t]*```{r" contained
+  syntax match rmdChunkDelim "}$" contained
+else
+  syntax match rmdChunkDelim "^[ \t]*```{r.*}$" contained
+endif
+syntax match rmdChunkDelim "^[ \t]*```$" contained
+syntax region rmdChunk start="^[ \t]*``` *{r.*}$" end="^[ \t]*```$" contains=@R,rmdChunkDelim keepend fold
+
+" also match and syntax highlight in-line R code
+syntax match rmdEndInline "`" contained
+syntax match rmdBeginInline "`r " contained
+syntax region rmdrInline start="`r "  end="`" contains=@R,rmdBeginInline,rmdEndInline keepend
+
+" match slidify special marker
+syntax match rmdSlidifySpecial "\*\*\*"
+
+
+if rmdIsPandoc == 0
+  syn match rmdBlockQuote /^\s*>.*\n\(.*\n\@<!\n\)*/ skipnl
+  " LaTeX
+  syntax include @LaTeX syntax/tex.vim
+  if exists("b:current_syntax")
+    unlet b:current_syntax
+  endif
+  " Inline
+  syntax match rmdLaTeXInlDelim "\$"
+  syntax match rmdLaTeXInlDelim "\\\$"
+  syn region texMathZoneX	matchgroup=Delimiter start="\$" skip="\\\\\|\\\$"	matchgroup=Delimiter end="\$" end="%stopzone\>"	contains=@texMathZoneGroup
+  " Region
+  syntax match rmdLaTeXRegDelim "\$\$" contained
+  syntax match rmdLaTeXRegDelim "\$\$latex$" contained
+  syntax region rmdLaTeXRegion start="^\$\$" skip="\\\$" end="\$\$$" contains=@LaTeX,rmdLaTeXSt,rmdLaTeXRegDelim keepend
+  syntax region rmdLaTeXRegion2 start="^\\\[" end="\\\]" contains=@LaTeX,rmdLaTeXSt,rmdLaTeXRegDelim keepend
+  hi def link rmdLaTeXSt Statement
+  hi def link rmdLaTeXInlDelim Special
+  hi def link rmdLaTeXRegDelim Special
+endif
+
+setlocal iskeyword=@,48-57,_,.
+
+syn sync match rmdSyncChunk grouphere rmdChunk "^[ \t]*``` *{r"
+
+hi def link rmdChunkDelim Special
+hi def link rmdBeginInline Special
+hi def link rmdEndInline Special
+hi def link rmdBlockQuote Comment
+hi def link rmdSlidifySpecial Special
+
+let b:current_syntax = "rmd"
+
+" vim: ts=8 sw=2
diff -Naur vim74.orig/runtime/syntax/rrst.vim vim74/runtime/syntax/rrst.vim
--- vim74.orig/runtime/syntax/rrst.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/rrst.vim	2014-10-10 14:53:43.145383563 +0000
@@ -0,0 +1,47 @@
+" reStructured Text with R statements
+" Language: reST with R code chunks
+" Maintainer: Alex Zvoleff, azvoleff@mail.sdsu.edu
+" Last Change: Wed Jul 09, 2014  10:29PM
+"
+" CONFIGURATION:
+"   To highlight chunk headers as R code, put in your vimrc:
+"   let rrst_syn_hl_chunk = 1
+
+" for portability
+if version < 600
+  syntax clear
+elseif exists("b:current_syntax")
+  finish
+endif
+
+" load all of the rst info
+runtime syntax/rst.vim
+unlet b:current_syntax
+
+" load all of the r syntax highlighting rules into @R
+syntax include @R syntax/r.vim
+
+setlocal iskeyword=@,48-57,_,.
+
+" highlight R chunks
+if exists("g:rrst_syn_hl_chunk")
+  " highlight R code inside chunk header
+  syntax match rrstChunkDelim "^\.\. {r" contained
+  syntax match rrstChunkDelim "}$" contained
+else
+  syntax match rrstChunkDelim "^\.\. {r .*}$" contained
+endif
+syntax match rrstChunkDelim "^\.\. \.\.$" contained
+syntax region rrstChunk start="^\.\. {r.*}$" end="^\.\. \.\.$" contains=@R,rrstChunkDelim keepend transparent fold
+
+" also highlight in-line R code
+syntax match rrstInlineDelim "`" contained
+syntax match rrstInlineDelim ":r:" contained
+syntax region rrstInline start=":r: *`" skip=/\\\\\|\\`/ end="`" contains=@R,rrstInlineDelim keepend
+
+hi def link rrstChunkDelim Special
+hi def link rrstInlineDelim Special
+
+let b:current_syntax = "rrst"
+
+" vim: ts=8 sw=2
diff -Naur vim74.orig/runtime/syntax/rst.vim vim74/runtime/syntax/rst.vim
--- vim74.orig/runtime/syntax/rst.vim	2013-06-04 14:41:25.000000000 +0000
+++ vim74/runtime/syntax/rst.vim	2014-10-10 14:53:43.148716887 +0000
@@ -1,7 +1,8 @@
 " Vim syntax file
 " Language:         reStructuredText documentation format
-" Maintainer:       Nikolai Weibull <now@bitwi.se>
-" Latest Revision:  2013-06-03
+" Maintainer:       Marshall Ward <marshall.ward@gmail.com>
+" Previous Maintainer: Nikolai Weibull <now@bitwi.se>
+" Latest Revision:  2014-08-23
 
 if exists("b:current_syntax")
   finish
@@ -47,7 +48,7 @@
 syn cluster rstDirectives           contains=rstFootnote,rstCitation,
       \ rstHyperlinkTarget,rstExDirective
 
-syn match   rstExplicitMarkup       '^\.\.\_s'
+syn match   rstExplicitMarkup       '^\s*\.\.\_s'
       \ nextgroup=@rstDirectives,rstComment,rstSubstitutionDefinition
 
 let s:ReferenceName = '[[:alnum:]]\+\%([_.-][[:alnum:]]\+\)*'
@@ -99,11 +100,11 @@
         \ ""
 
   call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, "'", "'")
-  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '"', '"') 
-  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '(', ')') 
-  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '\[', '\]') 
-  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '{', '}') 
-  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '<', '>') 
+  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '"', '"')
+  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '(', ')')
+  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '\[', '\]')
+  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '{', '}')
+  call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '<', '>')
 
   call s:DefineOneInlineMarkup(a:name, a:start, middle, a:end, '\%(^\|\s\|[/:]\)', '')
 
@@ -136,23 +137,24 @@
       \ "\<\%(\%(\%(https\=\|file\|ftp\|gopher\)://\|\%(mailto\|news\):\)[^[:space:]'\"<>]\+\|www[[:alnum:]_-]*\.[[:alnum:]_-]\+\.[^[:space:]'\"<>]\+\)[[:alnum:]/]"
 
 syn region rstCodeBlock contained matchgroup=rstDirective
-      \ start=+\%(sourcecode\|code\%(-block\)\=\)::\s+
+      \ start=+\%(sourcecode\|code\%(-block\)\=\)::\_s*\n\ze\z(\s\+\)+
       \ skip=+^$+
-      \ end=+^\s\@!+ 
+      \ end=+^\z1\@!+
       \ contains=@NoSpell
 syn cluster rstDirectives add=rstCodeBlock
 
 if !exists('g:rst_syntax_code_list')
-    let g:rst_syntax_code_list = ['vim', 'java', 'cpp', 'lisp', 'php', 'python', 'perl']
+    let g:rst_syntax_code_list = ['vim', 'java', 'cpp', 'lisp', 'php',
+                                \ 'python', 'perl', 'sh']
 endif
 
 for code in g:rst_syntax_code_list
     unlet! b:current_syntax
     exe 'syn include @rst'.code.' syntax/'.code.'.vim'
     exe 'syn region rstDirective'.code.' matchgroup=rstDirective fold '
-                \.'start=#\%(sourcecode\|code\%(-block\)\=\)::\s\+'.code.'\s*$# '
+                \.'start=#\%(sourcecode\|code\%(-block\)\=\)::\s\+'.code.'\_s*\n\ze\z(\s\+\)# '
                 \.'skip=#^$# '
-                \.'end=#^\s\@!# contains=@NoSpell,@rst'.code
+                \.'end=#^\z1\@!# contains=@NoSpell,@rst'.code
     exe 'syn cluster rstDirectives add=rstDirective'.code
 endfor
 
diff -Naur vim74.orig/runtime/syntax/sh.vim vim74/runtime/syntax/sh.vim
--- vim74.orig/runtime/syntax/sh.vim	2013-07-05 16:35:45.000000000 +0000
+++ vim74/runtime/syntax/sh.vim	2014-10-10 14:53:43.242049986 +0000
@@ -2,10 +2,10 @@
 " Language:		shell (sh) Korn shell (ksh) bash (sh)
 " Maintainer:		Charles E. Campbell  <NdrOchipS@PcampbellAfamily.Mbiz>
 " Previous Maintainer:	Lennart Schultz <Lennart.Schultz@ecmwf.int>
-" Last Change:		Jul 02, 2013
-" Version:		131
+" Last Change:		Mar 20, 2014
+" Version:		132
 " URL:		http://mysite.verizon.net/astronaut/vim/index.html#vimlinks_syntax
-" For options and settings, please use:      :help ft-sh-syntax
+" For options and settings, please use:	:help ft-sh-syntax
 " This file includes many ideas from ?ric Brunet (eric.brunet@ens.fr)
 
 " For version 5.x: Clear all syntax items {{{1
@@ -151,18 +151,18 @@
 " Error Codes: {{{1
 " ============
 if !exists("g:sh_no_error")
- syn match   shDoError "\<done\>"
- syn match   shIfError "\<fi\>"
- syn match   shInError "\<in\>"
- syn match   shCaseError ";;"
- syn match   shEsacError "\<esac\>"
- syn match   shCurlyError "}"
- syn match   shParenError ")"
- syn match   shOK	'\.\(done\|fi\|in\|esac\)'
+ syn match	shDoError	"\<done\>"
+ syn match	shIfError	"\<fi\>"
+ syn match	shInError	"\<in\>"
+ syn match	shCaseError	";;"
+ syn match	shEsacError	"\<esac\>"
+ syn match	shCurlyError	"}"
+ syn match	shParenError	")"
+ syn match	shOK	'\.\(done\|fi\|in\|esac\)'
  if exists("b:is_kornshell")
-  syn match     shDTestError "]]"
+   syn match	shDTestError	"]]"
  endif
- syn match     shTestError "]"
+ syn match	shTestError	"]"
 endif
 
 " Options: {{{1
@@ -321,12 +321,12 @@
 endif
 syn region  shSingleQuote	matchgroup=shQuote start=+'+ end=+'+		contains=@Spell
 syn region  shDoubleQuote	matchgroup=shQuote start=+\%(\%(\\\\\)*\\\)\@<!"+ skip=+\\"+ end=+"+	contains=@shDblQuoteList,shStringSpecial,@Spell
-"syn region  shDoubleQuote	matchgroup=shQuote start=+"+ skip=+\\"+ end=+"+	contains=@shDblQuoteList,shStringSpecial,@Spell
 syn match   shStringSpecial	"[^[:print:] \t]"	contained
 syn match   shStringSpecial	"\%(\\\\\)*\\[\\"'`$()#]"
-syn match   shSpecial	"[^\\]\zs\%(\\\\\)*\\[\\"'`$()#]" nextgroup=shMoreSpecial,shComment
-syn match   shSpecial	"^\%(\\\\\)*\\[\\"'`$()#]"	nextgroup=shComment
-syn match   shMoreSpecial	"\%(\\\\\)*\\[\\"'`$()#]" nextgroup=shMoreSpecial contained
+"syn match   shSpecial	"[^\\]\zs\%(\\\\\)*\\[\\"'`$()#]"	nextgroup=shMoreSpecial,shComment
+syn match   shSpecial	"[^\\]\zs\%(\\\\\)*\\[\\"'`$()#]"	nextgroup=shMoreSpecial
+syn match   shSpecial	"^\%(\\\\\)*\\[\\"'`$()#]"		nextgroup=shComment
+syn match   shMoreSpecial	"\%(\\\\\)*\\[\\"'`$()#]" 	contained	nextgroup=shMoreSpecial
 
 " Comments: {{{1
 "==========
@@ -363,9 +363,9 @@
  syn region shHereDoc matchgroup=shRedir19 fold start="<<\\\z([^ \t|]*\)"		matchgroup=shRedir19 end="^\z1\s*$"
 
 else
- syn region shHereDoc matchgroup=shRedir20 start="<<\s*\\\=\z([^ \t|]*\)"		matchgroup=shRedir20 end="^\z1\s*$"    contains=@shDblQuoteList
+ syn region shHereDoc matchgroup=shRedir20 start="<<\s*\\\=\z([^ \t|]*\)"		matchgroup=shRedir20 end="^\z1\s*$"	contains=@shDblQuoteList
  syn region shHereDoc matchgroup=shRedir21 start="<<\s*\"\z([^ \t|]*\)\""		matchgroup=shRedir21 end="^\z1\s*$"
- syn region shHereDoc matchgroup=shRedir22 start="<<-\s*\z([^ \t|]*\)"		matchgroup=shRedir22 end="^\s*\z1\s*$" contains=@shDblQuoteList
+ syn region shHereDoc matchgroup=shRedir22 start="<<-\s*\z([^ \t|]*\)"		matchgroup=shRedir22 end="^\s*\z1\s*$"	contains=@shDblQuoteList
  syn region shHereDoc matchgroup=shRedir23 start="<<-\s*'\z([^ \t|]*\)'"		matchgroup=shRedir23 end="^\s*\z1\s*$"
  syn region shHereDoc matchgroup=shRedir24 start="<<\s*'\z([^ \t|]*\)'"		matchgroup=shRedir24 end="^\z1\s*$"
  syn region shHereDoc matchgroup=shRedir25 start="<<-\s*\"\z([^ \t|]*\)\""		matchgroup=shRedir25 end="^\s*\z1\s*$"
@@ -450,21 +450,21 @@
 syn match  shDerefVar	contained	"{\@<=\k\+"		nextgroup=@shDerefVarList
 
 " sh ksh bash : ${var[... ]...}  array reference: {{{1
-syn region  shDerefVarArray   contained	matchgroup=shDeref start="\[" end="]"	contains=@shCommandSubList nextgroup=shDerefOp,shDerefOpError
+syn region  shDerefVarArray	contained	matchgroup=shDeref start="\[" end="]"	contains=@shCommandSubList nextgroup=shDerefOp,shDerefOpError
 
 " Special ${parameter OPERATOR word} handling: {{{1
-" sh ksh bash : ${parameter:-word}    word is default value
-" sh ksh bash : ${parameter:=word}    assign word as default value
-" sh ksh bash : ${parameter:?word}    display word if parameter is null
-" sh ksh bash : ${parameter:+word}    use word if parameter is not null, otherwise nothing
-"    ksh bash : ${parameter#pattern}  remove small left  pattern
-"    ksh bash : ${parameter##pattern} remove large left  pattern
-"    ksh bash : ${parameter%pattern}  remove small right pattern
-"    ksh bash : ${parameter%%pattern} remove large right pattern
-"        bash : ${parameter^pattern}  Case modification
-"        bash : ${parameter^^pattern} Case modification
-"        bash : ${parameter,pattern}  Case modification
-"        bash : ${parameter,,pattern} Case modification
+" sh ksh bash : ${parameter:-word}	word is default value
+" sh ksh bash : ${parameter:=word}	assign word as default value
+" sh ksh bash : ${parameter:?word}	display word if parameter is null
+" sh ksh bash : ${parameter:+word}	use word if parameter is not null, otherwise nothing
+"    ksh bash : ${parameter#pattern}	remove small left  pattern
+"    ksh bash : ${parameter##pattern}	remove large left  pattern
+"    ksh bash : ${parameter%pattern}	remove small right pattern
+"    ksh bash : ${parameter%%pattern}	remove large right pattern
+"        bash : ${parameter^pattern}	Case modification
+"        bash : ${parameter^^pattern}	Case modification
+"        bash : ${parameter,pattern}	Case modification
+"        bash : ${parameter,,pattern}	Case modification
 syn cluster shDerefPatternList	contains=shDerefPattern,shDerefString
 if !exists("g:sh_no_error")
  syn match shDerefOpError	contained	":[[:punct:]]"
@@ -598,6 +598,7 @@
 hi def link shSingleQuote	shString
 hi def link shSource	shOperator
 hi def link shStringSpecial	shSpecial
+hi def link shStringSpecial	Unique
 hi def link shSubShRegion	shOperator
 hi def link shTestOpr	shConditional
 hi def link shTestPattern	shString
diff -Naur vim74.orig/runtime/syntax/sisu.vim vim74/runtime/syntax/sisu.vim
--- vim74.orig/runtime/syntax/sisu.vim	2013-05-17 15:16:09.000000000 +0000
+++ vim74/runtime/syntax/sisu.vim	2014-10-10 14:53:43.258716611 +0000
@@ -1,8 +1,9 @@
 " SiSU Vim syntax file
-" SiSU Maintainer: Ralph Amissah <ralph@amissah.com>
-" SiSU Markup:     SiSU (sisu-4.0.9)
-" Last Change:     2013-02-22
-" URL (sisu-4.1.0): <http://git.sisudoc.org/?p=code/sisu.git;a=blob;f=data/sisu/conf/editor-syntax-etc/vim/syntax/sisu.vim;hb=HEAD>
+" SiSU Maintainer: Ralph Amissah <ralph.amissah@gmail.com>
+" SiSU Markup:     SiSU (sisu-5.6.7)
+" Last Change:     2014-09-14
+" URL: <http://git.sisudoc.org/gitweb/?p=code/sisu.git;a=blob;f=data/sisu/conf/editor-syntax-etc/vim/syntax/sisu.vim;hb=HEAD>
+"      <http://git.sisudoc.org/gitweb/?p=code/sisu.git;a=blob_plain;f=data/sisu/conf/editor-syntax-etc/vim/syntax/sisu.vim;hb=HEAD>
 "(originally looked at Ruby Vim by Mirko Nasato)
 
 if version < 600
@@ -23,15 +24,14 @@
   syn match   sisu_break               contains=@NoSpell                  " \\\\\( \|$\)\|<br>\|<br />"
   syn match   sisu_control             contains=@NoSpell                  "^\(-\\\\-\|=\\\\=\|-\.\.-\|<:p[bn]>\)\s*$"
   syn match   sisu_control             contains=@NoSpell                  "^<:\(bo\|---\)>\s*$"
+  syn match   sisu_marktail            contains=@NoSpell                  "^--[+~-]#\s*$"
   syn match   sisu_marktail                                               "[~-]#"
   syn match   sisu_control                                                "\""
   syn match   sisu_underline                                              "\(^\| \)_[a-zA-Z0-9]\+_\([ .,]\|$\)"
   syn match   sisu_number              contains=@NoSpell                  "[0-9a-f]\{32\}\|[0-9a-f]\{64\}"
   syn match   sisu_link                contains=@NoSpell                  "\(_\?https\?://\|\.\.\/\)\S\+"
   syn match   sisu_link                                                   " \*\~\S\+"
-  syn match   sisu_action                                                 "^<:insert\d\+>"
-  syn match   sisu_require             contains=@NoSpell                  "^<<\s*[a-zA-Z0-9^._-]\+\.ss[it]$"
-  syn match   sisu_require             contains=@NoSpell                  "^<<{[a-zA-Z0-9^._-]\+\.ss[it]}$"
+  syn match   sisu_require             contains=@NoSpell                  "^<<\s*[a-zA-Z0-9^./_-]\+\.ss[it]$"
   syn match   sisu_structure                                              "^:A\~$"
 
 "% "Document Sub Headers:
@@ -44,6 +44,8 @@
   syn match   sisu_sub_header_original                                    "^\s\+:\(publisher\|date\|language\|lang_char\|institution\|nationality\|source\):\s"
   syn match   sisu_sub_header_make                                        "^\s\+:\(headings\|num_top\|breaks\|language\|italics\|bold\|emphasis\|substitute\|omit\|plaintext_wrap\|texpdf_font_mono\|texpdf_font\|stamp\|promo\|ad\|manpage\|home_button_text\|home_button_image\|cover_image\|footer\):\s"
   syn match   sisu_sub_header_notes                                       "^\s\+:\(description\|abstract\|comment\|coverage\|relation\|source\|history\|type\|format\|prefix\|prefix_[ab]\|suffix\):\s"
+  syn match   sisu_within_index_ignore                                    "\S\+[:;]\(\s\+\|$\)"
+  syn match   sisu_within_index                                           "[:|;]\|+\d\+"
 
 "% "semantic markers: (ignore)
   syn match   sisu_sem_marker                                             ";{\|};[a-z._]*[a-z]"
@@ -93,17 +95,25 @@
 syn region sisu_header_content contains=sisu_error,sisu_comment,sisu_break,sisu_link,sisu_sub_header_make matchgroup=sisu_header start="^[@]make:[+-]\?\(\s\|\n\)"rs=e-1 end="\n$"
 
 "% "Headings:
-syn region sisu_heading contains=sisu_mark_endnote,sisu_content_endnote,sisu_marktail,sisu_strikeout,sisu_number,sisu_bold,sisu_control,sisu_identifier,sisu_ocn,sisu_error,sisu_error_wspace matchgroup=sisu_structure start="^\([1-8]\|:\?[A-C]\)\~\(\S\+\|[^-]\)" end="$"
+syn region sisu_heading contains=sisu_mark_endnote,sisu_content_endnote,sisu_marktail,sisu_strikeout,sisu_number,sisu_bold,sisu_control,sisu_identifier,sisu_ocn,sisu_error,sisu_error_wspace matchgroup=sisu_structure start="^\([1-4]\|:\?[A-D]\)\~\(\S\+\|[^-]\)" end="$"
 
 "% "Block Group Text:
 " table
 syn region sisu_content_alt contains=sisu_strikeout,sisu_number,sisu_bold,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_contain start="^table{.\+" end="}table"
 " table
+syn region sisu_content_alt contains=sisu_strikeout,sisu_number,sisu_bold,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_contain start="^```\s\+table" end="^```\(\s\|$\)"
 syn region sisu_content_alt contains=sisu_strikeout,sisu_number,sisu_bold,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_contain start="^{\(t\|table\)\(\~h\)\?\(\sc[0-9]\+;\)\?[0-9; ]*}" end="\n$"
 " block, group, poem, alt
-syn region sisu_content_alt contains=sisu_mark_endnote,sisu_content_endnote,sisu_link,sisu_mark,sisu_strikeout,sisu_number,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_contain start="^\(block\|group\|poem\|alt\){" end="^}\(block\|group\|poem\|alt\)"
+syn region sisu_content_alt contains=sisu_mark_endnote,sisu_content_endnote,sisu_link,sisu_mark,sisu_strikeout,sisu_number,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_contain start="^\(block\|group\|poem\|alt\){" end="^}\1"
+syn region sisu_content_alt contains=sisu_mark_endnote,sisu_content_endnote,sisu_link,sisu_mark,sisu_strikeout,sisu_number,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_contain start="^```\s\+\(block\|group\|poem\|alt\)" end="^```\(\s\|$\)"
+" box
+syn region sisu_content_alt contains=sisu_mark_endnote,sisu_content_endnote,sisu_link,sisu_mark,sisu_strikeout,sisu_number,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_contain start="^box\(\.[a-z]\+\)\?{" end="^}box"
+syn region sisu_content_alt contains=sisu_mark_endnote,sisu_content_endnote,sisu_link,sisu_mark,sisu_strikeout,sisu_number,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_contain start="^```\s\+\box\(\.[a-z]\+\)\?" end="^```\(\s\|$\)"
 " code
-syn region sisu_content_alt contains=sisu_error matchgroup=sisu_contain start="^code{" end="^}code"
+syn region sisu_content_alt contains=sisu_error,@NoSpell matchgroup=sisu_contain start="^code\(\.[a-z][0-9a-z_]\+\)\?{" end="^}code"
+syn region sisu_content_alt contains=sisu_error,@NoSpell matchgroup=sisu_contain start="^```\s\+code\(\.[a-z][0-9a-z_]\+\)\?" end="^```\(\s\|$\)"
+" quote
+syn region sisu_normal contains=sisu_fontface,sisu_bold,sisu_control,sisu_identifier,sisu_content_endnote,sisu_mark_endnote,sisu_link,sisu_sem_block,sisu_sem_content,sisu_sem_marker_block,sisu_sem_marker,sisu_sem_ex_marker_block,sisu_sem_ex_marker,sisu_linked,sisu_error,sisu_error_wspace matchgroup=sisu_contain start="^```\s\+quote" end="^```\(\s\|$\)"
 
 "% "Endnotes:
 " regular endnote or asterisk or plus sign endnote
@@ -138,7 +148,7 @@
 "% "Font Face Curly Brackets:
 "syn region sisu_identifier contains=sisu_strikeout,sisu_number,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_sem start="\S\+:{" end="}:[^<>,.!?:; ]\+" oneline
 " book index:
-syn region sisu_index matchgroup=sisu_index_block start="^={" end="}"
+syn region sisu_index contains=sisu_within_index_ignore,sisu_within_index matchgroup=sisu_index_block start="^={" end="}"
 " emphasis:
 syn region sisu_bold contains=sisu_strikeout,sisu_number,sisu_bold,sisu_control,sisu_identifier,sisu_error matchgroup=sisu_fontface start="\*{" end="}\*"
 " bold:
@@ -246,6 +256,8 @@
 hi def link sisu_index_block           Visual
 hi def link sisu_content_endnote       Special
 hi def link sisu_control               Delimiter
+hi def link sisu_within_index          Delimiter
+hi def link sisu_within_index_ignore   SpecialKey
 hi def link sisu_ocn                   Include
 hi def link sisu_number                Number
 hi def link sisu_identifier            Function
diff -Naur vim74.orig/runtime/syntax/spec.vim vim74/runtime/syntax/spec.vim
--- vim74.orig/runtime/syntax/spec.vim	2010-05-15 11:03:57.000000000 +0000
+++ vim74/runtime/syntax/spec.vim	2014-10-10 14:53:43.298716511 +0000
@@ -1,8 +1,9 @@
 " Filename:    spec.vim
 " Purpose:     Vim syntax file
 " Language:    SPEC: Build/install scripts for Linux RPM packages
-" Maintainer:  Donovan Rebbechi elflord@panix.com
-" Last Change: Fri Dec 3 11:54 EST 2004 Marcin Dalecki
+" Maintainer:  Igor Gnatenko i.gnatenko.brain@gmail.com
+" Former Maintainer:  Donovan Rebbechi elflord@panix.com (until March 2014)
+" Last Change: Sun Mar 2 10:33 MSK 2014 Igor Gnatenko
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -82,8 +83,8 @@
 
 "One line macros - valid in all ScriptAreas
 "tip: remember do include new items on specScriptArea's skip section
-syn region specSectionMacroArea oneline matchgroup=specSectionMacro start='^%\(define\|patch\d*\|setup\|configure\|GNUconfigure\|find_lang\|makeinstall\|include\)\>' end='$' contains=specCommandOpts,specMacroIdentifier
-syn region specSectionMacroBracketArea oneline matchgroup=specSectionMacro start='^%{\(configure\|GNUconfigure\|find_lang\|makeinstall\)}' end='$' contains=specCommandOpts,specMacroIdentifier
+syn region specSectionMacroArea oneline matchgroup=specSectionMacro start='^%\(define\|global\|patch\d*\|setup\|configure\|GNUconfigure\|find_lang\|makeinstall\|make_install\|include\)\>' end='$' contains=specCommandOpts,specMacroIdentifier
+syn region specSectionMacroBracketArea oneline matchgroup=specSectionMacro start='^%{\(configure\|GNUconfigure\|find_lang\|makeinstall\|make_install\)}' end='$' contains=specCommandOpts,specMacroIdentifier
 
 "%% Files Section %%
 "TODO %config valid parameters: missingok\|noreplace
@@ -113,7 +114,7 @@
 syn region specPackageArea matchgroup=specSection start='^%package' end='^%'me=e-1 contains=specPackageOpts,specPreAmble,specComment
 
 "%% Scripts Section %%
-syn region specScriptArea matchgroup=specSection start='^%\(prep\|build\|install\|clean\|pre\|postun\|preun\|post\)\>' skip='^%{\|^%\(define\|patch\d*\|configure\|GNUconfigure\|setup\|find_lang\|makeinstall\)\>' end='^%'me=e-1 contains=specSpecialVariables,specVariables,@specCommands,specVariables,shDo,shFor,shCaseEsac,specNoNumberHilite,specCommandOpts,shComment,shIf,specSpecialChar,specMacroIdentifier,specSectionMacroArea,specSectionMacroBracketArea,shOperator,shQuote1,shQuote2
+syn region specScriptArea matchgroup=specSection start='^%\(prep\|build\|install\|clean\|pre\|postun\|preun\|post\|posttrans\)\>' skip='^%{\|^%\(define\|patch\d*\|configure\|GNUconfigure\|setup\|find_lang\|makeinstall\|make_install\)\>' end='^%'me=e-1 contains=specSpecialVariables,specVariables,@specCommands,specVariables,shDo,shFor,shCaseEsac,specNoNumberHilite,specCommandOpts,shComment,shIf,specSpecialChar,specMacroIdentifier,specSectionMacroArea,specSectionMacroBracketArea,shOperator,shQuote1,shQuote2
 
 "%% Changelog Section %%
 syn region specChangelogArea matchgroup=specSection start='^%changelog' end='^%'me=e-1 contains=specEmail,specURL,specWeekday,specMonth,specNumber,specComment,specLicense
diff -Naur vim74.orig/runtime/syntax/svn.vim vim74/runtime/syntax/svn.vim
--- vim74.orig/runtime/syntax/svn.vim	2012-07-25 13:08:55.000000000 +0000
+++ vim74/runtime/syntax/svn.vim	2014-10-10 14:53:43.352049710 +0000
@@ -2,15 +2,18 @@
 " Language:     Subversion (svn) commit file
 " Maintainer:   Dmitry Vasiliev <dima at hlabs dot org>
 " URL:          https://github.com/hdima/vim-scripts/blob/master/syntax/svn.vim
-" Last Change:  2012-07-21
+" Last Change:  2013-11-08
 " Filenames:    svn-commit*.tmp
-" Version:      1.9
+" Version:      1.10
 
 " Contributors:
-"   Stefano Zacchiroli
+"
+" List of the contributors in alphabetical order:
+"
 "   A. S. Budden
-"   Myk Taylor
 "   Ingo Karkat
+"   Myk Taylor
+"   Stefano Zacchiroli
 
 " For version 5.x: Clear all syntax items.
 " For version 6.x: Quit when a syntax file was already loaded.
@@ -20,14 +23,19 @@
   finish
 endif
 
-syn region svnText      start="\%^" end="^--.*--$"me=s-1 contains=@Spell
+syn spell toplevel
 
-syn region svnRegion    start="^--.*--$" end="\%$" contains=ALL
-syn match svnRemoved    "^D    .*$" contained
-syn match svnRenamed    "^R[ M][ U][ +] .*$" contained
-syn match svnAdded      "^A[ M][ U][ +] .*$" contained
-syn match svnModified   "^M[ M][ U]  .*$" contained
-syn match svnProperty   "^_M[ U]  .*$" contained
+syn match svnFirstLine  "\%^.*" nextgroup=svnRegion,svnBlank skipnl
+syn match svnSummary    "^.\{0,50\}" contained containedin=svnFirstLine nextgroup=svnOverflow contains=@Spell
+syn match svnOverflow   ".*" contained contains=@Spell
+syn match svnBlank      "^.*" contained contains=@Spell
+
+syn region svnRegion    end="\%$" matchgroup=svnDelimiter start="^--.*--$" contains=svnRemoved,svnRenamed,svnAdded,svnModified,svnProperty,@NoSpell
+syn match svnRemoved    "^D    .*$" contained contains=@NoSpell
+syn match svnRenamed    "^R[ M][ U][ +] .*$" contained contains=@NoSpell
+syn match svnAdded      "^A[ M][ U][ +] .*$" contained contains=@NoSpell
+syn match svnModified   "^M[ M][ U]  .*$" contained contains=@NoSpell
+syn match svnProperty   "^_M[ U]  .*$" contained contains=@NoSpell
 
 " Synchronization.
 syn sync clear
@@ -44,7 +52,11 @@
     command -nargs=+ HiLink hi def link <args>
   endif
 
+  HiLink svnSummary     Keyword
+  HiLink svnBlank       Error
+
   HiLink svnRegion      Comment
+  HiLink svnDelimiter   NonText
   HiLink svnRemoved     Constant
   HiLink svnAdded       Identifier
   HiLink svnModified    Special
diff -Naur vim74.orig/runtime/syntax/systemverilog.vim vim74/runtime/syntax/systemverilog.vim
--- vim74.orig/runtime/syntax/systemverilog.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/systemverilog.vim	2014-10-10 14:53:43.362049685 +0000
@@ -0,0 +1,101 @@
+" Vim syntax file
+" Language:    SystemVerilog
+" Maintainer:  kocha <kocha.lsifrontend@gmail.com>
+" Last Change: 12-Aug-2013. 
+
+" For version 5.x: Clear all syntax items
+" For version 6.x: Quit when a syntax file was already loaded
+if version < 600
+    syntax clear
+elseif exists("b:current_syntax")
+    finish
+endif
+
+" Read in Verilog syntax files
+if version < 600
+    so <sfile>:p:h/verilog.vim
+else
+    runtime! syntax/verilog.vim
+    unlet b:current_syntax
+endif
+
+" IEEE1800-2005
+syn keyword systemverilogStatement   always_comb always_ff always_latch
+syn keyword systemverilogStatement   class endclass new
+syn keyword systemverilogStatement   virtual local const protected
+syn keyword systemverilogStatement   package endpackage
+syn keyword systemverilogStatement   rand randc constraint randomize
+syn keyword systemverilogStatement   with inside dist
+syn keyword systemverilogStatement   sequence endsequence randsequence 
+syn keyword systemverilogStatement   srandom
+syn keyword systemverilogStatement   logic bit byte
+syn keyword systemverilogStatement   int longint shortint
+syn keyword systemverilogStatement   struct packed
+syn keyword systemverilogStatement   final
+syn keyword systemverilogStatement   import export
+syn keyword systemverilogStatement   context pure 
+syn keyword systemverilogStatement   void shortreal chandle string
+syn keyword systemverilogStatement   clocking endclocking iff
+syn keyword systemverilogStatement   interface endinterface modport
+syn keyword systemverilogStatement   cover covergroup coverpoint endgroup
+syn keyword systemverilogStatement   property endproperty
+syn keyword systemverilogStatement   program endprogram
+syn keyword systemverilogStatement   bins binsof illegal_bins ignore_bins
+syn keyword systemverilogStatement   alias matches solve static assert
+syn keyword systemverilogStatement   assume super before expect bind
+syn keyword systemverilogStatement   extends null tagged extern this
+syn keyword systemverilogStatement   first_match throughout timeprecision
+syn keyword systemverilogStatement   timeunit type union 
+syn keyword systemverilogStatement   uwire var cross ref wait_order intersect
+syn keyword systemverilogStatement   wildcard within
+
+syn keyword systemverilogTypeDef     typedef enum
+
+syn keyword systemverilogConditional randcase
+syn keyword systemverilogConditional unique priority
+
+syn keyword systemverilogRepeat      return break continue
+syn keyword systemverilogRepeat      do foreach
+
+syn keyword systemverilogLabel       join_any join_none forkjoin
+
+" IEEE1800-2009 add
+syn keyword systemverilogStatement   checker endchecker
+syn keyword systemverilogStatement   accept_on reject_on
+syn keyword systemverilogStatement   sync_accept_on sync_reject_on
+syn keyword systemverilogStatement   eventually nexttime until until_with
+syn keyword systemverilogStatement   s_always s_eventually s_nexttime s_until s_until_with
+syn keyword systemverilogStatement   let untyped
+syn keyword systemverilogStatement   strong weak
+syn keyword systemverilogStatement   restrict global implies
+
+syn keyword systemverilogConditional unique0
+
+" IEEE1800-2012 add
+syn keyword systemverilogStatement   implements
+syn keyword systemverilogStatement   interconnect soft nettype
+
+" Define the default highlighting.
+if version >= 508 || !exists("did_systemverilog_syn_inits")
+   if version < 508
+      let did_systemverilog_syn_inits = 1
+      command -nargs=+ HiLink hi link <args>
+   else
+      command -nargs=+ HiLink hi def link <args>
+   endif
+
+   " The default highlighting.
+   HiLink systemverilogStatement       Statement
+   HiLink systemverilogTypeDef         TypeDef
+   HiLink systemverilogConditional     Conditional
+   HiLink systemverilogRepeat          Repeat
+   HiLink systemverilogLabel           Label
+   HiLink systemverilogGlobal          Define
+   HiLink systemverilogNumber          Number
+
+   delcommand HiLink
+endif
+
+let b:current_syntax = "systemverilog"
+
+" vim: ts=8
diff -Naur vim74.orig/runtime/syntax/tcl.vim vim74/runtime/syntax/tcl.vim
--- vim74.orig/runtime/syntax/tcl.vim	2010-05-15 11:03:56.000000000 +0000
+++ vim74/runtime/syntax/tcl.vim	2014-10-10 14:53:43.378716310 +0000
@@ -6,11 +6,9 @@
 "		(previously Matt Neumann <mattneu@purpleturtle.com>)
 "		(previously Allan Kelly <allan@fruitloaf.co.uk>)
 " Original:	Robin Becker <robin@jessikat.demon.co.uk>
-" Last Change:	2009/04/06 02:38:36
-" Version:	1.13
-" URL:		http://real.metasyntax.net:2357/cvs/cvsweb.cgi/Config/vim/syntax/tcl.vim
-"
-" Keywords TODO: click anchor
+" Last Change:	2014-02-12
+" Version:	1.14
+" URL:		http://bitbucket.org/taylor_venable/metasyntax/src/tip/Config/vim/syntax/tcl.vim
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -20,41 +18,39 @@
   finish
 endif
 
-" Basic Tcl commands: http://www.tcl.tk/man/tcl8.5/TclCmd/contents.htm
-syn keyword tclCommand		after append apply array bgerror binary catch cd chan clock
-syn keyword tclCommand		close concat dde dict encoding eof error eval exec exit
-syn keyword tclCommand		expr fblocked fconfigure fcopy file fileevent filename flush
-syn keyword tclCommand		format gets glob global history incr info interp join
-syn keyword tclCommand		lappend lassign lindex linsert list llength load lrange lrepeat
-syn keyword tclCommand		lreplace lreverse lsearch lset lsort memory namespace open package
-syn keyword tclCommand		pid proc puts pwd read regexp registry regsub rename return
-syn keyword tclCommand		scan seek set socket source split string subst tell time
-syn keyword tclCommand		trace unknown unload unset update uplevel upvar variable vwait
-
-" The 'Tcl Standard Library' commands: http://www.tcl.tk/man/tcl8.5/TclCmd/library.htm
-syn keyword tclCommand		auto_execok auto_import auto_load auto_mkindex auto_mkindex_old
-syn keyword tclCommand		auto_qualify auto_reset parray tcl_endOfWord tcl_findLibrary
-syn keyword tclCommand		tcl_startOfNextWord tcl_startOfPreviousWord tcl_wordBreakAfter
-syn keyword tclCommand		tcl_wordBreakBefore
-
-" Commands that were added in Tcl 8.6
-
-syn keyword tclCommand		my oo::copy oo::define oo::objdefine self
-syn keyword tclCommand		coroutine tailcall throw yield
-
-" Global variables used by Tcl: http://www.tcl.tk/man/tcl8.5/TclCmd/tclvars.htm
-syn keyword tclVars		env errorCode errorInfo tcl_library tcl_patchLevel tcl_pkgPath
-syn keyword tclVars		tcl_platform tcl_precision tcl_rcFileName tcl_traceCompile
-syn keyword tclVars		tcl_traceExec tcl_wordchars tcl_nonwordchars tcl_version argc argv
-syn keyword tclVars		argv0 tcl_interactive geometry
+" Basic Tcl commands: http://www.tcl.tk/man/tcl8.6/TclCmd/contents.htm
+syn keyword tclCommand		after append array bgerror binary cd chan clock close concat
+syn keyword tclCommand		dde dict encoding eof error eval exec exit expr fblocked
+syn keyword tclCommand		fconfigure fcopy file fileevent flush format gets glob
+syn keyword tclCommand		global history http incr info interp join lappend lassign
+syn keyword tclCommand		lindex linsert list llength lmap load lrange lrepeat
+syn keyword tclCommand		lreplace lreverse lsearch lset lsort memory my namespace
+syn keyword tclCommand		next nextto open package pid puts pwd read refchan regexp
+syn keyword tclCommand		registry regsub rename scan seek self set socket source
+syn keyword tclCommand		split string subst tell time trace unknown unload unset
+syn keyword tclCommand		update uplevel upvar variable vwait
+
+" The 'Tcl Standard Library' commands: http://www.tcl.tk/man/tcl8.6/TclCmd/library.htm
+syn keyword tclCommand		auto_execok auto_import auto_load auto_mkindex auto_reset
+syn keyword tclCommand		auto_qualify tcl_findLibrary parray tcl_endOfWord
+syn keyword tclCommand		tcl_startOfNextWord tcl_startOfPreviousWord
+syn keyword tclCommand		tcl_wordBreakAfter tcl_wordBreakBefore
+
+" Global variables used by Tcl: http://www.tcl.tk/man/tcl8.6/TclCmd/tclvars.htm
+syn keyword tclVars		auto_path env errorCode errorInfo tcl_library tcl_patchLevel
+syn keyword tclVars		tcl_pkgPath tcl_platform tcl_precision tcl_rcFileName
+syn keyword tclVars		tcl_traceCompile tcl_traceExec tcl_wordchars
+syn keyword tclVars		tcl_nonwordchars tcl_version argc argv argv0 tcl_interactive
 
 " Strings which expr accepts as boolean values, aside from zero / non-zero.
 syn keyword tclBoolean		true false on off yes no
 
-syn keyword tclLabel		case default
+syn keyword tclProcCommand	apply coroutine proc return tailcall yield yieldto
 syn keyword tclConditional	if then else elseif switch
-syn keyword tclConditional	try finally
+syn keyword tclConditional	catch try throw finally
+syn keyword tclLabel		default
 syn keyword tclRepeat		while for foreach break continue
+
 syn keyword tcltkSwitch	contained	insert create polygon fill outline tag
 
 " WIDGETS
@@ -91,6 +87,11 @@
 	" ${...} may contain any character except '}'
 syn match tclVarRef "${[^}]*}"
 
+" Used to facilitate hack to utilize string background for certain color
+" schemes, e.g. inkpot and lettuce.
+syn cluster tclVarRefC add=tclVarRef
+syn cluster tclSpecialC add=tclSpecial
+
 " The syntactic unquote-splicing replacement for [expand].
 syn match tclExpand '\s{\*}'
 syn match tclExpand '^{\*}'
@@ -203,9 +204,9 @@
 syn region tclEmbeddedStatement	start='\[' end='\]' contained contains=tclCommand,tclNumber,tclLineContinue,tclString,tclVarRef,tclEmbeddedStatement
 " A string needs the skip argument as it may legitimately contain \".
 " Match at start of line
-syn region  tclString		  start=+^"+ end=+"+ contains=tclSpecial skip=+\\\\\|\\"+
+syn region  tclString		  start=+^"+ end=+"+ contains=@tclSpecialC skip=+\\\\\|\\"+
 "Match all other legal strings.
-syn region  tclString		  start=+[^\\]"+ms=s+1  end=+"+ contains=tclSpecial,tclVarRef,tclEmbeddedStatement skip=+\\\\\|\\"+
+syn region  tclString		  start=+[^\\]"+ms=s+1  end=+"+ contains=@tclSpecialC,@tclVarRefC,tclEmbeddedStatement skip=+\\\\\|\\"+
 
 " Line continuation is backslash immediately followed by newline.
 syn match tclLineContinue '\\$'
@@ -231,6 +232,9 @@
 syn region  tclComment		start="^\s*\#" skip="\\$" end="$" contains=tclTodo
 syn region  tclComment		start=/;\s*\#/hs=s+1 skip="\\$" end="$" contains=tclTodo
 
+"syn match tclComment /^\s*\#.*$/
+"syn match tclComment /;\s*\#.*$/hs=s+1
+
 "syn sync ccomment tclComment
 
 " Define the default highlighting.
@@ -252,6 +256,7 @@
   HiLink tclNumber		Number
   HiLink tclError		Error
   HiLink tclCommand		Statement
+  HiLink tclProcCommand		Type
   HiLink tclString		String
   HiLink tclComment		Comment
   HiLink tclSpecial		Special
@@ -279,4 +284,4 @@
 
 let b:current_syntax = "tcl"
 
-" vim: ts=8 noet
+" vim: ts=8 noet nolist
diff -Naur vim74.orig/runtime/syntax/tex.vim vim74/runtime/syntax/tex.vim
--- vim74.orig/runtime/syntax/tex.vim	2013-07-05 16:35:45.000000000 +0000
+++ vim74/runtime/syntax/tex.vim	2014-10-10 14:53:43.385382959 +0000
@@ -1,8 +1,8 @@
 " Vim syntax file
 " Language:	TeX
 " Maintainer:	Charles E. Campbell <NdrchipO@ScampbellPfamily.AbizM>
-" Last Change:	Jun 24, 2013
-" Version:	79
+" Last Change:	Sep 09, 2014
+" Version:	82
 " URL:		http://www.drchip.org/astronaut/vim/index.html#SYNTAX_TEX
 "
 " Notes: {{{1
@@ -28,6 +28,16 @@
 "    lexical error-checking will be done.
 "
 "    ie. let g:tex_no_error=1
+"
+" 6. Please see  :help latex-syntax  for information on
+"      syntax folding           :help tex-folding
+"      spell checking           :help tex-nospell
+"      commands and mathzones   :help tex-runon
+"      new command highlighting :help tex-morecommands
+"      error highlighting       :help tex-error
+"      new math groups          :help tex-math
+"      new styles               :help tex-style
+"      using conceal mode       :help tex-conceal
 
 " Version Clears: {{{1
 " For version 5.x: Clear all syntax items
@@ -78,6 +88,12 @@
 else
  let s:tex_conceal= g:tex_conceal
 endif
+if !exists("g:tex_superscripts")
+ let g:tex_superscripts= "[0-9a-zA-W.,:;+-<>/()=]"
+endif
+if !exists("g:tex_subscripts")
+ let g:tex_subscripts= "[0-9aehijklmnoprstuvx,+-/().]"
+endif
 
 " Determine whether or not to use "*.sty" mode {{{1
 " The user may override the normal determination by setting
@@ -139,7 +155,7 @@
  syn cluster texMatchGroup	contains=texAccent,texBadMath,texComment,texDefCmd,texDelimiter,texDocType,texInput,texLength,texLigature,texMatcher,texNewCmd,texNewEnv,texOnlyMath,texParen,texRefZone,texSection,texSpecialChar,texStatement,texString,texTypeSize,texTypeStyle,texZone,texInputFile,texOption
  syn cluster texStyleGroup	contains=texAccent,texBadMath,texComment,texDefCmd,texDelimiter,texDocType,texInput,texLength,texLigature,texNewCmd,texNewEnv,texOnlyMath,texParen,texRefZone,texSection,texSpecialChar,texStatement,texString,texTypeSize,texTypeStyle,texZone,texInputFile,texOption,texStyleStatement,texStyleMatcher
 endif
-syn cluster texPreambleMatchGroup	contains=texAccent,texBadMath,texComment,texDefCmd,texDelimiter,texDocType,texInput,texLength,texLigature,texMatcher,texNewCmd,texNewEnv,texOnlyMath,texParen,texRefZone,texSection,texSpecialChar,texStatement,texString,texTypeSize,texTypeStyle,texZone,texInputFile,texOption
+syn cluster texPreambleMatchGroup	contains=texAccent,texBadMath,texComment,texDefCmd,texDelimiter,texDocType,texInput,texLength,texLigature,texMatcher,texNewCmd,texNewEnv,texOnlyMath,texParen,texRefZone,texSection,texSpecialChar,texStatement,texString,texTypeSize,texTypeStyle,texZone,texInputFile,texOption,texMathZoneZ
 syn cluster texRefGroup		contains=texMatcher,texComment,texDelimiter
 if !exists("tex_no_math")
  syn cluster texMathZones	contains=texMathZoneV,texMathZoneW,texMathZoneX,texMathZoneY,texMathZoneZ
@@ -321,22 +337,22 @@
 if s:tex_fast =~ 'p'
   if !exists("g:tex_nospell") || !g:tex_nospell
    if g:tex_fold_enabled && has("folding")
-    syn region texDocZone			matchgroup=texSection start='\\begin\s*{\s*document\s*}' end='\\end\s*{\s*document\s*}'											fold contains=@texFoldGroup,@texDocGroup,@Spell
+    syn region texDocZone		matchgroup=texSection start='\\begin\s*{\s*document\s*}' end='\\end\s*{\s*document\s*}'											fold contains=@texFoldGroup,@texDocGroup,@Spell
     syn region texPartZone		matchgroup=texSection start='\\part\>'			 end='\ze\s*\\\%(part\>\|end\s*{\s*document\s*}\)'								fold contains=@texFoldGroup,@texPartGroup,@Spell
     syn region texChapterZone		matchgroup=texSection start='\\chapter\>'		 end='\ze\s*\\\%(chapter\>\|part\>\|end\s*{\s*document\s*}\)'							fold contains=@texFoldGroup,@texChapterGroup,@Spell
     syn region texSectionZone		matchgroup=texSection start='\\section\>'		 end='\ze\s*\\\%(section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'					fold contains=@texFoldGroup,@texSectionGroup,@Spell
-    syn region texSubSectionZone		matchgroup=texSection start='\\subsection\>'		 end='\ze\s*\\\%(\%(sub\)\=section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				fold contains=@texFoldGroup,@texSubSectionGroup,@Spell
+    syn region texSubSectionZone	matchgroup=texSection start='\\subsection\>'		 end='\ze\s*\\\%(\%(sub\)\=section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				fold contains=@texFoldGroup,@texSubSectionGroup,@Spell
     syn region texSubSubSectionZone	matchgroup=texSection start='\\subsubsection\>'		 end='\ze\s*\\\%(\%(sub\)\{,2}section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				fold contains=@texFoldGroup,@texSubSubSectionGroup,@Spell
     syn region texParaZone		matchgroup=texSection start='\\paragraph\>'		 end='\ze\s*\\\%(paragraph\>\|\%(sub\)*section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'			fold contains=@texFoldGroup,@texParaGroup,@Spell
     syn region texSubParaZone		matchgroup=texSection start='\\subparagraph\>'		 end='\ze\s*\\\%(\%(sub\)\=paragraph\>\|\%(sub\)*section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'	fold contains=@texFoldGroup,@Spell
     syn region texTitle			matchgroup=texSection start='\\\%(author\|title\)\>\s*{' end='}'													fold contains=@texFoldGroup,@Spell
     syn region texAbstract		matchgroup=texSection start='\\begin\s*{\s*abstract\s*}' end='\\end\s*{\s*abstract\s*}'											fold contains=@texFoldGroup,@Spell
    else
-    syn region texDocZone			matchgroup=texSection start='\\begin\s*{\s*document\s*}' end='\\end\s*{\s*document\s*}'											contains=@texFoldGroup,@texDocGroup,@Spell
+    syn region texDocZone		matchgroup=texSection start='\\begin\s*{\s*document\s*}' end='\\end\s*{\s*document\s*}'											contains=@texFoldGroup,@texDocGroup,@Spell
     syn region texPartZone		matchgroup=texSection start='\\part\>'			 end='\ze\s*\\\%(part\>\|end\s*{\s*document\s*}\)'								contains=@texFoldGroup,@texPartGroup,@Spell
     syn region texChapterZone		matchgroup=texSection start='\\chapter\>'		 end='\ze\s*\\\%(chapter\>\|part\>\|end\s*{\s*document\s*}\)'							contains=@texFoldGroup,@texChapterGroup,@Spell
     syn region texSectionZone		matchgroup=texSection start='\\section\>'		 end='\ze\s*\\\%(section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'					contains=@texFoldGroup,@texSectionGroup,@Spell
-    syn region texSubSectionZone		matchgroup=texSection start='\\subsection\>'		 end='\ze\s*\\\%(\%(sub\)\=section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				contains=@texFoldGroup,@texSubSectionGroup,@Spell
+    syn region texSubSectionZone	matchgroup=texSection start='\\subsection\>'		 end='\ze\s*\\\%(\%(sub\)\=section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				contains=@texFoldGroup,@texSubSectionGroup,@Spell
     syn region texSubSubSectionZone	matchgroup=texSection start='\\subsubsection\>'		 end='\ze\s*\\\%(\%(sub\)\{,2}section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				contains=@texFoldGroup,@texSubSubSectionGroup,@Spell
     syn region texParaZone		matchgroup=texSection start='\\paragraph\>'		 end='\ze\s*\\\%(paragraph\>\|\%(sub\)*section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'			contains=@texFoldGroup,@texParaGroup,@Spell
     syn region texSubParaZone		matchgroup=texSection start='\\subparagraph\>'		 end='\ze\s*\\\%(\%(sub\)\=paragraph\>\|\%(sub\)*section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'	contains=@texFoldGroup,@Spell
@@ -345,22 +361,22 @@
    endif
   else
    if g:tex_fold_enabled && has("folding")
-    syn region texDocZone			matchgroup=texSection start='\\begin\s*{\s*document\s*}' end='\\end\s*{\s*document\s*}'											fold contains=@texFoldGroup,@texDocGroup
+    syn region texDocZone		matchgroup=texSection start='\\begin\s*{\s*document\s*}' end='\\end\s*{\s*document\s*}'											fold contains=@texFoldGroup,@texDocGroup
     syn region texPartZone		matchgroup=texSection start='\\part\>'			 end='\ze\s*\\\%(part\>\|end\s*{\s*document\s*}\)'								fold contains=@texFoldGroup,@texPartGroup
     syn region texChapterZone		matchgroup=texSection start='\\chapter\>'		 end='\ze\s*\\\%(chapter\>\|part\>\|end\s*{\s*document\s*}\)'							fold contains=@texFoldGroup,@texChapterGroup
     syn region texSectionZone		matchgroup=texSection start='\\section\>'		 end='\ze\s*\\\%(section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'					fold contains=@texFoldGroup,@texSectionGroup
-    syn region texSubSectionZone		matchgroup=texSection start='\\subsection\>'		 end='\ze\s*\\\%(\%(sub\)\=section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				fold contains=@texFoldGroup,@texSubSectionGroup
+    syn region texSubSectionZone	matchgroup=texSection start='\\subsection\>'		 end='\ze\s*\\\%(\%(sub\)\=section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				fold contains=@texFoldGroup,@texSubSectionGroup
     syn region texSubSubSectionZone	matchgroup=texSection start='\\subsubsection\>'		 end='\ze\s*\\\%(\%(sub\)\{,2}section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				fold contains=@texFoldGroup,@texSubSubSectionGroup
     syn region texParaZone		matchgroup=texSection start='\\paragraph\>'		 end='\ze\s*\\\%(paragraph\>\|\%(sub\)*section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'			fold contains=@texFoldGroup,@texParaGroup
     syn region texSubParaZone		matchgroup=texSection start='\\subparagraph\>'		 end='\ze\s*\\\%(\%(sub\)\=paragraph\>\|\%(sub\)*section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'	fold contains=@texFoldGroup
     syn region texTitle			matchgroup=texSection start='\\\%(author\|title\)\>\s*{' end='}'													fold contains=@texFoldGroup
     syn region texAbstract		matchgroup=texSection start='\\begin\s*{\s*abstract\s*}' end='\\end\s*{\s*abstract\s*}'											fold contains=@texFoldGroup
    else
-    syn region texDocZone			matchgroup=texSection start='\\begin\s*{\s*document\s*}' end='\\end\s*{\s*document\s*}'											contains=@texFoldGroup,@texDocGroup
+    syn region texDocZone		matchgroup=texSection start='\\begin\s*{\s*document\s*}' end='\\end\s*{\s*document\s*}'											contains=@texFoldGroup,@texDocGroup
     syn region texPartZone		matchgroup=texSection start='\\part\>'			 end='\ze\s*\\\%(part\>\|end\s*{\s*document\s*}\)'								contains=@texFoldGroup,@texPartGroup
     syn region texChapterZone		matchgroup=texSection start='\\chapter\>'		 end='\ze\s*\\\%(chapter\>\|part\>\|end\s*{\s*document\s*}\)'							contains=@texFoldGroup,@texChapterGroup
     syn region texSectionZone		matchgroup=texSection start='\\section\>'		 end='\ze\s*\\\%(section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'					contains=@texFoldGroup,@texSectionGroup
-    syn region texSubSectionZone		matchgroup=texSection start='\\subsection\>'		 end='\ze\s*\\\%(\%(sub\)\=section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				contains=@texFoldGroup,@texSubSectionGroup
+    syn region texSubSectionZone	matchgroup=texSection start='\\subsection\>'		 end='\ze\s*\\\%(\%(sub\)\=section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				contains=@texFoldGroup,@texSubSectionGroup
     syn region texSubSubSectionZone	matchgroup=texSection start='\\subsubsection\>'		 end='\ze\s*\\\%(\%(sub\)\{,2}section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'				contains=@texFoldGroup,@texSubSubSectionGroup
     syn region texParaZone		matchgroup=texSection start='\\paragraph\>'		 end='\ze\s*\\\%(paragraph\>\|\%(sub\)*section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'			contains=@texFoldGroup,@texParaGroup
     syn region texSubParaZone		matchgroup=texSection start='\\subparagraph\>'		 end='\ze\s*\\\%(\%(sub\)\=paragraph\>\|\%(sub\)*section\>\|chapter\>\|part\>\|end\s*{\s*document\s*}\)'	contains=@texFoldGroup
@@ -610,7 +626,7 @@
   syn region texRefZone		matchgroup=texStatement start="\\\(page\|eq\)ref{"	end="}\|%stopzone\>"	contains=@texRefGroup
   syn region texRefZone		matchgroup=texStatement start="\\v\=ref{"		end="}\|%stopzone\>"	contains=@texRefGroup
   syn region texRefOption	contained	matchgroup=Delimiter start='\[' end=']'		contains=@texRefGroup,texRefZone	nextgroup=texRefOption,texCite
-  syn region texCite	contained	matchgroup=Delimiter start='{' end='}'		contains=@texRefGroup,texRefZone,texCite
+  syn region texCite		contained	matchgroup=Delimiter start='{' end='}'		contains=@texRefGroup,texRefZone,texCite
 endif
 syn match  texRefZone		'\\cite\%([tp]\*\=\)\=' nextgroup=texRefOption,texCite
 
@@ -1035,8 +1051,11 @@
    syn region texSubscript	matchgroup=Delimiter start='_{'		skip="\\\\\|\\[{}]" end='}'	contained concealends contains=texSpecialChar,texSubscripts,texStatement,texSubscript,texSuperscript,texMathMatcher
   endif
   fun! s:SuperSub(group,leader,pat,cchar)
-    exe 'syn match '.a:group." '".a:leader.a:pat."' contained conceal cchar=".a:cchar
-    exe 'syn match '.a:group."s '".a:pat."' contained conceal cchar=".a:cchar.' nextgroup='.a:group.'s'
+    if a:pat =~ '^\\' || (a:leader == '\^' && a:pat =~ g:tex_superscripts) || (a:leader == '_' && a:pat =~ g:tex_subscripts)
+"     call Decho("SuperSub: group<".a:group."> leader<".a:leader."> pat<".a:pat."> cchar<".a:cchar.">")
+     exe 'syn match '.a:group." '".a:leader.a:pat."' contained conceal cchar=".a:cchar
+     exe 'syn match '.a:group."s '".a:pat."' contained conceal cchar=".a:cchar.' nextgroup='.a:group.'s'
+    endif
   endfun
   call s:SuperSub('texSuperscript','\^','0','')
   call s:SuperSub('texSuperscript','\^','1','')
@@ -1144,7 +1163,7 @@
   else
    fun! s:Accents(chr,...)
      let i= 1
-     for accent in ["`","\\'","^",'"','\~','\.',"c","H","k","r","u","v"]
+     for accent in ["`","\\'","^",'"','\~','\.','=',"c","H","k","r","u","v"]
       if i > a:0
        break
       endif
@@ -1160,46 +1179,46 @@
       let i= i + 1
      endfor
    endfun
-   "                  \`  \'  \^  \"  \~  \.  \c  \H  \k  \r  \u  \v
-   call s:Accents('a','','','','','','',' ',' ','','','','')
-   call s:Accents('A','','','','','','',' ',' ','','','','')
-   call s:Accents('c',' ','','',' ',' ','','',' ',' ',' ',' ','')
-   call s:Accents('C',' ','','',' ',' ','','',' ',' ',' ',' ','')
-   call s:Accents('d',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
-   call s:Accents('D',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
-   call s:Accents('e','','','','','','','',' ','',' ','','')
-   call s:Accents('E','','','','','','','',' ','',' ','','')
-   call s:Accents('g',' ','','',' ',' ','','',' ',' ',' ','',' ')
-   call s:Accents('G',' ','','',' ',' ','','',' ',' ',' ','',' ')
-   call s:Accents('h',' ',' ','',' ',' ',' ',' ',' ',' ',' ',' ','')
-   call s:Accents('H',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
-   call s:Accents('i','','','','','','',' ',' ',' ',' ','',' ')
-   call s:Accents('I','','','','','','',' ',' ',' ',' ','',' ')
-   call s:Accents('J',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
-   call s:Accents('k',' ',' ',' ',' ',' ',' ','',' ',' ',' ',' ',' ')
-   call s:Accents('K',' ',' ',' ',' ',' ',' ','',' ',' ',' ',' ',' ')
-   call s:Accents('l',' ','','',' ',' ',' ','',' ',' ',' ',' ','')
-   call s:Accents('L',' ','','',' ',' ',' ','',' ',' ',' ',' ','')
-   call s:Accents('n',' ','',' ',' ','',' ','',' ',' ',' ',' ','')
-   call s:Accents('N',' ','',' ',' ','',' ','',' ',' ',' ',' ','')
-   call s:Accents('o','','','','','','',' ','','',' ','',' ')
-   call s:Accents('O','','','','','','',' ','','',' ','',' ')
-   call s:Accents('r',' ','',' ',' ',' ',' ','',' ',' ',' ',' ','')
-   call s:Accents('R',' ','',' ',' ',' ',' ','',' ',' ',' ',' ','')
-   call s:Accents('s',' ','','',' ',' ',' ','',' ','',' ',' ','')
-   call s:Accents('S',' ','','',' ',' ',' ','',' ',' ',' ',' ','')
-   call s:Accents('t',' ',' ',' ',' ',' ',' ','',' ',' ',' ',' ','')
-   call s:Accents('T',' ',' ',' ',' ',' ',' ','',' ',' ',' ',' ','')
-   call s:Accents('u','','','','','',' ',' ','','','','','')
-   call s:Accents('U','','','','','',' ',' ','','','','','')
-   call s:Accents('w',' ',' ','',' ',' ',' ',' ',' ',' ',' ',' ',' ')
-   call s:Accents('W',' ',' ','',' ',' ',' ',' ',' ',' ',' ',' ',' ')
-   call s:Accents('y','','','','','',' ',' ',' ',' ',' ',' ',' ')
-   call s:Accents('Y','','','','','',' ',' ',' ',' ',' ',' ',' ')
-   call s:Accents('z',' ','',' ',' ',' ','',' ',' ',' ',' ',' ','')
-   call s:Accents('Z',' ','',' ',' ',' ','',' ',' ',' ',' ',' ','')
-   call s:Accents('\\i','','','','','','',' ',' ',' ',' ','',' ')
-   "                  \`  \'  \^  \"  \~  \.  \c  \H  \k  \r  \u  \v
+   "                  \`  \'  \^  \"  \~  \.  \=  \c  \H  \k  \r  \u  \v
+   call s:Accents('a','','','','','','','',' ',' ','','','','')
+   call s:Accents('A','','','','','','','',' ',' ','','','','')
+   call s:Accents('c',' ','','',' ',' ','',' ','',' ',' ',' ',' ','')
+   call s:Accents('C',' ','','',' ',' ','',' ','',' ',' ',' ',' ','')
+   call s:Accents('d',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
+   call s:Accents('D',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
+   call s:Accents('e','','','','','','','','',' ','',' ','','')
+   call s:Accents('E','','','','','','','','',' ','',' ','','')
+   call s:Accents('g',' ','','',' ',' ','',' ','',' ',' ',' ','','')
+   call s:Accents('G',' ','','',' ',' ','',' ','',' ',' ',' ','','')
+   call s:Accents('h',' ',' ','',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
+   call s:Accents('H',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
+   call s:Accents('i','','','','','','','',' ',' ','',' ','','')
+   call s:Accents('I','','','','','','','',' ',' ','',' ','','')
+   call s:Accents('J',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','')
+   call s:Accents('k',' ',' ',' ',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('K',' ',' ',' ',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('l',' ','','',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('L',' ','','',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('n',' ','',' ',' ','',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('N',' ','',' ',' ','',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('o','','','','','','','',' ','','',' ','','')
+   call s:Accents('O','','','','','','','',' ','','',' ','','')
+   call s:Accents('r',' ','',' ',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('R',' ','',' ',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('s',' ','','',' ',' ',' ',' ','',' ','',' ',' ','')
+   call s:Accents('S',' ','','',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('t',' ',' ',' ',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('T',' ',' ',' ',' ',' ',' ',' ','',' ',' ',' ',' ','')
+   call s:Accents('u','','','','','',' ','',' ','','','','','')
+   call s:Accents('U','','','','','',' ','',' ','','','','','')
+   call s:Accents('w',' ',' ','',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ')
+   call s:Accents('W',' ',' ','',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ')
+   call s:Accents('y','','','','','',' ',' ',' ',' ',' ',' ',' ',' ')
+   call s:Accents('Y','','','','','',' ',' ',' ',' ',' ',' ',' ',' ')
+   call s:Accents('z',' ','',' ',' ',' ','',' ',' ',' ',' ',' ',' ','')
+   call s:Accents('Z',' ','',' ',' ',' ','',' ',' ',' ',' ',' ',' ','')
+   call s:Accents('\\i','','','','','','',' ',' ',' ',' ',' ','',' ')
+   "                    \`  \'  \^  \"  \~  \.  \=  \c  \H  \k  \r  \u  \v
    delfun s:Accents
    syn match texAccent   '\\aa\>'	conceal cchar=
    syn match texAccent   '\\AA\>'	conceal cchar=
@@ -1242,7 +1261,7 @@
 if did_tex_syntax_inits == 1
  let did_tex_syntax_inits= 2
   " TeX highlighting groups which should share similar highlighting
-  if !exists("s:tex_no_error")
+  if !exists("g:tex_no_error")
    if !exists("g:tex_no_math")
     HiLink texBadMath		texError
     HiLink texMathDelimBad	texError
diff -Naur vim74.orig/runtime/syntax/upstreamlog.vim vim74/runtime/syntax/upstreamlog.vim
--- vim74.orig/runtime/syntax/upstreamlog.vim	2013-08-03 15:47:26.000000000 +0000
+++ vim74/runtime/syntax/upstreamlog.vim	2014-10-10 14:53:43.442049484 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:             Innovation Data Processing upstream.log file
 " Maintainer:           Rob Owens <rowens@fdrinnovation.com>
-" Latest Revision:      2013-07-26
+" Latest Revision:      2013-09-19
 
 " Quit when a syntax file was already loaded
 if exists("b:current_syntax")
@@ -31,13 +31,14 @@
 syn match upstreamlog_Profile /  Profile: \zs\S\{1,8}\ze, /
 syn match upstreamlog_Profile /, profile: \zs\S\{1,8}\ze,/
 syn match upstreamlog_Profile /found Profile: \zs\S\{1,8}\ze,/
-syn match upstreamlog_Profile /Backup Profile: \zs\ze Version date/
+syn match upstreamlog_Profile /Backup Profile: \zs\S\{1,8}\ze Version date/
+syn match upstreamlog_Profile /Backup profile: \zs\S\{1,8}\ze  Version date/
 syn match upstreamlog_Profile /Full of \zs\S\{1,8}\ze$/
 syn match upstreamlog_Profile /Incr. of \zs\S\{1,8}\ze$/
 syn match upstreamlog_Profile /Profile=\zs\S\{1,8}\ze,/
 " Target:
 syn region upstreamlog_Target start="Computer: \zs" end="\ze[\]\)]" 
-syn region upstreamlog_Target start="Computer name \zs" end="\ze," 
+syn region upstreamlog_Target start="Computer name \zs\"" end="\"\ze" 
 syn region upstreamlog_Target start="request to registered name \zs" end=" "
 
 
diff -Naur vim74.orig/runtime/syntax/usserverlog.vim vim74/runtime/syntax/usserverlog.vim
--- vim74.orig/runtime/syntax/usserverlog.vim	2013-08-03 15:47:26.000000000 +0000
+++ vim74/runtime/syntax/usserverlog.vim	2014-10-10 14:53:43.445382809 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:             Innovation Data Processing usserver.log file
 " Maintainer:           Rob Owens <rowens@fdrinnovation.com>
-" Latest Revision:      2013-07-26
+" Latest Revision:      2013-09-19
 
 " Quit when a syntax file was already loaded
 if exists("b:current_syntax")
@@ -36,13 +36,14 @@
 syn match usserverlog_Profile /Expecting Profile: \zs\S\{1,8}\ze,/
 syn match usserverlog_Profile /found Profile: \zs\S\{1,8}\ze,/
 syn match usserverlog_Profile /Profile \zs\S\{1,8} \zeis a member of group: /
-syn match usserverlog_Profile /Backup Profile: \zs\ze Version date/
+syn match upstreamlog_Profile /Backup Profile: \zs\S\{1,8}\ze Version date/
+syn match upstreamlog_Profile /Backup profile: \zs\S\{1,8}\ze  Version date/
 syn match usserverlog_Profile /Full of \zs\S\{1,8}\ze$/
 syn match usserverlog_Profile /Incr. of \zs\S\{1,8}\ze$/
 syn match usserverlog_Profile /Profile=\zs\S\{1,8}\ze,/
 " Target:
 syn region usserverlog_Target start="Computer: \zs" end="\ze[\]\)]" 
-syn region usserverlog_Target start="Computer name \zs" end="\ze," 
+syn region usserverlog_Target start="Computer name \zs\"" end="\"\ze" 
 syn region usserverlog_Target start="Registration add request successful \zs" end="$"
 syn region usserverlog_Target start="request to registered name \zs" end=" "
 syn region usserverlog_Target start=", sending to \zs" end="$"
diff -Naur vim74.orig/runtime/syntax/usw2kagtlog.vim vim74/runtime/syntax/usw2kagtlog.vim
--- vim74.orig/runtime/syntax/usw2kagtlog.vim	2013-08-03 15:47:26.000000000 +0000
+++ vim74/runtime/syntax/usw2kagtlog.vim	2014-10-10 14:53:43.445382809 +0000
@@ -1,7 +1,7 @@
 " Vim syntax file
 " Language:             Innovation Data Processing USW2KAgt.log file
 " Maintainer:           Rob Owens <rowens@fdrinnovation.com>
-" Latest Revision:      2013-07-26
+" Latest Revision:      2013-09-19
 
 " Quit when a syntax file was already loaded
 if exists("b:current_syntax")
@@ -26,13 +26,14 @@
 syn match usw2kagtlog_Profile /Profile name \zs\"\S\{1,8}\"/
 syn match usw2kagtlog_Profile / Profile: \zs\S\{1,8}/
 syn match usw2kagtlog_Profile /  Profile: \zs\S\{1,8}\ze, /
-syn match usw2kagtlog_Profile /Backup Profile: \zs\ze Version date/
+syn match upstreamlog_Profile /Backup Profile: \zs\S\{1,8}\ze Version date/
+syn match upstreamlog_Profile /Backup profile: \zs\S\{1,8}\ze  Version date/
 syn match usw2kagtlog_Profile /Full of \zs\S\{1,8}\ze$/
 syn match usw2kagtlog_Profile /Incr. of \zs\S\{1,8}\ze$/
 syn match usw2kagtlog_Profile /profile name "\zs\S\{1,8}\ze"/
 " Target:
 syn region usw2kagtlog_Target start="Computer: \zs" end="\ze[\]\)]" 
-syn region usw2kagtlog_Target start="Computer name \zs" end="\ze," 
+syn region usw2kagtlog_Target start="Computer name \zs\"" end="\"\ze" 
 " Agent Keywords:
 syn keyword usw2kagtlog_Agentword opened closed
 
diff -Naur vim74.orig/runtime/syntax/valgrind.vim vim74/runtime/syntax/valgrind.vim
--- vim74.orig/runtime/syntax/valgrind.vim	2012-04-30 11:03:36.000000000 +0000
+++ vim74/runtime/syntax/valgrind.vim	2014-10-10 14:53:43.445382809 +0000
@@ -2,9 +2,11 @@
 " Language: Valgrind Memory Debugger Output
 " Maintainer: Roger Luethi <rl@hellgate.ch>
 " Program URL: http://devel-home.kde.org/~sewardj/
-" Last Change: 2012 Apr 30
+" Last Change: 2014 Oct 02
 "
 " Notes: mostly based on strace.vim and xml.vim
+"
+" Contributors: Christoph Gysin <christoph.gysin@gmail.com>
 
 " Quit when a syntax file was already loaded
 if exists("b:current_syntax")
@@ -65,7 +67,7 @@
 syn match valgrindAddr "\(\W\)\@<=0x\x\+" contained
 syn match valgrindFunc "\(: \)\@<=\w\+" contained
 syn match valgrindBin "\((\(with\|\)in \)\@<=\S\+\()\)\@=" contained
-syn match valgrindSrc "\((\)\@<=.*:\d\+\()\)\@=" contained
+syn match valgrindSrc "\((\)\@<=[^)]*:\d\+\()\)\@=" contained
 
 " Define the default highlighting
 
diff -Naur vim74.orig/runtime/syntax/vhdl.vim vim74/runtime/syntax/vhdl.vim
--- vim74.orig/runtime/syntax/vhdl.vim	2012-06-01 16:05:47.000000000 +0000
+++ vim74/runtime/syntax/vhdl.vim	2014-10-10 14:53:43.458716109 +0000
@@ -1,12 +1,12 @@
 " Vim syntax file
 " Language:	VHDL
-" Maintainer:	Czo <Olivier.Sirol@lip6.fr>
+" Maintainer:	Daniel Kho <daniel.kho@tauhop.com>
+" Previous Maintainer:	Czo <Olivier.Sirol@lip6.fr>
 " Credits:	Stephan Hegel <stephan.hegel@snc.siemens.com.cn>
-" Last Change:	2012 Jun 01
-" 		(Dominique Pelle added @Spell)
+" Last Changed:	2012 Feb 03 by Thilo Six
+" $Id: vhdl.vim,v 1.1 2004/06/13 15:34:56 vimboss Exp $
 
-" VHSIC Hardware Description Language
-" Very High Scale Integrated Circuit
+" VHSIC (Very High Speed Integrated Circuit) Hardware Description Language
 
 " For version 5.x: Clear all syntax items
 " For version 6.x: Quit when a syntax file was already loaded
@@ -22,8 +22,8 @@
 " This is not VHDL. I use the C-Preprocessor cpp to generate different binaries
 " from one VHDL source file. Unfortunately there is no preprocessor for VHDL
 " available. If you don't like this, please remove the following lines.
-syn match cDefine "^#ifdef[ ]\+[A-Za-z_]\+"
-syn match cDefine "^#endif"
+"syn match cDefine "^#ifdef[ ]\+[A-Za-z_]\+"
+"syn match cDefine "^#endif"
 
 " case is not significant
 syn case ignore
@@ -31,11 +31,14 @@
 " VHDL keywords
 syn keyword vhdlStatement access after alias all assert
 syn keyword vhdlStatement architecture array attribute
+syn keyword vhdlStatement assume assume_guarantee
 syn keyword vhdlStatement begin block body buffer bus
 syn keyword vhdlStatement case component configuration constant
-syn keyword vhdlStatement disconnect downto
+syn keyword vhdlStatement context cover
+syn keyword vhdlStatement default disconnect downto
 syn keyword vhdlStatement elsif end entity exit
 syn keyword vhdlStatement file for function
+syn keyword vhdlStatement fairness force
 syn keyword vhdlStatement generate generic group guarded
 syn keyword vhdlStatement impure in inertial inout is
 syn keyword vhdlStatement label library linkage literal loop
@@ -43,12 +46,17 @@
 syn keyword vhdlStatement new next null
 syn keyword vhdlStatement of on open others out
 syn keyword vhdlStatement package port postponed procedure process pure
+syn keyword vhdlStatement parameter property protected
 syn keyword vhdlStatement range record register reject report return
+syn keyword vhdlStatement release restrict restrict_guarantee
 syn keyword vhdlStatement select severity signal shared
 syn keyword vhdlStatement subtype
+syn keyword vhdlStatement sequence strong
 syn keyword vhdlStatement then to transport type
 syn keyword vhdlStatement unaffected units until use
-syn keyword vhdlStatement variable wait when while with
+syn keyword vhdlStatement variable
+syn keyword vhdlStatement vmode vprop vunit
+syn keyword vhdlStatement wait when while with
 syn keyword vhdlStatement note warning error failure
 
 " Special match for "if" and "else" since "else if" shouldn't be highlighted.
@@ -60,6 +68,7 @@
 " Predefined VHDL types
 syn keyword vhdlType bit bit_vector
 syn keyword vhdlType character boolean integer real time
+syn keyword vhdlType boolean_vector integer_vector real_vector time_vector
 syn keyword vhdlType string severity_level
 " Predefined standard ieee VHDL types
 syn keyword vhdlType positive natural signed unsigned
@@ -67,11 +76,11 @@
 syn keyword vhdlType std_logic std_logic_vector
 syn keyword vhdlType std_ulogic std_ulogic_vector
 " Predefined non standard VHDL types for Mentor Graphics Sys1076/QuickHDL
-syn keyword vhdlType qsim_state qsim_state_vector
-syn keyword vhdlType qsim_12state qsim_12state_vector
-syn keyword vhdlType qsim_strength
+"syn keyword vhdlType qsim_state qsim_state_vector
+"syn keyword vhdlType qsim_12state qsim_12state_vector
+"syn keyword vhdlType qsim_strength
 " Predefined non standard VHDL types for Alliance VLSI CAD
-syn keyword vhdlType mux_bit mux_vector reg_bit reg_vector wor_bit wor_vector
+"syn keyword vhdlType mux_bit mux_vector reg_bit reg_vector wor_bit wor_vector
 
 " array attributes
 syn match vhdlAttribute "\'high"
@@ -122,14 +131,14 @@
 " Values for standard VHDL types
 syn match vhdlVector "\'[0L1HXWZU\-\?]\'"
 " Values for non standard VHDL types qsim_12state for Mentor Graphics Sys1076/QuickHDL
-syn keyword vhdlVector S0S S1S SXS S0R S1R SXR S0Z S1Z SXZ S0I S1I SXI
+"syn keyword vhdlVector S0S S1S SXS S0R S1R SXR S0Z S1Z SXZ S0I S1I SXI
 syn case ignore
 
 syn match  vhdlVector "B\"[01_]\+\""
 syn match  vhdlVector "O\"[0-7_]\+\""
 syn match  vhdlVector "X\"[0-9a-f_]\+\""
 syn match  vhdlCharacter "'.'"
-syn region vhdlString start=+"+  end=+"+ contains=@Spell
+syn region vhdlString start=+"+  end=+"+
 
 " floating numbers
 syn match vhdlNumber "-\=\<\d\+\.\d\+\(E[+\-]\=\d\+\)\>"
@@ -151,9 +160,15 @@
 syn match vhdlTime "\<\d\+\s\+\(\([fpnum]s\)\|\(sec\)\|\(min\)\|\(hr\)\)\>"
 syn match vhdlTime "\<\d\+\.\d\+\s\+\(\([fpnum]s\)\|\(sec\)\|\(min\)\|\(hr\)\)\>"
 
-syn match vhdlComment "--.*$" contains=@Spell
+syn keyword vhdlTodo contained TODO FIXME
+
+syn region vhdlComment start="/\*" end="\*/" contains=vhdlTodo,@Spell
+syn match vhdlComment "--.*" contains=vhdlTodo,@Spell
 " syn match vhdlGlobal "[\'$#~!%@?\^\[\]{}\\]"
 
+"Modify the following as needed.  The trade-off is performance versus functionality.
+syn sync minlines=200
+
 " Define the default highlighting.
 " For version 5.7 and earlier: only when not done already
 " For version 5.8 and later: only when an item doesn't have highlighting yet
@@ -165,19 +180,20 @@
     command -nargs=+ HiLink hi def link <args>
   endif
 
-  HiLink cDefine       PreProc
+"  HiLink cDefine       PreProc
   HiLink vhdlSpecial   Special
   HiLink vhdlStatement Statement
-  HiLink vhdlCharacter String
+  HiLink vhdlCharacter Character
   HiLink vhdlString    String
-  HiLink vhdlVector    String
-  HiLink vhdlBoolean   String
+  HiLink vhdlVector    Number
+  HiLink vhdlBoolean   Number
+  HiLink vhdlTodo      Todo
   HiLink vhdlComment   Comment
-  HiLink vhdlNumber    String
-  HiLink vhdlTime      String
+  HiLink vhdlNumber    Number
+  HiLink vhdlTime      Number
   HiLink vhdlType      Type
-  HiLink vhdlOperator  Type
-  HiLink vhdlGlobal    Error
+  HiLink vhdlOperator  Special
+"  HiLink vhdlGlobal    Error
   HiLink vhdlAttribute Type
 
   delcommand HiLink
diff -Naur vim74.orig/runtime/syntax/vim.vim vim74/runtime/syntax/vim.vim
--- vim74.orig/runtime/syntax/vim.vim	2013-07-05 16:35:45.000000000 +0000
+++ vim74/runtime/syntax/vim.vim	2014-10-10 14:53:43.472049408 +0000
@@ -1,8 +1,8 @@
 " Vim syntax file
-" Language:	Vim 7.3 script
-" Maintainer:	Dr. Charles E. Campbell, Jr. <NdrOchipS@PcampbellAfamily.Mbiz>
-" Last Change:	Jul 05, 2013
-" Version:	7.3-26
+" Language:	Vim 7.4 script
+" Maintainer:	Charles E. Campbell <NdrOchipS@PcampbellAfamily.Mbiz>
+" Last Change:	Mar 20, 2014
+" Version:	7.4-27
 " Automatically generated keyword lists: {{{1
 
 " Quit when a syntax file was already loaded {{{2
@@ -14,40 +14,40 @@
 
 " vimTodo: contains common special-notices for comments {{{2
 " Use the vimCommentGroup cluster to add your own.
-syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
 syn cluster vimCommentGroup	contains=vimTodo,@Spell
 
 " regular vim commands {{{2
-syn keyword vimCommand contained	a arga[dd] ar[gs] bar bn[ext] breaka[dd] bu bw[ipeout] caddf[ile] cd cgete[xpr] checkt[ime] cmdname cnf com con[tinue] cq[uit] cw[indow] delc[ommand] diffg[et] diffpu[t] dig[raphs] dr[op] earlier el[se] endfo[r] ene[w] filename fin[d] folddoc[losed] fu[nction] gui helpg[rep] ia in j[oin] kee[pmarks] laddf[ile] lb[uffer] le[ft] lgetb[uffer] l[ist] lN lNf lo[adview] lpf[ile] luado mak[e] menut[ranslate] mks[ession] mod[e] n new noautocmd on[ly] pc[lose] popu p[rint] promptr[epl] ptn pts[elect] py[thon] quote redi[r] res[ize] ru rv[iminfo] sbf[irst] sbr[ewind] scscope sfir[st] sim[alt] sme snoreme spe spellw[rong] star st[op] sunmenu syn ta tabf[ind] tabnew tabr[ewind] tcld[o] tj[ump] tN tp[revious] tu u[ndo] unlo[ckvar] verb[ose] vim[grep] vne[w] win wn[ext] w[rite] xa[ll] XMLent xunme
-syn keyword vimCommand contained	ab argd[elete] argu[ment] bd[elete] bN[ext] breakd[el] buf c cal[l] ce[nter] cg[etfile] cl cn cNf comc[lear] cope[n] cr[ewind] d d[elete] diffo diffsplit di[splay] ds[earch] ec elsei[f] endfun ex files fini[sh] foldd[oopen] g gvim helpt[ags] iabc[lear] index ju[mps] l lan lc[d] lefta[bove] lgete[xpr] ll lne lnf[ile] locale lp[revious] luafile Man mes mksp[ell] m[ove] N n[ext] noh[lsearch] o[pen] pe popu[p] P[rint] ps[earch] ptN pu[t] python3 r red[o] ret[ab] rub[y] sal[l] sbl[ast] sb[uffer] se[t] sh[ell] sl smenu snoremenu spelld[ump] sp[lit] start stopi[nsert] sus[pend] sync tab tabfir[st] tabn[ext] tabs tclf[ile] tl[ast] tn[ext] tr tu[nmenu] undoj[oin] uns[ilent] ve[rsion] vimgrepa[dd] vs[plit] winc[md] wN[ext] ws[verb] x[it] XMLns xunmenu
-syn keyword vimCommand contained	abc[lear] argdo as[cii] bel[owright] bo[tright] breakl[ist] bufdo cabc[lear] cat[ch] cex[pr] c[hange] cla[st] cN cnf[ile] comment co[py] cs de delf diffoff difft dj[ump] dsp[lit] echoe[rr] em[enu] endf[unction] exi[t] filet fir[st] foldo[pen] get h hi if intro k la lan[guage] lch[dir] let@ lg[etfile] lla[st] lnew[er] lNf[ile] loc[kmarks] lr[ewind] lv[imgrep] ma[rk] messages mkv mv nbc[lose] N[ext] nu[mber] opt[ions] ped[it] pp[op] pro pta[g] ptn[ext] pw[d] q re redr[aw] retu[rn] rubyd[o] san[dbox] sbm[odified] scrip setf[iletype] si sla[st] sn[ext] s@\n@\=\r" spe[llgood] spr[evious] startg[replace] sts[elect] sv[iew] syncbind tabc[lose] tabl[ast] tabN[ext] ta[g] te[aroff] tm tN[ext] tr[ewind] u undol[ist] up[date] vert[ical] vi[sual] w windo wp[revious] wundo xmapc[lear] xnoreme xwininfo
-syn keyword vimCommand contained	abo[veleft] arge[dit] au bf[irst] bp[revious] br[ewind] b[uffer] cad cb[uffer] cf[ile] changes cl[ist] cnew[er] cNf[ile] comp[iler] count cscope debug delf[unction] DiffOrig diffthis dl[ist] dwim echom[sg] emenu* en[dif] exu[sage] filetype fix[del] for go[to] ha[rdcopy] hid[e] ij[ump] is[earch] keepa lad la[st] lcl[ose] lex[pr] lgr[ep] lli[st] lne[xt] lo lockv[ar] ls lvimgrepa[dd] marks mk mkvie[w] mz nb[key] nkf o ownsyntax pe[rl] pr profd[el] ptf[irst] ptN[ext] py qa[ll] r[ead] redraws[tatus] rew[ind] rubyf[ile] sa[rgument] sbn[ext] scripte[ncoding] setg[lobal] sig sl[eep] sN[ext] so spelli[nfo] sre[wind] star[tinsert] sun[hide] sw[apname] synlist tabd[o] tabm[ove] tabo[nly] tags tf[irst] tm[enu] TOhtml try un unh[ide] v vi viu[sage] wa[ll] winp[os] wq wv[iminfo] xme xnoremenu y[ank]
-syn keyword vimCommand contained	al[l] argg[lobal] bad[d] bl[ast] br bro[wse] buffers caddb[uffer] cc cfir[st] chd[ir] clo[se] cn[ext] col[der] con cpf[ile] cstag debugg[reedy] delm[arks] diffp diffu[pdate] do e echon en endt[ry] f fin fo[ld] fu gr[ep] h[elp] his[tory] il[ist] isp[lit] keepalt laddb[uffer] lat lcs lf[ile] lgrepa[dd] lmak[e] lN[ext] loadk lol[der] lt[ag] lw[indow] mat[ch] mkdir mkv[imrc] mzf[ile] nbs[tart] nmapc[lear] ol[dfiles] p perld[o] pre[serve] prof[ile] ptj[ump] ptp[revious] py3 q[uit] rec[over] reg[isters] ri[ght] rundo sav[eas] sbN[ext] scrip[tnames] setl[ocal] sign sm[agic] sni[ff] sor[t] spellr[epall] st startr[eplace] sunme sy t tabe[dit] tabN tabp[revious] tc[l] th[row] tn to[pleft] ts[elect] una[bbreviate] unl ve vie[w] vmapc[lear] wh[ile] win[size] wqa[ll] x xmenu xterm errormsg
-syn keyword vimCommand contained	ar argl[ocal] ba[ll] bm[odified] brea[k] browseset bun[load] cad[dexpr] ccl[ose] cgetb[uffer] che[ckpath] cmapc[lear] cN[ext] colo[rscheme] conf[irm] cp[revious] cuna[bbrev] del di diffpatch dig doau ea e[dit] endf endw[hile] f[ile] fina[lly] foldc[lose] fun grepa[dd] helpf[ind] i imapc[lear] iuna[bbrev] keepj[umps] lad[dexpr] later lcscope lfir[st] lh[elpgrep] lmapc[lear] lnf loadkeymap lop[en] lua ma menut mk[exrc] mo mz[scheme] ne noa omapc[lear] P po[p] prev[ious] promptf[ind] ptl[ast] ptr[ewind] pyf[ile] quita[ll] red Ren rightb[elow] ru[ntime] sba[ll] sbp[revious] scs sf[ind] sil[ent] sm[ap] sno[magic] so[urce] spellu[ndo] sta[g] stj[ump] 
+syn keyword vimCommand contained	a arga[dd] ar[gs] bd[elete] bN[ext] breakd[el] bufdo cabc[lear] cat[ch] cex[pr] c[hange] cla[st] cnew[er] cNf[ile] con cp[revious] cuna[bbrev] del deletep delm[arks] diffp[atch] dig[raphs] do e echon endf endw[hile] f[ile] fin[d] folddoc[losed] fu[nction] gvim helpt[ags] iabc[lear] intro k l lan lc[d] lefta[bove] lg[etfile] lla[st] lnew[er] lNf[ile] lockv[ar] ls lvimgrepa[dd] mat[ch] mk[exrc] mo n n[ext] o ownsyntax perld[o] pre[serve] promptf[ind] ptl[ast] ptr[ewind] py3do qa[ll] r[ead] redr[aw] retu[rn] rub[y] rv[iminfo] sba[ll] sbN[ext] scripte[ncoding] setf[iletype] sh[ell] sim[alt] sm[ap] sni[ff] sor[t] spelli[nfo] spr[evious] start st[op] sunmenu syn ta tabf[ind] tabnew tabr[ewind] tcld[o] tj[ump] tN tr tu[nmenu] undoj[oin] uns[ilent] ve[rsion] vimgrepa[dd] vs[plit] winc[md] wN[ext] ws[verb] x[it] xnoremenu
+syn keyword vimCommand contained	ab argd[elete] argu[ment] bel[owright] bo[tright] breakl[ist] b[uffer] cad cb[uffer] cf[ile] changes cl[ist] cn[ext] col[der] conf[irm] cq[uit] cw[indow] delc[ommand] deletl delp diffpu[t] dir doau ea e[dit] endfo[r] ene[w] files fini[sh] foldd[oopen] g h hi if is[earch] keepa la lan[guage] lch[dir] lex[pr] lgr[ep] lli[st] lne[xt] lo lol[der] lt[ag] lw[indow] menut mks[ession] mod[e] nbc[lose] nmapc[lear] ol[dfiles] p po[p] prev[ious] promptr[epl] ptn pts[elect] pydo q[uit] rec[over] redraws[tatus] rew[ind] rubyd[o] sal[l] sbf[irst] sbp[revious] scrip[tnames] setg[lobal] si sl sme sno[magic] so[urce] spellr[epall] sre[wind] startg[replace] stopi[nsert] sus[pend] sync tab tabfir[st] tabn[ext] tabs tclf[ile] tl[ast] tn[ext] tr[ewind] u undol[ist] up[date] vert[ical] vi[sual] w windo wp[revious] wundo xmapc[lear] xunme
+syn keyword vimCommand contained	abc[lear] argdo as[cii] bf[irst] bp[revious] br[ewind] buffers caddb[uffer] cc cfir[st] chd[ir] clo[se] cN[ext] colo[rscheme] con[tinue] cr[ewind] d delel deletp dep diffs[plit] di[splay] dp earlier el[se] endfun ex filet fir[st] foldo[pen] go[to] ha[rdcopy] hid[e] ij[ump] isp[lit] keepalt lad la[st] lcl[ose] lf[ile] lgrepa[dd] lmak[e] lN[ext] loadk lop[en] lua ma menut[ranslate] mksp[ell] m[ove] nb[key] noa omapc[lear] pc[lose] popu p[rint] ps[earch] ptN pu[t] pyf[ile] quita[ll] red reg[isters] ri[ght] rubyf[ile] san[dbox] sbl[ast] sbr[ewind] scs setl[ocal] sig sla[st] smenu snoreme spe spellu[ndo] st star[tinsert] sts[elect] sv[iew] syncbind tabc[lose] tabl[ast] tabN[ext] ta[g] te[aroff] tm tN[ext] try un unh[ide] v vi viu[sage] wa[ll] winp[os] wq wv[iminfo] xme xunmenu
+syn keyword vimCommand contained	abo[veleft] arge[dit] au bl[ast] br bro[wse] bun[load] cad[dexpr] ccl[ose] cgetb[uffer] che[ckpath] cmapc[lear] cnf com cope[n] cs de delep delf di difft[his] dj[ump] dr[op] ec elsei[f] endf[unction] exi[t] filetype fix[del] for gr[ep] h[elp] his[tory] il[ist] iuna[bbrev] keepj[umps] laddb[uffer] lat lcs lfir[st] lh[elpgrep] lmapc[lear] lnf loadkeymap lpf[ile] luado mak[e] mes mkv mz nbs[tart] noautocmd on[ly] pe popu[p] pro pta[g] ptn[ext] pw[d] py[thon] r redi[r] res[ize] rightb[elow] rundo sa[rgument] sbm[odified] sb[uffer] scscope sf[ind] sign sl[eep] sn[ext] snoremenu spelld[ump] spellw[rong] sta[g] startr[eplace] sun[hide] sw[apname] syntime tabd[o] tabm[ove] tabo[nly] tags tf[irst] tm[enu] to[pleft] ts[elect] una[bbreviate] unl ve vie[w] vmapc[lear] wh[ile] win[size] wqa[ll] x xmenu xwininfo
+syn keyword vimCommand contained	al[l] argg[lobal] bad[d] bm[odified] brea[k] bu bw[ipeout] caddf[ile] cd cgete[xpr] checkt[ime] cn cNf comc[lear] co[py] cscope debug d[elete] delf[unction] diffg[et] diffu[pdate] dl ds[earch] echoe[rr] em[enu] en[dif] exu[sage] fin fo[ld] fu grepa[dd] helpf[ind] i imapc[lear] j[oin] kee[pmarks] lad[dexpr] later lcscope lgetb[uffer] l[ist] lN lNf lo[adview] lp[revious] luafile ma[rk] messages mkvie[w] mzf[ile] ne noh[lsearch] o[pen] ped[it] pp[op] profd[el] ptf[irst] ptN[ext] py python3 re red[o] ret[ab] ru ru[ntime] sav[eas] sbn[ext] scrip se[t] sfir[st] sil[ent] sm[agic] sN[ext] so spe[llgood] sp[lit] star stj[ump] sunme sy t tabe[dit] tabN tabp[revious] tc[l] th[row] tn tp[revious] tu u[ndo] unlo[ckvar] verb[ose] vim[grep] vne[w] win wn[ext] w[rite] xa[ll] xnoreme y[ank]
+syn keyword vimCommand contained	ar argl[ocal] ba[ll] bn[ext] breaka[dd] buf c cal[l] ce[nter] cg[etfile] cl cN cnf[ile] comp[iler] cpf[ile] cstag debugg[reedy] deletel dell diffo[ff] dig dli[st] dsp[lit] echom[sg] en endt[ry] f fina[lly] foldc[lose] fun gui helpg[rep] ia in ju[mps] keepp[atterns] laddf[ile] lb[uffer] le[ft] lgete[xpr] ll lne lnf[ile] loc[kmarks] lr[ewind] lv[imgrep] marks mk mkv[imrc] mz[scheme] new nu[mber] opt[ions] pe[rl] pr prof[ile] ptj[ump] ptp[revious] py3 q 
 syn match   vimCommand contained	"\<z[-+^.=]\="
+syn keyword vimStdPlugin contained	DiffOrig Man N[ext] P[rint] S TOhtml XMLent XMLns 
 
 " vimOptions are caught only when contained in a vimSet {{{2
-syn keyword vimOption contained	acd ambiwidth arabicshape autowriteall backupdir bdlay binary breakat bufhidden cd ci cinw co commentstring confirm cpoptions cscoperelative csre cursorcolumn delcombine diffopt ea efm ep et fdc fdo ffs fk foldcolumn foldmethod formatoptions gd go guifont guitabtooltip hid hkp iconstring imd include inex isi js kp linebreak lm lz matchpairs maxmemtot mkspellmem mod mousef mouset nf oft pa path pheader previewheight printmbcharset pvw remap rl ruf sc scrollopt selectmode shellpipe shellxquote showcmd sidescroll smartindent sol spellsuggest sr stal sua swf syntax taglength tbidi terse tildeop tl tpm ttimeoutlen ttymouse udf undoreload vbs vi vop wcm whichwrap wildignore winaltkeys winminwidth wmnu write
-syn keyword vimOption contained	ai ambw ari aw backupext beval biosk brk buflisted cdpath cin cinwords cocu compatible consk cpt cscopetag cst cursorline dex digraph ead ei equalalways eventignore fde fdt fileencoding fkmap foldenable foldminlines formatprg gdefault gp guifontset helpfile hidden hl ignorecase imdisable includeexpr inf isident key langmap lines lmap ma matchtime mco ml modeline mousefocus mousetime nrformats ofu para pdev pi previewwindow printmbfont qe report rlc ruler scb scs sessionoptions shellquote shiftround showfulltag sidescrolloff smarttab sp spf srr startofline suffixes switchbuf ta tagrelative tbis textauto timeout tm tr ttm ttyscroll udir updatecount vdir viewdir wa wd wi wildignorecase window winwidth wmw writeany
-syn keyword vimOption contained	akm anti arshape awa backupskip bex bioskey browsedir buftype cedit cindent clipboard cole complete conskey crb cscopetagorder csto cwh dg dip eadirection ek equalprg ex fdi fen fileencodings flp foldexpr foldnestmax fp gfm grepformat guifontwide helpheight highlight hlg im imi incsearch infercase isk keymap langmenu linespace loadplugins macatsui maxcombine mef mls modelines mousehide mp nu omnifunc paragraphs penc pm printdevice printoptions quoteescape restorescreen rnu rulerformat scr sect sft shellredir shiftwidth showmatch siso smc spc spl ss statusline suffixesadd sws tabline tags tbs textmode timeoutlen to ts tty ttytype ul updatetime ve viewoptions wak weirdinvert wic wildmenu winfixheight wiv wop writebackup
-syn keyword vimOption contained	al antialias autochdir background balloondelay bexpr bk bs casemap cf cink cmdheight colorcolumn completefunc copyindent cryptmethod cscopeverbose csverb debug dict dir eb enc errorbells expandtab fdl fenc fileformat fml foldignore foldopen fs gfn grepprg guiheadroom helplang history hls imactivatekey iminsert inde insertmode iskeyword keymodel laststatus lisp lpl magic maxfuncdepth menuitems mm modifiable mousem mps number opendevice paste pex pmbcs printencoding prompt rdt revins ro runtimepath scroll sections sh shellslash shm showmode sj smd spell splitbelow ssl stl sw sxe tabpagemax tagstack tenc textwidth title toolbar tsl ttybuiltin tw undodir ur verbose viminfo warn wfh wig wildmode winfixwidth wiw wrap writedelay
-syn keyword vimOption contained	aleph ar autoindent backspace ballooneval bg bkc bsdir cb cfu cinkeys cmdwinheight columns completeopt cot cscopepathcomp cspc cuc deco dictionary directory ed encoding errorfile exrc fdls fencs fileformats fmr foldlevel foldtext fsync gfs gtl guioptions hf hk hlsearch imak ims indentexpr is isp keywordprg lazyredraw lispwords ls makeef maxmapdepth mfd mmd modified mousemodel msm numberwidth operatorfunc pastetoggle pexpr pmbfn printexpr pt readonly ri rs sb scrollbind secure shcf shelltemp shortmess showtabline slm sn spellcapcheck splitright ssop stmp swapfile sxq tabstop tal term tf titlelen toolbariconsize tsr ttyfast tx undofile ut verbosefile virtualedit wb wfw wildchar wildoptions winheight wm wrapmargin ws
-syn keyword vimOption contained	allowrevins arab autoread backup balloonexpr bh bl bsk cc ch cino cmp com concealcursor cp cscopeprg csprg cul def diff display edcompatible endofline errorformat fcl fdm fex filetype fo foldlevelstart formatexpr ft gfw gtt guipty hh hkmap ic imc imsearch indentkeys isf isprint km lbr list lsp makeprg maxmem mh mmp more mouses mzq nuw opfunc patchexpr pfn popt printfont pumheight redrawtime rightleft rtp sbo scrolljump sel shell shelltype shortname shq sm so spellfile spr st sts swapsync syn tag tb termbidi tgst titleold top ttimeout ttym uc undolevels vb vfile visualbell wc wh wildcharm wim winminheight wmh wrapscan ww
-syn keyword vimOption contained	altkeymap arabic autowrite backupcopy bdir bin bomb bt ccv charconvert cinoptions cms comments conceallevel cpo cscopequickfix csqf cursorbind define diffexpr dy ef eol esckeys fcs fdn ff fillchars foldclose foldmarker formatlistpat gcr ghr guicursor guitablabel hi hkmapp icon imcmdline inc indk isfname joinspaces kmp lcs listchars lw mat maxmempattern mis mmt mouse mouseshape mzquantum odev osfiletype patchmode ph preserveindent printheader pvh relativenumber rightleftcmd ru sbr scrolloff selection shellcmdflag shellxescape showbreak si smartcase softtabstop spelllang sps sta su swb synmaxcol tagbsearch tbi termencoding thesaurus titlestring 
+syn keyword vimOption contained	acd ambiwidth arabicshape autowriteall backupdir bdlay binary breakat bufhidden cd ci cinw co commentstring confirm cpoptions cscoperelative csre cursorcolumn delcombine diffopt ea efm ep et fdc fdo ffs filetype fo foldlevelstart formatexpr ft gfw gtt guipty hh hkmap ic imaf iminsert includeexpr inf isident key langmap lines lmap ma matchtime mco ml modeline mousefocus mousetime nrformats ofu para pdev pi previewwindow printmbfont qe relativenumber rightleftcmd ru sbr scrolloff selection shellcmdflag shellxescape showbreak si smartcase softtabstop spelllang sps sta su swb synmaxcol tagbsearch tbi termencoding thesaurus titlestring tpm ttm ttytype undodir ut vfile vop wcm whichwrap wildignore winaltkeys winminwidth wmnu write
+syn keyword vimOption contained	ai ambw ari aw backupext beval biosk brk buflisted cdpath cin cinwords cocu compatible consk cpt cscopetag cst cursorline dex digraph ead ei equalalways eventignore fde fdt fic fillchars foldclose foldmarker formatlistpat gcr ghr guicursor guitablabel hi hkmapp icon imak ims incsearch infercase isk keymap langmenu linespace loadplugins macatsui maxcombine mef mls modelines mousehide mp nu omnifunc paragraphs penc pm printdevice printoptions quoteescape remap rl ruf sc scrollopt selectmode shellpipe shellxquote showcmd sidescroll smartindent sol spellsuggest sr stal sua swf syntax taglength tbidi terse tildeop tl tr tty tw undofile vb vi wa wd wi wildignorecase window winwidth wmw writeany
+syn keyword vimOption contained	akm anti arshape awa backupskip bex bioskey browsedir buftype cedit cindent clipboard cole complete conskey crb cscopetagorder csto cwh dg dip eadirection ek equalprg ex fdi fen fileencoding fk foldcolumn foldmethod formatoptions gd go guifont guitabtooltip hid hkp iconstring imc imsearch inde insertmode iskeyword keymodel laststatus lisp lpl magic maxfuncdepth menuitems mm modifiable mousem mps number opendevice paste pex pmbcs printencoding prompt rdt report rlc ruler scb scs sessionoptions shellquote shiftround showfulltag sidescrolloff smarttab sp spf srr startofline suffixes switchbuf ta tagrelative tbis textauto timeout tm ts ttybuiltin tx undolevels vbs viewdir wak weirdinvert wic wildmenu winfixheight wiv wop writebackup
+syn keyword vimOption contained	al antialias autochdir background balloondelay bexpr bk bs casemap cf cink cmdheight colorcolumn completefunc copyindent cryptmethod cscopeverbose csverb debug dict dir eb enc errorbells expandtab fdl fenc fileencodings fkmap foldenable foldminlines formatprg gdefault gp guifontset helpfile hidden hl ignorecase imcmdline imsf indentexpr is isp keywordprg lazyredraw lispwords ls makeef maxmapdepth mfd mmd modified mousemodel msm numberwidth operatorfunc pastetoggle pexpr pmbfn printexpr pt re restorescreen rnu rulerformat scr sect sft shellredir shiftwidth showmatch siso smc spc spl ss statusline suffixesadd sws tabline tags tbs textmode timeoutlen to tsl ttyfast uc undoreload vdir viewoptions warn wfh wig wildmode winfixwidth wiw wrap writedelay
+syn keyword vimOption contained	aleph ar autoindent backspace ballooneval bg bkc bsdir cb cfu cinkeys cmdwinheight columns completeopt cot cscopepathcomp cspc cuc deco dictionary directory ed encoding errorfile exrc fdls fencs fileformat flp foldexpr foldnestmax fp gfm grepformat guifontwide helpheight highlight hlg im imd imstatusfunc indentkeys isf isprint km lbr list lsp makeprg maxmem mh mmp more mouses mzq nuw opfunc patchexpr pfn popt printfont pumheight readonly revins ro runtimepath scroll sections sh shellslash shm showmode sj smd spell splitbelow ssl stl sw sxe tabpagemax tagstack tenc textwidth title toolbar tsr ttym udf updatecount ve viminfo wb wfw wildchar wildoptions winheight wm wrapmargin ws
+syn keyword vimOption contained	allowrevins arab autoread backup balloonexpr bh bl bsk cc ch cino cmp com concealcursor cp cscopeprg csprg cul def diff display edcompatible endofline errorformat fcl fdm fex fileformats fml foldignore foldopen fs gfn grepprg guiheadroom helplang history hls imactivatefunc imdisable inc indk isfname joinspaces kmp lcs listchars lw mat maxmempattern mis mmt mouse mouseshape mzquantum odev osfiletype patchmode ph preserveindent printheader pvh redrawtime ri rs sb scrollbind secure shcf shelltemp shortmess showtabline slm sn spellcapcheck splitright ssop stmp swapfile sxq tabstop tal term tf titlelen toolbariconsize ttimeout ttymouse udir updatetime verbose virtualedit wc wh wildcharm wim winminheight wmh wrapscan ww
+syn keyword vimOption contained	altkeymap arabic autowrite backupcopy bdir bin bomb bt ccv charconvert cinoptions cms comments conceallevel cpo cscopequickfix csqf cursorbind define diffexpr dy ef eol esckeys fcs fdn ff fileignorecase fmr foldlevel foldtext fsync gfs gtl guioptions hf hk hlsearch imactivatekey imi include inex isi js kp linebreak lm lz matchpairs maxmemtot mkspellmem mod mousef mouset nf oft pa path pheader previewheight printmbcharset pvw regexpengine rightleft rtp sbo scrolljump sel shell shelltype shortname shq sm so spellfile spr st sts swapsync syn tag tb termbidi tgst titleold top ttimeoutlen ttyscroll ul ur verbosefile visualbell 
 
 " vimOptions: These are the turn-off setting variants {{{2
-syn keyword vimOption contained	noacd noallowrevins noantialias noarabic noarshape noautoread noaw noballooneval nobinary nobk nobuflisted nocin noconfirm nocopyindent nocscopetag nocsverb nocursorbind nodeco nodiff noeb noek noequalalways noesckeys noex noexrc nofk nofoldenable nogdefault nohid nohk nohkmapp nohls noic noignorecase noimc noimd noincsearch noinfercase nois nojs nolbr nolisp noloadplugins nolz nomacatsui nomh nomod nomodifiable nomore nomousefocus nonu noodev nopaste nopreserveindent noprompt noreadonly noremap norevins norightleft nornu nors noruler nosc noscrollbind nosecure noshellslash noshiftround noshowcmd noshowmatch nosi nosmartcase nosmarttab nosn nospell nosplitright nosr nosta nostmp noswf notagbsearch notagstack notbidi notermbidi notextauto notf notildeop notitle notop nottimeout nottyfast novb nowa nowb nowfh nowildignorecase* * nowinfixheight nowiv nowrap nowrite nowritebackup
-syn keyword vimOption contained	noai noaltkeymap noar noarabicshape noautochdir noautowrite noawa nobeval nobiosk nobl nocf nocindent noconsk nocp nocscopeverbose nocuc nocursorcolumn nodelcombine nodigraph noed noendofline noerrorbells noet noexpandtab nofen nofkmap nogd noguipty nohidden nohkmap nohkp nohlsearch noicon noim noimcmdline noimdisable noinf noinsertmode nojoinspaces nolazyredraw nolinebreak nolist nolpl noma nomagic noml nomodeline nomodified nomousef nomousehide nonumber noopendevice nopi nopreviewwindow nopvw norelativenumber norestorescreen nori norl noro noru nosb noscb noscs nosft noshelltemp noshortname noshowfulltag noshowmode nosm nosmartindent nosmd nosol nosplitbelow nospr nossl nostartofline noswapfile nota notagrelative notbi notbs noterse notextmode notgst notimeout noto notr nottybuiltin notx novisualbell nowarn noweirdinvert nowfw nowildmenu nowinfixwidth nowmnu nowrapscan nowriteany nows
-syn keyword vimOption contained	noakm noanti noarab noari noautoindent noautowriteall nobackup nobin nobioskey nobomb noci nocompatible noconskey nocrb nocst nocul nocursorline nodg noea noedcompatible noeol 
+syn keyword vimOption contained	noacd noallowrevins noantialias noarabic noarshape noautoread noaw noballooneval nobinary nobk nobuflisted nocin noconfirm nocopyindent nocscoperelative nocsre nocuc nocursorcolumn nodelcombine nodigraph noed noendofline noerrorbells noex nofen nofk nogd nohid nohkmap nohkp nohlsearch noicon noim noimcmdline noimdisable noinf noinsertmode nojoinspaces nolazyredraw nolinebreak nolist nolpl noma nomagic noml nomodeline nomodified nomousef nomousehide nonumber noopendevice nopi nopreviewwindow nopvw norelativenumber norestorescreen nori norl noro noru nosb noscb noscs nosft noshelltemp noshortname noshowfulltag noshowmode nosm nosmartindent nosmd nosol nosplitbelow nospr nossl nostartofline noswapfile nota notagrelative notbi notbs noterse notextmode notgst notimeout noto notr nottybuiltin notx noundofile novisualbell nowarn noweirdinvert nowfw nowildignorecase nowinfixheight nowiv nowrap nowrite nowritebackup
+syn keyword vimOption contained	noai noaltkeymap noar noarabicshape noautochdir noautowrite noawa nobeval nobiosk nobl nocf nocindent noconsk nocp nocscopetag nocst nocul nocursorline nodg noea noedcompatible noeol noesckeys noexpandtab nofic nofkmap nogdefault nohidden nohkmapp nohls noic noignorecase noimc noimd noincsearch noinfercase nois nojs nolbr nolisp noloadplugins nolz nomacatsui nomh nomod nomodifiable nomore nomousefocus nonu noodev nopaste nopreserveindent noprompt noreadonly noremap norevins norightleft nornu nors noruler nosc noscrollbind nosecure noshellslash noshiftround noshowcmd noshowmatch nosi nosmartcase nosmarttab nosn nospell nosplitright nosr nosta nostmp noswf notagbsearch notagstack notbidi notermbidi notextauto notf notildeop notitle notop nottimeout nottyfast noudf novb nowa nowb nowfh nowic nowildmenu nowinfixwidth nowmnu nowrapscan nowriteany nows
+syn keyword vimOption contained	noakm noanti noarab noari noautoindent noautowriteall nobackup nobin nobioskey nobomb noci nocompatible noconskey nocrb nocscopeverbose nocsverb nocursorbind nodeco nodiff noeb noek noequalalways noet noexrc nofileignorecase nofoldenable noguipty nohk 
 
 " vimOptions: These are the invertible variants {{{2
-syn keyword vimOption contained	invacd invallowrevins invantialias invarabic invarshape invautoread invaw invballooneval invbinary invbk invbuflisted invcin invconfirm invcopyindent invcscopetag invcsverb invcursorbind invdeco invdiff inveb invek invequalalways invesckeys invex invexrc invfk invfoldenable invgdefault invhid invhk invhkmapp invhls invic invignorecase invimc invimd invincsearch invinfercase invis invjs invlbr invlisp invloadplugins invlz invmacatsui invmh invmod invmodifiable invmore invmousefocus invnu invodev invpaste invpreserveindent invprompt invreadonly invremap invrevins invrightleft invrnu invrs invruler invsc invscrollbind invsecure invshellslash invshiftround invshowcmd invshowmatch invsi invsmartcase invsmarttab invsn invspell invsplitright invsr invsta invstmp invswf invtagbsearch invtagstack invtbidi invtermbidi invtextauto invtf invtildeop invtitle invtop invttimeout invttyfast invvb invwa invwb invwfh invwildignorecase* * invwinfixheight invwiv invwrap invwrite invwritebackup
-syn keyword vimOption contained	invai invaltkeymap invar invarabicshape invautochdir invautowrite invawa invbeval invbiosk invbl invcf invcindent invconsk invcp invcscopeverbose invcuc invcursorcolumn invdelcombine invdigraph inved invendofline inverrorbells invet invexpandtab invfen invfkmap invgd invguipty invhidden invhkmap invhkp invhlsearch invicon invim invimcmdline invimdisable invinf invinsertmode invjoinspaces invlazyredraw invlinebreak invlist invlpl invma invmagic invml invmodeline invmodified invmousef invmousehide invnumber invopendevice invpi invpreviewwindow invpvw invrelativenumber invrestorescreen invri invrl invro invru invsb invscb invscs invsft invshelltemp invshortname invshowfulltag invshowmode invsm invsmartindent invsmd invsol invsplitbelow invspr invssl invstartofline invswapfile invta invtagrelative invtbi invtbs invterse invtextmode invtgst invtimeout invto invtr invttybuiltin invtx invvisualbell invwarn invweirdinvert invwfw invwildmenu invwinfixwidth invwmnu invwrapscan invwriteany invws
-syn keyword vimOption contained	invakm invanti invarab invari invautoindent invautowriteall invbackup invbin invbioskey invbomb invci invcompatible invconskey invcrb invcst invcul invcursorline invdg invea invedcompatible inveol 
+syn keyword vimOption contained	invacd invallowrevins invantialias invarabic invarshape invautoread invaw invballooneval invbinary invbk invbuflisted invcin invconfirm invcopyindent invcscoperelative invcsre invcuc invcursorcolumn invdelcombine invdigraph inved invendofline inverrorbells invex invfen invfk invgd invhid invhkmap invhkp invhlsearch invicon invim invimcmdline invimdisable invinf invinsertmode invjoinspaces invlazyredraw invlinebreak invlist invlpl invma invmagic invml invmodeline invmodified invmousef invmousehide invnumber invopendevice invpi invpreviewwindow invpvw invrelativenumber invrestorescreen invri invrl invro invru invsb invscb invscs invsft invshelltemp invshortname invshowfulltag invshowmode invsm invsmartindent invsmd invsol invsplitbelow invspr invssl invstartofline invswapfile invta invtagrelative invtbi invtbs invterse invtextmode invtgst invtimeout invto invtr invttybuiltin invtx invundofile invvisualbell invwarn invweirdinvert invwfw invwildignorecase invwinfixheight invwiv invwrap invwrite invwritebackup
+syn keyword vimOption contained	invai invaltkeymap invar invarabicshape invautochdir invautowrite invawa invbeval invbiosk invbl invcf invcindent invconsk invcp invcscopetag invcst invcul invcursorline invdg invea invedcompatible inveol invesckeys invexpandtab invfic invfkmap invgdefault invhidden invhkmapp invhls invic invignorecase invimc invimd invincsearch invinfercase invis invjs invlbr invlisp invloadplugins invlz invmacatsui invmh invmod invmodifiable invmore invmousefocus invnu invodev invpaste invpreserveindent invprompt invreadonly invremap invrevins invrightleft invrnu invrs invruler invsc invscrollbind invsecure invshellslash invshiftround invshowcmd invshowmatch invsi invsmartcase invsmarttab invsn invspell invsplitright invsr invsta invstmp invswf invtagbsearch invtagstack invtbidi invtermbidi invtextauto invtf invtildeop invtitle invtop invttimeout invttyfast invudf invvb invwa invwb invwfh invwic invwildmenu invwinfixwidth invwmnu invwrapscan invwriteany invws
+syn keyword vimOption contained	invakm invanti invarab invari invautoindent invautowriteall invbackup invbin invbioskey invbomb invci invcompatible invconskey invcrb invcscopeverbose invcsverb invcursorbind invdeco invdiff inveb invek invequalalways invet invexrc invfileignorecase invfoldenable invguipty invhk 
 
 " termcap codes (which can also be set) {{{2
-syn keyword vimOption contained	t_AB t_al t_bc t_ce t_cl t_Co t_cs t_Cs t_CS t_CV t_da t_db t_dl t_DL t_EI t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_te t_ti t_ts t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xs t_ZH t_ZR
-syn keyword vimOption contained	t_AF t_AL t_cd t_Ce t_cm 
+syn keyword vimOption contained	t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CS t_CV t_da t_db t_dl t_DL t_EI t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xs t_ZH t_ZR
+syn keyword vimOption contained	t_AF t_AL t_cd t_Ce t_cm t_cs 
 syn match   vimOption contained	"t_%1"
 syn match   vimOption contained	"t_#2"
 syn match   vimOption contained	"t_#4"
@@ -62,20 +62,20 @@
 
 " AutoCmd Events {{{2
 syn case ignore
-syn keyword vimAutoEvent contained	BufAdd BufCreate BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufRead BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite BufWriteCmd BufWritePost BufWritePre Cmd-event CmdwinEnter CmdwinLeave ColorScheme CursorHold CursorHoldI CursorMoved CursorMovedI EncodingChanged FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileEncoding FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave MenuPopup QuickFixCmdPost QuickFixCmdPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermResponse User UserGettingBored VimEnter VimLeave VimLeavePre VimResized WinEnter WinLeave 
+syn keyword vimAutoEvent contained	BufAdd BufCreate BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufRead BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite BufWriteCmd BufWritePost BufWritePre Cmd-event CmdwinEnter CmdwinLeave ColorScheme CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI EncodingChanged FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileEncoding FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave MenuPopup QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermResponse TextChanged TextChangedI User UserGettingBored VimEnter VimLeave VimLeavePre VimResized WinEnter WinLeave 
 
 " Highlight commonly used Groupnames {{{2
 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
 
 " Default highlighting groups {{{2
-syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine DiffAdd DiffChange DiffDelete DiffText Directory ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual VisualNOS WarningMsg WildMenu 
+syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual VisualNOS WarningMsg WildMenu 
 syn match vimHLGroup contained	"Conceal"
 syn case match
 
 " Function Names {{{2
-syn keyword vimFuncName contained	abs and argidx atan browsedir bufloaded bufwinnr call char2nr col complete_check cos cscope_connection delete diff_hlID eval exists expr8 filereadable finddir floor fnamemodify foldlevel foreground get getchar getcmdpos getfontname getftime getloclist getpos getregtype getwinposx glob has_key histadd histnr hostname index inputlist inputsecret isdirectory join libcall line2byte log map match matchdelete matchstr mkdir nextnonblank pathshorten printf pyeval reltime remote_foreground remote_read remove repeat reverse search searchpair searchpos serverlist setcmdpos setloclist setpos setreg settabwinvar shellescape simplify sinh soundfold spellsuggest sqrt str2nr strdisplaywidth stridx strlen strridx strwidth substitute synID synIDtrans system tabpagenr tagfiles tan tempname toupper trunc undofile values visualmode wincol winline winrestcmd winsaveview writefile
-syn keyword vimFuncName contained	acos append argv atan2 bufexists bufname byte2line ceil cindent complete confirm cosh cursor did_filetype empty eventhandler exp extend filewritable findfile fmod foldclosed foldtext function getbufline getcharmod getcmdtype getfperm getftype getmatches getqflist gettabvar getwinposy globpath haslocaldir histdel hlexists iconv input inputrestore insert islocked keys libcallnr lispindent log10 maparg matchadd matchend max mode nr2char pow pumvisible range reltimestr remote_peek remote_send rename resolve round searchdecl searchpairpos server2client setbufvar setline setmatches setqflist settabvar setwinvar shiftwidth sin sort spellbadword split str2float strchars strftime string strpart strtrans submatch synconcealed synIDattr synstack tabpagebuflist tabpagewinnr taglist tanh tolower tr type undotree virtcol winbufnr winheight winnr winrestview winwidth xor
-syn keyword vimFuncName contained	add argc asin browse buflisted bufnr byteidx changenr clearmatches complete_add copy count deepcopy diff_filler escape executable expand feedkeys filter float2nr fnameescape foldclosedend foldtextresult garbagecollect getbufvar getcmdline getcwd getfsize getline getpid getreg gettabwinvar getwinvar has hasmapto histget hlID indent inputdialog inputsave invert items len line localtime luaeval mapcheck matcharg matchlist min mzeval or prevnonblank py3eval readfile remote_expr 
+syn keyword vimFuncName contained	abs and argidx atan browsedir bufloaded bufwinnr byteidxcomp changenr clearmatches complete_add copy count deepcopy diff_filler escape executable expand feedkeys filter float2nr fnameescape foldclosedend foldtextresult garbagecollect getbufvar getcmdline getcwd getfsize getline getpid getreg gettabwinvar getwinvar has hasmapto histget hlID indent inputdialog inputsave invert items len line localtime luaeval mapcheck matcharg matchlist min mzeval or prevnonblank py3eval readfile remote_expr remote_read rename reverse screenchar search searchpairpos serverlist setcmdpos setloclist setpos setreg settabwinvar sha256 shiftwidth sin sort spellbadword split str2float strchars strftime string strpart strtrans submatch synconcealed synIDattr synstack tabpagebuflist tabpagewinnr taglist tanh tolower tr type undotree virtcol wildmenumode wincol winline winrestcmd winsaveview writefile
+syn keyword vimFuncName contained	acos append argv atan2 bufexists bufname byte2line call char2nr col complete_check cos cscope_connection delete diff_hlID eval exists expr8 filereadable finddir floor fnamemodify foldlevel foreground get getchar getcmdpos getfontname getftime getloclist getpos getregtype getwinposx glob has_key histadd histnr hostname index inputlist inputsecret isdirectory join libcall line2byte log map match matchdelete matchstr mkdir nextnonblank pathshorten printf pyeval reltime remote_foreground remote_send repeat round screencol searchdecl searchpos setbufvar setline setmatches setqflist settabvar setwinvar shellescape simplify sinh soundfold spellsuggest sqrt str2nr strdisplaywidth stridx strlen strridx strwidth substitute synID synIDtrans system tabpagenr tagfiles tan tempname toupper trunc undofile values visualmode winbufnr winheight winnr winrestview winwidth xor
+syn keyword vimFuncName contained	add argc asin browse buflisted bufnr byteidx ceil cindent complete confirm cosh cursor did_filetype empty eventhandler exp extend filewritable findfile fmod foldclosed foldtext function getbufline getcharmod getcmdtype getfperm getftype getmatches getqflist gettabvar getwinposy globpath haslocaldir histdel hlexists iconv input inputrestore insert islocked keys libcallnr lispindent log10 maparg matchadd matchend max mode nr2char pow pumvisible range reltimestr remote_peek remove resolve screenattr screenrow searchpair server2client 
 
 "--- syntax here and above generated by mkvimvim ---
 " Special Vim Highlighting (not automatic) {{{1
diff -Naur vim74.orig/runtime/syntax/vroom.vim vim74/runtime/syntax/vroom.vim
--- vim74.orig/runtime/syntax/vroom.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/syntax/vroom.vim	2014-10-10 14:53:43.482049383 +0000
@@ -0,0 +1,113 @@
+" Vim syntax file
+" Language:	Vroom (vim testing and executable documentation)
+" Maintainer:	David Barnett (https://github.com/google/vim-ft-vroom)
+" Last Change:	2014 Jul 23
+
+" For version 5.x: Clear all syntax items.
+" For version 6.x and later: Quit when a syntax file was already loaded.
+if v:version < 600
+  syntax clear
+elseif exists('b:current_syntax')
+  finish
+endif
+
+let s:cpo_save = &cpo
+set cpo-=C
+
+
+syn include @vroomVim syntax/vim.vim
+syn include @vroomShell syntax/sh.vim
+
+syntax region vroomAction
+    \ matchgroup=vroomOutput
+    \ start='\m^  ' end='\m$' keepend
+    \ contains=vroomControlBlock
+
+syntax region vroomAction
+    \ matchgroup=vroomOutput
+    \ start='\m^  & ' end='\m$' keepend
+    \ contains=vroomControlBlock
+
+syntax match vroomOutput '\m^  &$'
+
+syntax region vroomMessageBody
+    \ matchgroup=vroomMessage
+    \ start='\m^  \~ ' end='\m$' keepend
+    \ contains=vroomControlBlock
+
+syntax region vroomColoredAction
+    \ matchgroup=vroomInput
+    \ start='\m^  > ' end='\m$' keepend
+    \ contains=vimNotation,vroomControlBlock
+syntax region vroomAction
+    \ matchgroup=vroomInput
+    \ start='\m^  % ' end='\m$' keepend
+    \ contains=vimNotation,vroomControlBlock
+
+syntax region vroomAction
+    \ matchgroup=vroomContinuation
+    \ start='\m^  |' end='\m$' keepend
+
+syntax region vroomAction
+    \ start='\m^  \ze:' end='\m$' keepend
+    \ contains=@vroomVim,vroomControlBlock
+
+syntax region vroomAction
+    \ matchgroup=vroomDirective
+    \ start='\m^  @\i\+' end='\m$' keepend
+    \ contains=vroomControlBlock
+
+syntax region vroomSystemAction
+    \ matchgroup=vroomSystem
+    \ start='\m^  ! ' end='\m$' keepend
+    \ contains=@vroomShell,vroomControlBlock
+
+syntax region vroomHijackAction
+    \ matchgroup=vroomHijack
+    \ start='\m^  \$ ' end='\m$' keepend
+    \ contains=vroomControlBlock
+
+syntax match vroomControlBlock contains=vroomControlEscape,@vroomControls
+    \ '\v \([^&()][^()]*\)$'
+
+syntax match vroomControlEscape '\m&' contained
+
+syntax cluster vroomControls
+    \ contains=vroomDelay,vroomMode,vroomBuffer,vroomRange
+    \,vroomChannel,vroomBind,vroomStrictness
+syntax match vroomRange '\v\.(,\+?(\d+|\$)?)?' contained
+syntax match vroomRange '\v\d*,\+?(\d+|\$)?' contained
+syntax match vroomBuffer '\v\d+,@!' contained
+syntax match vroomDelay '\v\d+(\.\d+)?s' contained
+syntax match vroomMode '\v<%(regex|glob|verbatim)' contained
+syntax match vroomChannel '\v<%(stderr|stdout|command|status)>' contained
+syntax match vroomBind '\v<bind>' contained
+syntax match vroomStrictness '\v\<%(STRICT|RELAXED|GUESS-ERRORS)\>' contained
+
+highlight default link vroomInput Identifier
+highlight default link vroomDirective vroomInput
+highlight default link vroomControlBlock vroomInput
+highlight default link vroomSystem vroomInput
+highlight default link vroomOutput Statement
+highlight default link vroomContinuation Constant
+highlight default link vroomHijack Special
+highlight default link vroomColoredAction Statement
+highlight default link vroomSystemAction vroomSystem
+highlight default link vroomHijackAction vroomHijack
+highlight default link vroomMessage vroomOutput
+highlight default link vroomMessageBody Constant
+
+highlight default link vroomControlEscape Special
+highlight default link vroomBuffer vroomInput
+highlight default link vroomRange Include
+highlight default link vroomMode Constant
+highlight default link vroomDelay Type
+highlight default link vroomStrictness vroomMode
+highlight default link vroomChannel vroomMode
+highlight default link vroomBind vroomMode
+
+let b:current_syntax = 'vroom'
+
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
diff -Naur vim74.orig/runtime/syntax/yacc.vim vim74/runtime/syntax/yacc.vim
--- vim74.orig/runtime/syntax/yacc.vim	2012-11-15 01:25:58.000000000 +0000
+++ vim74/runtime/syntax/yacc.vim	2014-10-10 14:53:43.555382532 +0000
@@ -1,8 +1,8 @@
 " Vim syntax file
 " Language:	Yacc
 " Maintainer:	Charles E. Campbell <NdrOchipS@PcampbellAfamily.Mbiz>
-" Last Change:	Nov 14, 2012
-" Version:	10
+" Last Change:	Mar 20, 2014
+" Version:	11
 " URL:	http://mysite.verizon.net/astronaut/vim/index.html#vimlinks_syntax
 "
 " Options: {{{1
@@ -42,7 +42,7 @@
 " ---------------------------------------------------------------------
 "  Yacc Clusters: {{{1
 syn cluster yaccInitCluster	contains=yaccKey,yaccKeyActn,yaccBrkt,yaccType,yaccString,yaccUnionStart,yaccHeader2,yaccComment,yaccDefines,yaccParseParam,yaccParseOption
-syn cluster yaccRulesCluster	contains=yaccNonterminal,yaccString
+syn cluster yaccRulesCluster	contains=yaccNonterminal,yaccString,yaccComment
 
 " ---------------------------------------------------------------------
 "  Yacc Sections: {{{1
diff -Naur vim74.orig/runtime/syntax/yaml.vim vim74/runtime/syntax/yaml.vim
--- vim74.orig/runtime/syntax/yaml.vim	2010-10-08 13:33:39.000000000 +0000
+++ vim74/runtime/syntax/yaml.vim	2014-10-10 14:53:43.588715782 +0000
@@ -108,9 +108,10 @@
 syn match yamlFlowMappingMerge /<<\ze\s*:/ contained nextgroup=yamlKeyValueDelimiter
 
 syn match yamlBlockCollectionItemStart '^\s*\zs-\%(\s\+-\)*\s' nextgroup=yamlBlockMappingKey,yamlBlockMappingMerge
-execute 'syn match yamlBlockMappingKey /^\s*\zs'.s:ns_plain_out.'\ze\s*:\%(\s\|$\)/ '.
+" Use the old regexp engine, the NFA engine doesn't like all the \@ items.
+execute 'syn match yamlBlockMappingKey /\%#=1^\s*\zs'.s:ns_plain_out.'\ze\s*:\%(\s\|$\)/ '.
             \'nextgroup=yamlKeyValueDelimiter'
-execute 'syn match yamlBlockMappingKey /\s*\zs'.s:ns_plain_out.'\ze\s*:\%(\s\|$\)/ contained '.
+execute 'syn match yamlBlockMappingKey /\%#=1\s*\zs'.s:ns_plain_out.'\ze\s*:\%(\s\|$\)/ contained '.
             \'nextgroup=yamlKeyValueDelimiter'
 syn match yamlBlockMappingMerge /^\s*\zs<<\ze:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter
 syn match yamlBlockMappingMerge /<<\ze\s*:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter contained
diff -Naur vim74.orig/runtime/tutor/tutor vim74/runtime/tutor/tutor
--- vim74.orig/runtime/tutor/tutor	2012-10-03 13:29:40.000000000 +0000
+++ vim74/runtime/tutor/tutor	2014-10-10 14:53:43.645382306 +0000
@@ -55,8 +55,8 @@
   2. Type:	:q! <ENTER>.
      This exits the editor, DISCARDING any changes you have made.
 
-  3. When you see the shell prompt, type the command that got you into this
-     tutor.  That would be:	vimtutor <ENTER>
+  3. Get back here by executing the command that got you into this tutor. That
+     might be:  vimtutor <ENTER>
 
   4. If you have these steps memorized and are confident, execute steps
      1 through 3 to exit and re-enter the editor.
diff -Naur vim74.orig/runtime/tutor/tutor.es vim74/runtime/tutor/tutor.es
--- vim74.orig/runtime/tutor/tutor.es	2010-05-15 11:04:02.000000000 +0000
+++ vim74/runtime/tutor/tutor.es	2014-10-10 14:53:43.695382180 +0000
@@ -121,7 +121,7 @@
 	 h (izquierda)	   j (abajo)	  k (arriba)	  l (derecha)
 
   2. Para acceder a Vim (desde el smbolo del sistema %) escriba:
-     vin FILENAME <INTRO>
+     vim FILENAME <INTRO>
 
   3. Para salir de Vim escriba: <ESC> :q! <INTRO> para eliminar todos
      los cambios.
diff -Naur vim74.orig/runtime/tutor/tutor.es.utf-8 vim74/runtime/tutor/tutor.es.utf-8
--- vim74.orig/runtime/tutor/tutor.es.utf-8	2010-05-15 11:04:02.000000000 +0000
+++ vim74/runtime/tutor/tutor.es.utf-8	2014-10-10 14:53:43.698715505 +0000
@@ -121,7 +121,7 @@
 	 h (izquierda)	   j (abajo)	  k (arriba)	  l (derecha)
 
   2. Para acceder a Vim (desde el smbolo del sistema %) escriba:
-     vin FILENAME <INTRO>
+     vim FILENAME <INTRO>
 
   3. Para salir de Vim escriba: <ESC> :q! <INTRO> para eliminar todos
      los cambios.
diff -Naur vim74.orig/runtime/tutor/tutor.fr vim74/runtime/tutor/tutor.fr
--- vim74.orig/runtime/tutor/tutor.fr	2013-05-11 11:02:15.000000000 +0000
+++ vim74/runtime/tutor/tutor.fr	2014-10-10 14:53:43.702048830 +0000
@@ -1029,10 +1029,10 @@
   des Mines du Colorado et reprend des ides fournies par Charles Smith,
   Universit d'tat du Colorado. E-mail : bware@mines.colorado.edu.
 
-  Modifi pour Vim par Bram Moolenar.
+  Modifi pour Vim par Bram Moolenaar.
   Traduit en franais par Adrien Beau, en avril 2001.
   Dernires mises  jour par Dominique Pell.
 
   E-mail :      dominique.pelle@gmail.com
-  Last Change : 2013 May 10
+  Last Change : 2014 Aug 18
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/tutor/tutor.fr.utf-8 vim74/runtime/tutor/tutor.fr.utf-8
--- vim74.orig/runtime/tutor/tutor.fr.utf-8	2013-07-06 12:34:09.000000000 +0000
+++ vim74/runtime/tutor/tutor.fr.utf-8	2014-10-10 14:53:43.705382155 +0000
@@ -1029,10 +1029,10 @@
   des Mines du Colorado et reprend des ides fournies par Charles Smith,
   Universit d'tat du Colorado. E-mail : bware@mines.colorado.edu.
 
-  Modifi pour Vim par Bram Moolenar.
+  Modifi pour Vim par Bram Moolenaar.
   Traduit en franais par Adrien Beau, en avril 2001.
   Dernires mises  jour par Dominique Pell.
 
   E-mail :      dominique.pelle@gmail.com
-  Last Change : 2013 May 10
+  Last Change : 2014 Aug 18
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/tutor/tutor.it vim74/runtime/tutor/tutor.it
--- vim74.orig/runtime/tutor/tutor.it	2010-05-23 09:00:00.000000000 +0000
+++ vim74/runtime/tutor/tutor.it	2014-10-10 14:53:43.722048780 +0000
@@ -638,7 +638,7 @@
 NOTA: Se esci da Vim e riesegui Vim battendo  vim TEST , il file aperto
       sar una copia esatta di "tutor.it" al momento del salvataggio.
 
-  5. Ora cancella il file battendo (MR-DOS):   :!del TEST
+  5. Ora cancella il file battendo (MS-DOS):   :!del TEST
 				 o (Unix):     :!rm TEST
 
 
diff -Naur vim74.orig/runtime/tutor/tutor.it.utf-8 vim74/runtime/tutor/tutor.it.utf-8
--- vim74.orig/runtime/tutor/tutor.it.utf-8	2010-05-23 10:11:46.000000000 +0000
+++ vim74/runtime/tutor/tutor.it.utf-8	2014-10-10 14:53:43.725382105 +0000
@@ -638,7 +638,7 @@
 NOTA: Se esci da Vim e riesegui Vim battendo  vim TEST , il file aperto
       sar una copia esatta di "tutor.it" al momento del salvataggio.
 
-  5. Ora cancella il file battendo (MR-DOS):   :!del TEST
+  5. Ora cancella il file battendo (MS-DOS):   :!del TEST
 				 o (Unix):     :!rm TEST
 
 
diff -Naur vim74.orig/runtime/tutor/tutor.ja.euc vim74/runtime/tutor/tutor.ja.euc
--- vim74.orig/runtime/tutor/tutor.ja.euc	2013-03-03 10:22:10.000000000 +0000
+++ vim74/runtime/tutor/tutor.ja.euc	2014-10-10 14:53:43.728715430 +0000
@@ -55,8 +55,7 @@
   2. :		:q! <ENTER>
      
 
-  3. 
-     
+  3. 
      :		vimtutor <ENTER>
 
   4.  1  3 
@@ -904,7 +903,7 @@
 
 	       ** CTRL-D  <TAB>  **
 
-  1. :  :set nocp
+  1. :  :set nocp
 
   2.  :!ls  :!dir 
 
@@ -949,7 +948,7 @@
    Vim 
   Vim 
   Vim 
-  : ":help user-manual"
+  : ":help user-manual"
 
   
 	Vim - Vi Improved - by Steve Oualline
diff -Naur vim74.orig/runtime/tutor/tutor.ja.sjis vim74/runtime/tutor/tutor.ja.sjis
--- vim74.orig/runtime/tutor/tutor.ja.sjis	2013-03-03 10:22:18.000000000 +0000
+++ vim74/runtime/tutor/tutor.ja.sjis	2014-10-10 14:53:43.732048755 +0000
@@ -55,8 +55,7 @@
   2. ^Cv:		:q! <ENTER>
      WeGfB^IB
 
-  3. VFvvgoA`[gAnR}h
-     ^CvB
+  3. `[gAnR}hsAB
      R}h:		vimtutor <ENTER>
 
   4. XebvoMAXebv 1  3 
@@ -904,7 +903,7 @@
 
 	       ** CTRL-D  <TAB> R}hC **
 
-  1. Rp`[hmF:  :set nocp
+  1. [hmF:  :set nocp
 
   2. fBNgt@C :!ls  :!dir mFB
 
@@ -949,7 +948,7 @@
    Vim `[gAIBGfB^PA[
   gAVim TOv_`B
   Vim R}hASB
-  ~[U}jAQ: ":help user-manual"
+  ~[U[}jAQ: ":help user-manual"
 
   wKA{EB
 	Vim - Vi Improved - by Steve Oualline
diff -Naur vim74.orig/runtime/tutor/tutor.ja.utf-8 vim74/runtime/tutor/tutor.ja.utf-8
--- vim74.orig/runtime/tutor/tutor.ja.utf-8	2013-03-03 10:15:50.000000000 +0000
+++ vim74/runtime/tutor/tutor.ja.utf-8	2014-10-10 14:53:43.735382080 +0000
@@ -55,8 +55,7 @@
   2. :		:q! <ENTER>
      
 
-  3. 
-     
+  3. 
      :		vimtutor <ENTER>
 
   4.  1  3 
@@ -904,7 +903,7 @@
 
 	       ** CTRL-D  <TAB>  **
 
-  1. :  :set nocp
+  1. :  :set nocp
 
   2.  :!ls  :!dir 
 
@@ -949,7 +948,7 @@
    Vim 
   Vim 
   Vim 
-  : ":help user-manual"
+  : ":help user-manual"
 
   
 	Vim - Vi Improved - by Steve Oualline
diff -Naur vim74.orig/runtime/tutor/tutor.pt vim74/runtime/tutor/tutor.pt
--- vim74.orig/runtime/tutor/tutor.pt	2010-08-11 20:54:33.000000000 +0000
+++ vim74/runtime/tutor/tutor.pt	2014-10-10 14:53:43.768715330 +0000
@@ -58,11 +58,11 @@
      Isso sai do editor SEM salvar qualquer mudana que tenha sido feita.
      Se quiser salvar as alteraes e sair, digite     :wq <ENTER>
 
-  3. Quando vir o prompt do shell digite o comando que lhe trouxe a este
-     tutorial, na maioria dos casos:      vimtutor <ENTER>.
+  3. Repita o procedimento que lhe trouxe a este tutorial. O procedimento pode
+     ter sido a digitao de:  vimtutor <ENTER>.
 
   4. Se voc memorizou estes passos e est confiante, execute os passos de
-     1 a 3 para sair e re-entrar no editor.
+     1 a 3 para sair e reentrar no editor.
 
 NOTA:  :q! <ENTER>  descarta qualquer mudana. Em uma prxima lio ser
        ensinado como salvar as mudanas feitas em um arquivo.
@@ -560,7 +560,7 @@
 
   1. Mova o cursor para a linha abaixo marcada com --->.
 
-  2. Digite  :/s/aa/a <ENTER> . Note que este comando somente muda a 
+  2. Digite  :s/aa/a <ENTER> . Note que este comando somente muda a 
      primeira ocorrncia na linha.
 
   3. Agora digite  :s/aa/a/g   significando substituir globalmente na linha.
@@ -572,7 +572,7 @@
      digite  :#,#s/velho/novo/g   onde #,# so os nmeros das duas linhas.
      Digite  :%s/velho/novo/g     para mudar todas as ocorrncias no arquivo
                                   inteiro.
-     Digite  :%/velho/novo/gc     para mudar todas as ocorrncia no arquivo
+     Digite  :%s/velho/novo/gc    para mudar todas as ocorrncia no arquivo
                                   inteiro, com a opo de confirmar cada
 				  substituio.
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -971,7 +971,7 @@
   Colorado School of Mines, usando idias fornecidas por Charles Smith,
   Colorado State University.  E-mail: bware@mines.colorado.edu.
 
-  Modificado para o Vim por Bram Moolenar.
+  Modificado para o Vim por Bram Moolenaar.
 
   Verso 1.4 traduzida para o portugus por Marcelo Drudi Miranda, Escola
   Politcnica da Universidade de So Paulo.
diff -Naur vim74.orig/runtime/tutor/tutor.pt.utf-8 vim74/runtime/tutor/tutor.pt.utf-8
--- vim74.orig/runtime/tutor/tutor.pt.utf-8	2010-08-11 20:54:33.000000000 +0000
+++ vim74/runtime/tutor/tutor.pt.utf-8	2014-10-10 14:53:43.772048654 +0000
@@ -58,11 +58,11 @@
      Isso sai do editor SEM salvar qualquer mudana que tenha sido feita.
      Se quiser salvar as alteraes e sair, digite     :wq <ENTER>
 
-  3. Quando vir o prompt do shell digite o comando que lhe trouxe a este
-     tutorial, na maioria dos casos:      vimtutor <ENTER>.
+  3. Repita o procedimento que lhe trouxe a este tutorial. O procedimento pode
+     ter sido a digitao de:  vimtutor <ENTER>.
 
   4. Se voc memorizou estes passos e est confiante, execute os passos de
-     1 a 3 para sair e re-entrar no editor.
+     1 a 3 para sair e reentrar no editor.
 
 NOTA:  :q! <ENTER>  descarta qualquer mudana. Em uma prxima lio ser
        ensinado como salvar as mudanas feitas em um arquivo.
@@ -560,7 +560,7 @@
 
   1. Mova o cursor para a linha abaixo marcada com --->.
 
-  2. Digite  :/s/aa/a <ENTER> . Note que este comando somente muda a 
+  2. Digite  :s/aa/a <ENTER> . Note que este comando somente muda a 
      primeira ocorrncia na linha.
 
   3. Agora digite  :s/aa/a/g   significando substituir globalmente na linha.
@@ -572,7 +572,7 @@
      digite  :#,#s/velho/novo/g   onde #,# so os nmeros das duas linhas.
      Digite  :%s/velho/novo/g     para mudar todas as ocorrncias no arquivo
                                   inteiro.
-     Digite  :%/velho/novo/gc     para mudar todas as ocorrncia no arquivo
+     Digite  :%s/velho/novo/gc    para mudar todas as ocorrncia no arquivo
                                   inteiro, com a opo de confirmar cada
 				  substituio.
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -971,7 +971,7 @@
   Colorado School of Mines, usando idias fornecidas por Charles Smith,
   Colorado State University.  E-mail: bware@mines.colorado.edu.
 
-  Modificado para o Vim por Bram Moolenar.
+  Modificado para o Vim por Bram Moolenaar.
 
   Verso 1.4 traduzida para o portugus por Marcelo Drudi Miranda, Escola
   Politcnica da Universidade de So Paulo.
diff -Naur vim74.orig/runtime/tutor/tutor.sr.cp1250 vim74/runtime/tutor/tutor.sr.cp1250
--- vim74.orig/runtime/tutor/tutor.sr.cp1250	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/tutor/tutor.sr.cp1250	2014-10-10 14:53:43.802048579 +0000
@@ -0,0 +1,971 @@
+===============================================================================
+=    D o b r o d o  l i   u   VIM   p r i r u  n i k  -    Verzija 1.7      =
+===============================================================================
+
+     Vim je moan editor sa mnogo komandi, suvie da bismo ih ovde sve
+     opisali.  Prirunik je zamiljen da opie dovoljno komandi da biste
+     mogli lagodno da koristite Vim kao editor opte namene.
+
+     Priblino vreme potrebno za uspean zavretak prirunika je izmeu
+     25 i 30 minuta, u zavisnosti od vremena potroenog na vebu.
+
+     UPOZORENJE:
+     Komande u lekcijama e menjati tekst.  Iskopirajte ovaj fajl i
+     vebajte na kopiji (ako ste pokrenuli "vimtutor" ovo je ve kopija).
+
+     Vano je upamtiti da je ovaj prirunik zamiljen za aktivnu vebu.
+     To znai da morate upotrebljavati komande o kojima itate da biste
+     ih nauili.  Ako samo itate tekst, zaboraviete komande!
+
+     Ako je Caps Lock ukljuen ISKLJUITE ga.  Pritisnite taster  j  dovoljno
+     puta da lekcija 1.1 cela stane na ekran.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      Lekcija 1.1:  POMERANJE KURSORA
+
+
+ ** Za pomeranje kursora, pritiskajte tastere h,j,k,l kako je prikazano **
+	     ^
+	     k		    Savet: h je s leve strane i pomera kursor u levo.
+       < h	 l >		   l je s desne strane i pomera kursor u desno.
+	     j                     j izgleda kao strelica nanie.
+	     v
+  1. Pomerajte kursor po ekranu dok se ne naviknete na komande.
+
+  2. Pritisnite taster (j) dok ne pone da se ponavlja.
+     Sada znate kako da doete do naredne lekcije.
+
+  3. Koristei taster j preite na lekciju 1.2.
+
+NAPOMENA:  Ako niste sigurni ta ste zapravo pritisnuli, pritisnite <ESC>
+           za prelazak u Normal mod i pokuajte ponovo.
+
+NAPOMENA:  Strelice takoe pomeraju kursor, ali korienje tastera hjkl je
+           znatno bre, kad se jednom naviknete na njih.  Zaista!
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			   Lekcija 1.2: IZLAZAK IZ VIM-a
+
+
+  !! UPOZORENJE: Pre izvoenja bilo kog koraka, proitajte celu lekciju!!
+
+  1. Pritisnite <ESC> (editor je sada u Normal modu).
+
+  2. Otkucajte:	:q! <ENTER>.
+     Ovime se izlazi iz editora, sa GUBITKOM svih izmena.
+
+  3. Kada se pojavi komandni prompt, unesite komandu koja je pokrenula
+     ovaj prirunik:		vimtutor <ENTER>
+
+  4. Ako ste upamtili ove korake, izvrite ih redom od 1 do 3 da biste
+     izali iz editora i ponovo ga pokrenuli.
+
+NAPOMENA:  :q! <ENTER>  ponitava sve izmene koje ste napravili.
+           U narednim lekcijama nauiete kako da sauvate izmene.
+
+  5. Pomerite kursor na lekciju 1.3.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 1.3: IZMENA TEKSTA - BRISANJE
+
+
+	      ** Pritisnite  x  za brisanje znaka pod kursorom. **
+
+  1. Pomerite kursor na red oznaen sa --->.
+
+  2. Da biste ispravili greke, pomerajte kursor dok se
+     ne nae na slovu koje treba izbrisati.
+
+  3. Pritisnite taster  x  da izbriete neeljeno slovo.
+
+  4. Ponavljajte korake od 2 do 4 dok ne ispravite sve greke.
+
+---> RRRibaa riibi grizzze rrreepp.
+
+  5. Kad ispravite red, preite na lekciju 1.4.
+
+NAPOMENA:  Dok koristite prirunik, nemojte uiti komande napamet,
+           ve vebajte njihovu primenu.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		 Lekcija 1.4: IZMENA TEKSTA - UBACIVANJE
+
+
+	  ** Pritisnite  i  za ubacivanje teksta ispred kursora. **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  2. Da biste tekst prvog reda izjednaili s tekstom drugog, namestite
+     kursor na prvi znak POSLE kog ete ubaciti potreban tekst.
+
+  3. Pritisnite  i  pa unesite potrebne dopune.
+
+  4. Po ispravci svake greke pritisnite <ESC> da se vratite u Normal mod.
+     Ponovite korake od 2 do 4 da biste ispravili celu reenicu.
+
+---> Do teka neoje v red.
+---> Deo teksta nedostaje iz ovog reda.
+
+  5. Preite na sledeu lekciju.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 1.5: IZMENA TEKSTA - DODAVANJE
+
+
+	           ** Pritisnite  A  za dodavanje teksta. **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+     Nije vano gde se nalazi kursor u tom redu.
+
+  2. Pritisnite  A  i unesite dodatni tekst.
+
+  3. Poto ste dodali tekst, pritisnite <ESC> za povratak u
+     Normal mod.
+
+  4. Pomerite kursor na drugi red oznaen sa ---> i ponavljajte
+     korake 2 i 3 dok ne ispravite tekst.
+
+---> Deo teksta nedostaje u
+     Deo teksta nedostaje u ovom redu.
+---> Deo teksta nedostaje
+     Deo teksta nedostaje i ovde.
+
+  5. Preite na lekciju 1.6.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     Lekcija 1.6: IZMENA FAJLA
+
+
+     ** Upotrebite  :wq  za snimanje teksta i izlazak iz editora. **
+
+  !! UPOZORENJE: Pre izvoenja bilo kog koraka, proitajte celu lekciju!!
+
+  1. Izaite iz editora kao u lekciji 1.2:  :q!
+
+  2. Na komandnom promptu unesite sledeu komandu:  vim tutor <ENTER>
+     'vim' je komanda za pokretanja Vim editora, 'tutor' je ime fajla koji
+     elite da menjate.  Koristite fajl koji imate pravo da menjate.
+
+  3. Ubacujte i briite tekst kao u prethodnim lekcijama.
+
+  4. Snimite izmenjeni tekst i izaite iz Vim-a:  :wq <ENTER>
+
+  5. Ponovo pokrenite vimtutor i proitajte rezime koji sledi.
+
+  6. Poto proitate korake iznad i u potpunosti ih razumete:
+     izvrite ih.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 1 
+
+
+  1. Kursor se pomera strelicama ili pomou tastera hjkl .
+	h (levo)	j (dole)	k (gore)	l (desno)
+
+  2. Za pokretanje Vim-a iz shell-a:  vim IME_FAJLA <ENTER>
+
+  3. Izlaz:	<ESC>	:q! <ENTER> 	sve promene su izgubljene.
+       ILI:	<ESC>	:wq <ENTER> 	promene su sauvane.
+
+  4. Brisanje znaka na kome se nalazi kursor:  x
+
+  5. Ubacivanja ili dodavanje teksta:
+	 i   unesite tekst <ESC>	unos ispred kursora
+	 A   unesite tekst <ESC>	dodavanje na kraju reda
+
+NAPOMENA:  Pritiskom na <ESC> prebacujete Vim u Normal mod i
+           prekidate neeljenu ili delimino izvrenu komandu.
+
+Nastavite sa lekcijom 2.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			Lekcija 2.1: NAREDBE BRISANJA
+
+
+		 ** Otkucajte  dw  za brisanje rei. **
+
+  1. Pritisnite  <ESC>  da biste bili sigurni da ste u Normal modu.
+
+  2. Pomerite kursor na red oznaen sa --->.
+
+  3. Pomerite kursor na poetak rei koju treba izbrisati.
+
+  4. Otkucajte  dw  da biste uklonili re.
+
+NAPOMENA:  Slovo  d  e se pojaviti na dnu ekrana kad ga otkucate.  Vim eka
+	   da otkucate  w .  Ako je prikazano neko drugo slovo, pogreili ste u
+	   kucanju; pritisnite <ESC> i pokuajte ponovo.  (Ako se ne pojavi
+	   nita, moda je iskljuena opcija 'showcmd': vidi lekciju 6.5.)
+
+---> Neke rei smeno ne pripadaju na papir ovoj reenici.
+
+  5. Ponavljajte korake 3 i 4 dok ne ispravite reenicu, pa
+     preite na lekciju 2.2.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      Lekcija 2.2: JO BRISANJA
+
+
+       ** Otkucajte  d$  za brisanje znakova do kraja reda. **
+
+  1. Pritisnite  <ESC>  da biste bili sigurni da ste u Normal modu.
+
+  2. Pomerite kursor na red oznaen sa  --->.
+
+  3. Pomerite kursor do kraja ispravnog dela reenice
+     (POSLE prve . ).
+
+  4. Otkucajte  d$  za brisanje ostatka reda.
+
+---> Neko je uneo kraj ovog reda dvaput. kraj ovog reda dvaput.
+
+  5. Preite na lekciju 2.3 za podrobnije objanjenje.
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	      Lekcija 2.3: O OPERATORIMA I POKRETIMA
+
+
+  Mnoge komande za izmenu teksta sastoje se od operatora i pokreta.
+  Oblik komande brisanja sa  d  operatorom je sledei:
+
+  	d   pokret
+
+  Pri emu je:
+    d      - operator brisanja.
+    pokret - ono na emu e se operacija izvravati (opisano u nastavku).
+
+  Kratak spisak pokreta:
+    w - sve do poetka sledee rei, NE UKLJUUJUI prvo slovo.
+    e - sve do kraja tekue rei, UKLJUUJUI poslednje slovo.
+    $ - sve do kraje reda, UKLJUUJUI poslednje slovo.
+
+  Kucanjem  de  brisae se tekst od kursora do kraja rei.
+
+NAPOMENA:  Pritiskom samo na taster pokreta dok ste u Normal modu, bez
+           operatora, kursor se pomera kao to je opisano.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  Lekcija 2.4: KORIENJE BROJANJA ZA POKRETE
+
+
+  ** Unoenjem nekog broja pre pokreta, pokret se izvrava taj broj puta. **
+
+  1. Pomerite kursor na red oznaen sa --->.
+
+  2. Otkucajte  2w  da pomerite kursor dve rei napred.
+
+  3. Otkucajte  3e  da pomerite kursor na kraj tree rei napred.
+
+  4. Otkucajte  0  (nulu) da pomerite kursor na poetak reda.
+
+  5. Ponovite korake 2 i 3 s nekim drugim brojevima.
+
+---> Reenica sa reima po kojoj moete pomerati kursor.
+
+  6. Preite na lekciju 2.5.
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+             Lekcija 2.5: KORIENJE BROJANJA ZA VEE BRISANJE
+
+
+  ** Unoenje nekog broja s operatorom ponavlja operator taj broj puta. **
+
+  U kombinaciji operatora brisanja s pokretima spomenutim iznad
+  moete uneti broj pre pokreta da biste izbrisali vie znakova:
+
+	 d   broj   pokret
+
+  1. Pomerite kursor na prvo slovo u rei s VELIKIM SLOVIMA u redu
+     oznaenom sa --->.
+
+  2. Otkucajte  d2w  da izbriete dve rei sa VELIKIM SLOVIMA
+
+  3. Ponovite korake 1 i 2 sa razliitim brojevima da izbriete
+     uzastopne rei sa VELIKIM SLOVIMA korienjem samo jedne komande.
+
+---> ovaj ABC DE red FGHI JK LMN OP s reima je RS TUVZ ispravljen.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     Lekcija 2.6: OPERACIJE NAD REDOVIMA
+
+
+	       ** Otkucajte  dd  za brisanje celog reda. **
+
+  Zbog uestalosti brisanja celih redova, autori Vi-ja odluili su da
+  je lake brisati redove ako se otkuca  d  dvaput.
+
+  1. Pomerite kursor na drugi red u donjoj strofi.
+  2. Otkucajte  dd  da ga izbriete.
+  3. Pomerite kursor na etvrti red.
+  4. Otkucajte   2dd   da biste izbrisali dva reda.
+
+--->  1)  Sedlo mi je od marame,
+--->  2)  blato na sve strane,
+--->  3)  uzda od kanapa,
+--->  4)  auto mi je ovde,
+--->  5)  satovi pokazuju vreme,
+--->  6)  a bi mi je od oina
+--->  7)  prebijena tapa.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      Lekcija 2.7: PONITAVANJE PROMENA
+
+
+  ** Pritisnite  u  za ponitavanje poslednje komande,  U  za ceo red. **
+
+  1. Pomerite kursor na red oznaen sa ---> i postavite ga na mesto
+     prve greke.
+  2. Otkucajte  x  da izbriete prvi neeljeni znak.
+  3. Otkucajte  u  da ponitite poslednju izvrenu komandu.
+  4. Sad ispravite sve greke u redu koristei komandu  x  .
+  5. Otkucajte veliko  U  da biste vratili sadraj reda u prvobitno
+     stanje.
+  6. Onda otkucajte  u  nekoliko puta da biste ponitili  U
+     i prethodne komande.
+  7. Sad otkucajte CTRL-R (drei  CTRL  dok pritiskate R)
+     nekoliko puta da biste vratili izmene (ponitili ponitavanja).
+
+---> Iiisspravite greke uu ovvom redu ii poonititeee ih.
+
+  8. Ovo su veoma korisne komande.  Preite na rezime lekcije 2.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 2
+
+
+  1. Brisanje od kursora do sledee rei:	dw
+  2. Brisanje od kursora do kraja reda:		d$
+  3. Brisanje celog reda:			dd
+
+  4. Za ponavljanje pokreta prethodno unesite broj:  2w
+  5. Oblik komande za izmenu:
+               operator   [broj]   pokret
+     gde je:
+       operator - ta uraditi, recimo  d  za brisanje
+       [broj]   - neobavezan broj ponavljanja pokreta
+       pokret   - kretanje po tekstu na kome se radi,
+                  kao to je: w (re), $ (kraj reda), itd.
+
+  6. Pomeranje kursora na poetak reda:  0
+
+  7. Za ponitavanje prethodnih izmena, pritisnite:	u  (malo u)
+     Za ponitavanje svih promena u redu, pritisnite:	U  (veliko U)
+     Za vraanja promena, otkucajte:			CTRL-R
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       Lekcija 3.1: KOMANDA POSTAVLJANJA
+
+
+  ** Otkucajte  p  da postavite prethodno izbrisan tekst iza kursora. **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  2. Otkucajte  dd  da izbriete red i smestite ga u Vim registar.
+
+  3. Pomerite kursor na red c), IZNAD mesta gde treba postaviti izbrisan red.
+
+  4. Otkucajte  p  da postavite red ispod kursora.
+
+  5. Ponavljajte korake 2 do 4 da biste postavili sve linije u pravilnom
+     redosledu.
+
+---> d) prebijena tapa.
+---> b) uzda od kanapa,
+---> c) a bi mi je od oina
+---> a) Sedlo mi je od marame,
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       Lekcija 3.2: KOMANDA ZAMENE
+
+
+      ** Otkucajte  rx  da zamenite znak ispod kursora slovom  x . **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  2. Pomerite kursor tako da se nalazi na prvoj greci.
+
+  3. Otkucajte  r  i onda znak koji treba da tu stoji.
+
+  4. Ponavljajte korake 2 i 3 sve dok prvi red ne bude
+     isti kao drugi.
+
+--->  Kedi ju ovej red ugaen, nako je protresao pustane testere!
+--->  Kada je ovaj red unoen, neko je pritiskao pogrene tastere!
+
+  5. Preite na lekciju 3.2.
+
+NAPOMENA:  Setite se da treba da uite vebanjem, ne pamenjem.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 3.3: OPERATOR IZMENE
+
+
+	  ** Za izmenu teksta do kraja rei, otkucajte  ce  .**
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  2. Postavite kursor na  a  u  rakdur.
+
+  3. Otkucajte  ce  i ispravite re (u ovom sluaju otkucajte  ed  ).
+
+  4. Pritisnite <ESC> i pomerite kursor na sledei znak koji
+     treba ispraviti.
+
+  5. Ponavljajte korake 3 i 4 sve dok prva reenica ne bude ista
+     kao druga.
+
+---> Ovaj rakdur ima nekoliko rejga koje treflja isprpikati operagrom izmene.
+---> Ovaj red ima nekoliko rei koje treba ispraviti operatorom izmene.
+
+Uoite da  ce  brie re i postavlja editor u Insert mod.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	         Lekcija 3.4: DALJE IZMENE UPOTREBOM c
+
+
+    ** Komanda izmene se koristi sa istim pokretima kao i brisanje. **
+
+  1. Operator izmene se koristi na isti nain kao i operator brisanja:
+
+         c    [broj]   pokret
+
+  2. Pokreti su isti, recimo:   w (re) i  $ (kraj reda).
+
+  3. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  4. Pomerite kursor na prvu greku.
+
+  5. Otkucajte  c$  i unesite ostatak reda tako da bude isti kao
+     drugi red, pa pritisnite <ESC>.
+
+---> Kraj ovog reda treba izmeniti tako da izgleda kao red ispod.
+---> Kraj ovog reda treba ispraviti korienjem c$ komande.
+
+NAPOMENA:  Za ispravljanje greaka moete koristiti Backspace .
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 3
+
+
+  1. Za postavljanje teksta koji ste upravo izbrisali, pritisnite  p . Ovo
+     postavlja tekst IZA kursora (ako je bio izbrisan jedan ili vie redova
+     sadraj e doi na red ispod kursora).
+
+  2. Za zamenu znaka na kome se nalazi kursor, pritisnite  r  i onda
+     eljeni znak.
+
+  3. Operator izmene dozvoljava promenu teksta od kursora do pozicije gde
+     se zavrava pokret.  Primera radi, kucajte  ce  za izmenu od kursora do
+     kraja rei, ili  c$  za izmenu od kursora do kraja reda.
+
+  4. Oblik operacije izmene je:
+
+	 c   [broj]   pokret
+
+Preite na narednu lekciju.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	      Lekcija 4.1: POZICIJA KURSORA I STATUS FAJLA
+
+  ** Pritisnite CTRL-G za prikaz pozicije kursora u tekstu i status fajla.
+     Pritisnite  G  za pomeranje kursora na neki red u tekstu. **
+
+NAPOMENA:  Proitajte celu lekciju pre izvoenja bilo kog koraka!!
+
+  1. Drite taster CTRL i pritisnite  g .  Ovo zovemo CTRL-G.
+     Editor e na dnu ekrana ispisati poruku sa imenom fajla i pozicijom
+     kursora u tekstu.  Zapamtite broj reda za 3. korak.
+
+NAPOMENA:  U donjem desnom uglu moe se videti poziciju kursora ako je
+           ukljuena opcija 'ruler' (vidi  :help ruler  ili lekciju 6.5.)
+
+  2. Pritisnite  G  za pomeranje kursora na kraj teksta.
+     Pritisnite  1G  ili  gg  za pomranje kursora na poetak teksta.
+
+  3. Otkucajte broj reda na kome ste malopre bili i onda  G .  Kursor
+     e se vratiti na red na kome je bio kad ste otkucali CTRL-G.
+
+  4. Ako ste spremni, izvrite korake od 1 do 3.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 4.2: KOMANDE PRETRAIVANJA
+
+       ** Otkucajte  /  i onda izraz koji elite da potraite. **
+
+  1. U Normal modu otkucajte znak  / .  Primietite da se znak pojavio
+     zajedno sa kursorom na dnu ekrana kao i kod komande  : .
+
+  2. Sada otkucajte 'grrreka' <ENTER>.  (Bez razmaka i navodnika.)
+     To je re koju traite.
+
+  3. Za ponovno traenje istog izraza, otkucajte  n .
+     Za traenje istog izraza u suprotnom smeru, otkucajte  N .
+
+  4. Za traenje izraza unatrag, koristite  ?  umesto  / .
+
+  5. Za povratak na prethodnu poziciju otkucajte CTRL-O (drite CTRL dok
+     pritiskate O ).  Ponavljajte za ranije pozicije.  CTRL-I ide napred.
+
+---> "grrreka" je pogreno; umesto grrreka treba da stoji greka.
+
+NAPOMENA:  Ako pretraga doe do kraja teksta traenje e se nastaviti od
+	   njegovog poetka osim ako je opcija 'wrapscan' iskljuena.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  Lekcija 4.3: TRAENJE PARA ZAGRADE
+
+
+	** Otkucajte  %  za nalaenje para ), ] ili } . **
+
+  1. Postavite kursor na bilo koju od  ( ,  [  ili  {
+     otvorenih zagrada u redu oznaenom sa --->.
+
+  2. Otkucajte znak  % .
+
+  3. Kursor e se pomeriti na odgovarajuu zatvorenu zagradu.
+
+  4. Otkucajte  %  da pomerite kursor na prvu zagradu u paru.
+
+      5. Pomerite kursor na neku od (,),[,],{ ili } i ponovite komandu  % .
+
+---> Red ( testiranja obinih ( [ uglastih ] i { vitiastih } zagrada.))
+
+
+NAPOMENA:  Vrlo korisno u ispravljanju koda sa rasparenim zagradama!
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      Lekcija 4.4: KOMANDA ZAMENE
+
+
+       ** Otkucajte  :s/staro/novo/g  da zamenite 'staro' za 'novo'. **
+
+  1. Pomerite kursor na red oznaen sa --->.
+
+  2. Otkucajte  :s/rdi/ri/ <ENTER> .  Primetite da ova komanda zamenjuje
+     samo prvo "rdi" u redu.
+
+  3. Otkucajte  :s/rdi/ri/g .  Dodavanje opcije  g  znai da e se komanda
+     izvriti u celom redu, zamenom svih pojava niza "rdi".
+
+---> rdiba rdibi grdize rep.
+
+  4. Za zamenu svih izraza izmeu neka dva reda,
+     otkucajte :#,#s/staro/novo/g   gde su #,# krajnji brojevi redova u opsegu 
+                                    u kome e se obaviti zamena.
+     Otkucajte :%s/staro/novo/g     za zamenu svih izraza u celom tekstu.
+     Otkucajte :%s/staro/novo/gc    za nalaenje svih izraza u tekstu i
+     			            potvrdu zamene.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 4
+
+
+  1. CTRL-G  prikazuje poziciju kursora u tekstu i status fajla.
+             G  pomera kursor na kraj teksta.
+     broj    G  pomera kursor na navedeni red.
+            gg  pomera kursor na prvi red teksta.
+
+  2. Kucanjem  /  sa izrazom taj izraz se trai UNAPRED.
+     Kucanjem  ?  sa izrazom taj izraz se trai UNAZAD.
+     Posle komande traenja koristite  n  za nalaenje izraza u istom
+     smeru, a  N  za nalaenje u suprotnom smeru.
+     CTRL-O vraa kursor na prethodnu poziciju, a CTRL-I na narednu.
+
+  3. Kucanjem  %  kad je kursor na zagradi on se pomera na njen par.
+
+  4. Za zamenu prvog izraza staro za izraz novo            :s/staro/novo/
+     Za zamenu svih izraza u celom redu                    :s/staro/novo/g
+     Za zamenu svih izraza u opsegu linija #,#             :#,#s/staro/novo/g
+     Za zamenu u celom tekstu                              :%s/staro/novo/g
+     Za potvrdu svake zamene dodajte 'c'		   :%s/staro/novo/gc
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		Lekcija 5.1: IZVRAVANJE SPOLJANJIH KOMANDI
+
+
+  ** Otkucajte  :!  pa spoljanju komandu koju elite da izvrite. **
+
+  1. Otkucajte poznatu komandu  :  da biste namestili kursor na dno
+     ekrana.  Time omoguavate unos komande u komandnoj liniji editora.
+
+  2. Otkucajte znak  !  (uzvinik).  Ovime omoguavate
+     izvravanje bilo koje spoljanje komande.
+
+  3. Kao primer otkucajte   ls   posle ! i pritisnite <ENTER>.  Ovo e
+     prikazati sadraj direktorijuma, kao da ste na komandnom promptu.
+     Otkucajte   :!dir   ako   :!ls   ne radi.
+
+NAPOMENA:  Na ovaj nain mogue je izvriti bilo koju spoljanju komandu,
+           zajedno sa njenim argumentima.
+
+NAPOMENA:  Sve  :  komande se izvravaju poto pritisnete <ENTER> .
+	   U daljem tekstu to neemo uvek napominjati.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   Lekcija 5.2: VIE O SNIMANJU FAJLOVA
+
+           ** Za snimanje promena, otkucajte  :w IME_FAJLA . **
+
+  1. Otkucajte  :!dir  ili  :!ls  za pregled sadraja direktorijuma.
+     Ve znate da morate pritisnuti <ENTER> posle toga.
+
+  2. Izaberite ime fajla koji jo ne postoji, npr. TEST.
+
+  3. Otkucajte:	 :w TEST   (gde je TEST ime koje ste izabrali.)
+
+  4. Time ete snimiti ceo fajl (Vim Tutor) pod imenom TEST.
+     Za proveru, otkucajte opet  :!dir  ili  :!ls za pregled
+     sadraja direktorijuma.
+
+NAPOMENA:  Ako biste napustili Vim i ponovo ga pokrenuli sa vim TEST ,
+           tekst bi bio tana kopija ovog fajla u trenutku kad ste
+	   ga snimili.
+
+  5. Izbriite fajl tako to ete otkucati (MS-DOS):	:!del TEST
+				         ili (Unix):	:!rm TEST
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  Lekcija 5.3: SNIMANJE OZNAENOG TEKSTA
+
+
+   ** Da biste snimili deo teksta, otkucajte  v  pokret  :w IME_FAJLA **
+
+  1. Pomerite kursor na ovu liniju.
+
+  2. Pritisnite  v  i pomerite kursor pet redova ispod.  Primetite da je
+     tekst oznaen inverzno.
+
+  3. Pritisnite  : .  Na dnu ekrana pojavie se  :'<,'> .
+
+  4. Otkucajte  w TEST  , gde je TEST ime fajla koji jo ne postoji.
+     Proverite da zaista pie  :'<,'>w TEST  pre nego to pritisnete <ENTER>.
+
+  5. Vim e snimiti oznaeni tekst u TEST.  Proverite sa  :!dir  ili  !ls .
+     Nemojte jo brisati fajl!  Koristiemo ga u narednoj lekciji.
+
+NAPOMENA:  Komanda  v  zapoinje vizuelno oznaavanje.  Moete pomerati kursor
+           i tako menjati veliinu oznaenog teksta.  Onda moete upotrebiti
+           operatore nad tekstom.  Na primer,  d  e izbrisati oznaeni tekst.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   Lekcija 5.4: UITAVANJE FAJLA U TEKST
+
+
+       ** Za ubacivanje sadraja fajla, otkucajte  :r IME_FAJLA  **
+
+  1. Postavite kursor iznad ove linije.
+
+NAPOMENA:  Poto izvrite 2. korak videete tekst iz lekcije 5.3.  Tada
+           pomerite kursor DOLE da biste ponovo videli ovu lekciju.
+
+  2. Uitajte fajl TEST koristei komandu  :r TEST  gde je TEST ime fajla
+     koje ste koristili u prethodnoj lekciji.  Sadraj uitanog fajla je
+     ubaen ispod kursora.
+
+  3. Da biste proverili da je fajl uitan, vratite kursor unazad i
+     primetite dve kopije lekcije 5.3, originalnu i onu iz fajla.
+
+NAPOMENA:  Takoe moete uitati izlaz spoljanje komande.  Na primer,
+	   :r !ls  e uitati izlaz komande  ls  i postaviti ga ispod
+           kursora.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 5
+
+
+  1.  :!komanda  izvrava spoljanju komandu.
+
+      Korisni primeri:
+	 (MS-DOS)	  (Unix)
+	  :!dir		   :!ls		   -  pregled sadraja direktorijuma.
+	  :!del FAJL       :!rm FAJL       -  brie fajl FAJL.
+
+  2.  :w FAJL  zapisuje trenutni tekst na disk pod imenom FAJL.
+
+  3.  v  pokret  :w IME_FAJLA  snima vizuelno oznaene redove u fajl
+      IME_FAJLA.
+
+  4.  :r IME_FAJLA  uitava fajl IME_FAJLA sa diska i stavlja
+      njegov sadraj ispod kursora.
+
+  5.  :r !dir  uitava izlaz komande dir i postavlja ga ispod kursora.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 Lekcija 6.1: KOMANDA OTVORI
+
+
+	** Pritisnite  o  da biste otvorili red ispod kursora
+	   i preli u Insert mod. **
+
+  1. Pomerite kursor na sledei red oznaen sa --->.
+
+  2. Otkucajte malo  o  da biste otvorili novi red ISPOD kursora
+     i preli u Insert mod.
+
+  3. Otkucajte neki tekst i onda pritisnite <ESC> da biste izali
+     iz Insert moda.
+
+---> Kad pritisnete  o  kursor prelazi u novootvoreni red u Insert modu.
+
+  4. Za otvaranje reda IZNAD kursora, umesto malog otkucajte veliko O .
+     Isprobajte na donjem redu oznaenom sa --->.
+
+---> Otvorite red iznad ovog kucanjem velikog  O  dok je kursor u ovom redu.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			Lekcija 6.2: KOMANDA DODAJ
+
+
+	     ** Otkucajte  a  za dodavanje teksta IZA kursora. **
+
+  1. Pomerite kursor na poetak sledeeg reda oznaenog sa --->.
+  
+  2. Kucajte  e  dok kursor ne doe na kraj rei  re .
+
+  3. Otkucajte  a  (malo) da biste dodali tekst IZA kursora.
+
+  4. Dopunite re kao to je u redu ispod.  Pritisnite <ESC> za izlazak
+     iz Insert moda.
+
+  5. Sa  e  preite na narednu nepotpunu re i ponovite korake 3 i 4.
+  
+---> Ovaj re omoguava ve dodav teksta u nekom redu.
+---> Ovaj red omoguava vebanje dodavanja teksta u nekom redu.
+
+NAPOMENA:  Komande a, i, i  A  aktiviraju isti Insert mod, jedina
+           razlika je u poziciji od koje e se tekst ubacivati.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 6.3: DRUGI NAIN ZAMENE
+
+
+      ** Otkucajte veliko  R  da biste zamenili vie od jednog znaka. **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+     Pomerite kursor na poetak prvog  xxx .
+
+  2. Pritisnite  R  i otkucajte broj koji je red ispod,
+     tako da zameni xxx .
+
+  3. Pritisnite <ESC> za izlazak iz Replace moda.
+     Primetite da je ostatak reda ostao nepromenjen.
+
+  4. Ponovite korake da biste zamenili drugo xxx.
+
+---> Dodavanje 123 na xxx daje xxx.
+---> Dodavanje 123 na 456 daje 579.
+
+NAPOMENA:  Replace mod je kao Insert mod, s tom razlikom to svaki
+           uneti znak brie ve postojei.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		Lekcija 6.4: KOPIRANJE I LEPLJENJE TEKSTA
+
+
+    ** Koristite operator  y  za kopiranje a  p  za lepljenje teksta. **
+
+  1. Pomerite kursor na red sa --->  i postavite kursor posle "a)".
+  
+  2. Aktivirajte Visual mod sa  v  i pomerite kursor sve do ispred "prvi".
+  
+  3. Pritisnite  y  da biste kopirali oznaeni tekst u interni bafer.
+
+  4. Pomerite kursor do kraja sledeeg reda:  j$
+
+  5. Pritisnite  p  da biste zalepili tekst.  Onda otkucajte:  a drugi <ESC> .
+
+  6. Upotrebite Visual mod da oznaite " red.", kopirajte sa  y , kursor
+     pomerite na kraj sledeeg reda sa  j$  i tamo zalepite tekst sa  p .
+
+--->  a) ovo je prvi red.
+      b)
+
+NAPOMENA:  takoe moete koristiti  y  kao operator;  yw  kopira jednu re.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 6.5: POSTAVLJANJE OPCIJA
+
+
+ ** Postavite opciju tako da traenje i zamena ignoriu veliinu slova **
+
+  1. Potraite re 'razlika':  /razlika <ENTER>
+     Ponovite nekoliko puta pritiskom na  n .
+
+  2. Aktivirajte opciju 'ic' (Ignore case):  :set ic
+
+  3. Ponovo potraite re 'razlika' pritiskom na  n
+     Primetite da su sada pronaeni i RAZLIKA i Razlika.
+
+  4. Aktivirajte opcije 'hlsearch' i 'incsearch':  :set hls is
+
+  5. Ponovo otkucajte komandu traenja i uoite razlike:  /razlika <ENTER>
+
+  6. Za deaktiviranje opcije  ic  kucajte:  :set noic
+
+NAPOMENA:  Za neoznaavanje pronaenih izraza otkucajte:  :nohlsearch
+NAPOMENA:  Ako elite da ne razlikujete veliinu slova u samo jednoj komandi
+	   traenja, dodajte  \c  u izraz:  /razlika\c <ENTER>
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 6
+
+  1. Pritisnite  o  za otvaranje reda ISPOD kursora i prelazak u Insert mod.
+     Pritisnite  O  za otvaranje reda IZNAD kursora.
+
+  2. Pritisnite  a  za unos teksta IZA kursora.
+     Pritisnite  A  za unos teksta na kraju reda.
+
+  3. Komanda  e  pomera kursor na kraj rei.
+
+  4. Operator  y  kopira tekst,  p  ga lepi.
+
+  5. Kucanje velikog  R  aktivira Replace mod dok ne pritisnete <ESC> .
+
+  6. Kucanje ":set xxx" aktivira opciju "xxx".  Neke opcije su:
+  	'ic' 'ignorecase'	ne razlikuje velika/mala slova pri traenju
+	'is' 'incsearch'	prikazuje pronaen tekst dok kucate izraz
+	'hls' 'hlsearch'	oznaava inverzno sve pronaene izraze
+     Moete koristite dugo ili kratko ime opcije.
+
+  7. Ispred imena opcije stavite "no" da je deaktivirate:  :set noic
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       Lekcija 7.1: DOBIJANJE POMOI
+
+
+		   ** Koristite on-line sistem za pomo **
+
+  Vim ima detaljan on-line sistem za pomo.  Za poetak, pokuajte neto
+  od sledeeg:
+	- pritisnite taster <HELP> (ako ga imate na tastaturi)
+	- pritisnite taster <F1> (ako ga imate na tastaturi)
+	- otkucajte  :help <ENTER>
+
+  Proitajte tekst u prozoru pomoi da biste nauili pomo radi.
+  Kucanjem  CTRL-W CTRL-W  prelazite iz jednog prozora u drugi.
+  Otkucajte  :q <ENTER>  da zatvorite prozor pomoi.
+
+  Pomo o praktino bilo kojoj temi moete dobiti dodavanjem argumenta
+  komandi ":help".  Pokuajte ovo (ne zaboravite <ENTER> na kraju):
+
+	:help w
+	:help c_CTRL-D
+	:help insert-index
+	:help user-manual
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		Lekcija 7.2: PRAVLJENJE STARTNOG SKRIPTA
+
+
+		   ** Aktivirajte mogunosti editora **
+
+  Vim ima mnogo vie mogunosti nego Vi, ali veina nije automatski
+  aktivirana.  Za dodatne mogunosti napravite "vimrc" fajl.
+
+  1. Otvorite "vimrc" fajl.  Ovo zavisi od vaeg sistema:
+	:e ~/.vimrc		za Unix
+	:e $VIM/_vimrc		za MS-Windows
+
+  2. Onda uitajte primer sadraja "vimrc" fajla:
+	:r $VIMRUNTIME/vimrc_example.vim
+
+  3. Snimite fajl sa:
+	:w
+
+  Sledei put kada pokrenete Vim, bojenje sintakse teksta bie
+  aktivirano. Sva svoja podeavanja moete dodati u "vimrc" fajl.
+  Za vie informacija otkucajte  :help vimrc-intro
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     Lekcija 7.3: AUTOMATSKO DOVRAVANJE
+
+
+	** Dovravanje komandne linije sa CTRL-D i <TAB> **
+
+  1. Podesite Vim da ne bude u Vi-kompatibilnom modu:  :set nocp
+
+  2. Pogledajte koji fajlovi postoje u direktorijumu:  :!ls  ili  :!dir
+
+  3. Otkucajte poetak komande:  :e
+
+  4. Otkucajte  CTRL-D  i Vim e prikazati spisak komandi koje poinju sa "e".
+
+  5. Pritisnite <TAB>  i Vim e dopuniti ime komande u ":edit".
+
+  6. Dodajte razmak i poetak imena postojeeg fajla:  :edit FA
+
+  7. Pritisnite <TAB>.  Vim e dopuniti ime fajla (ako je jedinstveno).
+
+NAPOMENA:  Mogue je dopuniti mnoge komande.  Samo probajte CTRL-D i <TAB>.
+           Naroito je korisno za  :help  komande.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 7
+
+
+  1. Otkucajte  :help  ili pritisnite <F1> ili <Help>  za pomo.
+
+  2. Otkucajte  :help komanda  biste dobili pomo za tu komandu.
+
+  3. Otkucajte  CTRL-W CTRL-W  za prelazak u drugi prozor.
+
+  4. Otkucajte  :q  da zatvorite prozor pomoi.
+
+  5. Napravite vimrc startni skript za aktiviranje podeavanja koja
+     vam odgovaraju.
+
+  6. Dok kucate neku od  :  komandi, pritisnite CTRL-D da biste videli mogue
+     vrednosti.  Pritisnite <TAB> da odaberete jednu od njih.
+
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  Ovim je prirunik zavren.  Njegov cilj je bio kratak pregled Vim editora,
+  koliko da omogui njegovo relativno jednostavno korienje.  Prirunik nije
+  potpun, jer Vim ima mnogo vie komandi.  Kao sledee, proitajte prirunik:
+  ":help user-manual".
+
+  Za dalje itanje i uenje, preporuujemo knjigu:
+	Vim - Vi Improved - by Steve Oualline
+	Izdava: New Riders
+  Prva knjiga potpuno posveena Vim-u.  Naroito korisna za poetnike.
+  Ima mnotvo primera i slika.
+  Vidite http://iccf-holland.org/click5.html
+
+  Sledea knjiga je starija i vie govori o Vi-u nego o Vim-u, ali je takoe
+  preporuujemo:
+	Learning the Vi Editor - by Linda Lamb
+	Izdava: O'Reilly & Associates Inc.
+  Dobra knjiga iz koje moete saznati skoro sve to moete raditi u Vi-ju.
+  esto izdanje ima i informacija o Vim-u.
+
+  Ovaj prirunik su napisali: Michael C. Pierce i Robert K. Ware,
+  Colorado School of Mines koristei ideje Charlesa Smitha,
+  Colorado State University.  E-mail: bware@mines.colorado.edu.
+
+  Prilagoavanje za Vim uradio je Bram Moolenaar.
+
+  Prevod na srpski: Ivan Nejgebauer <ian@uns.ac.rs>
+  Verzija 1.0, maj/juni 2014.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/tutor/tutor.sr.utf-8 vim74/runtime/tutor/tutor.sr.utf-8
--- vim74.orig/runtime/tutor/tutor.sr.utf-8	1970-01-01 00:00:00.000000000 +0000
+++ vim74/runtime/tutor/tutor.sr.utf-8	2014-10-10 14:53:43.805381904 +0000
@@ -0,0 +1,971 @@
+===============================================================================
+=    D o b r o d o  l i   u   VIM   p r i r u  n i k  -    Verzija 1.7      =
+===============================================================================
+
+     Vim je moan editor sa mnogo komandi, suvie da bismo ih ovde sve
+     opisali.  Prirunik je zamiljen da opie dovoljno komandi da biste
+     mogli lagodno da koristite Vim kao editor opte namene.
+
+     Priblino vreme potrebno za uspean zavretak prirunika je izmeu
+     25 i 30 minuta, u zavisnosti od vremena potroenog na vebu.
+
+     UPOZORENJE:
+     Komande u lekcijama e menjati tekst.  Iskopirajte ovaj fajl i
+     vebajte na kopiji (ako ste pokrenuli "vimtutor" ovo je ve kopija).
+
+     Vano je upamtiti da je ovaj prirunik zamiljen za aktivnu vebu.
+     To znai da morate upotrebljavati komande o kojima itate da biste
+     ih nauili.  Ako samo itate tekst, zaboraviete komande!
+
+     Ako je Caps Lock ukljuen ISKLJUITE ga.  Pritisnite taster  j  dovoljno
+     puta da lekcija 1.1 cela stane na ekran.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      Lekcija 1.1:  POMERANJE KURSORA
+
+
+ ** Za pomeranje kursora, pritiskajte tastere h,j,k,l kako je prikazano **
+	     ^
+	     k		    Savet: h je s leve strane i pomera kursor u levo.
+       < h	 l >		   l je s desne strane i pomera kursor u desno.
+	     j                     j izgleda kao strelica nanie.
+	     v
+  1. Pomerajte kursor po ekranu dok se ne naviknete na komande.
+
+  2. Pritisnite taster (j) dok ne pone da se ponavlja.
+     Sada znate kako da doete do naredne lekcije.
+
+  3. Koristei taster j preite na lekciju 1.2.
+
+NAPOMENA:  Ako niste sigurni ta ste zapravo pritisnuli, pritisnite <ESC>
+           za prelazak u Normal mod i pokuajte ponovo.
+
+NAPOMENA:  Strelice takoe pomeraju kursor, ali korienje tastera hjkl je
+           znatno bre, kad se jednom naviknete na njih.  Zaista!
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			   Lekcija 1.2: IZLAZAK IZ VIM-a
+
+
+  !! UPOZORENJE: Pre izvoenja bilo kog koraka, proitajte celu lekciju!!
+
+  1. Pritisnite <ESC> (editor je sada u Normal modu).
+
+  2. Otkucajte:	:q! <ENTER>.
+     Ovime se izlazi iz editora, sa GUBITKOM svih izmena.
+
+  3. Kada se pojavi komandni prompt, unesite komandu koja je pokrenula
+     ovaj prirunik:		vimtutor <ENTER>
+
+  4. Ako ste upamtili ove korake, izvrite ih redom od 1 do 3 da biste
+     izali iz editora i ponovo ga pokrenuli.
+
+NAPOMENA:  :q! <ENTER>  ponitava sve izmene koje ste napravili.
+           U narednim lekcijama nauiete kako da sauvate izmene.
+
+  5. Pomerite kursor na lekciju 1.3.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 1.3: IZMENA TEKSTA - BRISANJE
+
+
+	      ** Pritisnite  x  za brisanje znaka pod kursorom. **
+
+  1. Pomerite kursor na red oznaen sa --->.
+
+  2. Da biste ispravili greke, pomerajte kursor dok se
+     ne nae na slovu koje treba izbrisati.
+
+  3. Pritisnite taster  x  da izbriete neeljeno slovo.
+
+  4. Ponavljajte korake od 2 do 4 dok ne ispravite sve greke.
+
+---> RRRibaa riibi grizzze rrreepp.
+
+  5. Kad ispravite red, preite na lekciju 1.4.
+
+NAPOMENA:  Dok koristite prirunik, nemojte uiti komande napamet,
+           ve vebajte njihovu primenu.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		 Lekcija 1.4: IZMENA TEKSTA - UBACIVANJE
+
+
+	  ** Pritisnite  i  za ubacivanje teksta ispred kursora. **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  2. Da biste tekst prvog reda izjednaili s tekstom drugog, namestite
+     kursor na prvi znak POSLE kog ete ubaciti potreban tekst.
+
+  3. Pritisnite  i  pa unesite potrebne dopune.
+
+  4. Po ispravci svake greke pritisnite <ESC> da se vratite u Normal mod.
+     Ponovite korake od 2 do 4 da biste ispravili celu reenicu.
+
+---> Do teka neoje v red.
+---> Deo teksta nedostaje iz ovog reda.
+
+  5. Preite na sledeu lekciju.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 1.5: IZMENA TEKSTA - DODAVANJE
+
+
+	           ** Pritisnite  A  za dodavanje teksta. **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+     Nije vano gde se nalazi kursor u tom redu.
+
+  2. Pritisnite  A  i unesite dodatni tekst.
+
+  3. Poto ste dodali tekst, pritisnite <ESC> za povratak u
+     Normal mod.
+
+  4. Pomerite kursor na drugi red oznaen sa ---> i ponavljajte
+     korake 2 i 3 dok ne ispravite tekst.
+
+---> Deo teksta nedostaje u
+     Deo teksta nedostaje u ovom redu.
+---> Deo teksta nedostaje
+     Deo teksta nedostaje i ovde.
+
+  5. Preite na lekciju 1.6.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     Lekcija 1.6: IZMENA FAJLA
+
+
+     ** Upotrebite  :wq  za snimanje teksta i izlazak iz editora. **
+
+  !! UPOZORENJE: Pre izvoenja bilo kog koraka, proitajte celu lekciju!!
+
+  1. Izaite iz editora kao u lekciji 1.2:  :q!
+
+  2. Na komandnom promptu unesite sledeu komandu:  vim tutor <ENTER>
+     'vim' je komanda za pokretanja Vim editora, 'tutor' je ime fajla koji
+     elite da menjate.  Koristite fajl koji imate pravo da menjate.
+
+  3. Ubacujte i briite tekst kao u prethodnim lekcijama.
+
+  4. Snimite izmenjeni tekst i izaite iz Vim-a:  :wq <ENTER>
+
+  5. Ponovo pokrenite vimtutor i proitajte rezime koji sledi.
+
+  6. Poto proitate korake iznad i u potpunosti ih razumete:
+     izvrite ih.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 1 
+
+
+  1. Kursor se pomera strelicama ili pomou tastera hjkl .
+	h (levo)	j (dole)	k (gore)	l (desno)
+
+  2. Za pokretanje Vim-a iz shell-a:  vim IME_FAJLA <ENTER>
+
+  3. Izlaz:	<ESC>	:q! <ENTER> 	sve promene su izgubljene.
+       ILI:	<ESC>	:wq <ENTER> 	promene su sauvane.
+
+  4. Brisanje znaka na kome se nalazi kursor:  x
+
+  5. Ubacivanja ili dodavanje teksta:
+	 i   unesite tekst <ESC>	unos ispred kursora
+	 A   unesite tekst <ESC>	dodavanje na kraju reda
+
+NAPOMENA:  Pritiskom na <ESC> prebacujete Vim u Normal mod i
+           prekidate neeljenu ili delimino izvrenu komandu.
+
+Nastavite sa lekcijom 2.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			Lekcija 2.1: NAREDBE BRISANJA
+
+
+		 ** Otkucajte  dw  za brisanje rei. **
+
+  1. Pritisnite  <ESC>  da biste bili sigurni da ste u Normal modu.
+
+  2. Pomerite kursor na red oznaen sa --->.
+
+  3. Pomerite kursor na poetak rei koju treba izbrisati.
+
+  4. Otkucajte  dw  da biste uklonili re.
+
+NAPOMENA:  Slovo  d  e se pojaviti na dnu ekrana kad ga otkucate.  Vim eka
+	   da otkucate  w .  Ako je prikazano neko drugo slovo, pogreili ste u
+	   kucanju; pritisnite <ESC> i pokuajte ponovo.  (Ako se ne pojavi
+	   nita, moda je iskljuena opcija 'showcmd': vidi lekciju 6.5.)
+
+---> Neke rei smeno ne pripadaju na papir ovoj reenici.
+
+  5. Ponavljajte korake 3 i 4 dok ne ispravite reenicu, pa
+     preite na lekciju 2.2.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      Lekcija 2.2: JO BRISANJA
+
+
+       ** Otkucajte  d$  za brisanje znakova do kraja reda. **
+
+  1. Pritisnite  <ESC>  da biste bili sigurni da ste u Normal modu.
+
+  2. Pomerite kursor na red oznaen sa  --->.
+
+  3. Pomerite kursor do kraja ispravnog dela reenice
+     (POSLE prve . ).
+
+  4. Otkucajte  d$  za brisanje ostatka reda.
+
+---> Neko je uneo kraj ovog reda dvaput. kraj ovog reda dvaput.
+
+  5. Preite na lekciju 2.3 za podrobnije objanjenje.
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	      Lekcija 2.3: O OPERATORIMA I POKRETIMA
+
+
+  Mnoge komande za izmenu teksta sastoje se od operatora i pokreta.
+  Oblik komande brisanja sa  d  operatorom je sledei:
+
+  	d   pokret
+
+  Pri emu je:
+    d      - operator brisanja.
+    pokret - ono na emu e se operacija izvravati (opisano u nastavku).
+
+  Kratak spisak pokreta:
+    w - sve do poetka sledee rei, NE UKLJUUJUI prvo slovo.
+    e - sve do kraja tekue rei, UKLJUUJUI poslednje slovo.
+    $ - sve do kraje reda, UKLJUUJUI poslednje slovo.
+
+  Kucanjem  de  brisae se tekst od kursora do kraja rei.
+
+NAPOMENA:  Pritiskom samo na taster pokreta dok ste u Normal modu, bez
+           operatora, kursor se pomera kao to je opisano.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  Lekcija 2.4: KORIENJE BROJANJA ZA POKRETE
+
+
+  ** Unoenjem nekog broja pre pokreta, pokret se izvrava taj broj puta. **
+
+  1. Pomerite kursor na red oznaen sa --->.
+
+  2. Otkucajte  2w  da pomerite kursor dve rei napred.
+
+  3. Otkucajte  3e  da pomerite kursor na kraj tree rei napred.
+
+  4. Otkucajte  0  (nulu) da pomerite kursor na poetak reda.
+
+  5. Ponovite korake 2 i 3 s nekim drugim brojevima.
+
+---> Reenica sa reima po kojoj moete pomerati kursor.
+
+  6. Preite na lekciju 2.5.
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+             Lekcija 2.5: KORIENJE BROJANJA ZA VEE BRISANJE
+
+
+  ** Unoenje nekog broja s operatorom ponavlja operator taj broj puta. **
+
+  U kombinaciji operatora brisanja s pokretima spomenutim iznad
+  moete uneti broj pre pokreta da biste izbrisali vie znakova:
+
+	 d   broj   pokret
+
+  1. Pomerite kursor na prvo slovo u rei s VELIKIM SLOVIMA u redu
+     oznaenom sa --->.
+
+  2. Otkucajte  d2w  da izbriete dve rei sa VELIKIM SLOVIMA
+
+  3. Ponovite korake 1 i 2 sa razliitim brojevima da izbriete
+     uzastopne rei sa VELIKIM SLOVIMA korienjem samo jedne komande.
+
+---> ovaj ABC DE red FGHI JK LMN OP s reima je RS TUVZ ispravljen.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     Lekcija 2.6: OPERACIJE NAD REDOVIMA
+
+
+	       ** Otkucajte  dd  za brisanje celog reda. **
+
+  Zbog uestalosti brisanja celih redova, autori Vi-ja odluili su da
+  je lake brisati redove ako se otkuca  d  dvaput.
+
+  1. Pomerite kursor na drugi red u donjoj strofi.
+  2. Otkucajte  dd  da ga izbriete.
+  3. Pomerite kursor na etvrti red.
+  4. Otkucajte   2dd   da biste izbrisali dva reda.
+
+--->  1)  Sedlo mi je od marame,
+--->  2)  blato na sve strane,
+--->  3)  uzda od kanapa,
+--->  4)  auto mi je ovde,
+--->  5)  satovi pokazuju vreme,
+--->  6)  a bi mi je od oina
+--->  7)  prebijena tapa.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      Lekcija 2.7: PONITAVANJE PROMENA
+
+
+  ** Pritisnite  u  za ponitavanje poslednje komande,  U  za ceo red. **
+
+  1. Pomerite kursor na red oznaen sa ---> i postavite ga na mesto
+     prve greke.
+  2. Otkucajte  x  da izbriete prvi neeljeni znak.
+  3. Otkucajte  u  da ponitite poslednju izvrenu komandu.
+  4. Sad ispravite sve greke u redu koristei komandu  x  .
+  5. Otkucajte veliko  U  da biste vratili sadraj reda u prvobitno
+     stanje.
+  6. Onda otkucajte  u  nekoliko puta da biste ponitili  U
+     i prethodne komande.
+  7. Sad otkucajte CTRL-R (drei  CTRL  dok pritiskate R)
+     nekoliko puta da biste vratili izmene (ponitili ponitavanja).
+
+---> Iiisspravite greke uu ovvom redu ii poonititeee ih.
+
+  8. Ovo su veoma korisne komande.  Preite na rezime lekcije 2.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 2
+
+
+  1. Brisanje od kursora do sledee rei:	dw
+  2. Brisanje od kursora do kraja reda:		d$
+  3. Brisanje celog reda:			dd
+
+  4. Za ponavljanje pokreta prethodno unesite broj:  2w
+  5. Oblik komande za izmenu:
+               operator   [broj]   pokret
+     gde je:
+       operator - ta uraditi, recimo  d  za brisanje
+       [broj]   - neobavezan broj ponavljanja pokreta
+       pokret   - kretanje po tekstu na kome se radi,
+                  kao to je: w (re), $ (kraj reda), itd.
+
+  6. Pomeranje kursora na poetak reda:  0
+
+  7. Za ponitavanje prethodnih izmena, pritisnite:	u  (malo u)
+     Za ponitavanje svih promena u redu, pritisnite:	U  (veliko U)
+     Za vraanja promena, otkucajte:			CTRL-R
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       Lekcija 3.1: KOMANDA POSTAVLJANJA
+
+
+  ** Otkucajte  p  da postavite prethodno izbrisan tekst iza kursora. **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  2. Otkucajte  dd  da izbriete red i smestite ga u Vim registar.
+
+  3. Pomerite kursor na red c), IZNAD mesta gde treba postaviti izbrisan red.
+
+  4. Otkucajte  p  da postavite red ispod kursora.
+
+  5. Ponavljajte korake 2 do 4 da biste postavili sve linije u pravilnom
+     redosledu.
+
+---> d) prebijena tapa.
+---> b) uzda od kanapa,
+---> c) a bi mi je od oina
+---> a) Sedlo mi je od marame,
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       Lekcija 3.2: KOMANDA ZAMENE
+
+
+      ** Otkucajte  rx  da zamenite znak ispod kursora slovom  x . **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  2. Pomerite kursor tako da se nalazi na prvoj greci.
+
+  3. Otkucajte  r  i onda znak koji treba da tu stoji.
+
+  4. Ponavljajte korake 2 i 3 sve dok prvi red ne bude
+     isti kao drugi.
+
+--->  Kedi ju ovej red ugaen, nako je protresao pustane testere!
+--->  Kada je ovaj red unoen, neko je pritiskao pogrene tastere!
+
+  5. Preite na lekciju 3.2.
+
+NAPOMENA:  Setite se da treba da uite vebanjem, ne pamenjem.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 3.3: OPERATOR IZMENE
+
+
+	  ** Za izmenu teksta do kraja rei, otkucajte  ce  .**
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  2. Postavite kursor na  a  u  rakdur.
+
+  3. Otkucajte  ce  i ispravite re (u ovom sluaju otkucajte  ed  ).
+
+  4. Pritisnite <ESC> i pomerite kursor na sledei znak koji
+     treba ispraviti.
+
+  5. Ponavljajte korake 3 i 4 sve dok prva reenica ne bude ista
+     kao druga.
+
+---> Ovaj rakdur ima nekoliko rejga koje treflja isprpikati operagrom izmene.
+---> Ovaj red ima nekoliko rei koje treba ispraviti operatorom izmene.
+
+Uoite da  ce  brie re i postavlja editor u Insert mod.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	         Lekcija 3.4: DALJE IZMENE UPOTREBOM c
+
+
+    ** Komanda izmene se koristi sa istim pokretima kao i brisanje. **
+
+  1. Operator izmene se koristi na isti nain kao i operator brisanja:
+
+         c    [broj]   pokret
+
+  2. Pokreti su isti, recimo:   w (re) i  $ (kraj reda).
+
+  3. Pomerite kursor na prvi sledei red oznaen sa --->.
+
+  4. Pomerite kursor na prvu greku.
+
+  5. Otkucajte  c$  i unesite ostatak reda tako da bude isti kao
+     drugi red, pa pritisnite <ESC>.
+
+---> Kraj ovog reda treba izmeniti tako da izgleda kao red ispod.
+---> Kraj ovog reda treba ispraviti korienjem c$ komande.
+
+NAPOMENA:  Za ispravljanje greaka moete koristiti Backspace .
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 3
+
+
+  1. Za postavljanje teksta koji ste upravo izbrisali, pritisnite  p . Ovo
+     postavlja tekst IZA kursora (ako je bio izbrisan jedan ili vie redova
+     sadraj e doi na red ispod kursora).
+
+  2. Za zamenu znaka na kome se nalazi kursor, pritisnite  r  i onda
+     eljeni znak.
+
+  3. Operator izmene dozvoljava promenu teksta od kursora do pozicije gde
+     se zavrava pokret.  Primera radi, kucajte  ce  za izmenu od kursora do
+     kraja rei, ili  c$  za izmenu od kursora do kraja reda.
+
+  4. Oblik operacije izmene je:
+
+	 c   [broj]   pokret
+
+Preite na narednu lekciju.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	      Lekcija 4.1: POZICIJA KURSORA I STATUS FAJLA
+
+  ** Pritisnite CTRL-G za prikaz pozicije kursora u tekstu i status fajla.
+     Pritisnite  G  za pomeranje kursora na neki red u tekstu. **
+
+NAPOMENA:  Proitajte celu lekciju pre izvoenja bilo kog koraka!!
+
+  1. Drite taster CTRL i pritisnite  g .  Ovo zovemo CTRL-G.
+     Editor e na dnu ekrana ispisati poruku sa imenom fajla i pozicijom
+     kursora u tekstu.  Zapamtite broj reda za 3. korak.
+
+NAPOMENA:  U donjem desnom uglu moe se videti poziciju kursora ako je
+           ukljuena opcija 'ruler' (vidi  :help ruler  ili lekciju 6.5.)
+
+  2. Pritisnite  G  za pomeranje kursora na kraj teksta.
+     Pritisnite  1G  ili  gg  za pomranje kursora na poetak teksta.
+
+  3. Otkucajte broj reda na kome ste malopre bili i onda  G .  Kursor
+     e se vratiti na red na kome je bio kad ste otkucali CTRL-G.
+
+  4. Ako ste spremni, izvrite korake od 1 do 3.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 4.2: KOMANDE PRETRAIVANJA
+
+       ** Otkucajte  /  i onda izraz koji elite da potraite. **
+
+  1. U Normal modu otkucajte znak  / .  Primietite da se znak pojavio
+     zajedno sa kursorom na dnu ekrana kao i kod komande  : .
+
+  2. Sada otkucajte 'grrreka' <ENTER>.  (Bez razmaka i navodnika.)
+     To je re koju traite.
+
+  3. Za ponovno traenje istog izraza, otkucajte  n .
+     Za traenje istog izraza u suprotnom smeru, otkucajte  N .
+
+  4. Za traenje izraza unatrag, koristite  ?  umesto  / .
+
+  5. Za povratak na prethodnu poziciju otkucajte CTRL-O (drite CTRL dok
+     pritiskate O ).  Ponavljajte za ranije pozicije.  CTRL-I ide napred.
+
+---> "grrreka" je pogreno; umesto grrreka treba da stoji greka.
+
+NAPOMENA:  Ako pretraga doe do kraja teksta traenje e se nastaviti od
+	   njegovog poetka osim ako je opcija 'wrapscan' iskljuena.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  Lekcija 4.3: TRAENJE PARA ZAGRADE
+
+
+	** Otkucajte  %  za nalaenje para ), ] ili } . **
+
+  1. Postavite kursor na bilo koju od  ( ,  [  ili  {
+     otvorenih zagrada u redu oznaenom sa --->.
+
+  2. Otkucajte znak  % .
+
+  3. Kursor e se pomeriti na odgovarajuu zatvorenu zagradu.
+
+  4. Otkucajte  %  da pomerite kursor na prvu zagradu u paru.
+
+      5. Pomerite kursor na neku od (,),[,],{ ili } i ponovite komandu  % .
+
+---> Red ( testiranja obinih ( [ uglastih ] i { vitiastih } zagrada.))
+
+
+NAPOMENA:  Vrlo korisno u ispravljanju koda sa rasparenim zagradama!
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      Lekcija 4.4: KOMANDA ZAMENE
+
+
+       ** Otkucajte  :s/staro/novo/g  da zamenite 'staro' za 'novo'. **
+
+  1. Pomerite kursor na red oznaen sa --->.
+
+  2. Otkucajte  :s/rdi/ri/ <ENTER> .  Primetite da ova komanda zamenjuje
+     samo prvo "rdi" u redu.
+
+  3. Otkucajte  :s/rdi/ri/g .  Dodavanje opcije  g  znai da e se komanda
+     izvriti u celom redu, zamenom svih pojava niza "rdi".
+
+---> rdiba rdibi grdize rep.
+
+  4. Za zamenu svih izraza izmeu neka dva reda,
+     otkucajte :#,#s/staro/novo/g   gde su #,# krajnji brojevi redova u opsegu 
+                                    u kome e se obaviti zamena.
+     Otkucajte :%s/staro/novo/g     za zamenu svih izraza u celom tekstu.
+     Otkucajte :%s/staro/novo/gc    za nalaenje svih izraza u tekstu i
+     			            potvrdu zamene.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 4
+
+
+  1. CTRL-G  prikazuje poziciju kursora u tekstu i status fajla.
+             G  pomera kursor na kraj teksta.
+     broj    G  pomera kursor na navedeni red.
+            gg  pomera kursor na prvi red teksta.
+
+  2. Kucanjem  /  sa izrazom taj izraz se trai UNAPRED.
+     Kucanjem  ?  sa izrazom taj izraz se trai UNAZAD.
+     Posle komande traenja koristite  n  za nalaenje izraza u istom
+     smeru, a  N  za nalaenje u suprotnom smeru.
+     CTRL-O vraa kursor na prethodnu poziciju, a CTRL-I na narednu.
+
+  3. Kucanjem  %  kad je kursor na zagradi on se pomera na njen par.
+
+  4. Za zamenu prvog izraza staro za izraz novo            :s/staro/novo/
+     Za zamenu svih izraza u celom redu                    :s/staro/novo/g
+     Za zamenu svih izraza u opsegu linija #,#             :#,#s/staro/novo/g
+     Za zamenu u celom tekstu                              :%s/staro/novo/g
+     Za potvrdu svake zamene dodajte 'c'		   :%s/staro/novo/gc
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		Lekcija 5.1: IZVRAVANJE SPOLJANJIH KOMANDI
+
+
+  ** Otkucajte  :!  pa spoljanju komandu koju elite da izvrite. **
+
+  1. Otkucajte poznatu komandu  :  da biste namestili kursor na dno
+     ekrana.  Time omoguavate unos komande u komandnoj liniji editora.
+
+  2. Otkucajte znak  !  (uzvinik).  Ovime omoguavate
+     izvravanje bilo koje spoljanje komande.
+
+  3. Kao primer otkucajte   ls   posle ! i pritisnite <ENTER>.  Ovo e
+     prikazati sadraj direktorijuma, kao da ste na komandnom promptu.
+     Otkucajte   :!dir   ako   :!ls   ne radi.
+
+NAPOMENA:  Na ovaj nain mogue je izvriti bilo koju spoljanju komandu,
+           zajedno sa njenim argumentima.
+
+NAPOMENA:  Sve  :  komande se izvravaju poto pritisnete <ENTER> .
+	   U daljem tekstu to neemo uvek napominjati.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   Lekcija 5.2: VIE O SNIMANJU FAJLOVA
+
+           ** Za snimanje promena, otkucajte  :w IME_FAJLA . **
+
+  1. Otkucajte  :!dir  ili  :!ls  za pregled sadraja direktorijuma.
+     Ve znate da morate pritisnuti <ENTER> posle toga.
+
+  2. Izaberite ime fajla koji jo ne postoji, npr. TEST.
+
+  3. Otkucajte:	 :w TEST   (gde je TEST ime koje ste izabrali.)
+
+  4. Time ete snimiti ceo fajl (Vim Tutor) pod imenom TEST.
+     Za proveru, otkucajte opet  :!dir  ili  :!ls za pregled
+     sadraja direktorijuma.
+
+NAPOMENA:  Ako biste napustili Vim i ponovo ga pokrenuli sa vim TEST ,
+           tekst bi bio tana kopija ovog fajla u trenutku kad ste
+	   ga snimili.
+
+  5. Izbriite fajl tako to ete otkucati (MS-DOS):	:!del TEST
+				         ili (Unix):	:!rm TEST
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  Lekcija 5.3: SNIMANJE OZNAENOG TEKSTA
+
+
+   ** Da biste snimili deo teksta, otkucajte  v  pokret  :w IME_FAJLA **
+
+  1. Pomerite kursor na ovu liniju.
+
+  2. Pritisnite  v  i pomerite kursor pet redova ispod.  Primetite da je
+     tekst oznaen inverzno.
+
+  3. Pritisnite  : .  Na dnu ekrana pojavie se  :'<,'> .
+
+  4. Otkucajte  w TEST  , gde je TEST ime fajla koji jo ne postoji.
+     Proverite da zaista pie  :'<,'>w TEST  pre nego to pritisnete <ENTER>.
+
+  5. Vim e snimiti oznaeni tekst u TEST.  Proverite sa  :!dir  ili  !ls .
+     Nemojte jo brisati fajl!  Koristiemo ga u narednoj lekciji.
+
+NAPOMENA:  Komanda  v  zapoinje vizuelno oznaavanje.  Moete pomerati kursor
+           i tako menjati veliinu oznaenog teksta.  Onda moete upotrebiti
+           operatore nad tekstom.  Na primer,  d  e izbrisati oznaeni tekst.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   Lekcija 5.4: UITAVANJE FAJLA U TEKST
+
+
+       ** Za ubacivanje sadraja fajla, otkucajte  :r IME_FAJLA  **
+
+  1. Postavite kursor iznad ove linije.
+
+NAPOMENA:  Poto izvrite 2. korak videete tekst iz lekcije 5.3.  Tada
+           pomerite kursor DOLE da biste ponovo videli ovu lekciju.
+
+  2. Uitajte fajl TEST koristei komandu  :r TEST  gde je TEST ime fajla
+     koje ste koristili u prethodnoj lekciji.  Sadraj uitanog fajla je
+     ubaen ispod kursora.
+
+  3. Da biste proverili da je fajl uitan, vratite kursor unazad i
+     primetite dve kopije lekcije 5.3, originalnu i onu iz fajla.
+
+NAPOMENA:  Takoe moete uitati izlaz spoljanje komande.  Na primer,
+	   :r !ls  e uitati izlaz komande  ls  i postaviti ga ispod
+           kursora.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 5
+
+
+  1.  :!komanda  izvrava spoljanju komandu.
+
+      Korisni primeri:
+	 (MS-DOS)	  (Unix)
+	  :!dir		   :!ls		   -  pregled sadraja direktorijuma.
+	  :!del FAJL       :!rm FAJL       -  brie fajl FAJL.
+
+  2.  :w FAJL  zapisuje trenutni tekst na disk pod imenom FAJL.
+
+  3.  v  pokret  :w IME_FAJLA  snima vizuelno oznaene redove u fajl
+      IME_FAJLA.
+
+  4.  :r IME_FAJLA  uitava fajl IME_FAJLA sa diska i stavlja
+      njegov sadraj ispod kursora.
+
+  5.  :r !dir  uitava izlaz komande dir i postavlja ga ispod kursora.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 Lekcija 6.1: KOMANDA OTVORI
+
+
+	** Pritisnite  o  da biste otvorili red ispod kursora
+	   i preli u Insert mod. **
+
+  1. Pomerite kursor na sledei red oznaen sa --->.
+
+  2. Otkucajte malo  o  da biste otvorili novi red ISPOD kursora
+     i preli u Insert mod.
+
+  3. Otkucajte neki tekst i onda pritisnite <ESC> da biste izali
+     iz Insert moda.
+
+---> Kad pritisnete  o  kursor prelazi u novootvoreni red u Insert modu.
+
+  4. Za otvaranje reda IZNAD kursora, umesto malog otkucajte veliko O .
+     Isprobajte na donjem redu oznaenom sa --->.
+
+---> Otvorite red iznad ovog kucanjem velikog  O  dok je kursor u ovom redu.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			Lekcija 6.2: KOMANDA DODAJ
+
+
+	     ** Otkucajte  a  za dodavanje teksta IZA kursora. **
+
+  1. Pomerite kursor na poetak sledeeg reda oznaenog sa --->.
+  
+  2. Kucajte  e  dok kursor ne doe na kraj rei  re .
+
+  3. Otkucajte  a  (malo) da biste dodali tekst IZA kursora.
+
+  4. Dopunite re kao to je u redu ispod.  Pritisnite <ESC> za izlazak
+     iz Insert moda.
+
+  5. Sa  e  preite na narednu nepotpunu re i ponovite korake 3 i 4.
+  
+---> Ovaj re omoguava ve dodav teksta u nekom redu.
+---> Ovaj red omoguava vebanje dodavanja teksta u nekom redu.
+
+NAPOMENA:  Komande a, i, i  A  aktiviraju isti Insert mod, jedina
+           razlika je u poziciji od koje e se tekst ubacivati.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 6.3: DRUGI NAIN ZAMENE
+
+
+      ** Otkucajte veliko  R  da biste zamenili vie od jednog znaka. **
+
+  1. Pomerite kursor na prvi sledei red oznaen sa --->.
+     Pomerite kursor na poetak prvog  xxx .
+
+  2. Pritisnite  R  i otkucajte broj koji je red ispod,
+     tako da zameni xxx .
+
+  3. Pritisnite <ESC> za izlazak iz Replace moda.
+     Primetite da je ostatak reda ostao nepromenjen.
+
+  4. Ponovite korake da biste zamenili drugo xxx.
+
+---> Dodavanje 123 na xxx daje xxx.
+---> Dodavanje 123 na 456 daje 579.
+
+NAPOMENA:  Replace mod je kao Insert mod, s tom razlikom to svaki
+           uneti znak brie ve postojei.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		Lekcija 6.4: KOPIRANJE I LEPLJENJE TEKSTA
+
+
+    ** Koristite operator  y  za kopiranje a  p  za lepljenje teksta. **
+
+  1. Pomerite kursor na red sa --->  i postavite kursor posle "a)".
+  
+  2. Aktivirajte Visual mod sa  v  i pomerite kursor sve do ispred "prvi".
+  
+  3. Pritisnite  y  da biste kopirali oznaeni tekst u interni bafer.
+
+  4. Pomerite kursor do kraja sledeeg reda:  j$
+
+  5. Pritisnite  p  da biste zalepili tekst.  Onda otkucajte:  a drugi <ESC> .
+
+  6. Upotrebite Visual mod da oznaite " red.", kopirajte sa  y , kursor
+     pomerite na kraj sledeeg reda sa  j$  i tamo zalepite tekst sa  p .
+
+--->  a) ovo je prvi red.
+      b)
+
+NAPOMENA:  takoe moete koristiti  y  kao operator;  yw  kopira jednu re.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    Lekcija 6.5: POSTAVLJANJE OPCIJA
+
+
+ ** Postavite opciju tako da traenje i zamena ignoriu veliinu slova **
+
+  1. Potraite re 'razlika':  /razlika <ENTER>
+     Ponovite nekoliko puta pritiskom na  n .
+
+  2. Aktivirajte opciju 'ic' (Ignore case):  :set ic
+
+  3. Ponovo potraite re 'razlika' pritiskom na  n
+     Primetite da su sada pronaeni i RAZLIKA i Razlika.
+
+  4. Aktivirajte opcije 'hlsearch' i 'incsearch':  :set hls is
+
+  5. Ponovo otkucajte komandu traenja i uoite razlike:  /razlika <ENTER>
+
+  6. Za deaktiviranje opcije  ic  kucajte:  :set noic
+
+NAPOMENA:  Za neoznaavanje pronaenih izraza otkucajte:  :nohlsearch
+NAPOMENA:  Ako elite da ne razlikujete veliinu slova u samo jednoj komandi
+	   traenja, dodajte  \c  u izraz:  /razlika\c <ENTER>
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 6
+
+  1. Pritisnite  o  za otvaranje reda ISPOD kursora i prelazak u Insert mod.
+     Pritisnite  O  za otvaranje reda IZNAD kursora.
+
+  2. Pritisnite  a  za unos teksta IZA kursora.
+     Pritisnite  A  za unos teksta na kraju reda.
+
+  3. Komanda  e  pomera kursor na kraj rei.
+
+  4. Operator  y  kopira tekst,  p  ga lepi.
+
+  5. Kucanje velikog  R  aktivira Replace mod dok ne pritisnete <ESC> .
+
+  6. Kucanje ":set xxx" aktivira opciju "xxx".  Neke opcije su:
+  	'ic' 'ignorecase'	ne razlikuje velika/mala slova pri traenju
+	'is' 'incsearch'	prikazuje pronaen tekst dok kucate izraz
+	'hls' 'hlsearch'	oznaava inverzno sve pronaene izraze
+     Moete koristite dugo ili kratko ime opcije.
+
+  7. Ispred imena opcije stavite "no" da je deaktivirate:  :set noic
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       Lekcija 7.1: DOBIJANJE POMOI
+
+
+		   ** Koristite on-line sistem za pomo **
+
+  Vim ima detaljan on-line sistem za pomo.  Za poetak, pokuajte neto
+  od sledeeg:
+	- pritisnite taster <HELP> (ako ga imate na tastaturi)
+	- pritisnite taster <F1> (ako ga imate na tastaturi)
+	- otkucajte  :help <ENTER>
+
+  Proitajte tekst u prozoru pomoi da biste nauili pomo radi.
+  Kucanjem  CTRL-W CTRL-W  prelazite iz jednog prozora u drugi.
+  Otkucajte  :q <ENTER>  da zatvorite prozor pomoi.
+
+  Pomo o praktino bilo kojoj temi moete dobiti dodavanjem argumenta
+  komandi ":help".  Pokuajte ovo (ne zaboravite <ENTER> na kraju):
+
+	:help w
+	:help c_CTRL-D
+	:help insert-index
+	:help user-manual
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		Lekcija 7.2: PRAVLJENJE STARTNOG SKRIPTA
+
+
+		   ** Aktivirajte mogunosti editora **
+
+  Vim ima mnogo vie mogunosti nego Vi, ali veina nije automatski
+  aktivirana.  Za dodatne mogunosti napravite "vimrc" fajl.
+
+  1. Otvorite "vimrc" fajl.  Ovo zavisi od vaeg sistema:
+	:e ~/.vimrc		za Unix
+	:e $VIM/_vimrc		za MS-Windows
+
+  2. Onda uitajte primer sadraja "vimrc" fajla:
+	:r $VIMRUNTIME/vimrc_example.vim
+
+  3. Snimite fajl sa:
+	:w
+
+  Sledei put kada pokrenete Vim, bojenje sintakse teksta bie
+  aktivirano. Sva svoja podeavanja moete dodati u "vimrc" fajl.
+  Za vie informacija otkucajte  :help vimrc-intro
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     Lekcija 7.3: AUTOMATSKO DOVRAVANJE
+
+
+	** Dovravanje komandne linije sa CTRL-D i <TAB> **
+
+  1. Podesite Vim da ne bude u Vi-kompatibilnom modu:  :set nocp
+
+  2. Pogledajte koji fajlovi postoje u direktorijumu:  :!ls  ili  :!dir
+
+  3. Otkucajte poetak komande:  :e
+
+  4. Otkucajte  CTRL-D  i Vim e prikazati spisak komandi koje poinju sa "e".
+
+  5. Pritisnite <TAB>  i Vim e dopuniti ime komande u ":edit".
+
+  6. Dodajte razmak i poetak imena postojeeg fajla:  :edit FA
+
+  7. Pritisnite <TAB>.  Vim e dopuniti ime fajla (ako je jedinstveno).
+
+NAPOMENA:  Mogue je dopuniti mnoge komande.  Samo probajte CTRL-D i <TAB>.
+           Naroito je korisno za  :help  komande.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			      REZIME lekcije 7
+
+
+  1. Otkucajte  :help  ili pritisnite <F1> ili <Help>  za pomo.
+
+  2. Otkucajte  :help komanda  biste dobili pomo za tu komandu.
+
+  3. Otkucajte  CTRL-W CTRL-W  za prelazak u drugi prozor.
+
+  4. Otkucajte  :q  da zatvorite prozor pomoi.
+
+  5. Napravite vimrc startni skript za aktiviranje podeavanja koja
+     vam odgovaraju.
+
+  6. Dok kucate neku od  :  komandi, pritisnite CTRL-D da biste videli mogue
+     vrednosti.  Pritisnite <TAB> da odaberete jednu od njih.
+
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  Ovim je prirunik zavren.  Njegov cilj je bio kratak pregled Vim editora,
+  koliko da omogui njegovo relativno jednostavno korienje.  Prirunik nije
+  potpun, jer Vim ima mnogo vie komandi.  Kao sledee, proitajte prirunik:
+  ":help user-manual".
+
+  Za dalje itanje i uenje, preporuujemo knjigu:
+	Vim - Vi Improved - by Steve Oualline
+	Izdava: New Riders
+  Prva knjiga potpuno posveena Vim-u.  Naroito korisna za poetnike.
+  Ima mnotvo primera i slika.
+  Vidite http://iccf-holland.org/click5.html
+
+  Sledea knjiga je starija i vie govori o Vi-u nego o Vim-u, ali je takoe
+  preporuujemo:
+	Learning the Vi Editor - by Linda Lamb
+	Izdava: O'Reilly & Associates Inc.
+  Dobra knjiga iz koje moete saznati skoro sve to moete raditi u Vi-ju.
+  esto izdanje ima i informacija o Vim-u.
+
+  Ovaj prirunik su napisali: Michael C. Pierce i Robert K. Ware,
+  Colorado School of Mines koristei ideje Charlesa Smitha,
+  Colorado State University.  E-mail: bware@mines.colorado.edu.
+
+  Prilagoavanje za Vim uradio je Bram Moolenaar.
+
+  Prevod na srpski: Ivan Nejgebauer <ian@uns.ac.rs>
+  Verzija 1.0, maj/juni 2014.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/tutor/tutor.utf-8 vim74/runtime/tutor/tutor.utf-8
--- vim74.orig/runtime/tutor/tutor.utf-8	2012-10-03 13:33:51.000000000 +0000
+++ vim74/runtime/tutor/tutor.utf-8	2014-10-10 14:53:43.825381854 +0000
@@ -55,8 +55,8 @@
   2. Type:	:q! <ENTER>.
      This exits the editor, DISCARDING any changes you have made.
 
-  3. When you see the shell prompt, type the command that got you into this
-     tutor.  That would be:	vimtutor <ENTER>
+  3. Get back here by executing the command that got you into this tutor. That
+     might be:  vimtutor <ENTER>
 
   4. If you have these steps memorized and are confident, execute steps
      1 through 3 to exit and re-enter the editor.
diff -Naur vim74.orig/runtime/tutor/tutor.vim vim74/runtime/tutor/tutor.vim
--- vim74.orig/runtime/tutor/tutor.vim	2012-09-21 12:23:48.000000000 +0000
+++ vim74/runtime/tutor/tutor.vim	2014-10-10 14:53:43.832048504 +0000
@@ -1,7 +1,7 @@
 " Vim tutor support file
 " Author: Eduardo F. Amatria <eferna1@platea.pntic.mec.es>
 " Maintainer: Bram Moolenaar
-" Last Change:	2012 Sep 21
+" Last Change:	2014 Jun 25
 
 " This Vim script is used for detecting if a translation of the
 " tutor file exist, i.e., a tutor.xx file, where xx is the language.
@@ -36,6 +36,8 @@
       let s:ext = ".pl"
     elseif s:lang =~ "Slovak"
       let s:ext = ".sk"
+    elseif s:lang =~ "Serbian"
+      let s:ext = ".sr"
     elseif s:lang =~ "Czech"
       let s:ext = ".cs"
     elseif s:lang =~ "Dutch"
@@ -122,6 +124,15 @@
   endif
 endif
 
+" The Slovak tutor is available in two encodings, guess which one to use
+" Note that the utf-8 version is the original, the cp1250 version is created
+" from it.
+if s:ext =~? '\.sr'
+  if &enc =~ 1250
+    let s:ext = ".sr.cp1250"
+  endif
+endif
+
 " The Czech tutor is available in three encodings, guess which one to use
 if s:ext =~? '\.cs'
   if &enc =~ 1250
diff -Naur vim74.orig/runtime/tutor/tutor.zh.big5 vim74/runtime/tutor/tutor.zh.big5
--- vim74.orig/runtime/tutor/tutor.zh.big5	2010-05-15 11:04:02.000000000 +0000
+++ vim74/runtime/tutor/tutor.zh.big5	2014-10-10 14:53:43.835381829 +0000
@@ -843,10 +843,10 @@
       P xuandong@sh163.net ANBOrC
 
       2002~0318  <linuxrat@gnuchina.org>
-      Bram Molenaarb2002~0316HnDANvimtutor1.4
+      Bram Moolenaarb2002~0316HnDANvimtutor1.4
       vimtutor1.5C
 
       2001~1115  <linuxrat@gnuchina.org>
-      Nvimtutor1.4Bram MolenaarMSven GuckesC
+      Nvimtutor1.4Bram MoolenaarMSven GuckesC
 
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/tutor/tutor.zh.euc vim74/runtime/tutor/tutor.zh.euc
--- vim74.orig/runtime/tutor/tutor.zh.euc	2012-10-03 19:27:18.000000000 +0000
+++ vim74/runtime/tutor/tutor.zh.euc	2014-10-10 14:53:43.838715154 +0000
@@ -988,9 +988,9 @@
        xuandong@sh163.net 
 
       20020318  <linuxrat@gnuchina.org>
-      Bram Molenaar20020316vimtutor1.4
+      Bram Moolenaar20020316vimtutor1.4
       vimtutor1.5
 
       20011115  <linuxrat@gnuchina.org>
-      vimtutor1.4Bram MolenaarSven Guckes
+      vimtutor1.4Bram MoolenaarSven Guckes
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/tutor/tutor.zh.utf-8 vim74/runtime/tutor/tutor.zh.utf-8
--- vim74.orig/runtime/tutor/tutor.zh.utf-8	2013-04-24 12:44:44.000000000 +0000
+++ vim74/runtime/tutor/tutor.zh.utf-8	2014-10-10 14:53:43.842048479 +0000
@@ -843,10 +843,10 @@
        xuandong@sh163.net 
 
       20020318  <linuxrat@gnuchina.org>
-      Bram Molenaar20020316vimtutor1.4
+      Bram Moolenaar20020316vimtutor1.4
       vimtutor1.5
 
       20011115  <linuxrat@gnuchina.org>
-      vimtutor1.4Bram MolenaarSven Guckes
+      vimtutor1.4Bram MoolenaarSven Guckes
 
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/tutor/tutor.zh_cn.utf-8 vim74/runtime/tutor/tutor.zh_cn.utf-8
--- vim74.orig/runtime/tutor/tutor.zh_cn.utf-8	2012-10-03 19:27:18.000000000 +0000
+++ vim74/runtime/tutor/tutor.zh_cn.utf-8	2014-10-10 14:53:43.855381778 +0000
@@ -988,9 +988,9 @@
        xuandong@sh163.net 
 
       20020318  <linuxrat@gnuchina.org>
-      Bram Molenaar20020316vimtutor1.4
+      Bram Moolenaar20020316vimtutor1.4
       vimtutor1.5
 
       20011115  <linuxrat@gnuchina.org>
-      vimtutor1.4Bram MolenaarSven Guckes
+      vimtutor1.4Bram MoolenaarSven Guckes
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/tutor/tutor.zh_tw.utf-8 vim74/runtime/tutor/tutor.zh_tw.utf-8
--- vim74.orig/runtime/tutor/tutor.zh_tw.utf-8	2010-05-15 11:04:02.000000000 +0000
+++ vim74/runtime/tutor/tutor.zh_tw.utf-8	2014-10-10 14:53:43.858715103 +0000
@@ -843,10 +843,10 @@
        xuandong@sh163.net 
 
       20020318  <linuxrat@gnuchina.org>
-      Bram Molenaar20020316vimtutor1.4
+      Bram Moolenaar20020316vimtutor1.4
       vimtutor1.5
 
       20011115  <linuxrat@gnuchina.org>
-      vimtutor1.4Bram MolenaarSven Guckes
+      vimtutor1.4Bram MoolenaarSven Guckes
 
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim74.orig/runtime/vimlogo.eps vim74/runtime/vimlogo.eps
--- vim74.orig/runtime/vimlogo.eps	2010-05-15 11:03:57.000000000 +0000
+++ vim74/runtime/vimlogo.eps	2014-10-10 14:53:43.892048353 +0000
@@ -1,791 +1,803 @@
-%!PS-Adobe-3.0 EPSF-3.0
-%%BoundingBox: 147 74 429 356 
-%%LanguageLevel: 1
-%%Creator: CorelDRAW 11
-%%Title: vimlogo.eps
-%%CreationDate: Mon Feb 02 14:35:16 2004
-%%DocumentProcessColors: Cyan Yellow Black 
-%%DocumentSuppliedResources: (atend)
-%%EndComments
-%%BeginProlog
-/AutoFlatness false def
-/AutoSteps 0 def
-/CMYKMarks true def
-/UseLevel 1 def
-%Build: CorelDRAW 11 Version 11.633
-%Color profile:  Generic offset separations profile
-/CorelIsEPS true def
-%%BeginResource: procset wCorel11Dict 11.0 0
-/wCorel11Dict 300 dict def wCorel11Dict begin
-% Copyright (c)1992-2002 Corel Corporation
-% All rights reserved.     v11.0 r0.0
-/bd{bind def}bind def/ld{load def}bd/xd{exch def}bd/_ null def/rp{{pop}repeat}
-bd/@cp/closepath ld/@gs/gsave ld/@gr/grestore ld/@np/newpath ld/Tl/translate ld
-/$sv 0 def/@sv{/$sv save def}bd/@rs{$sv restore}bd/spg/showpage ld/showpage{}
-bd currentscreen/@dsp xd/$dsp/@dsp def/$dsa xd/$dsf xd/$sdf false def/$SDF
-false def/$Scra 0 def/SetScr/setscreen ld/@ss{2 index 0 eq{$dsf 3 1 roll 4 -1
-roll pop}if exch $Scra add exch load SetScr}bd/SepMode_5 where{pop}{/SepMode_5
-0 def}ifelse/CorelIsSeps where{pop}{/CorelIsSeps false def}ifelse
-/CorelIsInRIPSeps where{pop}{/CorelIsInRIPSeps false def}ifelse/CorelIsEPS
-where{pop}{/CorelIsEPS false def}ifelse/CurrentInkName_5 where{pop}
-{/CurrentInkName_5(Composite)def}ifelse/$ink_5 where{pop}{/$ink_5 -1 def}
-ifelse/$c 0 def/$m 0 def/$y 0 def/$k 0 def/$t 1 def/$n _ def/$o 0 def/$fil 0
-def/$C 0 def/$M 0 def/$Y 0 def/$K 0 def/$T 1 def/$N _ def/$O 0 def/$PF false
-def/s1c 0 def/s1m 0 def/s1y 0 def/s1k 0 def/s1t 0 def/s1n _ def/$bkg false def
-/SK 0 def/SM 0 def/SY 0 def/SC 0 def/$op false def matrix currentmatrix/$ctm xd
-/$ptm matrix def/$ttm matrix def/$stm matrix def/$ffpnt true def
-/CorelDrawReencodeVect[16#0/grave 16#5/breve 16#6/dotaccent 16#8/ring
-16#A/hungarumlaut 16#B/ogonek 16#C/caron 16#D/dotlessi 16#27/quotesingle
-16#60/grave 16#7C/bar
-16#82/quotesinglbase/florin/quotedblbase/ellipsis/dagger/daggerdbl
-16#88/circumflex/perthousand/Scaron/guilsinglleft/OE
-16#91/quoteleft/quoteright/quotedblleft/quotedblright/bullet/endash/emdash
-16#98/tilde/trademark/scaron/guilsinglright/oe 16#9F/Ydieresis
-16#A1/exclamdown/cent/sterling/currency/yen/brokenbar/section
-16#a8/dieresis/copyright/ordfeminine/guillemotleft/logicalnot/minus/registered/macron
-16#b0/degree/plusminus/twosuperior/threesuperior/acute/mu/paragraph/periodcentered
-16#b8/cedilla/onesuperior/ordmasculine/guillemotright/onequarter/onehalf/threequarters/questiondown
-16#c0/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
-16#c8/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
-16#d0/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/multiply
-16#d8/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls
-16#e0/agrave/aacute/acircumflex/atilde/adieresis/aring/ae/ccedilla
-16#e8/egrave/eacute/ecircumflex/edieresis/igrave/iacute/icircumflex/idieresis
-16#f0/eth/ntilde/ograve/oacute/ocircumflex/otilde/odieresis/divide
-16#f8/oslash/ugrave/uacute/ucircumflex/udieresis/yacute/thorn/ydieresis]def
-/L2?/languagelevel where{pop languagelevel 2 ge}{false}ifelse def/Comp?{
-/LumSepsDict where{pop false}{/AldusSepsDict where{pop false}{1 0 0 0 @gs
-setcmykcolor currentcmykcolor @gr add add add 0 ne 0 1 0 0 @gs setcmykcolor
-currentcmykcolor @gr add add add 0 ne 0 0 1 0 @gs setcmykcolor currentcmykcolor
-@gr add add add 0 ne 0 0 0 1 @gs setcmykcolor currentcmykcolor @gr add add add
-0 ne and and and}ifelse}ifelse}bd/@PL{/LV where{pop LV 2 ge L2? not and{@np
-/Courier findfont 12 scalefont setfont 72 144 m
-(The PostScript level set in the Corel application is higher than)show 72 132 m
-(the PostScript level of this device. Change the PS Level in the Corel)show 72
-120 m(application to Level 1 by selecting the PostScript tab in the print)show
-72 108 m(dialog, and selecting Level 1 from the Compatibility drop down list.)
-show flush spg quit}if}if}bd/@BeginSysCorelDict{systemdict/Corel30Dict known
-{systemdict/Corel30Dict get exec}if systemdict/CorelLexDict known{1 systemdict
-/CorelLexDict get exec}if}bd/@EndSysCorelDict{systemdict/Corel30Dict known
-{end}if/EndCorelLexDict where{pop EndCorelLexDict}if}bd AutoFlatness{/@ifl{dup
-currentflat exch sub 10 gt{
-([Error: PathTooComplex; OffendingCommand: AnyPaintingOperator]\n)print flush
-@np exit}{currentflat 2 add setflat}ifelse}bd/@fill/fill ld/fill{currentflat{
-{@fill}stopped{@ifl}{exit}ifelse}bind loop setflat}bd/@eofill/eofill ld/eofill
-{currentflat{{@eofill}stopped{@ifl}{exit}ifelse}bind loop setflat}bd/@clip
-/clip ld/clip{currentflat{{@clip}stopped{@ifl}{exit}ifelse}bind loop setflat}
-bd/@eoclip/eoclip ld/eoclip{currentflat{{@eoclip}stopped{@ifl}{exit}ifelse}
-bind loop setflat}bd/@stroke/stroke ld/stroke{currentflat{{@stroke}stopped
-{@ifl}{exit}ifelse}bind loop setflat}bd}if L2?{/@ssa{true setstrokeadjust}bd}{
-/@ssa{}bd}ifelse/d/setdash ld/j/setlinejoin ld/J/setlinecap ld/M/setmiterlimit
-ld/w/setlinewidth ld/O{/$o xd}bd/R{/$O xd}bd/W/eoclip ld/c/curveto ld/C/c ld/l
-/lineto ld/L/l ld/rl/rlineto ld/m/moveto ld/n/newpath ld/N/newpath ld/P{11 rp}
-bd/u{}bd/U{}bd/A{pop}bd/q/@gs ld/Q/@gr ld/&{}bd/@j{@sv @np}bd/@J{@rs}bd/g{1
-exch sub/$k xd/$c 0 def/$m 0 def/$y 0 def/$t 1 def/$n _ def/$fil 0 def}bd/G{1
-sub neg/$K xd _ 1 0 0 0/$C xd/$M xd/$Y xd/$T xd/$N xd}bd/k{1 index type
-/stringtype eq{/$t xd/$n xd}{/$t 0 def/$n _ def}ifelse/$k xd/$y xd/$m xd/$c xd
-/$fil 0 def}bd/K{1 index type/stringtype eq{/$T xd/$N xd}{/$T 0 def/$N _ def}
-ifelse/$K xd/$Y xd/$M xd/$C xd}bd/x/k ld/X/K ld/sf{1 index type/stringtype eq{
-/s1t xd/s1n xd}{/s1t 0 def/s1n _ def}ifelse/s1k xd/s1y xd/s1m xd/s1c xd}bd/i{
-dup 0 ne{setflat}{pop}ifelse}bd/v{4 -2 roll 2 copy 6 -2 roll c}bd/V/v ld/y{2
-copy c}bd/Y/y ld/@w{matrix rotate/$ptm xd matrix scale $ptm dup concatmatrix
-/$ptm xd 1 eq{$ptm exch dup concatmatrix/$ptm xd}if 1 w}bd/@g{1 eq dup/$sdf xd
-{/$scp xd/$sca xd/$scf xd}if}bd/@G{1 eq dup/$SDF xd{/$SCP xd/$SCA xd/$SCF xd}
-if}bd/@D{2 index 0 eq{$dsf 3 1 roll 4 -1 roll pop}if 3 copy exch $Scra add exch
-load SetScr/$dsp xd/$dsa xd/$dsf xd}bd/$ngx{$SDF{$SCF SepMode_5 0 eq{$SCA}
-{$dsa}ifelse $SCP @ss}if}bd/@MN{2 copy le{pop}{exch pop}ifelse}bd/@MX{2 copy ge
-{pop}{exch pop}ifelse}bd/InRange{3 -1 roll @MN @MX}bd/@sqr{dup 0 rl dup 0 exch
-rl neg 0 rl @cp}bd/currentscale{1 0 dtransform matrix defaultmatrix idtransform
-dup mul exch dup mul add sqrt 0 1 dtransform matrix defaultmatrix idtransform
-dup mul exch dup mul add sqrt}bd/@unscale{}bd/wDstChck{2 1 roll dup 3 -1 roll
-eq{1 add}if}bd/@dot{dup mul exch dup mul add 1 exch sub}bd/@lin{exch pop abs 1
-exch sub}bd/cmyk2rgb{3{dup 5 -1 roll add 1 exch sub dup 0 lt{pop 0}if exch}
-repeat pop}bd/rgb2cmyk{3{1 exch sub 3 1 roll}repeat 3 copy @MN @MN 3{dup 5 -1
-roll sub neg exch}repeat}bd/rgb2g{2 index .299 mul 2 index .587 mul add 1 index
-.114 mul add 4 1 roll pop pop pop}bd/WaldoColor_5 where{pop}{/SetRgb
-/setrgbcolor ld/GetRgb/currentrgbcolor ld/SetGry/setgray ld/GetGry/currentgray
-ld/SetRgb2 systemdict/setrgbcolor get def/GetRgb2 systemdict/currentrgbcolor
-get def/SetHsb systemdict/sethsbcolor get def/GetHsb systemdict
-/currenthsbcolor get def/rgb2hsb{SetRgb2 GetHsb}bd/hsb2rgb{3 -1 roll dup floor
-sub 3 1 roll SetHsb GetRgb2}bd/setcmykcolor where{pop/LumSepsDict where{pop
-/SetCmyk_5{LumSepsDict/setcmykcolor get exec}def}{/AldusSepsDict where{pop
-/SetCmyk_5{AldusSepsDict/setcmykcolor get exec}def}{/SetCmyk_5/setcmykcolor ld
-}ifelse}ifelse}{/SetCmyk_5{cmyk2rgb SetRgb}bd}ifelse/currentcmykcolor where{
-pop/GetCmyk/currentcmykcolor ld}{/GetCmyk{GetRgb rgb2cmyk}bd}ifelse
-/setoverprint where{pop}{/setoverprint{/$op xd}bd}ifelse/currentoverprint where
-{pop}{/currentoverprint{$op}bd}ifelse/@tc_5{5 -1 roll dup 1 ge{pop}{4{dup 6 -1
-roll mul exch}repeat pop}ifelse}bd/@trp{exch pop 5 1 roll @tc_5}bd
-/setprocesscolor_5{SepMode_5 0 eq{SetCmyk_5}{0 4 $ink_5 sub index exch pop 5 1
-roll pop pop pop pop SepsColor true eq{$ink_5 3 gt{1 sub neg SetGry}{0 0 0 4
-$ink_5 roll SetCmyk_5}ifelse}{1 sub neg SetGry}ifelse}ifelse}bd
-/findcmykcustomcolor where{pop}{/findcmykcustomcolor{5 array astore}bd}ifelse
-/Corelsetcustomcolor_exists false def/setcustomcolor where{pop
-/Corelsetcustomcolor_exists true def}if CorelIsSeps true eq CorelIsInRIPSeps
-false eq and{/Corelsetcustomcolor_exists false def}if
-Corelsetcustomcolor_exists false eq{/setcustomcolor{exch aload pop SepMode_5 0
-eq{pop @tc_5 setprocesscolor_5}{CurrentInkName_5 eq{4 index}{0}ifelse 6 1 roll
-5 rp 1 sub neg SetGry}ifelse}bd}if/@scc_5{dup type/booleantype eq{dup
-currentoverprint ne{setoverprint}{pop}ifelse}{1 eq setoverprint}ifelse dup _ eq
-{pop setprocesscolor_5 pop}{findcmykcustomcolor exch setcustomcolor}ifelse
-SepMode_5 0 eq{true}{GetGry 1 eq currentoverprint and not}ifelse}bd/colorimage
-where{pop/ColorImage{colorimage}def}{/ColorImage{/ncolors xd/$multi xd $multi
-true eq{ncolors 3 eq{/daqB xd/daqG xd/daqR xd pop pop exch pop abs{daqR pop
-daqG pop daqB pop}repeat}{/daqK xd/daqY xd/daqM xd/daqC xd pop pop exch pop abs
-{daqC pop daqM pop daqY pop daqK pop}repeat}ifelse}{/dataaq xd{dataaq ncolors
-dup 3 eq{/$dat xd 0 1 $dat length 3 div 1 sub{dup 3 mul $dat 1 index get 255
-div $dat 2 index 1 add get 255 div $dat 3 index 2 add get 255 div rgb2g 255 mul
-cvi exch pop $dat 3 1 roll put}for $dat 0 $dat length 3 idiv getinterval pop}{
-4 eq{/$dat xd 0 1 $dat length 4 div 1 sub{dup 4 mul $dat 1 index get 255 div
-$dat 2 index 1 add get 255 div $dat 3 index 2 add get 255 div $dat 4 index 3
-add get 255 div cmyk2rgb rgb2g 255 mul cvi exch pop $dat 3 1 roll put}for $dat
-0 $dat length ncolors idiv getinterval}if}ifelse}image}ifelse}bd}ifelse
-/setcmykcolor{1 5 1 roll _ currentoverprint @scc_5/$ffpnt xd}bd
-/currentcmykcolor{GetCmyk}bd/setrgbcolor{rgb2cmyk setcmykcolor}bd
-/currentrgbcolor{currentcmykcolor cmyk2rgb}bd/sethsbcolor{hsb2rgb setrgbcolor}
-bd/currenthsbcolor{currentrgbcolor rgb2hsb}bd/setgray{dup dup setrgbcolor}bd
-/currentgray{currentrgbcolor rgb2g}bd/InsideDCS false def/IMAGE/image ld/image
-{InsideDCS{IMAGE}{/EPSDict where{pop SepMode_5 0 eq{IMAGE}{dup type/dicttype eq
-{dup/ImageType get 1 ne{IMAGE}{dup dup/BitsPerComponent get 8 eq exch
-/BitsPerComponent get 1 eq or currentcolorspace 0 get/DeviceGray eq and{
-CurrentInkName_5(Black)eq{IMAGE}{dup/DataSource get/TCC xd/Height get abs{TCC
-pop}repeat}ifelse}{IMAGE}ifelse}ifelse}{2 index 1 ne{CurrentInkName_5(Black)eq
-{IMAGE}{/TCC xd pop pop exch pop abs{TCC pop}repeat}ifelse}{IMAGE}ifelse}
-ifelse}ifelse}{IMAGE}ifelse}ifelse}bd}ifelse/WaldoColor_5 true def/$fm 0 def
-/wfill{1 $fm eq{fill}{eofill}ifelse}bd/@Pf{@sv SepMode_5 0 eq $Psc 0 ne or
-$ink_5 3 eq or{0 J 0 j[]0 d $t $c $m $y $k $n $o @scc_5 pop $ctm setmatrix 72
-1000 div dup matrix scale dup concat dup Bburx exch Bbury exch itransform
-ceiling cvi/Bbury xd ceiling cvi/Bburx xd Bbllx exch Bblly exch itransform
-floor cvi/Bblly xd floor cvi/Bbllx xd $Prm aload pop $Psn load exec}{1 SetGry
-wfill}ifelse @rs @np}bd/F{matrix currentmatrix $sdf{$scf $sca $scp @ss}if $fil
-1 eq{CorelPtrnDoFill}{$fil 2 eq{@ff}{$fil 3 eq{@Pf}{$fil 4 eq
-{CorelShfillDoFill}{$t $c $m $y $k $n $o @scc_5{wfill}{@np}ifelse}ifelse}
-ifelse}ifelse}ifelse $sdf{$dsf $dsa $dsp @ss}if setmatrix}bd/f{@cp F}bd/S{
-matrix currentmatrix $ctm setmatrix $SDF{$SCF $SCA $SCP @ss}if $T $C $M $Y $K
-$N $O @scc_5{matrix currentmatrix $ptm concat stroke setmatrix}{@np}ifelse $SDF
-{$dsf $dsa $dsp @ss}if setmatrix}bd/s{@cp S}bd/B{@gs F @gr S}bd/b{@cp B}bd/_E{
-5 array astore exch cvlit xd}bd/@cc{currentfile $dat readhexstring pop}bd/@sm{
-/$ctm $ctm currentmatrix def}bd/@E{/Bbury xd/Bburx xd/Bblly xd/Bbllx xd}bd/@c{
-@cp}bd/@P{/$fil 3 def/$Psn xd/$Psc xd array astore/$Prm xd}bd/tcc{@cc}def/@B{
-@gs S @gr F}bd/@b{@cp @B}bd/@sep{CurrentInkName_5(Composite)eq{/$ink_5 -1 def}
-{CurrentInkName_5(Cyan)eq{/$ink_5 0 def}{CurrentInkName_5(Magenta)eq{/$ink_5 1
-def}{CurrentInkName_5(Yellow)eq{/$ink_5 2 def}{CurrentInkName_5(Black)eq
-{/$ink_5 3 def}{/$ink_5 4 def}ifelse}ifelse}ifelse}ifelse}ifelse}bd/@whi{@gs
--72000 dup m -72000 72000 l 72000 dup l 72000 -72000 l @cp 1 SetGry fill @gr}
-bd/@neg{[{1 exch sub}/exec cvx currenttransfer/exec cvx]cvx settransfer @whi}
-bd/deflevel 0 def/@sax{/deflevel deflevel 1 add def}bd/@eax{/deflevel deflevel
-dup 0 gt{1 sub}if def deflevel 0 gt{/eax load}{eax}ifelse}bd/eax{{exec}forall}
-bd/@rax{deflevel 0 eq{@rs @sv}if}bd systemdict/pdfmark known not{/pdfmark
-/cleartomark ld}if/wclip{1 $fm eq{clip}{eoclip}ifelse}bd
-% Copyright (c)1992-2002 Corel Corporation
-% All rights reserved.     v11.0 r0.0
-/@ii{concat 3 index 3 index m 3 index 1 index l 2 copy l 1 index 3 index l 3
-index 3 index l clip pop pop pop pop}bd/@i{@sm @gs @ii 6 index 1 ne{/$frg true
-def pop pop}{1 eq{s1t s1c s1m s1y s1k s1n $O @scc_5/$frg xd}{/$frg false def}
-ifelse 1 eq{@gs $ctm setmatrix F @gr}if}ifelse @np/$ury xd/$urx xd/$lly xd
-/$llx xd/$bts xd/$hei xd/$wid xd/$dat $wid $bts mul 8 div ceiling cvi string
-def $bkg $frg or{$SDF{$SCF $SCA $SCP @ss}if $llx $lly Tl $urx $llx sub $ury
-$lly sub scale $bkg{$t $c $m $y $k $n $o @scc_5 pop}if $wid $hei abs $bts 1 eq
-{$bkg}{$bts}ifelse[$wid 0 0 $hei neg 0 $hei 0 gt{$hei}{0}ifelse]/tcc load $bts
-1 eq{imagemask}{image}ifelse $SDF{$dsf $dsa $dsp @ss}if}{$hei abs{tcc pop}
-repeat}ifelse @gr $ctm setmatrix}bd/@I{@sm @gs @ii @np/$ury xd/$urx xd/$lly xd
-/$llx xd/$ncl xd/$bts xd/$hei xd/$wid xd $ngx $llx $lly Tl $urx $llx sub $ury
-$lly sub scale $wid $hei abs $bts[$wid 0 0 $hei neg 0 $hei 0 gt{$hei}{0}ifelse
-]$msimage false eq $ncl 1 eq or{/$dat $wid $bts mul $ncl mul 8 div ceiling cvi
-string def/@cc load false $ncl ColorImage}{$wid $bts mul 8 div ceiling cvi $ncl
-3 eq{dup dup/$dat1 exch string def/$dat2 exch string def/$dat3 exch string def
-/@cc1 load/@cc2 load/@cc3 load}{dup dup dup/$dat1 exch string def/$dat2 exch
-string def/$dat3 exch string def/$dat4 exch string def/@cc1 load/@cc2 load
-/@cc3 load/@cc4 load}ifelse true $ncl ColorImage}ifelse $SDF{$dsf $dsa $dsp
-@ss}if @gr $ctm setmatrix}bd/@cc1{currentfile $dat1 readhexstring pop}bd/@cc2{
-currentfile $dat2 readhexstring pop}bd/@cc3{currentfile $dat3 readhexstring pop
-}bd/@cc4{currentfile $dat4 readhexstring pop}bd/$msimage false def/COMP 0 def
-/MaskedImage false def L2?{/@I_2{@sm @gs @ii @np/$ury xd/$urx xd/$lly xd/$llx
-xd/$ncl xd/$bts xd/$hei xd/$wid xd/$dat $wid $bts mul $ncl mul 8 div ceiling
-cvi string def $ngx $ncl 1 eq{/DeviceGray}{$ncl 3 eq{/DeviceRGB}{/DeviceCMYK}
-ifelse}ifelse setcolorspace $llx $lly Tl $urx $llx sub $ury $lly sub scale 8
-dict begin/ImageType 1 def/Width $wid def/Height $hei abs def/BitsPerComponent
-$bts def/Decode $ncl 1 eq{[0 1]}{$ncl 3 eq{[0 1 0 1 0 1]}{[0 1 0 1 0 1 0 1]}
-ifelse}ifelse def/ImageMatrix[$wid 0 0 $hei neg 0 $hei 0 gt{$hei}{0}ifelse]def
-/DataSource currentfile/ASCII85Decode filter COMP 1 eq{/DCTDecode filter}{COMP
-2 eq{/RunLengthDecode filter}if}ifelse def currentdict end image $SDF{$dsf $dsa
-$dsp @ss}if @gr $ctm setmatrix}bd}{/@I_2{}bd}ifelse/@I_3{@sm @gs @ii @np/$ury
-xd/$urx xd/$lly xd/$llx xd/$ncl xd/$bts xd/$hei xd/$wid xd/$dat $wid $bts mul
-$ncl mul 8 div ceiling cvi string def $ngx $ncl 1 eq{/DeviceGray}{$ncl 3 eq
-{/DeviceRGB}{/DeviceCMYK}ifelse}ifelse setcolorspace $llx $lly Tl $urx $llx sub
-$ury $lly sub scale/ImageDataDict 8 dict def ImageDataDict begin/ImageType 1
-def/Width $wid def/Height $hei abs def/BitsPerComponent $bts def/Decode $ncl 1
-eq{[0 1]}{$ncl 3 eq{[0 1 0 1 0 1]}{[0 1 0 1 0 1 0 1]}ifelse}ifelse def
-/ImageMatrix[$wid 0 0 $hei neg 0 $hei 0 gt{$hei}{0}ifelse]def/DataSource
-currentfile/ASCII85Decode filter COMP 1 eq{/DCTDecode filter}{COMP 2 eq{
-/RunLengthDecode filter}if}ifelse def end/MaskedImageDict 7 dict def
-MaskedImageDict begin/ImageType 3 def/InterleaveType 3 def/MaskDict
-ImageMaskDict def/DataDict ImageDataDict def end MaskedImageDict image $SDF
-{$dsf $dsa $dsp @ss}if @gr $ctm setmatrix}bd/@SetMask{/$mbts xd/$mhei xd/$mwid
-xd/ImageMaskDict 8 dict def ImageMaskDict begin/ImageType 1 def/Width $mwid def
-/Height $mhei abs def/BitsPerComponent $mbts def/DataSource maskstream def
-/ImageMatrix[$mwid 0 0 $mhei neg 0 $mhei 0 gt{$mhei}{0}ifelse]def/Decode[1 0]
-def end}bd/@daq{dup type/arraytype eq{{}forall}if}bd/@BMP{/@cc xd UseLevel 3 eq
-MaskedImage true eq and{7 -2 roll pop pop @I_3}{12 index 1 gt UseLevel 2 eq
-UseLevel 3 eq or and{7 -2 roll pop pop @I_2}{11 index 1 eq{12 -1 roll pop @i}{
-7 -2 roll pop pop @I}ifelse}ifelse}ifelse}bd
-% Copyright (c)1992-2002 Corel Corporation
-% All rights reserved.     v11.0 r0.0
-/@p{/$fil 1 def 1 eq dup/$vectpat xd{/$pfrg true def}{@gs $t $c $m $y $k $n $o
-@scc_5/$pfrg xd @gr}ifelse/$pm xd/$psy xd/$psx xd/$pyf xd/$pxf xd/$pn xd}bd
-/CorelPtrnDoFill{@gs $ctm setmatrix $pm concat CorelPtrnSetBBox wclip @sv Bburx
-Bbury $pm itransform/$tury xd/$turx xd Bbllx Bblly $pm itransform/$tlly xd
-/$tllx xd newpath $tllx $tlly m $tllx $tury l $turx $tury l $turx $tlly l $tllx
-$tlly m @cp pathbbox @rs/$tury xd/$turx xd/$tlly xd/$tllx xd/$wid $turx $tllx
-sub def/$hei $tury $tlly sub def @gs $vectpat{1 0 0 0 0 _ $o @scc_5{wfill}if}{
-$t $c $m $y $k $n $o @scc_5{SepMode_5 0 eq $pfrg or{$tllx $tlly Tl $wid $hei
-scale <00> 8 1 false[8 0 0 1 0 0]{}imagemask}{/$bkg true def}ifelse}if}ifelse
-@gr $wid 0 gt $hei 0 gt and{$pn cvlit load aload pop/$pd xd 3 -1 roll sub
-/$phei xd exch sub/$pwid xd $wid $pwid div ceiling 1 add/$tlx xd $hei $phei div
-ceiling 1 add/$tly xd currentdict/CorelPtrnL2Pattern known $psy 0 eq and $psx 0
-eq and{CorelPtrnL2Pattern}{$psx 0 eq{CorelPtrnTileVeritcal}{CorelPtrnTileHoriz
-}ifelse}ifelse}if @gr @np/$bkg false def}bd/CorelPtrnSetBBox{pathbbox/$ury xd
-/$urx xd/$lly xd/$llx xd}bd/CorelPtrnSetFirstTile{$tllx $pxf add dup $tllx gt
-{$pwid sub}if/$tx xd $tury $pyf sub dup $tury lt{$phei add}if/$ty xd}bd/p{/$pm
-xd 7 rp/$pyf xd/$pxf xd/$pn xd/$fil 1 def}bd/CorelPtrnDraw{@ep}bd
-/CorelPtrnPutTile{@sv/$in true def 2 copy dup $lly le{/$in false def}if $phei
-sub $ury ge{/$in false def}if dup $urx ge{/$in false def}if $pwid add $llx le{
-/$in false def}if $in{@np 2 copy m $pwid 0 rl 0 $phei neg rl $pwid neg 0 rl 0
-$phei rl clip @np $pn cvlit load aload pop 7 -1 roll 5 index sub 7 -1 roll 3
-index sub Tl matrix currentmatrix/$ctm xd CorelPtrnDraw pop pop pop pop}{pop
-pop}ifelse @rs}bd/CorelPtrnTileHoriz{CorelPtrnSetFirstTile 0 1 $tly 1 sub{dup
-$psx mul $tx add{dup $llx gt{$pwid sub}{exit}ifelse}loop exch $phei mul $ty
-exch sub 0 1 $tlx 1 sub{$pwid mul 3 copy 3 -1 roll add exch CorelPtrnPutTile
-pop}for pop pop}for}bd/CorelPtrnTileVeritcal{CorelPtrnSetFirstTile 0 1 $tlx 1
-sub{dup $pwid mul $tx add exch $psy mul $ty exch sub{dup $ury lt{$phei add}
-{exit}ifelse}loop 0 1 $tly 1 sub{$phei mul 3 copy sub CorelPtrnPutTile pop}for
-pop pop}for}bd L2? UseLevel 2 ge and{/CorelPtrnL2Pattern{@sv[$pn cvlit load
-aload pop pop]$pwid $phei $pn cvlit load aload pop pop pop pop pathbbox pop pop
-2 index sub exch 3 index sub 4 -2 roll pop pop exch matrix identmatrix
-translate/PatternMatrix xd/PatternYStep xd/PatternXStep xd/PatternBBox xd
-currentdict/PatternMainDict xd <</PaintType 1/PatternType 1/TilingType 1/BBox
-PatternBBox/XStep PatternXStep/YStep PatternYStep/PaintProc{begin
-PatternMainDict begin $ctm currentmatrix pop 0 CorelPtrnDraw end end}bind >>
-PatternMatrix makepattern setpattern fill @rs}def}if
+%!PS-Adobe-3.0 EPSF-3.0
+%%For: 
+%%Title: 
+%%Creator: Scribus1.4.2
+%%Pages: 1
+%%BoundingBox: 0 0 282 282
+%%HiResBoundingBox: 0 0 282 282
+%%LanguageLevel: 3
+%%EndComments
+%%BeginProlog
+/Scribusdict 100 dict def
+Scribusdict begin
+/sp {showpage} bind def
+/oldsetgray /setgray load def
+/cmyk {setcmykcolor} def
+/m {moveto} bind def
+/l {lineto} bind def
+/li {lineto} bind def
+/cu {curveto} bind def
+/cl {closepath} bind def
+/gs {gsave} bind def
+/gr {grestore} bind def
+/tr {translate} bind def
+/ro {rotate} bind def
+/sh {show} bind def
+/shg {setcmykcolor moveto glyphshow} def
+/shgsp {moveto glyphshow} def
+/sc {scale} bind def
+/se {selectfont} bind def
+/sf {setfont} bind def
+/sw {setlinewidth} bind def
+/f  {findfont} bind def
+/fi {fill} bind def
+/st {stroke} bind def
+/shgf {gs dup scale begin cvx exec fill end gr} bind def
+/shgs {gs dup 1 exch div currentlinewidth mul sw dup scale
+       begin cvx exec st end gr} bind def
+/bEPS {
+    /b4_Inc_state save def
+    /dict_count countdictstack def
+    /op_count count 1 sub def
+    userdict begin
+    /showpage { } def
+    0 setgray 0 setlinecap
+    1 setlinewidth 0 setlinejoin
+    10 setmiterlimit [ ] 0 setdash newpath
+    /languagelevel where
+    {pop languagelevel
+    1 ne
+    {false setstrokeadjust false setoverprint
+    } if } if } bind def
+/eEPS { count op_count sub {pop} repeat
+    countdictstack dict_count sub {end} repeat
+    b4_Inc_state restore } bind def
+    end
+%%EndProlog
+%%BeginSetup
+%%EndSetup
+%%Page: 1 1
+%%PageOrientation: Portrait
+Scribusdict begin
+save
+/DeviceCMYK setcolorspace
+0 0 tr
+0 0 m
+282 0 li
+282 282 li
+0 282 li cl clip newpath
+gs
+0.708406 281.428 m
+281.58 281.428 li
+281.58 0.556 li
+0.708406 0.556 li
+0.708406 281.428 li
+cl
+eoclip newpath
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+0.816406 281.32 tr
+280.656 -138.888 m
+138.888 0 li
+0 -141.696 li
+138.888 -280.656 li
+280.656 -138.888 li
+cl
+0 0 0 1 cmyk eofill
+280.656 -138.888 m
+138.888 0 li
+0 -141.696 li
+138.888 -280.656 li
+280.656 -138.888 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+139.704 142.432 tr
+127.584 0 m
+136.08 0 li
+0 -136.08 li
+0 -127.584 li
+127.584 0 li
+cl
+0.6 0 0.4 0.580392 cmyk eofill
+127.584 0 m
+136.08 0 li
+0 -136.08 li
+0 -127.584 li
+127.584 0 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+6.50391 139.624 tr
+0 0 m
+8.49609 0 li
+133.2 -124.776 li
+133.2 -133.272 li
+0 0 li
+cl
+0.6 0 0.4 0.509804 cmyk eofill
+0 0 m
+8.49609 0 li
+133.2 -124.776 li
+133.2 -133.272 li
+0 0 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+6.50391 275.632 tr
+133.2 -8.42384 m
+133.2 0 li
+0 -136.008 li
+8.49609 -136.008 li
+133.2 -8.42384 li
+cl
+0.6 0 0.4 0 cmyk eofill
+133.2 -8.42384 m
+133.2 0 li
+0 -136.008 li
+8.49609 -136.008 li
+133.2 -8.42384 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+139.704 275.632 tr
+0 0 m
+0 -8.42384 li
+127.584 -133.2 li
+136.08 -133.2 li
+0 0 li
+cl
+0.729412 0 0.988235 0 cmyk eofill
+0 0 m
+0 -8.42384 li
+127.584 -133.2 li
+136.08 -133.2 li
+0 0 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+15 267.208 tr
+124.704 -252.36 m
+252.288 -124.776 li
+124.704 0 li
+0 -127.584 li
+124.704 -252.36 li
+cl
+0.6 0 0.4 0.4 cmyk eofill
+124.704 -252.36 m
+252.288 -124.776 li
+124.704 0 li
+0 -127.584 li
+124.704 -252.36 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+18.8164 270.016 tr
+147.384 -31.1758 m
+155.88 -39.7431 li
+97.2716 -99.2156 li
+97.2716 -39.7431 li
+102.96 -39.7431 li
+111.456 -31.1758 li
+111.456 -8.5674 li
+102.96 0 li
+8.4951 0 li
+0 -8.5674 li
+0 -31.1758 li
+8.4951 -39.7431 li
+15.1191 -39.7431 li
+15.1191 -232.488 li
+25.4873 -240.984 li
+54.792 -240.984 li
+257.904 -31.1758 li
+257.904 -8.5674 li
+249.408 0 li
+156.816 0 li
+147.384 -8.5674 li
+147.384 -31.1758 li
+cl
+0 0 0 1 cmyk eofill
+147.384 -31.1758 m
+155.88 -39.7431 li
+97.2716 -99.2156 li
+97.2716 -39.7431 li
+102.96 -39.7431 li
+111.456 -31.1758 li
+111.456 -8.5674 li
+102.96 0 li
+8.4951 0 li
+0 -8.5674 li
+0 -31.1758 li
+8.4951 -39.7431 li
+15.1191 -39.7431 li
+15.1191 -232.488 li
+25.4873 -240.984 li
+54.792 -240.984 li
+257.904 -31.1758 li
+257.904 -8.5674 li
+249.408 0 li
+156.816 0 li
+147.384 -8.5674 li
+147.384 -31.1758 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+24.4316 264.4 tr
+5.6885 -28.4404 m
+0 -22.752 li
+0 -5.7608 li
+5.6885 -0.0723 li
+94.5364 0 li
+100.152 -5.7608 li
+94.5364 -8.4961 li
+91.6564 -5.7608 li
+5.6885 -19.8721 li
+5.6885 -28.4404 li
+cl
+0 0 0 0 cmyk eofill
+5.6885 -28.4404 m
+0 -22.752 li
+0 -5.7608 li
+5.6885 -0.0723 li
+94.5364 0 li
+100.152 -5.7608 li
+94.5364 -8.4961 li
+91.6564 -5.7608 li
+5.6885 -19.8721 li
+5.6885 -28.4404 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+40.4883 241.648 tr
+6.624 -206.928 m
+0 -201.24 li
+0 -5.6162 li
+6.624 0 li
+6.624 -206.928 li
+cl
+0 0 0 0 cmyk eofill
+6.624 -206.928 m
+0 -201.24 li
+0 -5.6162 li
+6.624 0 li
+6.624 -206.928 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+100.032 241.648 tr
+88.848 -5.6884 m
+94.536 0 li
+94.536 -11.3759 li
+0 -107.712 li
+10.44 -85.0324 li
+88.848 -5.6884 li
+cl
+0 0 0 0 cmyk eofill
+88.848 -5.6884 m
+94.536 0 li
+94.536 -11.3759 li
+0 -107.712 li
+10.44 -85.0324 li
+88.848 -5.6884 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+30.1201 247.336 tr
+18.9356 -2.8798 m
+16.9922 -5.6875 li
+10.3682 -11.3759 li
+0 -11.3759 li
+0 0 li
+18.9356 -2.8798 li
+cl
+0 0 0 0.501961 cmyk eofill
+18.9356 -2.8798 m
+16.9922 -5.6875 li
+10.3682 -11.3759 li
+0 -11.3759 li
+0 0 li
+18.9356 -2.8798 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+100.032 258.64 tr
+10.44 -22.6796 m
+10.44 -102.024 li
+0 -124.632 li
+0 -16.9199 li
+16.056 -16.9199 li
+18.936 -14.1113 li
+16.056 0 li
+24.552 0 li
+24.552 -16.9912 li
+18.936 -22.6796 li
+10.44 -22.6796 li
+cl
+0 0 0 0.501961 cmyk eofill
+10.44 -22.6796 m
+10.44 -102.024 li
+0 -124.632 li
+0 -16.9199 li
+16.056 -16.9199 li
+18.936 -14.1113 li
+16.056 0 li
+24.552 0 li
+24.552 -16.9912 li
+18.936 -22.6796 li
+10.44 -22.6796 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+171.888 264.328 tr
+5.616 -28.3681 m
+0 -22.6797 li
+0 -5.6885 li
+6.552 0 li
+92.592 0 li
+99.216 -5.6885 li
+89.712 -14.1845 li
+5.616 -19.7998 li
+5.616 -28.3681 li
+cl
+0 0 0 0 cmyk eofill
+5.616 -28.3681 m
+0 -22.6797 li
+0 -5.6885 li
+6.552 0 li
+92.592 0 li
+99.216 -5.6885 li
+89.712 -14.1845 li
+5.616 -19.7998 li
+5.616 -28.3681 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+47.1123 258.64 tr
+223.992 -16.9912 m
+24.5518 -223.92 li
+0 -223.92 li
+0 -215.424 li
+18 -215.424 li
+217.368 -11.3037 li
+214.488 0 li
+223.992 0 li
+223.992 -16.9912 li
+cl
+0 0 0 0.501961 cmyk eofill
+223.992 -16.9912 m
+24.5518 -223.92 li
+0 -223.92 li
+0 -215.424 li
+18 -215.424 li
+217.368 -11.3037 li
+214.488 0 li
+223.992 0 li
+223.992 -16.9912 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+177.504 247.336 tr
+18.936 -2.8798 m
+16.992 -5.6875 li
+11.376 -11.3759 li
+0 -11.3759 li
+0 0 li
+18.936 -2.8798 li
+cl
+0 0 0 0.501961 cmyk eofill
+18.936 -2.8798 m
+16.992 -5.6875 li
+11.376 -11.3759 li
+0 -11.3759 li
+0 0 li
+18.936 -2.8798 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+30.1201 258.712 tr
+69.9119 -124.704 m
+69.9119 -16.9922 li
+85.9679 -16.9922 li
+88.8479 -14.1836 li
+88.8479 -2.8076 li
+85.9679 0 li
+2.8076 0 li
+0 -2.8076 li
+0 -14.1836 li
+2.8076 -16.9922 li
+16.9922 -16.9922 li
+16.9922 -215.496 li
+20.6641 -218.304 li
+36.8643 -218.304 li
+235.296 -11.376 li
+235.296 -3.2402 li
+232.416 0 li
+150.264 0 li
+147.384 -2.8076 li
+147.384 -14.2558 li
+150.264 -17.0635 li
+164.448 -17.0635 li
+164.448 -28.4394 li
+69.9119 -124.704 li
+cl
+0 0 0 0.2 cmyk eofill
+69.9119 -124.704 m
+69.9119 -16.9922 li
+85.9679 -16.9922 li
+88.8479 -14.1836 li
+88.8479 -2.8076 li
+85.9679 0 li
+2.8076 0 li
+0 -2.8076 li
+0 -14.1836 li
+2.8076 -16.9922 li
+16.9922 -16.9922 li
+16.9922 -215.496 li
+20.6641 -218.304 li
+36.8643 -218.304 li
+235.296 -11.376 li
+235.296 -3.2402 li
+232.416 0 li
+150.264 0 li
+147.384 -2.8076 li
+147.384 -14.2558 li
+150.264 -17.0635 li
+164.448 -17.0635 li
+164.448 -28.4394 li
+69.9119 -124.704 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+145.896 139.552 tr
+5.688 -5.688 m
+12.312 0 li
+29.304 0 li
+34.056 -5.688 li
+28.368 -22.68 li
+21.816 -28.368 li
+4.824 -28.368 li
+0 -22.68 li
+5.688 -5.688 li
+cl
+0 0 0 1 cmyk eofill
+5.688 -5.688 m
+12.312 0 li
+29.304 0 li
+34.056 -5.688 li
+28.368 -22.68 li
+21.816 -28.368 li
+4.824 -28.368 li
+0 -22.68 li
+5.688 -5.688 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+157.272 108.376 tr
+0 -68.04 m
+17.064 -17.064 li
+11.376 -17.064 li
+17.064 0 li
+42.48 0 li
+48.168 -5.688 li
+51.984 -5.688 li
+57.6 0 li
+76.536 0 li
+82.224 -5.688 li
+85.968 -5.688 li
+91.656 0 li
+112.392 0 li
+119.952 -11.376 li
+107.568 -51.696 li
+113.184 -51.696 li
+107.712 -68.04 li
+73.656 -68.04 li
+86.976 -28.368 li
+78.48 -28.368 li
+70.632 -51.552 li
+76.248 -51.552 li
+70.92 -68.04 li
+36.864 -68.04 li
+50.112 -28.368 li
+41.616 -28.368 li
+33.696 -51.696 li
+39.384 -51.696 li
+34.056 -68.04 li
+0 -68.04 li
+cl
+0 0 0 1 cmyk eofill
+0 -68.04 m
+17.064 -17.064 li
+11.376 -17.064 li
+17.064 0 li
+42.48 0 li
+48.168 -5.688 li
+51.984 -5.688 li
+57.6 0 li
+76.536 0 li
+82.224 -5.688 li
+85.968 -5.688 li
+91.656 0 li
+112.392 0 li
+119.952 -11.376 li
+107.568 -51.696 li
+113.184 -51.696 li
+107.712 -68.04 li
+73.656 -68.04 li
+86.976 -28.368 li
+78.48 -28.368 li
+70.632 -51.552 li
+76.248 -51.552 li
+70.92 -68.04 li
+36.864 -68.04 li
+50.112 -28.368 li
+41.616 -28.368 li
+33.696 -51.696 li
+39.384 -51.696 li
+34.056 -68.04 li
+0 -68.04 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+164.832 102.688 tr
+102.24 0 m
+106.632 -6.264 li
+92.664 -51.048 li
+98.28 -51.048 li
+96.408 -56.664 li
+73.728 -56.664 li
+86.976 -16.992 li
+67.104 -16.992 li
+55.8 -51.048 li
+61.416 -51.048 li
+59.544 -56.664 li
+36.864 -56.664 li
+50.112 -16.992 li
+30.24 -16.992 li
+18.936 -51.048 li
+24.624 -51.048 li
+22.68 -56.664 li
+0 -56.664 li
+17.064 -5.688 li
+11.376 -5.688 li
+13.248 0 li
+34.056 0 li
+39.744 -5.688 li
+45.36 -5.688 li
+51.048 0 li
+68.04 0 li
+73.728 -5.688 li
+79.416 -5.688 li
+85.104 0 li
+102.24 0 li
+cl
+0 0 0 0.2 cmyk eofill
+102.24 0 m
+106.632 -6.264 li
+92.664 -51.048 li
+98.28 -51.048 li
+96.408 -56.664 li
+73.728 -56.664 li
+86.976 -16.992 li
+67.104 -16.992 li
+55.8 -51.048 li
+61.416 -51.048 li
+59.544 -56.664 li
+36.864 -56.664 li
+50.112 -16.992 li
+30.24 -16.992 li
+18.936 -51.048 li
+24.624 -51.048 li
+22.68 -56.664 li
+0 -56.664 li
+17.064 -5.688 li
+11.376 -5.688 li
+13.248 0 li
+34.056 0 li
+39.744 -5.688 li
+45.36 -5.688 li
+51.048 0 li
+68.04 0 li
+73.728 -5.688 li
+79.416 -5.688 li
+85.104 0 li
+102.24 0 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+120.408 108.376 tr
+51.048 0 m
+33.696 -51.624 li
+39.6 -51.624 li
+33.984 -68.04 li
+0 -68.04 li
+16.992 -17.064 li
+11.304 -17.064 li
+51.048 0 li
+cl
+11.304 -17.064 m
+16.992 0 li
+51.048 0 li
+11.304 -17.064 li
+cl
+0 0 0 1 cmyk eofill
+51.048 0 m
+33.696 -51.624 li
+39.6 -51.624 li
+33.984 -68.04 li
+0 -68.04 li
+16.992 -17.064 li
+11.304 -17.064 li
+51.048 0 li
+cl
+11.304 -17.064 m
+16.992 0 li
+51.048 0 li
+11.304 -17.064 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+127.968 102.688 tr
+22.68 -56.664 m
+24.552 -51.048 li
+18.864 -51.048 li
+35.928 0 li
+12.312 0 li
+10.368 -5.688 li
+16.992 -5.688 li
+0 -56.664 li
+22.68 -56.664 li
+cl
+0 0 0 0.2 cmyk eofill
+22.68 -56.664 m
+24.552 -51.048 li
+18.864 -51.048 li
+35.928 0 li
+12.312 0 li
+10.368 -5.688 li
+16.992 -5.688 li
+0 -56.664 li
+22.68 -56.664 li
+cl
+0 0 0 1 cmyk st
+gr
+gs
+0.216 sw
+0 setlinecap
+0 setlinejoin
+[] 0 setdash
+152.52 133.864 tr
+16.992 -14.184 m
+20.808 -2.808 li
+18.936 0 li
+7.56 0 li
+3.816 -2.808 li
+0 -14.184 li
+1.944 -16.992 li
+13.32 -16.992 li
+16.992 -14.184 li
+cl
+0 0 0 0.2 cmyk eofill
+16.992 -14.184 m
+20.808 -2.808 li
+18.936 0 li
+7.56 0 li
+3.816 -2.808 li
+0 -14.184 li
+1.944 -16.992 li
+13.32 -16.992 li
+16.992 -14.184 li
+cl
+0 0 0 1 cmyk st
+gr
+gr
+%%PageTrailer
+restore
+gs
+gr
+sp
 end
-%%EndResource
-%%EndProlog
-%%BeginSetup
-wCorel11Dict begin
-@BeginSysCorelDict
-2.6131 setmiterlimit
-1.00 setflat
-/$fst 128 def
-%%EndSetup
-
-%%Page: 1 1
-%LogicalPage: 1
-%%BeginPageSetup
-@sv
-@sm
-@sv
-%%EndPageSetup
-@rax %Note: Object
-147.81600 74.66400 428.47200 355.32000 @E
- 0 O 0 @g
-0.00 0.00 0.00 1.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-428.47200 216.43200 m
-286.70400 355.32000 L
-147.81600 213.62400 L
-286.70400 74.66400 L
-428.47200 216.43200 L
-@c
-B
-
-@rax %Note: Object
-286.70400 80.35200 422.78400 216.43200 @E
- 0 O 0 @g
-0.60 0.00 0.40 0.58 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-414.28800 216.43200 m
-422.78400 216.43200 L
-286.70400 80.35200 L
-286.70400 88.84800 L
-414.28800 216.43200 L
-@c
-B
-
-@rax %Note: Object
-153.50400 80.35200 286.70400 213.62400 @E
- 0 O 0 @g
-0.60 0.00 0.40 0.51 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-153.50400 213.62400 m
-162.00000 213.62400 L
-286.70400 88.84800 L
-286.70400 80.35200 L
-153.50400 213.62400 L
-@c
-B
-
-@rax %Note: Object
-153.50400 213.62400 286.70400 349.63200 @E
- 0 O 0 @g
-0.60 0.00 0.40 0.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-286.70400 341.20800 m
-286.70400 349.63200 L
-153.50400 213.62400 L
-162.00000 213.62400 L
-286.70400 341.20800 L
-@c
-B
-
-@rax %Note: Object
-286.70400 216.43200 422.78400 349.63200 @E
- 0 O 0 @g
-0.73 0.00 0.99 0.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-286.70400 349.63200 m
-286.70400 341.20800 L
-414.28800 216.43200 L
-422.78400 216.43200 L
-286.70400 349.63200 L
-@c
-B
-
-@rax %Note: Object
-162.00000 88.84800 414.28800 341.20800 @E
- 0 O 0 @g
-0.60 0.00 0.40 0.40 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-286.70400 88.84800 m
-414.28800 216.43200 L
-286.70400 341.20800 L
-162.00000 213.62400 L
-286.70400 88.84800 L
-@c
-B
-
-@rax %Note: Object
-165.81600 103.03200 423.72000 344.01600 @E
- 0 O 0 @g
-0.00 0.00 0.00 1.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-313.20000 312.84000 m
-321.69600 304.27200 L
-321.69600 304.27200 L
-263.08800 244.80000 L
-263.08800 304.27200 L
-268.77600 304.27200 L
-277.27200 312.84000 L
-277.27200 335.44800 L
-268.77600 344.01600 L
-174.31200 344.01600 L
-165.81600 335.44800 L
-165.81600 312.84000 L
-174.31200 304.27200 L
-180.93600 304.27200 L
-180.93600 111.52800 L
-191.30400 103.03200 L
-220.60800 103.03200 L
-423.72000 312.84000 L
-423.72000 335.44800 L
-415.22400 344.01600 L
-322.63200 344.01600 L
-313.20000 335.44800 L
-313.20000 312.84000 L
-@c
-B
-
-@rax %Note: Object
-171.43200 309.96000 271.58400 338.40000 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-177.12000 309.96000 m
-171.43200 315.64800 L
-171.43200 332.64000 L
-177.12000 338.32800 L
-265.96800 338.40000 L
-271.58400 332.64000 L
-265.96800 329.90400 L
-263.08800 332.64000 L
-177.12000 318.52800 L
-177.12000 309.96000 L
-@c
-B
-
-@rax %Note: Object
-187.48800 108.72000 194.11200 315.64800 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-194.11200 108.72000 m
-187.48800 114.40800 L
-187.48800 310.03200 L
-194.11200 315.64800 L
-194.11200 108.72000 L
-@c
-B
-
-@rax %Note: Object
-247.03200 207.93600 341.56800 315.64800 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-335.88000 309.96000 m
-341.56800 315.64800 L
-341.56800 304.27200 L
-247.03200 207.93600 L
-257.47200 230.61600 L
-335.88000 309.96000 L
-@c
-B
-
-@rax %Note: Object
-177.12000 309.96000 196.05600 321.33600 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.50 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-196.05600 318.45600 m
-194.11200 315.64800 L
-187.48800 309.96000 L
-177.12000 309.96000 L
-177.12000 321.33600 L
-196.05600 318.45600 L
-@c
-B
-
-@rax %Note: Object
-247.03200 208.00800 271.58400 332.64000 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.50 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-257.47200 309.96000 m
-257.47200 230.61600 L
-247.03200 208.00800 L
-247.03200 315.72000 L
-263.08800 315.72000 L
-265.96800 318.52800 L
-263.08800 332.64000 L
-271.58400 332.64000 L
-271.58400 315.64800 L
-265.96800 309.96000 L
-257.47200 309.96000 L
-@c
-B
-
-@rax %Note: Object
-318.88800 309.96000 418.10400 338.32800 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-324.50400 309.96000 m
-318.88800 315.64800 L
-318.88800 332.64000 L
-325.44000 338.32800 L
-411.48000 338.32800 L
-418.10400 332.64000 L
-408.60000 324.14400 L
-324.50400 318.52800 L
-324.50400 309.96000 L
-@c
-B
-
-@rax %Note: Object
-194.11200 108.72000 418.10400 332.64000 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.50 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-418.10400 315.64800 m
-218.66400 108.72000 L
-194.11200 108.72000 L
-194.11200 117.21600 L
-212.11200 117.21600 L
-411.48000 321.33600 L
-408.60000 332.64000 L
-418.10400 332.64000 L
-418.10400 315.64800 L
-@c
-B
-
-@rax %Note: Object
-324.50400 309.96000 343.44000 321.33600 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.50 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-343.44000 318.45600 m
-341.49600 315.64800 L
-335.88000 309.96000 L
-324.50400 309.96000 L
-324.50400 321.33600 L
-343.44000 318.45600 L
-@c
-B
-
-@rax %Note: Object
-177.12000 114.40800 412.41600 332.71200 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.20 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-247.03200 208.00800 m
-247.03200 315.72000 L
-263.08800 315.72000 L
-265.96800 318.52800 L
-265.96800 329.90400 L
-263.08800 332.71200 L
-179.92800 332.71200 L
-177.12000 329.90400 L
-177.12000 318.52800 L
-179.92800 315.72000 L
-194.11200 315.72000 L
-194.11200 117.21600 L
-197.78400 114.40800 L
-213.98400 114.40800 L
-412.41600 321.33600 L
-412.41600 329.47200 L
-409.53600 332.71200 L
-327.38400 332.71200 L
-324.50400 329.90400 L
-324.50400 318.45600 L
-327.38400 315.64800 L
-341.56800 315.64800 L
-341.56800 304.27200 L
-247.03200 208.00800 L
-@c
-B
-
-@rax %Note: Object
-292.89600 185.18400 326.95200 213.55200 @E
- 0 O 0 @g
-0.00 0.00 0.00 1.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-298.58400 207.86400 m
-305.20800 213.55200 L
-322.20000 213.55200 L
-326.95200 207.86400 L
-321.26400 190.87200 L
-314.71200 185.18400 L
-297.72000 185.18400 L
-292.89600 190.87200 L
-298.58400 207.86400 L
-@c
-B
-
-@rax %Note: Object
-304.27200 114.33600 424.22400 182.37600 @E
- 0 O 0 @g
-0.00 0.00 0.00 1.00 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-304.27200 114.33600 m
-321.33600 165.31200 L
-315.64800 165.31200 L
-321.33600 182.37600 L
-346.75200 182.37600 L
-352.44000 176.68800 L
-356.25600 176.68800 L
-361.87200 182.37600 L
-380.80800 182.37600 L
-386.49600 176.68800 L
-390.24000 176.68800 L
-395.92800 182.37600 L
-416.66400 182.37600 L
-424.22400 171.00000 L
-411.84000 130.68000 L
-417.45600 130.68000 L
-411.98400 114.33600 L
-377.92800 114.33600 L
-391.24800 154.00800 L
-382.75200 154.00800 L
-374.90400 130.82400 L
-380.52000 130.82400 L
-375.19200 114.33600 L
-341.13600 114.33600 L
-354.38400 154.00800 L
-345.88800 154.00800 L
-337.96800 130.68000 L
-343.65600 130.68000 L
-338.32800 114.33600 L
-304.27200 114.33600 L
-@c
-B
-
-@rax %Note: Object
-311.83200 120.02400 418.46400 176.68800 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.20 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-414.07200 176.68800 m
-418.46400 170.42400 L
-404.49600 125.64000 L
-410.11200 125.64000 L
-408.24000 120.02400 L
-385.56000 120.02400 L
-398.80800 159.69600 L
-378.93600 159.69600 L
-367.63200 125.64000 L
-373.24800 125.64000 L
-371.37600 120.02400 L
-348.69600 120.02400 L
-361.94400 159.69600 L
-342.07200 159.69600 L
-330.76800 125.64000 L
-336.45600 125.64000 L
-334.51200 120.02400 L
-311.83200 120.02400 L
-328.89600 171.00000 L
-323.20800 171.00000 L
-325.08000 176.68800 L
-345.88800 176.68800 L
-351.57600 171.00000 L
-357.19200 171.00000 L
-362.88000 176.68800 L
-379.87200 176.68800 L
-385.56000 171.00000 L
-391.24800 171.00000 L
-396.93600 176.68800 L
-414.07200 176.68800 L
-@c
-B
-
-@rax %Note: Object
-267.40800 114.33600 318.45600 182.37600 @E
- 0 O 0 @g
-0.00 0.00 0.00 1.00 k
-/$fm 0 def
-318.45600 182.37600 m
-301.10400 130.75200 L
-307.00800 130.75200 L
-301.39200 114.33600 L
-267.40800 114.33600 L
-284.40000 165.31200 L
-278.71200 165.31200 L
-318.45600 182.37600 L
-@c
-278.71200 165.31200 m
-284.40000 182.37600 L
-318.45600 182.37600 L
-@c
-F
-
-@rax %Note: Object
-267.40800 114.33600 318.45600 182.37600 @E
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-318.45600 182.37600 m
-301.10400 130.75200 L
-307.00800 130.75200 L
-301.39200 114.33600 L
-267.40800 114.33600 L
-284.40000 165.31200 L
-278.71200 165.31200 L
-@c
-278.71200 165.31200 m
-284.40000 182.37600 L
-318.45600 182.37600 L
-@c
-S
-
-@rax %Note: Object
-274.96800 120.02400 310.89600 176.68800 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.20 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-297.64800 120.02400 m
-299.52000 125.64000 L
-293.83200 125.64000 L
-310.89600 176.68800 L
-287.28000 176.68800 L
-285.33600 171.00000 L
-291.96000 171.00000 L
-274.96800 120.02400 L
-297.64800 120.02400 L
-@c
-B
-
-@rax %Note: Object
-299.52000 190.87200 320.32800 207.86400 @E
- 0 O 0 @g
-0.00 0.00 0.00 0.20 k
-0 J 0 j [] 0 d 0 R 0 @G
-0.00 0.00 0.00 1.00 K
-0 0.21600 0.21600 0.00000 @w
-/$fm 0 def
-316.51200 193.68000 m
-320.32800 205.05600 L
-318.45600 207.86400 L
-307.08000 207.86400 L
-303.33600 205.05600 L
-299.52000 193.68000 L
-301.46400 190.87200 L
-312.84000 190.87200 L
-316.51200 193.68000 L
-@c
-B
-
-%%PageTrailer
-@rs
-@rs
-%%Trailer
-@EndSysCorelDict
-end
-%%DocumentSuppliedResources: procset wCorel11Dict 11.0 0
-%%EOF
+%%Trailer
+%%EOF
diff -Naur vim74.orig/runtime/vimrc_example.vim vim74/runtime/vimrc_example.vim
--- vim74.orig/runtime/vimrc_example.vim	2011-04-15 18:58:36.000000000 +0000
+++ vim74/runtime/vimrc_example.vim	2014-10-10 14:53:43.908714978 +0000
@@ -1,7 +1,7 @@
 " An example for a vimrc file.
 "
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last change:	2011 Apr 15
+" Last change:	2014 Feb 05
 "
 " To use it, copy it to
 "     for Unix and OS/2:  ~/.vimrc
@@ -24,7 +24,8 @@
 if has("vms")
   set nobackup		" do not keep a backup file, use versions instead
 else
-  set backup		" keep a backup file
+  set backup		" keep a backup file (restore to previous version)
+  set undofile		" keep an undo file (undo changes after closing)
 endif
 set history=50		" keep 50 lines of command line history
 set ruler		" show the cursor position all the time
diff -Naur vim74.orig/src/GvimExt/Make_cyg.mak vim74/src/GvimExt/Make_cyg.mak
--- vim74.orig/src/GvimExt/Make_cyg.mak	2011-09-30 14:45:49.000000000 +0000
+++ vim74/src/GvimExt/Make_cyg.mak	2014-10-10 14:53:43.942048227 +0000
@@ -31,12 +31,12 @@
 ifeq ($(CROSS),yes)
 DEL = rm
 ifeq ($(MINGWOLD),yes)
-CXXFLAGS := -O2 -mno-cygwin -fvtable-thunks
+CXXFLAGS := -O2 -fvtable-thunks
 else
-CXXFLAGS := -O2 -mno-cygwin
+CXXFLAGS := -O2
 endif
 else
-CXXFLAGS := -O2 -mno-cygwin
+CXXFLAGS := -O2
 ifneq (sh.exe, $(SHELL))
 DEL = rm
 else
diff -Naur vim74.orig/src/INSTALLpc.txt vim74/src/INSTALLpc.txt
--- vim74.orig/src/INSTALLpc.txt	2012-08-29 15:29:09.000000000 +0000
+++ vim74/src/INSTALLpc.txt	2014-10-10 14:53:43.975381477 +0000
@@ -192,6 +192,30 @@
 Vim with Make_mvc.mak.
 
 
+Targeting Windows XP with new MSVC      *new-msvc-windows-xp*
+----------------------------------
+
+Beginning with Visual C++ 2010, Microsoft changed the behavior of LINK.EXE
+so that it targets Windows 6.0 (Vista) by default.  In order to override
+this, the target Windows version number needs to be passed to LINK like
+follows:
+    LINK ... /subsystem:console,5.01
+
+Make_mvc.mak now supports a macro SUBSYSTEM_VER to pass the Windows version.
+Use lines like follows to target Windows XP (assuming using Visual C++ 2012
+under 64-bit Windows):
+    set WinSdk71=%ProgramFiles(x86)%\Microsoft SDKs\Windows\v7.1A
+    set SDK_INCLUDE_DIR=%WinSdk71%\Include
+    set INCLUDE=%WinSdk71%\Include;%INCLUDE%
+    set LIB=%WinSdk71%\Lib;%LIB%
+    set PATH=%WinSdk71%\Bin;%PATH%
+    set CL=/D_USING_V110_SDK71_
+    nmake -f Make_mvc.mak ... WINVER=0x0501 SUBSYSTEM_VER=5.01
+
+The following Visual C++ team blog can serve as a reference page:
+    http://blogs.msdn.com/b/vcblog/archive/2012/10/08/windows-xp-targeting-with-c-in-visual-studio-2012.aspx
+
+
 2. MinGW
 ========
 
diff -Naur vim74.orig/src/Make_bc3.mak vim74/src/Make_bc3.mak
--- vim74.orig/src/Make_bc3.mak	2010-05-18 18:27:58.000000000 +0000
+++ vim74/src/Make_bc3.mak	2014-10-10 14:53:43.978714802 +0000
@@ -54,6 +54,8 @@
 	blowfish.obj \
 	buffer.obj \
 	charset.obj \
+	crypt.obj \
+	crypt_zip.obj \
 	diff.obj \
 	digraph.obj \
 	edit.obj \
diff -Naur vim74.orig/src/Make_bc5.mak vim74/src/Make_bc5.mak
--- vim74.orig/src/Make_bc5.mak	2013-06-03 18:09:58.000000000 +0000
+++ vim74/src/Make_bc5.mak	2014-10-10 14:53:43.982048127 +0000
@@ -419,7 +419,7 @@
 ALIGNARG = -a$(ALIGN)
 #
 !if ("$(DEBUG)"=="yes")
-DEFINES=$(DEFINES) -DDEBUG
+DEFINES=$(DEFINES) -DDEBUG -D_DEBUG
 !endif
 #
 !if ("$(OLE)"=="yes")
@@ -580,6 +580,8 @@
 	$(OBJDIR)\blowfish.obj \
 	$(OBJDIR)\buffer.obj \
 	$(OBJDIR)\charset.obj \
+	$(OBJDIR)\crypt.obj \
+	$(OBJDIR)\crypt_zip.obj \
 	$(OBJDIR)\diff.obj \
 	$(OBJDIR)\digraph.obj \
 	$(OBJDIR)\edit.obj \
diff -Naur vim74.orig/src/Make_cyg.mak vim74/src/Make_cyg.mak
--- vim74.orig/src/Make_cyg.mak	2013-07-06 11:32:11.000000000 +0000
+++ vim74/src/Make_cyg.mak	2014-10-10 14:53:43.985381452 +0000
@@ -1,6 +1,7 @@
 #
 # Makefile for VIM on Win32, using Cygnus gcc
-# Last updated by Dan Sharp.  Last Change: 2013 Apr 22
+# Updated by Dan Sharp.
+# Last Change: 2014 Aug 10
 #
 # Also read INSTALLpc.txt!
 #
@@ -8,6 +9,7 @@
 # Cygwin application use the Makefile (just like on Unix).
 #
 # GUI		no or yes: set to yes if you want the GUI version (yes)
+# DIRECTX	no or yes: set to yes if you want use DirectWrite (no)
 # PERL		define to path to Perl dir to get Perl support (not defined)
 #   PERL_VER	  define to version of Perl being used (56)
 #   DYNAMIC_PERL  no or yes: set to yes to load the Perl DLL dynamically (yes)
@@ -88,6 +90,10 @@
 ARCH = i386
 endif
 
+ifndef DIRECTX
+DIRECTX = no
+endif
+
 ifndef WINVER
 WINVER = 0x0500
 endif
@@ -155,7 +161,7 @@
 ifeq (yes, $(DYNAMIC_PERL))
 DEFINES += -DDYNAMIC_PERL -DDYNAMIC_PERL_DLL=\"perl$(PERL_VER).dll\"
 else
-EXTRA_LIBS += $(PERL)/lib/CORE/perl$(PERL_VER).lib
+EXTRA_LIBS += -L$(PERL)/lib/CORE -lperl$(PERL_VER)
 endif
 endif
 
@@ -272,7 +278,7 @@
 DEFINES += -DDYNAMIC_RUBY -DDYNAMIC_RUBY_DLL=\"$(RUBY_INSTALL_NAME).dll\"
 DEFINES += -DDYNAMIC_RUBY_VER=$(RUBY_VER)
 else
-EXTRA_LIBS += $(RUBY)/lib/$(RUBY_INSTALL_NAME).lib
+EXTRA_LIBS += $(RUBY)/lib/$(RUBY_INSTALL_NAME)
 endif
 endif
 
@@ -439,8 +445,6 @@
 ##############################
 ifeq (yes, $(USEDLL))
 DEFINES += -D_MAX_PATH=256 -D__CYGWIN__
-else
-INCLUDES += -mno-cygwin
 endif
 
 ##############################
@@ -472,6 +476,15 @@
 endif
 
 ##############################
+ifeq (yes, $(DIRECTX))
+# Only allow DIRECTX for a GUI build.
+DEFINES += -DFEAT_DIRECTX -DDYNAMIC_DIRECTX
+EXTRA_OBJS += $(OUTDIR)/gui_dwrite.o
+EXTRA_LIBS += -ld2d1 -ldwrite
+USE_STDCPLUS = yes
+endif
+
+##############################
 ifdef XPM
 # Only allow XPM for a GUI build.
 DEFINES += -DFEAT_XPM_W32
@@ -497,11 +510,7 @@
 DEFINES += -DFEAT_OLE
 EXTRA_OBJS += $(OUTDIR)/if_ole.o
 EXTRA_LIBS += -loleaut32
-ifeq (yes, $(STATIC_STDCPLUS))
-EXTRA_LIBS += -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
-else
-EXTRA_LIBS += -lstdc++
-endif
+USE_STDCPLUS = yes
 endif
 
 ##############################
@@ -515,6 +524,15 @@
 DIRSLASH = \\
 endif
 
+##############################
+ifeq (yes, $(USE_STDCPLUS))
+ifeq (yes, $(STATIC_STDCPLUS))
+EXTRA_LIBS += -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
+else
+EXTRA_LIBS += -lstdc++
+endif
+endif
+
 #>>>>> end of choices
 ###########################################################################
 
@@ -529,6 +547,8 @@
 	$(OUTDIR)/blowfish.o \
 	$(OUTDIR)/buffer.o \
 	$(OUTDIR)/charset.o \
+	$(OUTDIR)/crypt.o \
+	$(OUTDIR)/crypt_zip.o \
 	$(OUTDIR)/diff.o \
 	$(OUTDIR)/digraph.o \
 	$(OUTDIR)/edit.o \
@@ -645,6 +665,9 @@
 $(OUTDIR)/gui_w32.o:	gui_w32.c gui_w48.c $(INCL)
 	$(CC) -c $(CFLAGS) gui_w32.c -o $(OUTDIR)/gui_w32.o
 
+$(OUTDIR)/gui_dwrite.o:	gui_dwrite.cpp $(INCL) gui_dwrite.h
+	$(CC) -c $(CFLAGS) gui_dwrite.cpp -o $(OUTDIR)/gui_dwrite.o
+
 $(OUTDIR)/if_cscope.o:	if_cscope.c $(INCL) if_cscope.h
 	$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o
 
diff -Naur vim74.orig/src/Make_dice.mak vim74/src/Make_dice.mak
--- vim74.orig/src/Make_dice.mak	2010-05-18 18:29:00.000000000 +0000
+++ vim74/src/Make_dice.mak	2014-10-10 14:53:43.995381427 +0000
@@ -29,6 +29,8 @@
 	blowfish.c \
 	buffer.c \
 	charset.c \
+	crypt.c \
+	crypt_zip.c \
 	diff.c \
 	digraph.c \
 	edit.c \
@@ -75,6 +77,8 @@
 OBJ =	o/blowfish.o \
 	o/buffer.o \
 	o/charset.o \
+	o/crypt.o \
+	o/crypt_zip.o \
 	o/diff.o \
 	o/digraph.o \
 	o/edit.o \
@@ -143,6 +147,10 @@
 
 o/charset.o:	charset.c  $(SYMS)
 
+o/crypt.o:	crypt.c  $(SYMS)
+
+o/crypt_zip.o:	crypt_zip.c  $(SYMS)
+
 o/diff.o:	diff.c	$(SYMS)
 
 o/digraph.o:	digraph.c  $(SYMS)
diff -Naur vim74.orig/src/Make_djg.mak vim74/src/Make_djg.mak
--- vim74.orig/src/Make_djg.mak	2010-05-18 18:29:18.000000000 +0000
+++ vim74/src/Make_djg.mak	2014-10-10 14:53:44.002048077 +0000
@@ -22,6 +22,8 @@
 	obj/blowfish.o \
 	obj/buffer.o \
 	obj/charset.o \
+	obj/crypt.o \
+	obj/crypt_zip.o \
 	obj/diff.o \
 	obj/digraph.o \
 	obj/edit.o \
diff -Naur vim74.orig/src/Make_ivc.mak vim74/src/Make_ivc.mak
--- vim74.orig/src/Make_ivc.mak	2013-02-26 13:18:19.000000000 +0000
+++ vim74/src/Make_ivc.mak	2014-10-10 14:53:44.012048051 +0000
@@ -213,6 +213,8 @@
 	"$(INTDIR)/blowfish.obj" \
 	"$(INTDIR)/buffer.obj" \
 	"$(INTDIR)/charset.obj" \
+	"$(INTDIR)/crypt.obj" \
+	"$(INTDIR)/crypt_zip.obj" \
 	"$(INTDIR)/diff.obj" \
 	"$(INTDIR)/digraph.obj" \
 	"$(INTDIR)/edit.obj" \
@@ -339,6 +341,14 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\crypt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\crypt_zip.c
+# End Source File
+# Begin Source File
+
 SOURCE=.\diff.c
 # End Source File
 # Begin Source File
diff -Naur vim74.orig/src/Make_manx.mak vim74/src/Make_manx.mak
--- vim74.orig/src/Make_manx.mak	2010-05-18 18:30:54.000000000 +0000
+++ vim74/src/Make_manx.mak	2014-10-10 14:53:44.015381376 +0000
@@ -37,6 +37,8 @@
 SRC =	blowfish.c \
 	buffer.c \
 	charset.c \
+	crypt.c \
+	crypt_zip.c \
 	diff.c \
 	digraph.c \
 	edit.c \
@@ -85,6 +87,8 @@
 OBJ =	obj/blowfish.o \
 	obj/buffer.o \
 	obj/charset.o \
+	obj/crypt.o \
+	obj/crypt_zip.o \
 	obj/diff.o \
 	obj/digraph.o \
 	obj/edit.o \
@@ -131,6 +135,8 @@
 PRO =	proto/blowfish.pro \
 	proto/buffer.pro \
 	proto/charset.pro \
+	proto/crypt.pro \
+	proto/crypt_zip.pro \
 	proto/diff.pro \
 	proto/digraph.pro \
 	proto/edit.pro \
@@ -227,6 +233,12 @@
 obj/charset.o:	charset.c
 	$(CCSYM) $@ charset.c
 
+obj/crypt.o:	crypt.c
+	$(CCSYM) $@ crypt.c
+
+obj/crypt_zip.o: crypt_zip.c
+	$(CCSYM) $@ crypt_zip.c
+
 obj/diff.o:	diff.c
 	$(CCSYM) $@ diff.c
 
diff -Naur vim74.orig/src/Make_ming.mak vim74/src/Make_ming.mak
--- vim74.orig/src/Make_ming.mak	2013-07-06 11:32:11.000000000 +0000
+++ vim74/src/Make_ming.mak	2014-10-10 14:53:44.028714676 +0000
@@ -31,6 +31,8 @@
 OPTIMIZE=MAXSPEED
 # set to yes to make gvim, no for vim
 GUI=yes
+# set to yes if you want to use DirectWrite (DirectX)
+DIRECTX=no
 # FEATURES=[TINY | SMALL  | NORMAL | BIG | HUGE]
 # Set to TINY to make minimal version (few features).
 FEATURES=BIG
@@ -359,6 +361,7 @@
 
 CFLAGS = -Iproto $(DEFINES) -pipe -w -march=$(ARCH) -Wall
 WINDRES_FLAGS = --preprocessor="$(WINDRES_CC) -E -xc" -DRC_INVOKED
+EXTRA_LIBS =
 
 ifdef GETTEXT
 DEFINES += -DHAVE_GETTEXT -DHAVE_LOCALE_H
@@ -377,9 +380,10 @@
 endif
 
 ifdef PERL
-CFLAGS += -I$(PERLLIBS) -DFEAT_PERL -L$(PERLLIBS)
+CFLAGS += -I$(PERLLIBS) -DFEAT_PERL
 ifeq (yes, $(DYNAMIC_PERL))
 CFLAGS += -DDYNAMIC_PERL -DDYNAMIC_PERL_DLL=\"perl$(PERL_VER).dll\"
+EXTRA_LIBS += -L$(PERLLIBS) -lperl$(PERL_VER)
 endif
 endif
 
@@ -454,6 +458,14 @@
 endif
 endif
 
+# DirectWrite (DirectX)
+ifeq ($(DIRECTX),yes)
+# Only allow DirectWrite for a GUI build.
+ifeq (yes, $(GUI))
+DEFINES += -DFEAT_DIRECTX -DDYNAMIC_DIRECTX
+endif
+endif
+
 # Only allow XPM for a GUI build.
 ifeq (yes, $(GUI))
 
@@ -505,6 +517,8 @@
 	$(OUTDIR)/blowfish.o \
 	$(OUTDIR)/buffer.o \
 	$(OUTDIR)/charset.o \
+	$(OUTDIR)/crypt.o \
+	$(OUTDIR)/crypt_zip.o \
 	$(OUTDIR)/diff.o \
 	$(OUTDIR)/digraph.o \
 	$(OUTDIR)/edit.o \
@@ -591,12 +605,20 @@
 LIB += -lwsock32
 endif
 endif
+ifeq ($(DIRECTX),yes)
+# Only allow DIRECTX for a GUI build.
+ifeq (yes, $(GUI))
+OBJ += $(OUTDIR)/gui_dwrite.o
+LIB += -ld2d1 -ldwrite
+USE_STDCPLUS = yes
+endif
+endif
 ifdef XPM
 # Only allow XPM for a GUI build.
 ifeq (yes, $(GUI))
 OBJ += $(OUTDIR)/xpm_w32.o
 # You'll need libXpm.a from http://gnuwin32.sf.net
-LIB += -L $(XPM)/lib -lXpm
+LIB += -L$(XPM)/lib -lXpm
 endif
 endif
 
@@ -632,7 +654,7 @@
 
 ifdef PERL
 ifeq (no, $(DYNAMIC_PERL))
-LIB += -lperl$(PERL_VER)
+LIB += -L$(PERLLIBS) -lperl$(PERL_VER)
 endif
 endif
 
@@ -648,11 +670,7 @@
 ifeq (yes, $(OLE))
 LIB += -loleaut32
 OBJ += $(OUTDIR)/if_ole.o
-ifeq (yes, $(STATIC_STDCPLUS))
-LIB += -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
-else
-LIB += -lstdc++
-endif
+USE_STDCPLUS = yes
 endif
 
 ifeq (yes, $(MBYTE))
@@ -676,6 +694,14 @@
 DEFINES+=-DDYNAMIC_ICONV
 endif
 
+ifeq (yes, $(USE_STDCPLUS))
+ifeq (yes, $(STATIC_STDCPLUS))
+LIB += -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
+else
+LIB += -lstdc++
+endif
+endif
+
 all: $(TARGET) vimrun.exe xxd/xxd.exe install.exe uninstal.exe GvimExt/gvimext.dll
 
 vimrun.exe: vimrun.c
@@ -749,6 +775,9 @@
 $(OUTDIR)/gui_w32.o:	gui_w32.c gui_w48.c $(INCL)
 	$(CC) -c $(CFLAGS) gui_w32.c -o $(OUTDIR)/gui_w32.o
 
+$(OUTDIR)/gui_dwrite.o:	gui_dwrite.cpp $(INCL) gui_dwrite.h
+	$(CC) -c $(CFLAGS) gui_dwrite.cpp -o $(OUTDIR)/gui_dwrite.o
+
 $(OUTDIR)/if_cscope.o:	if_cscope.c $(INCL) if_cscope.h
 	$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o
 
diff -Naur vim74.orig/src/Make_morph.mak vim74/src/Make_morph.mak
--- vim74.orig/src/Make_morph.mak	2010-05-18 18:31:26.000000000 +0000
+++ vim74/src/Make_morph.mak	2014-10-10 14:53:44.032048001 +0000
@@ -27,6 +27,8 @@
 SRC =	blowfish.c						\
 	buffer.c						\
 	charset.c						\
+	crypt.c							\
+	crypt_zip.c						\
 	diff.c							\
 	digraph.c						\
 	edit.c							\
diff -Naur vim74.orig/src/Make_mvc.mak vim74/src/Make_mvc.mak
--- vim74.orig/src/Make_mvc.mak	2013-07-09 11:13:12.000000000 +0000
+++ vim74/src/Make_mvc.mak	2014-10-10 14:53:44.045381301 +0000
@@ -24,6 +24,9 @@
 #
 #	GUI interface: GUI=yes (default is no)
 #
+#	GUI with DirectWrite(DirectX): DIRECTX=yes
+#	  (default is no, requires GUI=yes)
+#
 #	OLE interface: OLE=yes (usually with GUI=yes)
 #
 #	Multibyte support: MBYTE=yes (default is no)
@@ -168,6 +171,9 @@
 !else
 OBJDIR = .\ObjC
 !endif
+!if "$(DIRECTX)" == "yes"
+OBJDIR = $(OBJDIR)X
+!endif
 !if "$(OLE)" == "yes"
 OBJDIR = $(OBJDIR)O
 !endif
@@ -292,6 +298,13 @@
 NETBEANS_LIB	= WSock32.lib
 !endif
 
+# DirectWrite(DirectX)
+!if "$(DIRECTX)" == "yes"
+DIRECTX_DEFS	= -DFEAT_DIRECTX -DDYNAMIC_DIRECTX
+DIRECTX_INCL	= gui_dwrite.h
+DIRECTX_OBJ	= $(OUTDIR)\gui_dwrite.obj
+!endif
+
 !ifndef XPM
 # XPM is not set, use the included xpm files, depending on the architecture.
 !if "$(CPU)" == "AMD64"
@@ -424,6 +437,12 @@
 !if "$(_NMAKE_VER)" == "11.00.60610.1"
 MSVCVER = 11.0
 !endif
+!if "$(_NMAKE_VER)" == "11.00.61030.0"
+MSVCVER = 11.0
+!endif
+!if "$(_NMAKE_VER)" == "12.00.21005.1"
+MSVCVER = 12.0
+!endif
 !endif
 
 # Abort building VIM if version of VC is unrecognised.
@@ -438,7 +457,7 @@
 !endif
 
 # Convert processor ID to MVC-compatible number
-!if ("$(MSVCVER)" != "8.0") && ("$(MSVCVER)" != "9.0") && ("$(MSVCVER)" != "10.0") && ("$(MSVCVER)" != "11.0")
+!if ("$(MSVCVER)" != "8.0") && ("$(MSVCVER)" != "9.0") && ("$(MSVCVER)" != "10.0") && ("$(MSVCVER)" != "11.0") && ("$(MSVCVER)" != "12.0")
 !if "$(CPUNR)" == "i386"
 CPUARG = /G3
 !elseif "$(CPUNR)" == "i486"
@@ -472,7 +491,7 @@
 OPTFLAG = /Ox
 !endif
 
-!if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0") || ("$(MSVCVER)" == "10.0") || ("$(MSVCVER)" == "11.0")
+!if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0") || ("$(MSVCVER)" == "10.0") || ("$(MSVCVER)" == "11.0") || ("$(MSVCVER)" == "12.0")
 # Use link time code generation if not worried about size
 !if "$(OPTIMIZE)" != "SPACE"
 OPTFLAG = $(OPTFLAG) /GL
@@ -485,7 +504,7 @@
 !endif
 
 # Static code analysis generally available starting with VS2012
-!if ("$(ANALYZE)" == "yes") && ("$(MSVCVER)" == "11.0")
+!if ("$(ANALYZE)" == "yes") && (("$(MSVCVER)" == "10.0") || ("$(MSVCVER)" == "11.0") || ("$(MSVCVER)" == "12.0"))
 CFLAGS=$(CFLAGS) /analyze
 !endif
 
@@ -528,6 +547,8 @@
 	$(OUTDIR)\blowfish.obj \
 	$(OUTDIR)\buffer.obj \
 	$(OUTDIR)\charset.obj \
+	$(OUTDIR)\crypt.obj \
+	$(OUTDIR)\crypt_zip.obj \
 	$(OUTDIR)\diff.obj \
 	$(OUTDIR)\digraph.obj \
 	$(OUTDIR)\edit.obj \
@@ -636,6 +657,16 @@
 SUBSYSTEM = console
 !endif
 
+!if "$(SUBSYSTEM_VER)" != ""
+SUBSYSTEM = $(SUBSYSTEM),$(SUBSYSTEM_VER)
+!endif
+
+!if "$(GUI)" == "yes" && "$(DIRECTX)" == "yes"
+CFLAGS = $(CFLAGS) $(DIRECTX_DEFS)
+GUI_INCL = $(GUI_INCL) $(DIRECTX_INCL)
+GUI_OBJ = $(GUI_OBJ) $(DIRECTX_OBJ)
+!endif
+
 # iconv.dll library (dynamically loaded)
 !ifndef ICONV
 ICONV = yes
@@ -822,7 +853,12 @@
 PERL_LIB = $(PERL_INCDIR)\perl.lib
 !else
 PERL_DLL = perl$(PERL_VER).dll
+!if exist($(PERL_INCDIR)\perl$(PERL_VER).lib)
 PERL_LIB = $(PERL_INCDIR)\perl$(PERL_VER).lib
+!else
+# For ActivePerl 5.18 and later
+PERL_LIB = $(PERL_INCDIR)\libperl$(PERL_VER).a
+!endif
 !endif
 
 CFLAGS = $(CFLAGS) -DFEAT_PERL
@@ -943,7 +979,7 @@
 
 # Report link time code generation progress if used. 
 !ifdef NODEBUG
-!if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0") || ("$(MSVCVER)" == "10.0") || ("$(MSVCVER)" == "11.0")
+!if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0") || ("$(MSVCVER)" == "10.0") || ("$(MSVCVER)" == "11.0") || ("$(MSVCVER)" == "12.0")
 !if "$(OPTIMIZE)" != "SPACE"
 LINKARGS1 = $(LINKARGS1) /LTCG:STATUS
 !endif
@@ -962,6 +998,7 @@
 		$(LUA_OBJ) $(MZSCHEME_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(PYTHON3_OBJ) $(RUBY_OBJ) \
 		$(TCL_OBJ) $(SNIFF_OBJ) $(CSCOPE_OBJ) $(NETBEANS_OBJ) \
 		$(XPM_OBJ) $(OUTDIR)\version.obj $(LINKARGS2)
+	if exist $(VIM).exe.manifest mt.exe -nologo -manifest $(VIM).exe.manifest -updateresource:$(VIM).exe;1
 
 $(VIM): $(VIM).exe
 
@@ -1061,6 +1098,10 @@
 
 $(OUTDIR)/charset.obj:	$(OUTDIR) charset.c  $(INCL)
 
+$(OUTDIR)/crypt.obj:	$(OUTDIR) crypt.c  $(INCL)
+
+$(OUTDIR)/crypt_zip.obj: $(OUTDIR) crypt_zip.c  $(INCL)
+
 $(OUTDIR)/diff.obj:	$(OUTDIR) diff.c  $(INCL)
 
 $(OUTDIR)/digraph.obj:	$(OUTDIR) digraph.c  $(INCL)
@@ -1095,6 +1136,8 @@
 
 $(OUTDIR)/gui_w32.obj:	$(OUTDIR) gui_w32.c gui_w48.c $(INCL) $(GUI_INCL)
 
+$(OUTDIR)/gui_dwrite.obj:	$(OUTDIR) gui_dwrite.cpp $(INCL) $(GUI_INCL)
+
 $(OUTDIR)/if_cscope.obj: $(OUTDIR) if_cscope.c  $(INCL)
 
 $(OUTDIR)/if_lua.obj: $(OUTDIR) if_lua.c  $(INCL)
@@ -1245,6 +1288,8 @@
 	proto/blowfish.pro \
 	proto/buffer.pro \
 	proto/charset.pro \
+	proto/crypt.pro \
+	proto/crypt_zip.pro \
 	proto/diff.pro \
 	proto/digraph.pro \
 	proto/edit.pro \
diff -Naur vim74.orig/src/Make_os2.mak vim74/src/Make_os2.mak
--- vim74.orig/src/Make_os2.mak	2010-05-18 18:32:32.000000000 +0000
+++ vim74/src/Make_os2.mak	2014-10-10 14:53:44.048714626 +0000
@@ -42,6 +42,8 @@
 	blowfish.o \
 	buffer.o \
 	charset.o \
+	crypt.o \
+	crypt_zip.o \
 	diff.o \
 	digraph.o \
 	edit.o \
@@ -117,6 +119,8 @@
 blowfish.o:	blowfish.c  $(INCL)
 buffer.o:	buffer.c  $(INCL)
 charset.o:	charset.c  $(INCL)
+crypt.o:	crypt.c  $(INCL)
+crypt_zip.o:	crypt_zip.c  $(INCL)
 diff.o:		diff.c  $(INCL)
 digraph.o:	digraph.c  $(INCL)
 edit.o:		edit.c  $(INCL)
diff -Naur vim74.orig/src/Make_sas.mak vim74/src/Make_sas.mak
--- vim74.orig/src/Make_sas.mak	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/Make_sas.mak	2014-10-10 14:53:44.048714626 +0000
@@ -92,6 +92,8 @@
 	blowfish.c \
 	buffer.c \
 	charset.c \
+	crypt.c \
+	crypt_zip.c \
 	diff.c \
 	digraph.c \
 	edit.c \
@@ -139,6 +141,8 @@
 	blowfish.o \
 	buffer.o \
 	charset.o \
+	crypt.o \
+	crypt_zip.o \
 	diff.o \
 	digraph.o \
 	edit.o \
@@ -186,6 +190,8 @@
 	proto/blowfish.pro \
 	proto/buffer.pro \
 	proto/charset.pro \
+	proto/crypt.pro \
+	proto/crypt_zip.pro \
 	proto/diff.pro \
 	proto/digraph.pro \
 	proto/edit.pro \
@@ -290,6 +296,10 @@
 proto/buffer.pro:	buffer.c
 charset.o:		charset.c
 proto/charset.pro:	charset.c
+crypt.o:		crypt.c
+proto/crypt.pro:	crypt.c
+crypt_zip.o:		crypt_zip.c
+proto/crypt_zip.pro:	crypt_zip.c
 diff.o:			diff.c
 proto/diff.pro:		diff.c
 digraph.o:		digraph.c
diff -Naur vim74.orig/src/Make_vms.mms vim74/src/Make_vms.mms
--- vim74.orig/src/Make_vms.mms	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/Make_vms.mms	2014-10-10 14:53:44.055381276 +0000
@@ -2,7 +2,7 @@
 # Makefile for Vim on OpenVMS
 #
 # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
-# Last change:  2008 Aug 16
+# Last change:  2014 Feb 24
 #
 # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
 # with MMS and MMK
@@ -21,9 +21,6 @@
 ######################################################################
 # Configuration section.
 ######################################################################
-# VMS version
-# Uncomment if you use VMS version 6.2 or older
-# OLD_VMS = YES
 
 # Compiler selection.
 # Comment out if you use the VAXC compiler
@@ -60,7 +57,7 @@
 
 # Uncomment if want a debug version. Resulting executable is DVIM.EXE
 # Development purpose only! Normally, it should not be defined. !!!
-# DEBUG = YES
+# DEBUG = YES 
 
 # Languages support for Perl, Python, TCL etc.
 # If you don't need it really, leave them behind the comment.
@@ -87,6 +84,9 @@
 # Allow FEATURE_MZSCHEME
 # VIM_MZSCHEME = YES
 
+# Use ICONV
+# VIM_ICONV  = YES
+
 ######################################################################
 # Directory, library and include files configuration section.
 # Normally you need not to change anything below. !
@@ -99,25 +99,25 @@
 
 .IFDEF MMSVAX
 .IFDEF DECC	     # VAX with DECC
-CC_DEF  = cc # /decc # some system requires this switch but when it is not required /ver might fail
+CC_DEF  = cc # /decc # some versions require /decc switch but when it is not required /ver might fail
 PREFIX  = /prefix=all
+OPTIMIZE= /noopt     # do not optimize on VAX. The compiler has hard time with crypto functions
 .ELSE		     # VAX with VAXC
 CC_DEF	= cc
 PREFIX	=
+OPTIMIZE= /noopt
 CCVER	=
 .ENDIF
-.ELSE		     # AXP wixh DECC
+.ELSE		     # AXP and IA64 with DECC
 CC_DEF  = cc
 PREFIX  = /prefix=all
+OPTIMIZE= /opt
 .ENDIF
 
+
 LD_DEF  = link
 C_INC   = [.proto]
 
-.IFDEF OLD_VMS
-VMS_DEF = ,"OLD_VMS"
-.ENDIF
-
 .IFDEF DEBUG
 DEBUG_DEF = ,"DEBUG"
 TARGET    = dvim.exe
@@ -125,7 +125,7 @@
 LDFLAGS   = /debug
 .ELSE
 TARGET    = vim.exe
-CFLAGS    = /opt$(PREFIX)
+CFLAGS    = $(OPTIMIZE)$(PREFIX)
 LDFLAGS   =
 .ENDIF
 
@@ -274,6 +274,11 @@
 MZSCH_OBJ = if_mzsch.obj
 .ENDIF
 
+.IFDEF VIM_ICONV
+# ICONV related setup
+ICONV_DEF = ,"USE_ICONV"
+.ENDIF
+
 ######################################################################
 # End of configuration section.
 # Please, do not change anything below without programming experience.
@@ -287,8 +292,8 @@
 
 .SUFFIXES : .obj .c
 
-ALL_CFLAGS = /def=($(MODEL_DEF)$(DEFS)$(VMS_DEF)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
- $(TCL_DEF)$(SNIFF_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)) -
+ALL_CFLAGS = /def=($(MODEL_DEF)$(DEFS)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
+ $(TCL_DEF)$(SNIFF_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)$(ICONV_DEF)) -
  $(CFLAGS)$(GUI_FLAG) -
  /include=($(C_INC)$(GUI_INC_DIR)$(GUI_INC)$(PERL_INC)$(PYTHON_INC)$(TCL_INC))
 
@@ -296,8 +301,8 @@
 # It is specially formated for correct display of unix like includes
 # as $(GUI_INC) - replaced with $(GUI_INC_VER)
 # Otherwise should not be any other difference.
-ALL_CFLAGS_VER = /def=($(MODEL_DEF)$(DEFS)$(VMS_DEF)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
- $(TCL_DEF)$(SNIFF_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)) -
+ALL_CFLAGS_VER = /def=($(MODEL_DEF)$(DEFS)$(DEBUG_DEF)$(PERL_DEF)$(PYTHON_DEF) -
+ $(TCL_DEF)$(SNIFF_DEF)$(RUBY_DEF)$(XIM_DEF)$(HANGULIN_DEF)$(TAG_DEF)$(MZSCH_DEF)$(ICONV_DEF)) -
  $(CFLAGS)$(GUI_FLAG) -
  /include=($(C_INC)$(GUI_INC_DIR)$(GUI_INC_VER)$(PERL_INC)$(PYTHON_INC)$(TCL_INC))
 
diff -Naur vim74.orig/src/Makefile vim74/src/Makefile
--- vim74.orig/src/Makefile	2013-08-10 12:21:15.000000000 +0000
+++ vim74/src/Makefile	2014-10-10 14:53:44.085381200 +0000
@@ -546,6 +546,7 @@
 # again.
 #CC = cc
 #CC = gcc
+#CC = clang
 
 # COMPILER FLAGS - change as you please. Either before running {{{1
 # configure or afterwards. For examples see below.
@@ -585,6 +586,9 @@
 # as root: sysctl -w vm.max_proc_mmap=30000
 #EXTRA_LIBS = /usr/local/lib/libefence.a
 
+# Autoconf binary.
+AUTOCONF = autoconf
+
 # PURIFY - remove the # to use the "purify" program (hoi Nia++!)
 #PURIFY = purify
 
@@ -1427,6 +1431,8 @@
 	blowfish.c \
 	buffer.c \
 	charset.c \
+	crypt.c \
+	crypt_zip.c \
 	diff.c \
 	digraph.c \
 	edit.c \
@@ -1516,6 +1522,8 @@
 	objects/buffer.o \
 	objects/blowfish.o \
 	objects/charset.o \
+	objects/crypt.o \
+	objects/crypt_zip.o \
 	objects/diff.o \
 	objects/digraph.o \
 	objects/edit.o \
@@ -1585,6 +1593,8 @@
 	blowfish.pro \
 	buffer.pro \
 	charset.pro \
+	crypt.pro \
+	crypt_zip.pro \
 	diff.pro \
 	digraph.pro \
 	edit.pro \
@@ -1660,13 +1670,16 @@
 # auto/config.h isn't updated.  The dependency on auto/config.mk should make
 # sure configure is run when it's needed.
 #
+# Remove the config.cache every time, once in a while it causes problems that
+# are very hard to figure out.
+#
 config auto/config.mk: auto/configure config.mk.in config.h.in
-	if test -f auto/config.cache && \
-	    grep '^ac_cv_env_CFLAGS_value=' auto/config.cache > /dev/null && \
-	    ! grep -x -F 'ac_cv_env_CFLAGS_value=$(CFLAGS)' auto/config.cache > /dev/null; then \
-		rm auto/config.cache; \
-	fi
-	GUI_INC_LOC="$(GUI_INC_LOC)" GUI_LIB_LOC="$(GUI_LIB_LOC)" \
+	-rm -f auto/config.cache
+	if test "X$(MAKECMDGOALS)" != "Xclean" \
+		-a "X$(MAKECMDGOALS)" != "Xdistclean" \
+		-a "X$(MAKECMDGOALS)" != "Xautoconf" \
+		-a "X$(MAKECMDGOALS)" != "Xreconfig"; then \
+	    GUI_INC_LOC="$(GUI_INC_LOC)" GUI_LIB_LOC="$(GUI_LIB_LOC)" \
 		CC="$(CC)" CPPFLAGS="$(CPPFLAGS)" CFLAGS="$(CFLAGS)" \
 		LDFLAGS="$(LDFLAGS)" $(CONF_SHELL) srcdir="$(srcdir)" \
 		./configure $(CONF_OPT_GUI) $(CONF_OPT_X) $(CONF_OPT_XSMP) \
@@ -1679,7 +1692,8 @@
 		$(CONF_OPT_COMPBY) $(CONF_OPT_ACL)  $(CONF_OPT_NETBEANS) \
 		$(CONF_ARGS) $(CONF_OPT_MZSCHEME) $(CONF_OPT_PLTHOME) \
 		$(CONF_OPT_LUA) $(CONF_OPT_LUA_PREFIX) \
-		$(CONF_OPT_SYSMOUSE)
+		$(CONF_OPT_SYSMOUSE); \
+	fi
 
 # Use "make reconfig" to rerun configure without cached values.
 # When config.h changes, most things will be recompiled automatically.
@@ -1710,7 +1724,7 @@
 # - Uses ">config.log" instead of "./config.log".
 autoconf:
 	if test ! -f configure.save; then mv configure configure.save; fi
-	autoconf
+	$(AUTOCONF)
 	sed -e 's+>config.log+>auto/config.log+' -e 's+\./config.log+auto/config.log+' configure > auto/configure
 	chmod 755 auto/configure
 	mv -f configure.save configure
@@ -1745,10 +1759,11 @@
 languages:
 	@if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
 		cd $(PODIR); \
-		CC="$(CC)" $(MAKE) prefix=$(DESTDIR)$(prefix); \
+		  CC="$(CC)" $(MAKE) prefix=$(DESTDIR)$(prefix); \
 	fi
 	-@if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
-		cd $(PODIR); CC="$(CC)" $(MAKE) prefix=$(DESTDIR)$(prefix) converted; \
+		cd $(PODIR); \
+		  CC="$(CC)" $(MAKE) prefix=$(DESTDIR)$(prefix) converted; \
 	fi
 
 # Update the *.po files for changes in the sources.  Only run manually.
@@ -1861,7 +1876,7 @@
 	-if test $(VIMTARGET) != vim -a ! -r vim; then \
 		ln -s $(VIMTARGET) vim; \
 	fi
-	cd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) $(GUI_TESTARG)
+	cd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
 	$(MAKE) -f Makefile unittest
 
 unittesttargets:
@@ -1874,6 +1889,15 @@
 
 # Run individual test, assuming that Vim was already compiled.
 test1 test2 test3 test4 test5 test6 test7 test8 test9 \
+	test_autoformat_join \
+	test_breakindent \
+	test_changelist \
+	test_eval \
+	test_insertcount \
+	test_listlbr \
+	test_listlbr_utf8 \
+	test_options \
+	test_qf_title \
 	test10 test11 test12 test13 test14 test15 test16 test17 test18 test19 \
 	test20 test21 test22 test23 test24 test25 test26 test27 test28 test29 \
 	test30 test31 test32 test33 test34 test35 test36 test37 test38 test39 \
@@ -1882,8 +1906,9 @@
 	test60 test61 test62 test63 test64 test65 test66 test67 test68 test69 \
 	test70 test71 test72 test73 test74 test75 test76 test77 test78 test79 \
 	test80 test81 test82 test83 test84 test85 test86 test87 test88 test89 \
-	test90 test91 test92 test93 test94 test95 test96 test97 test98 test99:
-	cd testdir; rm $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET)
+	test90 test91 test92 test93 test94 test95 test96 test97 test98 test99 \
+	test100 test101 test102 test103 test104 test105 test106 test107:
+	cd testdir; rm $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
 
 testclean:
 	cd testdir; $(MAKE) -f Makefile clean
@@ -2380,6 +2405,7 @@
 				 ../../testdir/*.in \
 				 ../../testdir/*.vim \
 				 ../../testdir/python* \
+				 ../../testdir/sautest \
 				 ../../testdir/test83-tags? \
 				 ../../testdir/*.ok .
 
@@ -2451,7 +2477,7 @@
 
 auto/if_perl.c: if_perl.xs
 	$(PERL) -e 'unless ( $$] >= 5.005 ) { for (qw(na defgv errgv)) { print "#define PL_$$_ $$_\n" }}' > $@
-	$(PERL) $(PERLLIB)/ExtUtils/xsubpp -prototypes -typemap \
+	$(PERL) $(PERL_XSUBPP) -prototypes -typemap \
 	    $(PERLLIB)/ExtUtils/typemap if_perl.xs >> $@
 
 auto/osdef.h: auto/config.h osdef.sh osdef1.h.in osdef2.h.in
@@ -2493,6 +2519,12 @@
 objects/charset.o: charset.c
 	$(CCC) -o $@ charset.c
 
+objects/crypt.o: crypt.c
+	$(CCC) -o $@ crypt.c
+
+objects/crypt_zip.o: crypt_zip.c
+	$(CCC) -o $@ crypt_zip.c
+
 objects/diff.o: diff.c
 	$(CCC) -o $@ diff.c
 
@@ -2842,6 +2874,14 @@
  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
  gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h globals.h farsi.h \
  arabic.h
+objects/crypt.o: crypt.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+ ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+ gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h globals.h farsi.h \
+ arabic.h
+objects/crypt_zip.o: crypt_zip.c vim.h auto/config.h feature.h os_unix.h \
+ auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
+ regexp.h gui.h gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h \
+ globals.h farsi.h arabic.h
 objects/diff.o: diff.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
  gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h globals.h farsi.h \
diff -Naur vim74.orig/src/auto/config.mk vim74/src/auto/config.mk
--- vim74.orig/src/auto/config.mk	2013-08-10 12:28:27.000000000 +0000
+++ vim74/src/auto/config.mk	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-the first targets to make vim are: scratch config myself
-srcdir = .
-VIMNAME = vim
-EXNAME = ex
-VIEWNAME = view
diff -Naur vim74.orig/src/auto/configure vim74/src/auto/configure
--- vim74.orig/src/auto/configure	2013-08-04 18:01:06.000000000 +0000
+++ vim74/src/auto/configure	2014-10-10 14:53:44.182047624 +0000
@@ -1,11 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.65.
+# Generated by GNU Autoconf 2.69.
 #
 #
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation,
-# Inc.
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -89,6 +87,7 @@
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -133,6 +132,31 @@
 # CDPATH.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
 if test "x$CONFIG_SHELL" = x; then
   as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
@@ -166,7 +190,8 @@
 else
   exitcode=1; echo positional parameters were not saved.
 fi
-test x\$exitcode = x0 || exit 1"
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
   as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
@@ -211,14 +236,25 @@
 
 
       if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
 fi
 
     if test x$as_have_required = xno; then :
@@ -316,10 +352,18 @@
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
@@ -356,19 +400,19 @@
 fi # as_fn_arith
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
+# script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $1" >&2
+  $as_echo "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -441,6 +485,10 @@
   chmod +x "$as_me.lineno" ||
     { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
   # original and so on.  Autoconf is especially sensitive to this).
@@ -475,16 +523,16 @@
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -496,28 +544,8 @@
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -530,7 +558,7 @@
 exec 6>&1
 
 # Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
 # so uname gets run too.
 ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
 
@@ -659,6 +687,7 @@
 PERL_OBJ
 PERL_SRC
 shrpenv
+vi_cv_perl_xsubpp
 vi_cv_perllib
 vi_cv_path_perl
 MZSCHEME_MZC
@@ -691,6 +720,7 @@
 CPP_MM
 STRIP
 AWK
+FGREP
 EGREP
 GREP
 CPP
@@ -753,6 +783,7 @@
 with_view_name
 with_global_runtime
 with_modified_by
+enable_smack
 enable_selinux
 with_features
 with_compiledby
@@ -872,8 +903,9 @@
   fi
 
   case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
   esac
 
   # Accept the important Cygnus configure options, so we can diagnose typos.
@@ -918,7 +950,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -944,7 +976,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1148,7 +1180,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1164,7 +1196,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1194,8 +1226,8 @@
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) as_fn_error "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information."
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
     ;;
 
   *=*)
@@ -1203,7 +1235,7 @@
     # Reject names that are not valid shell variable names.
     case $ac_envvar in #(
       '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
     esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
@@ -1213,7 +1245,7 @@
     $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
       $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
     ;;
 
   esac
@@ -1221,13 +1253,13 @@
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error "missing argument to $ac_option"
+  as_fn_error $? "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
@@ -1250,7 +1282,7 @@
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1264,8 +1296,6 @@
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1280,9 +1310,9 @@
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error "working directory cannot be determined"
+  as_fn_error $? "working directory cannot be determined"
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error "pwd does not report name of working directory"
+  as_fn_error $? "pwd does not report name of working directory"
 
 
 # Find the source files, if location was not specified.
@@ -1321,11 +1351,11 @@
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
 	pwd)`
 # When building in place, set srcdir=.
 if test "$ac_abs_confdir" = "$ac_pwd"; then
@@ -1365,7 +1395,7 @@
       --help=short        display options specific to this package
       --help=recursive    display the short help of all the included packages
   -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
+  -q, --quiet, --silent   do not print \`checking ...' messages
       --cache-file=FILE   cache test results in FILE [disabled]
   -C, --config-cache      alias for \`--cache-file=config.cache'
   -n, --no-create         do not create output files
@@ -1425,7 +1455,8 @@
   --enable-fail-if-missing    Fail if dependencies on additional features
      specified on the command line are missing.
   --disable-darwin        Disable Darwin (Mac OS X) support.
-  --disable-selinux	  Don't check for SELinux support.
+  --disable-smack	  Do not check for Smack support.
+  --disable-selinux	  Do not check for SELinux support.
   --disable-xsmp          Disable XSMP session management
   --disable-xsmp-interact Disable XSMP interaction
   --enable-luainterp=OPTS     Include Lua interpreter.  default=no OPTS=no/yes/dynamic
@@ -1563,9 +1594,9 @@
 if $ac_init_version; then
   cat <<\_ACEOF
 configure
-generated by GNU Autoconf 2.65
+generated by GNU Autoconf 2.69
 
-Copyright (C) 2009 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1609,7 +1640,7 @@
 
 	ac_retval=1
 fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_compile
@@ -1635,7 +1666,7 @@
     mv -f conftest.er1 conftest.err
   fi
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } >/dev/null && {
+  test $ac_status = 0; } > conftest.i && {
 	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        }; then :
@@ -1646,7 +1677,7 @@
 
     ac_retval=1
 fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_cpp
@@ -1678,7 +1709,7 @@
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
+	 test -x conftest$ac_exeext
        }; then :
   ac_retval=0
 else
@@ -1692,7 +1723,7 @@
   # interfere with the next link command; also delete a directory that is
   # left behind by Apple's compiler.  We do this before executing the actions.
   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_link
@@ -1734,7 +1765,7 @@
        ac_retval=$ac_status
 fi
   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_run
@@ -1747,10 +1778,10 @@
 ac_fn_c_check_header_mongrel ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  if eval \${$3+:} false; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 fi
 eval ac_res=\$$3
@@ -1786,7 +1817,7 @@
 else
   ac_header_preproc=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
 $as_echo "$ac_header_preproc" >&6; }
 
@@ -1813,7 +1844,7 @@
 esac
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=\$ac_header_compiler"
@@ -1822,7 +1853,7 @@
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_header_mongrel
 
@@ -1835,7 +1866,7 @@
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1853,7 +1884,7 @@
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_header_compile
 
@@ -1865,7 +1896,7 @@
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1920,7 +1951,7 @@
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_func
 
@@ -1933,7 +1964,7 @@
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=no"
@@ -1974,7 +2005,7 @@
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_type
 
@@ -1987,7 +2018,7 @@
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for uint$2_t" >&5
 $as_echo_n "checking for uint$2_t... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=no"
@@ -2002,7 +2033,8 @@
 main ()
 {
 static int test_array [1 - 2 * !((($ac_type) -1 >> ($2 / 2 - 1)) >> ($2 / 2 - 1) == 3)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2017,8 +2049,7 @@
 esac
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-       eval as_val=\$$3
-   if test "x$as_val" = x""no; then :
+       if eval test \"x\$"$3"\" = x"no"; then :
 
 else
   break
@@ -2028,7 +2059,7 @@
 eval ac_res=\$$3
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_find_uintX_t
 
@@ -2049,7 +2080,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) >= 0)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2065,7 +2097,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2091,7 +2124,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) < 0)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2107,7 +2141,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) >= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2141,7 +2176,8 @@
 main ()
 {
 static int test_array [1 - 2 * !(($2) <= $ac_mid)];
-test_array [0] = 0
+test_array [0] = 0;
+return test_array [0];
 
   ;
   return 0;
@@ -2205,7 +2241,7 @@
 rm -f conftest.val
 
   fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_compute_int
@@ -2214,7 +2250,7 @@
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.65.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
@@ -2324,11 +2360,9 @@
   {
     echo
 
-    cat <<\_ASBOX
-## ---------------- ##
+    $as_echo "## ---------------- ##
 ## Cache variables. ##
-## ---------------- ##
-_ASBOX
+## ---------------- ##"
     echo
     # The following way of writing the cache mishandles newlines in values,
 (
@@ -2362,11 +2396,9 @@
 )
     echo
 
-    cat <<\_ASBOX
-## ----------------- ##
+    $as_echo "## ----------------- ##
 ## Output variables. ##
-## ----------------- ##
-_ASBOX
+## ----------------- ##"
     echo
     for ac_var in $ac_subst_vars
     do
@@ -2379,11 +2411,9 @@
     echo
 
     if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------------- ##
+      $as_echo "## ------------------- ##
 ## File substitutions. ##
-## ------------------- ##
-_ASBOX
+## ------------------- ##"
       echo
       for ac_var in $ac_subst_files
       do
@@ -2397,11 +2427,9 @@
     fi
 
     if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
+      $as_echo "## ----------- ##
 ## confdefs.h. ##
-## ----------- ##
-_ASBOX
+## ----------- ##"
       echo
       cat confdefs.h
       echo
@@ -2456,7 +2484,12 @@
 ac_site_file1=NONE
 ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  ac_site_file1=$CONFIG_SITE
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
 elif test "x$prefix" != xNONE; then
   ac_site_file1=$prefix/share/config.site
   ac_site_file2=$prefix/etc/config.site
@@ -2471,7 +2504,11 @@
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
 $as_echo "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5; }
   fi
 done
 
@@ -2547,7 +2584,7 @@
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
 fi
 ## -------------------- ##
 ## Main body of script. ##
@@ -2569,7 +2606,7 @@
 $as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
 set x ${MAKE-make}
 ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${ac_cv_prog_make_${ac_make}_set+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat >conftest.make <<\_ACEOF
@@ -2577,7 +2614,7 @@
 all:
 	@echo '@@@%%%=$(MAKE)=@@@%%%'
 _ACEOF
-# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
 case `${MAKE-make} -f conftest.make 2>/dev/null` in
   *@@@%%%=?*=@@@%%%*)
     eval ac_cv_prog_make_${ac_make}_set=yes;;
@@ -2607,7 +2644,7 @@
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2619,7 +2656,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2647,7 +2684,7 @@
 set dummy gcc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -2659,7 +2696,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2700,7 +2737,7 @@
 set dummy ${ac_tool_prefix}cc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2712,7 +2749,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2740,7 +2777,7 @@
 set dummy cc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2753,7 +2790,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
@@ -2799,7 +2836,7 @@
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
+if ${ac_cv_prog_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2811,7 +2848,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2843,7 +2880,7 @@
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -2855,7 +2892,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -2897,8 +2934,8 @@
 
 test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "no acceptable C compiler found in \$PATH
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5; }
 
 # Provide some information about the compiler.
 $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
@@ -3012,9 +3049,8 @@
 
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "C compiler cannot create executables
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "C compiler cannot create executables
+See \`config.log' for more details" "$LINENO" 5; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
@@ -3056,8 +3092,8 @@
 else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest conftest$ac_cv_exeext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
@@ -3114,9 +3150,9 @@
     else
 	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run C compiled programs.
+as_fn_error $? "cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5; }
     fi
   fi
 fi
@@ -3127,7 +3163,7 @@
 ac_clean_files=$ac_clean_files_save
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
 $as_echo_n "checking for suffix of object files... " >&6; }
-if test "${ac_cv_objext+set}" = set; then :
+if ${ac_cv_objext+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3167,8 +3203,8 @@
 
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
@@ -3178,7 +3214,7 @@
 ac_objext=$OBJEXT
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
 $as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if test "${ac_cv_c_compiler_gnu+set}" = set; then :
+if ${ac_cv_c_compiler_gnu+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3215,7 +3251,7 @@
 ac_save_CFLAGS=$CFLAGS
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
 $as_echo_n "checking whether $CC accepts -g... " >&6; }
-if test "${ac_cv_prog_cc_g+set}" = set; then :
+if ${ac_cv_prog_cc_g+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_save_c_werror_flag=$ac_c_werror_flag
@@ -3293,7 +3329,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
 $as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then :
+if ${ac_cv_prog_cc_c89+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_prog_cc_c89=no
@@ -3302,8 +3338,7 @@
 /* end confdefs.h.  */
 #include <stdarg.h>
 #include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
+struct stat;
 /* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
 struct buf { int x; };
 FILE * (*rcsopen) (struct buf *, struct stat *, int);
@@ -3399,7 +3434,7 @@
   CPP=
 fi
 if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then :
+  if ${ac_cv_prog_CPP+:} false; then :
   $as_echo_n "(cached) " >&6
 else
       # Double quotes because CPP needs to be expanded
@@ -3429,7 +3464,7 @@
   # Broken: fails on valid input.
 continue
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether nonexistent headers
   # can be detected and how.
@@ -3445,11 +3480,11 @@
 ac_preproc_ok=:
 break
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.i conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then :
   break
 fi
@@ -3488,7 +3523,7 @@
   # Broken: fails on valid input.
 continue
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether nonexistent headers
   # can be detected and how.
@@ -3504,18 +3539,18 @@
 ac_preproc_ok=:
 break
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.i conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then :
 
 else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5; }
 fi
 
 ac_ext=c
@@ -3527,7 +3562,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
 $as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then :
+if ${ac_cv_path_GREP+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$GREP"; then
@@ -3541,7 +3576,7 @@
     for ac_prog in grep ggrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+      as_fn_executable_p "$ac_path_GREP" || continue
 # Check for GNU ac_path_GREP and select it if it is found.
   # Check for GNU $ac_path_GREP
 case `"$ac_path_GREP" --version 2>&1` in
@@ -3576,7 +3611,7 @@
   done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_GREP"; then
-    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_GREP=$GREP
@@ -3590,7 +3625,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
 $as_echo_n "checking for egrep... " >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then :
+if ${ac_cv_path_EGREP+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
@@ -3607,7 +3642,7 @@
     for ac_prog in egrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+      as_fn_executable_p "$ac_path_EGREP" || continue
 # Check for GNU ac_path_EGREP and select it if it is found.
   # Check for GNU $ac_path_EGREP
 case `"$ac_path_EGREP" --version 2>&1` in
@@ -3642,7 +3677,7 @@
   done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_EGREP=$EGREP
@@ -3664,9 +3699,75 @@
 
 fi
 rm -f conftest*
- { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing strerror" >&5
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
+$as_echo_n "checking for fgrep... " >&6; }
+if ${ac_cv_path_FGREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
+   then ac_cv_path_FGREP="$GREP -F"
+   else
+     if test -z "$FGREP"; then
+  ac_path_FGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in fgrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_FGREP" || continue
+# Check for GNU ac_path_FGREP and select it if it is found.
+  # Check for GNU $ac_path_FGREP
+case `"$ac_path_FGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'FGREP' >> "conftest.nl"
+    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_FGREP="$ac_path_FGREP"
+      ac_path_FGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_FGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_FGREP"; then
+    as_fn_error $? "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_FGREP=$FGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
+$as_echo "$ac_cv_path_FGREP" >&6; }
+ FGREP="$ac_cv_path_FGREP"
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing strerror" >&5
 $as_echo_n "checking for library containing strerror... " >&6; }
-if test "${ac_cv_search_strerror+set}" = set; then :
+if ${ac_cv_search_strerror+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -3700,11 +3801,11 @@
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if test "${ac_cv_search_strerror+set}" = set; then :
+  if ${ac_cv_search_strerror+:} false; then :
   break
 fi
 done
-if test "${ac_cv_search_strerror+set}" = set; then :
+if ${ac_cv_search_strerror+:} false; then :
 
 else
   ac_cv_search_strerror=no
@@ -3725,7 +3826,7 @@
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AWK+set}" = set; then :
+if ${ac_cv_prog_AWK+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AWK"; then
@@ -3737,7 +3838,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_AWK="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3765,7 +3866,7 @@
 set dummy strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then :
+if ${ac_cv_prog_STRIP+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$STRIP"; then
@@ -3777,7 +3878,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_STRIP="strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -3804,7 +3905,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
 $as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then :
+if ${ac_cv_header_stdc+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3916,7 +4017,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sys/wait.h that is POSIX.1 compatible" >&5
 $as_echo_n "checking for sys/wait.h that is POSIX.1 compatible... " >&6; }
-if test "${ac_cv_header_sys_wait_h+set}" = set; then :
+if ${ac_cv_header_sys_wait_h+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -3974,9 +4075,9 @@
   test "$GCC" = yes && CFLAGS="-O2 -fno-strength-reduce -Wall"
 fi
 if test "$GCC" = yes; then
-    gccversion=`"$CC" -dumpversion`
+    gccversion=`$CC -dumpversion`
   if test "x$gccversion" = "x"; then
-        gccversion=`"$CC" --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[^0-9]*\([0-9]\.[0-9.]*\).*$/\1/g'`
+        gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[^0-9]*\([0-9]\.[0-9.]*\).*$/\1/g'`
   fi
     if test "$gccversion" = "3.0.1" -o "$gccversion" = "3.0.2" -o "$gccversion" = "4.0.1"; then
     echo 'GCC [34].0.[12] has a bug in the optimizer, disabling "-O#"'
@@ -3989,6 +4090,24 @@
   fi
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for recent clang version" >&5
+$as_echo_n "checking for recent clang version... " >&6; }
+CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*$/\1/p'`
+if test x"$CLANG_VERSION_STRING" != x"" ; then
+  CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([0-9][0-9]*\)\.[0-9][0-9]*\.[0-9][0-9]*/\1/p'`
+  CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[0-9][0-9]*\.\([0-9][0-9]*\)\.[0-9][0-9]*/\1/p'`
+  CLANG_REVISION=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[0-9][0-9]*\.[0-9][0-9]*\.\([0-9][0-9]*\)/\1/p'`
+  CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CLANG_VERSION" >&5
+$as_echo "$CLANG_VERSION" >&6; }
+          if test "$CLANG_VERSION" -ge 500002075 ; then
+    CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
 if test "$cross_compiling" = yes; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: cannot compile a simple program; if not cross compiling check CC and CFLAGS" >&5
 $as_echo "cannot compile a simple program; if not cross compiling check CC and CFLAGS" >&6; }
@@ -4089,7 +4208,7 @@
 set dummy xcode-select; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_XCODE_SELECT+set}" = set; then :
+if ${ac_cv_path_XCODE_SELECT+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $XCODE_SELECT in
@@ -4103,7 +4222,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_XCODE_SELECT="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4203,7 +4322,7 @@
     MACOSX=yes
     OS_EXTRA_SRC="os_macosx.m os_mac_conv.c";
     OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
-        CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX -no-cpp-precomp"
+            CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX"
 
                 # On IRIX 5.3, sys/types and inttypes.h are conflicting.
 for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
@@ -4212,8 +4331,7 @@
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
 "
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -4224,7 +4342,7 @@
 
 
 ac_fn_c_check_header_mongrel "$LINENO" "Carbon/Carbon.h" "ac_cv_header_Carbon_Carbon_h" "$ac_includes_default"
-if test "x$ac_cv_header_Carbon_Carbon_h" = x""yes; then :
+if test "x$ac_cv_header_Carbon_Carbon_h" = xyes; then :
   CARBON=yes
 fi
 
@@ -4245,6 +4363,19 @@
 $as_echo "no" >&6; }
 fi
 
+for ac_header in AvailabilityMacros.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "AvailabilityMacros.h" "ac_cv_header_AvailabilityMacros_h" "$ac_includes_default"
+if test "x$ac_cv_header_AvailabilityMacros_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_AVAILABILITYMACROS_H 1
+_ACEOF
+
+fi
+
+done
+
+
 
 
 
@@ -4265,7 +4396,7 @@
       have_local_include=yes
       have_local_lib=yes
       ;;
-    *) as_fn_error "must pass path argument to --with-local-dir" "$LINENO" 5 ;;
+    *) as_fn_error $? "must pass path argument to --with-local-dir" "$LINENO" 5 ;;
     esac
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $local_dir" >&5
 $as_echo "$local_dir" >&6; }
@@ -4280,7 +4411,7 @@
 
   if test "$GCC" = yes -a "$local_dir" != no; then
     echo 'void f(){}' > conftest.c
-        have_local_include=`${CC-cc} -no-cpp-precomp -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
+        have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
     have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/lib"`
     rm -f conftest.c conftest.o
   fi
@@ -4460,21 +4591,120 @@
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-selinux argument" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-smack argument" >&5
+$as_echo_n "checking --disable-smack argument... " >&6; }
+# Check whether --enable-smack was given.
+if test "${enable_smack+set}" = set; then :
+  enableval=$enable_smack;
+else
+  enable_smack="yes"
+fi
+
+if test "$enable_smack" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  ac_fn_c_check_header_mongrel "$LINENO" "linux/xattr.h" "ac_cv_header_linux_xattr_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_xattr_h" = xyes; then :
+  true
+else
+  enable_smack="no"
+fi
+
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+if test "$enable_smack" = "yes"; then
+  ac_fn_c_check_header_mongrel "$LINENO" "attr/xattr.h" "ac_cv_header_attr_xattr_h" "$ac_includes_default"
+if test "x$ac_cv_header_attr_xattr_h" = xyes; then :
+  true
+else
+  enable_smack="no"
+fi
+
+
+fi
+if test "$enable_smack" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XATTR_NAME_SMACKEXEC in linux/xattr.h" >&5
+$as_echo_n "checking for XATTR_NAME_SMACKEXEC in linux/xattr.h... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <linux/xattr.h>
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "XATTR_NAME_SMACKEXEC" >/dev/null 2>&1; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }; enable_smack="no"
+fi
+rm -f conftest*
+
+fi
+if test "$enable_smack" = "yes"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for setxattr in -lattr" >&5
+$as_echo_n "checking for setxattr in -lattr... " >&6; }
+if ${ac_cv_lib_attr_setxattr+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lattr  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char setxattr ();
+int
+main ()
+{
+return setxattr ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_attr_setxattr=yes
+else
+  ac_cv_lib_attr_setxattr=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_attr_setxattr" >&5
+$as_echo "$ac_cv_lib_attr_setxattr" >&6; }
+if test "x$ac_cv_lib_attr_setxattr" = xyes; then :
+  LIBS="$LIBS -lattr"
+	   found_smack="yes"
+	   $as_echo "#define HAVE_SMACK 1" >>confdefs.h
+
+fi
+
+fi
+
+if test "x$found_smack" = "x"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-selinux argument" >&5
 $as_echo_n "checking --disable-selinux argument... " >&6; }
-# Check whether --enable-selinux was given.
+  # Check whether --enable-selinux was given.
 if test "${enable_selinux+set}" = set; then :
   enableval=$enable_selinux;
 else
   enable_selinux="yes"
 fi
 
-if test "$enable_selinux" = "yes"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+  if test "$enable_selinux" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for is_selinux_enabled in -lselinux" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for is_selinux_enabled in -lselinux" >&5
 $as_echo_n "checking for is_selinux_enabled in -lselinux... " >&6; }
-if test "${ac_cv_lib_selinux_is_selinux_enabled+set}" = set; then :
+if ${ac_cv_lib_selinux_is_selinux_enabled+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -4508,15 +4738,16 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_selinux_is_selinux_enabled" >&5
 $as_echo "$ac_cv_lib_selinux_is_selinux_enabled" >&6; }
-if test "x$ac_cv_lib_selinux_is_selinux_enabled" = x""yes; then :
+if test "x$ac_cv_lib_selinux_is_selinux_enabled" = xyes; then :
   LIBS="$LIBS -lselinux"
-	   $as_echo "#define HAVE_SELINUX 1" >>confdefs.h
+	     $as_echo "#define HAVE_SELINUX 1" >>confdefs.h
 
 fi
 
-else
-   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+  else
+     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
+  fi
 fi
 
 
@@ -4670,7 +4901,7 @@
 set dummy luajit; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_luajit+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_luajit+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_luajit in
@@ -4684,7 +4915,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_luajit="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4709,16 +4940,16 @@
       if test "X$vi_cv_path_luajit" != "X"; then
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking LuaJIT version" >&5
 $as_echo_n "checking LuaJIT version... " >&6; }
-if test "${vi_cv_version_luajit+set}" = set; then :
+if ${vi_cv_version_luajit+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-   vi_cv_version_luajit=`${vi_cv_path_luajit} -v | sed 's/LuaJIT \([0-9.]*\)\.[0-9] .*/\1/'`
+   vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \([0-9.]*\)\.[0-9]\(-[a-z0-9]*\)* .*/\1/'`
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $vi_cv_version_luajit" >&5
 $as_echo "$vi_cv_version_luajit" >&6; }
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Lua version of LuaJIT" >&5
 $as_echo_n "checking Lua version of LuaJIT... " >&6; }
-if test "${vi_cv_version_lua_luajit+set}" = set; then :
+if ${vi_cv_version_lua_luajit+:} false; then :
   $as_echo_n "(cached) " >&6
 else
    vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e "print(_VERSION)" | sed 's/.* //'`
@@ -4733,7 +4964,7 @@
 set dummy lua; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_plain_lua+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_plain_lua+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_plain_lua in
@@ -4747,7 +4978,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_plain_lua="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -4772,7 +5003,7 @@
       if test "X$vi_cv_path_plain_lua" != "X"; then
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Lua version" >&5
 $as_echo_n "checking Lua version... " >&6; }
-if test "${vi_cv_version_plain_lua+set}" = set; then :
+if ${vi_cv_version_plain_lua+:} false; then :
   $as_echo_n "(cached) " >&6
 else
    vi_cv_version_plain_lua=`${vi_cv_path_plain_lua} -e "print(_VERSION)" | sed 's/.* //'`
@@ -4932,7 +5163,7 @@
     fi
   fi
   if test "$fail_if_missing" = "yes" -a "$lua_ok" != "yes"; then
-    as_fn_error "could not configure lua" "$LINENO" 5
+    as_fn_error $? "could not configure lua" "$LINENO" 5
   fi
 
 
@@ -4986,7 +5217,7 @@
 set dummy mzscheme; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_mzscheme+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_mzscheme+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_mzscheme in
@@ -5000,7 +5231,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_mzscheme="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5033,7 +5264,7 @@
 	if test "X$vi_cv_path_mzscheme" != "X"; then
 	    	    { $as_echo "$as_me:${as_lineno-$LINENO}: checking MzScheme install prefix" >&5
 $as_echo_n "checking MzScheme install prefix... " >&6; }
-if test "${vi_cv_path_mzscheme_pfx+set}" = set; then :
+if ${vi_cv_path_mzscheme_pfx+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   	    	    echo "(display (simplify-path		\
@@ -5168,9 +5399,19 @@
 $as_echo_n "checking for mzscheme_base.c... " >&6; }
     if test -f "${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
       MZSCHEME_EXTRA="mzscheme_base.c"
+      MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+      MZSCHEME_MOD="++lib scheme/base"
     else
       if test -f "${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
 	MZSCHEME_EXTRA="mzscheme_base.c"
+	MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+	MZSCHEME_MOD="++lib scheme/base"
+      else
+	if test -f "${SCHEME_COLLECTS}collects/racket/base.rkt" ; then
+	  MZSCHEME_EXTRA="mzscheme_base.c"
+	  MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/raco ctool"
+	  MZSCHEME_MOD=""
+	fi
       fi
     fi
     if test "X$MZSCHEME_EXTRA" != "X" ; then
@@ -5185,7 +5426,7 @@
 
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ffi_type_void in -lffi" >&5
 $as_echo_n "checking for ffi_type_void in -lffi... " >&6; }
-if test "${ac_cv_lib_ffi_ffi_type_void+set}" = set; then :
+if ${ac_cv_lib_ffi_ffi_type_void+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -5219,7 +5460,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ffi_ffi_type_void" >&5
 $as_echo "$ac_cv_lib_ffi_ffi_type_void" >&6; }
-if test "x$ac_cv_lib_ffi_ffi_type_void" = x""yes; then :
+if test "x$ac_cv_lib_ffi_ffi_type_void" = xyes; then :
   MZSCHEME_LIBS="$MZSCHEME_LIBS -lffi"
 fi
 
@@ -5295,7 +5536,7 @@
 set dummy perl; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_perl+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_perl+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_perl in
@@ -5309,7 +5550,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_perl="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5364,6 +5605,14 @@
       fi
       vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`
 
+      vi_cv_perl_extutils=unknown_perl_extutils_path
+      for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do
+	xsubpp_path="$vi_cv_perllib/$extutils_rel_path/xsubpp"
+	if test -f "$xsubpp_path"; then
+	  vi_cv_perl_xsubpp="$xsubpp_path"
+	fi
+      done
+
             perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \
 	      -e 'ccflags;perl_inc;print"\n"' | sed -e 's/-fno[^ ]*//'`
             perllibs=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed -e 'ldopts' | \
@@ -5409,7 +5658,7 @@
 	  	  PERL_CFLAGS=`echo "$perlcppflags" | sed -e 's/-pipe //' -e 's/-W[^ ]*//'`
 	fi
 	if test "X$perlldflags" != "X"; then
-	  if test "X`echo \"$LDFLAGS\" | grep -F -e \"$perlldflags\"`" = "X"; then
+	  if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$perlldflags\"`" = "X"; then
 	    LDFLAGS="$perlldflags $LDFLAGS"
 	  fi
 	fi
@@ -5457,7 +5706,7 @@
   fi
 
   if test "$fail_if_missing" = "yes" -a "$perl_ok" != "yes"; then
-    as_fn_error "could not configure perl" "$LINENO" 5
+    as_fn_error $? "could not configure perl" "$LINENO" 5
   fi
 fi
 
@@ -5485,7 +5734,7 @@
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_python+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_python+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_python in
@@ -5499,7 +5748,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_python="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5528,7 +5777,7 @@
 
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python version" >&5
 $as_echo_n "checking Python version... " >&6; }
-if test "${vi_cv_var_python_version+set}" = set; then :
+if ${vi_cv_var_python_version+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   vi_cv_var_python_version=`
@@ -5548,7 +5797,7 @@
 
             { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's install prefix" >&5
 $as_echo_n "checking Python's install prefix... " >&6; }
-if test "${vi_cv_path_python_pfx+set}" = set; then :
+if ${vi_cv_path_python_pfx+:} false; then :
   $as_echo_n "(cached) " >&6
 else
    vi_cv_path_python_pfx=`
@@ -5560,7 +5809,7 @@
 
             { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's execution prefix" >&5
 $as_echo_n "checking Python's execution prefix... " >&6; }
-if test "${vi_cv_path_python_epfx+set}" = set; then :
+if ${vi_cv_path_python_epfx+:} false; then :
   $as_echo_n "(cached) " >&6
 else
    vi_cv_path_python_epfx=`
@@ -5571,7 +5820,7 @@
 $as_echo "$vi_cv_path_python_epfx" >&6; }
 
 
-      if test "${vi_cv_path_pythonpath+set}" = set; then :
+      if ${vi_cv_path_pythonpath+:} false; then :
   $as_echo_n "(cached) " >&6
 else
    vi_cv_path_pythonpath=`
@@ -5591,7 +5840,7 @@
 
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's configuration directory" >&5
 $as_echo_n "checking Python's configuration directory... " >&6; }
-if test "${vi_cv_path_python_conf+set}" = set; then :
+if ${vi_cv_path_python_conf+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -5621,7 +5870,7 @@
 $as_echo "can't find it!" >&6; }
       else
 
-			if test "${vi_cv_path_python_plibs+set}" = set; then :
+			if ${vi_cv_path_python_plibs+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -5653,10 +5902,19 @@
 
 fi
 
+	if ${vi_cv_dll_name_python+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	  if test "X$python_DLLLIBRARY" != "X"; then
+	    vi_cv_dll_name_python="$python_DLLLIBRARY"
+	  else
+	    vi_cv_dll_name_python="$python_INSTSONAME"
+	  fi
+
+fi
+
 
-	if test "X$python_DLLLIBRARY" != "X"; then
-	  python_INSTSONAME="$python_DLLLIBRARY"
-	fi
 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
@@ -5762,7 +6020,7 @@
   fi
 
   if test "$fail_if_missing" = "yes" -a "$python_ok" != "yes"; then
-    as_fn_error "could not configure python" "$LINENO" 5
+    as_fn_error $? "could not configure python" "$LINENO" 5
   fi
 fi
 
@@ -5792,7 +6050,7 @@
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_python3+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_python3+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_python3 in
@@ -5806,7 +6064,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_python3="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -5835,7 +6093,7 @@
 
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python version" >&5
 $as_echo_n "checking Python version... " >&6; }
-if test "${vi_cv_var_python3_version+set}" = set; then :
+if ${vi_cv_var_python3_version+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   vi_cv_var_python3_version=`
@@ -5855,7 +6113,7 @@
 
             { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's abiflags" >&5
 $as_echo_n "checking Python's abiflags... " >&6; }
-if test "${vi_cv_var_python3_abiflags+set}" = set; then :
+if ${vi_cv_var_python3_abiflags+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -5872,7 +6130,7 @@
 
             { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's install prefix" >&5
 $as_echo_n "checking Python's install prefix... " >&6; }
-if test "${vi_cv_path_python3_pfx+set}" = set; then :
+if ${vi_cv_path_python3_pfx+:} false; then :
   $as_echo_n "(cached) " >&6
 else
    vi_cv_path_python3_pfx=`
@@ -5884,7 +6142,7 @@
 
             { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's execution prefix" >&5
 $as_echo_n "checking Python's execution prefix... " >&6; }
-if test "${vi_cv_path_python3_epfx+set}" = set; then :
+if ${vi_cv_path_python3_epfx+:} false; then :
   $as_echo_n "(cached) " >&6
 else
    vi_cv_path_python3_epfx=`
@@ -5895,7 +6153,7 @@
 $as_echo "$vi_cv_path_python3_epfx" >&6; }
 
 
-      if test "${vi_cv_path_python3path+set}" = set; then :
+      if ${vi_cv_path_python3path+:} false; then :
   $as_echo_n "(cached) " >&6
 else
    vi_cv_path_python3path=`
@@ -5915,7 +6173,7 @@
 
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking Python's configuration directory" >&5
 $as_echo_n "checking Python's configuration directory... " >&6; }
-if test "${vi_cv_path_python3_conf+set}" = set; then :
+if ${vi_cv_path_python3_conf+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -5946,7 +6204,7 @@
 $as_echo "can't find it!" >&6; }
       else
 
-                        if test "${vi_cv_path_python3_plibs+set}" = set; then :
+                        if ${vi_cv_path_python3_plibs+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -5960,19 +6218,28 @@
 	@echo "python3_DLLLIBRARY='$(DLLLIBRARY)'"
 	@echo "python3_INSTSONAME='$(INSTSONAME)'"
 eof
-                        eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
-            rm -f -- "${tmp_mkf}"
+	    	    eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+	    rm -f -- "${tmp_mkf}"
 	    vi_cv_path_python3_plibs="-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
-            vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
-                        vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
-            vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
+	    vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
+	    	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
+	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
+
+fi
+
+	if ${vi_cv_dll_name_python3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+	  if test "X$python3_DLLLIBRARY" != "X"; then
+	    vi_cv_dll_name_python3="$python3_DLLLIBRARY"
+	  else
+	    vi_cv_dll_name_python3="$python3_INSTSONAME"
+	  fi
 
 fi
 
 
-        if test "X$python3_DLLLIBRARY" != "X"; then
-	  python3_INSTSONAME="$python3_DLLLIBRARY"
-        fi
         PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
         if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
@@ -6073,7 +6340,7 @@
     fi
   fi
   if test "$fail_if_missing" = "yes" -a "$python3_ok" != "yes"; then
-    as_fn_error "could not configure python3" "$LINENO" 5
+    as_fn_error $? "could not configure python3" "$LINENO" 5
   fi
 fi
 
@@ -6097,8 +6364,8 @@
   if test "$cross_compiling" = yes; then :
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run test program while cross compiling
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot run test program while cross compiling
+See \`config.log' for more details" "$LINENO" 5; }
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -6132,7 +6399,7 @@
     int main(int argc, char** argv)
     {
       int not_needed = 0;
-      if (no_rtl_global_needed_for("${python_INSTSONAME}", "${vi_cv_path_python_pfx}"))
+      if (no_rtl_global_needed_for("${vi_cv_dll_name_python}", "${vi_cv_path_python_pfx}"))
             not_needed = 1;
       return !not_needed;
     }
@@ -6162,8 +6429,8 @@
   if test "$cross_compiling" = yes; then :
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run test program while cross compiling
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot run test program while cross compiling
+See \`config.log' for more details" "$LINENO" 5; }
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -6198,7 +6465,7 @@
     int main(int argc, char** argv)
     {
       int not_needed = 0;
-      if (no_rtl_global_needed_for("${python3_INSTSONAME}", L"${vi_cv_path_python3_pfx}"))
+      if (no_rtl_global_needed_for("${vi_cv_dll_name_python3}", L"${vi_cv_path_python3_pfx}"))
             not_needed = 1;
       return !not_needed;
     }
@@ -6221,18 +6488,18 @@
 
   PYTHON_SRC="if_python.c"
   PYTHON_OBJ="objects/if_python.o"
-  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${python_INSTSONAME}\\\""
+  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
   PYTHON_LIBS=
   PYTHON3_SRC="if_python3.c"
   PYTHON3_OBJ="objects/if_python3.o"
-  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${python3_INSTSONAME}\\\""
+  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
   PYTHON3_LIBS=
 elif test "$python_ok" = yes && test "$enable_pythoninterp" = "dynamic"; then
   $as_echo "#define DYNAMIC_PYTHON 1" >>confdefs.h
 
   PYTHON_SRC="if_python.c"
   PYTHON_OBJ="objects/if_python.o"
-  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${python_INSTSONAME}\\\""
+  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
   PYTHON_LIBS=
 elif test "$python_ok" = yes; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking if -fPIE can be added for Python" >&5
@@ -6271,7 +6538,7 @@
 
   PYTHON3_SRC="if_python3.c"
   PYTHON3_OBJ="objects/if_python3.o"
-  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${python3_INSTSONAME}\\\""
+  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
   PYTHON3_LIBS=
 elif test "$python3_ok" = yes; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking if -fPIE can be added for Python3" >&5
@@ -6337,7 +6604,7 @@
 set dummy $tclsh_name; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_tcl+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_tcl in
@@ -6351,7 +6618,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6381,7 +6648,7 @@
 set dummy $tclsh_name; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_tcl+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_tcl in
@@ -6395,7 +6662,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6424,7 +6691,7 @@
 set dummy $tclsh_name; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_tcl+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_tcl in
@@ -6438,7 +6705,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6467,7 +6734,7 @@
 set dummy $tclsh_name; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_tcl+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_tcl in
@@ -6481,7 +6748,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6510,7 +6777,7 @@
 set dummy $tclsh_name; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_tcl+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_tcl+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_tcl in
@@ -6524,7 +6791,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_tcl="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6641,7 +6908,7 @@
     fi
   fi
   if test "$fail_if_missing" = "yes" -a -z "$TCL_SRC"; then
-    as_fn_error "could not configure Tcl" "$LINENO" 5
+    as_fn_error $? "could not configure Tcl" "$LINENO" 5
   fi
 fi
 
@@ -6679,7 +6946,7 @@
 set dummy $RUBY_CMD; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_vi_cv_path_ruby+set}" = set; then :
+if ${ac_cv_path_vi_cv_path_ruby+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $vi_cv_path_ruby in
@@ -6693,7 +6960,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_vi_cv_path_ruby="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -6736,9 +7003,9 @@
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $rubyhdrdir" >&5
 $as_echo "$rubyhdrdir" >&6; }
 	RUBY_CFLAGS="-I$rubyhdrdir"
-        rubyarch=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG['arch']"`
-        if test -d "$rubyhdrdir/$rubyarch"; then
-          RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyhdrdir/$rubyarch"
+        rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e "print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG['rubyarchhdrdir'] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG['arch']"`
+        if test -d "$rubyarchdir"; then
+          RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyarchdir"
         fi
         rubyversion=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG['ruby_version'].gsub(/\./, '')[0,2]"`
 	if test "X$rubyversion" = "X"; then
@@ -6767,7 +7034,7 @@
 	if test "X$rubyldflags" != "X"; then
 	  	  	  	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
 	  if test "X$rubyldflags" != "X"; then
-	    if test "X`echo \"$LDFLAGS\" | grep -F -e \"$rubyldflags\"`" = "X"; then
+	    if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$rubyldflags\"`" = "X"; then
 	      LDFLAGS="$rubyldflags $LDFLAGS"
 	    fi
 	  fi
@@ -6795,7 +7062,7 @@
   fi
 
   if test "$fail_if_missing" = "yes" -a -z "$RUBY_OBJ"; then
-    as_fn_error "could not configure Ruby" "$LINENO" 5
+    as_fn_error $? "could not configure Ruby" "$LINENO" 5
   fi
 fi
 
@@ -6857,7 +7124,7 @@
 $as_echo "no" >&6; }
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for socket in -lsocket" >&5
 $as_echo_n "checking for socket in -lsocket... " >&6; }
-if test "${ac_cv_lib_socket_socket+set}" = set; then :
+if ${ac_cv_lib_socket_socket+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -6891,7 +7158,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_socket" >&5
 $as_echo "$ac_cv_lib_socket_socket" >&6; }
-if test "x$ac_cv_lib_socket_socket" = x""yes; then :
+if test "x$ac_cv_lib_socket_socket" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBSOCKET 1
 _ACEOF
@@ -6902,7 +7169,7 @@
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lnsl" >&5
 $as_echo_n "checking for gethostbyname in -lnsl... " >&6; }
-if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then :
+if ${ac_cv_lib_nsl_gethostbyname+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -6936,7 +7203,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_gethostbyname" >&5
 $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then :
+if test "x$ac_cv_lib_nsl_gethostbyname" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBNSL 1
 _ACEOF
@@ -7086,7 +7353,7 @@
 set dummy xmkmf; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_xmkmfpath+set}" = set; then :
+if ${ac_cv_path_xmkmfpath+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $xmkmfpath in
@@ -7100,7 +7367,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_xmkmfpath="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -7138,8 +7405,8 @@
   have_x=disabled
 else
   case $x_includes,$x_libraries in #(
-    *\'*) as_fn_error "cannot use X directory names containing '" "$LINENO" 5;; #(
-    *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then :
+    *\'*) as_fn_error $? "cannot use X directory names containing '" "$LINENO" 5;; #(
+    *,NONE | NONE,*) if ${ac_cv_have_x+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   # One or both of the vars are not set, and there is no cached value.
@@ -7156,7 +7423,7 @@
 	@echo libdir='${LIBDIR}'
 _ACEOF
   if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
-    # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+    # GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
     for ac_var in incroot usrlibdir libdir; do
       eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
     done
@@ -7242,7 +7509,7 @@
   fi
 done
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 fi # $ac_x_includes = no
 
 if test "$ac_x_libraries" = no; then
@@ -7416,7 +7683,7 @@
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dnet_ntoa in -ldnet" >&5
 $as_echo_n "checking for dnet_ntoa in -ldnet... " >&6; }
-if test "${ac_cv_lib_dnet_dnet_ntoa+set}" = set; then :
+if ${ac_cv_lib_dnet_dnet_ntoa+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7450,14 +7717,14 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
 $as_echo "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
-if test "x$ac_cv_lib_dnet_dnet_ntoa" = x""yes; then :
+if test "x$ac_cv_lib_dnet_dnet_ntoa" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
 fi
 
     if test $ac_cv_lib_dnet_dnet_ntoa = no; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dnet_ntoa in -ldnet_stub" >&5
 $as_echo_n "checking for dnet_ntoa in -ldnet_stub... " >&6; }
-if test "${ac_cv_lib_dnet_stub_dnet_ntoa+set}" = set; then :
+if ${ac_cv_lib_dnet_stub_dnet_ntoa+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7491,7 +7758,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
 $as_echo "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
-if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = x""yes; then :
+if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
 fi
 
@@ -7510,14 +7777,14 @@
     # The functions gethostbyname, getservbyname, and inet_addr are
     # in -lbsd on LynxOS 3.0.1/i386, according to Lars Hecking.
     ac_fn_c_check_func "$LINENO" "gethostbyname" "ac_cv_func_gethostbyname"
-if test "x$ac_cv_func_gethostbyname" = x""yes; then :
+if test "x$ac_cv_func_gethostbyname" = xyes; then :
 
 fi
 
     if test $ac_cv_func_gethostbyname = no; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lnsl" >&5
 $as_echo_n "checking for gethostbyname in -lnsl... " >&6; }
-if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then :
+if ${ac_cv_lib_nsl_gethostbyname+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7551,14 +7818,14 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_gethostbyname" >&5
 $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then :
+if test "x$ac_cv_lib_nsl_gethostbyname" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
 fi
 
       if test $ac_cv_lib_nsl_gethostbyname = no; then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lbsd" >&5
 $as_echo_n "checking for gethostbyname in -lbsd... " >&6; }
-if test "${ac_cv_lib_bsd_gethostbyname+set}" = set; then :
+if ${ac_cv_lib_bsd_gethostbyname+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7592,7 +7859,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bsd_gethostbyname" >&5
 $as_echo "$ac_cv_lib_bsd_gethostbyname" >&6; }
-if test "x$ac_cv_lib_bsd_gethostbyname" = x""yes; then :
+if test "x$ac_cv_lib_bsd_gethostbyname" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lbsd"
 fi
 
@@ -7607,14 +7874,14 @@
     # must be given before -lnsl if both are needed.  We assume that
     # if connect needs -lnsl, so does gethostbyname.
     ac_fn_c_check_func "$LINENO" "connect" "ac_cv_func_connect"
-if test "x$ac_cv_func_connect" = x""yes; then :
+if test "x$ac_cv_func_connect" = xyes; then :
 
 fi
 
     if test $ac_cv_func_connect = no; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for connect in -lsocket" >&5
 $as_echo_n "checking for connect in -lsocket... " >&6; }
-if test "${ac_cv_lib_socket_connect+set}" = set; then :
+if ${ac_cv_lib_socket_connect+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7648,7 +7915,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_connect" >&5
 $as_echo "$ac_cv_lib_socket_connect" >&6; }
-if test "x$ac_cv_lib_socket_connect" = x""yes; then :
+if test "x$ac_cv_lib_socket_connect" = xyes; then :
   X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
 fi
 
@@ -7656,14 +7923,14 @@
 
     # Guillermo Gomez says -lposix is necessary on A/UX.
     ac_fn_c_check_func "$LINENO" "remove" "ac_cv_func_remove"
-if test "x$ac_cv_func_remove" = x""yes; then :
+if test "x$ac_cv_func_remove" = xyes; then :
 
 fi
 
     if test $ac_cv_func_remove = no; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for remove in -lposix" >&5
 $as_echo_n "checking for remove in -lposix... " >&6; }
-if test "${ac_cv_lib_posix_remove+set}" = set; then :
+if ${ac_cv_lib_posix_remove+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7697,7 +7964,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_posix_remove" >&5
 $as_echo "$ac_cv_lib_posix_remove" >&6; }
-if test "x$ac_cv_lib_posix_remove" = x""yes; then :
+if test "x$ac_cv_lib_posix_remove" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
 fi
 
@@ -7705,14 +7972,14 @@
 
     # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
     ac_fn_c_check_func "$LINENO" "shmat" "ac_cv_func_shmat"
-if test "x$ac_cv_func_shmat" = x""yes; then :
+if test "x$ac_cv_func_shmat" = xyes; then :
 
 fi
 
     if test $ac_cv_func_shmat = no; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shmat in -lipc" >&5
 $as_echo_n "checking for shmat in -lipc... " >&6; }
-if test "${ac_cv_lib_ipc_shmat+set}" = set; then :
+if ${ac_cv_lib_ipc_shmat+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7746,7 +8013,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ipc_shmat" >&5
 $as_echo "$ac_cv_lib_ipc_shmat" >&6; }
-if test "x$ac_cv_lib_ipc_shmat" = x""yes; then :
+if test "x$ac_cv_lib_ipc_shmat" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
 fi
 
@@ -7764,7 +8031,7 @@
   # John Interrante, Karl Berry
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for IceConnectionNumber in -lICE" >&5
 $as_echo_n "checking for IceConnectionNumber in -lICE... " >&6; }
-if test "${ac_cv_lib_ICE_IceConnectionNumber+set}" = set; then :
+if ${ac_cv_lib_ICE_IceConnectionNumber+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7798,7 +8065,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
 $as_echo "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
-if test "x$ac_cv_lib_ICE_IceConnectionNumber" = x""yes; then :
+if test "x$ac_cv_lib_ICE_IceConnectionNumber" = xyes; then :
   X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
 fi
 
@@ -7876,7 +8143,7 @@
 
             { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _XdmcpAuthDoIt in -lXdmcp" >&5
 $as_echo_n "checking for _XdmcpAuthDoIt in -lXdmcp... " >&6; }
-if test "${ac_cv_lib_Xdmcp__XdmcpAuthDoIt+set}" = set; then :
+if ${ac_cv_lib_Xdmcp__XdmcpAuthDoIt+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7910,14 +8177,14 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&5
 $as_echo "$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&6; }
-if test "x$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" = x""yes; then :
+if test "x$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"
 fi
 
 
                     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for IceOpenConnection in -lICE" >&5
 $as_echo_n "checking for IceOpenConnection in -lICE... " >&6; }
-if test "${ac_cv_lib_ICE_IceOpenConnection+set}" = set; then :
+if ${ac_cv_lib_ICE_IceOpenConnection+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7951,7 +8218,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ICE_IceOpenConnection" >&5
 $as_echo "$ac_cv_lib_ICE_IceOpenConnection" >&6; }
-if test "x$ac_cv_lib_ICE_IceOpenConnection" = x""yes; then :
+if test "x$ac_cv_lib_ICE_IceOpenConnection" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"
 fi
 
@@ -7959,7 +8226,7 @@
         LDFLAGS="$X_LIBS $ac_save_LDFLAGS"
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XpmCreatePixmapFromData in -lXpm" >&5
 $as_echo_n "checking for XpmCreatePixmapFromData in -lXpm... " >&6; }
-if test "${ac_cv_lib_Xpm_XpmCreatePixmapFromData+set}" = set; then :
+if ${ac_cv_lib_Xpm_XpmCreatePixmapFromData+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -7993,7 +8260,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&5
 $as_echo "$ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&6; }
-if test "x$ac_cv_lib_Xpm_XpmCreatePixmapFromData" = x""yes; then :
+if test "x$ac_cv_lib_Xpm_XpmCreatePixmapFromData" = xyes; then :
   X_PRE_LIBS="$X_PRE_LIBS -lXpm"
 fi
 
@@ -8051,11 +8318,11 @@
 
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of wchar_t is 2 bytes" >&5
 $as_echo_n "checking size of wchar_t is 2 bytes... " >&6; }
-    if test "${ac_cv_small_wchar_t+set}" = set; then :
+    if ${ac_cv_small_wchar_t+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "$cross_compiling" = yes; then :
-  as_fn_error "failed to compile test program" "$LINENO" 5
+  as_fn_error $? "failed to compile test program" "$LINENO" 5
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -8354,7 +8621,7 @@
 set dummy pkg-config; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_PKG_CONFIG+set}" = set; then :
+if ${ac_cv_path_PKG_CONFIG+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   case $PKG_CONFIG in
@@ -8368,7 +8635,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -8593,7 +8860,7 @@
       { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
 $as_echo "not found" >&6; }
       if test "x" = xfail; then
-	as_fn_error "Could not find libgnomeui-2.0 via pkg-config" "$LINENO" 5
+	as_fn_error $? "Could not find libgnomeui-2.0 via pkg-config" "$LINENO" 5
       fi
     fi
   }
@@ -8786,7 +9053,7 @@
   LDFLAGS="$X_LIBS $LDFLAGS"
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XShapeQueryExtension in -lXext" >&5
 $as_echo_n "checking for XShapeQueryExtension in -lXext... " >&6; }
-if test "${ac_cv_lib_Xext_XShapeQueryExtension+set}" = set; then :
+if ${ac_cv_lib_Xext_XShapeQueryExtension+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8820,13 +9087,13 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
 $as_echo "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
-if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = x""yes; then :
+if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = xyes; then :
   GUI_X_LIBS="-lXext"
 fi
 
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for wslen in -lw" >&5
 $as_echo_n "checking for wslen in -lw... " >&6; }
-if test "${ac_cv_lib_w_wslen+set}" = set; then :
+if ${ac_cv_lib_w_wslen+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8860,13 +9127,13 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_w_wslen" >&5
 $as_echo "$ac_cv_lib_w_wslen" >&6; }
-if test "x$ac_cv_lib_w_wslen" = x""yes; then :
+if test "x$ac_cv_lib_w_wslen" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"
 fi
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlsym in -ldl" >&5
 $as_echo_n "checking for dlsym in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlsym+set}" = set; then :
+if ${ac_cv_lib_dl_dlsym+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8900,13 +9167,13 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlsym" >&5
 $as_echo "$ac_cv_lib_dl_dlsym" >&6; }
-if test "x$ac_cv_lib_dl_dlsym" = x""yes; then :
+if test "x$ac_cv_lib_dl_dlsym" = xyes; then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"
 fi
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XmuCreateStippledPixmap in -lXmu" >&5
 $as_echo_n "checking for XmuCreateStippledPixmap in -lXmu... " >&6; }
-if test "${ac_cv_lib_Xmu_XmuCreateStippledPixmap+set}" = set; then :
+if ${ac_cv_lib_Xmu_XmuCreateStippledPixmap+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8940,14 +9207,14 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&5
 $as_echo "$ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&6; }
-if test "x$ac_cv_lib_Xmu_XmuCreateStippledPixmap" = x""yes; then :
+if test "x$ac_cv_lib_Xmu_XmuCreateStippledPixmap" = xyes; then :
   GUI_X_LIBS="-lXmu $GUI_X_LIBS"
 fi
 
   if test -z "$SKIP_MOTIF"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XpEndJob in -lXp" >&5
 $as_echo_n "checking for XpEndJob in -lXp... " >&6; }
-if test "${ac_cv_lib_Xp_XpEndJob+set}" = set; then :
+if ${ac_cv_lib_Xp_XpEndJob+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -8981,7 +9248,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xp_XpEndJob" >&5
 $as_echo "$ac_cv_lib_Xp_XpEndJob" >&6; }
-if test "x$ac_cv_lib_Xp_XpEndJob" = x""yes; then :
+if test "x$ac_cv_lib_Xp_XpEndJob" = xyes; then :
   GUI_X_LIBS="-lXp $GUI_X_LIBS"
 fi
 
@@ -9020,7 +9287,7 @@
   for ac_header in X11/SM/SMlib.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "X11/SM/SMlib.h" "ac_cv_header_X11_SM_SMlib_h" "$ac_includes_default"
-if test "x$ac_cv_header_X11_SM_SMlib_h" = x""yes; then :
+if test "x$ac_cv_header_X11_SM_SMlib_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_X11_SM_SMLIB_H 1
 _ACEOF
@@ -9040,8 +9307,7 @@
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -9064,7 +9330,7 @@
 $as_echo "yes" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no; xim has been disabled" >&5
-$as_echo "no; xim has been disabled" >&6; }; enable_xim = "no"
+$as_echo "no; xim has been disabled" >&6; }; enable_xim="no"
 fi
 rm -f conftest*
 
@@ -9123,8 +9389,7 @@
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -9192,7 +9457,7 @@
 
 
 if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
-  as_fn_error "cannot use workshop without Motif" "$LINENO" 5
+  as_fn_error $? "cannot use workshop without Motif" "$LINENO" 5
 fi
 
 if test "$enable_xim" = "yes"; then
@@ -9246,13 +9511,13 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether toupper is broken" >&5
 $as_echo_n "checking whether toupper is broken... " >&6; }
-if test "${vim_cv_toupper_broken+set}" = set; then :
+if ${vim_cv_toupper_broken+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
     if test "$cross_compiling" = yes; then :
 
-    as_fn_error "cross-compiling: please set 'vim_cv_toupper_broken'" "$LINENO" 5
+    as_fn_error $? "cross-compiling: please set 'vim_cv_toupper_broken'" "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9336,7 +9601,7 @@
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 ac_fn_c_check_header_mongrel "$LINENO" "elf.h" "ac_cv_header_elf_h" "$ac_includes_default"
-if test "x$ac_cv_header_elf_h" = x""yes; then :
+if test "x$ac_cv_header_elf_h" = xyes; then :
   HAS_ELF=1
 fi
 
@@ -9344,7 +9609,7 @@
 if test "$HAS_ELF" = 1; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for main in -lelf" >&5
 $as_echo_n "checking for main in -lelf... " >&6; }
-if test "${ac_cv_lib_elf_main+set}" = set; then :
+if ${ac_cv_lib_elf_main+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -9372,7 +9637,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_elf_main" >&5
 $as_echo "$ac_cv_lib_elf_main" >&6; }
-if test "x$ac_cv_lib_elf_main" = x""yes; then :
+if test "x$ac_cv_lib_elf_main" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBELF 1
 _ACEOF
@@ -9388,7 +9653,7 @@
   as_ac_Header=`$as_echo "ac_cv_header_dirent_$ac_hdr" | $as_tr_sh`
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_hdr that defines DIR" >&5
 $as_echo_n "checking for $ac_hdr that defines DIR... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$as_ac_Header+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9415,8 +9680,7 @@
 eval ac_res=\$$as_ac_Header
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
 _ACEOF
@@ -9429,7 +9693,7 @@
 if test $ac_header_dirent = dirent.h; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing opendir" >&5
 $as_echo_n "checking for library containing opendir... " >&6; }
-if test "${ac_cv_search_opendir+set}" = set; then :
+if ${ac_cv_search_opendir+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -9463,11 +9727,11 @@
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if test "${ac_cv_search_opendir+set}" = set; then :
+  if ${ac_cv_search_opendir+:} false; then :
   break
 fi
 done
-if test "${ac_cv_search_opendir+set}" = set; then :
+if ${ac_cv_search_opendir+:} false; then :
 
 else
   ac_cv_search_opendir=no
@@ -9486,7 +9750,7 @@
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing opendir" >&5
 $as_echo_n "checking for library containing opendir... " >&6; }
-if test "${ac_cv_search_opendir+set}" = set; then :
+if ${ac_cv_search_opendir+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_func_search_save_LIBS=$LIBS
@@ -9520,11 +9784,11 @@
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext
-  if test "${ac_cv_search_opendir+set}" = set; then :
+  if ${ac_cv_search_opendir+:} false; then :
   break
 fi
 done
-if test "${ac_cv_search_opendir+set}" = set; then :
+if ${ac_cv_search_opendir+:} false; then :
 
 else
   ac_cv_search_opendir=no
@@ -9584,8 +9848,7 @@
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -9601,7 +9864,7 @@
 #  include <sys/stream.h>
 #endif
 "
-if test "x$ac_cv_header_sys_ptem_h" = x""yes; then :
+if test "x$ac_cv_header_sys_ptem_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SYS_PTEM_H 1
 _ACEOF
@@ -9617,7 +9880,7 @@
 #  include <sys/param.h>
 #endif
 "
-if test "x$ac_cv_header_sys_sysctl_h" = x""yes; then :
+if test "x$ac_cv_header_sys_sysctl_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SYS_SYSCTL_H 1
 _ACEOF
@@ -9657,7 +9920,7 @@
 for ac_header in strings.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "strings.h" "ac_cv_header_strings_h" "$ac_includes_default"
-if test "x$ac_cv_header_strings_h" = x""yes; then :
+if test "x$ac_cv_header_strings_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_STRINGS_H 1
 _ACEOF
@@ -9716,7 +9979,7 @@
 if test $ac_cv_c_compiler_gnu = yes; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC needs -traditional" >&5
 $as_echo_n "checking whether $CC needs -traditional... " >&6; }
-if test "${ac_cv_prog_gcc_traditional+set}" = set; then :
+if ${ac_cv_prog_gcc_traditional+:} false; then :
   $as_echo_n "(cached) " >&6
 else
     ac_pattern="Autoconf.*'x'"
@@ -9757,7 +10020,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for an ANSI C-conforming const" >&5
 $as_echo_n "checking for an ANSI C-conforming const... " >&6; }
-if test "${ac_cv_c_const+set}" = set; then :
+if ${ac_cv_c_const+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9766,11 +10029,11 @@
 int
 main ()
 {
-/* FIXME: Include the comments suggested by Paul. */
+
 #ifndef __cplusplus
-  /* Ultrix mips cc rejects this.  */
+  /* Ultrix mips cc rejects this sort of thing.  */
   typedef int charset[2];
-  const charset cs;
+  const charset cs = { 0, 0 };
   /* SunOS 4.1.1 cc rejects this.  */
   char const *const *pcpcc;
   char **ppc;
@@ -9787,8 +10050,9 @@
   ++pcpcc;
   ppc = (char**) pcpcc;
   pcpcc = (char const *const *) ppc;
-  { /* SCO 3.2v4 cc rejects this.  */
-    char *t;
+  { /* SCO 3.2v4 cc rejects this sort of thing.  */
+    char tx;
+    char *t = &tx;
     char const *s = 0 ? (char *) 0 : (char const *) 0;
 
     *t++ = 0;
@@ -9804,10 +10068,10 @@
     iptr p = 0;
     ++p;
   }
-  { /* AIX XL C 1.02.0.0 rejects this saying
+  { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
        "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
-    struct s { int j; const int *ap[3]; };
-    struct s *b; b->j = 5;
+    struct s { int j; const int *ap[3]; } bx;
+    struct s *b = &bx; b->j = 5;
   }
   { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
     const int foo = 10;
@@ -9837,7 +10101,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for working volatile" >&5
 $as_echo_n "checking for working volatile... " >&6; }
-if test "${ac_cv_c_volatile+set}" = set; then :
+if ${ac_cv_c_volatile+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9870,7 +10134,7 @@
 fi
 
 ac_fn_c_check_type "$LINENO" "mode_t" "ac_cv_type_mode_t" "$ac_includes_default"
-if test "x$ac_cv_type_mode_t" = x""yes; then :
+if test "x$ac_cv_type_mode_t" = xyes; then :
 
 else
 
@@ -9881,7 +10145,7 @@
 fi
 
 ac_fn_c_check_type "$LINENO" "off_t" "ac_cv_type_off_t" "$ac_includes_default"
-if test "x$ac_cv_type_off_t" = x""yes; then :
+if test "x$ac_cv_type_off_t" = xyes; then :
 
 else
 
@@ -9892,7 +10156,7 @@
 fi
 
 ac_fn_c_check_type "$LINENO" "pid_t" "ac_cv_type_pid_t" "$ac_includes_default"
-if test "x$ac_cv_type_pid_t" = x""yes; then :
+if test "x$ac_cv_type_pid_t" = xyes; then :
 
 else
 
@@ -9903,7 +10167,7 @@
 fi
 
 ac_fn_c_check_type "$LINENO" "size_t" "ac_cv_type_size_t" "$ac_includes_default"
-if test "x$ac_cv_type_size_t" = x""yes; then :
+if test "x$ac_cv_type_size_t" = xyes; then :
 
 else
 
@@ -9915,7 +10179,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for uid_t in sys/types.h" >&5
 $as_echo_n "checking for uid_t in sys/types.h... " >&6; }
-if test "${ac_cv_type_uid_t+set}" = set; then :
+if ${ac_cv_type_uid_t+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9960,7 +10224,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether time.h and sys/time.h may both be included" >&5
 $as_echo_n "checking whether time.h and sys/time.h may both be included... " >&6; }
-if test "${ac_cv_header_time+set}" = set; then :
+if ${ac_cv_header_time+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9994,7 +10258,7 @@
 fi
 
 ac_fn_c_check_type "$LINENO" "ino_t" "ac_cv_type_ino_t" "$ac_includes_default"
-if test "x$ac_cv_type_ino_t" = x""yes; then :
+if test "x$ac_cv_type_ino_t" = xyes; then :
 
 else
 
@@ -10005,7 +10269,7 @@
 fi
 
 ac_fn_c_check_type "$LINENO" "dev_t" "ac_cv_type_dev_t" "$ac_includes_default"
-if test "x$ac_cv_type_dev_t" = x""yes; then :
+if test "x$ac_cv_type_dev_t" = xyes; then :
 
 else
 
@@ -10017,7 +10281,7 @@
 
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian" >&5
 $as_echo_n "checking whether byte ordering is bigendian... " >&6; }
-if test "${ac_cv_c_bigendian+set}" = set; then :
+if ${ac_cv_c_bigendian+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_c_bigendian=unknown
@@ -10235,7 +10499,7 @@
 
      ;; #(
    *)
-     as_fn_error "unknown endianness
+     as_fn_error $? "unknown endianness
  presetting ac_cv_c_bigendian=no (or yes) will help" "$LINENO" 5 ;;
  esac
 
@@ -10371,7 +10635,7 @@
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: OK" >&5
 $as_echo "OK" >&6; }
 else
-  as_fn_error "FAILED" "$LINENO" 5
+  as_fn_error $? "FAILED" "$LINENO" 5
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
@@ -10387,7 +10651,7 @@
     as_ac_Lib=`$as_echo "ac_cv_lib_${libname}''_tgetent" | $as_tr_sh`
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for tgetent in -l${libname}" >&5
 $as_echo_n "checking for tgetent in -l${libname}... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval \${$as_ac_Lib+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -10422,8 +10686,7 @@
 eval ac_res=\$$as_ac_Lib
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_LIB${libname}" | $as_tr_cpp` 1
 _ACEOF
@@ -10489,7 +10752,7 @@
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 else
-  as_fn_error "NOT FOUND!
+  as_fn_error $? "NOT FOUND!
       You need to install a terminal library; for example ncurses.
       Or specify the name of the library with --with-tlib." "$LINENO" 5
 fi
@@ -10499,13 +10762,13 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we talk terminfo" >&5
 $as_echo_n "checking whether we talk terminfo... " >&6; }
-if test "${vim_cv_terminfo+set}" = set; then :
+if ${vim_cv_terminfo+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
     if test "$cross_compiling" = yes; then :
 
-      as_fn_error "cross-compiling: please set 'vim_cv_terminfo'" "$LINENO" 5
+      as_fn_error $? "cross-compiling: please set 'vim_cv_terminfo'" "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -10552,13 +10815,13 @@
 if test "x$olibs" != "x$LIBS"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking what tgetent() returns for an unknown terminal" >&5
 $as_echo_n "checking what tgetent() returns for an unknown terminal... " >&6; }
-if test "${vim_cv_tgent+set}" = set; then :
+if ${vim_cv_tgent+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
       if test "$cross_compiling" = yes; then :
 
-	as_fn_error "failed to compile test program." "$LINENO" 5
+	as_fn_error $? "failed to compile test program." "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -10853,13 +11116,13 @@
 rm -f conftest_grp
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking default tty permissions/group" >&5
 $as_echo_n "checking default tty permissions/group... " >&6; }
-if test "${vim_cv_tty_group+set}" = set; then :
+if ${vim_cv_tty_group+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
     if test "$cross_compiling" = yes; then :
 
-      as_fn_error "cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode'" "$LINENO" 5
+      as_fn_error $? "cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode'" "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -10940,7 +11203,7 @@
 _ACEOF
 
   if test "x$vim_cv_tty_mode" = "x" ; then
-    as_fn_error "It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)" "$LINENO" 5
+    as_fn_error $? "It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)" "$LINENO" 5
   else
     $as_echo "#define PTYMODE 0620" >>confdefs.h
 
@@ -10950,7 +11213,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking return type of signal handlers" >&5
 $as_echo_n "checking return type of signal handlers... " >&6; }
-if test "${ac_cv_type_signal+set}" = set; then :
+if ${ac_cv_type_signal+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11023,13 +11286,13 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking getcwd implementation is broken" >&5
 $as_echo_n "checking getcwd implementation is broken... " >&6; }
-if test "${vim_cv_getcwd_broken+set}" = set; then :
+if ${vim_cv_getcwd_broken+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
     if test "$cross_compiling" = yes; then :
 
-      as_fn_error "cross-compiling: please set 'vim_cv_getcwd_broken'" "$LINENO" 5
+      as_fn_error $? "cross-compiling: please set 'vim_cv_getcwd_broken'" "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11082,8 +11345,7 @@
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -11093,7 +11355,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGEFILE_SOURCE value needed for large files" >&5
 $as_echo_n "checking for _LARGEFILE_SOURCE value needed for large files... " >&6; }
-if test "${ac_cv_sys_largefile_source+set}" = set; then :
+if ${ac_cv_sys_largefile_source+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   while :; do
@@ -11169,7 +11431,7 @@
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
 $as_echo_n "checking for special C compiler options needed for large files... " >&6; }
-if test "${ac_cv_sys_largefile_CC+set}" = set; then :
+if ${ac_cv_sys_largefile_CC+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_sys_largefile_CC=no
@@ -11185,7 +11447,7 @@
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -11220,7 +11482,7 @@
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
 $as_echo_n "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
-if test "${ac_cv_sys_file_offset_bits+set}" = set; then :
+if ${ac_cv_sys_file_offset_bits+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   while :; do
@@ -11231,7 +11493,7 @@
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -11255,7 +11517,7 @@
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -11289,7 +11551,7 @@
   if test $ac_cv_sys_file_offset_bits = unknown; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
 $as_echo_n "checking for _LARGE_FILES value needed for large files... " >&6; }
-if test "${ac_cv_sys_large_files+set}" = set; then :
+if ${ac_cv_sys_large_files+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   while :; do
@@ -11300,7 +11562,7 @@
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -11324,7 +11586,7 @@
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -11356,6 +11618,8 @@
 esac
 rm -rf conftest*
   fi
+
+
 fi
 
 
@@ -11389,13 +11653,13 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stat() ignores a trailing slash" >&5
 $as_echo_n "checking whether stat() ignores a trailing slash... " >&6; }
-if test "${vim_cv_stat_ignores_slash+set}" = set; then :
+if ${vim_cv_stat_ignores_slash+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
     if test "$cross_compiling" = yes; then :
 
-      as_fn_error "cross-compiling: please set 'vim_cv_stat_ignores_slash'" "$LINENO" 5
+      as_fn_error $? "cross-compiling: please set 'vim_cv_stat_ignores_slash'" "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11519,7 +11783,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for strtod in -lm" >&5
 $as_echo_n "checking for strtod in -lm... " >&6; }
-if test "${ac_cv_lib_m_strtod+set}" = set; then :
+if ${ac_cv_lib_m_strtod+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -11553,7 +11817,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_strtod" >&5
 $as_echo "$ac_cv_lib_m_strtod" >&6; }
-if test "x$ac_cv_lib_m_strtod" = x""yes; then :
+if test "x$ac_cv_lib_m_strtod" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBM 1
 _ACEOF
@@ -11619,7 +11883,7 @@
 $as_echo "no" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for acl_get_file in -lposix1e" >&5
 $as_echo_n "checking for acl_get_file in -lposix1e... " >&6; }
-if test "${ac_cv_lib_posix1e_acl_get_file+set}" = set; then :
+if ${ac_cv_lib_posix1e_acl_get_file+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -11653,12 +11917,12 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_posix1e_acl_get_file" >&5
 $as_echo "$ac_cv_lib_posix1e_acl_get_file" >&6; }
-if test "x$ac_cv_lib_posix1e_acl_get_file" = x""yes; then :
+if test "x$ac_cv_lib_posix1e_acl_get_file" = xyes; then :
   LIBS="$LIBS -lposix1e"
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for acl_get_file in -lacl" >&5
 $as_echo_n "checking for acl_get_file in -lacl... " >&6; }
-if test "${ac_cv_lib_acl_acl_get_file+set}" = set; then :
+if ${ac_cv_lib_acl_acl_get_file+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -11692,11 +11956,11 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_acl_acl_get_file" >&5
 $as_echo "$ac_cv_lib_acl_acl_get_file" >&6; }
-if test "x$ac_cv_lib_acl_acl_get_file" = x""yes; then :
+if test "x$ac_cv_lib_acl_acl_get_file" = xyes; then :
   LIBS="$LIBS -lacl"
 		  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgetxattr in -lattr" >&5
 $as_echo_n "checking for fgetxattr in -lattr... " >&6; }
-if test "${ac_cv_lib_attr_fgetxattr+set}" = set; then :
+if ${ac_cv_lib_attr_fgetxattr+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -11730,7 +11994,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_attr_fgetxattr" >&5
 $as_echo "$ac_cv_lib_attr_fgetxattr" >&6; }
-if test "x$ac_cv_lib_attr_fgetxattr" = x""yes; then :
+if test "x$ac_cv_lib_attr_fgetxattr" = xyes; then :
   LIBS="$LIBS -lattr"
 fi
 
@@ -11772,7 +12036,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for acl_get in -lsec" >&5
 $as_echo_n "checking for acl_get in -lsec... " >&6; }
-if test "${ac_cv_lib_sec_acl_get+set}" = set; then :
+if ${ac_cv_lib_sec_acl_get+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -11806,7 +12070,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sec_acl_get" >&5
 $as_echo "$ac_cv_lib_sec_acl_get" >&6; }
-if test "x$ac_cv_lib_sec_acl_get" = x""yes; then :
+if test "x$ac_cv_lib_sec_acl_get" = xyes; then :
   LIBS="$LIBS -lsec"; $as_echo "#define HAVE_SOLARIS_ZFS_ACL 1" >>confdefs.h
 
 else
@@ -11902,7 +12166,7 @@
 $as_echo "no" >&6; }
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gpm" >&5
 $as_echo_n "checking for gpm... " >&6; }
-if test "${vi_cv_have_gpm+set}" = set; then :
+if ${vi_cv_have_gpm+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   olibs="$LIBS" ; LIBS="-lgpm"
@@ -11955,7 +12219,7 @@
 $as_echo "no" >&6; }
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysmouse" >&5
 $as_echo_n "checking for sysmouse... " >&6; }
-if test "${vi_cv_have_sysmouse+set}" = set; then :
+if ${vi_cv_have_sysmouse+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12161,7 +12425,7 @@
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of int" >&5
 $as_echo_n "checking size of int... " >&6; }
-if test "${ac_cv_sizeof_int+set}" = set; then :
+if ${ac_cv_sizeof_int+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int))" "ac_cv_sizeof_int"        "$ac_includes_default"; then :
@@ -12170,9 +12434,8 @@
   if test "$ac_cv_type_int" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (int)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (int)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_int=0
    fi
@@ -12195,7 +12458,7 @@
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long" >&5
 $as_echo_n "checking size of long... " >&6; }
-if test "${ac_cv_sizeof_long+set}" = set; then :
+if ${ac_cv_sizeof_long+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long))" "ac_cv_sizeof_long"        "$ac_includes_default"; then :
@@ -12204,9 +12467,8 @@
   if test "$ac_cv_type_long" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (long)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (long)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_long=0
    fi
@@ -12229,7 +12491,7 @@
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of time_t" >&5
 $as_echo_n "checking size of time_t... " >&6; }
-if test "${ac_cv_sizeof_time_t+set}" = set; then :
+if ${ac_cv_sizeof_time_t+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (time_t))" "ac_cv_sizeof_time_t"        "$ac_includes_default"; then :
@@ -12238,9 +12500,8 @@
   if test "$ac_cv_type_time_t" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (time_t)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (time_t)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_time_t=0
    fi
@@ -12263,7 +12524,7 @@
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of off_t" >&5
 $as_echo_n "checking size of off_t... " >&6; }
-if test "${ac_cv_sizeof_off_t+set}" = set; then :
+if ${ac_cv_sizeof_off_t+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (off_t))" "ac_cv_sizeof_off_t"        "$ac_includes_default"; then :
@@ -12272,9 +12533,8 @@
   if test "$ac_cv_type_off_t" = yes; then
      { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "cannot compute sizeof (off_t)
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "cannot compute sizeof (off_t)
+See \`config.log' for more details" "$LINENO" 5; }
    else
      ac_cv_sizeof_off_t=0
    fi
@@ -12292,6 +12552,15 @@
 
 
 
+cat >>confdefs.h <<_ACEOF
+#define VIM_SIZEOF_INT $ac_cv_sizeof_int
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define VIM_SIZEOF_LONG $ac_cv_sizeof_long
+_ACEOF
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking uint32_t is 32 bits" >&5
 $as_echo_n "checking uint32_t is 32 bits... " >&6; }
 if test "$cross_compiling" = yes; then :
@@ -12318,7 +12587,7 @@
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
 $as_echo "ok" >&6; }
 else
-  as_fn_error "WRONG!  uint32_t not defined correctly." "$LINENO" 5
+  as_fn_error $? "WRONG!  uint32_t not defined correctly." "$LINENO" 5
 fi
 rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
   conftest.$ac_objext conftest.beam conftest.$ac_ext
@@ -12350,13 +12619,13 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether memmove handles overlaps" >&5
 $as_echo_n "checking whether memmove handles overlaps... " >&6; }
-if test "${vim_cv_memmove_handles_overlap+set}" = set; then :
+if ${vim_cv_memmove_handles_overlap+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
     if test "$cross_compiling" = yes; then :
 
-	as_fn_error "cross-compiling: please set 'vim_cv_memmove_handles_overlap'" "$LINENO" 5
+	as_fn_error $? "cross-compiling: please set 'vim_cv_memmove_handles_overlap'" "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12387,13 +12656,13 @@
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether bcopy handles overlaps" >&5
 $as_echo_n "checking whether bcopy handles overlaps... " >&6; }
-if test "${vim_cv_bcopy_handles_overlap+set}" = set; then :
+if ${vim_cv_bcopy_handles_overlap+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
       if test "$cross_compiling" = yes; then :
 
-	as_fn_error "cross-compiling: please set 'vim_cv_bcopy_handles_overlap'" "$LINENO" 5
+	as_fn_error $? "cross-compiling: please set 'vim_cv_bcopy_handles_overlap'" "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12424,13 +12693,13 @@
   else
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether memcpy handles overlaps" >&5
 $as_echo_n "checking whether memcpy handles overlaps... " >&6; }
-if test "${vim_cv_memcpy_handles_overlap+set}" = set; then :
+if ${vim_cv_memcpy_handles_overlap+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
 	if test "$cross_compiling" = yes; then :
 
-	    as_fn_error "cross-compiling: please set 'vim_cv_memcpy_handles_overlap'" "$LINENO" 5
+	    as_fn_error $? "cross-compiling: please set 'vim_cv_memcpy_handles_overlap'" "$LINENO" 5
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12525,7 +12794,7 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _xpg4_setrunelocale in -lxpg4" >&5
 $as_echo_n "checking for _xpg4_setrunelocale in -lxpg4... " >&6; }
-if test "${ac_cv_lib_xpg4__xpg4_setrunelocale+set}" = set; then :
+if ${ac_cv_lib_xpg4__xpg4_setrunelocale+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -12559,7 +12828,7 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xpg4__xpg4_setrunelocale" >&5
 $as_echo "$ac_cv_lib_xpg4__xpg4_setrunelocale" >&6; }
-if test "x$ac_cv_lib_xpg4__xpg4_setrunelocale" = x""yes; then :
+if test "x$ac_cv_lib_xpg4__xpg4_setrunelocale" = xyes; then :
   LIBS="$LIBS -lxpg4"
 fi
 
@@ -12621,7 +12890,7 @@
 set dummy msgfmt; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_MSGFMT+set}" = set; then :
+if ${ac_cv_prog_MSGFMT+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$MSGFMT"; then
@@ -12633,7 +12902,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_MSGFMT="msgfmt"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
@@ -12659,6 +12928,8 @@
   if test -f po/Makefile; then
     have_gettext="no"
     if test -n "$MSGFMT"; then
+      olibs=$LIBS
+      LIBS=""
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <libintl.h>
@@ -12672,10 +12943,9 @@
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: gettext() works" >&5
-$as_echo "gettext() works" >&6; }; have_gettext="yes"
+$as_echo "gettext() works" >&6; }; have_gettext="yes"; LIBS=$olibs
 else
-  olibs=$LIBS
-	  LIBS="$LIBS -lintl"
+  LIBS="-lintl"
 	  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <libintl.h>
@@ -12689,7 +12959,8 @@
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: gettext() works with -lintl" >&5
-$as_echo "gettext() works with -lintl" >&6; }; have_gettext="yes"
+$as_echo "gettext() works with -lintl" >&6; }; have_gettext="yes";
+	      LIBS="$olibs -lintl"
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: gettext() doesn't work" >&5
 $as_echo "gettext() doesn't work" >&6; };
@@ -12704,7 +12975,7 @@
       { $as_echo "$as_me:${as_lineno-$LINENO}: result: msgfmt not found - disabled" >&5
 $as_echo "msgfmt not found - disabled" >&6; };
     fi
-    if test $have_gettext = "yes"; then
+    if test $have_gettext = "yes" -a "x$features" != "xtiny" -a "x$features" != "xsmall"; then
       $as_echo "#define HAVE_GETTEXT 1" >>confdefs.h
 
       MAKEMO=yes
@@ -12712,7 +12983,7 @@
             for ac_func in bind_textdomain_codeset
 do :
   ac_fn_c_check_func "$LINENO" "bind_textdomain_codeset" "ac_cv_func_bind_textdomain_codeset"
-if test "x$ac_cv_func_bind_textdomain_codeset" = x""yes; then :
+if test "x$ac_cv_func_bind_textdomain_codeset" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_BIND_TEXTDOMAIN_CODESET 1
 _ACEOF
@@ -12755,11 +13026,11 @@
 fi
 
 ac_fn_c_check_header_mongrel "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default"
-if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
+if test "x$ac_cv_header_dlfcn_h" = xyes; then :
   DLL=dlfcn.h
 else
   ac_fn_c_check_header_mongrel "$LINENO" "dl.h" "ac_cv_header_dl_h" "$ac_includes_default"
-if test "x$ac_cv_header_dl_h" = x""yes; then :
+if test "x$ac_cv_header_dl_h" = xyes; then :
   DLL=dl.h
 fi
 
@@ -12956,7 +13227,7 @@
 for ac_header in setjmp.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "setjmp.h" "ac_cv_header_setjmp_h" "$ac_includes_default"
-if test "x$ac_cv_header_setjmp_h" = x""yes; then :
+if test "x$ac_cv_header_setjmp_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SETJMP_H 1
 _ACEOF
@@ -13107,10 +13378,21 @@
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
+    if test "x$cache_file" != "x/dev/null"; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
 $as_echo "$as_me: updating cache $cache_file" >&6;}
-    cat confcache >$cache_file
+      if test ! -f "$cache_file" || test -h "$cache_file"; then
+	cat confcache >"$cache_file"
+      else
+        case $cache_file in #(
+        */* | ?:*)
+	  mv -f confcache "$cache_file"$$ &&
+	  mv -f "$cache_file"$$ "$cache_file" ;; #(
+        *)
+	  mv -f confcache "$cache_file" ;;
+	esac
+      fi
+    fi
   else
     { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
 $as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
@@ -13126,6 +13408,7 @@
 
 ac_libobjs=
 ac_ltlibobjs=
+U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
@@ -13142,7 +13425,7 @@
 
 
 
-: ${CONFIG_STATUS=./config.status}
+: "${CONFIG_STATUS=./config.status}"
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
@@ -13243,6 +13526,7 @@
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -13288,19 +13572,19 @@
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
+# script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $1" >&2
+  $as_echo "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -13438,16 +13722,16 @@
     # ... but there are two gotchas:
     # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
     # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
+    # In both cases, we have to default to `cp -pR'.
     ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
+      as_ln_s='cp -pR'
   elif ln conf$$.file conf$$ 2>/dev/null; then
     as_ln_s=ln
   else
-    as_ln_s='cp -p'
+    as_ln_s='cp -pR'
   fi
 else
-  as_ln_s='cp -p'
+  as_ln_s='cp -pR'
 fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
@@ -13496,7 +13780,7 @@
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -13507,28 +13791,16 @@
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -13550,7 +13822,7 @@
 # values after options handling.
 ac_log="
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.65.  Invocation command line was
+generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -13612,10 +13884,10 @@
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.65,
+configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2009 Free Software Foundation, Inc.
+Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -13631,11 +13903,16 @@
 while test $# != 0
 do
   case $1 in
-  --*=*)
+  --*=?*)
     ac_option=`expr "X$1" : 'X\([^=]*\)='`
     ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
     ac_shift=:
     ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
   *)
     ac_option=$1
     ac_optarg=$2
@@ -13657,6 +13934,7 @@
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
@@ -13669,7 +13947,7 @@
     ac_need_defaults=false;;
   --he | --h)
     # Conflict between --help and --header
-    as_fn_error "ambiguous option: \`$1'
+    as_fn_error $? "ambiguous option: \`$1'
 Try \`$0 --help' for more information.";;
   --help | --hel | -h )
     $as_echo "$ac_cs_usage"; exit ;;
@@ -13678,7 +13956,7 @@
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) as_fn_error "unrecognized option: \`$1'
+  -*) as_fn_error $? "unrecognized option: \`$1'
 Try \`$0 --help' for more information." ;;
 
   *) as_fn_append ac_config_targets " $1"
@@ -13698,7 +13976,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
   \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
@@ -13730,7 +14008,7 @@
     "auto/config.h") CONFIG_HEADERS="$CONFIG_HEADERS auto/config.h:config.h.in" ;;
     "auto/config.mk") CONFIG_FILES="$CONFIG_FILES auto/config.mk:config.mk.in" ;;
 
-  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
@@ -13752,9 +14030,10 @@
 # after its creation but before its name has been assigned to `$tmp'.
 $debug ||
 {
-  tmp=
+  tmp= ac_tmp=
   trap 'exit_status=$?
-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+  : "${ac_tmp:=$tmp}"
+  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
 ' 0
   trap 'as_fn_exit 1' 1 2 13 15
 }
@@ -13762,12 +14041,13 @@
 
 {
   tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -n "$tmp" && test -d "$tmp"
+  test -d "$tmp"
 }  ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
-} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+ac_tmp=$tmp
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -13784,12 +14064,12 @@
 fi
 ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
 if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\r'
+  ac_cs_awk_cr='\\r'
 else
   ac_cs_awk_cr=$ac_cr
 fi
 
-echo 'BEGIN {' >"$tmp/subs1.awk" &&
+echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
 _ACEOF
 
 
@@ -13798,18 +14078,18 @@
   echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
   echo "_ACEOF"
 } >conf$$subs.sh ||
-  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   . ./conf$$subs.sh ||
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
 
   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
   if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -13817,7 +14097,7 @@
 rm -f conf$$subs.sh
 
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
 _ACEOF
 sed -n '
 h
@@ -13865,7 +14145,7 @@
 rm -f conf$$subs.awk
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACAWK
-cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
   for (key in S) S_is_set[key] = 1
   FS = ""
 
@@ -13897,21 +14177,29 @@
   sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
 else
   cat
-fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
 s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
 s/^[^=]*=[	 ]*$//
 }'
 fi
@@ -13923,7 +14211,7 @@
 # No need to generate them if there are no CONFIG_HEADERS.
 # This happens for instance with `./config.status Makefile'.
 if test -n "$CONFIG_HEADERS"; then
-cat >"$tmp/defines.awk" <<\_ACAWK ||
+cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
 BEGIN {
 _ACEOF
 
@@ -13935,11 +14223,11 @@
 # handling of long lines.
 ac_delim='%!_!# '
 for ac_last_try in false false :; do
-  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
-  if test -z "$ac_t"; then
+  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_tt"; then
     break
   elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -14024,7 +14312,7 @@
 _ACAWK
 _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-  as_fn_error "could not setup config headers machinery" "$LINENO" 5
+  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
 fi # test -n "$CONFIG_HEADERS"
 
 
@@ -14037,7 +14325,7 @@
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -14056,7 +14344,7 @@
     for ac_f
     do
       case $ac_f in
-      -) ac_f="$tmp/stdin";;
+      -) ac_f="$ac_tmp/stdin";;
       *) # Look for the file first in the build tree, then in the source tree
 	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
 	 # because $ac_f cannot contain `:'.
@@ -14065,7 +14353,7 @@
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
@@ -14091,8 +14379,8 @@
     esac
 
     case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
+    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
     esac
     ;;
   esac
@@ -14217,23 +14505,24 @@
 s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
 $ac_datarootdir_hack
 "
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
+  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
+      "$ac_tmp/out"`; test -z "$ac_out"; } &&
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
+which seems to be undefined.  Please make sure it is defined" >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
+which seems to be undefined.  Please make sure it is defined" >&2;}
 
-  rm -f "$tmp/stdin"
+  rm -f "$ac_tmp/stdin"
   case $ac_file in
-  -) cat "$tmp/out" && rm -f "$tmp/out";;
-  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
+  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
   esac \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
  ;;
   :H)
   #
@@ -14242,21 +14531,21 @@
   if test x"$ac_file" != x-; then
     {
       $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
-    } >"$tmp/config.h" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5
-    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
+    } >"$ac_tmp/config.h" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
 $as_echo "$as_me: $ac_file is unchanged" >&6;}
     else
       rm -f "$ac_file"
-      mv "$tmp/config.h" "$ac_file" \
-	|| as_fn_error "could not create $ac_file" "$LINENO" 5
+      mv "$ac_tmp/config.h" "$ac_file" \
+	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
     fi
   else
     $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
-      || as_fn_error "could not create -" "$LINENO" 5
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error $? "could not create -" "$LINENO" 5
   fi
  ;;
 
@@ -14271,7 +14560,7 @@
 ac_clean_files=$ac_clean_files_save
 
 test $ac_write_fail = 0 ||
-  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
 
 
 # configure is writing to config.log, and then calls config.status.
@@ -14292,7 +14581,7 @@
   exec 5>>auto/config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit $?
+  $ac_cs_success || as_fn_exit 1
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
diff -Naur vim74.orig/src/blowfish.c vim74/src/blowfish.c
--- vim74.orig/src/blowfish.c	2010-12-17 18:58:18.000000000 +0000
+++ vim74/src/blowfish.c	2014-10-10 14:53:44.195380924 +0000
@@ -6,20 +6,28 @@
  * Do ":help credits" in Vim to see a list of people who contributed.
  * See README.txt for an overview of the Vim source code.
  *
- * Blowfish encryption for Vim; in Blowfish output feedback mode.
+ * Blowfish encryption for Vim; in Blowfish cipher feedback mode.
  * Contributed by Mohsin Ahmed, http://www.cs.albany.edu/~mosh
  * Based on http://www.schneier.com/blowfish.html by Bruce Schneier.
+ *
+ * There are two variants:
+ * - The old one "blowfish" has a flaw which makes it much easier to crack the
+ *   key.  To see this, make a text file with one line of 1000 "x" characters
+ *   and write it encrypted.  Use "xxd" to inspect the bytes in the file.  You
+ *   will see that a block of 8 bytes repeats 8 times.
+ * - The new one "blowfish2" is better.  It uses an 8 byte CFB to avoid the
+ *   repeats.
  */
 
 #include "vim.h"
 
-#if defined(FEAT_CRYPT)
+#if defined(FEAT_CRYPT) || defined(PROTO)
 
 #define ARRAY_LENGTH(A)      (sizeof(A)/sizeof(A[0]))
 
 #define BF_BLOCK    8
 #define BF_BLOCK_MASK 7
-#define BF_OFB_LEN  (8*(BF_BLOCK))
+#define BF_MAX_CFB_LEN  (8 * BF_BLOCK)
 
 typedef union {
     UINT32_T ul[2];
@@ -37,14 +45,26 @@
 # endif
 #endif
 
-static void bf_e_block __ARGS((UINT32_T *p_xl, UINT32_T *p_xr));
-static void bf_e_cblock __ARGS((char_u *block));
-static int bf_check_tables __ARGS((UINT32_T a_ipa[18], UINT32_T a_sbi[4][256], UINT32_T val));
+/* The state of encryption, referenced by cryptstate_T. */
+typedef struct {
+    UINT32_T	pax[18];	    /* P-array */
+    UINT32_T	sbx[4][256];	    /* S-boxes */
+    int		randbyte_offset;
+    int		update_offset;
+    char_u	cfb_buffer[BF_MAX_CFB_LEN]; /* up to 64 bytes used */
+    int		cfb_len;	    /* size of cfb_buffer actually used */
+} bf_state_T;
+
+
+static void bf_e_block __ARGS((bf_state_T *state, UINT32_T *p_xl, UINT32_T *p_xr));
+static void bf_e_cblock __ARGS((bf_state_T *state, char_u *block));
+static int bf_check_tables __ARGS((UINT32_T pax[18], UINT32_T sbx[4][256], UINT32_T val));
 static int bf_self_test __ARGS((void));
+static void bf_key_init __ARGS((bf_state_T *state, char_u *password, char_u *salt, int salt_len));
+static void bf_cfb_init __ARGS((bf_state_T *state, char_u *seed, int seed_len));
 
 /* Blowfish code */
-static UINT32_T pax[18];
-static UINT32_T ipa[18] = {
+static UINT32_T pax_init[18] = {
     0x243f6a88u, 0x85a308d3u, 0x13198a2eu,
     0x03707344u, 0xa4093822u, 0x299f31d0u,
     0x082efa98u, 0xec4e6c89u, 0x452821e6u,
@@ -53,8 +73,7 @@
     0xb5470917u, 0x9216d5d9u, 0x8979fb1bu
 };
 
-static UINT32_T sbx[4][256];
-static UINT32_T sbi[4][256] = {
+static UINT32_T sbx_init[4][256] = {
    {0xd1310ba6u, 0x98dfb5acu, 0x2ffd72dbu, 0xd01adfb7u,
     0xb8e1afedu, 0x6a267e96u, 0xba7c9045u, 0xf12c7f99u,
     0x24a19947u, 0xb3916cf7u, 0x0801f2e2u, 0x858efc16u,
@@ -314,33 +333,40 @@
  }
 };
 
-
 #define F1(i) \
-    xl ^= pax[i]; \
-    xr ^= ((sbx[0][xl >> 24] + \
-    sbx[1][(xl & 0xFF0000) >> 16]) ^ \
-    sbx[2][(xl & 0xFF00) >> 8]) + \
-    sbx[3][xl & 0xFF];
+    xl ^= bfs->pax[i]; \
+    xr ^= ((bfs->sbx[0][xl >> 24] + \
+    bfs->sbx[1][(xl & 0xFF0000) >> 16]) ^ \
+    bfs->sbx[2][(xl & 0xFF00) >> 8]) + \
+    bfs->sbx[3][xl & 0xFF];
 
 #define F2(i) \
-    xr ^= pax[i]; \
-    xl ^= ((sbx[0][xr >> 24] + \
-    sbx[1][(xr & 0xFF0000) >> 16]) ^ \
-    sbx[2][(xr & 0xFF00) >> 8]) + \
-    sbx[3][xr & 0xFF];
-
+    xr ^= bfs->pax[i]; \
+    xl ^= ((bfs->sbx[0][xr >> 24] + \
+    bfs->sbx[1][(xr & 0xFF0000) >> 16]) ^ \
+    bfs->sbx[2][(xr & 0xFF00) >> 8]) + \
+    bfs->sbx[3][xr & 0xFF];
 
     static void
-bf_e_block(p_xl, p_xr)
+bf_e_block(bfs, p_xl, p_xr)
+    bf_state_T *bfs;
     UINT32_T *p_xl;
     UINT32_T *p_xr;
 {
-    UINT32_T temp, xl = *p_xl, xr = *p_xr;
-
-    F1(0) F2(1) F1(2) F2(3) F1(4) F2(5) F1(6) F2(7)
-    F1(8) F2(9) F1(10) F2(11) F1(12) F2(13) F1(14) F2(15)
-    xl ^= pax[16];
-    xr ^= pax[17];
+    UINT32_T temp;
+    UINT32_T xl = *p_xl;
+    UINT32_T xr = *p_xr;
+
+    F1(0) F2(1)
+    F1(2) F2(3)
+    F1(4) F2(5)
+    F1(6) F2(7)
+    F1(8) F2(9)
+    F1(10) F2(11)
+    F1(12) F2(13)
+    F1(14) F2(15)
+    xl ^= bfs->pax[16];
+    xr ^= bfs->pax[17];
     temp = xl;
     xl = xr;
     xr = temp;
@@ -348,22 +374,6 @@
     *p_xr = xr;
 }
 
-#if 0  /* not used */
-    static void
-bf_d_block(p_xl, p_xr)
-    UINT32_T *p_xl;
-    UINT32_T *p_xr;
-{
-    UINT32_T temp, xl = *p_xl, xr = *p_xr;
-    F1(17) F2(16) F1(15) F2(14) F1(13) F2(12) F1(11) F2(10)
-    F1(9) F2(8) F1(7) F2(6) F1(5) F2(4) F1(3) F2(2)
-    xl ^= pax[1];
-    xr ^= pax[0];
-    temp = xl; xl = xr; xr = temp;
-    *p_xl = xl; *p_xr = xr;
-}
-#endif
-
 
 #ifdef WORDS_BIGENDIAN
 # define htonl2(x) \
@@ -374,7 +384,8 @@
 #endif
 
     static void
-bf_e_cblock(block)
+bf_e_cblock(bfs, block)
+    bf_state_T *bfs;
     char_u *block;
 {
     block8	bk;
@@ -382,35 +393,22 @@
     memcpy(bk.uc, block, 8);
     htonl2(bk.ul[0]);
     htonl2(bk.ul[1]);
-    bf_e_block(&bk.ul[0], &bk.ul[1]);
+    bf_e_block(bfs, &bk.ul[0], &bk.ul[1]);
     htonl2(bk.ul[0]);
     htonl2(bk.ul[1]);
     memcpy(block, bk.uc, 8);
 }
 
-#if 0  /* not used */
-    void
-bf_d_cblock(block)
-    char_u *block;
-{
-    block8 bk;
-    memcpy(bk.uc, block, 8);
-    htonl2(bk.ul[0]); htonl2(bk.ul[1]);
-    bf_d_block(&bk.ul[0], &bk.ul[1]);
-    htonl2(bk.ul[0]); htonl2(bk.ul[1]);
-    memcpy(block, bk.uc, 8);
-}
-#endif
-
 /*
  * Initialize the crypt method using "password" as the encryption key and
  * "salt[salt_len]" as the salt.
  */
-    void
-bf_key_init(password, salt, salt_len)
-    char_u *password;
-    char_u *salt;
-    int    salt_len;
+    static void
+bf_key_init(bfs, password, salt, salt_len)
+    bf_state_T	*bfs;
+    char_u	*password;
+    char_u	*salt;
+    int		salt_len;
 {
     int      i, j, keypos = 0;
     unsigned u;
@@ -418,7 +416,7 @@
     char_u   *key;
     int      keylen;
 
-    /* Process the key 1000 times.
+    /* Process the key 1001 times.
      * See http://en.wikipedia.org/wiki/Key_strengthening. */
     key = sha256_key(password, salt, salt_len);
     for (i = 0; i < 1000; i++)
@@ -437,52 +435,54 @@
 	key[i] = u;
     }
 
-    mch_memmove(sbx, sbi, 4 * 4 * 256);
+    /* Use "key" to initialize the P-array ("pax") and S-boxes ("sbx") of
+     * Blowfish. */
+    mch_memmove(bfs->sbx, sbx_init, 4 * 4 * 256);
 
     for (i = 0; i < 18; ++i)
     {
 	val = 0;
 	for (j = 0; j < 4; ++j)
 	    val = (val << 8) | key[keypos++ % keylen];
-	pax[i] = ipa[i] ^ val;
+	bfs->pax[i] = pax_init[i] ^ val;
     }
 
     data_l = data_r = 0;
     for (i = 0; i < 18; i += 2)
     {
-	bf_e_block(&data_l, &data_r);
-	pax[i + 0] = data_l;
-	pax[i + 1] = data_r;
+	bf_e_block(bfs, &data_l, &data_r);
+	bfs->pax[i + 0] = data_l;
+	bfs->pax[i + 1] = data_r;
     }
 
     for (i = 0; i < 4; ++i)
     {
 	for (j = 0; j < 256; j += 2)
 	{
-	    bf_e_block(&data_l, &data_r);
-	    sbx[i][j + 0] = data_l;
-	    sbx[i][j + 1] = data_r;
+	    bf_e_block(bfs, &data_l, &data_r);
+	    bfs->sbx[i][j + 0] = data_l;
+	    bfs->sbx[i][j + 1] = data_r;
 	}
     }
 }
 
 /*
- * BF Self test for corrupted tables or instructions
+ * Blowfish self-test for corrupted tables or instructions.
  */
     static int
-bf_check_tables(a_ipa, a_sbi, val)
-    UINT32_T a_ipa[18];
-    UINT32_T a_sbi[4][256];
+bf_check_tables(pax, sbx, val)
+    UINT32_T pax[18];
+    UINT32_T sbx[4][256];
     UINT32_T val;
 {
     int i, j;
     UINT32_T c = 0;
 
     for (i = 0; i < 18; i++)
-	c ^= a_ipa[i];
+	c ^= pax[i];
     for (i = 0; i < 4; i++)
 	for (j = 0; j < 256; j++)
-	    c ^= a_sbi[i][j];
+	    c ^= sbx[i][j];
     return c == val;
 }
 
@@ -520,6 +520,10 @@
     int    err = 0;
     block8 bk;
     UINT32_T ui = 0xffffffffUL;
+    bf_state_T state;
+
+    vim_memset(&state, 0, sizeof(bf_state_T));
+    state.cfb_len = BF_MAX_CFB_LEN;
 
     /* We can't simply use sizeof(UINT32_T), it would generate a compiler
      * warning. */
@@ -528,21 +532,21 @@
 	EMSG(_("E820: sizeof(uint32_t) != 4"));
     }
 
-    if (!bf_check_tables(ipa, sbi, 0x6ffa520a))
+    if (!bf_check_tables(pax_init, sbx_init, 0x6ffa520a))
 	err++;
 
     bn = ARRAY_LENGTH(bf_test_data);
     for (i = 0; i < bn; i++)
     {
-	bf_key_init((char_u *)(bf_test_data[i].password),
+	bf_key_init(&state, (char_u *)(bf_test_data[i].password),
 		    bf_test_data[i].salt,
 		    (int)STRLEN(bf_test_data[i].salt));
-	if (!bf_check_tables(pax, sbx, bf_test_data[i].keysum))
+	if (!bf_check_tables(state.pax, state.sbx, bf_test_data[i].keysum))
 	    err++;
 
 	/* Don't modify bf_test_data[i].plaintxt, self test is idempotent. */
 	memcpy(bk.uc, bf_test_data[i].plaintxt, 8);
-	bf_e_cblock(bk.uc);
+	bf_e_cblock(&state, bk.uc);
 	if (memcmp(bk.uc, bf_test_data[i].cryptxt, 8) != 0)
 	{
 	    if (err == 0 && memcmp(bk.uc, bf_test_data[i].badcryptxt, 8) == 0)
@@ -554,43 +558,43 @@
     return err > 0 ? FAIL : OK;
 }
 
-/* Output feedback mode. */
-static int randbyte_offset = 0;
-static int update_offset = 0;
-static char_u ofb_buffer[BF_OFB_LEN]; /* 64 bytes */
+/*
+ * CFB: Cipher Feedback Mode.
+ */
 
 /*
- * Initialize with seed "iv[iv_len]".
+ * Initialize with seed "seed[seed_len]".
  */
-    void
-bf_ofb_init(iv, iv_len)
-    char_u *iv;
-    int    iv_len;
+    static void
+bf_cfb_init(bfs, seed, seed_len)
+    bf_state_T	*bfs;
+    char_u	*seed;
+    int		seed_len;
 {
     int i, mi;
 
-    randbyte_offset = update_offset = 0;
-    vim_memset(ofb_buffer, 0, BF_OFB_LEN);
-    if (iv_len > 0)
+    bfs->randbyte_offset = bfs->update_offset = 0;
+    vim_memset(bfs->cfb_buffer, 0, bfs->cfb_len);
+    if (seed_len > 0)
     {
-	mi = iv_len > BF_OFB_LEN ? iv_len : BF_OFB_LEN;
+	mi = seed_len > bfs->cfb_len ? seed_len : bfs->cfb_len;
 	for (i = 0; i < mi; i++)
-	    ofb_buffer[i % BF_OFB_LEN] ^= iv[i % iv_len];
+	    bfs->cfb_buffer[i % bfs->cfb_len] ^= seed[i % seed_len];
     }
 }
 
-#define BF_OFB_UPDATE(c) { \
-    ofb_buffer[update_offset] ^= (char_u)c; \
-    if (++update_offset == BF_OFB_LEN) \
-	update_offset = 0; \
+#define BF_CFB_UPDATE(bfs, c) { \
+    bfs->cfb_buffer[bfs->update_offset] ^= (char_u)c; \
+    if (++bfs->update_offset == bfs->cfb_len) \
+	bfs->update_offset = 0; \
 }
 
-#define BF_RANBYTE(t) { \
-    if ((randbyte_offset & BF_BLOCK_MASK) == 0) \
-	bf_e_cblock(&ofb_buffer[randbyte_offset]); \
-    t = ofb_buffer[randbyte_offset]; \
-    if (++randbyte_offset == BF_OFB_LEN) \
-	randbyte_offset = 0; \
+#define BF_RANBYTE(bfs, t) { \
+    if ((bfs->randbyte_offset & BF_BLOCK_MASK) == 0) \
+	bf_e_cblock(bfs, &(bfs->cfb_buffer[bfs->randbyte_offset])); \
+    t = bfs->cfb_buffer[bfs->randbyte_offset]; \
+    if (++bfs->randbyte_offset == bfs->cfb_len) \
+	bfs->randbyte_offset = 0; \
 }
 
 /*
@@ -598,90 +602,69 @@
  * "from" and "to" can be equal to encrypt in place.
  */
     void
-bf_crypt_encode(from, len, to)
+crypt_blowfish_encode(state, from, len, to)
+    cryptstate_T *state;
     char_u	*from;
     size_t	len;
     char_u	*to;
 {
+    bf_state_T *bfs = state->method_state;
     size_t	i;
     int		ztemp, t;
 
     for (i = 0; i < len; ++i)
     {
 	ztemp = from[i];
-	BF_RANBYTE(t);
-	BF_OFB_UPDATE(ztemp);
+	BF_RANBYTE(bfs, t);
+	BF_CFB_UPDATE(bfs, ztemp);
 	to[i] = t ^ ztemp;
     }
 }
 
 /*
- * Decrypt "ptr[len]" in place.
+ * Decrypt "from[len]" into "to[len]".
  */
     void
-bf_crypt_decode(ptr, len)
-    char_u	*ptr;
-    long	len;
+crypt_blowfish_decode(state, from, len, to)
+    cryptstate_T *state;
+    char_u	*from;
+    size_t	len;
+    char_u	*to;
 {
-    char_u	*p;
+    bf_state_T *bfs = state->method_state;
+    size_t	i;
     int		t;
 
-    for (p = ptr; p < ptr + len; ++p)
+    for (i = 0; i < len; ++i)
     {
-	BF_RANBYTE(t);
-	*p ^= t;
-	BF_OFB_UPDATE(*p);
+	BF_RANBYTE(bfs, t);
+	to[i] = from[i] ^ t;
+	BF_CFB_UPDATE(bfs, to[i]);
     }
 }
 
-/*
- * Initialize the encryption keys and the random header according to
- * the given password.
- */
     void
-bf_crypt_init_keys(passwd)
-    char_u *passwd;		/* password string with which to modify keys */
-{
-    char_u *p;
-
-    for (p = passwd; *p != NUL; ++p)
-    {
-	BF_OFB_UPDATE(*p);
-    }
-}
+crypt_blowfish_init(state, key, salt, salt_len, seed, seed_len)
+    cryptstate_T	*state;
+    char_u*		key;
+    char_u*		salt;
+    int			salt_len;
+    char_u*		seed;
+    int			seed_len;
+{
+    bf_state_T	*bfs = (bf_state_T *)alloc_clear(sizeof(bf_state_T));
+
+    state->method_state = bfs;
+
+    /* "blowfish" uses a 64 byte buffer, causing it to repeat 8 byte groups 8
+     * times.  "blowfish2" uses a 8 byte buffer to avoid repeating. */
+    bfs->cfb_len = state->method_nr == CRYPT_M_BF ? BF_MAX_CFB_LEN : BF_BLOCK;
 
-static int save_randbyte_offset;
-static int save_update_offset;
-static char_u save_ofb_buffer[BF_OFB_LEN];
-static UINT32_T save_pax[18];
-static UINT32_T save_sbx[4][256];
-
-/*
- * Save the current crypt state.  Can only be used once before
- * bf_crypt_restore().
- */
-    void
-bf_crypt_save()
-{
-    save_randbyte_offset = randbyte_offset;
-    save_update_offset = update_offset;
-    mch_memmove(save_ofb_buffer, ofb_buffer, BF_OFB_LEN);
-    mch_memmove(save_pax, pax, 4 * 18);
-    mch_memmove(save_sbx, sbx, 4 * 4 * 256);
-}
+    if (blowfish_self_test() == FAIL)
+	return;
 
-/*
- * Restore the current crypt state.  Can only be used after
- * bf_crypt_save().
- */
-    void
-bf_crypt_restore()
-{
-    randbyte_offset = save_randbyte_offset;
-    update_offset = save_update_offset;
-    mch_memmove(ofb_buffer, save_ofb_buffer, BF_OFB_LEN);
-    mch_memmove(pax, save_pax, 4 * 18);
-    mch_memmove(sbx, save_sbx, 4 * 4 * 256);
+    bf_key_init(bfs, key, salt, salt_len);
+    bf_cfb_init(bfs, seed, seed_len);
 }
 
 /*
diff -Naur vim74.orig/src/buffer.c vim74/src/buffer.c
--- vim74.orig/src/buffer.c	2013-07-17 14:39:00.000000000 +0000
+++ vim74/src/buffer.c	2014-10-10 14:53:44.208714224 +0000
@@ -28,9 +28,9 @@
 #include "vim.h"
 
 #if defined(FEAT_CMDL_COMPL) || defined(FEAT_LISTCMDS) || defined(FEAT_EVAL) || defined(FEAT_PERL)
-static char_u	*buflist_match __ARGS((regprog_T *prog, buf_T *buf));
+static char_u	*buflist_match __ARGS((regprog_T *prog, buf_T *buf, int ignore_case));
 # define HAVE_BUFLIST_MATCH
-static char_u	*fname_match __ARGS((regprog_T *prog, char_u *name));
+static char_u	*fname_match __ARGS((regprog_T *prog, char_u *name, int ignore_case));
 #endif
 static void	buflist_setfpos __ARGS((buf_T *buf, win_T *win, linenr_T lnum, colnr_T col, int copy_options));
 static wininfo_T *find_wininfo __ARGS((buf_T *buf, int skip_diff_buffer));
@@ -211,7 +211,12 @@
 
     /* if first time loading this buffer, init b_chartab[] */
     if (curbuf->b_flags & BF_NEVERLOADED)
+    {
 	(void)buf_init_chartab(curbuf, FALSE);
+#ifdef FEAT_CINDENT
+	parse_cino(curbuf);
+#endif
+    }
 
     /*
      * Set/reset the Changed flag first, autocmds may change the buffer.
@@ -366,7 +371,11 @@
 	unload_buf = TRUE;
 #endif
 
-    if (win != NULL)
+    if (win != NULL
+#ifdef FEAT_WINDOWS
+	&& win_valid(win)	/* in case autocommands closed the window */
+#endif
+	    )
     {
 	/* Set b_last_cursor when closing the last window for the buffer.
 	 * Remember the last cursor position and window options of the buffer.
@@ -671,8 +680,16 @@
 #endif
 #ifdef FEAT_AUTOCMD
     aubuflocal_remove(buf);
+    if (autocmd_busy)
+    {
+	/* Do not free the buffer structure while autocommands are executing,
+	 * it's still needed. Free it when autocmd_busy is reset. */
+	buf->b_next = au_pending_free_buf;
+	au_pending_free_buf = buf;
+    }
+    else
 #endif
-    vim_free(buf);
+	vim_free(buf);
 }
 
 /*
@@ -989,6 +1006,50 @@
 #if defined(FEAT_LISTCMDS) || defined(FEAT_PYTHON) \
 	|| defined(FEAT_PYTHON3) || defined(PROTO)
 
+static int	empty_curbuf __ARGS((int close_others, int forceit, int action));
+
+/*
+ * Make the current buffer empty.
+ * Used when it is wiped out and it's the last buffer.
+ */
+    static int
+empty_curbuf(close_others, forceit, action)
+    int close_others;
+    int forceit;
+    int action;
+{
+    int	    retval;
+    buf_T   *buf = curbuf;
+
+    if (action == DOBUF_UNLOAD)
+    {
+	EMSG(_("E90: Cannot unload last buffer"));
+	return FAIL;
+    }
+
+    if (close_others)
+    {
+	/* Close any other windows on this buffer, then make it empty. */
+#ifdef FEAT_WINDOWS
+	close_windows(buf, TRUE);
+#endif
+    }
+
+    setpcmark();
+    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,
+					  forceit ? ECMD_FORCEIT : 0, curwin);
+
+    /*
+     * do_ecmd() may create a new buffer, then we have to delete
+     * the old one.  But do_ecmd() may have done that already, check
+     * if the buffer still exists.
+     */
+    if (buf != curbuf && buf_valid(buf) && buf->b_nwindows == 0)
+	close_buffer(NULL, buf, action, FALSE);
+    if (!close_others)
+	need_fileinfo = FALSE;
+    return retval;
+}
 /*
  * Implementation of the commands for the buffer list.
  *
@@ -1109,7 +1170,6 @@
     if (unload)
     {
 	int	forward;
-	int	retval;
 
 	/* When unloading or deleting a buffer that's already unloaded and
 	 * unlisted: fail silently. */
@@ -1150,30 +1210,7 @@
 	    if (bp->b_p_bl && bp != buf)
 		break;
 	if (bp == NULL && buf == curbuf)
-	{
-	    if (action == DOBUF_UNLOAD)
-	    {
-		EMSG(_("E90: Cannot unload last buffer"));
-		return FAIL;
-	    }
-
-	    /* Close any other windows on this buffer, then make it empty. */
-#ifdef FEAT_WINDOWS
-	    close_windows(buf, TRUE);
-#endif
-	    setpcmark();
-	    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,
-					  forceit ? ECMD_FORCEIT : 0, curwin);
-
-	    /*
-	     * do_ecmd() may create a new buffer, then we have to delete
-	     * the old one.  But do_ecmd() may have done that already, check
-	     * if the buffer still exists.
-	     */
-	    if (buf != curbuf && buf_valid(buf) && buf->b_nwindows == 0)
-		close_buffer(NULL, buf, action, FALSE);
-	    return retval;
-	}
+	    return empty_curbuf(TRUE, forceit, action);
 
 #ifdef FEAT_WINDOWS
 	/*
@@ -1186,7 +1223,10 @@
 		   && !(curwin->w_closing || curwin->w_buffer->b_closing)
 # endif
 		   && (firstwin != lastwin || first_tabpage->tp_next != NULL))
-	    win_close(curwin, FALSE);
+	{
+	    if (win_close(curwin, FALSE) == FAIL)
+		break;
+	}
 #endif
 
 	/*
@@ -1204,7 +1244,8 @@
 
 	/*
 	 * Deleting the current buffer: Need to find another buffer to go to.
-	 * There must be another, otherwise it would have been handled above.
+	 * There should be another, otherwise it would have been handled
+	 * above.  However, autocommands may have deleted all buffers.
 	 * First use au_new_curbuf, if it is valid.
 	 * Then prefer the buffer we most recently visited.
 	 * Else try to find one that is loaded, after the current buffer,
@@ -1303,6 +1344,13 @@
 	}
     }
 
+    if (buf == NULL)
+    {
+	/* Autocommands must have wiped out all other buffers.  Only option
+	 * now is to make the current buffer empty. */
+	return empty_curbuf(FALSE, forceit, action);
+    }
+
     /*
      * make buf current buffer
      */
@@ -1396,10 +1444,8 @@
 	curwin->w_alt_fnum = curbuf->b_fnum; /* remember alternate file */
     buflist_altfpos(curwin);			 /* remember curpos */
 
-#ifdef FEAT_VISUAL
     /* Don't restart Select mode after switching to another buffer. */
     VIsual_reselect = FALSE;
-#endif
 
     /* close_windows() or apply_autocmds() may change curbuf */
     prevbuf = curbuf;
@@ -1647,7 +1693,11 @@
 	    buf->b_p_bl = TRUE;
 #ifdef FEAT_AUTOCMD
 	    if (!(flags & BLN_DUMMY))
+	    {
 		apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf);
+		if (!buf_valid(buf))
+		    return NULL;
+	    }
 #endif
 	}
 	return buf;
@@ -1823,8 +1873,14 @@
     if (!(flags & BLN_DUMMY))
     {
 	apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf);
+	if (!buf_valid(buf))
+	    return NULL;
 	if (flags & BLN_LISTED)
+	{
 	    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf);
+	    if (!buf_valid(buf))
+		return NULL;
+	}
 # ifdef FEAT_EVAL
 	if (aborting())		/* autocmds may abort script processing */
 	    return NULL;
@@ -1941,6 +1997,11 @@
     clear_string_option(&buf->b_p_qe);
 #endif
     buf->b_p_ar = -1;
+    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;
+#ifdef FEAT_LISP
+    clear_string_option(&buf->b_p_lw);
+#endif
+    clear_string_option(&buf->b_p_bkc);
 }
 
 /*
@@ -2222,7 +2283,7 @@
 #ifdef FEAT_DIFF
 			    && (!diffmode || diff_mode_buf(buf))
 #endif
-			    && buflist_match(prog, buf) != NULL)
+			    && buflist_match(prog, buf, FALSE) != NULL)
 		    {
 			if (curtab_only)
 			{
@@ -2336,7 +2397,7 @@
 	    {
 		if (!buf->b_p_bl)	/* skip unlisted buffers */
 		    continue;
-		p = buflist_match(prog, buf);
+		p = buflist_match(prog, buf, p_wic);
 		if (p != NULL)
 		{
 		    if (round == 1)
@@ -2384,16 +2445,17 @@
  * Check for a match on the file name for buffer "buf" with regprog "prog".
  */
     static char_u *
-buflist_match(prog, buf)
+buflist_match(prog, buf, ignore_case)
     regprog_T	*prog;
     buf_T	*buf;
+    int		ignore_case;  /* when TRUE ignore case, when FALSE use 'fic' */
 {
     char_u	*match;
 
     /* First try the short file name, then the long file name. */
-    match = fname_match(prog, buf->b_sfname);
+    match = fname_match(prog, buf->b_sfname, ignore_case);
     if (match == NULL)
-	match = fname_match(prog, buf->b_ffname);
+	match = fname_match(prog, buf->b_ffname, ignore_case);
 
     return match;
 }
@@ -2403,9 +2465,10 @@
  * Return "name" when there is a match, NULL when not.
  */
     static char_u *
-fname_match(prog, name)
+fname_match(prog, name, ignore_case)
     regprog_T	*prog;
     char_u	*name;
+    int		ignore_case;  /* when TRUE ignore case, when FALSE use 'fic' */
 {
     char_u	*match = NULL;
     char_u	*p;
@@ -2414,7 +2477,8 @@
     if (name != NULL)
     {
 	regmatch.regprog = prog;
-	regmatch.rm_ic = p_fic;	/* ignore case when 'fileignorecase' is set */
+	/* Ignore case when 'fileignorecase' or the argument is set. */
+	regmatch.rm_ic = p_fic || ignore_case;
 	if (vim_regexec(&regmatch, name, (colnr_T)0))
 	    match = name;
 	else
@@ -4059,7 +4123,8 @@
 		item[curitem].minwid = -syn_namen2id(t, (int)(s - t));
 		curitem++;
 	    }
-	    ++s;
+	    if (*s != NUL)
+		++s;
 	    continue;
 	}
 
@@ -5468,6 +5533,10 @@
     return;
 }
 
+/*
+ * For an existing, placed sign "markId" change the type to "typenr".
+ * Returns the line number of the sign, or zero if the sign is not found.
+ */
     linenr_T
 buf_change_sign_type(buf, markId, typenr)
     buf_T	*buf;		/* buffer to store sign in */
@@ -5636,6 +5705,14 @@
 {
     signlist_T	*next;
 
+    /* When deleting the last sign need to redraw the windows to remove the
+     * sign column. Not when curwin is NULL (this means we're exiting). */
+    if (buf->b_signlist != NULL && curwin != NULL)
+    {
+	redraw_buf_later(buf, NOT_VALID);
+	changed_cline_bef_curs();
+    }
+
     while (buf->b_signlist != NULL)
     {
 	next = buf->b_signlist->next;
@@ -5654,11 +5731,7 @@
 
     for (buf = firstbuf; buf != NULL; buf = buf->b_next)
 	if (buf->b_signlist != NULL)
-	{
-	    /* Need to redraw the windows to remove the sign column. */
-	    redraw_buf_later(buf, NOT_VALID);
 	    buf_delete_signs(buf);
-	}
 }
 
 /*
diff -Naur vim74.orig/src/charset.c vim74/src/charset.c
--- vim74.orig/src/charset.c	2013-02-06 15:20:01.000000000 +0000
+++ vim74/src/charset.c	2014-10-10 14:53:44.212047549 +0000
@@ -867,9 +867,10 @@
     char_u	*s;
 {
     colnr_T	col = startcol;
+    char_u	*line = s; /* pointer to start of line, for breakindent */
 
     while (*s != NUL)
-	col += lbr_chartabsize_adv(&s, col);
+	col += lbr_chartabsize_adv(line, &s, col);
     return (int)col;
 }
 
@@ -877,16 +878,17 @@
  * Like linetabsize(), but for a given window instead of the current one.
  */
     int
-win_linetabsize(wp, p, len)
+win_linetabsize(wp, line, len)
     win_T	*wp;
-    char_u	*p;
+    char_u	*line;
     colnr_T	len;
 {
     colnr_T	col = 0;
     char_u	*s;
 
-    for (s = p; *s != NUL && (len == MAXCOL || s < p + len); mb_ptr_adv(s))
-	col += win_lbr_chartabsize(wp, s, col, NULL);
+    for (s = line; *s != NUL && (len == MAXCOL || s < line + len);
+								mb_ptr_adv(s))
+	col += win_lbr_chartabsize(wp, line, s, col, NULL);
     return (int)col;
 }
 
@@ -1021,12 +1023,13 @@
  * like chartabsize(), but also check for line breaks on the screen
  */
     int
-lbr_chartabsize(s, col)
+lbr_chartabsize(line, s, col)
+    char_u		*line UNUSED; /* start of the line */
     unsigned char	*s;
     colnr_T		col;
 {
 #ifdef FEAT_LINEBREAK
-    if (!curwin->w_p_lbr && *p_sbr == NUL)
+    if (!curwin->w_p_lbr && *p_sbr == NUL && !curwin->w_p_bri)
     {
 #endif
 #ifdef FEAT_MBYTE
@@ -1036,7 +1039,7 @@
 	RET_WIN_BUF_CHARTABSIZE(curwin, curbuf, s, col)
 #ifdef FEAT_LINEBREAK
     }
-    return win_lbr_chartabsize(curwin, s, col, NULL);
+    return win_lbr_chartabsize(curwin, line == NULL ? s : line, s, col, NULL);
 #endif
 }
 
@@ -1044,13 +1047,14 @@
  * Call lbr_chartabsize() and advance the pointer.
  */
     int
-lbr_chartabsize_adv(s, col)
+lbr_chartabsize_adv(line, s, col)
+    char_u	*line; /* start of the line */
     char_u	**s;
     colnr_T	col;
 {
     int		retval;
 
-    retval = lbr_chartabsize(*s, col);
+    retval = lbr_chartabsize(line, *s, col);
     mb_ptr_adv(*s);
     return retval;
 }
@@ -1063,8 +1067,9 @@
  * value, init to 0 before calling.
  */
     int
-win_lbr_chartabsize(wp, s, col, headp)
+win_lbr_chartabsize(wp, line, s, col, headp)
     win_T	*wp;
+    char_u	*line UNUSED; /* start of the line */
     char_u	*s;
     colnr_T	col;
     int		*headp UNUSED;
@@ -1073,6 +1078,7 @@
     int		c;
     int		size;
     colnr_T	col2;
+    colnr_T	col_adj = 0; /* col + screen size of tab */
     colnr_T	colmax;
     int		added;
 # ifdef FEAT_MBYTE
@@ -1086,9 +1092,9 @@
     int		n;
 
     /*
-     * No 'linebreak' and 'showbreak': return quickly.
+     * No 'linebreak', 'showbreak' and 'breakindent': return quickly.
      */
-    if (!wp->w_p_lbr && *p_sbr == NUL)
+    if (!wp->w_p_lbr && !wp->w_p_bri && *p_sbr == NUL)
 #endif
     {
 #ifdef FEAT_MBYTE
@@ -1104,6 +1110,8 @@
      */
     size = win_chartabsize(wp, s, col);
     c = *s;
+    if (tab_corr)
+	col_adj = size - 1;
 
     /*
      * If 'linebreak' set check at a blank before a non-blank if the line
@@ -1112,7 +1120,6 @@
     if (wp->w_p_lbr
 	    && vim_isbreak(c)
 	    && !vim_isbreak(s[1])
-	    && !wp->w_p_list
 	    && wp->w_p_wrap
 # ifdef FEAT_VERTSPLIT
 	    && wp->w_width != 0
@@ -1125,12 +1132,13 @@
 	 */
 	numberextra = win_col_off(wp);
 	col2 = col;
-	colmax = (colnr_T)(W_WIDTH(wp) - numberextra);
+	colmax = (colnr_T)(W_WIDTH(wp) - numberextra - col_adj);
 	if (col >= colmax)
 	{
-	    n = colmax + win_col_off2(wp);
+	    colmax += col_adj;
+	    n = colmax +  win_col_off2(wp);
 	    if (n > 0)
-		colmax += (((col - colmax) / n) + 1) * n;
+		colmax += (((col - colmax) / n) + 1) * n - col_adj;
 	}
 
 	for (;;)
@@ -1147,7 +1155,7 @@
 	    col2 += win_chartabsize(wp, s, col2);
 	    if (col2 >= colmax)		/* doesn't fit */
 	    {
-		size = colmax - col;
+		size = colmax - col + col_adj;
 		tab_corr = FALSE;
 		break;
 	    }
@@ -1163,11 +1171,12 @@
 # endif
 
     /*
-     * May have to add something for 'showbreak' string at start of line
+     * May have to add something for 'breakindent' and/or 'showbreak'
+     * string at start of line.
      * Set *headp to the size of what we add.
      */
     added = 0;
-    if (*p_sbr != NUL && wp->w_p_wrap && col != 0)
+    if ((*p_sbr != NUL || wp->w_p_bri) && wp->w_p_wrap && col != 0)
     {
 	numberextra = win_col_off(wp);
 	col += numberextra + mb_added;
@@ -1175,16 +1184,20 @@
 	{
 	    col -= W_WIDTH(wp);
 	    numberextra = W_WIDTH(wp) - (numberextra - win_col_off2(wp));
+	    if (*p_sbr != NUL && col >= (colnr_T)STRLEN(p_sbr))
+		col -= (colnr_T)STRLEN(p_sbr);
 	    if (numberextra > 0)
 		col = col % numberextra;
 	}
 	if (col == 0 || col + size > (colnr_T)W_WIDTH(wp))
 	{
-	    added = vim_strsize(p_sbr);
-	    if (tab_corr)
-		size += (added / wp->w_buffer->b_p_ts) * wp->w_buffer->b_p_ts;
-	    else
-		size += added;
+	    added = 0;
+	    if (*p_sbr != NUL)
+		added += vim_strsize(p_sbr);
+	    if (wp->w_p_bri)
+		added += get_breakindent_win(wp, line);
+
+	    size += added;
 	    if (col != 0)
 		added = 0;
 	}
@@ -1274,13 +1287,14 @@
     colnr_T	vcol;
     char_u	*ptr;		/* points to current char */
     char_u	*posptr;	/* points to char at pos->col */
+    char_u	*line;		/* start of the line */
     int		incr;
     int		head;
     int		ts = wp->w_buffer->b_p_ts;
     int		c;
 
     vcol = 0;
-    ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
+    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
     if (pos->col == MAXCOL)
 	posptr = NULL;  /* continue until the NUL */
     else
@@ -1288,12 +1302,13 @@
 
     /*
      * This function is used very often, do some speed optimizations.
-     * When 'list', 'linebreak' and 'showbreak' are not set use a simple loop.
+     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set
+     * use a simple loop.
      * Also use this when 'list' is set but tabs take their normal size.
      */
     if ((!wp->w_p_list || lcs_tab1 != NUL)
 #ifdef FEAT_LINEBREAK
-	    && !wp->w_p_lbr && *p_sbr == NUL
+	    && !wp->w_p_lbr && *p_sbr == NUL && !wp->w_p_bri
 #endif
        )
     {
@@ -1355,7 +1370,7 @@
 	{
 	    /* A tab gets expanded, depending on the current column */
 	    head = 0;
-	    incr = win_lbr_chartabsize(wp, ptr, vcol, &head);
+	    incr = win_lbr_chartabsize(wp, line, ptr, vcol, &head);
 	    /* make sure we don't go past the end of the line */
 	    if (*ptr == NUL)
 	    {
@@ -1380,10 +1395,7 @@
 		&& (State & NORMAL)
 		&& !wp->w_p_list
 		&& !virtual_active()
-#ifdef FEAT_VISUAL
-		&& !(VIsual_active
-				   && (*p_sel == 'e' || ltoreq(*pos, VIsual)))
-#endif
+		&& !(VIsual_active && (*p_sel == 'e' || ltoreq(*pos, VIsual)))
 		)
 	    *cursor = vcol + incr - 1;	    /* cursor at end */
 	else
@@ -1463,7 +1475,6 @@
 }
 #endif
 
-#if defined(FEAT_VISUAL) || defined(PROTO)
 /*
  * Get the leftmost and rightmost virtual column of pos1 and pos2.
  * Used for Visual block mode.
@@ -1500,7 +1511,6 @@
     else
 	*right = to1;
 }
-#endif
 
 /*
  * skipwhite: skip over ' ' and '\t'.
diff -Naur vim74.orig/src/config.h.in vim74/src/config.h.in
--- vim74.orig/src/config.h.in	2013-02-26 13:18:19.000000000 +0000
+++ vim74/src/config.h.in	2014-10-10 14:53:44.215380874 +0000
@@ -37,10 +37,10 @@
 #undef UNIX
 
 /* Defined to the size of an int */
-#undef SIZEOF_INT
+#undef VIM_SIZEOF_INT
 
 /* Defined to the size of a long */
-#undef SIZEOF_LONG
+#undef VIM_SIZEOF_LONG
 
 /* Defined to the size of off_t */
 #undef SIZEOF_OFF_T
@@ -191,6 +191,7 @@
 #undef HAVE_SIGSETJMP
 #undef HAVE_SIGSTACK
 #undef HAVE_SIGVEC
+#undef HAVE_SMACK
 #undef HAVE_STRCASECMP
 #undef HAVE_STRERROR
 #undef HAVE_STRFTIME
@@ -442,3 +443,6 @@
 
 /* Define if you want Cygwin to use the WIN32 clipboard, not compatible with X11*/
 #undef FEAT_CYGWIN_WIN32_CLIPBOARD
+
+/* Define if we have AvailabilityMacros.h on Mac OS X */
+#undef HAVE_AVAILABILITYMACROS_H
diff -Naur vim74.orig/src/config.mk.in vim74/src/config.mk.in
--- vim74.orig/src/config.mk.in	2010-11-03 21:26:24.000000000 +0000
+++ vim74/src/config.mk.in	2014-10-10 14:53:44.218714199 +0000
@@ -48,11 +48,12 @@
 MZSCHEME_OBJ	= @MZSCHEME_OBJ@
 MZSCHEME_CFLAGS	= @MZSCHEME_CFLAGS@
 MZSCHEME_PRO	= @MZSCHEME_PRO@
-MZSCHEME_EXTRA  = @MZSCHEME_EXTRA@
+MZSCHEME_EXTRA	= @MZSCHEME_EXTRA@
 MZSCHEME_MZC	= @MZSCHEME_MZC@
 
 PERL		= @vi_cv_path_perl@
 PERLLIB		= @vi_cv_perllib@
+PERL_XSUBPP	= @vi_cv_perl_xsubpp@
 PERL_LIBS	= @PERL_LIBS@
 SHRPENV		= @shrpenv@
 PERL_SRC	= @PERL_SRC@
@@ -164,6 +165,8 @@
 ### If the *.po files are to be translated to *.mo files.
 MAKEMO		= @MAKEMO@
 
+MSGFMT		= @MSGFMT@
+
 # Make sure that "make first" will run "make all" once configure has done its
 # work.  This is needed when using the Makefile in the top directory.
 first: all
diff -Naur vim74.orig/src/configure.in vim74/src/configure.in
--- vim74.orig/src/configure.in	2013-08-04 18:00:50.000000000 +0000
+++ vim74/src/configure.in	2014-10-10 14:53:44.228714174 +0000
@@ -14,6 +14,7 @@
 AC_PROG_CC	dnl required by almost everything
 AC_PROG_CPP	dnl required by header file checks
 AC_PROGRAM_EGREP dnl required by AC_EGREP_CPP
+AC_PROG_FGREP	dnl finds working grep -F
 AC_ISC_POSIX	dnl required by AC_C_CROSS
 AC_PROG_AWK	dnl required for "make html" in ../doc
 
@@ -45,10 +46,10 @@
 fi
 if test "$GCC" = yes; then
   dnl method that should work for nearly all versions
-  gccversion=`"$CC" -dumpversion`
+  gccversion=`$CC -dumpversion`
   if test "x$gccversion" = "x"; then
     dnl old method; fall-back for when -dumpversion doesn't work
-    gccversion=`"$CC" --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[[^0-9]]*\([[0-9]]\.[[0-9.]]*\).*$/\1/g'`
+    gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[[^0-9]]*\([[0-9]]\.[[0-9.]]*\).*$/\1/g'`
   fi
   dnl version 4.0.1 was reported to cause trouble on Macintosh by Marcin Dalecki
   if test "$gccversion" = "3.0.1" -o "$gccversion" = "3.0.2" -o "$gccversion" = "4.0.1"; then
@@ -62,6 +63,29 @@
   fi
 fi
 
+dnl clang-500.2.75 or around has abandoned -f[no-]strength-reduce and issues a
+dnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on
+dnl the version number of the clang in use.
+dnl Note that this does not work to get the version of clang 3.1 or 3.2.
+AC_MSG_CHECKING(for recent clang version)
+CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\).*$/\1/p'`
+if test x"$CLANG_VERSION_STRING" != x"" ; then
+  CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*/\1/p'`
+  CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/p'`
+  CLANG_REVISION=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)/\1/p'`
+  CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
+  AC_MSG_RESULT($CLANG_VERSION)
+  dnl If you find the same issue with versions earlier than 500.2.75,
+  dnl change the constant 500002075 below appropriately.  To get the
+  dnl integer corresponding to a version number, refer to the
+  dnl definition of CLANG_VERSION above.
+  if test "$CLANG_VERSION" -ge 500002075 ; then
+    CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
+  fi
+else
+  AC_MSG_RESULT(no)
+fi
+
 dnl If configure thinks we are cross compiling, there might be something
 dnl wrong with the CC or CFLAGS settings, give a useful warning message
 if test "$cross_compiling" = yes; then
@@ -181,7 +205,8 @@
     OS_EXTRA_SRC="os_macosx.m os_mac_conv.c";
     OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
     dnl TODO: use -arch i386 on Intel machines
-    CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX -no-cpp-precomp"
+    dnl Removed -no-cpp-precomp, only for very old compilers.
+    CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX"
 
     dnl If Carbon is found, assume we don't want X11
     dnl unless it was specifically asked for (--with-x)
@@ -205,6 +230,10 @@
   AC_MSG_RESULT(no)
 fi
 
+dnl Mac OS X 10.9+ no longer include AvailabilityMacros.h in Carbon
+dnl so we need to include it to have access to version macros.
+AC_CHECK_HEADERS(AvailabilityMacros.h)
+
 AC_SUBST(OS_EXTRA_SRC)
 AC_SUBST(OS_EXTRA_OBJ)
 
@@ -235,8 +264,8 @@
   ])
   if test "$GCC" = yes -a "$local_dir" != no; then
     echo 'void f(){}' > conftest.c
-    dnl -no-cpp-precomp is needed for OS X 10.2 (Ben Fowler)
-    have_local_include=`${CC-cc} -no-cpp-precomp -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
+    dnl Removed -no-cpp-precomp, only needed for OS X 10.2 (Ben Fowler)
+    have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
     have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/lib"`
     rm -f conftest.c conftest.o
   fi
@@ -358,18 +387,48 @@
 AC_SUBST(QUOTESED)
 
 
-dnl Link with -lselinux for SELinux stuff; if not found
-AC_MSG_CHECKING(--disable-selinux argument)
-AC_ARG_ENABLE(selinux,
-	[  --disable-selinux	  Don't check for SELinux support.],
-	, enable_selinux="yes")
-if test "$enable_selinux" = "yes"; then
+dnl Link with -lsmack for Smack stuff; if not found
+AC_MSG_CHECKING(--disable-smack argument)
+AC_ARG_ENABLE(smack,
+	[  --disable-smack	  Do not check for Smack support.],
+	, enable_smack="yes")
+if test "$enable_smack" = "yes"; then
   AC_MSG_RESULT(no)
-  AC_CHECK_LIB(selinux, is_selinux_enabled,
-	  [LIBS="$LIBS -lselinux"
-	   AC_DEFINE(HAVE_SELINUX)])
+  AC_CHECK_HEADER([linux/xattr.h], true, enable_smack="no")
 else
-   AC_MSG_RESULT(yes)
+  AC_MSG_RESULT(yes)
+fi
+if test "$enable_smack" = "yes"; then
+  AC_CHECK_HEADER([attr/xattr.h], true, enable_smack="no")
+fi
+if test "$enable_smack" = "yes"; then
+  AC_MSG_CHECKING(for XATTR_NAME_SMACKEXEC in linux/xattr.h)
+  AC_EGREP_CPP(XATTR_NAME_SMACKEXEC, [#include <linux/xattr.h>],
+	       AC_MSG_RESULT(yes),
+	       AC_MSG_RESULT(no); enable_smack="no")
+fi
+if test "$enable_smack" = "yes"; then
+  AC_CHECK_LIB(attr, setxattr,
+	  [LIBS="$LIBS -lattr"
+	   found_smack="yes"
+	   AC_DEFINE(HAVE_SMACK)])
+fi
+
+dnl When smack was found don't search for SELinux
+if test "x$found_smack" = "x"; then
+  dnl Link with -lselinux for SELinux stuff; if not found
+  AC_MSG_CHECKING(--disable-selinux argument)
+  AC_ARG_ENABLE(selinux,
+	  [  --disable-selinux	  Do not check for SELinux support.],
+	  , enable_selinux="yes")
+  if test "$enable_selinux" = "yes"; then
+    AC_MSG_RESULT(no)
+    AC_CHECK_LIB(selinux, is_selinux_enabled,
+	    [LIBS="$LIBS -lselinux"
+	     AC_DEFINE(HAVE_SELINUX)])
+  else
+     AC_MSG_RESULT(yes)
+  fi
 fi
 
 dnl Check user requested features.
@@ -468,7 +527,7 @@
       if test "X$vi_cv_path_luajit" != "X"; then
 	dnl -- find LuaJIT version
 	AC_CACHE_CHECK(LuaJIT version, vi_cv_version_luajit,
-	[ vi_cv_version_luajit=`${vi_cv_path_luajit} -v | sed 's/LuaJIT \([[0-9.]]*\)\.[[0-9]] .*/\1/'` ])
+	[ vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \([[0-9.]]*\)\.[[0-9]]\(-[[a-z0-9]]*\)* .*/\1/'` ])
 	AC_CACHE_CHECK(Lua version of LuaJIT, vi_cv_version_lua_luajit,
 	[ vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e "print(_VERSION)" | sed 's/.* //'` ])
 	vi_cv_path_lua="$vi_cv_path_luajit"
@@ -774,9 +833,19 @@
     AC_MSG_CHECKING(for mzscheme_base.c)
     if test -f "${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
       MZSCHEME_EXTRA="mzscheme_base.c"
+      MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+      MZSCHEME_MOD="++lib scheme/base"
     else
       if test -f "${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
 	MZSCHEME_EXTRA="mzscheme_base.c"
+	MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+	MZSCHEME_MOD="++lib scheme/base"
+      else
+	if test -f "${SCHEME_COLLECTS}collects/racket/base.rkt" ; then
+	  MZSCHEME_EXTRA="mzscheme_base.c"
+	  MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/raco ctool"
+	  MZSCHEME_MOD=""
+	fi
       fi
     fi
     if test "X$MZSCHEME_EXTRA" != "X" ; then
@@ -864,6 +933,14 @@
       fi
       vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`
       AC_SUBST(vi_cv_perllib)
+      vi_cv_perl_extutils=unknown_perl_extutils_path
+      for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do
+	xsubpp_path="$vi_cv_perllib/$extutils_rel_path/xsubpp"
+	if test -f "$xsubpp_path"; then
+	  vi_cv_perl_xsubpp="$xsubpp_path"
+	fi
+      done
+      AC_SUBST(vi_cv_perl_xsubpp)
       dnl Remove "-fno-something", it breaks using cproto.
       perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \
 	      -e 'ccflags;perl_inc;print"\n"' | sed -e 's/-fno[[^ ]]*//'`
@@ -898,7 +975,7 @@
 	  PERL_CFLAGS=`echo "$perlcppflags" | sed -e 's/-pipe //' -e 's/-W[[^ ]]*//'`
 	fi
 	if test "X$perlldflags" != "X"; then
-	  if test "X`echo \"$LDFLAGS\" | grep -F -e \"$perlldflags\"`" = "X"; then
+	  if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$perlldflags\"`" = "X"; then
 	    LDFLAGS="$perlldflags $LDFLAGS"
 	  fi
 	fi
@@ -1063,10 +1140,15 @@
 	      vi_cv_path_python_plibs=`echo $vi_cv_path_python_plibs | sed s/-ltermcap//`
 	    fi
 	])
+	AC_CACHE_VAL(vi_cv_dll_name_python,
+	[
+	  if test "X$python_DLLLIBRARY" != "X"; then
+	    vi_cv_dll_name_python="$python_DLLLIBRARY"
+	  else
+	    vi_cv_dll_name_python="$python_INSTSONAME"
+	  fi
+	])
 
-	if test "X$python_DLLLIBRARY" != "X"; then
-	  python_INSTSONAME="$python_DLLLIBRARY"
-	fi
 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
@@ -1254,19 +1336,24 @@
 	@echo "python3_DLLLIBRARY='$(DLLLIBRARY)'"
 	@echo "python3_INSTSONAME='$(INSTSONAME)'"
 eof
-            dnl -- delete the lines from make about Entering/Leaving directory
-            eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
-            rm -f -- "${tmp_mkf}"
+	    dnl -- delete the lines from make about Entering/Leaving directory
+	    eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+	    rm -f -- "${tmp_mkf}"
 	    vi_cv_path_python3_plibs="-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
-            vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
-            dnl remove -ltermcap, it can conflict with an earlier -lncurses
-            vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
-            vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
-        ])
-  
-        if test "X$python3_DLLLIBRARY" != "X"; then
-	  python3_INSTSONAME="$python3_DLLLIBRARY"
-        fi
+	    vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
+	    dnl remove -ltermcap, it can conflict with an earlier -lncurses
+	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
+	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
+	])
+	AC_CACHE_VAL(vi_cv_dll_name_python3,
+	[
+	  if test "X$python3_DLLLIBRARY" != "X"; then
+	    vi_cv_dll_name_python3="$python3_DLLLIBRARY"
+	  else
+	    vi_cv_dll_name_python3="$python3_INSTSONAME"
+	  fi
+	])
+
         PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
         if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
@@ -1359,7 +1446,7 @@
   ldflags_save=$LDFLAGS
   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
   LDFLAGS="-ldl $LDFLAGS"
-  AC_RUN_IFELSE([
+  AC_RUN_IFELSE([AC_LANG_SOURCE([
     #include <dlfcn.h>
     /* If this program fails, then RTLD_GLOBAL is needed.
      * RTLD_GLOBAL will be used and then it is not possible to
@@ -1389,10 +1476,10 @@
     int main(int argc, char** argv)
     {
       int not_needed = 0;
-      if (no_rtl_global_needed_for("${python_INSTSONAME}", "${vi_cv_path_python_pfx}"))
+      if (no_rtl_global_needed_for("${vi_cv_dll_name_python}", "${vi_cv_path_python_pfx}"))
             not_needed = 1;
       return !not_needed;
-    }],
+    }])],
     [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
 
   CFLAGS=$cflags_save
@@ -1404,7 +1491,7 @@
   ldflags_save=$LDFLAGS
   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
   LDFLAGS="-ldl $LDFLAGS"
-  AC_RUN_IFELSE([
+  AC_RUN_IFELSE([AC_LANG_SOURCE([
     #include <dlfcn.h>
     #include <wchar.h>
     /* If this program fails, then RTLD_GLOBAL is needed.
@@ -1435,10 +1522,10 @@
     int main(int argc, char** argv)
     {
       int not_needed = 0;
-      if (no_rtl_global_needed_for("${python3_INSTSONAME}", L"${vi_cv_path_python3_pfx}"))
+      if (no_rtl_global_needed_for("${vi_cv_dll_name_python3}", L"${vi_cv_path_python3_pfx}"))
             not_needed = 1;
       return !not_needed;
-    }],
+    }])],
     [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
 
   CFLAGS=$cflags_save
@@ -1446,17 +1533,17 @@
 
   PYTHON_SRC="if_python.c"
   PYTHON_OBJ="objects/if_python.o"
-  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${python_INSTSONAME}\\\""
+  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
   PYTHON_LIBS=
   PYTHON3_SRC="if_python3.c"
   PYTHON3_OBJ="objects/if_python3.o"
-  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${python3_INSTSONAME}\\\""
+  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
   PYTHON3_LIBS=
 elif test "$python_ok" = yes && test "$enable_pythoninterp" = "dynamic"; then
   AC_DEFINE(DYNAMIC_PYTHON)
   PYTHON_SRC="if_python.c"
   PYTHON_OBJ="objects/if_python.o"
-  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${python_INSTSONAME}\\\""
+  PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
   PYTHON_LIBS=
 elif test "$python_ok" = yes; then
   dnl Check that adding -fPIE works.  It may be needed when using a static
@@ -1478,7 +1565,7 @@
   AC_DEFINE(DYNAMIC_PYTHON3)
   PYTHON3_SRC="if_python3.c"
   PYTHON3_OBJ="objects/if_python3.o"
-  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${python3_INSTSONAME}\\\""
+  PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
   PYTHON3_LIBS=
 elif test "$python3_ok" = yes; then
   dnl Check that adding -fPIE works.  It may be needed when using a static
@@ -1654,9 +1741,9 @@
       if test "X$rubyhdrdir" != "X"; then
 	AC_MSG_RESULT($rubyhdrdir)
 	RUBY_CFLAGS="-I$rubyhdrdir"
-        rubyarch=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['arch']]"`
-        if test -d "$rubyhdrdir/$rubyarch"; then
-          RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyhdrdir/$rubyarch"
+        rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e "print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG[['rubyarchhdrdir']] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG[['arch']]"`
+        if test -d "$rubyarchdir"; then
+          RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyarchdir"
         fi
         rubyversion=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['ruby_version']].gsub(/\./, '')[[0,2]]"`
 	if test "X$rubyversion" = "X"; then
@@ -1689,7 +1776,7 @@
 	  dnl configure, so strip these flags first (if present)
 	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
 	  if test "X$rubyldflags" != "X"; then
-	    if test "X`echo \"$LDFLAGS\" | grep -F -e \"$rubyldflags\"`" = "X"; then
+	    if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$rubyldflags\"`" = "X"; then
 	      LDFLAGS="$rubyldflags $LDFLAGS"
 	    fi
 	  fi
@@ -2574,7 +2661,7 @@
     AC_MSG_CHECKING(for XIMText in X11/Xlib.h)
     AC_EGREP_CPP(XIMText, [#include <X11/Xlib.h>],
 		  AC_MSG_RESULT(yes),
-		  AC_MSG_RESULT(no; xim has been disabled); enable_xim = "no")
+		  AC_MSG_RESULT(no; xim has been disabled); enable_xim="no")
   fi
   CPPFLAGS=$cppflags_save
 
@@ -2699,7 +2786,7 @@
 
 AC_CACHE_CHECK([whether toupper is broken], [vim_cv_toupper_broken],
   [
-    AC_RUN_IFELSE([[
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include "confdefs.h"
 #include <ctype.h>
 #if STDC_HEADERS
@@ -2707,7 +2794,7 @@
 # include <stddef.h>
 #endif
 main() { exit(toupper('A') == 'A' && tolower('z') == 'z'); }
-  ]],[
+  ]])],[
     vim_cv_toupper_broken=yes
   ],[
     vim_cv_toupper_broken=no
@@ -2955,7 +3042,7 @@
 
 AC_CACHE_CHECK([whether we talk terminfo], [vim_cv_terminfo],
   [
-    AC_RUN_IFELSE([[
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include "confdefs.h"
 #ifdef HAVE_TERMCAP_H
 # include <termcap.h>
@@ -2969,7 +3056,7 @@
 #endif
 main()
 {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(!strcmp(s==0 ? "" : s, "1")); }
-    ]],[
+    ]])],[
       vim_cv_terminfo=no
     ],[
       vim_cv_terminfo=yes
@@ -2985,7 +3072,7 @@
 if test "x$olibs" != "x$LIBS"; then
   AC_CACHE_CHECK([what tgetent() returns for an unknown terminal], [vim_cv_tgent],
     [
-      AC_RUN_IFELSE([[
+      AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include "confdefs.h"
 #ifdef HAVE_TERMCAP_H
 # include <termcap.h>
@@ -2996,7 +3083,7 @@
 #endif
 main()
 {char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist"); exit(res != 0); }
-      ]],[
+      ]])],[
 	vim_cv_tgent=zero
       ],[
 	vim_cv_tgent=non-zero
@@ -3120,7 +3207,7 @@
 rm -f conftest_grp
 AC_CACHE_CHECK([default tty permissions/group], [vim_cv_tty_group],
   [
-    AC_RUN_IFELSE([[
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3156,7 +3243,7 @@
   fclose(fp);
   exit(0);
 }
-    ]],[
+    ]])],[
       if test -f conftest_grp; then
 	vim_cv_tty_group=`cat conftest_grp`
 	if test "x$vim_cv_tty_mode" = "x" ; then
@@ -3214,7 +3301,7 @@
 dnl system("sh -c pwd")
 AC_CACHE_CHECK([getcwd implementation is broken], [vim_cv_getcwd_broken],
   [
-    AC_RUN_IFELSE([[
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include "confdefs.h"
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
@@ -3227,7 +3314,7 @@
   environ = dagger;
   return getcwd(buffer, 500) ? 0 : 1;
 }
-    ]],[
+    ]])],[
       vim_cv_getcwd_broken=no
     ],[
       vim_cv_getcwd_broken=yes
@@ -3270,7 +3357,7 @@
 
 AC_CACHE_CHECK([whether stat() ignores a trailing slash], [vim_cv_stat_ignores_slash],
   [
-    AC_RUN_IFELSE([[
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include "confdefs.h"
 #if STDC_HEADERS
 # include <stdlib.h>
@@ -3279,7 +3366,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 main() {struct stat st;  exit(stat("configure/", &st) != 0); }
-    ]],[
+    ]])],[
       vim_cv_stat_ignores_slash=yes
     ],[
       vim_cv_stat_ignores_slash=no
@@ -3543,6 +3630,10 @@
 AC_CHECK_SIZEOF([time_t])
 AC_CHECK_SIZEOF([off_t])
 
+dnl Use different names to avoid clashing with other header files.
+AC_DEFINE_UNQUOTED(VIM_SIZEOF_INT, [$ac_cv_sizeof_int])
+AC_DEFINE_UNQUOTED(VIM_SIZEOF_LONG, [$ac_cv_sizeof_long])
+
 dnl Make sure that uint32_t is really 32 bits unsigned.
 AC_MSG_CHECKING([uint32_t is 32 bits])
 AC_TRY_RUN([
@@ -3589,7 +3680,7 @@
 
 AC_CACHE_CHECK([whether memmove handles overlaps],[vim_cv_memmove_handles_overlap],
   [
-    AC_RUN_IFELSE([[#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog]],
+    AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog]])],
       [
 	vim_cv_memmove_handles_overlap=yes
       ],[
@@ -3604,7 +3695,7 @@
 else
   AC_CACHE_CHECK([whether bcopy handles overlaps],[vim_cv_bcopy_handles_overlap],
     [
-      AC_RUN_IFELSE([[#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog]],
+      AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog]])],
       [
 	vim_cv_bcopy_handles_overlap=yes
       ],[
@@ -3619,7 +3710,7 @@
   else
     AC_CACHE_CHECK([whether memcpy handles overlaps],[vim_cv_memcpy_handles_overlap],
       [
-	AC_RUN_IFELSE([[#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog]],
+	AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog]])],
 	  [
 	    vim_cv_memcpy_handles_overlap=yes
 	  ],[
@@ -3697,6 +3788,9 @@
 fi
 
 dnl Check if gettext() is working and if it needs -lintl
+dnl We take care to base this on an empty LIBS: on some systems libelf would be
+dnl in LIBS and implicitly take along libintl. The final LIBS would then not
+dnl contain libintl, and the link step would fail due to -Wl,--as-needed.
 AC_MSG_CHECKING(--disable-nls argument)
 AC_ARG_ENABLE(nls,
 	[  --disable-nls           Don't support NLS (gettext()).], ,
@@ -3715,22 +3809,24 @@
   if test -f po/Makefile; then
     have_gettext="no"
     if test -n "$MSGFMT"; then
+      olibs=$LIBS
+      LIBS=""
       AC_TRY_LINK(
 	[#include <libintl.h>],
 	[gettext("Test");],
-	AC_MSG_RESULT([gettext() works]); have_gettext="yes",
-	  olibs=$LIBS
-	  LIBS="$LIBS -lintl"
+	AC_MSG_RESULT([gettext() works]); have_gettext="yes"; LIBS=$olibs,
+	  LIBS="-lintl"
 	  AC_TRY_LINK(
 	      [#include <libintl.h>],
 	      [gettext("Test");],
-	      AC_MSG_RESULT([gettext() works with -lintl]); have_gettext="yes",
+	      AC_MSG_RESULT([gettext() works with -lintl]); have_gettext="yes";
+	      LIBS="$olibs -lintl",
 	      AC_MSG_RESULT([gettext() doesn't work]);
 	      LIBS=$olibs))
     else
       AC_MSG_RESULT([msgfmt not found - disabled]);
     fi
-    if test $have_gettext = "yes"; then
+    if test $have_gettext = "yes" -a "x$features" != "xtiny" -a "x$features" != "xsmall"; then
       AC_DEFINE(HAVE_GETTEXT)
       MAKEMO=yes
       AC_SUBST(MAKEMO)
diff -Naur vim74.orig/src/crypt.c vim74/src/crypt.c
--- vim74.orig/src/crypt.c	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/crypt.c	2014-10-10 14:53:44.232047499 +0000
@@ -0,0 +1,585 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * crypt.c: Generic encryption support.
+ */
+#include "vim.h"
+
+#if defined(FEAT_CRYPT) || defined(PROTO)
+/*
+ * Optional encryption support.
+ * Mohsin Ahmed, mosh@sasi.com, 1998-09-24
+ * Based on zip/crypt sources.
+ * Refactored by David Leadbeater, 2014.
+ *
+ * NOTE FOR USA: Since 2000 exporting this code from the USA is allowed to
+ * most countries.  There are a few exceptions, but that still should not be a
+ * problem since this code was originally created in Europe and India.
+ *
+ * Blowfish addition originally made by Mohsin Ahmed,
+ * http://www.cs.albany.edu/~mosh 2010-03-14
+ * Based on blowfish by Bruce Schneier (http://www.schneier.com/blowfish.html)
+ * and sha256 by Christophe Devine.
+ */
+
+typedef struct {
+    char    *name;	/* encryption name as used in 'cryptmethod' */
+    char    *magic;	/* magic bytes stored in file header */
+    int	    salt_len;	/* length of salt, or 0 when not using salt */
+    int	    seed_len;	/* length of seed, or 0 when not using salt */
+    int	    works_inplace; /* encryption/decryption can be done in-place */
+    int	    whole_undofile; /* whole undo file is encrypted */
+
+    /* Optional function pointer for a self-test. */
+    int (* self_test_fn)();
+
+    /* Function pointer for initializing encryption/decription. */
+    void (* init_fn)(cryptstate_T *state, char_u *key,
+		      char_u *salt, int salt_len, char_u *seed, int seed_len);
+
+    /* Function pointers for encoding/decoding from one buffer into another.
+     * Optional, however, these or the _buffer ones should be configured. */
+    void (*encode_fn)(cryptstate_T *state, char_u *from, size_t len,
+								  char_u *to);
+    void (*decode_fn)(cryptstate_T *state, char_u *from, size_t len,
+								  char_u *to);
+
+    /* Function pointers for encoding and decoding, can buffer data if needed.
+     * Optional (however, these or the above should be configured). */
+    long (*encode_buffer_fn)(cryptstate_T *state, char_u *from, size_t len,
+							     char_u **newptr);
+    long (*decode_buffer_fn)(cryptstate_T *state, char_u *from, size_t len,
+							     char_u **newptr);
+
+    /* Function pointers for in-place encoding and decoding, used for
+     * crypt_*_inplace(). "from" and "to" arguments will be equal.
+     * These may be the same as decode_fn and encode_fn above, however an
+     * algorithm may implement them in a way that is not interchangeable with
+     * the crypt_(en|de)code() interface (for example because it wishes to add
+     * padding to files).
+     * This method is used for swap and undo files which have a rigid format.
+     */
+    void (*encode_inplace_fn)(cryptstate_T *state, char_u *p1, size_t len,
+								  char_u *p2);
+    void (*decode_inplace_fn)(cryptstate_T *state, char_u *p1, size_t len,
+								  char_u *p2);
+} cryptmethod_T;
+
+/* index is method_nr of cryptstate_T, CRYPT_M_* */
+static cryptmethod_T cryptmethods[CRYPT_M_COUNT] = {
+    /* PK_Zip; very weak */
+    {
+	"zip",
+	"VimCrypt~01!",
+	0,
+	0,
+	TRUE,
+	FALSE,
+	NULL,
+	crypt_zip_init,
+	crypt_zip_encode, crypt_zip_decode,
+	NULL, NULL,
+	crypt_zip_encode, crypt_zip_decode,
+    },
+
+    /* Blowfish/CFB + SHA-256 custom key derivation; implementation issues. */
+    {
+	"blowfish",
+	"VimCrypt~02!",
+	8,
+	8,
+	TRUE,
+	FALSE,
+	blowfish_self_test,
+	crypt_blowfish_init,
+	crypt_blowfish_encode, crypt_blowfish_decode,
+	NULL, NULL,
+	crypt_blowfish_encode, crypt_blowfish_decode,
+    },
+
+    /* Blowfish/CFB + SHA-256 custom key derivation; fixed. */
+    {
+	"blowfish2",
+	"VimCrypt~03!",
+	8,
+	8,
+	TRUE,
+	TRUE,
+	blowfish_self_test,
+	crypt_blowfish_init,
+	crypt_blowfish_encode, crypt_blowfish_decode,
+	NULL, NULL,
+	crypt_blowfish_encode, crypt_blowfish_decode,
+    },
+};
+
+#define CRYPT_MAGIC_LEN	12	/* cannot change */
+static char	crypt_magic_head[] = "VimCrypt~";
+
+/*
+ * Return int value for crypt method name.
+ * 0 for "zip", the old method.  Also for any non-valid value.
+ * 1 for "blowfish".
+ * 2 for "blowfish2".
+ */
+    int
+crypt_method_nr_from_name(name)
+    char_u  *name;
+{
+    int i;
+
+    for (i = 0; i < CRYPT_M_COUNT; ++i)
+	if (STRCMP(name, cryptmethods[i].name) == 0)
+	    return i;
+    return 0;
+}
+
+/*
+ * Get the crypt method used for a file from "ptr[len]", the magic text at the
+ * start of the file.
+ * Returns -1 when no encryption used.
+ */
+    int
+crypt_method_nr_from_magic(ptr, len)
+    char  *ptr;
+    int   len;
+{
+    int i;
+
+    if (len < CRYPT_MAGIC_LEN)
+	return -1;
+
+    for (i = 0; i < CRYPT_M_COUNT; i++)
+	if (memcmp(ptr, cryptmethods[i].magic, CRYPT_MAGIC_LEN) == 0)
+	    return i;
+
+    i = (int)STRLEN(crypt_magic_head);
+    if (len >= i && memcmp(ptr, crypt_magic_head, i) == 0)
+	EMSG(_("E821: File is encrypted with unknown method"));
+
+    return -1;
+}
+
+/*
+ * Return TRUE if the crypt method for "method_nr" can be done in-place.
+ */
+    int
+crypt_works_inplace(state)
+    cryptstate_T *state;
+{
+    return cryptmethods[state->method_nr].works_inplace;
+}
+
+/*
+ * Get the crypt method for buffer "buf" as a number.
+ */
+    int
+crypt_get_method_nr(buf)
+    buf_T *buf;
+{
+    return crypt_method_nr_from_name(*buf->b_p_cm == NUL ? p_cm : buf->b_p_cm);
+}
+
+/*
+ * Return TRUE when the buffer uses an encryption method that encrypts the
+ * whole undo file, not only the text.
+ */
+    int
+crypt_whole_undofile(method_nr)
+    int method_nr;
+{
+    return cryptmethods[method_nr].whole_undofile;
+}
+
+/*
+ * Get crypt method specifc length of the file header in bytes.
+ */
+    int
+crypt_get_header_len(method_nr)
+    int method_nr;
+{
+    return CRYPT_MAGIC_LEN
+	+ cryptmethods[method_nr].salt_len
+	+ cryptmethods[method_nr].seed_len;
+}
+
+/*
+ * Set the crypt method for buffer "buf" to "method_nr" using the int value as
+ * returned by crypt_method_nr_from_name().
+ */
+    void
+crypt_set_cm_option(buf, method_nr)
+    buf_T   *buf;
+    int	    method_nr;
+{
+    free_string_option(buf->b_p_cm);
+    buf->b_p_cm = vim_strsave((char_u *)cryptmethods[method_nr].name);
+}
+
+/*
+ * If the crypt method for the current buffer has a self-test, run it and
+ * return OK/FAIL.
+ */
+    int
+crypt_self_test()
+{
+    int method_nr = crypt_get_method_nr(curbuf);
+
+    if (cryptmethods[method_nr].self_test_fn == NULL)
+	return OK;
+    return cryptmethods[method_nr].self_test_fn();
+}
+
+/*
+ * Allocate a crypt state and initialize it.
+ */
+    cryptstate_T *
+crypt_create(method_nr, key, salt, salt_len, seed, seed_len)
+    int		method_nr;
+    char_u	*key;
+    char_u	*salt;
+    int		salt_len;
+    char_u	*seed;
+    int		seed_len;
+{
+    cryptstate_T *state = (cryptstate_T *)alloc((int)sizeof(cryptstate_T));
+
+    state->method_nr = method_nr;
+    cryptmethods[method_nr].init_fn(state, key, salt, salt_len, seed, seed_len);
+    return state;
+}
+
+/*
+ * Allocate a crypt state from a file header and initialize it.
+ * Assumes that header contains at least the number of bytes that
+ * crypt_get_header_len() returns for "method_nr".
+ */
+    cryptstate_T *
+crypt_create_from_header(method_nr, key, header)
+    int		method_nr;
+    char_u	*key;
+    char_u	*header;
+{
+    char_u	*salt = NULL;
+    char_u	*seed = NULL;
+    int		salt_len = cryptmethods[method_nr].salt_len;
+    int		seed_len = cryptmethods[method_nr].seed_len;
+
+    if (salt_len > 0)
+	salt = header + CRYPT_MAGIC_LEN;
+    if (seed_len > 0)
+	seed = header + CRYPT_MAGIC_LEN + salt_len;
+
+    return crypt_create(method_nr, key, salt, salt_len, seed, seed_len);
+}
+
+/*
+ * Read the crypt method specific header data from "fp".
+ * Return an allocated cryptstate_T or NULL on error.
+ */
+    cryptstate_T *
+crypt_create_from_file(fp, key)
+    FILE    *fp;
+    char_u  *key;
+{
+    int		method_nr;
+    int		header_len;
+    char	magic_buffer[CRYPT_MAGIC_LEN];
+    char_u	*buffer;
+    cryptstate_T *state;
+
+    if (fread(magic_buffer, CRYPT_MAGIC_LEN, 1, fp) != 1)
+	return NULL;
+    method_nr = crypt_method_nr_from_magic(magic_buffer, CRYPT_MAGIC_LEN);
+    if (method_nr < 0)
+	return NULL;
+
+    header_len = crypt_get_header_len(method_nr);
+    if ((buffer = alloc(header_len)) == NULL)
+	return NULL;
+    mch_memmove(buffer, magic_buffer, CRYPT_MAGIC_LEN);
+    if (header_len > CRYPT_MAGIC_LEN
+	    && fread(buffer + CRYPT_MAGIC_LEN,
+				    header_len - CRYPT_MAGIC_LEN, 1, fp) != 1)
+    {
+	vim_free(buffer);
+	return NULL;
+    }
+
+    state = crypt_create_from_header(method_nr, key, buffer);
+    vim_free(buffer);
+    return state;
+}
+
+/*
+ * Allocate a cryptstate_T for writing and initialize it with "key".
+ * Allocates and fills in the header and stores it in "header", setting
+ * "header_len".  The header may include salt and seed, depending on
+ * cryptmethod.  Caller must free header.
+ * Returns the state or NULL on failure.
+ */
+    cryptstate_T *
+crypt_create_for_writing(method_nr, key, header, header_len)
+    int	    method_nr;
+    char_u  *key;
+    char_u  **header;
+    int	    *header_len;
+{
+    int	    len = crypt_get_header_len(method_nr);
+    char_u  *salt = NULL;
+    char_u  *seed = NULL;
+    int	    salt_len = cryptmethods[method_nr].salt_len;
+    int	    seed_len = cryptmethods[method_nr].seed_len;
+    cryptstate_T *state;
+
+    *header_len = len;
+    *header = alloc(len);
+    if (*header == NULL)
+	return NULL;
+
+    mch_memmove(*header, cryptmethods[method_nr].magic, CRYPT_MAGIC_LEN);
+    if (salt_len > 0 || seed_len > 0)
+    {
+	if (salt_len > 0)
+	    salt = *header + CRYPT_MAGIC_LEN;
+	if (seed_len > 0)
+	    seed = *header + CRYPT_MAGIC_LEN + salt_len;
+
+	/* TODO: Should this be crypt method specific? (Probably not worth
+	 * it).  sha2_seed is pretty bad for large amounts of entropy, so make
+	 * that into something which is suitable for anything. */
+	sha2_seed(salt, salt_len, seed, seed_len);
+    }
+
+    state = crypt_create(method_nr, key, salt, salt_len, seed, seed_len);
+    if (state == NULL)
+    {
+	vim_free(*header);
+	*header = NULL;
+    }
+    return state;
+}
+
+/*
+ * Free the crypt state.
+ */
+    void
+crypt_free_state(state)
+    cryptstate_T	*state;
+{
+    vim_free(state->method_state);
+    vim_free(state);
+}
+
+/*
+ * Encode "from[len]" and store the result in a newly allocated buffer, which
+ * is stored in "newptr".
+ * Return number of bytes in "newptr", 0 for need more or -1 on error.
+ */
+    long
+crypt_encode_alloc(state, from, len, newptr)
+    cryptstate_T *state;
+    char_u	*from;
+    size_t	len;
+    char_u	**newptr;
+{
+    cryptmethod_T *method = &cryptmethods[state->method_nr];
+
+    if (method->encode_buffer_fn != NULL)
+	/* Has buffer function, pass through. */
+	return method->encode_buffer_fn(state, from, len, newptr);
+    if (len == 0)
+	/* Not buffering, just return EOF. */
+	return (long)len;
+
+    *newptr = alloc((long)len);
+    if (*newptr == NULL)
+	return -1;
+    method->encode_fn(state, from, len, *newptr);
+    return (long)len;
+}
+
+/*
+ * Decrypt "ptr[len]" and store the result in a newly allocated buffer, which
+ * is stored in "newptr".
+ * Return number of bytes in "newptr", 0 for need more or -1 on error.
+ */
+    long
+crypt_decode_alloc(state, ptr, len, newptr)
+    cryptstate_T *state;
+    char_u	*ptr;
+    long	len;
+    char_u      **newptr;
+{
+    cryptmethod_T *method = &cryptmethods[state->method_nr];
+
+    if (method->decode_buffer_fn != NULL)
+	/* Has buffer function, pass through. */
+	return method->decode_buffer_fn(state, ptr, len, newptr);
+
+    if (len == 0)
+	/* Not buffering, just return EOF. */
+	return len;
+
+    *newptr = alloc(len);
+    if (*newptr == NULL)
+	return -1;
+    method->decode_fn(state, ptr, len, *newptr);
+    return len;
+}
+
+/*
+ * Encrypting "from[len]" into "to[len]".
+ */
+    void
+crypt_encode(state, from, len, to)
+    cryptstate_T *state;
+    char_u	*from;
+    size_t	len;
+    char_u	*to;
+{
+    cryptmethods[state->method_nr].encode_fn(state, from, len, to);
+}
+
+/*
+ * decrypting "from[len]" into "to[len]".
+ */
+    void
+crypt_decode(state, from, len, to)
+    cryptstate_T *state;
+    char_u	*from;
+    size_t	len;
+    char_u	*to;
+{
+    cryptmethods[state->method_nr].decode_fn(state, from, len, to);
+}
+
+/*
+ * Simple inplace encryption, modifies "buf[len]" in place.
+ */
+    void
+crypt_encode_inplace(state, buf, len)
+    cryptstate_T *state;
+    char_u	*buf;
+    size_t	len;
+{
+    cryptmethods[state->method_nr].encode_inplace_fn(state, buf, len, buf);
+}
+
+/*
+ * Simple inplace decryption, modifies "buf[len]" in place.
+ */
+    void
+crypt_decode_inplace(state, buf, len)
+    cryptstate_T *state;
+    char_u	*buf;
+    size_t	len;
+{
+    cryptmethods[state->method_nr].decode_inplace_fn(state, buf, len, buf);
+}
+
+/*
+ * Free an allocated crypt key.  Clear the text to make sure it doesn't stay
+ * in memory anywhere.
+ */
+    void
+crypt_free_key(key)
+    char_u *key;
+{
+    char_u *p;
+
+    if (key != NULL)
+    {
+	for (p = key; *p != NUL; ++p)
+	    *p = 0;
+	vim_free(key);
+    }
+}
+
+/*
+ * Ask the user for a crypt key.
+ * When "store" is TRUE, the new key is stored in the 'key' option, and the
+ * 'key' option value is returned: Don't free it.
+ * When "store" is FALSE, the typed key is returned in allocated memory.
+ * Returns NULL on failure.
+ */
+    char_u *
+crypt_get_key(store, twice)
+    int		store;
+    int		twice;	    /* Ask for the key twice. */
+{
+    char_u	*p1, *p2 = NULL;
+    int		round;
+
+    for (round = 0; ; ++round)
+    {
+	cmdline_star = TRUE;
+	cmdline_row = msg_row;
+	p1 = getcmdline_prompt(NUL, round == 0
+		? (char_u *)_("Enter encryption key: ")
+		: (char_u *)_("Enter same key again: "), 0, EXPAND_NOTHING,
+		NULL);
+	cmdline_star = FALSE;
+
+	if (p1 == NULL)
+	    break;
+
+	if (round == twice)
+	{
+	    if (p2 != NULL && STRCMP(p1, p2) != 0)
+	    {
+		MSG(_("Keys don't match!"));
+		crypt_free_key(p1);
+		crypt_free_key(p2);
+		p2 = NULL;
+		round = -1;		/* do it again */
+		continue;
+	    }
+
+	    if (store)
+	    {
+		set_option_value((char_u *)"key", 0L, p1, OPT_LOCAL);
+		crypt_free_key(p1);
+		p1 = curbuf->b_p_key;
+	    }
+	    break;
+	}
+	p2 = p1;
+    }
+
+    /* since the user typed this, no need to wait for return */
+    if (msg_didout)
+	msg_putchar('\n');
+    need_wait_return = FALSE;
+    msg_didout = FALSE;
+
+    crypt_free_key(p2);
+    return p1;
+}
+
+
+/*
+ * Append a message to IObuff for the encryption/decryption method being used.
+ */
+    void
+crypt_append_msg(buf)
+    buf_T *buf;
+{
+    if (crypt_get_method_nr(buf) == 0)
+	STRCAT(IObuff, _("[crypted]"));
+    else
+    {
+	STRCAT(IObuff, "[");
+	STRCAT(IObuff, *buf->b_p_cm == NUL ? p_cm : buf->b_p_cm);
+	STRCAT(IObuff, "]");
+    }
+}
+
+#endif /* FEAT_CRYPT */
diff -Naur vim74.orig/src/crypt_zip.c vim74/src/crypt_zip.c
--- vim74.orig/src/crypt_zip.c	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/crypt_zip.c	2014-10-10 14:53:44.245380798 +0000
@@ -0,0 +1,158 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * crypt_zip.c: Zip encryption support.
+ */
+#include "vim.h"
+
+#if defined(FEAT_CRYPT) || defined(PROTO)
+/*
+ * Optional encryption support.
+ * Mohsin Ahmed, mosh@sasi.com, 98-09-24
+ * Based on zip/crypt sources.
+ *
+ * NOTE FOR USA: Since 2000 exporting this code from the USA is allowed to
+ * most countries.  There are a few exceptions, but that still should not be a
+ * problem since this code was originally created in Europe and India.
+ */
+
+/* Need a type that should be 32 bits. 64 also works but wastes space. */
+# if VIM_SIZEOF_INT >= 4
+typedef unsigned int u32_T;	/* int is at least 32 bits */
+# else
+typedef unsigned long u32_T;	/* long should be 32 bits or more */
+# endif
+
+/* The state of encryption, referenced by cryptstate_T. */
+typedef struct {
+    u32_T keys[3];
+} zip_state_T;
+
+
+static void make_crc_tab __ARGS((void));
+
+static u32_T crc_32_table[256];
+
+/*
+ * Fill the CRC table, if not done already.
+ */
+    static void
+make_crc_tab()
+{
+    u32_T	s, t, v;
+    static int	done = FALSE;
+
+    if (done)
+	return;
+    for (t = 0; t < 256; t++)
+    {
+	v = t;
+	for (s = 0; s < 8; s++)
+	    v = (v >> 1) ^ ((v & 1) * (u32_T)0xedb88320L);
+	crc_32_table[t] = v;
+    }
+    done = TRUE;
+}
+
+#define CRC32(c, b) (crc_32_table[((int)(c) ^ (b)) & 0xff] ^ ((c) >> 8))
+
+/*
+ * Return the next byte in the pseudo-random sequence.
+ */
+#define DECRYPT_BYTE_ZIP(keys, t) { \
+    short_u temp = (short_u)keys[2] | 2; \
+    t = (int)(((unsigned)(temp * (temp ^ 1U)) >> 8) & 0xff); \
+}
+
+/*
+ * Update the encryption keys with the next byte of plain text.
+ */
+#define UPDATE_KEYS_ZIP(keys, c) { \
+    keys[0] = CRC32(keys[0], (c)); \
+    keys[1] += keys[0] & 0xff; \
+    keys[1] = keys[1] * 134775813L + 1; \
+    keys[2] = CRC32(keys[2], (int)(keys[1] >> 24)); \
+}
+
+/*
+ * Initialize for encryption/decryption.
+ */
+    void
+crypt_zip_init(state, key, salt, salt_len, seed, seed_len)
+    cryptstate_T    *state;
+    char_u	    *key;
+    char_u	    *salt UNUSED;
+    int		    salt_len UNUSED;
+    char_u	    *seed UNUSED;
+    int		    seed_len UNUSED;
+{
+    char_u	*p;
+    zip_state_T	*zs;
+
+    zs = (zip_state_T *)alloc(sizeof(zip_state_T));
+    state->method_state = zs;
+
+    make_crc_tab();
+    zs->keys[0] = 305419896L;
+    zs->keys[1] = 591751049L;
+    zs->keys[2] = 878082192L;
+    for (p = key; *p != NUL; ++p)
+    {
+	UPDATE_KEYS_ZIP(zs->keys, (int)*p);
+    }
+}
+
+/*
+ * Encrypt "from[len]" into "to[len]".
+ * "from" and "to" can be equal to encrypt in place.
+ */
+    void
+crypt_zip_encode(state, from, len, to)
+    cryptstate_T *state;
+    char_u	*from;
+    size_t	len;
+    char_u	*to;
+{
+    zip_state_T *zs = state->method_state;
+    size_t	i;
+    int		ztemp, t;
+
+    for (i = 0; i < len; ++i)
+    {
+	ztemp = from[i];
+	DECRYPT_BYTE_ZIP(zs->keys, t);
+	UPDATE_KEYS_ZIP(zs->keys, ztemp);
+	to[i] = t ^ ztemp;
+    }
+}
+
+/*
+ * Decrypt "from[len]" into "to[len]".
+ */
+    void
+crypt_zip_decode(state, from, len, to)
+    cryptstate_T *state;
+    char_u	*from;
+    size_t	len;
+    char_u	*to;
+{
+    zip_state_T *zs = state->method_state;
+    size_t	i;
+    short_u	temp;
+
+    for (i = 0; i < len; ++i)
+    {
+	temp = (short_u)zs->keys[2] | 2;
+	temp = (int)(((unsigned)(temp * (temp ^ 1U)) >> 8) & 0xff);
+	UPDATE_KEYS_ZIP(zs->keys, to[i] = from[i] ^ temp);
+    }
+}
+
+#endif /* FEAT_CRYPT */
diff -Naur vim74.orig/src/diff.c vim74/src/diff.c
--- vim74.orig/src/diff.c	2013-07-17 11:43:15.000000000 +0000
+++ vim74/src/diff.c	2014-10-10 14:53:44.248714123 +0000
@@ -622,6 +622,7 @@
 		    wp->w_topfill = (n < 0 ? 0 : n);
 		else if (n > 0 && n > wp->w_topfill)
 		    wp->w_topfill = n;
+		check_topfill(wp, FALSE);
 	    }
 	}
 }
@@ -1203,7 +1204,7 @@
 
     for (wp = firstwin; wp != NULL; wp = wp->w_next)
     {
-	if (wp == curwin || (eap->forceit && wp->w_p_diff))
+	if (eap->forceit ? wp->w_p_diff : wp == curwin)
 	{
 	    /* Set 'diff', 'scrollbind' off and 'wrap' on. If option values
 	     * were saved in diff_win_options() restore them. */
diff -Naur vim74.orig/src/digraph.c vim74/src/digraph.c
--- vim74.orig/src/digraph.c	2012-01-10 20:57:16.000000000 +0000
+++ vim74/src/digraph.c	2014-10-10 14:53:44.252047448 +0000
@@ -1425,6 +1425,8 @@
 	{'W', '=', 0x20a9},
 	{'=', 'e', 0x20ac}, /* euro */
 	{'E', 'u', 0x20ac}, /* euro */
+	{'=', 'R', 0x20bd}, /* rouble */
+	{'=', 'P', 0x20bd}, /* rouble */
 	{'o', 'C', 0x2103},
 	{'c', 'o', 0x2105},
 	{'o', 'F', 0x2109},
diff -Naur vim74.orig/src/dosinst.c vim74/src/dosinst.c
--- vim74.orig/src/dosinst.c	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/dosinst.c	2014-10-10 14:53:44.258714098 +0000
@@ -1192,23 +1192,29 @@
 	fprintf(fd, "  if arg3 =~ ' ' | let arg3 = '\"' . arg3 . '\"' | endif\n");
 
 	/* If the path has a space:  When using cmd.exe (Win NT/2000/XP) put
-	 * quotes around the whole command and around the diff command.
+	 * quotes around the diff command and rely on the default value of
+         * shellxquote to solve the quoting problem for the whole command.
+         *
 	 * Otherwise put a double quote just before the space and at the
 	 * end of the command.  Putting quotes around the whole thing
 	 * doesn't work on Win 95/98/ME.  This is mostly guessed! */
-	fprintf(fd, "  let eq = ''\n");
 	fprintf(fd, "  if $VIMRUNTIME =~ ' '\n");
 	fprintf(fd, "    if &sh =~ '\\<cmd'\n");
-	fprintf(fd, "      let cmd = '\"\"' . $VIMRUNTIME . '\\diff\"'\n");
-	fprintf(fd, "      let eq = '\"'\n");
+	fprintf(fd, "      if empty(&shellxquote)\n");
+	fprintf(fd, "        let l:shxq_sav = ''\n");
+	fprintf(fd, "        set shellxquote&\n");
+	fprintf(fd, "      endif\n");
+	fprintf(fd, "      let cmd = '\"' . $VIMRUNTIME . '\\diff\"'\n");
 	fprintf(fd, "    else\n");
 	fprintf(fd, "      let cmd = substitute($VIMRUNTIME, ' ', '\" ', '') . '\\diff\"'\n");
 	fprintf(fd, "    endif\n");
 	fprintf(fd, "  else\n");
 	fprintf(fd, "    let cmd = $VIMRUNTIME . '\\diff'\n");
 	fprintf(fd, "  endif\n");
-	fprintf(fd, "  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq\n");
-
+	fprintf(fd, "  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3\n");
+	fprintf(fd, "  if exists('l:shxq_sav')\n");
+	fprintf(fd, "    let &shellxquote=l:shxq_sav\n");
+	fprintf(fd, "  endif\n");
 	fprintf(fd, "endfunction\n");
 	fprintf(fd, "\n");
     }
@@ -1773,9 +1779,11 @@
 
 /*
  * We used to use "homedir" as the working directory, but that is a bad choice
- * on multi-user systems.  Not specifying a directory appears to work best.
+ * on multi-user systems.  However, not specifying a directory results in the
+ * current directory to be c:\Windows\system32 on Windows 7. Use environment
+ * variables instead.
  */
-#define WORKDIR ""
+#define WORKDIR "%HOMEDRIVE%%HOMEPATH%"
 
 /*
  * Create shortcut(s) in the Start Menu\Programs\Vim folder.
diff -Naur vim74.orig/src/edit.c vim74/src/edit.c
--- vim74.orig/src/edit.c	2013-07-04 18:22:25.000000000 +0000
+++ vim74/src/edit.c	2014-10-10 14:53:44.282047373 +0000
@@ -199,7 +199,7 @@
 static void spell_back_to_badword __ARGS((void));
 static int  spell_bad_len = 0;	/* length of located bad word */
 #endif
-static void stop_insert __ARGS((pos_T *end_insert_pos, int esc));
+static void stop_insert __ARGS((pos_T *end_insert_pos, int esc, int nomove));
 static int  echeck_abbr __ARGS((int));
 static int  replace_pop __ARGS((void));
 static void replace_join __ARGS((int off));
@@ -220,9 +220,7 @@
 #ifdef FEAT_RIGHTLEFT
 static void ins_ctrl_ __ARGS((void));
 #endif
-#ifdef FEAT_VISUAL
 static int ins_start_select __ARGS((int c));
-#endif
 static void ins_insert __ARGS((int replaceState));
 static void ins_ctrl_o __ARGS((void));
 static void ins_shift __ARGS((int c, int lastc));
@@ -264,6 +262,7 @@
 
 static colnr_T	Insstart_textlen;	/* length of line when insert started */
 static colnr_T	Insstart_blank_vcol;	/* vcol for first inserted blank */
+static int	update_Insstart_orig = TRUE; /* set Insstart_orig to Insstart */
 
 static char_u	*last_insert = NULL;	/* the text of the previous insert,
 					   K_SPECIAL and CSI are escaped */
@@ -340,6 +339,9 @@
      * error message */
     check_for_delay(TRUE);
 
+    /* set Insstart_orig to Insstart */
+    update_Insstart_orig = TRUE;
+
 #ifdef HAVE_SANDBOX
     /* Don't allow inserting in the sandbox. */
     if (sandbox != 0)
@@ -631,6 +633,9 @@
 	if (arrow_used)	    /* don't repeat insert when arrow key used */
 	    count = 0;
 
+	if (update_Insstart_orig)
+	    Insstart_orig = Insstart;
+
 	if (stop_insert_mode)
 	{
 	    /* ":stopinsert" used or 'insertmode' reset */
@@ -925,7 +930,6 @@
 	    }
 #endif
 
-#ifdef FEAT_VISUAL
 	/*
 	 * If 'keymodel' contains "startsel", may start selection.  If it
 	 * does, a CTRL-O and c will be stuffed, we need to get these
@@ -933,7 +937,6 @@
 	 */
 	if (ins_start_select(c))
 	    continue;
-#endif
 
 	/*
 	 * The big switch to handle a character in insert mode.
@@ -1556,87 +1559,89 @@
     int		conceal_update_lines = FALSE;
 #endif
 
-    if (!char_avail())
-    {
+    if (char_avail())
+	return;
+
 #if defined(FEAT_AUTOCMD) || defined(FEAT_CONCEAL)
-	/* Trigger CursorMoved if the cursor moved.  Not when the popup menu is
-	 * visible, the command might delete it. */
-	if (ready && (
+    /* Trigger CursorMoved if the cursor moved.  Not when the popup menu is
+     * visible, the command might delete it. */
+    if (ready && (
 # ifdef FEAT_AUTOCMD
-		    has_cursormovedI()
+		has_cursormovedI()
 # endif
 # if defined(FEAT_AUTOCMD) && defined(FEAT_CONCEAL)
-		    ||
+		||
 # endif
 # ifdef FEAT_CONCEAL
-		    curwin->w_p_cole > 0
+		curwin->w_p_cole > 0
 # endif
-		    )
-	    && !equalpos(last_cursormoved, curwin->w_cursor)
+		)
+	&& !equalpos(last_cursormoved, curwin->w_cursor)
 # ifdef FEAT_INS_EXPAND
-	    && !pum_visible()
+	&& !pum_visible()
 # endif
-	   )
-	{
+       )
+    {
 # ifdef FEAT_SYN_HL
-	    /* Need to update the screen first, to make sure syntax
-	     * highlighting is correct after making a change (e.g., inserting
-	     * a "(".  The autocommand may also require a redraw, so it's done
-	     * again below, unfortunately. */
-	    if (syntax_present(curwin) && must_redraw)
-		update_screen(0);
+	/* Need to update the screen first, to make sure syntax
+	 * highlighting is correct after making a change (e.g., inserting
+	 * a "(".  The autocommand may also require a redraw, so it's done
+	 * again below, unfortunately. */
+	if (syntax_present(curwin) && must_redraw)
+	    update_screen(0);
 # endif
 # ifdef FEAT_AUTOCMD
-	    if (has_cursormovedI())
-		apply_autocmds(EVENT_CURSORMOVEDI, NULL, NULL, FALSE, curbuf);
+	if (has_cursormovedI())
+	    apply_autocmds(EVENT_CURSORMOVEDI, NULL, NULL, FALSE, curbuf);
 # endif
 # ifdef FEAT_CONCEAL
-	    if (curwin->w_p_cole > 0)
-	    {
-		conceal_old_cursor_line = last_cursormoved.lnum;
-		conceal_new_cursor_line = curwin->w_cursor.lnum;
-		conceal_update_lines = TRUE;
-	    }
-# endif
-	    last_cursormoved = curwin->w_cursor;
+	if (curwin->w_p_cole > 0)
+	{
+	    conceal_old_cursor_line = last_cursormoved.lnum;
+	    conceal_new_cursor_line = curwin->w_cursor.lnum;
+	    conceal_update_lines = TRUE;
 	}
+# endif
+	last_cursormoved = curwin->w_cursor;
+    }
 #endif
+
 #ifdef FEAT_AUTOCMD
-	/* Trigger TextChangedI if b_changedtick differs. */
-	if (!ready && has_textchangedI()
-		&& last_changedtick != curbuf->b_changedtick
+    /* Trigger TextChangedI if b_changedtick differs. */
+    if (ready && has_textchangedI()
+	    && last_changedtick != curbuf->b_changedtick
 # ifdef FEAT_INS_EXPAND
-		&& !pum_visible()
+	    && !pum_visible()
 # endif
-		)
-	{
-	    if (last_changedtick_buf == curbuf)
-		apply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);
-	    last_changedtick_buf = curbuf;
-	    last_changedtick = curbuf->b_changedtick;
-	}
+	    )
+    {
+	if (last_changedtick_buf == curbuf)
+	    apply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);
+	last_changedtick_buf = curbuf;
+	last_changedtick = curbuf->b_changedtick;
+    }
 #endif
-	if (must_redraw)
-	    update_screen(0);
-	else if (clear_cmdline || redraw_cmdline)
-	    showmode();		/* clear cmdline and show mode */
+
+    if (must_redraw)
+	update_screen(0);
+    else if (clear_cmdline || redraw_cmdline)
+	showmode();		/* clear cmdline and show mode */
 # if defined(FEAT_CONCEAL)
-	if ((conceal_update_lines
-		&& (conceal_old_cursor_line != conceal_new_cursor_line
-		    || conceal_cursor_line(curwin)))
-		|| need_cursor_line_redraw)
-	{
-	    if (conceal_old_cursor_line != conceal_new_cursor_line)
-		update_single_line(curwin, conceal_old_cursor_line);
-	    update_single_line(curwin, conceal_new_cursor_line == 0
-			   ? curwin->w_cursor.lnum : conceal_new_cursor_line);
-	    curwin->w_valid &= ~VALID_CROW;
-	}
-# endif
-	showruler(FALSE);
-	setcursor();
-	emsg_on_display = FALSE;	/* may remove error message now */
+    if ((conceal_update_lines
+	    && (conceal_old_cursor_line != conceal_new_cursor_line
+		|| conceal_cursor_line(curwin)))
+	    || need_cursor_line_redraw)
+    {
+	if (conceal_old_cursor_line != conceal_new_cursor_line)
+	    update_single_line(curwin, conceal_old_cursor_line);
+	update_single_line(curwin, conceal_new_cursor_line == 0
+		       ? curwin->w_cursor.lnum : conceal_new_cursor_line);
+	curwin->w_valid &= ~VALID_CROW;
     }
+# endif
+    showruler(FALSE);
+    setcursor();
+    emsg_on_display = FALSE;	/* may remove error message now */
 }
 
 /*
@@ -1951,7 +1956,7 @@
 	    else
 #endif
 		++new_cursor_col;
-	    vcol += lbr_chartabsize(ptr + new_cursor_col, (colnr_T)vcol);
+	    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);
 	}
 	vcol = last_vcol;
 
@@ -3467,7 +3472,6 @@
     }
 
     compl_enter_selects = !compl_used_match;
-    compl_shown_match = compl_curr_match = compl_first_match;
 
     /* Show the popup menu with a different set of matches. */
     ins_compl_show_pum();
@@ -3850,7 +3854,8 @@
 	    ins_compl_free();
 	    compl_started = FALSE;
 	    compl_matches = 0;
-	    msg_clr_cmdline();		/* necessary for "noshowmode" */
+	    if (!shortmess(SHM_COMPLETIONMENU))
+		msg_clr_cmdline();	/* necessary for "noshowmode" */
 	    ctrl_x_mode = 0;
 	    compl_enter_selects = FALSE;
 	    if (edit_submode != NULL)
@@ -4030,7 +4035,7 @@
 	goto theend;
     }
     curwin->w_cursor = pos;	/* restore the cursor position */
-    check_cursor();
+    validate_cursor();
     if (!equalpos(curwin->w_cursor, pos))
     {
 	EMSG(_(e_compldel));
@@ -4179,6 +4184,7 @@
     char_u	*dict = NULL;
     int		dict_f = 0;
     compl_T	*old_match;
+    int		set_match_pos;
 
     if (!compl_started)
     {
@@ -4197,6 +4203,7 @@
     for (;;)
     {
 	found_new_match = FAIL;
+	set_match_pos = FALSE;
 
 	/* For ^N/^P pick a new entry from e_cpt if compl_started is off,
 	 * or if found_all says this entry is done.  For ^X^L only use the
@@ -4216,6 +4223,10 @@
 		    dec(&first_match_pos);
 		last_match_pos = first_match_pos;
 		type = 0;
+
+		/* Remember the first match so that the loop stops when we
+		 * wrap and come back there a second time. */
+		set_match_pos = TRUE;
 	    }
 	    else if (vim_strchr((char_u *)"buwU", *e_cpt) != NULL
 		 && (ins_buf = ins_compl_next_buf(ins_buf, *e_cpt)) != curbuf)
@@ -4380,7 +4391,7 @@
 	    if (ins_buf->b_p_inf)
 		p_scs = FALSE;
 
-	    /*	buffers other than curbuf are scanned from the beginning or the
+	    /*	Buffers other than curbuf are scanned from the beginning or the
 	     *	end but never from the middle, thus setting nowrapscan in this
 	     *	buffers is a good idea, on the other hand, we always set
 	     *	wrapscan for curbuf to avoid missing matches -- Acevedo,Webb */
@@ -4407,12 +4418,13 @@
 				 compl_pattern, 1L, SEARCH_KEEP + SEARCH_NFMSG,
 						  RE_LAST, (linenr_T)0, NULL);
 		--msg_silent;
-		if (!compl_started)
+		if (!compl_started || set_match_pos)
 		{
 		    /* set "compl_started" even on fail */
 		    compl_started = TRUE;
 		    first_match_pos = *pos;
 		    last_match_pos = *pos;
+		    set_match_pos = FALSE;
 		}
 		else if (first_match_pos.lnum == last_match_pos.lnum
 				 && first_match_pos.col == last_match_pos.col)
@@ -4580,6 +4592,9 @@
      */
     i = compl_col + (compl_cont_status & CONT_ADDING ? compl_length : 0);
     backspace_until_column(i);
+
+    /* TODO: is this sufficient for redrawing?  Redrawing everything causes
+     * flicker, thus we can't do that. */
     changed_cline_bef_curs();
 }
 
@@ -5184,9 +5199,21 @@
 	}
 	else if (ctrl_x_mode == CTRL_X_FILES)
 	{
-	    while (--startcol >= 0 && vim_isfilec(line[startcol]))
-		;
-	    compl_col += ++startcol;
+	    /* Go back to just before the first filename character. */
+	    if (startcol > 0)
+	    {
+		char_u	*p = line + startcol;
+
+		mb_ptr_back(line, p);
+		while (p > line && vim_isfilec(PTR2CHAR(p)))
+		    mb_ptr_back(line, p);
+		if (p == line && vim_isfilec(PTR2CHAR(p)))
+		    startcol = 0;
+		else
+		    startcol = (int)(p - line) + 1;
+	    }
+
+	    compl_col += startcol;
 	    compl_length = (int)curs_col - startcol;
 	    compl_pattern = addstar(line + compl_col, compl_length,
 								EXPAND_FILES);
@@ -5246,7 +5273,7 @@
 		return FAIL;
 	    }
 	    curwin->w_cursor = pos;	/* restore the cursor position */
-	    check_cursor();
+	    validate_cursor();
 	    if (!equalpos(curwin->w_cursor, pos))
 	    {
 		EMSG(_(e_compldel));
@@ -5262,7 +5289,8 @@
 	    {
 		ctrl_x_mode = 0;
 		edit_submode = NULL;
-		msg_clr_cmdline();
+		if (!shortmess(SHM_COMPLETIONMENU))
+		    msg_clr_cmdline();
 		return FAIL;
 	    }
 
@@ -5521,15 +5549,18 @@
 
     /* Show a message about what (completion) mode we're in. */
     showmode();
-    if (edit_submode_extra != NULL)
+    if (!shortmess(SHM_COMPLETIONMENU))
     {
-	if (!p_smd)
-	    msg_attr(edit_submode_extra,
-		    edit_submode_highl < HLF_COUNT
-		    ? hl_attr(edit_submode_highl) : 0);
+	if (edit_submode_extra != NULL)
+	{
+	    if (!p_smd)
+		msg_attr(edit_submode_extra,
+			edit_submode_highl < HLF_COUNT
+			? hl_attr(edit_submode_highl) : 0);
+	}
+	else
+	    msg_clr_cmdline();	/* necessary for "noshowmode" */
     }
-    else
-	msg_clr_cmdline();	/* necessary for "noshowmode" */
 
     /* Show the popup menu, unless we got interrupted. */
     if (!compl_interrupted)
@@ -6100,6 +6131,12 @@
     int		no_leader = FALSE;
     int		do_comments = (flags & INSCHAR_DO_COM);
 #endif
+#ifdef FEAT_LINEBREAK
+    int		has_lbr = curwin->w_p_lbr;
+
+    /* make sure win_lbr_chartabsize() counts correctly */
+    curwin->w_p_lbr = FALSE;
+#endif
 
     /*
      * When 'ai' is off we don't want a space under the cursor to be
@@ -6452,6 +6489,9 @@
     if (save_char != NUL)		/* put back space after cursor */
 	pchar_cursor(save_char);
 
+#ifdef FEAT_LINEBREAK
+    curwin->w_p_lbr = has_lbr;
+#endif
     if (!format_only && haveto_redraw)
     {
 	update_topline();
@@ -6687,7 +6727,7 @@
     if (!arrow_used)	    /* something has been inserted */
     {
 	AppendToRedobuff(ESC_STR);
-	stop_insert(end_insert_pos, FALSE);
+	stop_insert(end_insert_pos, FALSE, FALSE);
 	arrow_used = TRUE;	/* this means we stopped the current insert */
     }
 #ifdef FEAT_SPELL
@@ -6737,13 +6777,19 @@
 {
     if (arrow_used)
     {
+	Insstart = curwin->w_cursor;	/* new insertion starts here */
+	if (Insstart.col > Insstart_orig.col && !ins_need_undo)
+	    /* Don't update the original insert position when moved to the
+	     * right, except when nothing was inserted yet. */
+	    update_Insstart_orig = FALSE;
+	Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
+
 	if (u_save_cursor() == OK)
 	{
 	    arrow_used = FALSE;
 	    ins_need_undo = FALSE;
 	}
-	Insstart = curwin->w_cursor;	/* new insertion starts here */
-	Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
+
 	ai_col = 0;
 #ifdef FEAT_VREPLACE
 	if (State & VREPLACE_FLAG)
@@ -6776,9 +6822,10 @@
  * to another window/buffer.
  */
     static void
-stop_insert(end_insert_pos, esc)
+stop_insert(end_insert_pos, esc, nomove)
     pos_T	*end_insert_pos;
     int		esc;			/* called by ins_esc() */
+    int		nomove;			/* <c-\><c-o>, don't move cursor */
 {
     int		cc;
     char_u	*ptr;
@@ -6849,7 +6896,7 @@
 	 * Do this when ESC was used or moving the cursor up/down.
 	 * Check for the old position still being valid, just in case the text
 	 * got changed unexpectedly. */
-	if (did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL
+	if (!nomove && did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL
 			&& curwin->w_cursor.lnum != end_insert_pos->lnum))
 		&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)
 	{
@@ -6872,7 +6919,6 @@
 	    else if (cc != NUL)
 		++curwin->w_cursor.col;	/* put cursor back on the NUL */
 
-#ifdef FEAT_VISUAL
 	    /* <C-S-Right> may have started Visual mode, adjust the position for
 	     * deleted characters. */
 	    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)
@@ -6882,12 +6928,11 @@
 		if (VIsual.col > len)
 		{
 		    VIsual.col = len;
-# ifdef FEAT_VIRTUALEDIT
+#ifdef FEAT_VIRTUALEDIT
 		    VIsual.coladd = 0;
-# endif
+#endif
 		}
 	    }
-#endif
 	}
     }
     did_ai = FALSE;
@@ -6902,6 +6947,7 @@
     if (end_insert_pos != NULL)
     {
 	curbuf->b_op_start = Insstart;
+	curbuf->b_op_start_orig = Insstart_orig;
 	curbuf->b_op_end = *end_insert_pos;
     }
 }
@@ -7098,9 +7144,10 @@
 	for (;;)
 	{
 	    coladvance(v - width);
-	    /* getviscol() is slow, skip it when 'showbreak' is empty and
-	     * there are no multi-byte characters */
-	    if ((*p_sbr == NUL
+	    /* getviscol() is slow, skip it when 'showbreak' is empty,
+	     * 'breakindent' is not set and there are no multi-byte
+	     * characters */
+	    if ((*p_sbr == NUL && !curwin->w_p_bri
 #  ifdef FEAT_MBYTE
 			&& !has_mbyte
 #  endif
@@ -7845,8 +7892,7 @@
 	    if (try_match && keytyped == ':')
 	    {
 		p = ml_get_curline();
-		if (cin_iscase(p, FALSE) || cin_isscopedecl(p)
-							   || cin_islabel(30))
+		if (cin_iscase(p, FALSE) || cin_isscopedecl(p) || cin_islabel())
 		    return TRUE;
 		/* Need to get the line again after cin_islabel(). */
 		p = ml_get_curline();
@@ -7856,7 +7902,7 @@
 		{
 		    p[curwin->w_cursor.col - 1] = ' ';
 		    i = (cin_iscase(p, FALSE) || cin_isscopedecl(p)
-							  || cin_islabel(30));
+							    || cin_islabel());
 		    p = ml_get_curline();
 		    p[curwin->w_cursor.col - 1] = ':';
 		    if (i)
@@ -8084,9 +8130,7 @@
     int		need_redraw = FALSE;
     int		regname;
     int		literally = 0;
-#ifdef FEAT_VISUAL
     int		vis_active = VIsual_active;
-#endif
 
     /*
      * If we are going to wait for a character, show a '"'.
@@ -8190,11 +8234,9 @@
     if (need_redraw || stuff_empty())
 	edit_unputchar();
 
-#ifdef FEAT_VISUAL
     /* Disallow starting Visual mode here, would get a weird mode. */
     if (!vis_active && VIsual_active)
 	end_visual_mode();
-#endif
 }
 
 /*
@@ -8237,6 +8279,7 @@
 
 		  /* Need to reset Insstart, esp. because a BS that joins
 		   * a line to the previous one must save for undo. */
+		  update_Insstart_orig = FALSE;
 		  Insstart = curwin->w_cursor;
 		  break;
 
@@ -8361,12 +8404,12 @@
 
 	    (void)start_redo_ins();
 	    if (cmdchar == 'r' || cmdchar == 'v')
-		stuffReadbuff(ESC_STR);	/* no ESC in redo buffer */
+		stuffRedoReadbuff(ESC_STR);	/* no ESC in redo buffer */
 	    ++RedrawingDisabled;
 	    disabled_redraw = TRUE;
 	    return FALSE;	/* repeat the insert */
 	}
-	stop_insert(&curwin->w_cursor, TRUE);
+	stop_insert(&curwin->w_cursor, TRUE, nomove);
 	undisplay_dollar();
     }
 
@@ -8390,11 +8433,7 @@
 #endif
 	       )
 	    && (restart_edit == NUL
-		   || (gchar_cursor() == NUL
-#ifdef FEAT_VISUAL
-		       && !VIsual_active
-#endif
-		      ))
+		   || (gchar_cursor() == NUL && !VIsual_active))
 #ifdef FEAT_RIGHTLEFT
 	    && !revins_on
 #endif
@@ -8496,7 +8535,6 @@
 }
 #endif
 
-#ifdef FEAT_VISUAL
 /*
  * If 'keymodel' contains "startsel", may start selection.
  * Returns TRUE when a CTRL-O and other keys stuffed.
@@ -8552,7 +8590,6 @@
 	}
     return FALSE;
 }
-#endif
 
 /*
  * <Insert> key in Insert mode: toggle insert/replace mode.
@@ -8672,7 +8709,7 @@
     {
 	temp = curwin->w_cursor.col;
 	if (!can_bs(BS_EOL)		/* only if "eol" included */
-		|| do_join(2, FALSE, TRUE, FALSE) == FAIL)
+		|| do_join(2, FALSE, TRUE, FALSE, FALSE) == FAIL)
 	    vim_beep();
 	else
 	    curwin->w_cursor.col = temp;
@@ -8747,8 +8784,8 @@
 		((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)
 		    || (!can_bs(BS_START)
 			&& (arrow_used
-			    || (curwin->w_cursor.lnum == Insstart.lnum
-				&& curwin->w_cursor.col <= Insstart.col)))
+			    || (curwin->w_cursor.lnum == Insstart_orig.lnum
+				&& curwin->w_cursor.col <= Insstart_orig.col)))
 		    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0
 					 && curwin->w_cursor.col <= ai_col)
 		    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))
@@ -8799,8 +8836,8 @@
      */
     if (curwin->w_cursor.col == 0)
     {
-	lnum = Insstart.lnum;
-	if (curwin->w_cursor.lnum == Insstart.lnum
+	lnum = Insstart_orig.lnum;
+	if (curwin->w_cursor.lnum == lnum
 #ifdef FEAT_RIGHTLEFT
 			|| revins_on
 #endif
@@ -8809,8 +8846,9 @@
 	    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),
 			       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)
 		return FALSE;
-	    --Insstart.lnum;
-	    Insstart.col = MAXCOL;
+	    --Insstart_orig.lnum;
+	    Insstart_orig.col = MAXCOL;
+	    Insstart = Insstart_orig;
 	}
 	/*
 	 * In replace mode:
@@ -8853,7 +8891,7 @@
 			ptr[len - 1] = NUL;
 		}
 
-		(void)do_join(2, FALSE, FALSE, FALSE);
+		(void)do_join(2, FALSE, FALSE, FALSE, FALSE);
 		if (temp == NUL && gchar_cursor() != NUL)
 		    inc_cursor();
 	    }
@@ -8946,7 +8984,7 @@
 
 	    *inserted_space_p = FALSE;
 	    if (p_sta && in_indent)
-		ts = (int)get_sw_value();
+		ts = (int)get_sw_value(curbuf);
 	    else
 		ts = (int)get_sts_value();
 	    /* Compute the virtual column where we want to be.  Since
@@ -8968,9 +9006,9 @@
 	    while (vcol < want_vcol)
 	    {
 		/* Remember the first char we inserted */
-		if (curwin->w_cursor.lnum == Insstart.lnum
-				   && curwin->w_cursor.col < Insstart.col)
-		    Insstart.col = curwin->w_cursor.col;
+		if (curwin->w_cursor.lnum == Insstart_orig.lnum
+				   && curwin->w_cursor.col < Insstart_orig.col)
+		    Insstart_orig.col = curwin->w_cursor.col;
 
 #ifdef FEAT_VREPLACE
 		if (State & VREPLACE_FLAG)
@@ -9058,8 +9096,8 @@
 		revins_on ||
 #endif
 		(curwin->w_cursor.col > mincol
-		 && (curwin->w_cursor.lnum != Insstart.lnum
-		     || curwin->w_cursor.col != Insstart.col)));
+		 && (curwin->w_cursor.lnum != Insstart_orig.lnum
+		     || curwin->w_cursor.col != Insstart_orig.col)));
 	did_backspace = TRUE;
     }
 #ifdef FEAT_SMARTINDENT
@@ -9077,9 +9115,9 @@
     AppendCharToRedobuff(c);
 
     /* If deleted before the insertion point, adjust it */
-    if (curwin->w_cursor.lnum == Insstart.lnum
-				       && curwin->w_cursor.col < Insstart.col)
-	Insstart.col = curwin->w_cursor.col;
+    if (curwin->w_cursor.lnum == Insstart_orig.lnum
+				       && curwin->w_cursor.col < Insstart_orig.col)
+	Insstart_orig.col = curwin->w_cursor.col;
 
     /* vi behaviour: the cursor moves backward but the character that
      *		     was there remains visible
@@ -9635,7 +9673,7 @@
      * When nothing special, insert TAB like a normal character
      */
     if (!curbuf->b_p_et
-	    && !(p_sta && ind && curbuf->b_p_ts != get_sw_value())
+	    && !(p_sta && ind && curbuf->b_p_ts != get_sw_value(curbuf))
 	    && get_sts_value() == 0)
 	return TRUE;
 
@@ -9651,7 +9689,7 @@
     AppendToRedobuff((char_u *)"\t");
 
     if (p_sta && ind)		/* insert tab in indent, use 'shiftwidth' */
-	temp = (int)get_sw_value();
+	temp = (int)get_sw_value(curbuf);
     else if (curbuf->b_p_sts != 0) /* use 'softtabstop' when set */
 	temp = (int)get_sts_value();
     else			/* otherwise use 'tabstop' */
@@ -9740,11 +9778,11 @@
 	getvcol(curwin, &fpos, &vcol, NULL, NULL);
 	getvcol(curwin, cursor, &want_vcol, NULL, NULL);
 
-	/* Use as many TABs as possible.  Beware of 'showbreak' and
-	 * 'linebreak' adding extra virtual columns. */
+	/* Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'
+	 * and 'linebreak' adding extra virtual columns. */
 	while (vim_iswhite(*ptr))
 	{
-	    i = lbr_chartabsize((char_u *)"\t", vcol);
+	    i = lbr_chartabsize(NULL, (char_u *)"\t", vcol);
 	    if (vcol + i > want_vcol)
 		break;
 	    if (*ptr != TAB)
@@ -9766,11 +9804,12 @@
 	if (change_col >= 0)
 	{
 	    int repl_off = 0;
+	    char_u *line = ptr;
 
 	    /* Skip over the spaces we need. */
 	    while (vcol < want_vcol && *ptr == ' ')
 	    {
-		vcol += lbr_chartabsize(ptr, vcol);
+		vcol += lbr_chartabsize(line, ptr, vcol);
 		++ptr;
 		++repl_off;
 	    }
@@ -10011,6 +10050,7 @@
     int	    c;
     int	    temp;
     char_u  *ptr, *prev_ptr;
+    char_u  *line;
 
     if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)
     {
@@ -10020,13 +10060,13 @@
 
     /* try to advance to the cursor column */
     temp = 0;
-    ptr = ml_get(lnum);
+    line = ptr = ml_get(lnum);
     prev_ptr = ptr;
     validate_virtcol();
     while ((colnr_T)temp < curwin->w_virtcol && *ptr != NUL)
     {
 	prev_ptr = ptr;
-	temp += lbr_chartabsize_adv(&ptr, (colnr_T)temp);
+	temp += lbr_chartabsize_adv(line, &ptr, (colnr_T)temp);
     }
     if ((colnr_T)temp > curwin->w_virtcol)
 	ptr = prev_ptr;
diff -Naur vim74.orig/src/eval.c vim74/src/eval.c
--- vim74.orig/src/eval.c	2013-07-05 16:23:42.000000000 +0000
+++ vim74/src/eval.c	2014-10-10 14:53:44.322047272 +0000
@@ -125,9 +125,6 @@
  */
 static hashtab_T	compat_hashtab;
 
-/* When using exists() don't auto-load a script. */
-static int		no_autoload = FALSE;
-
 /*
  * When recursively copying lists and dicts we need to remember which ones we
  * have done to avoid endless recursiveness.  This unique ID is used for that.
@@ -137,6 +134,9 @@
 #define COPYID_INC 2
 #define COPYID_MASK (~0x1)
 
+/* Abort conversion to string after a recursion error. */
+static int  did_echo_string_emsg = FALSE;
+
 /*
  * Array to hold the hashtab with variables local to each sourced script.
  * Each item holds a variable (nameless) that points to the dict_T.
@@ -156,6 +156,11 @@
 /* Values for trans_function_name() argument: */
 #define TFN_INT		1	/* internal function name OK */
 #define TFN_QUIET	2	/* no error messages */
+#define TFN_NO_AUTOLOAD	4	/* do not use script autoloading */
+
+/* Values for get_lval() flags argument: */
+#define GLV_QUIET	TFN_QUIET	/* no error messages */
+#define GLV_NO_AUTOLOAD	TFN_NO_AUTOLOAD	/* do not use script autoloading */
 
 /*
  * Structure to hold info for a user function.
@@ -356,8 +361,10 @@
     {VV_NAME("mouse_col",	 VAR_NUMBER), 0},
     {VV_NAME("operator",	 VAR_STRING), VV_RO},
     {VV_NAME("searchforward",	 VAR_NUMBER), 0},
+    {VV_NAME("hlsearch",	 VAR_NUMBER), 0},
     {VV_NAME("oldfiles",	 VAR_LIST), 0},
     {VV_NAME("windowid",	 VAR_NUMBER), VV_RO},
+    {VV_NAME("progpath",	 VAR_STRING), VV_RO},
 };
 
 /* shorthand */
@@ -389,7 +396,7 @@
 static char_u *list_arg_vars __ARGS((exarg_T *eap, char_u *arg, int *first));
 static char_u *ex_let_one __ARGS((char_u *arg, typval_T *tv, int copy, char_u *endchars, char_u *op));
 static int check_changedtick __ARGS((char_u *arg));
-static char_u *get_lval __ARGS((char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int quiet, int fne_flags));
+static char_u *get_lval __ARGS((char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags));
 static void clear_lval __ARGS((lval_T *lp));
 static void set_var_lval __ARGS((lval_T *lp, char_u *endp, typval_T *rettv, int copy, char_u *op));
 static int tv_op __ARGS((typval_T *tv1, typval_T *tv2, char_u  *op));
@@ -444,7 +451,7 @@
 #endif
 static int get_env_tv __ARGS((char_u **arg, typval_T *rettv, int evaluate));
 static int find_internal_func __ARGS((char_u *name));
-static char_u *deref_func_name __ARGS((char_u *name, int *lenp));
+static char_u *deref_func_name __ARGS((char_u *name, int *lenp, int no_autoload));
 static int get_func_tv __ARGS((char_u *name, int len, typval_T *rettv, char_u **arg, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
 static int call_func __ARGS((char_u *funcname, int len, typval_T *rettv, int argcount, typval_T *argvars, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
 static void emsg_funcname __ARGS((char *ermsg, char_u *name));
@@ -459,6 +466,7 @@
 static void f_append __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_argc __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_argidx __ARGS((typval_T *argvars, typval_T *rettv));
+static void f_arglistid __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_argv __ARGS((typval_T *argvars, typval_T *rettv));
 #ifdef FEAT_FLOAT
 static void f_asin __ARGS((typval_T *argvars, typval_T *rettv));
@@ -474,7 +482,9 @@
 static void f_bufnr __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_bufwinnr __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_byte2line __ARGS((typval_T *argvars, typval_T *rettv));
+static void byteidx __ARGS((typval_T *argvars, typval_T *rettv, int comp));
 static void f_byteidx __ARGS((typval_T *argvars, typval_T *rettv));
+static void f_byteidxcomp __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_call __ARGS((typval_T *argvars, typval_T *rettv));
 #ifdef FEAT_FLOAT
 static void f_ceil __ARGS((typval_T *argvars, typval_T *rettv));
@@ -508,6 +518,7 @@
 static void f_eval __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_eventhandler __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_executable __ARGS((typval_T *argvars, typval_T *rettv));
+static void f_exepath __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_exists __ARGS((typval_T *argvars, typval_T *rettv));
 #ifdef FEAT_FLOAT
 static void f_exp __ARGS((typval_T *argvars, typval_T *rettv));
@@ -543,6 +554,7 @@
 static void f_getcmdline __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getcmdpos __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getcmdtype __ARGS((typval_T *argvars, typval_T *rettv));
+static void f_getcmdwintype __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getcwd __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getfontname __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getfperm __ARGS((typval_T *argvars, typval_T *rettv));
@@ -552,6 +564,7 @@
 static void f_getline __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getmatches __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getpid __ARGS((typval_T *argvars, typval_T *rettv));
+static void f_getcurpos __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getpos __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getqflist __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getreg __ARGS((typval_T *argvars, typval_T *rettv));
@@ -610,6 +623,7 @@
 static void f_mapcheck __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_match __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_matchadd __ARGS((typval_T *argvars, typval_T *rettv));
+static void f_matchaddpos __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_matcharg __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_matchdelete __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_matchend __ARGS((typval_T *argvars, typval_T *rettv));
@@ -719,6 +733,7 @@
 static void f_synstack __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_synconcealed __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_system __ARGS((typval_T *argvars, typval_T *rettv));
+static void f_systemlist __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_tabpagebuflist __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_tabpagenr __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_tabpagewinnr __ARGS((typval_T *argvars, typval_T *rettv));
@@ -739,6 +754,7 @@
 static void f_type __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_undofile __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_undotree __ARGS((typval_T *argvars, typval_T *rettv));
+static void f_uniq __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_values __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_virtcol __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_visualmode __ARGS((typval_T *argvars, typval_T *rettv));
@@ -755,7 +771,7 @@
 static void f_writefile __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_xor __ARGS((typval_T *argvars, typval_T *rettv));
 
-static int list2fpos __ARGS((typval_T *arg, pos_T *posp, int *fnump));
+static int list2fpos __ARGS((typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp));
 static pos_T *var2fpos __ARGS((typval_T *varp, int dollar_lnum, int *fnum));
 static int get_env_len __ARGS((char_u **arg));
 static int get_id_len __ARGS((char_u **arg));
@@ -767,7 +783,7 @@
 static char_u * make_expanded_name __ARGS((char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end));
 static int eval_isnamec __ARGS((int c));
 static int eval_isnamec1 __ARGS((int c));
-static int get_var_tv __ARGS((char_u *name, int len, typval_T *rettv, int verbose));
+static int get_var_tv __ARGS((char_u *name, int len, typval_T *rettv, int verbose, int no_autoload));
 static int handle_subscript __ARGS((char_u **arg, typval_T *rettv, int evaluate, int verbose));
 static typval_T *alloc_tv __ARGS((void));
 static typval_T *alloc_string_tv __ARGS((char_u *string));
@@ -778,8 +794,8 @@
 static char_u *get_tv_string __ARGS((typval_T *varp));
 static char_u *get_tv_string_buf __ARGS((typval_T *varp, char_u *buf));
 static char_u *get_tv_string_buf_chk __ARGS((typval_T *varp, char_u *buf));
-static dictitem_T *find_var __ARGS((char_u *name, hashtab_T **htp));
-static dictitem_T *find_var_in_ht __ARGS((hashtab_T *ht, int htname, char_u *varname, int writing));
+static dictitem_T *find_var __ARGS((char_u *name, hashtab_T **htp, int no_autoload));
+static dictitem_T *find_var_in_ht __ARGS((hashtab_T *ht, int htname, char_u *varname, int no_autoload));
 static hashtab_T *find_var_ht __ARGS((char_u *name, char_u **varname));
 static void vars_clear_ext __ARGS((hashtab_T *ht, int free_val));
 static void delete_var __ARGS((hashtab_T *ht, hashitem_T *hi));
@@ -799,7 +815,7 @@
 static void list_func_head __ARGS((ufunc_T *fp, int indent));
 static ufunc_T *find_func __ARGS((char_u *name));
 static int function_exists __ARGS((char_u *name));
-static int builtin_function __ARGS((char_u *name));
+static int builtin_function __ARGS((char_u *name, int len));
 #ifdef FEAT_PROFILE
 static void func_do_profile __ARGS((ufunc_T *fp));
 static void prof_sort_list __ARGS((FILE *fd, ufunc_T **sorttab, int st_len, char *title, int prefer_self));
@@ -828,6 +844,8 @@
 static int searchpair_cmn __ARGS((typval_T *argvars, pos_T *match_pos));
 static int search_cmn __ARGS((typval_T *argvars, pos_T *match_pos, int *flagsp));
 static void setwinvar __ARGS((typval_T *argvars, typval_T *rettv, int off));
+static int write_list __ARGS((FILE *fd, list_T *list, int binary));
+static void get_cmd_output_as_rettv __ARGS((typval_T *argvars, typval_T *rettv, int retlist));
 
 
 #ifdef EBCDIC
@@ -869,6 +887,7 @@
 	    hash_add(&compat_hashtab, p->vv_di.di_key);
     }
     set_vim_var_nr(VV_SEARCHFORWARD, 1L);
+    set_vim_var_nr(VV_HLSEARCH, 1L);
     set_reg_var(0);  /* default for v:register is not 0 but '"' */
 
 #ifdef EBCDIC
@@ -915,12 +934,13 @@
     /* autoloaded script names */
     ga_clear_strings(&ga_loaded);
 
-    /* script-local variables */
+    /* Script-local variables. First clear all the variables and in a second
+     * loop free the scriptvar_T, because a variable in one script might hold
+     * a reference to the whole scope of another script. */
     for (i = 1; i <= ga_scripts.ga_len; ++i)
-    {
 	vars_clear(&SCRIPT_VARS(i));
+    for (i = 1; i <= ga_scripts.ga_len; ++i)
 	vim_free(SCRIPT_SV(i));
-    }
     ga_clear(&ga_scripts);
 
     /* unreferenced lists and dicts */
@@ -1054,7 +1074,7 @@
     ga_init2(&redir_ga, (int)sizeof(char), 500);
 
     /* Parse the variable name (can be a dict or list entry). */
-    redir_endp = get_lval(redir_varname, NULL, redir_lval, FALSE, FALSE, FALSE,
+    redir_endp = get_lval(redir_varname, NULL, redir_lval, FALSE, FALSE, 0,
 							     FNE_CHECK_START);
     if (redir_endp == NULL || redir_lval->ll_name == NULL || *redir_endp != NUL)
     {
@@ -1145,7 +1165,7 @@
 	    /* Call get_lval() again, if it's inside a Dict or List it may
 	     * have changed. */
 	    redir_endp = get_lval(redir_varname, NULL, redir_lval,
-					FALSE, FALSE, FALSE, FNE_CHECK_START);
+					FALSE, FALSE, 0, FNE_CHECK_START);
 	    if (redir_endp != NULL && redir_lval->ll_name != NULL)
 		set_var_lval(redir_lval, redir_endp, &tv, FALSE, (char_u *)".");
 	    clear_lval(redir_lval);
@@ -1848,8 +1868,9 @@
 	return;
     if (argend > arg && argend[-1] == '.')  /* for var.='str' */
 	--argend;
-    expr = vim_strchr(argend, '=');
-    if (expr == NULL)
+    expr = skipwhite(argend);
+    if (*expr != '=' && !(vim_strchr((char_u *)"+-.", *expr) != NULL
+			  && expr[1] == '='))
     {
 	/*
 	 * ":let" without "=": list variables
@@ -1878,12 +1899,14 @@
     {
 	op[0] = '=';
 	op[1] = NUL;
-	if (expr > argend)
+	if (*expr != '=')
 	{
-	    if (vim_strchr((char_u *)"+-.", expr[-1]) != NULL)
-		op[0] = expr[-1];   /* +=, -= or .= */
+	    if (vim_strchr((char_u *)"+-.", *expr) != NULL)
+		op[0] = *expr;   /* +=, -= or .= */
+	    expr = skipwhite(expr + 2);
 	}
-	expr = skipwhite(expr + 1);
+	else
+	    expr = skipwhite(expr + 1);
 
 	if (eap->skip)
 	    ++emsg_skip;
@@ -2234,7 +2257,7 @@
 	    {
 		if (tofree != NULL)
 		    name = tofree;
-		if (get_var_tv(name, len, &tv, TRUE) == FAIL)
+		if (get_var_tv(name, len, &tv, TRUE, FALSE) == FAIL)
 		    error = TRUE;
 		else
 		{
@@ -2445,7 +2468,7 @@
 	    p = get_tv_string_chk(tv);
 	    if (p != NULL && op != NULL && *op == '.')
 	    {
-		s = get_reg_contents(*arg == '@' ? '"' : *arg, TRUE, TRUE);
+		s = get_reg_contents(*arg == '@' ? '"' : *arg, GREG_EXPR_SRC);
 		if (s != NULL)
 		{
 		    p = ptofree = concat_str(s, p);
@@ -2469,7 +2492,7 @@
     {
 	lval_T	lv;
 
-	p = get_lval(arg, tv, &lv, FALSE, FALSE, FALSE, FNE_CHECK_START);
+	p = get_lval(arg, tv, &lv, FALSE, FALSE, 0, FNE_CHECK_START);
 	if (p != NULL && lv.ll_name != NULL)
 	{
 	    if (endchars != NULL && vim_strchr(endchars, *skipwhite(p)) == NULL)
@@ -2514,18 +2537,22 @@
  * "unlet" is TRUE for ":unlet": slightly different behavior when something is
  * wrong; must end in space or cmd separator.
  *
+ * flags:
+ *  GLV_QUIET:       do not give error messages
+ *  GLV_NO_AUTOLOAD: do not use script autoloading
+ *
  * Returns a pointer to just after the name, including indexes.
  * When an evaluation error occurs "lp->ll_name" is NULL;
  * Returns NULL for a parsing error.  Still need to free items in "lp"!
  */
     static char_u *
-get_lval(name, rettv, lp, unlet, skip, quiet, fne_flags)
+get_lval(name, rettv, lp, unlet, skip, flags, fne_flags)
     char_u	*name;
     typval_T	*rettv;
     lval_T	*lp;
     int		unlet;
     int		skip;
-    int		quiet;	    /* don't give error messages */
+    int		flags;	    /* GLV_ values */
     int		fne_flags;  /* flags for find_name_end() */
 {
     char_u	*p;
@@ -2539,6 +2566,7 @@
     char_u	*key = NULL;
     int		len;
     hashtab_T	*ht;
+    int		quiet = flags & GLV_QUIET;
 
     /* Clear everything in "lp". */
     vim_memset(lp, 0, sizeof(lval_T));
@@ -2586,7 +2614,7 @@
 
     cc = *p;
     *p = NUL;
-    v = find_var(lp->ll_name, &ht);
+    v = find_var(lp->ll_name, &ht, flags & GLV_NO_AUTOLOAD);
     if (v == NULL && !quiet)
 	EMSG2(_(e_undefvar), lp->ll_name);
     *p = cc;
@@ -2899,7 +2927,7 @@
 
 		/* handle +=, -= and .= */
 		if (get_var_tv(lp->ll_name, (int)STRLEN(lp->ll_name),
-							     &tv, TRUE) == OK)
+						      &tv, TRUE, FALSE) == OK)
 		{
 		    if (tv_op(&tv, rettv, op) == OK)
 			set_var(lp->ll_name, &tv, FALSE);
@@ -2917,6 +2945,23 @@
 	;
     else if (lp->ll_range)
     {
+	listitem_T *ll_li = lp->ll_li;
+	int ll_n1 = lp->ll_n1;
+
+	/*
+	 * Check whether any of the list items is locked
+	 */
+	for (ri = rettv->vval.v_list->lv_first; ri != NULL; )
+	{
+	    if (tv_check_lock(ll_li->li_tv.v_lock, lp->ll_name))
+		return;
+	    ri = ri->li_next;
+	    if (ri == NULL || (!lp->ll_empty2 && lp->ll_n2 == ll_n1))
+		break;
+	    ll_li = ll_li->li_next;
+	    ++ll_n1;
+	}
+
 	/*
 	 * Assign the List values to the list items.
 	 */
@@ -3420,7 +3465,7 @@
 
     /* If it is the name of a variable of type VAR_FUNC use its contents. */
     len = (int)STRLEN(tofree);
-    name = deref_func_name(tofree, &len);
+    name = deref_func_name(tofree, &len, FALSE);
 
     /* Skip white space to allow ":call func ()".  Not good, but required for
      * backward compatibility. */
@@ -3551,7 +3596,7 @@
     do
     {
 	/* Parse the name and find the end. */
-	name_end = get_lval(arg, NULL, &lv, TRUE, eap->skip || error, FALSE,
+	name_end = get_lval(arg, NULL, &lv, TRUE, eap->skip || error, 0,
 							     FNE_CHECK_START);
 	if (lv.ll_name == NULL)
 	    error = TRUE;	    /* error but continue parsing */
@@ -3618,6 +3663,17 @@
     else if (lp->ll_range)
     {
 	listitem_T    *li;
+	listitem_T    *ll_li = lp->ll_li;
+	int           ll_n1 = lp->ll_n1;
+
+	while (ll_li != NULL && (lp->ll_empty2 || lp->ll_n2 >= ll_n1))
+	{
+	    li = ll_li->li_next;
+	    if (tv_check_lock(ll_li->li_tv.v_lock, lp->ll_name))
+		return FAIL;
+	    ll_li = li;
+	    ++ll_n1;
+	}
 
 	/* Delete a range of List items. */
 	while (lp->ll_li != NULL && (lp->ll_empty2 || lp->ll_n2 >= lp->ll_n1))
@@ -3704,7 +3760,7 @@
 	    ret = FAIL;
 	else
 	{
-	    di = find_var(lp->ll_name, NULL);
+	    di = find_var(lp->ll_name, NULL, TRUE);
 	    if (di == NULL)
 		ret = FAIL;
 	    else
@@ -4410,7 +4466,7 @@
 		    if (rettv->v_type != var2.v_type)
 			EMSG(_("E691: Can only compare List with List"));
 		    else
-			EMSG(_("E692: Invalid operation for Lists"));
+			EMSG(_("E692: Invalid operation for List"));
 		    clear_tv(rettv);
 		    clear_tv(&var2);
 		    return FAIL;
@@ -5103,7 +5159,8 @@
 		if (evaluate)
 		{
 		    rettv->v_type = VAR_STRING;
-		    rettv->vval.v_string = get_reg_contents(**arg, TRUE, TRUE);
+		    rettv->vval.v_string = get_reg_contents(**arg,
+							    GREG_EXPR_SRC);
 		}
 		if (**arg != NUL)
 		    ++*arg;
@@ -5147,7 +5204,7 @@
 	    {
 		/* If "s" is the name of a variable of type VAR_FUNC
 		 * use its contents. */
-		s = deref_func_name(s, &len);
+		s = deref_func_name(s, &len, !evaluate);
 
 		/* Invoke the function. */
 		ret = get_func_tv(s, len, rettv, arg,
@@ -5174,7 +5231,7 @@
 		}
 	    }
 	    else if (evaluate)
-		ret = get_var_tv(s, len, rettv, TRUE);
+		ret = get_var_tv(s, len, rettv, TRUE, FALSE);
 	    else
 		ret = OK;
 	}
@@ -5976,7 +6033,7 @@
     list_T  *l;
     listitem_T *item;
 {
-    list_remove(l, item, item);
+    vimlist_remove(l, item, item);
     listitem_free(item);
 }
 
@@ -6413,6 +6470,16 @@
     if (ni == NULL)
 	return FAIL;
     copy_tv(tv, &ni->li_tv);
+    list_insert(l, ni, item);
+    return OK;
+}
+
+    void
+list_insert(l, ni, item)
+    list_T	*l;
+    listitem_T	*ni;
+    listitem_T	*item;
+{
     if (item == NULL)
 	/* Append new item at end of list. */
 	list_append(l, ni);
@@ -6434,7 +6501,6 @@
 	item->li_prev = ni;
 	++l->lv_len;
     }
-    return OK;
 }
 
 /*
@@ -6546,9 +6612,11 @@
 /*
  * Remove items "item" to "item2" from list "l".
  * Does not free the listitem or the value!
+ * This used to be called list_remove, but that conflicts with a Sun header
+ * file.
  */
     void
-list_remove(l, item, item2)
+vimlist_remove(l, item, item2)
     list_T	*l;
     listitem_T	*item;
     listitem_T	*item2;
@@ -6651,6 +6719,8 @@
 	}
 
 	line_breakcheck();
+	if (did_echo_string_emsg)  /* recursion error, bail out */
+	    break;
     }
 
     /* Allocate result buffer with its total size, avoid re-allocation and
@@ -7425,8 +7495,10 @@
 	    if (s != NULL)
 		ga_concat(&ga, s);
 	    vim_free(tofree);
-	    if (s == NULL)
+	    if (s == NULL || did_echo_string_emsg)
 		break;
+	    line_breakcheck();
+
 	}
     }
     if (todo > 0)
@@ -7584,9 +7656,16 @@
 
     if (recurse >= DICT_MAXNEST)
     {
-	EMSG(_("E724: variable nested too deep for displaying"));
+	if (!did_echo_string_emsg)
+	{
+	    /* Only give this message once for a recursive call to avoid
+	     * flooding the user with errors.  And stop iterating over lists
+	     * and dicts. */
+	    did_echo_string_emsg = TRUE;
+	    EMSG(_("E724: variable nested too deep for displaying"));
+	}
 	*tofree = NULL;
-	return NULL;
+	return (char_u *)"{E724}";
     }
     ++recurse;
 
@@ -7654,7 +7733,8 @@
 	    *tofree = NULL;
     }
 
-    --recurse;
+    if (--recurse == 0)
+	did_echo_string_emsg = FALSE;
     return r;
 }
 
@@ -7767,7 +7847,7 @@
  * Get the value of an environment variable.
  * "arg" is pointing to the '$'.  It is advanced to after the name.
  * If the environment variable was not set, silently assume it is empty.
- * Always return OK.
+ * Return FAIL if the name is invalid.
  */
     static int
 get_env_tv(arg, rettv, evaluate)
@@ -7786,32 +7866,33 @@
     len = get_env_len(arg);
     if (evaluate)
     {
-	if (len != 0)
+	if (len == 0)
+           return FAIL; /* can't be an environment variable */
+
+	cc = name[len];
+	name[len] = NUL;
+	/* first try vim_getenv(), fast for normal environment vars */
+	string = vim_getenv(name, &mustfree);
+	if (string != NULL && *string != NUL)
 	{
-	    cc = name[len];
-	    name[len] = NUL;
-	    /* first try vim_getenv(), fast for normal environment vars */
-	    string = vim_getenv(name, &mustfree);
-	    if (string != NULL && *string != NUL)
-	    {
-		if (!mustfree)
-		    string = vim_strsave(string);
-	    }
-	    else
-	    {
-		if (mustfree)
-		    vim_free(string);
+	    if (!mustfree)
+		string = vim_strsave(string);
+	}
+	else
+	{
+	    if (mustfree)
+		vim_free(string);
 
-		/* next try expanding things like $VIM and ${HOME} */
-		string = expand_env_save(name - 1);
-		if (string != NULL && *string == '$')
-		{
-		    vim_free(string);
-		    string = NULL;
-		}
+	    /* next try expanding things like $VIM and ${HOME} */
+	    string = expand_env_save(name - 1);
+	    if (string != NULL && *string == '$')
+	    {
+		vim_free(string);
+		string = NULL;
 	    }
-	    name[len] = cc;
 	}
+	name[len] = cc;
+
 	rettv->v_type = VAR_STRING;
 	rettv->vval.v_string = string;
     }
@@ -7841,6 +7922,7 @@
     {"append",		2, 2, f_append},
     {"argc",		0, 0, f_argc},
     {"argidx",		0, 0, f_argidx},
+    {"arglistid",	0, 2, f_arglistid},
     {"argv",		0, 1, f_argv},
 #ifdef FEAT_FLOAT
     {"asin",		1, 1, f_asin},	/* WJMc */
@@ -7860,6 +7942,7 @@
     {"bufwinnr",	1, 1, f_bufwinnr},
     {"byte2line",	1, 1, f_byte2line},
     {"byteidx",		2, 2, f_byteidx},
+    {"byteidxcomp",	2, 2, f_byteidxcomp},
     {"call",		2, 3, f_call},
 #ifdef FEAT_FLOAT
     {"ceil",		1, 1, f_ceil},
@@ -7893,6 +7976,7 @@
     {"eval",		1, 1, f_eval},
     {"eventhandler",	0, 0, f_eventhandler},
     {"executable",	1, 1, f_executable},
+    {"exepath",		1, 1, f_exepath},
     {"exists",		1, 1, f_exists},
 #ifdef FEAT_FLOAT
     {"exp",		1, 1, f_exp},
@@ -7929,6 +8013,8 @@
     {"getcmdline",	0, 0, f_getcmdline},
     {"getcmdpos",	0, 0, f_getcmdpos},
     {"getcmdtype",	0, 0, f_getcmdtype},
+    {"getcmdwintype",	0, 0, f_getcmdwintype},
+    {"getcurpos",	0, 0, f_getcurpos},
     {"getcwd",		0, 0, f_getcwd},
     {"getfontname",	0, 1, f_getfontname},
     {"getfperm",	1, 1, f_getfperm},
@@ -7941,7 +8027,7 @@
     {"getpid",		0, 0, f_getpid},
     {"getpos",		1, 1, f_getpos},
     {"getqflist",	0, 0, f_getqflist},
-    {"getreg",		0, 2, f_getreg},
+    {"getreg",		0, 3, f_getreg},
     {"getregtype",	0, 1, f_getregtype},
     {"gettabvar",	2, 3, f_gettabvar},
     {"gettabwinvar",	3, 4, f_gettabwinvar},
@@ -7949,7 +8035,7 @@
     {"getwinposy",	0, 0, f_getwinposy},
     {"getwinvar",	2, 3, f_getwinvar},
     {"glob",		1, 3, f_glob},
-    {"globpath",	2, 3, f_globpath},
+    {"globpath",	2, 4, f_globpath},
     {"has",		1, 1, f_has},
     {"has_key",		2, 2, f_has_key},
     {"haslocaldir",	0, 0, f_haslocaldir},
@@ -7992,13 +8078,14 @@
     {"log10",		1, 1, f_log10},
 #endif
 #ifdef FEAT_LUA
-    {"luaeval",         1, 2, f_luaeval},
+    {"luaeval",		1, 2, f_luaeval},
 #endif
     {"map",		2, 2, f_map},
     {"maparg",		1, 4, f_maparg},
     {"mapcheck",	1, 3, f_mapcheck},
     {"match",		2, 4, f_match},
     {"matchadd",	2, 4, f_matchadd},
+    {"matchaddpos",	2, 4, f_matchaddpos},
     {"matcharg",	1, 1, f_matcharg},
     {"matchdelete",	1, 1, f_matchdelete},
     {"matchend",	2, 4, f_matchend},
@@ -8100,7 +8187,7 @@
     {"strridx",		2, 3, f_strridx},
     {"strtrans",	1, 1, f_strtrans},
     {"strwidth",	1, 1, f_strwidth},
-    {"submatch",	1, 1, f_submatch},
+    {"submatch",	1, 2, f_submatch},
     {"substitute",	4, 4, f_substitute},
     {"synID",		3, 3, f_synID},
     {"synIDattr",	2, 3, f_synIDattr},
@@ -8108,6 +8195,7 @@
     {"synconcealed",	2, 2, f_synconcealed},
     {"synstack",	2, 2, f_synstack},
     {"system",		1, 2, f_system},
+    {"systemlist",	1, 2, f_systemlist},
     {"tabpagebuflist",	0, 1, f_tabpagebuflist},
     {"tabpagenr",	0, 1, f_tabpagenr},
     {"tabpagewinnr",	1, 2, f_tabpagewinnr},
@@ -8128,6 +8216,7 @@
     {"type",		1, 1, f_type},
     {"undofile",	1, 1, f_undofile},
     {"undotree",	0, 0, f_undotree},
+    {"uniq",		1, 3, f_uniq},
     {"values",		1, 1, f_values},
     {"virtcol",		1, 1, f_virtcol},
     {"visualmode",	0, 1, f_visualmode},
@@ -8269,16 +8358,17 @@
  * name it contains, otherwise return "name".
  */
     static char_u *
-deref_func_name(name, lenp)
+deref_func_name(name, lenp, no_autoload)
     char_u	*name;
     int		*lenp;
+    int		no_autoload;
 {
     dictitem_T	*v;
     int		cc;
 
     cc = name[*lenp];
     name[*lenp] = NUL;
-    v = find_var(name, NULL);
+    v = find_var(name, NULL, no_autoload);
     name[*lenp] = cc;
     if (v != NULL && v->di_tv.v_type == VAR_FUNC)
     {
@@ -8449,33 +8539,39 @@
     /* execute the function if no errors detected and executing */
     if (evaluate && error == ERROR_NONE)
     {
+	char_u *rfname = fname;
+
+	/* Ignore "g:" before a function name. */
+	if (fname[0] == 'g' && fname[1] == ':')
+	    rfname = fname + 2;
+
 	rettv->v_type = VAR_NUMBER;	/* default rettv is number zero */
 	rettv->vval.v_number = 0;
 	error = ERROR_UNKNOWN;
 
-	if (!builtin_function(fname))
+	if (!builtin_function(rfname, -1))
 	{
 	    /*
 	     * User defined function.
 	     */
-	    fp = find_func(fname);
+	    fp = find_func(rfname);
 
 #ifdef FEAT_AUTOCMD
 	    /* Trigger FuncUndefined event, may load the function. */
 	    if (fp == NULL
 		    && apply_autocmds(EVENT_FUNCUNDEFINED,
-						     fname, fname, TRUE, NULL)
+						     rfname, rfname, TRUE, NULL)
 		    && !aborting())
 	    {
 		/* executed an autocommand, search for the function again */
-		fp = find_func(fname);
+		fp = find_func(rfname);
 	    }
 #endif
 	    /* Try loading a package. */
-	    if (fp == NULL && script_autoload(fname, TRUE) && !aborting())
+	    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())
 	    {
 		/* loaded a package, search for the function again */
-		fp = find_func(fname);
+		fp = find_func(rfname);
 	    }
 
 	    if (fp != NULL)
@@ -8814,6 +8910,41 @@
 }
 
 /*
+ * "arglistid()" function
+ */
+    static void
+f_arglistid(argvars, rettv)
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv;
+{
+    win_T	*wp;
+    tabpage_T	*tp = NULL;
+    long	n;
+
+    rettv->vval.v_number = -1;
+    if (argvars[0].v_type != VAR_UNKNOWN)
+    {
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	{
+	    n = get_tv_number(&argvars[1]);
+	    if (n >= 0)
+		tp = find_tabpage(n);
+	}
+	else
+	    tp = curtab;
+
+	if (tp != NULL)
+	{
+	    wp = find_win_by_nr(&argvars[0], tp);
+	    if (wp != NULL)
+		rettv->vval.v_number = wp->w_alist->id;
+	}
+    }
+    else
+	rettv->vval.v_number = curwin->w_alist->id;
+}
+
+/*
  * "argv(nr)" function
  */
     static void
@@ -9176,13 +9307,11 @@
 #endif
 }
 
-/*
- * "byteidx()" function
- */
     static void
-f_byteidx(argvars, rettv)
+byteidx(argvars, rettv, comp)
     typval_T	*argvars;
     typval_T	*rettv;
+    int		comp UNUSED;
 {
 #ifdef FEAT_MBYTE
     char_u	*t;
@@ -9202,7 +9331,10 @@
     {
 	if (*t == NUL)		/* EOL reached */
 	    return;
-	t += (*mb_ptr2len)(t);
+	if (enc_utf8 && comp)
+	    t += utf_ptr2len(t);
+	else
+	    t += (*mb_ptr2len)(t);
     }
     rettv->vval.v_number = (varnumber_T)(t - str);
 #else
@@ -9211,6 +9343,28 @@
 #endif
 }
 
+/*
+ * "byteidx()" function
+ */
+    static void
+f_byteidx(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    byteidx(argvars, rettv, FALSE);
+}
+
+/*
+ * "byteidxcomp()" function
+ */
+    static void
+f_byteidxcomp(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    byteidx(argvars, rettv, TRUE);
+}
+
     int
 func_call(name, args, selfdict, rettv)
     char_u	*name;
@@ -9731,14 +9885,17 @@
     if (argvars[1].v_type == VAR_UNKNOWN)
     {
 	pos_T	    pos;
+	colnr_T	    curswant = -1;
 
-	if (list2fpos(argvars, &pos, NULL) == FAIL)
+	if (list2fpos(argvars, &pos, NULL, &curswant) == FAIL)
 	    return;
 	line = pos.lnum;
 	col = pos.col;
 #ifdef FEAT_VIRTUALEDIT
 	coladd = pos.coladd;
 #endif
+	if (curswant >= 0)
+	    curwin->w_curswant = curswant - 1;
     }
     else
     {
@@ -9994,7 +10151,22 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    rettv->vval.v_number = mch_can_exe(get_tv_string(&argvars[0]));
+    rettv->vval.v_number = mch_can_exe(get_tv_string(&argvars[0]), NULL);
+}
+
+/*
+ * "exepath()" function
+ */
+    static void
+f_exepath(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    char_u *p = NULL;
+
+    (void)mch_can_exe(get_tv_string(&argvars[0]), &p);
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = p;
 }
 
 /*
@@ -10010,8 +10182,6 @@
     int		n = FALSE;
     int		len = 0;
 
-    no_autoload = TRUE;
-
     p = get_tv_string(&argvars[0]);
     if (*p == '$')			/* environment variable */
     {
@@ -10062,7 +10232,7 @@
 	{
 	    if (tofree != NULL)
 		name = tofree;
-	    n = (get_var_tv(name, len, &tv, FALSE) == OK);
+	    n = (get_var_tv(name, len, &tv, FALSE, TRUE) == OK);
 	    if (n)
 	    {
 		/* handle d.key, l[idx], f(expr) */
@@ -10078,8 +10248,6 @@
     }
 
     rettv->vval.v_number = n;
-
-    no_autoload = FALSE;
 }
 
 #ifdef FEAT_FLOAT
@@ -11090,6 +11258,8 @@
 {
     char_u	*p;
 
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
     if (retlist && rettv_list_alloc(rettv) == FAIL)
 	return;
 
@@ -11102,8 +11272,6 @@
 	    p = ml_get_buf(buf, start, FALSE);
 	else
 	    p = (char_u *)"";
-
-	rettv->v_type = VAR_STRING;
 	rettv->vval.v_string = vim_strsave(p);
     }
     else
@@ -11234,13 +11402,14 @@
 	    n = safe_vgetc();
 	else if (get_tv_number_chk(&argvars[0], &error) == 1)
 	    /* getchar(1): only check if char avail */
-	    n = vpeekc();
-	else if (error || vpeekc() == NUL)
+	    n = vpeekc_any();
+	else if (error || vpeekc_any() == NUL)
 	    /* illegal argument or getchar(0) and no char avail: return zero */
 	    n = 0;
 	else
 	    /* getchar(0) and char avail: return char */
 	    n = safe_vgetc();
+
 	if (n == K_IGNORE)
 	    continue;
 	break;
@@ -11364,6 +11533,26 @@
 }
 
 /*
+ * "getcmdwintype()" function
+ */
+    static void
+f_getcmdwintype(argvars, rettv)
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv;
+{
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
+#ifdef FEAT_CMDWIN
+    rettv->vval.v_string = alloc(2);
+    if (rettv->vval.v_string != NULL)
+    {
+	rettv->vval.v_string[0] = cmdwin_type;
+	rettv->vval.v_string[1] = NUL;
+    }
+#endif
+}
+
+/*
  * "getcwd()" function
  */
     static void
@@ -11630,6 +11819,7 @@
 #ifdef FEAT_SEARCH_EXTRA
     dict_T	*dict;
     matchitem_T	*cur = curwin->w_match_head;
+    int		i;
 
     if (rettv_list_alloc(rettv) == OK)
     {
@@ -11638,8 +11828,36 @@
 	    dict = dict_alloc();
 	    if (dict == NULL)
 		return;
+	    if (cur->match.regprog == NULL)
+	    {
+		/* match added with matchaddpos() */
+		for (i = 0; i < MAXPOSMATCH; ++i)
+		{
+		    llpos_T	*llpos;
+		    char	buf[6];
+		    list_T	*l;
+
+		    llpos = &cur->pos.pos[i];
+		    if (llpos->lnum == 0)
+			break;
+		    l = list_alloc();
+		    if (l == NULL)
+			break;
+		    list_append_number(l, (varnumber_T)llpos->lnum);
+		    if (llpos->col > 0)
+		    {
+			list_append_number(l, (varnumber_T)llpos->col);
+			list_append_number(l, (varnumber_T)llpos->len);
+		    }
+		    sprintf(buf, "pos%d", i + 1);
+		    dict_add_list(dict, buf, l);
+		}
+	    }
+	    else
+	    {
+		dict_add_nr_str(dict, "pattern", 0L, cur->pattern);
+	    }
 	    dict_add_nr_str(dict, "group", 0L, syn_id2name(cur->hlg_id));
-	    dict_add_nr_str(dict, "pattern", 0L, cur->pattern);
 	    dict_add_nr_str(dict, "priority", (long)cur->priority, NULL);
 	    dict_add_nr_str(dict, "id", (long)cur->id, NULL);
 	    list_append_dict(rettv->vval.v_list, dict);
@@ -11660,6 +11878,19 @@
     rettv->vval.v_number = mch_get_pid();
 }
 
+static void getpos_both __ARGS((typval_T *argvars, typval_T *rettv, int getcurpos));
+
+/*
+ * "getcurpos()" function
+ */
+    static void
+f_getcurpos(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    getpos_both(argvars, rettv, TRUE);
+}
+
 /*
  * "getpos(string)" function
  */
@@ -11668,6 +11899,15 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
+    getpos_both(argvars, rettv, FALSE);
+}
+
+    static void
+getpos_both(argvars, rettv, getcurpos)
+    typval_T	*argvars;
+    typval_T	*rettv;
+    int		getcurpos;
+{
     pos_T	*fp;
     list_T	*l;
     int		fnum = -1;
@@ -11675,7 +11915,10 @@
     if (rettv_list_alloc(rettv) == OK)
     {
 	l = rettv->vval.v_list;
-	fp = var2fpos(&argvars[0], TRUE, &fnum);
+	if (getcurpos)
+	    fp = &curwin->w_cursor;
+	else
+	    fp = var2fpos(&argvars[0], TRUE, &fnum);
 	if (fnum != -1)
 	    list_append_number(l, (varnumber_T)fnum);
 	else
@@ -11690,6 +11933,8 @@
 				(fp != NULL) ? (varnumber_T)fp->coladd :
 #endif
 							      (varnumber_T)0);
+	if (getcurpos)
+	    list_append_number(l, (varnumber_T)curwin->w_curswant + 1);
     }
     else
 	rettv->vval.v_number = FALSE;
@@ -11734,6 +11979,7 @@
     char_u	*strregname;
     int		regname;
     int		arg2 = FALSE;
+    int		return_list = FALSE;
     int		error = FALSE;
 
     if (argvars[0].v_type != VAR_UNKNOWN)
@@ -11741,17 +11987,34 @@
 	strregname = get_tv_string_chk(&argvars[0]);
 	error = strregname == NULL;
 	if (argvars[1].v_type != VAR_UNKNOWN)
+	{
 	    arg2 = get_tv_number_chk(&argvars[1], &error);
+	    if (!error && argvars[2].v_type != VAR_UNKNOWN)
+		return_list = get_tv_number_chk(&argvars[2], &error);
+	}
     }
     else
 	strregname = vimvars[VV_REG].vv_str;
+
+    if (error)
+	return;
+
     regname = (strregname == NULL ? '"' : *strregname);
     if (regname == 0)
 	regname = '"';
 
-    rettv->v_type = VAR_STRING;
-    rettv->vval.v_string = error ? NULL :
-				    get_reg_contents(regname, TRUE, arg2);
+    if (return_list)
+    {
+	rettv->v_type = VAR_LIST;
+	rettv->vval.v_list = (list_T *)get_reg_contents(regname,
+				      (arg2 ? GREG_EXPR_SRC : 0) | GREG_LIST);
+    }
+    else
+    {
+	rettv->v_type = VAR_STRING;
+	rettv->vval.v_string = get_reg_contents(regname,
+						    arg2 ? GREG_EXPR_SRC : 0);
+    }
 }
 
 /*
@@ -11791,12 +12054,10 @@
     {
 	case MLINE: buf[0] = 'V'; break;
 	case MCHAR: buf[0] = 'v'; break;
-#ifdef FEAT_VISUAL
 	case MBLOCK:
 		buf[0] = Ctrl_V;
 		sprintf((char *)buf + 1, "%ld", reglen + 1);
 		break;
-#endif
     }
     rettv->v_type = VAR_STRING;
     rettv->vval.v_string = vim_strsave(buf);
@@ -11810,7 +12071,8 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    tabpage_T	*tp;
+    win_T	*oldcurwin;
+    tabpage_T	*tp, *oldtabpage;
     dictitem_T	*v;
     char_u	*varname;
     int		done = FALSE;
@@ -11822,13 +12084,23 @@
     tp = find_tabpage((int)get_tv_number_chk(&argvars[0], NULL));
     if (tp != NULL && varname != NULL)
     {
-	/* look up the variable */
-	v = find_var_in_ht(&tp->tp_vars->dv_hashtab, 0, varname, FALSE);
-	if (v != NULL)
-	{
-	    copy_tv(&v->di_tv, rettv);
-	    done = TRUE;
+	/* Set tp to be our tabpage, temporarily.  Also set the window to the
+	 * first window in the tabpage, otherwise the window is not valid. */
+	if (switch_win(&oldcurwin, &oldtabpage, tp->tp_firstwin, tp, TRUE)
+									== OK)
+	{
+	    /* look up the variable */
+	    /* Let gettabvar({nr}, "") return the "t:" dictionary. */
+	    v = find_var_in_ht(&tp->tp_vars->dv_hashtab, 't', varname, FALSE);
+	    if (v != NULL)
+	    {
+		copy_tv(&v->di_tv, rettv);
+		done = TRUE;
+	    }
 	}
+
+	/* restore previous notion of curwin */
+	restore_win(oldcurwin, oldtabpage, TRUE);
     }
 
     if (!done && argvars[2].v_type != VAR_UNKNOWN)
@@ -11963,22 +12235,24 @@
     {
 	/* Set curwin to be our win, temporarily.  Also set the tabpage,
 	 * otherwise the window is not valid. */
-	switch_win(&oldcurwin, &oldtabpage, win, tp, TRUE);
-
-	if (*varname == '&')	/* window-local-option */
-	{
-	    if (get_option_tv(&varname, rettv, 1) == OK)
-		done = TRUE;
-	}
-	else
+	if (switch_win(&oldcurwin, &oldtabpage, win, tp, TRUE) == OK)
 	{
-	    /* Look up the variable. */
-	    /* Let getwinvar({nr}, "") return the "w:" dictionary. */
-	    v = find_var_in_ht(&win->w_vars->dv_hashtab, 'w', varname, FALSE);
-	    if (v != NULL)
+	    if (*varname == '&')	/* window-local-option */
 	    {
-		copy_tv(&v->di_tv, rettv);
-		done = TRUE;
+		if (get_option_tv(&varname, rettv, 1) == OK)
+		    done = TRUE;
+	    }
+	    else
+	    {
+		/* Look up the variable. */
+		/* Let getwinvar({nr}, "") return the "w:" dictionary. */
+		v = find_var_in_ht(&win->w_vars->dv_hashtab, 'w',
+							      varname, FALSE);
+		if (v != NULL)
+		{
+		    copy_tv(&v->di_tv, rettv);
+		    done = TRUE;
+		}
 	    }
 	}
 
@@ -12056,18 +12330,37 @@
     char_u	buf1[NUMBUFLEN];
     char_u	*file = get_tv_string_buf_chk(&argvars[1], buf1);
     int		error = FALSE;
+    garray_T	ga;
+    int		i;
 
     /* When the optional second argument is non-zero, don't remove matches
     * for 'wildignore' and don't put matches for 'suffixes' at the end. */
-    if (argvars[2].v_type != VAR_UNKNOWN
-				&& get_tv_number_chk(&argvars[2], &error))
-	flags |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
-    if (file == NULL || error)
-	rettv->vval.v_string = NULL;
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	if (get_tv_number_chk(&argvars[2], &error))
+	    flags |= WILD_KEEP_ALL;
+	if (argvars[3].v_type != VAR_UNKNOWN
+				    && get_tv_number_chk(&argvars[3], &error))
+	{
+	    rettv->v_type = VAR_LIST;
+	    rettv->vval.v_list = NULL;
+	}
+    }
+    if (file != NULL && !error)
+    {
+	ga_init2(&ga, (int)sizeof(char_u *), 10);
+	globpath(get_tv_string(&argvars[0]), file, &ga, flags);
+	if (rettv->v_type == VAR_STRING)
+	    rettv->vval.v_string = ga_concat_strings(&ga, "\n");
+	else if (rettv_list_alloc(rettv) != FAIL)
+	    for (i = 0; i < ga.ga_len; ++i)
+		list_append_string(rettv->vval.v_list,
+					    ((char_u **)(ga.ga_data))[i], -1);
+	ga_clear_strings(&ga);
+    }
     else
-	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file,
-								       flags);
+	rettv->vval.v_string = NULL;
 }
 
 /*
@@ -12135,6 +12428,9 @@
 #ifndef CASE_INSENSITIVE_FILENAME
 	"fname_case",
 #endif
+#ifdef HAVE_ACL
+	"acl",
+#endif
 #ifdef FEAT_ARABIC
 	"arabic",
 #endif
@@ -12209,6 +12505,9 @@
 #ifdef FEAT_DIGRAPHS
 	"digraphs",
 #endif
+#ifdef FEAT_DIRECTX
+	"directx",
+#endif
 #ifdef FEAT_DND
 	"dnd",
 #endif
@@ -12507,9 +12806,7 @@
 #ifdef FEAT_VIRTUALEDIT
 	"virtualedit",
 #endif
-#ifdef FEAT_VISUAL
 	"visual",
-#endif
 #ifdef FEAT_VISUALEXTRA
 	"visualextra",
 #endif
@@ -12538,7 +12835,12 @@
 	"xfontset",
 #endif
 #ifdef FEAT_XPM_W32
-	"xpm_w32",
+	"xpm",
+	"xpm_w32",	/* for backward compatibility */
+#else
+# if defined(HAVE_XPM)
+	"xpm",
+# endif
 #endif
 #ifdef USE_XSMP
 	"xsmp",
@@ -12569,7 +12871,26 @@
     if (n == FALSE)
     {
 	if (STRNICMP(name, "patch", 5) == 0)
-	    n = has_patch(atoi((char *)name + 5));
+	{
+	    if (name[5] == '-'
+		    && STRLEN(name) > 11
+		    && vim_isdigit(name[6])
+		    && vim_isdigit(name[8])
+		    && vim_isdigit(name[10]))
+	    {
+		int major = atoi((char *)name + 6);
+		int minor = atoi((char *)name + 8);
+
+		/* Expect "patch-9.9.01234". */
+		n = (major < VIM_VERSION_MAJOR
+		     || (major == VIM_VERSION_MAJOR
+			 && (minor < VIM_VERSION_MINOR
+			     || (minor == VIM_VERSION_MINOR
+				 && has_patch(atoi((char *)name + 10))))));
+	    }
+	    else
+		n = has_patch(atoi((char *)name + 5));
+	}
 	else if (STRICMP(name, "vim_starting") == 0)
 	    n = (starting != 0);
 #ifdef FEAT_MBYTE
@@ -13045,9 +13366,18 @@
 	}
 
 	if (defstr != NULL)
+	{
+# ifdef FEAT_EX_EXTRA
+	    int save_ex_normal_busy = ex_normal_busy;
+	    ex_normal_busy = 0;
+# endif
 	    rettv->vval.v_string =
 		getcmdline_prompt(inputsecret_flag ? NUL : '@', p, echo_attr,
 				  xp_type, xp_arg);
+# ifdef FEAT_EX_EXTRA
+	    ex_normal_busy = save_ex_normal_busy;
+# endif
+	}
 	if (inputdialog && rettv->vval.v_string == NULL
 		&& argvars[1].v_type != VAR_UNKNOWN
 		&& argvars[2].v_type != VAR_UNKNOWN)
@@ -13298,8 +13628,8 @@
     dictitem_T	*di;
 
     rettv->vval.v_number = -1;
-    end = get_lval(get_tv_string(&argvars[0]), NULL, &lv, FALSE, FALSE, FALSE,
-							     FNE_CHECK_START);
+    end = get_lval(get_tv_string(&argvars[0]), NULL, &lv, FALSE, FALSE,
+					GLV_NO_AUTOLOAD, FNE_CHECK_START);
     if (end != NULL && lv.ll_name != NULL)
     {
 	if (*end != NUL)
@@ -13312,7 +13642,7 @@
 		    rettv->vval.v_number = 1;	    /* always locked */
 		else
 		{
-		    di = find_var(lv.ll_name, NULL);
+		    di = find_var(lv.ll_name, NULL, TRUE);
 		    if (di != NULL)
 		    {
 			/* Consider a variable locked when:
@@ -13846,6 +14176,7 @@
     int		type;
 {
     char_u	*str = NULL;
+    long	len = 0;
     char_u	*expr = NULL;
     char_u	*pat;
     regmatch_T	regmatch;
@@ -13885,7 +14216,10 @@
 	li = l->lv_first;
     }
     else
+    {
 	expr = str = get_tv_string(&argvars[0]);
+	len = (long)STRLEN(str);
+    }
 
     pat = get_tv_string_buf_chk(&argvars[1], patbuf);
     if (pat == NULL)
@@ -13909,7 +14243,7 @@
 	{
 	    if (start < 0)
 		start = 0;
-	    if (start > (long)STRLEN(str))
+	    if (start > len)
 		goto theend;
 	    /* When "count" argument is there ignore matches before "start",
 	     * otherwise skip part of the string.  Differs when pattern is "^"
@@ -13917,7 +14251,10 @@
 	    if (argvars[3].v_type != VAR_UNKNOWN)
 		startcol = start;
 	    else
+	    {
 		str += start;
+		len -= start;
+	    }
 	}
 
 	if (argvars[3].v_type != VAR_UNKNOWN)
@@ -13967,6 +14304,12 @@
 #else
 		startcol = (colnr_T)(regmatch.startp[0] + 1 - str);
 #endif
+		if (startcol > (colnr_T)len
+				      || str + startcol <= regmatch.startp[0])
+		{
+		    match = FALSE;
+		    break;
+		}
 	    }
 	}
 
@@ -14067,19 +14410,70 @@
 	return;
     }
 
-    rettv->vval.v_number = match_add(curwin, grp, pat, prio, id);
+    rettv->vval.v_number = match_add(curwin, grp, pat, prio, id, NULL);
 #endif
 }
 
 /*
- * "matcharg()" function
+ * "matchaddpos()" function
  */
     static void
-f_matcharg(argvars, rettv)
+f_matchaddpos(argvars, rettv)
     typval_T	*argvars UNUSED;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
-    if (rettv_list_alloc(rettv) == OK)
+#ifdef FEAT_SEARCH_EXTRA
+    char_u	buf[NUMBUFLEN];
+    char_u	*group;
+    int		prio = 10;
+    int		id = -1;
+    int		error = FALSE;
+    list_T	*l;
+
+    rettv->vval.v_number = -1;
+
+    group = get_tv_string_buf_chk(&argvars[0], buf);
+    if (group == NULL)
+	return;
+
+    if (argvars[1].v_type != VAR_LIST)
+    {
+	EMSG2(_(e_listarg), "matchaddpos()");
+	return;
+    }
+    l = argvars[1].vval.v_list;
+    if (l == NULL)
+	return;
+
+    if (argvars[2].v_type != VAR_UNKNOWN)
+    {
+	prio = get_tv_number_chk(&argvars[2], &error);
+	if (argvars[3].v_type != VAR_UNKNOWN)
+	    id = get_tv_number_chk(&argvars[3], &error);
+    }
+    if (error == TRUE)
+	return;
+
+    /* id == 3 is ok because matchaddpos() is supposed to substitute :3match */
+    if (id == 1 || id == 2)
+    {
+	EMSGN("E798: ID is reserved for \":match\": %ld", id);
+	return;
+    }
+
+    rettv->vval.v_number = match_add(curwin, group, NULL, prio, id, l);
+#endif
+}
+
+/*
+ * "matcharg()" function
+ */
+    static void
+f_matcharg(argvars, rettv)
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv;
+{
+    if (rettv_list_alloc(rettv) == OK)
     {
 #ifdef FEAT_SEARCH_EXTRA
 	int	    id = get_tv_number(&argvars[0]);
@@ -14095,8 +14489,8 @@
 	    }
 	    else
 	    {
-		list_append_string(rettv->vval.v_list, NUL, -1);
-		list_append_string(rettv->vval.v_list, NUL, -1);
+		list_append_string(rettv->vval.v_list, NULL, -1);
+		list_append_string(rettv->vval.v_list, NULL, -1);
 	    }
 	}
 #endif
@@ -14292,14 +14686,23 @@
 	return;
 
     dir = get_tv_string_buf(&argvars[0], buf);
-    if (argvars[1].v_type != VAR_UNKNOWN)
+    if (*dir == NUL)
+	rettv->vval.v_number = FAIL;
+    else
     {
-	if (argvars[2].v_type != VAR_UNKNOWN)
-	    prot = get_tv_number_chk(&argvars[2], NULL);
-	if (prot != -1 && STRCMP(get_tv_string(&argvars[1]), "p") == 0)
-	    mkdir_recurse(dir, prot);
+	if (*gettail(dir) == NUL)
+	    /* remove trailing slashes */
+	    *gettail_sep(dir) = NUL;
+
+	if (argvars[1].v_type != VAR_UNKNOWN)
+	{
+	    if (argvars[2].v_type != VAR_UNKNOWN)
+		prot = get_tv_number_chk(&argvars[2], NULL);
+	    if (prot != -1 && STRCMP(get_tv_string(&argvars[1]), "p") == 0)
+		mkdir_recurse(dir, prot);
+	}
+	rettv->vval.v_number = prot == -1 ? FAIL : vim_mkdir_emsg(dir, prot);
     }
-    rettv->vval.v_number = prot != -1 ? vim_mkdir_emsg(dir, prot) : 0;
 }
 #endif
 
@@ -14316,7 +14719,6 @@
     buf[1] = NUL;
     buf[2] = NUL;
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	if (VIsual_select)
@@ -14324,9 +14726,7 @@
 	else
 	    buf[0] = VIsual_mode;
     }
-    else
-#endif
-	if (State == HITRETURN || State == ASKMORE || State == SETWSIZE
+    else if (State == HITRETURN || State == ASKMORE || State == SETWSIZE
 		|| State == CONFIRM)
     {
 	buf[0] = 'r';
@@ -15289,7 +15689,7 @@
 	    if (argvars[2].v_type == VAR_UNKNOWN)
 	    {
 		/* Remove one item, return its value. */
-		list_remove(l, item, item);
+		vimlist_remove(l, item, item);
 		*rettv = item->li_tv;
 		vim_free(item);
 	    }
@@ -15315,7 +15715,7 @@
 			EMSG(_(e_invrange));
 		    else
 		    {
-			list_remove(l, item, item2);
+			vimlist_remove(l, item, item2);
 			if (rettv_list_alloc(rettv) == OK)
 			{
 			    l = rettv->vval.v_list;
@@ -16564,7 +16964,7 @@
 	    match_add(curwin, get_dict_string(d, (char_u *)"group", FALSE),
 		    get_dict_string(d, (char_u *)"pattern", FALSE),
 		    (int)get_dict_number(d, (char_u *)"priority"),
-		    (int)get_dict_number(d, (char_u *)"id"));
+		    (int)get_dict_number(d, (char_u *)"id"), NULL);
 	    li = li->li_next;
 	}
 	rettv->vval.v_number = 0;
@@ -16583,12 +16983,13 @@
     pos_T	pos;
     int		fnum;
     char_u	*name;
+    colnr_T	curswant = -1;
 
     rettv->vval.v_number = -1;
     name = get_tv_string_chk(argvars);
     if (name != NULL)
     {
-	if (list2fpos(&argvars[1], &pos, &fnum) == OK)
+	if (list2fpos(&argvars[1], &pos, &fnum, &curswant) == OK)
 	{
 	    if (--pos.col < 0)
 		pos.col = 0;
@@ -16598,6 +16999,8 @@
 		if (fnum == curbuf->b_fnum)
 		{
 		    curwin->w_cursor = pos;
+		    if (curswant >= 0)
+			curwin->w_curswant = curswant - 1;
 		    check_cursor();
 		    rettv->vval.v_number = 0;
 		}
@@ -16655,8 +17058,6 @@
     regname = *strregname;
     if (regname == 0 || regname == '@')
 	regname = '"';
-    else if (regname == '=')
-	return;
 
     if (argvars[2].v_type != VAR_UNKNOWN)
     {
@@ -16675,7 +17076,6 @@
 		case 'V': case 'l':	/* line-wise selection */
 		    yank_type = MLINE;
 		    break;
-#ifdef FEAT_VISUAL
 		case 'b': case Ctrl_V:	/* block-wise selection */
 		    yank_type = MBLOCK;
 		    if (VIM_ISDIGIT(stropt[1]))
@@ -16685,14 +17085,62 @@
 			--stropt;
 		    }
 		    break;
-#endif
 	    }
     }
 
-    strval = get_tv_string_chk(&argvars[1]);
-    if (strval != NULL)
+    if (argvars[1].v_type == VAR_LIST)
+    {
+	char_u		**lstval;
+	char_u		**allocval;
+	char_u		buf[NUMBUFLEN];
+	char_u		**curval;
+	char_u		**curallocval;
+	int		len = argvars[1].vval.v_list->lv_len;
+	listitem_T	*li;
+
+	/* First half: use for pointers to result lines; second half: use for
+	 * pointers to allocated copies. */
+	lstval = (char_u **)alloc(sizeof(char_u *) * ((len + 1) * 2));
+	if (lstval == NULL)
+	    return;
+	curval = lstval;
+	allocval = lstval + len + 2;
+	curallocval = allocval;
+
+	for (li = argvars[1].vval.v_list->lv_first; li != NULL;
+							     li = li->li_next)
+	{
+	    strval = get_tv_string_buf_chk(&li->li_tv, buf);
+	    if (strval == NULL)
+		goto free_lstval;
+	    if (strval == buf)
+	    {
+		/* Need to make a copy, next get_tv_string_buf_chk() will
+		 * overwrite the string. */
+		strval = vim_strsave(buf);
+		if (strval == NULL)
+		    goto free_lstval;
+		*curallocval++ = strval;
+	    }
+	    *curval++ = strval;
+	}
+	*curval++ = NULL;
+
+	write_reg_contents_lst(regname, lstval, -1,
+						append, yank_type, block_len);
+free_lstval:
+	while (curallocval > allocval)
+	    vim_free(*--curallocval);
+	vim_free(lstval);
+    }
+    else
+    {
+	strval = get_tv_string_chk(&argvars[1]);
+	if (strval == NULL)
+	    return;
 	write_reg_contents_ex(regname, strval, -1,
 						append, yank_type, block_len);
+    }
     rettv->vval.v_number = 0;
 }
 
@@ -16808,34 +17256,33 @@
     if (win != NULL && varname != NULL && varp != NULL)
     {
 #ifdef FEAT_WINDOWS
-	if (switch_win(&save_curwin, &save_curtab, win, tp, TRUE) == FAIL)
-	    return;
+	if (switch_win(&save_curwin, &save_curtab, win, tp, TRUE) == OK)
 #endif
-
-	if (*varname == '&')
 	{
-	    long	numval;
-	    char_u	*strval;
-	    int		error = FALSE;
+	    if (*varname == '&')
+	    {
+		long	numval;
+		char_u	*strval;
+		int		error = FALSE;
 
-	    ++varname;
-	    numval = get_tv_number_chk(varp, &error);
-	    strval = get_tv_string_buf_chk(varp, nbuf);
-	    if (!error && strval != NULL)
-		set_option_value(varname, numval, strval, OPT_LOCAL);
-	}
-	else
-	{
-	    winvarname = alloc((unsigned)STRLEN(varname) + 3);
-	    if (winvarname != NULL)
+		++varname;
+		numval = get_tv_number_chk(varp, &error);
+		strval = get_tv_string_buf_chk(varp, nbuf);
+		if (!error && strval != NULL)
+		    set_option_value(varname, numval, strval, OPT_LOCAL);
+	    }
+	    else
 	    {
-		STRCPY(winvarname, "w:");
-		STRCPY(winvarname + 2, varname);
-		set_var(winvarname, varp, TRUE);
-		vim_free(winvarname);
+		winvarname = alloc((unsigned)STRLEN(varname) + 3);
+		if (winvarname != NULL)
+		{
+		    STRCPY(winvarname, "w:");
+		    STRCPY(winvarname + 2, varname);
+		    set_var(winvarname, varp, TRUE);
+		    vim_free(winvarname);
+		}
 	    }
 	}
-
 #ifdef FEAT_WINDOWS
 	restore_win(save_curwin, save_curtab, TRUE);
 #endif
@@ -16869,7 +17316,7 @@
     typval_T	*rettv;
 {
     rettv->vval.v_string = vim_strsave_shellescape(
-		       get_tv_string(&argvars[0]), non_zero_arg(&argvars[1]));
+		get_tv_string(&argvars[0]), non_zero_arg(&argvars[1]), TRUE);
     rettv->v_type = VAR_STRING;
 }
 
@@ -16881,7 +17328,7 @@
     typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
-    rettv->vval.v_number = get_sw_value();
+    rettv->vval.v_number = get_sw_value(curbuf);
 }
 
 /*
@@ -16947,14 +17394,24 @@
 #endif
 	item_compare2 __ARGS((const void *s1, const void *s2));
 
+/* struct used in the array that's given to qsort() */
+typedef struct
+{
+    listitem_T	*item;
+    int		idx;
+} sortItem_T;
+
 static int	item_compare_ic;
+static int	item_compare_numeric;
 static char_u	*item_compare_func;
 static dict_T	*item_compare_selfdict;
 static int	item_compare_func_err;
+static int	item_compare_keep_zero;
+static void	do_sort_uniq __ARGS((typval_T *argvars, typval_T *rettv, int sort));
 #define ITEM_COMPARE_FAIL 999
 
 /*
- * Compare functions for f_sort() below.
+ * Compare functions for f_sort() and f_uniq() below.
  */
     static int
 #ifdef __BORLANDC__
@@ -16964,22 +17421,63 @@
     const void	*s1;
     const void	*s2;
 {
+    sortItem_T  *si1, *si2;
+    typval_T	*tv1, *tv2;
     char_u	*p1, *p2;
-    char_u	*tofree1, *tofree2;
+    char_u	*tofree1 = NULL, *tofree2 = NULL;
     int		res;
     char_u	numbuf1[NUMBUFLEN];
     char_u	numbuf2[NUMBUFLEN];
 
-    p1 = tv2string(&(*(listitem_T **)s1)->li_tv, &tofree1, numbuf1, 0);
-    p2 = tv2string(&(*(listitem_T **)s2)->li_tv, &tofree2, numbuf2, 0);
+    si1 = (sortItem_T *)s1;
+    si2 = (sortItem_T *)s2;
+    tv1 = &si1->item->li_tv;
+    tv2 = &si2->item->li_tv;
+    /* tv2string() puts quotes around a string and allocates memory.  Don't do
+     * that for string variables. Use a single quote when comparing with a
+     * non-string to do what the docs promise. */
+    if (tv1->v_type == VAR_STRING)
+    {
+	if (tv2->v_type != VAR_STRING || item_compare_numeric)
+	    p1 = (char_u *)"'";
+	else
+	    p1 = tv1->vval.v_string;
+    }
+    else
+	p1 = tv2string(tv1, &tofree1, numbuf1, 0);
+    if (tv2->v_type == VAR_STRING)
+    {
+	if (tv1->v_type != VAR_STRING || item_compare_numeric)
+	    p2 = (char_u *)"'";
+	else
+	    p2 = tv2->vval.v_string;
+    }
+    else
+	p2 = tv2string(tv2, &tofree2, numbuf2, 0);
     if (p1 == NULL)
 	p1 = (char_u *)"";
     if (p2 == NULL)
 	p2 = (char_u *)"";
-    if (item_compare_ic)
-	res = STRICMP(p1, p2);
+    if (!item_compare_numeric)
+    {
+	if (item_compare_ic)
+	    res = STRICMP(p1, p2);
+	else
+	    res = STRCMP(p1, p2);
+    }
     else
-	res = STRCMP(p1, p2);
+    {
+	double n1, n2;
+	n1 = strtod((char *)p1, (char **)&p1);
+	n2 = strtod((char *)p2, (char **)&p2);
+	res = n1 == n2 ? 0 : n1 > n2 ? 1 : -1;
+    }
+
+    /* When the result would be zero, compare the item indexes.  Makes the
+     * sort stable. */
+    if (res == 0 && !item_compare_keep_zero)
+	res = si1->idx > si2->idx ? 1 : -1;
+
     vim_free(tofree1);
     vim_free(tofree2);
     return res;
@@ -16993,6 +17491,7 @@
     const void	*s1;
     const void	*s2;
 {
+    sortItem_T  *si1, *si2;
     int		res;
     typval_T	rettv;
     typval_T	argv[3];
@@ -17002,10 +17501,13 @@
     if (item_compare_func_err)
 	return 0;
 
-    /* copy the values.  This is needed to be able to set v_lock to VAR_FIXED
+    si1 = (sortItem_T *)s1;
+    si2 = (sortItem_T *)s2;
+
+    /* Copy the values.  This is needed to be able to set v_lock to VAR_FIXED
      * in the copy without changing the original list items. */
-    copy_tv(&(*(listitem_T **)s1)->li_tv, &argv[0]);
-    copy_tv(&(*(listitem_T **)s2)->li_tv, &argv[1]);
+    copy_tv(&si1->item->li_tv, &argv[0]);
+    copy_tv(&si2->item->li_tv, &argv[1]);
 
     rettv.v_type = VAR_UNKNOWN;		/* clear_tv() uses this */
     res = call_func(item_compare_func, (int)STRLEN(item_compare_func),
@@ -17021,6 +17523,12 @@
     if (item_compare_func_err)
 	res = ITEM_COMPARE_FAIL;  /* return value has wrong type */
     clear_tv(&rettv);
+
+    /* When the result would be zero, compare the pointers themselves.  Makes
+     * the sort stable. */
+    if (res == 0 && !item_compare_keep_zero)
+	res = si1->idx > si2->idx ? 1 : -1;
+
     return res;
 }
 
@@ -17028,23 +17536,24 @@
  * "sort({list})" function
  */
     static void
-f_sort(argvars, rettv)
+do_sort_uniq(argvars, rettv, sort)
     typval_T	*argvars;
     typval_T	*rettv;
+    int		sort;
 {
     list_T	*l;
     listitem_T	*li;
-    listitem_T	**ptrs;
+    sortItem_T	*ptrs;
     long	len;
     long	i;
 
     if (argvars[0].v_type != VAR_LIST)
-	EMSG2(_(e_listarg), "sort()");
+	EMSG2(_(e_listarg), sort ? "sort()" : "uniq()");
     else
     {
 	l = argvars[0].vval.v_list;
 	if (l == NULL || tv_check_lock(l->lv_lock,
-					     (char_u *)_("sort() argument")))
+	       (char_u *)(sort ? _("sort() argument") : _("uniq() argument"))))
 	    return;
 	rettv->vval.v_list = l;
 	rettv->v_type = VAR_LIST;
@@ -17055,6 +17564,7 @@
 	    return;	/* short list sorts pretty quickly */
 
 	item_compare_ic = FALSE;
+	item_compare_numeric = FALSE;
 	item_compare_func = NULL;
 	item_compare_selfdict = NULL;
 	if (argvars[1].v_type != VAR_UNKNOWN)
@@ -17073,6 +17583,19 @@
 		    item_compare_ic = TRUE;
 		else
 		    item_compare_func = get_tv_string(&argvars[1]);
+		if (item_compare_func != NULL)
+		{
+		    if (STRCMP(item_compare_func, "n") == 0)
+		    {
+			item_compare_func = NULL;
+			item_compare_numeric = TRUE;
+		    }
+		    else if (STRCMP(item_compare_func, "i") == 0)
+		    {
+			item_compare_func = NULL;
+			item_compare_ic = TRUE;
+		    }
+		}
 	    }
 
 	    if (argvars[2].v_type != VAR_UNKNOWN)
@@ -17088,32 +17611,81 @@
 	}
 
 	/* Make an array with each entry pointing to an item in the List. */
-	ptrs = (listitem_T **)alloc((int)(len * sizeof(listitem_T *)));
+	ptrs = (sortItem_T *)alloc((int)(len * sizeof(sortItem_T)));
 	if (ptrs == NULL)
 	    return;
+
 	i = 0;
-	for (li = l->lv_first; li != NULL; li = li->li_next)
-	    ptrs[i++] = li;
+	if (sort)
+	{
+	    /* sort(): ptrs will be the list to sort */
+	    for (li = l->lv_first; li != NULL; li = li->li_next)
+	    {
+		ptrs[i].item = li;
+		ptrs[i].idx = i;
+		++i;
+	    }
 
-	item_compare_func_err = FALSE;
-	/* test the compare function */
-	if (item_compare_func != NULL
-		&& item_compare2((void *)&ptrs[0], (void *)&ptrs[1])
+	    item_compare_func_err = FALSE;
+	    item_compare_keep_zero = FALSE;
+	    /* test the compare function */
+	    if (item_compare_func != NULL
+		    && item_compare2((void *)&ptrs[0], (void *)&ptrs[1])
 							 == ITEM_COMPARE_FAIL)
-	    EMSG(_("E702: Sort compare function failed"));
+		EMSG(_("E702: Sort compare function failed"));
+	    else
+	    {
+		/* Sort the array with item pointers. */
+		qsort((void *)ptrs, (size_t)len, sizeof(sortItem_T),
+		    item_compare_func == NULL ? item_compare : item_compare2);
+
+		if (!item_compare_func_err)
+		{
+		    /* Clear the List and append the items in sorted order. */
+		    l->lv_first = l->lv_last = l->lv_idx_item = NULL;
+		    l->lv_len = 0;
+		    for (i = 0; i < len; ++i)
+			list_append(l, ptrs[i].item);
+		}
+	    }
+	}
 	else
 	{
-	    /* Sort the array with item pointers. */
-	    qsort((void *)ptrs, (size_t)len, sizeof(listitem_T *),
-		    item_compare_func == NULL ? item_compare : item_compare2);
+	    int	(*item_compare_func_ptr)__ARGS((const void *, const void *));
+
+	    /* f_uniq(): ptrs will be a stack of items to remove */
+	    item_compare_func_err = FALSE;
+	    item_compare_keep_zero = TRUE;
+	    item_compare_func_ptr = item_compare_func
+					       ? item_compare2 : item_compare;
+
+	    for (li = l->lv_first; li != NULL && li->li_next != NULL;
+							     li = li->li_next)
+	    {
+		if (item_compare_func_ptr((void *)&li, (void *)&li->li_next)
+									 == 0)
+		    ptrs[i++].item = li;
+		if (item_compare_func_err)
+		{
+		    EMSG(_("E882: Uniq compare function failed"));
+		    break;
+		}
+	    }
 
 	    if (!item_compare_func_err)
 	    {
-		/* Clear the List and append the items in the sorted order. */
-		l->lv_first = l->lv_last = l->lv_idx_item = NULL;
-		l->lv_len = 0;
-		for (i = 0; i < len; ++i)
-		    list_append(l, ptrs[i]);
+		while (--i >= 0)
+		{
+		    li = ptrs[i].item->li_next;
+		    ptrs[i].item->li_next = li->li_next;
+		    if (li->li_next != NULL)
+			li->li_next->li_prev = ptrs[i].item;
+		    else
+			l->lv_last = ptrs[i].item;
+		    list_fix_watch(l, li);
+		    listitem_free(li);
+		    l->lv_len--;
+		}
 	    }
 	}
 
@@ -17122,6 +17694,28 @@
 }
 
 /*
+ * "sort({list})" function
+ */
+    static void
+f_sort(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    do_sort_uniq(argvars, rettv, TRUE);
+}
+
+/*
+ * "uniq({list})" function
+ */
+    static void
+f_uniq(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    do_sort_uniq(argvars, rettv, FALSE);
+}
+
+/*
  * "soundfold({word})" function
  */
     static void
@@ -17709,9 +18303,29 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    rettv->v_type = VAR_STRING;
-    rettv->vval.v_string =
-		    reg_submatch((int)get_tv_number_chk(&argvars[0], NULL));
+    int		error = FALSE;
+    int		no;
+    int		retList = 0;
+
+    no = (int)get_tv_number_chk(&argvars[0], &error);
+    if (error)
+	return;
+    error = FALSE;
+    if (argvars[1].v_type != VAR_UNKNOWN)
+	retList = get_tv_number_chk(&argvars[1], &error);
+    if (error)
+	return;
+
+    if (retList == 0)
+    {
+	rettv->v_type = VAR_STRING;
+	rettv->vval.v_string = reg_submatch(no);
+    }
+    else
+    {
+	rettv->v_type = VAR_LIST;
+	rettv->vval.v_list = reg_submatch_list(no);
+    }
 }
 
 /*
@@ -17979,13 +18593,11 @@
 #endif
 }
 
-/*
- * "system()" function
- */
     static void
-f_system(argvars, rettv)
+get_cmd_output_as_rettv(argvars, rettv, retlist)
     typval_T	*argvars;
     typval_T	*rettv;
+    int		retlist;
 {
     char_u	*res = NULL;
     char_u	*p;
@@ -17993,9 +18605,13 @@
     char_u	buf[NUMBUFLEN];
     int		err = FALSE;
     FILE	*fd;
+    list_T	*list = NULL;
+    int		flags = SHELL_SILENT;
 
+    rettv->v_type = VAR_STRING;
+    rettv->vval.v_string = NULL;
     if (check_restricted() || check_secure())
-	goto done;
+	goto errret;
 
     if (argvars[1].v_type != VAR_UNKNOWN)
     {
@@ -18006,74 +18622,165 @@
 	if ((infile = vim_tempname('i')) == NULL)
 	{
 	    EMSG(_(e_notmp));
-	    goto done;
+	    goto errret;
 	}
 
 	fd = mch_fopen((char *)infile, WRITEBIN);
 	if (fd == NULL)
 	{
 	    EMSG2(_(e_notopen), infile);
-	    goto done;
+	    goto errret;
 	}
-	p = get_tv_string_buf_chk(&argvars[1], buf);
-	if (p == NULL)
+	if (argvars[1].v_type == VAR_LIST)
 	{
-	    fclose(fd);
-	    goto done;		/* type error; errmsg already given */
+	    if (write_list(fd, argvars[1].vval.v_list, TRUE) == FAIL)
+		err = TRUE;
+	}
+	else
+	{
+	    size_t len;
+
+	    p = get_tv_string_buf_chk(&argvars[1], buf);
+	    if (p == NULL)
+	    {
+		fclose(fd);
+		goto errret;		/* type error; errmsg already given */
+	    }
+	    len = STRLEN(p);
+	    if (len > 0 && fwrite(p, len, 1, fd) != 1)
+		err = TRUE;
 	}
-	if (fwrite(p, STRLEN(p), 1, fd) != 1)
-	    err = TRUE;
 	if (fclose(fd) != 0)
 	    err = TRUE;
 	if (err)
 	{
 	    EMSG(_("E677: Error writing temp file"));
-	    goto done;
+	    goto errret;
 	}
     }
 
-    res = get_cmd_output(get_tv_string(&argvars[0]), infile,
-						 SHELL_SILENT | SHELL_COOKED);
+    /* Omit SHELL_COOKED when invoked with ":silent".  Avoids that the shell
+     * echoes typeahead, that messes up the display. */
+    if (!msg_silent)
+	flags += SHELL_COOKED;
 
-#ifdef USE_CR
-    /* translate <CR> into <NL> */
-    if (res != NULL)
+    if (retlist)
     {
-	char_u	*s;
+	int		len;
+	listitem_T	*li;
+	char_u		*s = NULL;
+	char_u		*start;
+	char_u		*end;
+	int		i;
+
+	res = get_cmd_output(get_tv_string(&argvars[0]), infile, flags, &len);
+	if (res == NULL)
+	    goto errret;
+
+	list = list_alloc();
+	if (list == NULL)
+	    goto errret;
 
-	for (s = res; *s; ++s)
+	for (i = 0; i < len; ++i)
 	{
-	    if (*s == CAR)
-		*s = NL;
+	    start = res + i;
+	    while (i < len && res[i] != NL)
+		++i;
+	    end = res + i;
+
+	    s = alloc((unsigned)(end - start + 1));
+	    if (s == NULL)
+		goto errret;
+
+	    for (p = s; start < end; ++p, ++start)
+		*p = *start == NUL ? NL : *start;
+	    *p = NUL;
+
+	    li = listitem_alloc();
+	    if (li == NULL)
+	    {
+		vim_free(s);
+		goto errret;
+	    }
+	    li->li_tv.v_type = VAR_STRING;
+	    li->li_tv.vval.v_string = s;
+	    list_append(list, li);
 	}
+
+	++list->lv_refcount;
+	rettv->v_type = VAR_LIST;
+	rettv->vval.v_list = list;
+	list = NULL;
     }
-#else
-# ifdef USE_CRNL
-    /* translate <CR><NL> into <NL> */
-    if (res != NULL)
+    else
     {
-	char_u	*s, *d;
+	res = get_cmd_output(get_tv_string(&argvars[0]), infile, flags, NULL);
+#ifdef USE_CR
+	/* translate <CR> into <NL> */
+	if (res != NULL)
+	{
+	    char_u	*s;
 
-	d = res;
-	for (s = res; *s; ++s)
+	    for (s = res; *s; ++s)
+	    {
+		if (*s == CAR)
+		    *s = NL;
+	    }
+	}
+#else
+# ifdef USE_CRNL
+	/* translate <CR><NL> into <NL> */
+	if (res != NULL)
 	{
-	    if (s[0] == CAR && s[1] == NL)
-		++s;
-	    *d++ = *s;
+	    char_u	*s, *d;
+
+	    d = res;
+	    for (s = res; *s; ++s)
+	    {
+		if (s[0] == CAR && s[1] == NL)
+		    ++s;
+		*d++ = *s;
+	    }
+	    *d = NUL;
 	}
-	*d = NUL;
-    }
 # endif
 #endif
+	rettv->vval.v_string = res;
+	res = NULL;
+    }
 
-done:
+errret:
     if (infile != NULL)
     {
 	mch_remove(infile);
 	vim_free(infile);
     }
-    rettv->v_type = VAR_STRING;
-    rettv->vval.v_string = res;
+    if (res != NULL)
+	vim_free(res);
+    if (list != NULL)
+	list_free(list, TRUE);
+}
+
+/*
+ * "system()" function
+ */
+    static void
+f_system(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    get_cmd_output_as_rettv(argvars, rettv, FALSE);
+}
+
+/*
+ * "systemlist()" function
+ */
+    static void
+f_systemlist(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    get_cmd_output_as_rettv(argvars, rettv, TRUE);
 }
 
 /*
@@ -18688,7 +19395,6 @@
     typval_T	*argvars UNUSED;
     typval_T	*rettv UNUSED;
 {
-#ifdef FEAT_VISUAL
     char_u	str[2];
 
     rettv->v_type = VAR_STRING;
@@ -18699,7 +19405,6 @@
     /* A non-zero number or non-empty string argument: reset mode. */
     if (non_zero_arg(&argvars[0]))
 	curbuf->b_visual_mode_eval = NUL;
-#endif
 }
 
 /*
@@ -18839,20 +19544,30 @@
 	EMSG(_(e_invarg));
     else
     {
-	curwin->w_cursor.lnum = get_dict_number(dict, (char_u *)"lnum");
-	curwin->w_cursor.col = get_dict_number(dict, (char_u *)"col");
+	if (dict_find(dict, (char_u *)"lnum", -1) != NULL)
+	    curwin->w_cursor.lnum = get_dict_number(dict, (char_u *)"lnum");
+	if (dict_find(dict, (char_u *)"col", -1) != NULL)
+	    curwin->w_cursor.col = get_dict_number(dict, (char_u *)"col");
 #ifdef FEAT_VIRTUALEDIT
-	curwin->w_cursor.coladd = get_dict_number(dict, (char_u *)"coladd");
+	if (dict_find(dict, (char_u *)"coladd", -1) != NULL)
+	    curwin->w_cursor.coladd = get_dict_number(dict, (char_u *)"coladd");
 #endif
-	curwin->w_curswant = get_dict_number(dict, (char_u *)"curswant");
-	curwin->w_set_curswant = FALSE;
+	if (dict_find(dict, (char_u *)"curswant", -1) != NULL)
+	{
+	    curwin->w_curswant = get_dict_number(dict, (char_u *)"curswant");
+	    curwin->w_set_curswant = FALSE;
+	}
 
-	set_topline(curwin, get_dict_number(dict, (char_u *)"topline"));
+	if (dict_find(dict, (char_u *)"topline", -1) != NULL)
+	    set_topline(curwin, get_dict_number(dict, (char_u *)"topline"));
 #ifdef FEAT_DIFF
-	curwin->w_topfill = get_dict_number(dict, (char_u *)"topfill");
+	if (dict_find(dict, (char_u *)"topfill", -1) != NULL)
+	    curwin->w_topfill = get_dict_number(dict, (char_u *)"topfill");
 #endif
-	curwin->w_leftcol = get_dict_number(dict, (char_u *)"leftcol");
-	curwin->w_skipcol = get_dict_number(dict, (char_u *)"skipcol");
+	if (dict_find(dict, (char_u *)"leftcol", -1) != NULL)
+	    curwin->w_leftcol = get_dict_number(dict, (char_u *)"leftcol");
+	if (dict_find(dict, (char_u *)"skipcol", -1) != NULL)
+	    curwin->w_skipcol = get_dict_number(dict, (char_u *)"skipcol");
 
 	check_cursor();
 	win_new_height(curwin, curwin->w_height);
@@ -18923,6 +19638,49 @@
 }
 
 /*
+ * Write list of strings to file
+ */
+    static int
+write_list(fd, list, binary)
+    FILE	*fd;
+    list_T	*list;
+    int		binary;
+{
+    listitem_T	*li;
+    int		c;
+    int		ret = OK;
+    char_u	*s;
+
+    for (li = list->lv_first; li != NULL; li = li->li_next)
+    {
+	for (s = get_tv_string(&li->li_tv); *s != NUL; ++s)
+	{
+	    if (*s == '\n')
+		c = putc(NUL, fd);
+	    else
+		c = putc(*s, fd);
+	    if (c == EOF)
+	    {
+		ret = FAIL;
+		break;
+	    }
+	}
+	if (!binary || li->li_next != NULL)
+	    if (putc('\n', fd) == EOF)
+	    {
+		ret = FAIL;
+		break;
+	    }
+	if (ret == FAIL)
+	{
+	    EMSG(_(e_write));
+	    break;
+	}
+    }
+    return ret;
+}
+
+/*
  * "writefile()" function
  */
     static void
@@ -18933,10 +19691,7 @@
     int		binary = FALSE;
     char_u	*fname;
     FILE	*fd;
-    listitem_T	*li;
-    char_u	*s;
     int		ret = 0;
-    int		c;
 
     if (check_restricted() || check_secure())
 	return;
@@ -18963,33 +19718,8 @@
     }
     else
     {
-	for (li = argvars[0].vval.v_list->lv_first; li != NULL;
-							     li = li->li_next)
-	{
-	    for (s = get_tv_string(&li->li_tv); *s != NUL; ++s)
-	    {
-		if (*s == '\n')
-		    c = putc(NUL, fd);
-		else
-		    c = putc(*s, fd);
-		if (c == EOF)
-		{
-		    ret = -1;
-		    break;
-		}
-	    }
-	    if (!binary || li->li_next != NULL)
-		if (putc('\n', fd) == EOF)
-		{
-		    ret = -1;
-		    break;
-		}
-	    if (ret < 0)
-	    {
-		EMSG(_(e_write));
-		break;
-	    }
-	}
+	if (write_list(fd, argvars[0].vval.v_list, binary) == FAIL)
+	    ret = -1;
 	fclose(fd);
     }
 
@@ -19073,14 +19803,12 @@
 	return NULL;
     if (name[0] == '.')				/* cursor */
 	return &curwin->w_cursor;
-#ifdef FEAT_VISUAL
     if (name[0] == 'v' && name[1] == NUL)	/* Visual start */
     {
 	if (VIsual_active)
 	    return &VIsual;
 	return &curwin->w_cursor;
     }
-#endif
     if (name[0] == '\'')			/* mark */
     {
 	pp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);
@@ -19135,21 +19863,22 @@
  * validity.
  */
     static int
-list2fpos(arg, posp, fnump)
+list2fpos(arg, posp, fnump, curswantp)
     typval_T	*arg;
     pos_T	*posp;
     int		*fnump;
+    colnr_T	*curswantp;
 {
     list_T	*l = arg->vval.v_list;
     long	i = 0;
     long	n;
 
-    /* List must be: [fnum, lnum, col, coladd], where "fnum" is only there
-     * when "fnump" isn't NULL and "coladd" is optional. */
+    /* List must be: [fnum, lnum, col, coladd, curswant], where "fnum" is only
+     * there when "fnump" isn't NULL; "coladd" and "curswant" are optional. */
     if (arg->v_type != VAR_LIST
 	    || l == NULL
 	    || l->lv_len < (fnump == NULL ? 2 : 3)
-	    || l->lv_len > (fnump == NULL ? 3 : 4))
+	    || l->lv_len > (fnump == NULL ? 4 : 5))
 	return FAIL;
 
     if (fnump != NULL)
@@ -19173,13 +19902,16 @@
     posp->col = n;
 
 #ifdef FEAT_VIRTUALEDIT
-    n = list_find_nr(l, i, NULL);
+    n = list_find_nr(l, i, NULL);	/* off */
     if (n < 0)
 	posp->coladd = 0;
     else
 	posp->coladd = n;
 #endif
 
+    if (curswantp != NULL)
+	*curswantp = list_find_nr(l, i + 1, NULL);  /* curswant */
+
     return OK;
 }
 
@@ -19719,11 +20451,12 @@
  * Return OK or FAIL.
  */
     static int
-get_var_tv(name, len, rettv, verbose)
+get_var_tv(name, len, rettv, verbose, no_autoload)
     char_u	*name;
     int		len;		/* length of "name" */
     typval_T	*rettv;		/* NULL when only checking existence */
     int		verbose;	/* may give error message */
+    int		no_autoload;	/* do not use script autoloading */
 {
     int		ret = OK;
     typval_T	*tv = NULL;
@@ -19750,7 +20483,7 @@
      */
     else
     {
-	v = find_var(name, NULL);
+	v = find_var(name, NULL, no_autoload);
 	if (v != NULL)
 	    tv = &v->di_tv;
     }
@@ -19790,24 +20523,30 @@
     while (ret == OK
 	    && (**arg == '['
 		|| (**arg == '.' && rettv->v_type == VAR_DICT)
-		|| (**arg == '(' && rettv->v_type == VAR_FUNC))
+		|| (**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC)))
 	    && !vim_iswhite(*(*arg - 1)))
     {
 	if (**arg == '(')
 	{
 	    /* need to copy the funcref so that we can clear rettv */
-	    functv = *rettv;
-	    rettv->v_type = VAR_UNKNOWN;
+	    if (evaluate)
+	    {
+		functv = *rettv;
+		rettv->v_type = VAR_UNKNOWN;
 
-	    /* Invoke the function.  Recursive! */
-	    s = functv.vval.v_string;
+		/* Invoke the function.  Recursive! */
+		s = functv.vval.v_string;
+	    }
+	    else
+		s = (char_u *)"";
 	    ret = get_func_tv(s, (int)STRLEN(s), rettv, arg,
 			curwin->w_cursor.lnum, curwin->w_cursor.lnum,
 			&len, evaluate, selfdict);
 
 	    /* Clear the funcref afterwards, so that deleting it while
 	     * evaluating the arguments is possible (see test55). */
-	    clear_tv(&functv);
+	    if (evaluate)
+		clear_tv(&functv);
 
 	    /* Stop the expression evaluation when immediately aborting on
 	     * error, or when an interrupt occurred or an exception was thrown
@@ -20094,6 +20833,9 @@
     return res != NULL ? res : (char_u *)"";
 }
 
+/*
+ * Careful: This uses a single, static buffer.  YOU CAN ONLY USE IT ONCE!
+ */
     char_u *
 get_tv_string_chk(varp)
     typval_T	*varp;
@@ -20146,9 +20888,10 @@
  * hashtab_T used.
  */
     static dictitem_T *
-find_var(name, htp)
+find_var(name, htp, no_autoload)
     char_u	*name;
     hashtab_T	**htp;
+    int		no_autoload;
 {
     char_u	*varname;
     hashtab_T	*ht;
@@ -20158,7 +20901,7 @@
 	*htp = ht;
     if (ht == NULL)
 	return NULL;
-    return find_var_in_ht(ht, *name, varname, htp != NULL);
+    return find_var_in_ht(ht, *name, varname, no_autoload || htp != NULL);
 }
 
 /*
@@ -20166,11 +20909,11 @@
  * Returns NULL if not found.
  */
     static dictitem_T *
-find_var_in_ht(ht, htname, varname, writing)
+find_var_in_ht(ht, htname, varname, no_autoload)
     hashtab_T	*ht;
     int		htname;
     char_u	*varname;
-    int		writing;
+    int		no_autoload;
 {
     hashitem_T	*hi;
 
@@ -20202,7 +20945,7 @@
 	 * worked find the variable again.  Don't auto-load a script if it was
 	 * loaded already, otherwise it would be loaded every time when
 	 * checking if a function name is a Funcref variable. */
-	if (ht == &globvarht && !writing)
+	if (ht == &globvarht && !no_autoload)
 	{
 	    /* Note: script_autoload() may make "hi" invalid. It must either
 	     * be obtained again or not used. */
@@ -20282,7 +21025,7 @@
 {
     dictitem_T	*v;
 
-    v = find_var(name, NULL);
+    v = find_var(name, NULL, FALSE);
     if (v == NULL)
 	return NULL;
     return get_tv_string(&v->di_tv);
@@ -20560,6 +21303,13 @@
 		v->di_tv.vval.v_number = get_tv_number(tv);
 		if (STRCMP(varname, "searchforward") == 0)
 		    set_search_direction(v->di_tv.vval.v_number ? '/' : '?');
+#ifdef FEAT_SEARCH_EXTRA
+		else if (STRCMP(varname, "hlsearch") == 0)
+		{
+		    no_hlsearch = !v->di_tv.vval.v_number;
+		    redraw_all_later(SOME_VALID);
+		}
+#endif
 	    }
 	    return;
 	}
@@ -20650,7 +21400,8 @@
     char_u *name;    /* points to start of variable name */
     int    new_var;  /* TRUE when creating the variable */
 {
-    if (!(vim_strchr((char_u *)"wbs", name[0]) != NULL && name[1] == ':')
+    /* Allow for w: b: s: and t:. */
+    if (!(vim_strchr((char_u *)"wbst", name[0]) != NULL && name[1] == ':')
 	    && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':')
 						     ? name[2] : name[0]))
     {
@@ -21206,6 +21957,8 @@
      * dict.func    existing dict entry that's not a Funcref
      *		    "name" == NULL, "fudi.fd_dict" set,
      *		    "fudi.fd_di" set, "fudi.fd_newkey" == NULL
+     * s:func	    script-local function name
+     * g:func	    global function name, same as "func"
      */
     p = eap->arg;
     name = trans_function_name(&p, eap->skip, 0, &fudi);
@@ -21361,6 +22114,7 @@
 		if (STRCMP(((char_u **)(newargs.ga_data))[i], arg) == 0)
 		{
 		    EMSG2(_("E853: Duplicate argument name: %s"), arg);
+		    vim_free(arg);
 		    goto erret;
 		}
 
@@ -21604,7 +22358,7 @@
      */
     if (fudi.fd_dict == NULL)
     {
-	v = find_var(name, &ht);
+	v = find_var(name, &ht, FALSE);
 	if (v != NULL && v->di_tv.v_type == VAR_FUNC)
 	{
 	    emsg_funcname(N_("E707: Function name conflicts with variable: %s"),
@@ -21762,8 +22516,9 @@
  * Also handles a Funcref in a List or Dictionary.
  * Returns the function name in allocated memory, or NULL for failure.
  * flags:
- * TFN_INT:   internal function name OK
- * TFN_QUIET: be quiet
+ * TFN_INT:         internal function name OK
+ * TFN_QUIET:       be quiet
+ * TFN_NO_AUTOLOAD: do not use script autoloading
  * Advances "pp" to just after the function name (if no error).
  */
     static char_u *
@@ -21801,7 +22556,8 @@
     if (lead > 2)
 	start += lead;
 
-    end = get_lval(start, NULL, &lv, FALSE, skip, flags & TFN_QUIET,
+    /* Note that TFN_ flags use the same values as GLV_ flags. */
+    end = get_lval(start, NULL, &lv, FALSE, skip, flags,
 					      lead > 2 ? 0 : FNE_CHECK_START);
     if (end == start)
     {
@@ -21863,14 +22619,14 @@
     if (lv.ll_exp_name != NULL)
     {
 	len = (int)STRLEN(lv.ll_exp_name);
-	name = deref_func_name(lv.ll_exp_name, &len);
+	name = deref_func_name(lv.ll_exp_name, &len, flags & TFN_NO_AUTOLOAD);
 	if (name == lv.ll_exp_name)
 	    name = NULL;
     }
     else
     {
 	len = (int)(end - *pp);
-	name = deref_func_name(*pp, &len);
+	name = deref_func_name(*pp, &len, flags & TFN_NO_AUTOLOAD);
 	if (name == *pp)
 	    name = NULL;
     }
@@ -21878,6 +22634,14 @@
     {
 	name = vim_strsave(name);
 	*pp = end;
+	if (STRNCMP(name, "<SNR>", 5) == 0)
+	{
+	    /* Change "<SNR>" to the byte sequence. */
+	    name[0] = K_SPECIAL;
+	    name[1] = KS_EXTRA;
+	    name[2] = (int)KE_SNR;
+	    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);
+	}
 	goto theend;
     }
 
@@ -21896,7 +22660,8 @@
     }
     else
     {
-	if (lead == 2)	/* skip over "s:" */
+	/* skip over "s:" and "g:" */
+	if (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))
 	    lv.ll_name += 2;
 	len = (int)(end - lv.ll_name);
     }
@@ -21924,11 +22689,23 @@
 	    lead += (int)STRLEN(sid_buf);
 	}
     }
-    else if (!(flags & TFN_INT) && builtin_function(lv.ll_name))
+    else if (!(flags & TFN_INT) && builtin_function(lv.ll_name, len))
     {
-	EMSG2(_("E128: Function name must start with a capital or contain a colon: %s"), lv.ll_name);
+	EMSG2(_("E128: Function name must start with a capital or \"s:\": %s"),
+								       start);
 	goto theend;
     }
+    if (!skip && !(flags & TFN_QUIET))
+    {
+	char_u *cp = vim_strchr(lv.ll_name, ':');
+
+	if (cp != NULL && cp < end)
+	{
+	    EMSG2(_("E884: Function name cannot contain a colon: %s"), start);
+	    goto theend;
+	}
+    }
+
     name = alloc((unsigned)(len + lead + 1));
     if (name != NULL)
     {
@@ -21941,7 +22718,7 @@
 		STRCPY(name + 3, sid_buf);
 	}
 	mch_memmove(name + lead, lv.ll_name, (size_t)len);
-	name[len + lead] = NUL;
+	name[lead + len] = NUL;
     }
     *pp = end;
 
@@ -22062,7 +22839,7 @@
 translated_function_exists(name)
     char_u	*name;
 {
-    if (builtin_function(name))
+    if (builtin_function(name, -1))
 	return find_internal_func(name) >= 0;
     return find_func(name) != NULL;
 }
@@ -22078,7 +22855,8 @@
     char_u  *p;
     int	    n = FALSE;
 
-    p = trans_function_name(&nm, FALSE, TFN_INT|TFN_QUIET, NULL);
+    p = trans_function_name(&nm, FALSE, TFN_INT|TFN_QUIET|TFN_NO_AUTOLOAD,
+			    NULL);
     nm = skipwhite(nm);
 
     /* Only accept "funcname", "funcname ", "funcname (..." and
@@ -22109,14 +22887,20 @@
 
 /*
  * Return TRUE if "name" looks like a builtin function name: starts with a
- * lower case letter and doesn't contain a ':' or AUTOLOAD_CHAR.
+ * lower case letter and doesn't contain AUTOLOAD_CHAR.
+ * "len" is the length of "name", or -1 for NUL terminated.
  */
     static int
-builtin_function(name)
+builtin_function(name, len)
     char_u *name;
+    int len;
 {
-    return ASCII_ISLOWER(name[0]) && vim_strchr(name, ':') == NULL
-				   && vim_strchr(name, AUTOLOAD_CHAR) == NULL;
+    char_u *p;
+
+    if (!ASCII_ISLOWER(name[0]))
+	return FALSE;
+    p = vim_strchr(name, AUTOLOAD_CHAR);
+    return p == NULL || (len > 0 && p > name + len);
 }
 
 #if defined(FEAT_PROFILE) || defined(PROTO)
@@ -22325,10 +23109,6 @@
     int		ret = FALSE;
     int		i;
 
-    /* Return quickly when autoload disabled. */
-    if (no_autoload)
-	return FALSE;
-
     /* If there is no '#' after name[0] there is no package name. */
     p = vim_strchr(name, AUTOLOAD_CHAR);
     if (p == NULL || p == name)
@@ -22772,7 +23552,10 @@
 			msg_outnum((long)argvars[i].vval.v_number);
 		    else
 		    {
+			/* Do not want errors such as E724 here. */
+			++emsg_off;
 			s = tv2string(&argvars[i], &tofree, numbuf2, 0);
+			--emsg_off;
 			if (s != NULL)
 			{
 			    if (vim_strsize(s) > MSG_BUF_CLEN)
@@ -22864,8 +23647,10 @@
 
 	    /* The value may be very long.  Skip the middle part, so that we
 	     * have some idea how it starts and ends. smsg() would always
-	     * truncate it at the end. */
+	     * truncate it at the end. Don't want errors such as E724 here. */
+	    ++emsg_off;
 	    s = tv2string(fc->rettv, &tofree, numbuf2, 0);
+	    --emsg_off;
 	    if (s != NULL)
 	    {
 		if (vim_strsize(s) > MSG_BUF_CLEN)
@@ -24260,6 +25045,17 @@
 	}
     }
 
+    if (src[*usedlen] == ':' && src[*usedlen + 1] == 'S')
+    {
+	p = vim_strsave_shellescape(*fnamep, FALSE, FALSE);
+	if (p == NULL)
+	    return -1;
+	vim_free(*bufp);
+	*bufp = *fnamep = p;
+	*fnamelen = (int)STRLEN(p);
+	*usedlen += 2;
+    }
+
     return valid;
 }
 
@@ -24283,6 +25079,7 @@
     garray_T	ga;
     char_u	*ret;
     char_u	*save_cpo;
+    char_u	*zero_width = NULL;
 
     /* Make 'cpoptions' empty, so that the 'l' flag doesn't work here */
     save_cpo = p_cpo;
@@ -24299,6 +25096,22 @@
 	tail = str;
 	while (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))
 	{
+	    /* Skip empty match except for first match. */
+	    if (regmatch.startp[0] == regmatch.endp[0])
+	    {
+		if (zero_width == regmatch.startp[0])
+		{
+		    /* avoid getting stuck on a match with an empty string */
+		    i = MB_PTR2LEN(tail);
+		    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail,
+								   (size_t)i);
+		    ga.ga_len += i;
+		    tail += i;
+		    continue;
+		}
+		zero_width = regmatch.startp[0];
+	    }
+
 	    /*
 	     * Get some space for a temporary buffer to do the substitution
 	     * into.  It will contain:
@@ -24321,20 +25134,9 @@
 	    (void)vim_regsub(&regmatch, sub, (char_u *)ga.ga_data
 					  + ga.ga_len + i, TRUE, TRUE, FALSE);
 	    ga.ga_len += i + sublen - 1;
-	    /* avoid getting stuck on a match with an empty string */
-	    if (tail == regmatch.endp[0])
-	    {
-		if (*tail == NUL)
-		    break;
-		*((char_u *)ga.ga_data + ga.ga_len) = *tail++;
-		++ga.ga_len;
-	    }
-	    else
-	    {
-		tail = regmatch.endp[0];
-		if (*tail == NUL)
-		    break;
-	    }
+	    tail = regmatch.endp[0];
+	    if (*tail == NUL)
+		break;
 	    if (!do_all)
 		break;
 	}
diff -Naur vim74.orig/src/ex_cmds.c vim74/src/ex_cmds.c
--- vim74.orig/src/ex_cmds.c	2013-08-07 13:15:51.000000000 +0000
+++ vim74/src/ex_cmds.c	2014-10-10 14:53:44.332047247 +0000
@@ -1012,7 +1012,18 @@
 
     if (bangredo)	    /* put cmd in redo buffer for ! command */
     {
-	AppendToRedobuffLit(prevcmd, -1);
+	/* If % or # appears in the command, it must have been escaped.
+	 * Reescape them, so that redoing them does not substitute them by the
+	 * buffername. */
+	char_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)"%#");
+
+	if (cmd != NULL)
+	{
+	    AppendToRedobuffLit(cmd, -1);
+	    vim_free(cmd);
+	}
+	else
+	    AppendToRedobuffLit(prevcmd, -1);
 	AppendToRedobuff((char_u *)"\n");
 	bangredo = FALSE;
     }
@@ -1541,7 +1552,18 @@
     char_u	*buf;
     long_u	len;
 
-    len = (long_u)STRLEN(cmd) + 3;			/* "()" + NUL */
+#if (defined(UNIX) && !defined(ARCHIE)) || defined(OS2)
+    int		is_fish_shell;
+    char_u	*shell_name = get_isolated_shell_name();
+
+    /* Account for fish's different syntax for subshells */
+    is_fish_shell = (fnamecmp(shell_name, "fish") == 0);
+    vim_free(shell_name);
+    if (is_fish_shell)
+	len = (long_u)STRLEN(cmd) + 13;		/* "begin; " + "; end" + NUL */
+    else
+#endif
+	len = (long_u)STRLEN(cmd) + 3;			/* "()" + NUL */
     if (itmp != NULL)
 	len += (long_u)STRLEN(itmp) + 9;		/* " { < " + " } " */
     if (otmp != NULL)
@@ -1556,7 +1578,12 @@
      * redirecting input and/or output.
      */
     if (itmp != NULL || otmp != NULL)
-	vim_snprintf((char *)buf, len, "(%s)", (char *)cmd);
+    {
+	if (is_fish_shell)
+	    vim_snprintf((char *)buf, len, "begin; %s; end", (char *)cmd);
+	else
+	    vim_snprintf((char *)buf, len, "(%s)", (char *)cmd);
+    }
     else
 	STRCPY(buf, cmd);
     if (itmp != NULL)
@@ -1566,7 +1593,7 @@
     }
 #else
     /*
-     * for shells that don't understand braces around commands, at least allow
+     * For shells that don't understand braces around commands, at least allow
      * the use of commands in a pipe.
      */
     STRCPY(buf, cmd);
@@ -1977,11 +2004,14 @@
     {
 	fclose(fp_in);
 
-	/*
-	 * In case of an error keep the original viminfo file.
-	 * Otherwise rename the newly written file.
-	 */
-	if (viminfo_errcnt || vim_rename(tempname, fname) == -1)
+	/* In case of an error keep the original viminfo file.  Otherwise
+	 * rename the newly written file.  Give an error if that fails. */
+	if (viminfo_errcnt == 0 && vim_rename(tempname, fname) == -1)
+	{
+	    ++viminfo_errcnt;
+	    EMSG2(_("E886: Can't rename viminfo file to %s!"), fname);
+	}
+	if (viminfo_errcnt > 0)
 	    mch_remove(tempname);
 
 #ifdef WIN3264
@@ -3253,21 +3283,21 @@
     if (  ((!other_file && !(flags & ECMD_OLDBUF))
 	    || (curbuf->b_nwindows == 1
 		&& !(flags & (ECMD_HIDE | ECMD_ADDBUF))))
-	&& check_changed(curbuf, p_awa, !other_file,
-					(flags & ECMD_FORCEIT), FALSE))
+	&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)
+			       | (other_file ? 0 : CCGD_MULTWIN)
+			       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)
+			       | (eap == NULL ? 0 : CCGD_EXCMD)))
     {
 	if (fnum == 0 && other_file && ffname != NULL)
 	    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);
 	goto theend;
     }
 
-#ifdef FEAT_VISUAL
     /*
      * End Visual mode before switching to another buffer, so the text can be
      * copied into the GUI selection buffer.
      */
     reset_VIsual();
-#endif
 
 #ifdef FEAT_AUTOCMD
     if ((command != NULL || newlnum > (linenr_T)0)
@@ -3332,6 +3362,12 @@
 #endif
 	    buf = buflist_new(ffname, sfname, 0L,
 		    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));
+#ifdef FEAT_AUTOCMD
+	    /* autocommands may change curwin and curbuf */
+	    if (oldwin != NULL)
+		oldwin = curwin;
+	    old_curbuf = curbuf;
+#endif
 	}
 	if (buf == NULL)
 	    goto theend;
@@ -3975,11 +4011,19 @@
 	    eap->nextcmd = p;
 	}
 	else
+	{
+	    int save_State = State;
+
+	    /* Set State to avoid the cursor shape to be set to INSERT mode
+	     * when getline() returns. */
+	    State = CMDLINE;
 	    theline = eap->getline(
 #ifdef FEAT_EVAL
 		    eap->cstack->cs_looplevel > 0 ? -1 :
 #endif
 		    NUL, eap->cookie, indent);
+	    State = save_State;
+	}
 	lines_left = Rows - 1;
 	if (theline == NULL)
 	    break;
@@ -4097,12 +4141,12 @@
      * 'scroll' */
     if (eap->forceit)
 	bigness = curwin->w_height;
-    else if (firstwin == lastwin)
-	bigness = curwin->w_p_scr * 2;
 #ifdef FEAT_WINDOWS
-    else
+    else if (firstwin != lastwin)
 	bigness = curwin->w_height - 3;
 #endif
+    else
+	bigness = curwin->w_p_scr * 2;
     if (bigness < 1)
 	bigness = 1;
 
@@ -4298,7 +4342,7 @@
     pos_T	old_cursor = curwin->w_cursor;
     int		start_nsubs;
 #ifdef FEAT_EVAL
-    int         save_ma = 0;
+    int		save_ma = 0;
 #endif
 
     cmd = eap->arg;
@@ -4409,6 +4453,31 @@
 	endcolumn = (curwin->w_curswant == MAXCOL);
     }
 
+    /* Recognize ":%s/\n//" and turn it into a join command, which is much
+     * more efficient.
+     * TODO: find a generic solution to make line-joining operations more
+     * efficient, avoid allocating a string that grows in size.
+     */
+    if (pat != NULL && STRCMP(pat, "\\n") == 0
+	    && *sub == NUL
+	    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'
+					     || *cmd == 'p' || *cmd == '#'))))
+    {
+	curwin->w_cursor.lnum = eap->line1;
+	if (*cmd == 'l')
+	    eap->flags = EXFLAG_LIST;
+	else if (*cmd == '#')
+	    eap->flags = EXFLAG_NR;
+	else if (*cmd == 'p')
+	    eap->flags = EXFLAG_PRINT;
+
+	(void)do_join(eap->line2 - eap->line1 + 1, FALSE, TRUE, FALSE, TRUE);
+	sub_nlines = sub_nsubs = eap->line2 - eap->line1 + 1;
+	(void)do_sub_msg(FALSE);
+	ex_may_print(eap);
+	return;
+    }
+
     /*
      * Find trailing options.  When '&' is used, keep old options.
      */
@@ -4740,11 +4809,17 @@
 			    char_u	*resp;
 			    colnr_T	sc, ec;
 
-			    print_line_no_prefix(lnum, FALSE, FALSE);
+			    print_line_no_prefix(lnum, do_number, do_list);
 
 			    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);
 			    curwin->w_cursor.col = regmatch.endpos[0].col - 1;
 			    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);
+			    if (do_number || curwin->w_p_nu)
+			    {
+				int numw = number_width(curwin) + 1;
+				sc += numw;
+				ec += numw;
+			    }
 			    msg_start();
 			    for (i = 0; i < (long)sc; ++i)
 				msg_putchar(' ');
@@ -5447,7 +5522,15 @@
 	    smsg((char_u *)_("Pattern not found: %s"), pat);
     }
     else
+    {
+#ifdef FEAT_CLIPBOARD
+	start_global_changes();
+#endif
 	global_exe(cmd);
+#ifdef FEAT_CLIPBOARD
+	end_global_changes();
+#endif
+    }
 
     ml_clearmarked();	   /* clear rest of the marks */
     vim_regfree(regmatch.regprog);
@@ -5816,6 +5899,26 @@
     vim_free(tag);
 }
 
+/*
+ * ":helpclose": Close one help window
+ */
+    void
+ex_helpclose(eap)
+    exarg_T	*eap UNUSED;
+{
+#if defined(FEAT_WINDOWS)
+    win_T *win;
+
+    FOR_ALL_WINDOWS(win)
+    {
+	if (win->w_buffer->b_help)
+	{
+	    win_close(win, FALSE);
+	    return;
+	}
+    }
+#endif
+}
 
 #if defined(FEAT_MULTI_LANG) || defined(PROTO)
 /*
@@ -5928,14 +6031,18 @@
 			       "?", ":?", "?<CR>", "g?", "g?g?", "g??", "z?",
 			       "/\\?", "/\\z(\\)", "\\=", ":s\\=",
 			       "[count]", "[quotex]", "[range]",
-			       "[pattern]", "\\|", "\\%$"};
+			       "[pattern]", "\\|", "\\%$",
+			       "s/\\~", "s/\\U", "s/\\L",
+			       "s/\\1", "s/\\2", "s/\\3", "s/\\9"};
     static char *(rtable[]) = {"star", "gstar", "[star", "]star", ":star",
 			       "/star", "/\\\\star", "quotestar", "starstar",
 			       "cpo-star", "/\\\\(\\\\)", "/\\\\%(\\\\)",
 			       "?", ":?", "?<CR>", "g?", "g?g?", "g??", "z?",
 			       "/\\\\?", "/\\\\z(\\\\)", "\\\\=", ":s\\\\=",
 			       "\\[count]", "\\[quotex]", "\\[range]",
-			       "\\[pattern]", "\\\\bar", "/\\\\%\\$"};
+			       "\\[pattern]", "\\\\bar", "/\\\\%\\$",
+			       "s/\\\\\\~", "s/\\\\U", "s/\\\\L",
+			       "s/\\\\1", "s/\\\\2", "s/\\\\3", "s/\\\\9"};
     int flags;
 
     d = IObuff;		    /* assume IObuff is long enough! */
@@ -5974,7 +6081,7 @@
 	  /* Replace:
 	   * "[:...:]" with "\[:...:]"
 	   * "[++...]" with "\[++...]"
-	   * "\{" with "\\{"
+	   * "\{" with "\\{"		   -- matching "} \}"
 	   */
 	    if ((arg[0] == '[' && (arg[1] == ':'
 			 || (arg[1] == '+' && arg[2] == '+')))
@@ -7223,7 +7330,10 @@
 	    else
 		/* ":sign place {id} file={fname}": change sign type */
 		lnum = buf_change_sign_type(buf, id, sp->sn_typenr);
-	    update_debug_sign(buf, lnum);
+	    if (lnum > 0)
+		update_debug_sign(buf, lnum);
+	    else
+		EMSG2(_("E885: Not possible to change sign %s"), sign_name);
 	}
 	else
 	    EMSG(_(e_invarg));
@@ -7658,7 +7768,7 @@
 # ifdef FEAT_WINDOWS
 	    ++emsg_off;
 # endif
-	    split = check_changed(curbuf, TRUE, FALSE, FALSE, FALSE);
+	    split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);
 # ifdef FEAT_WINDOWS
 	    --emsg_off;
 # else
diff -Naur vim74.orig/src/ex_cmds.h vim74/src/ex_cmds.h
--- vim74.orig/src/ex_cmds.h	2013-06-08 13:08:20.000000000 +0000
+++ vim74/src/ex_cmds.h	2014-10-10 14:53:44.335380572 +0000
@@ -132,9 +132,9 @@
 EX(CMD_aunmenu,		"aunmenu",	ex_menu,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_buffer,		"buffer",	ex_buffer,
-			BANG|RANGE|NOTADR|BUFNAME|BUFUNL|COUNT|EXTRA|TRLBAR),
+			BANG|RANGE|NOTADR|BUFNAME|BUFUNL|COUNT|EXTRA|EDITCMD|TRLBAR),
 EX(CMD_bNext,		"bNext",	ex_bprevious,
-			BANG|RANGE|NOTADR|COUNT|TRLBAR),
+			BANG|RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_ball,		"ball",		ex_buffer_all,
 			RANGE|NOTADR|COUNT|TRLBAR),
 EX(CMD_badd,		"badd",		ex_edit,
@@ -146,19 +146,19 @@
 EX(CMD_belowright,	"belowright",	ex_wrongmodifier,
 			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_bfirst,		"bfirst",	ex_brewind,
-			BANG|RANGE|NOTADR|TRLBAR),
+			BANG|RANGE|NOTADR|EDITCMD|TRLBAR),
 EX(CMD_blast,		"blast",	ex_blast,
-			BANG|RANGE|NOTADR|TRLBAR),
+			BANG|RANGE|NOTADR|EDITCMD|TRLBAR),
 EX(CMD_bmodified,	"bmodified",	ex_bmodified,
-			BANG|RANGE|NOTADR|COUNT|TRLBAR),
+			BANG|RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_bnext,		"bnext",	ex_bnext,
-			BANG|RANGE|NOTADR|COUNT|TRLBAR),
+			BANG|RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_botright,	"botright",	ex_wrongmodifier,
 			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_bprevious,	"bprevious",	ex_bprevious,
-			BANG|RANGE|NOTADR|COUNT|TRLBAR),
+			BANG|RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_brewind,		"brewind",	ex_brewind,
-			BANG|RANGE|NOTADR|TRLBAR),
+			BANG|RANGE|NOTADR|EDITCMD|TRLBAR),
 EX(CMD_break,		"break",	ex_break,
 			TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_breakadd,	"breakadd",	ex_breakadd,
@@ -417,6 +417,8 @@
 			BANG|FILES|EDITCMD|ARGOPT|TRLBAR|CMDWIN),
 EX(CMD_help,		"help",		ex_help,
 			BANG|EXTRA|NOTRLCOM),
+EX(CMD_helpclose,	"helpclose",	ex_helpclose,
+			RANGE|NOTADR|COUNT|TRLBAR),
 EX(CMD_helpfind,	"helpfind",	ex_helpfind,
 			EXTRA|NOTRLCOM),
 EX(CMD_helpgrep,	"helpgrep",	ex_helpgrep,
@@ -477,6 +479,8 @@
 			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_keepjumps,	"keepjumps",	ex_wrongmodifier,
 			NEEDARG|EXTRA|NOTRLCOM),
+EX(CMD_keeppatterns,	"keeppatterns",	ex_wrongmodifier,
+			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_keepalt,		"keepalt",	ex_wrongmodifier,
 			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_list,		"list",		ex_print,
@@ -571,14 +575,14 @@
 			RANGE|NOTADR|COUNT|TRLBAR|BANG),
 EX(CMD_ltag,		"ltag",	ex_tag,
 			NOTADR|TRLBAR|BANG|WORD1),
+EX(CMD_lunmap,		"lunmap",	ex_unmap,
+			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_lua,		"lua",		ex_lua,
 			RANGE|EXTRA|NEEDARG|CMDWIN),
 EX(CMD_luado,		"luado",	ex_luado,
 			RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN),
 EX(CMD_luafile,		"luafile",	ex_luafile,
 			RANGE|FILE1|NEEDARG|CMDWIN),
-EX(CMD_lunmap,		"lunmap",	ex_unmap,
-			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_lvimgrep,	"lvimgrep",	ex_vimgrep,
 			RANGE|NOTADR|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE),
 EX(CMD_lvimgrepadd,	"lvimgrepadd",	ex_vimgrep,
@@ -653,6 +657,8 @@
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_noremenu,	"noremenu",	ex_menu,
 			RANGE|NOTADR|ZEROR|BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
+EX(CMD_noswapfile,	"noswapfile",	ex_wrongmodifier,
+			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_normal,		"normal",	ex_normal,
 			RANGE|BANG|EXTRA|NEEDARG|NOTRLCOM|USECTRLV|SBOXOK|CMDWIN),
 EX(CMD_number,		"number",	ex_print,
@@ -808,23 +814,23 @@
 EX(CMD_saveas,		"saveas",	ex_write,
 			BANG|DFLALL|FILE1|ARGOPT|CMDWIN|TRLBAR),
 EX(CMD_sbuffer,		"sbuffer",	ex_buffer,
-			BANG|RANGE|NOTADR|BUFNAME|BUFUNL|COUNT|EXTRA|TRLBAR),
+			BANG|RANGE|NOTADR|BUFNAME|BUFUNL|COUNT|EXTRA|EDITCMD|TRLBAR),
 EX(CMD_sbNext,		"sbNext",	ex_bprevious,
-			RANGE|NOTADR|COUNT|TRLBAR),
+			RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_sball,		"sball",	ex_buffer_all,
-			RANGE|NOTADR|COUNT|TRLBAR),
+			RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_sbfirst,		"sbfirst",	ex_brewind,
-			TRLBAR),
+			EDITCMD|TRLBAR),
 EX(CMD_sblast,		"sblast",	ex_blast,
-			TRLBAR),
+			EDITCMD|TRLBAR),
 EX(CMD_sbmodified,	"sbmodified",	ex_bmodified,
-			RANGE|NOTADR|COUNT|TRLBAR),
+			RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_sbnext,		"sbnext",	ex_bnext,
-			RANGE|NOTADR|COUNT|TRLBAR),
+			RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_sbprevious,	"sbprevious",	ex_bprevious,
-			RANGE|NOTADR|COUNT|TRLBAR),
+			RANGE|NOTADR|COUNT|EDITCMD|TRLBAR),
 EX(CMD_sbrewind,	"sbrewind",	ex_brewind,
-			TRLBAR),
+			EDITCMD|TRLBAR),
 EX(CMD_scriptnames,	"scriptnames",	ex_scriptnames,
 			TRLBAR|CMDWIN),
 EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
diff -Naur vim74.orig/src/ex_cmds2.c vim74/src/ex_cmds2.c
--- vim74.orig/src/ex_cmds2.c	2013-06-28 18:14:53.000000000 +0000
+++ vim74/src/ex_cmds2.c	2014-10-10 14:53:44.342047222 +0000
@@ -1436,20 +1436,20 @@
 }
 
 /*
- * return TRUE if buffer was changed and cannot be abandoned.
+ * Return TRUE if buffer was changed and cannot be abandoned.
+ * For flags use the CCGD_ values.
  */
     int
-check_changed(buf, checkaw, mult_win, forceit, allbuf)
+check_changed(buf, flags)
     buf_T	*buf;
-    int		checkaw;	/* do autowrite if buffer was changed */
-    int		mult_win;	/* check also when several wins for the buf */
-    int		forceit;
-    int		allbuf UNUSED;	/* may write all buffers */
+    int		flags;
 {
+    int forceit = (flags & CCGD_FORCEIT);
+
     if (       !forceit
 	    && bufIsChanged(buf)
-	    && (mult_win || buf->b_nwindows <= 1)
-	    && (!checkaw || autowrite(buf, forceit) == FAIL))
+	    && ((flags & CCGD_MULTWIN) || buf->b_nwindows <= 1)
+	    && (!(flags & CCGD_AW) || autowrite(buf, forceit) == FAIL))
     {
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 	if ((p_confirm || cmdmod.confirm) && p_write)
@@ -1457,7 +1457,7 @@
 	    buf_T	*buf2;
 	    int		count = 0;
 
-	    if (allbuf)
+	    if (flags & CCGD_ALLBUF)
 		for (buf2 = firstbuf; buf2 != NULL; buf2 = buf2->b_next)
 		    if (bufIsChanged(buf2)
 				     && (buf2->b_ffname != NULL
@@ -1480,7 +1480,10 @@
 	    return bufIsChanged(buf);
 	}
 #endif
-	EMSG(_(e_nowrtmsg));
+	if (flags & CCGD_EXCMD)
+	    EMSG(_(e_nowrtmsg));
+	else
+	    EMSG(_(e_nowrtmsg_nobang));
 	return TRUE;
     }
     return FALSE;
@@ -1690,7 +1693,9 @@
 	{
 	    /* Try auto-writing the buffer.  If this fails but the buffer no
 	    * longer exists it's not changed, that's OK. */
-	    if (check_changed(buf, p_awa, TRUE, FALSE, TRUE) && buf_valid(buf))
+	    if (check_changed(buf, (p_awa ? CCGD_AW : 0)
+				 | CCGD_MULTWIN
+				 | CCGD_ALLBUF) && buf_valid(buf))
 		break;	    /* didn't save - still changes */
 	}
     }
@@ -2274,7 +2279,10 @@
 		vim_free(p);
 	    }
 	    if ((!P_HID(curbuf) || !other)
-		  && check_changed(curbuf, TRUE, !other, eap->forceit, FALSE))
+		  && check_changed(curbuf, CCGD_AW
+					 | (other ? 0 : CCGD_MULTWIN)
+					 | (eap->forceit ? CCGD_FORCEIT : 0)
+					 | CCGD_EXCMD))
 		return;
 	}
 
@@ -2315,7 +2323,9 @@
      */
     if (       P_HID(curbuf)
 	    || eap->cmdidx == CMD_snext
-	    || !check_changed(curbuf, TRUE, FALSE, eap->forceit, FALSE))
+	    || !check_changed(curbuf, CCGD_AW
+				    | (eap->forceit ? CCGD_FORCEIT : 0)
+				    | CCGD_EXCMD))
     {
 	if (*eap->arg != NUL)		    /* redefine file list */
 	{
@@ -2454,11 +2464,16 @@
 	 * great speed improvement. */
 	save_ei = au_event_disable(",Syntax");
 #endif
+#ifdef FEAT_CLIPBOARD
+    start_global_changes();
+#endif
 
     if (eap->cmdidx == CMD_windo
 	    || eap->cmdidx == CMD_tabdo
 	    || P_HID(curbuf)
-	    || !check_changed(curbuf, TRUE, FALSE, eap->forceit, FALSE))
+	    || !check_changed(curbuf, CCGD_AW
+				    | (eap->forceit ? CCGD_FORCEIT : 0)
+				    | CCGD_EXCMD))
     {
 	/* start at the first argument/window/buffer */
 	i = 0;
@@ -2579,6 +2594,9 @@
 					       curbuf->b_fname, TRUE, curbuf);
     }
 #endif
+#ifdef FEAT_CLIPBOARD
+    end_global_changes();
+#endif
 }
 
 /*
@@ -2738,8 +2756,8 @@
  * used.
  * Returns OK when at least one match found, FAIL otherwise.
  *
- * If "name" is NULL calls callback for each entry in runtimepath. Cookie is 
- * passed by reference in this case, setting it to NULL indicates that callback 
+ * If "name" is NULL calls callback for each entry in runtimepath. Cookie is
+ * passed by reference in this case, setting it to NULL indicates that callback
  * has done its job.
  */
     int
@@ -4329,7 +4347,7 @@
     /* Find all available locales by running command "locale -a".  If this
      * doesn't work we won't have completion. */
     char_u *locale_a = get_cmd_output((char_u *)"locale -a",
-							NULL, SHELL_SILENT);
+						    NULL, SHELL_SILENT, NULL);
     if (locale_a == NULL)
 	return NULL;
     ga_init2(&locales_ga, sizeof(char_u *), 20);
diff -Naur vim74.orig/src/ex_docmd.c vim74/src/ex_docmd.c
--- vim74.orig/src/ex_docmd.c	2013-07-24 13:09:37.000000000 +0000
+++ vim74/src/ex_docmd.c	2014-10-10 14:53:44.352047197 +0000
@@ -316,7 +316,6 @@
 static void	ex_operators __ARGS((exarg_T *eap));
 static void	ex_put __ARGS((exarg_T *eap));
 static void	ex_copymove __ARGS((exarg_T *eap));
-static void	ex_may_print __ARGS((exarg_T *eap));
 static void	ex_submagic __ARGS((exarg_T *eap));
 static void	ex_join __ARGS((exarg_T *eap));
 static void	ex_at __ARGS((exarg_T *eap));
@@ -1843,6 +1842,11 @@
 			    cmdmod.keepalt = TRUE;
 			    continue;
 			}
+			if (checkforcmd(&ea.cmd, "keeppatterns", 5))
+			{
+			    cmdmod.keeppatterns = TRUE;
+			    continue;
+			}
 			if (!checkforcmd(&ea.cmd, "keepjumps", 5))
 			    break;
 			cmdmod.keepjumps = TRUE;
@@ -1869,18 +1873,23 @@
 #endif
 			continue;
 
-	    case 'n':	if (!checkforcmd(&ea.cmd, "noautocmd", 3))
-			    break;
-#ifdef FEAT_AUTOCMD
-			if (cmdmod.save_ei == NULL)
+	    case 'n':	if (checkforcmd(&ea.cmd, "noautocmd", 3))
 			{
-			    /* Set 'eventignore' to "all". Restore the
-			     * existing option value later. */
-			    cmdmod.save_ei = vim_strsave(p_ei);
-			    set_string_option_direct((char_u *)"ei", -1,
+#ifdef FEAT_AUTOCMD
+			    if (cmdmod.save_ei == NULL)
+			    {
+				/* Set 'eventignore' to "all". Restore the
+				 * existing option value later. */
+				cmdmod.save_ei = vim_strsave(p_ei);
+				set_string_option_direct((char_u *)"ei", -1,
 					 (char_u *)"all", OPT_FREE, SID_NONE);
-			}
+			    }
 #endif
+			    continue;
+			}
+			if (!checkforcmd(&ea.cmd, "noswapfile", 6))
+			    break;
+			cmdmod.noswapfile = TRUE;
 			continue;
 
 	    case 'r':	if (!checkforcmd(&ea.cmd, "rightbelow", 6))
@@ -2134,6 +2143,26 @@
     /* Find the command and let "p" point to after it. */
     p = find_command(&ea, NULL);
 
+#ifdef FEAT_AUTOCMD
+    /* If this looks like an undefined user command and there are CmdUndefined
+     * autocommands defined, trigger the matching autocommands. */
+    if (p != NULL && ea.cmdidx == CMD_SIZE && !ea.skip
+	    && ASCII_ISUPPER(*ea.cmd)
+	    && has_cmdundefined())
+    {
+	int ret;
+
+	p = ea.cmd;
+	while (ASCII_ISALNUM(*p))
+	    ++p;
+	p = vim_strnsave(ea.cmd, (int)(p - ea.cmd));
+	ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);
+	vim_free(p);
+	if (ret && !aborting())
+	    p = find_command(&ea, NULL);
+    }
+#endif
+
 #ifdef FEAT_USR_CMDS
     if (p == NULL)
     {
@@ -2584,12 +2613,15 @@
 	    case CMD_keepalt:
 	    case CMD_keepjumps:
 	    case CMD_keepmarks:
+	    case CMD_keeppatterns:
 	    case CMD_leftabove:
 	    case CMD_let:
 	    case CMD_lockmarks:
 	    case CMD_lua:
 	    case CMD_match:
 	    case CMD_mzscheme:
+	    case CMD_noautocmd:
+	    case CMD_noswapfile:
 	    case CMD_perl:
 	    case CMD_psearch:
 	    case CMD_python:
@@ -3089,9 +3121,11 @@
     {"keepalt", 5, FALSE},
     {"keepjumps", 5, FALSE},
     {"keepmarks", 3, FALSE},
+    {"keeppatterns", 5, FALSE},
     {"leftabove", 5, FALSE},
     {"lockmarks", 3, FALSE},
     {"noautocmd", 3, FALSE},
+    {"noswapfile", 3, FALSE},
     {"rightbelow", 6, FALSE},
     {"sandbox", 3, FALSE},
     {"silent", 3, FALSE},
@@ -3254,7 +3288,11 @@
 	    ++p;
 	/* for python 3.x: ":py3*" commands completion */
 	if (cmd[0] == 'p' && cmd[1] == 'y' && p == cmd + 2 && *p == '3')
+	{
 	    ++p;
+	    while (ASCII_ISALPHA(*p) || *p == '*')
+		++p;
+	}
 	len = (int)(p - cmd);
 
 	if (len == 0)
@@ -3597,8 +3635,11 @@
 	case CMD_keepalt:
 	case CMD_keepjumps:
 	case CMD_keepmarks:
+	case CMD_keeppatterns:
 	case CMD_leftabove:
 	case CMD_lockmarks:
+	case CMD_noautocmd:
+	case CMD_noswapfile:
 	case CMD_rightbelow:
 	case CMD_sandbox:
 	case CMD_silent:
@@ -4559,25 +4600,15 @@
 
 	/* For a shell command a '!' must be escaped. */
 	if ((eap->usefilter || eap->cmdidx == CMD_bang)
-			    && vim_strpbrk(repl, (char_u *)"!&;()<>") != NULL)
+			    && vim_strpbrk(repl, (char_u *)"!") != NULL)
 	{
 	    char_u	*l;
 
-	    l = vim_strsave_escaped(repl, (char_u *)"!&;()<>");
+	    l = vim_strsave_escaped(repl, (char_u *)"!");
 	    if (l != NULL)
 	    {
 		vim_free(repl);
 		repl = l;
-		/* For a sh-like shell escape "!" another time. */
-		if (strstr((char *)p_sh, "sh") != NULL)
-		{
-		    l = vim_strsave_escaped(repl, (char_u *)"!");
-		    if (l != NULL)
-		    {
-			vim_free(repl);
-			repl = l;
-		    }
-		}
 	    }
 	}
 
@@ -4830,7 +4861,7 @@
     if (*arg == '+')	    /* +[command] */
     {
 	++arg;
-	if (vim_isspace(*arg))
+	if (vim_isspace(*arg) || *arg == NUL)
 	    command = dollar_command;
 	else
 	{
@@ -5104,6 +5135,8 @@
 	    goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);
 	else
 	    goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);
+	if (eap->do_ecmd_cmd != NULL)
+	    do_cmdline_cmd(eap->do_ecmd_cmd);
     }
 }
 
@@ -5116,6 +5149,8 @@
     exarg_T	*eap;
 {
     goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);
+    if (eap->do_ecmd_cmd != NULL)
+	do_cmdline_cmd(eap->do_ecmd_cmd);
 }
 
 /*
@@ -5127,6 +5162,8 @@
     exarg_T	*eap;
 {
     goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);
+    if (eap->do_ecmd_cmd != NULL)
+	do_cmdline_cmd(eap->do_ecmd_cmd);
 }
 
 /*
@@ -5140,6 +5177,8 @@
     exarg_T	*eap;
 {
     goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);
+    if (eap->do_ecmd_cmd != NULL)
+	do_cmdline_cmd(eap->do_ecmd_cmd);
 }
 
 /*
@@ -5153,6 +5192,8 @@
     exarg_T	*eap;
 {
     goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);
+    if (eap->do_ecmd_cmd != NULL)
+	do_cmdline_cmd(eap->do_ecmd_cmd);
 }
 
 /*
@@ -5164,6 +5205,8 @@
     exarg_T	*eap;
 {
     goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);
+    if (eap->do_ecmd_cmd != NULL)
+	do_cmdline_cmd(eap->do_ecmd_cmd);
 }
 #endif
 
@@ -6565,7 +6608,9 @@
     if (check_more(FALSE, eap->forceit) == OK && only_one_window())
 	exiting = TRUE;
     if ((!P_HID(curbuf)
-		&& check_changed(curbuf, p_awa, FALSE, eap->forceit, FALSE))
+		&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)
+				       | (eap->forceit ? CCGD_FORCEIT : 0)
+				       | CCGD_EXCMD))
 	    || check_more(TRUE, eap->forceit) == FAIL
 	    || (only_one_window() && check_changed_any(eap->forceit)))
     {
@@ -7099,7 +7144,7 @@
     if (!P_HID(curbuf) && !split)
     {
 	++emsg_off;
-	split = check_changed(curbuf, TRUE, FALSE, FALSE, FALSE);
+	split = check_changed(curbuf, CCGD_AW);
 	--emsg_off;
     }
     if (split)
@@ -7198,6 +7243,7 @@
     else
     {
 	curwin->w_alist->al_refcount = 1;
+	curwin->w_alist->id = ++max_alist_id;
 	alist_init(curwin->w_alist);
     }
 }
@@ -7361,7 +7407,11 @@
 {
     /* Set recoverymode right away to avoid the ATTENTION prompt. */
     recoverymode = TRUE;
-    if (!check_changed(curbuf, p_awa, TRUE, eap->forceit, FALSE)
+    if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)
+			     | CCGD_MULTWIN
+			     | (eap->forceit ? CCGD_FORCEIT : 0)
+			     | CCGD_EXCMD)
+
 	    && (*eap->arg == NUL
 			     || setfname(curbuf, eap->arg, NULL, TRUE) == OK))
 	ml_recover();
@@ -7910,6 +7960,8 @@
 					       ? ECMD_ONE : eap->do_ecmd_lnum,
 		    (P_HID(curbuf) ? ECMD_HIDE : 0)
 		    + (eap->forceit ? ECMD_FORCEIT : 0)
+		      /* after a split we can use an existing buffer */
+		    + (old_curwin != NULL ? ECMD_OLDBUF : 0)
 #ifdef FEAT_LISTCMDS
 		    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0 )
 #endif
@@ -8036,6 +8088,8 @@
 {
 #ifdef FEAT_SCROLLBIND
     win_T	*wp;
+    win_T	*save_curwin = curwin;
+    buf_T	*save_curbuf = curbuf;
     long	topline;
     long	y;
     linenr_T	old_linenr = curwin->w_cursor.lnum;
@@ -8067,13 +8121,13 @@
 
 
     /*
-     * set all scrollbind windows to the same topline
+     * Set all scrollbind windows to the same topline.
      */
-    wp = curwin;
     for (curwin = firstwin; curwin; curwin = curwin->w_next)
     {
 	if (curwin->w_p_scb)
 	{
+	    curbuf = curwin->w_buffer;
 	    y = topline - curwin->w_topline;
 	    if (y > 0)
 		scrollup(y, TRUE);
@@ -8087,7 +8141,8 @@
 #endif
 	}
     }
-    curwin = wp;
+    curwin = save_curwin;
+    curbuf = save_curbuf;
     if (curwin->w_p_scb)
     {
 	did_syncbind = TRUE;
@@ -8207,6 +8262,7 @@
     int		local;
 {
     vim_free(curwin->w_localdir);
+    curwin->w_localdir = NULL;
     if (local)
     {
 	/* If still in global directory, need to remember current
@@ -8223,7 +8279,6 @@
 	 * name. */
 	vim_free(globaldir);
 	globaldir = NULL;
-	curwin->w_localdir = NULL;
     }
 
     shorten_fnames(TRUE);
@@ -8350,7 +8405,7 @@
     {
 	n = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;
 	if (n >= 0)
-	    windgoto((int)n, curwin->w_wcol);
+	    windgoto((int)n, W_WINCOL(curwin) + curwin->w_wcol);
     }
 
     len = eap->line2;
@@ -8556,6 +8611,9 @@
 	beginline(BL_SOL | BL_FIX);
     }
 
+    if (VIsual_active)
+	end_visual_mode();
+
     switch (eap->cmdidx)
     {
 	case CMD_delete:
@@ -8647,7 +8705,7 @@
 /*
  * Print the current line if flags were given to the Ex command.
  */
-    static void
+    void
 ex_may_print(eap)
     exarg_T	*eap;
 {
@@ -8692,7 +8750,7 @@
 	}
 	++eap->line2;
     }
-    (void)do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE);
+    (void)do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, TRUE);
     beginline(BL_WHITE | BL_FIX);
     ex_may_print(eap);
 }
@@ -8965,11 +9023,7 @@
     RedrawingDisabled = 0;
     p_lz = FALSE;
     update_topline();
-    update_screen(eap->forceit ? CLEAR :
-#ifdef FEAT_VISUAL
-	    VIsual_active ? INVERTED :
-#endif
-	    0);
+    update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);
 #ifdef FEAT_TITLE
     if (need_maketitle)
 	maketitle();
@@ -9004,11 +9058,7 @@
 	status_redraw_all();
     else
 	status_redraw_curbuf();
-    update_screen(
-# ifdef FEAT_VISUAL
-	    VIsual_active ? INVERTED :
-# endif
-	    0);
+    update_screen(VIsual_active ? INVERTED : 0);
     RedrawingDisabled = r;
     p_lz = p;
     out_flush();
@@ -10273,6 +10323,7 @@
     char_u	*sname;
     win_T	*edited_win = NULL;
     int		tabnr;
+    int		restore_stal = FALSE;
     win_T	*tab_firstwin;
     frame_T	*tab_topframe;
     int		cur_arg_idx = 0;
@@ -10355,7 +10406,7 @@
     }
 
     /* the global argument list */
-    if (ses_arglist(fd, "args", &global_alist.al_ga,
+    if (ses_arglist(fd, "argglobal", &global_alist.al_ga,
 			    !(ssop_flags & SSOP_CURDIR), &ssop_flags) == FAIL)
 	return FAIL;
 
@@ -10382,6 +10433,19 @@
 #endif
 
     /*
+     * When there are two or more tabpages and 'showtabline' is 1 the tabline
+     * will be displayed when creating the next tab.  That resizes the windows
+     * in the first tab, which may cause problems.  Set 'showtabline' to 2
+     * temporarily to avoid that.
+     */
+    if (p_stal == 1 && first_tabpage->tp_next != NULL)
+    {
+	if (put_line(fd, "set stal=2") == FAIL)
+	    return FAIL;
+	restore_stal = TRUE;
+    }
+
+    /*
      * May repeat putting Windows for each tab, when "tabpages" is in
      * 'sessionoptions'.
      * Don't use goto_tabpage(), it may change directory and trigger
@@ -10531,6 +10595,8 @@
 		|| put_eol(fd) == FAIL)
 	    return FAIL;
     }
+    if (restore_stal && put_line(fd, "set stal=1") == FAIL)
+	return FAIL;
 
     /*
      * Wipe out an empty unnamed buffer we started in.
@@ -10929,9 +10995,9 @@
     char_u	*buf = NULL;
     char_u	*s;
 
-    if (gap->ga_len == 0)
-	return put_line(fd, "silent! argdel *");
-    if (fputs(cmd, fd) < 0)
+    if (fputs(cmd, fd) < 0 || put_eol(fd) == FAIL)
+	return FAIL;
+    if (put_line(fd, "silent! argdel *") == FAIL)
 	return FAIL;
     for (i = 0; i < gap->ga_len; ++i)
     {
@@ -10948,7 +11014,9 @@
 		    s = buf;
 		}
 	    }
-	    if (fputs(" ", fd) < 0 || ses_put_fname(fd, s, flagp) == FAIL)
+	    if (fputs("argadd ", fd) < 0
+		    || ses_put_fname(fd, s, flagp) == FAIL
+		    || put_eol(fd) == FAIL)
 	    {
 		vim_free(buf);
 		return FAIL;
@@ -10956,7 +11024,7 @@
 	    vim_free(buf);
 	}
     }
-    return put_eol(fd);
+    return OK;
 }
 
 /*
@@ -11389,7 +11457,7 @@
 ex_nohlsearch(eap)
     exarg_T	*eap UNUSED;
 {
-    no_hlsearch = TRUE;
+    SET_NO_HLSEARCH(TRUE);
     redraw_all_later(SOME_VALID);
 }
 
@@ -11453,7 +11521,7 @@
 
 	    c = *end;
 	    *end = NUL;
-	    match_add(curwin, g, p + 1, 10, id);
+	    match_add(curwin, g, p + 1, 10, id, NULL);
 	    vim_free(g);
 	    *end = c;
 	}
@@ -11470,8 +11538,7 @@
 ex_X(eap)
     exarg_T	*eap UNUSED;
 {
-    if (get_crypt_method(curbuf) == 0 || blowfish_self_test() == OK)
-	(void)get_crypt_key(TRUE, TRUE);
+    (void)crypt_get_key(TRUE, TRUE);
 }
 #endif
 
@@ -11498,6 +11565,10 @@
 {
     linenr_T	lnum;
 
+#ifdef FEAT_CLIPBOARD
+    start_global_changes();
+#endif
+
     /* First set the marks for all lines closed/open. */
     for (lnum = eap->line1; lnum <= eap->line2; ++lnum)
 	if (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed))
@@ -11506,5 +11577,8 @@
     /* Execute the command on the marked lines. */
     global_exe(eap->arg);
     ml_clearmarked();	   /* clear rest of the marks */
+#ifdef FEAT_CLIPBOARD
+    end_global_changes();
+#endif
 }
 #endif
diff -Naur vim74.orig/src/ex_eval.c vim74/src/ex_eval.c
--- vim74.orig/src/ex_eval.c	2013-06-08 13:50:28.000000000 +0000
+++ vim74/src/ex_eval.c	2014-10-10 14:53:44.358713847 +0000
@@ -321,6 +321,17 @@
 }
 
 /*
+ * Free global "*msg_list" and the messages it contains, then set "*msg_list"
+ * to NULL.
+ */
+    void
+free_global_msglist()
+{
+    free_msglist(*msg_list);
+    *msg_list = NULL;
+}
+
+/*
  * Throw the message specified in the call to cause_errthrow() above as an
  * error exception.  If cstack is NULL, postpone the throw until do_cmdline()
  * has returned (see do_one_cmd()).
@@ -410,66 +421,41 @@
     return TRUE;
 }
 
-
 /*
- * Throw a new exception.  Return FAIL when out of memory or it was tried to
- * throw an illegal user exception.  "value" is the exception string for a user
- * or interrupt exception, or points to a message list in case of an error
- * exception.
+ * Get an exception message that is to be stored in current_exception->value.
  */
-    static int
-throw_exception(value, type, cmdname)
+    char_u *
+get_exception_string(value, type, cmdname, should_free)
     void	*value;
     int		type;
     char_u	*cmdname;
+    int		*should_free;
 {
-    except_T	*excp;
-    char_u	*p, *mesg, *val;
+    char_u	*ret, *mesg;
     int		cmdlen;
-
-    /*
-     * Disallow faking Interrupt or error exceptions as user exceptions.  They
-     * would be treated differently from real interrupt or error exceptions when
-     * no active try block is found, see do_cmdline().
-     */
-    if (type == ET_USER)
-    {
-	if (STRNCMP((char_u *)value, "Vim", 3) == 0 &&
-		(((char_u *)value)[3] == NUL || ((char_u *)value)[3] == ':' ||
-		 ((char_u *)value)[3] == '('))
-	{
-	    EMSG(_("E608: Cannot :throw exceptions with 'Vim' prefix"));
-	    goto fail;
-	}
-    }
-
-    excp = (except_T *)alloc((unsigned)sizeof(except_T));
-    if (excp == NULL)
-	goto nomem;
+    char_u	*p, *val;
 
     if (type == ET_ERROR)
     {
-	/* Store the original message and prefix the exception value with
-	 * "Vim:" or, if a command name is given, "Vim(cmdname):". */
-	excp->messages = (struct msglist *)value;
-	mesg = excp->messages->throw_msg;
+	*should_free = FALSE;
+	mesg = ((struct msglist *)value)->throw_msg;
 	if (cmdname != NULL && *cmdname != NUL)
 	{
 	    cmdlen = (int)STRLEN(cmdname);
-	    excp->value = vim_strnsave((char_u *)"Vim(",
+	    ret = vim_strnsave((char_u *)"Vim(",
 					   4 + cmdlen + 2 + (int)STRLEN(mesg));
-	    if (excp->value == NULL)
-		goto nomem;
-	    STRCPY(&excp->value[4], cmdname);
-	    STRCPY(&excp->value[4 + cmdlen], "):");
-	    val = excp->value + 4 + cmdlen + 2;
+	    if (ret == NULL)
+		return ret;
+	    STRCPY(&ret[4], cmdname);
+	    STRCPY(&ret[4 + cmdlen], "):");
+	    val = ret + 4 + cmdlen + 2;
 	}
 	else
 	{
-	    excp->value = vim_strnsave((char_u *)"Vim:", 4 + (int)STRLEN(mesg));
-	    if (excp->value == NULL)
-		goto nomem;
-	    val = excp->value + 4;
+	    ret = vim_strnsave((char_u *)"Vim:", 4 + (int)STRLEN(mesg));
+	    if (ret == NULL)
+		return ret;
+	    val = ret + 4;
 	}
 
 	/* msg_add_fname may have been used to prefix the message with a file
@@ -506,14 +492,65 @@
 	}
     }
     else
-	excp->value = value;
+    {
+	*should_free = FALSE;
+	ret = (char_u *) value;
+    }
+
+    return ret;
+}
+
+
+/*
+ * Throw a new exception.  Return FAIL when out of memory or it was tried to
+ * throw an illegal user exception.  "value" is the exception string for a
+ * user or interrupt exception, or points to a message list in case of an
+ * error exception.
+ */
+    static int
+throw_exception(value, type, cmdname)
+    void	*value;
+    int		type;
+    char_u	*cmdname;
+{
+    except_T	*excp;
+    int		should_free;
+
+    /*
+     * Disallow faking Interrupt or error exceptions as user exceptions.  They
+     * would be treated differently from real interrupt or error exceptions
+     * when no active try block is found, see do_cmdline().
+     */
+    if (type == ET_USER)
+    {
+	if (STRNCMP((char_u *)value, "Vim", 3) == 0
+		&& (((char_u *)value)[3] == NUL || ((char_u *)value)[3] == ':'
+		    || ((char_u *)value)[3] == '('))
+	{
+	    EMSG(_("E608: Cannot :throw exceptions with 'Vim' prefix"));
+	    goto fail;
+	}
+    }
+
+    excp = (except_T *)alloc((unsigned)sizeof(except_T));
+    if (excp == NULL)
+	goto nomem;
+
+    if (type == ET_ERROR)
+	/* Store the original message and prefix the exception value with
+	 * "Vim:" or, if a command name is given, "Vim(cmdname):". */
+	excp->messages = (struct msglist *)value;
+
+    excp->value = get_exception_string(value, type, cmdname, &should_free);
+    if (excp->value == NULL && should_free)
+	goto nomem;
 
     excp->type = type;
     excp->throw_name = vim_strsave(sourcing_name == NULL
 					      ? (char_u *)"" : sourcing_name);
     if (excp->throw_name == NULL)
     {
-	if (type == ET_ERROR)
+	if (should_free)
 	    vim_free(excp->value);
 	goto nomem;
     }
@@ -2033,10 +2070,7 @@
 	/* If an error was about to be converted to an exception when
 	 * enter_cleanup() was called, free the message list. */
 	if (msg_list != NULL)
-	{
-	    free_msglist(*msg_list);
-	    *msg_list = NULL;
-	}
+	    free_global_msglist();
     }
 
     /*
diff -Naur vim74.orig/src/ex_getln.c vim74/src/ex_getln.c
--- vim74.orig/src/ex_getln.c	2013-07-05 17:44:21.000000000 +0000
+++ vim74/src/ex_getln.c	2014-10-10 14:53:44.365380497 +0000
@@ -342,6 +342,13 @@
     do_digraph(-1);		/* init digraph typeahead */
 #endif
 
+    /* If something above caused an error, reset the flags, we do want to type
+     * and execute commands. Display may be messed up a bit. */
+    if (did_emsg)
+	redrawcmd();
+    did_emsg = FALSE;
+    got_int = FALSE;
+
     /*
      * Collect the command string, handling editing keys.
      */
@@ -752,11 +759,14 @@
 #ifdef FEAT_CMDWIN
 	if (c == cedit_key || c == K_CMDWIN)
 	{
-	    /*
-	     * Open a window to edit the command line (and history).
-	     */
-	    c = ex_window();
-	    some_key_typed = TRUE;
+	    if (ex_normal_busy == 0 && got_int == FALSE)
+	    {
+		/*
+		 * Open a window to edit the command line (and history).
+		 */
+		c = ex_window();
+		some_key_typed = TRUE;
+	    }
 	}
 # ifdef FEAT_DIGRAPHS
 	else
@@ -2188,6 +2198,7 @@
     int		vcol = 0;
     char_u	*p;
     int		prev_char;
+    int		len;
 
     /* Switch cursor on now.  This avoids that it happens after the "\n", which
      * confuses the system function that computes tabstops. */
@@ -2264,7 +2275,17 @@
 	    {
 		if (line_ga.ga_len > 0)
 		{
-		    --line_ga.ga_len;
+#ifdef FEAT_MBYTE
+		    if (has_mbyte)
+		    {
+			p = (char_u *)line_ga.ga_data;
+			p[line_ga.ga_len] = NUL;
+			len = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;
+			line_ga.ga_len -= len;
+		    }
+		    else
+#endif
+			--line_ga.ga_len;
 		    goto redraw;
 		}
 		continue;
@@ -2280,14 +2301,14 @@
 
 	    if (c1 == Ctrl_T)
 	    {
-		long        sw = get_sw_value();
+		long	    sw = get_sw_value(curbuf);
 
 		p = (char_u *)line_ga.ga_data;
 		p[line_ga.ga_len] = NUL;
-		indent = get_indent_str(p, 8);
+		indent = get_indent_str(p, 8, FALSE);
 		indent += sw - indent % sw;
 add_indent:
-		while (get_indent_str(p, 8) < indent)
+		while (get_indent_str(p, 8, FALSE) < indent)
 		{
 		    char_u *s = skipwhite(p);
 
@@ -2300,8 +2321,9 @@
 		/* redraw the line */
 		msg_col = startcol;
 		vcol = 0;
-		for (p = (char_u *)line_ga.ga_data;
-			  p < (char_u *)line_ga.ga_data + line_ga.ga_len; ++p)
+		p = (char_u *)line_ga.ga_data;
+		p[line_ga.ga_len] = NUL;
+		while (p < (char_u *)line_ga.ga_data + line_ga.ga_len)
 		{
 		    if (*p == TAB)
 		    {
@@ -2309,11 +2331,14 @@
 			{
 			    msg_putchar(' ');
 			} while (++vcol % 8);
+			++p;
 		    }
 		    else
 		    {
-			msg_outtrans_len(p, 1);
-			vcol += char2cells(*p);
+			len = MB_PTR2LEN(p);
+			msg_outtrans_len(p, len);
+			vcol += ptr2cells(p);
+			p += len;
 		    }
 		}
 		msg_clr_eos();
@@ -2335,11 +2360,11 @@
 		else
 		{
 		    p[line_ga.ga_len] = NUL;
-		    indent = get_indent_str(p, 8);
+		    indent = get_indent_str(p, 8, FALSE);
 		    --indent;
-		    indent -= indent % get_sw_value();
+		    indent -= indent % get_sw_value(curbuf);
 		}
-		while (get_indent_str(p, 8) > indent)
+		while (get_indent_str(p, 8, FALSE) > indent)
 		{
 		    char_u *s = skipwhite(p);
 
@@ -2362,7 +2387,16 @@
 
 	if (IS_SPECIAL(c1))
 	    c1 = '?';
-	((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;
+#ifdef FEAT_MBYTE
+	if (has_mbyte)
+	    len = (*mb_char2bytes)(c1,
+				  (char_u *)line_ga.ga_data + line_ga.ga_len);
+	else
+#endif
+	{
+	    len = 1;
+	    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;
+	}
 	if (c1 == '\n')
 	    msg_putchar('\n');
 	else if (c1 == TAB)
@@ -2376,10 +2410,10 @@
 	else
 	{
 	    msg_outtrans_len(
-		     ((char_u *)line_ga.ga_data) + line_ga.ga_len, 1);
+		     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);
 	    vcol += char2cells(c1);
 	}
-	++line_ga.ga_len;
+	line_ga.ga_len += len;
 	escaped = FALSE;
 
 	windgoto(msg_row, msg_col);
@@ -3852,9 +3886,9 @@
     char_u	buf[20];
     int		j = 0;
 
-    /* Don't escape '[' and '{' if they are in 'isfname'. */
+    /* Don't escape '[', '{' and '!' if they are in 'isfname'. */
     for (p = PATH_ESC_CHARS; *p != NUL; ++p)
-	if ((*p != '[' && *p != '{') || !vim_isfilec(*p))
+	if ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))
 	    buf[j++] = *p;
     buf[j] = NUL;
     p = vim_strsave_escaped(fname, buf);
@@ -4178,7 +4212,7 @@
 /*
  * Prepare a string for expansion.
  * When expanding file names: The string will be used with expand_wildcards().
- * Copy the file name into allocated memory and add a '*' at the end.
+ * Copy "fname[len]" into allocated memory and add a '*' at the end.
  * When expanding other names: The string will be used with regcomp().  Copy
  * the name into allocated memory and prepend "^".
  */
@@ -5095,9 +5129,9 @@
     char_u	***file;
     char	*dirnames[];
 {
-    char_u	*matches;
     char_u	*s;
     char_u	*e;
+    char_u	*match;
     garray_T	ga;
     int		i;
     int		pat_len;
@@ -5116,33 +5150,27 @@
 	    return FAIL;
 	}
 	sprintf((char *)s, "%s/%s*.vim", dirnames[i], pat);
-	matches = globpath(p_rtp, s, 0);
+	globpath(p_rtp, s, &ga, 0);
 	vim_free(s);
-	if (matches == NULL)
-	    continue;
+    }
 
-	for (s = matches; *s != NUL; s = e)
-	{
-	    e = vim_strchr(s, '\n');
-	    if (e == NULL)
-		e = s + STRLEN(s);
-	    if (ga_grow(&ga, 1) == FAIL)
-		break;
-	    if (e - 4 > s && STRNICMP(e - 4, ".vim", 4) == 0)
-	    {
-		for (s = e - 4; s > matches; mb_ptr_back(matches, s))
-		    if (*s == '\n' || vim_ispathsep(*s))
-			break;
-		++s;
-		((char_u **)ga.ga_data)[ga.ga_len] =
-					    vim_strnsave(s, (int)(e - s - 4));
-		++ga.ga_len;
-	    }
-	    if (*e != NUL)
-		++e;
+    for (i = 0; i < ga.ga_len; ++i)
+    {
+	match = ((char_u **)ga.ga_data)[i];
+	s = match;
+	e = s + STRLEN(s);
+	if (e - 4 > s && STRNICMP(e - 4, ".vim", 4) == 0)
+	{
+	    e -= 4;
+	    for (s = e; s > match; mb_ptr_back(match, s))
+		if (s < match || vim_ispathsep(*s))
+		    break;
+	    ++s;
+	    *e = NUL;
+	    mch_memmove(match, s, e - s + 1);
 	}
-	vim_free(matches);
     }
+
     if (ga.ga_len == 0)
 	return FAIL;
 
@@ -5160,33 +5188,28 @@
 #if defined(FEAT_CMDL_COMPL) || defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Expand "file" for all comma-separated directories in "path".
- * Returns an allocated string with all matches concatenated, separated by
- * newlines.  Returns NULL for an error or no matches.
+ * Adds the matches to "ga".  Caller must init "ga".
  */
-    char_u *
-globpath(path, file, expand_options)
+    void
+globpath(path, file, ga, expand_options)
     char_u	*path;
     char_u	*file;
+    garray_T	*ga;
     int		expand_options;
 {
     expand_T	xpc;
     char_u	*buf;
-    garray_T	ga;
     int		i;
-    int		len;
     int		num_p;
     char_u	**p;
-    char_u	*cur = NULL;
 
     buf = alloc(MAXPATHL);
     if (buf == NULL)
-	return NULL;
+	return;
 
     ExpandInit(&xpc);
     xpc.xp_context = EXPAND_FILES;
 
-    ga_init2(&ga, 1, 100);
-
     /* Loop over all entries in {path}. */
     while (*path != NUL)
     {
@@ -5207,30 +5230,23 @@
 			     WILD_SILENT|expand_options) != FAIL && num_p > 0)
 	    {
 		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT|expand_options);
-		for (len = 0, i = 0; i < num_p; ++i)
-		    len += (int)STRLEN(p[i]) + 1;
 
-		/* Concatenate new results to previous ones. */
-		if (ga_grow(&ga, len) == OK)
+		if (ga_grow(ga, num_p) == OK)
 		{
-		    cur = (char_u *)ga.ga_data + ga.ga_len;
 		    for (i = 0; i < num_p; ++i)
 		    {
-			STRCPY(cur, p[i]);
-			cur += STRLEN(p[i]);
-			*cur++ = '\n';
+			((char_u **)ga->ga_data)[ga->ga_len] =
+					vim_strnsave(p[i], (int)STRLEN(p[i]));
+			++ga->ga_len;
 		    }
-		    ga.ga_len += len;
 		}
+
 		FreeWild(num_p, p);
 	    }
 	}
     }
-    if (cur != NULL)
-	*--cur = 0; /* Replace trailing newline with NUL */
 
     vim_free(buf);
-    return (char_u *)ga.ga_data;
 }
 
 #endif
@@ -5498,6 +5514,9 @@
     if (hislen == 0)		/* no history */
 	return;
 
+    if (cmdmod.keeppatterns && histype == HIST_SEARCH)
+	return;
+
     /*
      * Searches inside the same mapping overwrite each other, so that only
      * the last line is kept.  Be careful not to remove a line that was moved
@@ -6347,6 +6366,9 @@
 #ifdef FEAT_RIGHTLEFT
     int			save_cmdmsg_rl = cmdmsg_rl;
 #endif
+#ifdef FEAT_FOLDING
+    int			save_KeyTyped;
+#endif
 
     /* Can't do this recursively.  Can't do it when typing a password. */
     if (cmdwin_type != 0
@@ -6481,8 +6503,19 @@
     RedrawingDisabled = i;
 
 # ifdef FEAT_AUTOCMD
+
+#  ifdef FEAT_FOLDING
+    save_KeyTyped = KeyTyped;
+#  endif
+
     /* Trigger CmdwinLeave autocommands. */
     apply_autocmds(EVENT_CMDWINLEAVE, typestr, typestr, FALSE, curbuf);
+
+#  ifdef FEAT_FOLDING
+    /* Restore KeyTyped in case it is modified by autocommands */
+    KeyTyped = save_KeyTyped;
+#  endif
+
 # endif
 
     /* Restore the command line info. */
diff -Naur vim74.orig/src/feature.h vim74/src/feature.h
--- vim74.orig/src/feature.h	2013-05-18 18:18:20.000000000 +0000
+++ vim74/src/feature.h	2014-10-10 14:53:44.375380472 +0000
@@ -211,18 +211,11 @@
 #endif
 
 /*
- * +visual		Visual mode.
+ * +visual		Visual mode - now always included.
  * +visualextra		Extra features for Visual mode (mostly block operators).
  */
-#ifdef FEAT_SMALL
-# define FEAT_VISUAL
-# ifdef FEAT_NORMAL
-#  define FEAT_VISUALEXTRA
-# endif
-#else
-# ifdef FEAT_CLIPBOARD
-#  undef FEAT_CLIPBOARD	/* can't use clipboard without Visual mode */
-# endif
+#ifdef FEAT_NORMAL
+# define FEAT_VISUALEXTRA
 #endif
 
 /*
@@ -328,7 +321,7 @@
  *
  * Disabled for EBCDIC as it requires multibyte.
  */
-#if defined(FEAT_BIG) && !defined(WIN16) && SIZEOF_INT >= 4 && !defined(EBCDIC)
+#if defined(FEAT_BIG) && !defined(WIN16) && VIM_SIZEOF_INT >= 4 && !defined(EBCDIC)
 # define FEAT_ARABIC
 #endif
 #ifdef FEAT_ARABIC
@@ -640,7 +633,7 @@
  */
 #if (defined(FEAT_NORMAL) || defined(FEAT_GUI_GTK) || defined(FEAT_ARABIC)) \
 	&& !defined(FEAT_MBYTE) && !defined(WIN16) \
-	&& SIZEOF_INT >= 4 && !defined(EBCDIC)
+	&& VIM_SIZEOF_INT >= 4 && !defined(EBCDIC)
 # define FEAT_MBYTE
 #endif
 
@@ -661,7 +654,7 @@
 # define FEAT_MBYTE
 #endif
 
-#if defined(FEAT_MBYTE) && SIZEOF_INT < 4 && !defined(PROTO)
+#if defined(FEAT_MBYTE) && VIM_SIZEOF_INT < 4 && !defined(PROTO)
 	Error: Can only handle multi-byte feature with 32 bit int or larger
 #endif
 
@@ -1144,13 +1137,10 @@
 #ifdef FEAT_GUI
 # ifndef FEAT_CLIPBOARD
 #  define FEAT_CLIPBOARD
-#  ifndef FEAT_VISUAL
-#   define FEAT_VISUAL
-#  endif
 # endif
 #endif
 
-#if defined(FEAT_NORMAL) && defined(FEAT_VISUAL) \
+#if defined(FEAT_NORMAL) \
 	&& (defined(UNIX) || defined(VMS)) \
 	&& defined(WANT_X11) && defined(HAVE_X11)
 # define FEAT_XCLIPBOARD
diff -Naur vim74.orig/src/fileio.c vim74/src/fileio.c
--- vim74.orig/src/fileio.c	2013-08-05 19:58:03.000000000 +0000
+++ vim74/src/fileio.c	2014-10-10 14:53:44.385380447 +0000
@@ -24,20 +24,6 @@
 #define BUFSIZE		8192	/* size of normal write buffer */
 #define SMBUFSIZE	256	/* size of emergency write buffer */
 
-#ifdef FEAT_CRYPT
-/* crypt_magic[0] is pkzip crypt, crypt_magic[1] is sha2+blowfish */
-static char	*crypt_magic[] = {"VimCrypt~01!", "VimCrypt~02!"};
-static char	crypt_magic_head[] = "VimCrypt~";
-# define CRYPT_MAGIC_LEN	12		/* must be multiple of 4! */
-
-/* For blowfish, after the magic header, we store 8 bytes of salt and then 8
- * bytes of seed (initialisation vector). */
-static int	crypt_salt_len[] = {0, 8};
-static int	crypt_seed_len[] = {0, 8};
-#define CRYPT_SALT_LEN_MAX 8
-#define CRYPT_SEED_LEN_MAX 8
-#endif
-
 /* Is there any system that doesn't have access()? */
 #define USE_MCH_ACCESS
 
@@ -55,7 +41,6 @@
 static void check_marks_read __ARGS((void));
 #endif
 #ifdef FEAT_CRYPT
-static int crypt_method_from_magic __ARGS((char *ptr, int len));
 static char_u *check_for_cryptkey __ARGS((char_u *cryptkey, char_u *ptr, long *sizep, off_t *filesizep, int newfile, char_u *fname, int *did_ask));
 #endif
 #ifdef UNIX
@@ -116,6 +101,9 @@
 #ifdef HAS_BW_FLAGS
     int		bw_flags;	/* FIO_ flags */
 #endif
+#ifdef FEAT_CRYPT
+    buf_T	*bw_buffer;	/* buffer being written */
+#endif
 #ifdef FEAT_MBYTE
     char_u	bw_rest[CONV_RESTLEN]; /* not converted bytes */
     int		bw_restlen;	/* nr of bytes in bw_rest[] */
@@ -250,7 +238,6 @@
 #ifdef FEAT_CRYPT
     char_u	*cryptkey = NULL;
     int		did_ask_for_key = FALSE;
-    int		crypt_method_used;
 #endif
 #ifdef FEAT_PERSISTENT_UNDO
     context_sha256_T sha_ctx;
@@ -428,13 +415,13 @@
 	}
     }
 
-#ifdef UNIX
-    /*
-     * On Unix it is possible to read a directory, so we have to
-     * check for it before the mch_open().
-     */
     if (!read_stdin && !read_buffer)
     {
+#ifdef UNIX
+	/*
+	 * On Unix it is possible to read a directory, so we have to
+	 * check for it before the mch_open().
+	 */
 	perm = mch_getperm(fname);
 	if (perm >= 0 && !S_ISREG(perm)		    /* not a regular file ... */
 # ifdef S_ISFIFO
@@ -457,8 +444,8 @@
 	    msg_scroll = msg_save;
 	    return FAIL;
 	}
-
-# if defined(MSDOS) || defined(MSWIN) || defined(OS2)
+#endif
+#if defined(MSDOS) || defined(MSWIN) || defined(OS2)
 	/*
 	 * MS-Windows allows opening a device, but we will probably get stuck
 	 * trying to read it.
@@ -470,9 +457,8 @@
 	    msg_scroll = msg_save;
 	    return FAIL;
 	}
-# endif
-    }
 #endif
+    }
 
     /* Set default or forced 'fileformat' and 'binary'. */
     set_file_options(set_options, eap);
@@ -967,13 +953,6 @@
 #endif
     }
 
-#ifdef FEAT_CRYPT
-    if (cryptkey != NULL)
-	/* Need to reset the state, but keep the key, don't want to ask for it
-	 * again. */
-	crypt_pop_state();
-#endif
-
     /*
      * When retrying with another "fenc" and the first time "fileformat"
      * will be reset.
@@ -1176,6 +1155,15 @@
 	if (read_undo_file)
 	    sha256_start(&sha_ctx);
 #endif
+#ifdef FEAT_CRYPT
+	if (curbuf->b_cryptstate != NULL)
+	{
+	    /* Need to free the state, but keep the key, don't want to ask for
+	     * it again. */
+	    crypt_free_state(curbuf->b_cryptstate);
+	    curbuf->b_cryptstate = NULL;
+	}
+#endif
     }
 
     while (!error && !got_int)
@@ -1186,7 +1174,7 @@
 	 * The amount is limited by the fact that read() only can read
 	 * upto max_unsigned characters (and other things).
 	 */
-#if SIZEOF_INT <= 2
+#if VIM_SIZEOF_INT <= 2
 	if (linerest >= 0x7ff0)
 	{
 	    ++split;
@@ -1198,7 +1186,7 @@
 	{
 	    if (!skip_read)
 	    {
-#if SIZEOF_INT > 2
+#if VIM_SIZEOF_INT > 2
 # if defined(SSIZE_MAX) && (SSIZE_MAX < 0x10000L)
 		size = SSIZE_MAX;		    /* use max I/O size, 52K */
 # else
@@ -1340,6 +1328,76 @@
 		    size = read_eintr(fd, ptr, size);
 		}
 
+#ifdef FEAT_CRYPT
+		/*
+		 * At start of file: Check for magic number of encryption.
+		 */
+		if (filesize == 0 && size > 0)
+		    cryptkey = check_for_cryptkey(cryptkey, ptr, &size,
+						  &filesize, newfile, sfname,
+						  &did_ask_for_key);
+		/*
+		 * Decrypt the read bytes.  This is done before checking for
+		 * EOF because the crypt layer may be buffering.
+		 */
+		if (cryptkey != NULL && size > 0)
+		{
+		    if (crypt_works_inplace(curbuf->b_cryptstate))
+		    {
+			crypt_decode_inplace(curbuf->b_cryptstate, ptr, size);
+		    }
+		    else
+		    {
+			char_u	*newptr = NULL;
+			int	decrypted_size;
+
+			decrypted_size = crypt_decode_alloc(
+				    curbuf->b_cryptstate, ptr, size, &newptr);
+
+			/* If the crypt layer is buffering, not producing
+			 * anything yet, need to read more. */
+			if (size > 0 && decrypted_size == 0)
+			    continue;
+
+			if (linerest == 0)
+			{
+			    /* Simple case: reuse returned buffer (may be
+			     * NULL, checked later). */
+			    new_buffer = newptr;
+			}
+			else
+			{
+			    long_u	new_size;
+
+			    /* Need new buffer to add bytes carried over. */
+			    new_size = (long_u)(decrypted_size + linerest + 1);
+			    new_buffer = lalloc(new_size, FALSE);
+			    if (new_buffer == NULL)
+			    {
+				do_outofmem_msg(new_size);
+				error = TRUE;
+				break;
+			    }
+
+			    mch_memmove(new_buffer, buffer, linerest);
+			    if (newptr != NULL)
+				mch_memmove(new_buffer + linerest, newptr,
+							      decrypted_size);
+			}
+
+			if (new_buffer != NULL)
+			{
+			    vim_free(buffer);
+			    buffer = new_buffer;
+			    new_buffer = NULL;
+			    line_start = buffer;
+			    ptr = buffer + linerest;
+			}
+			size = decrypted_size;
+		    }
+		}
+#endif
+
 		if (size <= 0)
 		{
 		    if (size < 0)		    /* read error */
@@ -1404,21 +1462,6 @@
 		    }
 #endif
 		}
-
-#ifdef FEAT_CRYPT
-		/*
-		 * At start of file: Check for magic number of encryption.
-		 */
-		if (filesize == 0)
-		    cryptkey = check_for_cryptkey(cryptkey, ptr, &size,
-					&filesize, newfile, sfname,
-					&did_ask_for_key);
-		/*
-		 * Decrypt the read bytes.
-		 */
-		if (cryptkey != NULL && size > 0)
-		    crypt_decode(ptr, size);
-#endif
 	    }
 	    skip_read = FALSE;
 
@@ -1431,10 +1474,9 @@
 	     */
 	    if ((filesize == 0
 # ifdef FEAT_CRYPT
-		   || (filesize == (CRYPT_MAGIC_LEN
-					   + crypt_salt_len[use_crypt_method]
-					   + crypt_seed_len[use_crypt_method])
-							  && cryptkey != NULL)
+		   || (cryptkey != NULL
+			&& filesize == crypt_get_header_len(
+						 crypt_get_method_nr(curbuf)))
 # endif
 		       )
 		    && (fio_flags == FIO_UCSBOM
@@ -2263,15 +2305,15 @@
 	save_file_ff(curbuf);		/* remember the current file format */
 
 #ifdef FEAT_CRYPT
-    crypt_method_used = use_crypt_method;
-    if (cryptkey != NULL)
+    if (curbuf->b_cryptstate != NULL)
     {
-	crypt_pop_state();
-	if (cryptkey != curbuf->b_p_key)
-	    free_crypt_key(cryptkey);
-	/* don't set cryptkey to NULL, it's used below as a flag that
-	 * encryption was used */
+	crypt_free_state(curbuf->b_cryptstate);
+	curbuf->b_cryptstate = NULL;
     }
+    if (cryptkey != NULL && cryptkey != curbuf->b_p_key)
+	crypt_free_key(cryptkey);
+    /* Don't set cryptkey to NULL, it's used below as a flag that
+     * encryption was used. */
 #endif
 
 #ifdef FEAT_MBYTE
@@ -2458,10 +2500,7 @@
 #ifdef FEAT_CRYPT
 	    if (cryptkey != NULL)
 	    {
-		if (crypt_method_used == 1)
-		    STRCAT(IObuff, _("[blowfish]"));
-		else
-		    STRCAT(IObuff, _("[crypted]"));
+		crypt_append_msg(curbuf);
 		c = TRUE;
 	    }
 #endif
@@ -2490,9 +2529,7 @@
 #ifdef FEAT_CRYPT
 	    if (cryptkey != NULL)
 		msg_add_lines(c, (long)linecnt, filesize
-			- CRYPT_MAGIC_LEN
-			- crypt_salt_len[use_crypt_method]
-			- crypt_seed_len[use_crypt_method]);
+			 - crypt_get_header_len(crypt_get_method_nr(curbuf)));
 	    else
 #endif
 		msg_add_lines(c, (long)linecnt, filesize);
@@ -2883,33 +2920,6 @@
 
 #if defined(FEAT_CRYPT) || defined(PROTO)
 /*
- * Get the crypt method used for a file from "ptr[len]", the magic text at the
- * start of the file.
- * Returns -1 when no encryption used.
- */
-    static int
-crypt_method_from_magic(ptr, len)
-    char  *ptr;
-    int   len;
-{
-    int i;
-
-    for (i = 0; i < (int)(sizeof(crypt_magic) / sizeof(crypt_magic[0])); i++)
-    {
-	if (len < (CRYPT_MAGIC_LEN + crypt_salt_len[i] + crypt_seed_len[i]))
-	    continue;
-	if (memcmp(ptr, crypt_magic[i], CRYPT_MAGIC_LEN) == 0)
-	    return i;
-    }
-
-    i = (int)STRLEN(crypt_magic_head);
-    if (len >= i && memcmp(ptr, crypt_magic_head, i) == 0)
-	EMSG(_("E821: File is encrypted with unknown method"));
-
-    return -1;
-}
-
-/*
  * Check for magic number used for encryption.  Applies to the current buffer.
  * If found, the magic number is removed from ptr[*sizep] and *sizep and
  * *filesizep are updated.
@@ -2925,13 +2935,17 @@
     char_u	*fname;		/* file name to display */
     int		*did_ask;	/* flag: whether already asked for key */
 {
-    int method = crypt_method_from_magic((char *)ptr, *sizep);
+    int method = crypt_method_nr_from_magic((char *)ptr, *sizep);
+    int b_p_ro = curbuf->b_p_ro;
 
     if (method >= 0)
     {
-	set_crypt_method(curbuf, method);
-	if (method > 0)
-	    (void)blowfish_self_test();
+	/* Mark the buffer as read-only until the decryption has taken place.
+	 * Avoids accidentally overwriting the file with garbage. */
+	curbuf->b_p_ro = TRUE;
+
+	/* Set the cryptmethod local to the buffer. */
+	crypt_set_cm_option(curbuf, method);
 	if (cryptkey == NULL && !*did_ask)
 	{
 	    if (*curbuf->b_p_key)
@@ -2944,7 +2958,7 @@
 		 * Happens when retrying to detect encoding. */
 		smsg((char_u *)_(need_key_msg), fname);
 		msg_scroll = TRUE;
-		cryptkey = get_crypt_key(newfile, FALSE);
+		cryptkey = crypt_get_key(newfile, FALSE);
 		*did_ask = TRUE;
 
 		/* check if empty key entered */
@@ -2959,24 +2973,20 @@
 
 	if (cryptkey != NULL)
 	{
-	    int seed_len = crypt_seed_len[method];
-	    int salt_len = crypt_salt_len[method];
+	    int header_len;
 
-	    crypt_push_state();
-	    use_crypt_method = method;
-	    if (method == 0)
-		crypt_init_keys(cryptkey);
-	    else
-	    {
-		bf_key_init(cryptkey, ptr + CRYPT_MAGIC_LEN, salt_len);
-		bf_ofb_init(ptr + CRYPT_MAGIC_LEN + salt_len, seed_len);
-	    }
+	    curbuf->b_cryptstate = crypt_create_from_header(
+						       method, cryptkey, ptr);
+	    crypt_set_cm_option(curbuf, method);
+
+	    /* Remove cryptmethod specific header from the text. */
+	    header_len = crypt_get_header_len(method);
+	    *filesizep += header_len;
+	    *sizep -= header_len;
+	    mch_memmove(ptr, ptr + header_len, (size_t)*sizep);
 
-	    /* Remove magic number from the text */
-	    *filesizep += CRYPT_MAGIC_LEN + salt_len + seed_len;
-	    *sizep -= CRYPT_MAGIC_LEN + salt_len + seed_len;
-	    mch_memmove(ptr, ptr + CRYPT_MAGIC_LEN + salt_len + seed_len,
-							      (size_t)*sizep);
+	    /* Restore the read-only flag. */
+	    curbuf->b_p_ro = b_p_ro;
 	}
     }
     /* When starting to edit a new file which does not have encryption, clear
@@ -2986,85 +2996,6 @@
 
     return cryptkey;
 }
-
-/*
- * Check for magic number used for encryption.  Applies to the current buffer.
- * If found and decryption is possible returns OK;
- */
-    int
-prepare_crypt_read(fp)
-    FILE	*fp;
-{
-    int		method;
-    char_u	buffer[CRYPT_MAGIC_LEN + CRYPT_SALT_LEN_MAX
-						    + CRYPT_SEED_LEN_MAX + 2];
-
-    if (fread(buffer, CRYPT_MAGIC_LEN, 1, fp) != 1)
-	return FAIL;
-    method = crypt_method_from_magic((char *)buffer,
-					CRYPT_MAGIC_LEN +
-					CRYPT_SEED_LEN_MAX +
-					CRYPT_SALT_LEN_MAX);
-    if (method < 0 || method != get_crypt_method(curbuf))
-	return FAIL;
-
-    crypt_push_state();
-    if (method == 0)
-	crypt_init_keys(curbuf->b_p_key);
-    else
-    {
-	int salt_len = crypt_salt_len[method];
-	int seed_len = crypt_seed_len[method];
-
-	if (fread(buffer, salt_len + seed_len, 1, fp) != 1)
-	    return FAIL;
-	bf_key_init(curbuf->b_p_key, buffer, salt_len);
-	bf_ofb_init(buffer + salt_len, seed_len);
-    }
-    return OK;
-}
-
-/*
- * Prepare for writing encrypted bytes for buffer "buf".
- * Returns a pointer to an allocated header of length "*lenp".
- * When out of memory returns NULL.
- * Otherwise calls crypt_push_state(), call crypt_pop_state() later.
- */
-    char_u *
-prepare_crypt_write(buf, lenp)
-    buf_T *buf;
-    int   *lenp;
-{
-    char_u  *header;
-    int	    seed_len = crypt_seed_len[get_crypt_method(buf)];
-    int     salt_len = crypt_salt_len[get_crypt_method(buf)];
-    char_u  *salt;
-    char_u  *seed;
-
-    header = alloc_clear(CRYPT_MAGIC_LEN + CRYPT_SALT_LEN_MAX
-						    + CRYPT_SEED_LEN_MAX + 2);
-    if (header != NULL)
-    {
-	crypt_push_state();
-	use_crypt_method = get_crypt_method(buf);  /* select zip or blowfish */
-	vim_strncpy(header, (char_u *)crypt_magic[use_crypt_method],
-							     CRYPT_MAGIC_LEN);
-	if (use_crypt_method == 0)
-	    crypt_init_keys(buf->b_p_key);
-	else
-	{
-	    /* Using blowfish, add salt and seed. */
-	    salt = header + CRYPT_MAGIC_LEN;
-	    seed = salt + salt_len;
-	    sha2_seed(salt, salt_len, seed, seed_len);
-	    bf_key_init(buf->b_p_key, salt, salt_len);
-	    bf_ofb_init(seed, seed_len);
-	}
-    }
-    *lenp = CRYPT_MAGIC_LEN + salt_len + seed_len;
-    return header;
-}
-
 #endif  /* FEAT_CRYPT */
 
 #ifdef UNIX
@@ -3218,9 +3149,7 @@
     int		    write_undo_file = FALSE;
     context_sha256_T sha_ctx;
 #endif
-#ifdef FEAT_CRYPT
-    int		    crypt_method_used;
-#endif
+    unsigned int    bkc = get_bkc_value(buf);
 
     if (fname == NULL || *fname == NUL)	/* safety check */
 	return FAIL;
@@ -3256,6 +3185,9 @@
     write_info.bw_iconv_fd = (iconv_t)-1;
 # endif
 #endif
+#ifdef FEAT_CRYPT
+    write_info.bw_buffer = buf;
+#endif
 
     /* After writing a file changedtick changes but we don't want to display
      * the line. */
@@ -3716,10 +3648,10 @@
 	struct stat st;
 #endif
 
-	if ((bkc_flags & BKC_YES) || append)	/* "yes" */
+	if ((bkc & BKC_YES) || append)	/* "yes" */
 	    backup_copy = TRUE;
 #if defined(UNIX) || defined(WIN32)
-	else if ((bkc_flags & BKC_AUTO))	/* "auto" */
+	else if ((bkc & BKC_AUTO))	/* "auto" */
 	{
 	    int		i;
 
@@ -3807,7 +3739,7 @@
 	/*
 	 * Break symlinks and/or hardlinks if we've been asked to.
 	 */
-	if ((bkc_flags & BKC_BREAKSYMLINK) || (bkc_flags & BKC_BREAKHARDLINK))
+	if ((bkc & BKC_BREAKSYMLINK) || (bkc & BKC_BREAKHARDLINK))
 	{
 # ifdef UNIX
 	    int	lstat_res;
@@ -3815,24 +3747,24 @@
 	    lstat_res = mch_lstat((char *)fname, &st);
 
 	    /* Symlinks. */
-	    if ((bkc_flags & BKC_BREAKSYMLINK)
+	    if ((bkc & BKC_BREAKSYMLINK)
 		    && lstat_res == 0
 		    && st.st_ino != st_old.st_ino)
 		backup_copy = FALSE;
 
 	    /* Hardlinks. */
-	    if ((bkc_flags & BKC_BREAKHARDLINK)
+	    if ((bkc & BKC_BREAKHARDLINK)
 		    && st_old.st_nlink > 1
 		    && (lstat_res != 0 || st.st_ino == st_old.st_ino))
 		backup_copy = FALSE;
 # else
 #  if defined(WIN32)
 	    /* Symlinks. */
-	    if ((bkc_flags & BKC_BREAKSYMLINK) && mch_is_symbolic_link(fname))
+	    if ((bkc & BKC_BREAKSYMLINK) && mch_is_symbolic_link(fname))
 		backup_copy = FALSE;
 
 	    /* Hardlinks. */
-	    if ((bkc_flags & BKC_BREAKHARDLINK) && mch_is_hard_link(fname))
+	    if ((bkc & BKC_BREAKHARDLINK) && mch_is_hard_link(fname))
 		backup_copy = FALSE;
 #  endif
 # endif
@@ -4024,7 +3956,7 @@
 						)
 			    mch_setperm(backup,
 					  (perm & 0707) | ((perm & 07) << 3));
-# ifdef HAVE_SELINUX
+# if defined(HAVE_SELINUX) || defined(HAVE_SMACK)
 			mch_copy_sec(fname, backup);
 # endif
 #endif
@@ -4063,7 +3995,7 @@
 #ifdef HAVE_ACL
 			mch_set_acl(backup, acl);
 #endif
-#ifdef HAVE_SELINUX
+#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)
 			mch_copy_sec(fname, backup);
 #endif
 			break;
@@ -4499,17 +4431,17 @@
 #ifdef FEAT_CRYPT
     if (*buf->b_p_key != NUL && !filtering)
     {
-	char_u *header;
-	int    header_len;
+	char_u		*header;
+	int		header_len;
 
-	header = prepare_crypt_write(buf, &header_len);
-	if (header == NULL)
+	buf->b_cryptstate = crypt_create_for_writing(crypt_get_method_nr(buf),
+					  buf->b_p_key, &header, &header_len);
+	if (buf->b_cryptstate == NULL || header == NULL)
 	    end = 0;
 	else
 	{
-	    /* Write magic number, so that Vim knows that this file is
-	     * encrypted when reading it again.  This also undergoes utf-8 to
-	     * ucs-2/4 conversion when needed. */
+	    /* Write magic number, so that Vim knows how this file is
+	     * encrypted when reading it back. */
 	    write_info.bw_buf = header;
 	    write_info.bw_len = header_len;
 	    write_info.bw_flags = FIO_NOCONVERT;
@@ -4712,7 +4644,7 @@
     }
 #endif
 
-#ifdef HAVE_SELINUX
+#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)
     /* Probably need to set the security context. */
     if (!backup_copy)
 	mch_copy_sec(backup, wfname);
@@ -4763,12 +4695,13 @@
 	mch_set_acl(wfname, acl);
 #endif
 #ifdef FEAT_CRYPT
-    crypt_method_used = use_crypt_method;
-    if (wb_flags & FIO_ENCRYPTED)
-	crypt_pop_state();
+    if (buf->b_cryptstate != NULL)
+    {
+	crypt_free_state(buf->b_cryptstate);
+	buf->b_cryptstate = NULL;
+    }
 #endif
 
-
 #if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
     if (wfname != fname)
     {
@@ -4918,10 +4851,7 @@
 #ifdef FEAT_CRYPT
 	if (wb_flags & FIO_ENCRYPTED)
 	{
-	    if (crypt_method_used == 1)
-		STRCAT(IObuff, _("[blowfish]"));
-	    else
-		STRCAT(IObuff, _("[crypted]"));
+	    crypt_append_msg(buf);
 	    c = TRUE;
 	}
 #endif
@@ -5288,7 +5218,7 @@
     if (shortmess(SHM_LINES))
 	sprintf((char *)p,
 #ifdef LONG_LONG_OFF_T
-		"%ldL, %lldC", lnum, nchars
+		"%ldL, %lldC", lnum, (long long)nchars
 #else
 		/* Explicit typecast avoids warning on Mac OS X 10.6 */
 		"%ldL, %ldC", lnum, (long)nchars
@@ -5306,7 +5236,7 @@
 	else
 	    sprintf((char *)p,
 #ifdef LONG_LONG_OFF_T
-		    _("%lld characters"), nchars
+		    _("%lld characters"), (long long)nchars
 #else
 		    /* Explicit typecast avoids warning on Mac OS X 10.6 */
 		    _("%ld characters"), (long)nchars
@@ -5734,8 +5664,26 @@
 #endif /* FEAT_MBYTE */
 
 #ifdef FEAT_CRYPT
-    if (flags & FIO_ENCRYPTED)		/* encrypt the data */
-	crypt_encode(buf, len, buf);
+    if (flags & FIO_ENCRYPTED)
+    {
+	/* Encrypt the data. Do it in-place if possible, otherwise use an
+	 * allocated buffer. */
+	if (crypt_works_inplace(ip->bw_buffer->b_cryptstate))
+	{
+	    crypt_encode_inplace(ip->bw_buffer->b_cryptstate, buf, len);
+	}
+	else
+	{
+	    char_u *outbuf;
+
+	    len = crypt_encode_alloc(curbuf->b_cryptstate, buf, len, &outbuf);
+	    if (len == 0)
+		return OK;  /* Crypt layer is buffering, will flush later. */
+	    wlen = write_eintr(ip->bw_fd, outbuf, len);
+	    vim_free(outbuf);
+	    return (wlen < len) ? FAIL : OK;
+	}
+    }
 #endif
 
     wlen = write_eintr(ip->bw_fd, buf, len);
@@ -6701,6 +6649,9 @@
     mch_set_acl(to, acl);
     mch_free_acl(acl);
 #endif
+#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)
+    mch_copy_sec(from, to);
+#endif
     if (errmsg != NULL)
     {
 	EMSG2(errmsg, to);
@@ -6888,6 +6839,7 @@
 	    && buf->b_mtime != 0
 	    && ((stat_res = mch_stat((char *)buf->b_ffname, &st)) < 0
 		|| time_differs((long)st.st_mtime, buf->b_mtime)
+		|| st.st_size != buf->b_orig_size
 #ifdef HAVE_ST_MODE
 		|| (int)st.st_mode != buf->b_orig_mode
 #else
@@ -7550,7 +7502,7 @@
     p = (char_u *)tempnam("tmp:", (char *)itmp);
     if (p != NULL)
     {
-	/* VMS will use '.LOG' if we don't explicitly specify an extension,
+	/* VMS will use '.LIS' if we don't explicitly specify an extension,
 	 * and VIM will then be unable to find the file later */
 	STRCPY(itmp, p);
 	STRCAT(itmp, ".txt");
@@ -7690,6 +7642,7 @@
     {"BufWriteCmd",	EVENT_BUFWRITECMD},
     {"CmdwinEnter",	EVENT_CMDWINENTER},
     {"CmdwinLeave",	EVENT_CMDWINLEAVE},
+    {"CmdUndefined",	EVENT_CMDUNDEFINED},
     {"ColorScheme",	EVENT_COLORSCHEME},
     {"CompleteDone",	EVENT_COMPLETEDONE},
     {"CursorHold",	EVENT_CURSORHOLD},
@@ -9057,6 +9010,9 @@
 
 	    curwin = aco->save_curwin;
 	    curbuf = curwin->w_buffer;
+	    /* In case the autocommand move the cursor to a position that that
+	     * not exist in curbuf. */
+	    check_cursor();
 	}
     }
 }
@@ -9208,6 +9164,24 @@
     return (first_autopat[(int)EVENT_INSERTCHARPRE] != NULL);
 }
 
+/*
+ * Return TRUE when there is an CmdUndefined autocommand defined.
+ */
+    int
+has_cmdundefined()
+{
+    return (first_autopat[(int)EVENT_CMDUNDEFINED] != NULL);
+}
+
+/*
+ * Return TRUE when there is an FuncUndefined autocommand defined.
+ */
+    int
+has_funcundefined()
+{
+    return (first_autopat[(int)EVENT_FUNCUNDEFINED] != NULL);
+}
+
     static int
 apply_autocmds_group(event, fname, fname_io, force, group, buf, eap)
     event_T	event;
@@ -9321,7 +9295,9 @@
      */
     if (fname_io == NULL)
     {
-	if (fname != NULL && *fname != NUL)
+	if (event == EVENT_COLORSCHEME)
+	    autocmd_fname = NULL;
+	else if (fname != NULL && *fname != NUL)
 	    autocmd_fname = fname;
 	else if (buf != NULL)
 	    autocmd_fname = buf->b_ffname;
@@ -9374,14 +9350,15 @@
     else
     {
 	sfname = vim_strsave(fname);
-	/* Don't try expanding FileType, Syntax, FuncUndefined, WindowID or
-	 * QuickFixCmd* */
+	/* Don't try expanding FileType, Syntax, FuncUndefined, WindowID,
+	 * ColorScheme or QuickFixCmd* */
 	if (event == EVENT_FILETYPE
 		|| event == EVENT_SYNTAX
 		|| event == EVENT_FUNCUNDEFINED
 		|| event == EVENT_REMOTEREPLY
 		|| event == EVENT_SPELLFILEMISSING
 		|| event == EVENT_QUICKFIXCMDPRE
+		|| event == EVENT_COLORSCHEME
 		|| event == EVENT_QUICKFIXCMDPOST)
 	    fname = vim_strsave(fname);
 	else
@@ -9536,13 +9513,26 @@
 
     /*
      * When stopping to execute autocommands, restore the search patterns and
-     * the redo buffer.
+     * the redo buffer.  Free any buffers in the au_pending_free_buf list and
+     * free any windows in the au_pending_free_win list.
      */
     if (!autocmd_busy)
     {
 	restore_search_patterns();
 	restoreRedobuff();
 	did_filetype = FALSE;
+	while (au_pending_free_buf != NULL)
+	{
+	    buf_T *b = au_pending_free_buf->b_next;
+	    vim_free(au_pending_free_buf);
+	    au_pending_free_buf = b;
+	}
+	while (au_pending_free_win != NULL)
+	{
+	    win_T *w = au_pending_free_win->w_next;
+	    vim_free(au_pending_free_win);
+	    au_pending_free_win = w;
+	}
     }
 
     /*
diff -Naur vim74.orig/src/fold.c vim74/src/fold.c
--- vim74.orig/src/fold.c	2013-06-15 14:57:24.000000000 +0000
+++ vim74/src/fold.c	2014-10-10 14:53:44.395380422 +0000
@@ -430,11 +430,9 @@
     }
     if (done == DONE_NOTHING)
 	EMSG(_(e_nofold));
-#ifdef FEAT_VISUAL
     /* Force a redraw to remove the Visual highlighting. */
     if (had_visual)
 	redraw_curbuf_later(INVERTED);
-#endif
 }
 
 /* openFold() {{{2 */
@@ -807,11 +805,9 @@
     if (!did_one)
     {
 	EMSG(_(e_nofold));
-#ifdef FEAT_VISUAL
 	/* Force a redraw to remove the Visual highlighting. */
 	if (had_visual)
 	    redraw_curbuf_later(INVERTED);
-#endif
     }
     else
 	/* Deleting markers may make cursor column invalid. */
@@ -1065,7 +1061,6 @@
 }
 
 /* foldAdjustVisual() {{{2 */
-#ifdef FEAT_VISUAL
 /*
  * Adjust the Visual area to include any fold at the start or end completely.
  */
@@ -1103,7 +1098,6 @@
 #endif
     }
 }
-#endif
 
 /* cursor_foldstart() {{{2 */
 /*
@@ -3052,7 +3046,7 @@
 	    flp->lvl = -1;
     }
     else
-	flp->lvl = get_indent_buf(buf, lnum) / get_sw_value();
+	flp->lvl = get_indent_buf(buf, lnum) / get_sw_value(curbuf);
     if (flp->lvl > flp->wp->w_p_fdn)
     {
 	flp->lvl = flp->wp->w_p_fdn;
diff -Naur vim74.orig/src/getchar.c vim74/src/getchar.c
--- vim74.orig/src/getchar.c	2013-06-29 11:43:27.000000000 +0000
+++ vim74/src/getchar.c	2014-10-10 14:53:44.398713746 +0000
@@ -40,13 +40,13 @@
 
 #define MINIMAL_SIZE 20			/* minimal size for b_str */
 
-static struct buffheader redobuff = {{NULL, {NUL}}, NULL, 0, 0};
-static struct buffheader old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
+static buffheader_T redobuff = {{NULL, {NUL}}, NULL, 0, 0};
+static buffheader_T old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
 #if defined(FEAT_AUTOCMD) || defined(FEAT_EVAL) || defined(PROTO)
-static struct buffheader save_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
-static struct buffheader save_old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
+static buffheader_T save_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
+static buffheader_T save_old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
 #endif
-static struct buffheader recordbuff = {{NULL, {NUL}}, NULL, 0, 0};
+static buffheader_T recordbuff = {{NULL, {NUL}}, NULL, 0, 0};
 
 static int typeahead_char = 0;		/* typeahead char that's not flushed */
 
@@ -112,11 +112,12 @@
 
 static int	last_recorded_len = 0;	/* number of last recorded chars */
 
-static char_u	*get_buffcont __ARGS((struct buffheader *, int));
-static void	add_buff __ARGS((struct buffheader *, char_u *, long n));
-static void	add_num_buff __ARGS((struct buffheader *, long));
-static void	add_char_buff __ARGS((struct buffheader *, int));
-static int	read_stuff __ARGS((int advance));
+static char_u	*get_buffcont __ARGS((buffheader_T *, int));
+static void	add_buff __ARGS((buffheader_T *, char_u *, long n));
+static void	add_num_buff __ARGS((buffheader_T *, long));
+static void	add_char_buff __ARGS((buffheader_T *, int));
+static int	read_readbuffers __ARGS((int advance));
+static int	read_readbuf __ARGS((buffheader_T *buf, int advance));
 static void	start_stuff __ARGS((void));
 static int	read_redo __ARGS((int, int));
 static void	copy_redo __ARGS((int));
@@ -137,9 +138,9 @@
  */
     void
 free_buff(buf)
-    struct buffheader	*buf;
+    buffheader_T	*buf;
 {
-    struct buffblock	*p, *np;
+    buffblock_T	*p, *np;
 
     for (p = buf->bh_first.b_next; p != NULL; p = np)
     {
@@ -155,14 +156,14 @@
  */
     static char_u *
 get_buffcont(buffer, dozero)
-    struct buffheader	*buffer;
+    buffheader_T	*buffer;
     int			dozero;	    /* count == zero is not an error */
 {
     long_u	    count = 0;
     char_u	    *p = NULL;
     char_u	    *p2;
     char_u	    *str;
-    struct buffblock *bp;
+    buffblock_T *bp;
 
     /* compute the total length of the string */
     for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
@@ -230,11 +231,11 @@
  */
     static void
 add_buff(buf, s, slen)
-    struct buffheader	*buf;
+    buffheader_T	*buf;
     char_u		*s;
     long		slen;	/* length of "s" or -1 */
 {
-    struct buffblock *p;
+    buffblock_T *p;
     long_u	    len;
 
     if (slen < 0)
@@ -270,7 +271,7 @@
 	    len = MINIMAL_SIZE;
 	else
 	    len = slen;
-	p = (struct buffblock *)lalloc((long_u)(sizeof(struct buffblock) + len),
+	p = (buffblock_T *)lalloc((long_u)(sizeof(buffblock_T) + len),
 									TRUE);
 	if (p == NULL)
 	    return; /* no space, just forget it */
@@ -289,7 +290,7 @@
  */
     static void
 add_num_buff(buf, n)
-    struct buffheader *buf;
+    buffheader_T *buf;
     long	      n;
 {
     char_u	number[32];
@@ -304,7 +305,7 @@
  */
     static void
 add_char_buff(buf, c)
-    struct buffheader	*buf;
+    buffheader_T	*buf;
     int			c;
 {
 #ifdef FEAT_MBYTE
@@ -354,46 +355,71 @@
 #endif
 }
 
+/* First read ahead buffer. Used for translated commands. */
+static buffheader_T readbuf1 = {{NULL, {NUL}}, NULL, 0, 0};
+
+/* Second read ahead buffer. Used for redo. */
+static buffheader_T readbuf2 = {{NULL, {NUL}}, NULL, 0, 0};
+
 /*
- * Get one byte from the stuff buffer.
+ * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2
+ * if that one is empty.
  * If advance == TRUE go to the next char.
  * No translation is done K_SPECIAL and CSI are escaped.
  */
     static int
-read_stuff(advance)
+read_readbuffers(advance)
     int		advance;
 {
-    char_u		c;
-    struct buffblock	*curr;
+    int c;
+
+    c = read_readbuf(&readbuf1, advance);
+    if (c == NUL)
+	c = read_readbuf(&readbuf2, advance);
+    return c;
+}
+
+    static int
+read_readbuf(buf, advance)
+    buffheader_T    *buf;
+    int		    advance;
+{
+    char_u	c;
+    buffblock_T	*curr;
 
-    if (stuffbuff.bh_first.b_next == NULL)  /* buffer is empty */
+    if (buf->bh_first.b_next == NULL)  /* buffer is empty */
 	return NUL;
 
-    curr = stuffbuff.bh_first.b_next;
-    c = curr->b_str[stuffbuff.bh_index];
+    curr = buf->bh_first.b_next;
+    c = curr->b_str[buf->bh_index];
 
     if (advance)
     {
-	if (curr->b_str[++stuffbuff.bh_index] == NUL)
+	if (curr->b_str[++buf->bh_index] == NUL)
 	{
-	    stuffbuff.bh_first.b_next = curr->b_next;
+	    buf->bh_first.b_next = curr->b_next;
 	    vim_free(curr);
-	    stuffbuff.bh_index = 0;
+	    buf->bh_index = 0;
 	}
     }
     return c;
 }
 
 /*
- * Prepare the stuff buffer for reading (if it contains something).
+ * Prepare the read buffers for reading (if they contain something).
  */
     static void
 start_stuff()
 {
-    if (stuffbuff.bh_first.b_next != NULL)
+    if (readbuf1.bh_first.b_next != NULL)
     {
-	stuffbuff.bh_curr = &(stuffbuff.bh_first);
-	stuffbuff.bh_space = 0;
+	readbuf1.bh_curr = &(readbuf1.bh_first);
+	readbuf1.bh_space = 0;
+    }
+    if (readbuf2.bh_first.b_next != NULL)
+    {
+	readbuf2.bh_curr = &(readbuf2.bh_first);
+	readbuf2.bh_space = 0;
     }
 }
 
@@ -403,7 +429,18 @@
     int
 stuff_empty()
 {
-    return (stuffbuff.bh_first.b_next == NULL);
+    return (readbuf1.bh_first.b_next == NULL
+	 && readbuf2.bh_first.b_next == NULL);
+}
+
+/*
+ * Return TRUE if readbuf1 is empty.  There may still be redo characters in
+ * redbuf2.
+ */
+    int
+readbuf1_empty()
+{
+    return (readbuf1.bh_first.b_next == NULL);
 }
 
 /*
@@ -428,7 +465,7 @@
     init_typebuf();
 
     start_stuff();
-    while (read_stuff(TRUE) != NUL)
+    while (read_readbuffers(TRUE) != NUL)
 	;
 
     if (flush_typeahead)	    /* remove all typeahead */
@@ -483,7 +520,7 @@
 	redobuff = old_redobuff;
 	old_redobuff.bh_first.b_next = NULL;
 	start_stuff();
-	while (read_stuff(TRUE) != NUL)
+	while (read_readbuffers(TRUE) != NUL)
 	    ;
     }
 }
@@ -638,7 +675,18 @@
 stuffReadbuff(s)
     char_u	*s;
 {
-    add_buff(&stuffbuff, s, -1L);
+    add_buff(&readbuf1, s, -1L);
+}
+
+/*
+ * Append string "s" to the redo stuff buffer.
+ * CSI and K_SPECIAL must already have been escaped.
+ */
+    void
+stuffRedoReadbuff(s)
+    char_u	*s;
+{
+    add_buff(&readbuf2, s, -1L);
 }
 
     void
@@ -646,7 +694,7 @@
     char_u	*s;
     long	len;
 {
-    add_buff(&stuffbuff, s, len);
+    add_buff(&readbuf1, s, len);
 }
 
 #if defined(FEAT_EVAL) || defined(PROTO)
@@ -692,7 +740,7 @@
 stuffcharReadbuff(c)
     int		   c;
 {
-    add_char_buff(&stuffbuff, c);
+    add_char_buff(&readbuf1, c);
 }
 
 /*
@@ -702,7 +750,7 @@
 stuffnumReadbuff(n)
     long    n;
 {
-    add_num_buff(&stuffbuff, n);
+    add_num_buff(&readbuf1, n);
 }
 
 /*
@@ -718,13 +766,13 @@
     int		init;
     int		old_redo;
 {
-    static struct buffblock	*bp;
-    static char_u		*p;
-    int				c;
+    static buffblock_T	*bp;
+    static char_u	*p;
+    int			c;
 #ifdef FEAT_MBYTE
-    int				n;
-    char_u			buf[MB_MAXBYTES + 1];
-    int				i;
+    int			n;
+    char_u		buf[MB_MAXBYTES + 1];
+    int			i;
 #endif
 
     if (init)
@@ -795,11 +843,11 @@
     int	    c;
 
     while ((c = read_redo(FALSE, old_redo)) != NUL)
-	stuffcharReadbuff(c);
+	add_char_buff(&readbuf2, c);
 }
 
 /*
- * Stuff the redo buffer into the stuffbuff.
+ * Stuff the redo buffer into readbuf2.
  * Insert the redo count into the command.
  * If "old_redo" is TRUE, the last but one command is repeated
  * instead of the last command (inserting text). This is used for
@@ -823,17 +871,16 @@
     /* copy the buffer name, if present */
     if (c == '"')
     {
-	add_buff(&stuffbuff, (char_u *)"\"", 1L);
+	add_buff(&readbuf2, (char_u *)"\"", 1L);
 	c = read_redo(FALSE, old_redo);
 
 	/* if a numbered buffer is used, increment the number */
 	if (c >= '1' && c < '9')
 	    ++c;
-	add_char_buff(&stuffbuff, c);
+	add_char_buff(&readbuf2, c);
 	c = read_redo(FALSE, old_redo);
     }
 
-#ifdef FEAT_VISUAL
     if (c == 'v')   /* redo Visual */
     {
 	VIsual = curwin->w_cursor;
@@ -843,25 +890,24 @@
 	redo_VIsual_busy = TRUE;
 	c = read_redo(FALSE, old_redo);
     }
-#endif
 
     /* try to enter the count (in place of a previous count) */
     if (count)
     {
 	while (VIM_ISDIGIT(c))	/* skip "old" count */
 	    c = read_redo(FALSE, old_redo);
-	add_num_buff(&stuffbuff, count);
+	add_num_buff(&readbuf2, count);
     }
 
     /* copy from the redo buffer into the stuff buffer */
-    add_char_buff(&stuffbuff, c);
+    add_char_buff(&readbuf2, c);
     copy_redo(old_redo);
     return OK;
 }
 
 /*
  * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing
- * the redo buffer into the stuffbuff.
+ * the redo buffer into readbuf2.
  * return FAIL for failure, OK otherwise
  */
     int
@@ -879,7 +925,7 @@
 	if (vim_strchr((char_u *)"AaIiRrOo", c) != NULL)
 	{
 	    if (c == 'O' || c == 'o')
-		stuffReadbuff(NL_STR);
+		add_buff(&readbuf2, NL_STR, -1L);
 	    break;
 	}
     }
@@ -1125,7 +1171,6 @@
     return typebuf.tb_maplen == 0;
 }
 
-#if defined(FEAT_VISUAL) || defined(PROTO)
 /*
  * Return the number of characters that are mapped (or not typed).
  */
@@ -1134,7 +1179,6 @@
 {
     return typebuf.tb_maplen;
 }
-#endif
 
 /*
  * remove "len" characters from typebuf.tb_buf[typebuf.tb_off + offset]
@@ -1360,8 +1404,10 @@
     tp->old_mod_mask = old_mod_mask;
     old_char = -1;
 
-    tp->save_stuffbuff = stuffbuff;
-    stuffbuff.bh_first.b_next = NULL;
+    tp->save_readbuf1 = readbuf1;
+    readbuf1.bh_first.b_next = NULL;
+    tp->save_readbuf2 = readbuf2;
+    readbuf2.bh_first.b_next = NULL;
 # ifdef USE_INPUT_BUF
     tp->save_inputbuf = get_input_buf();
 # endif
@@ -1384,8 +1430,10 @@
     old_char = tp->old_char;
     old_mod_mask = tp->old_mod_mask;
 
-    free_buff(&stuffbuff);
-    stuffbuff = tp->save_stuffbuff;
+    free_buff(&readbuf1);
+    readbuf1 = tp->save_readbuf1;
+    free_buff(&readbuf2);
+    readbuf2 = tp->save_readbuf2;
 # ifdef USE_INPUT_BUF
     set_input_buf(tp->save_inputbuf);
 # endif
@@ -1846,7 +1894,7 @@
 }
 #endif
 
-#if defined(FEAT_INS_EXPAND) || defined(PROTO)
+#if defined(FEAT_INS_EXPAND) || defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Check if any character is available, also half an escape sequence.
  * Trick: when no typeahead found, but there is something in the typeahead
@@ -1992,7 +2040,7 @@
 		typeahead_char = 0;
 	}
 	else
-	    c = read_stuff(advance);
+	    c = read_readbuffers(advance);
 	if (c != NUL && !got_int)
 	{
 	    if (advance)
@@ -2165,10 +2213,16 @@
 #ifdef FEAT_MBYTE
 				/* Don't allow mapping the first byte(s) of a
 				 * multi-byte char.  Happens when mapping
-				 * <M-a> and then changing 'encoding'. */
-				if (has_mbyte && MB_BYTE2LEN(c1)
-						  > (*mb_ptr2len)(mp->m_keys))
-				    mlen = 0;
+				 * <M-a> and then changing 'encoding'. Beware
+				 * that 0x80 is escaped. */
+				{
+				    char_u *p1 = mp->m_keys;
+				    char_u *p2 = mb_unescape(&p1);
+
+				    if (has_mbyte && p2 != NULL
+					  && MB_BYTE2LEN(c1) > MB_PTR2LEN(p2))
+					mlen = 0;
+				}
 #endif
 				/*
 				 * Check an entry whether it matches.
@@ -2261,6 +2315,10 @@
 				msg_row = Rows - 1;
 				msg_clr_eos();		/* clear ruler */
 			    }
+#ifdef FEAT_WINDOWS
+			    status_redraw_all();
+			    redraw_statuslines();
+#endif
 			    showmode();
 			    setcursor();
 			    continue;
@@ -2392,7 +2450,6 @@
 				idx = get_menu_index(current_menu, local_State);
 				if (idx != MENU_INDEX_INVALID)
 				{
-# ifdef FEAT_VISUAL
 				    /*
 				     * In Select mode and a Visual mode menu
 				     * is used:  Switch to Visual mode
@@ -2406,7 +2463,6 @@
 					(void)ins_typebuf(K_SELECT_STRING,
 						  REMAP_NONE, 0, TRUE, FALSE);
 				    }
-# endif
 				    ins_typebuf(current_menu->strings[idx],
 						current_menu->noremap[idx],
 						0, TRUE,
@@ -2465,7 +2521,6 @@
 			    break;
 			}
 
-#ifdef FEAT_VISUAL
 			/*
 			 * In Select mode and a Visual mode mapping is used:
 			 * Switch to Visual mode temporarily.  Append K_SELECT
@@ -2478,7 +2533,6 @@
 			    (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,
 							      0, TRUE, FALSE);
 			}
-#endif
 
 #ifdef FEAT_EVAL
 			/* Copy the values from *mp that are used, because
@@ -2632,7 +2686,7 @@
 				{
 				    if (!vim_iswhite(ptr[col]))
 					curwin->w_wcol = vcol;
-				    vcol += lbr_chartabsize(ptr + col,
+				    vcol += lbr_chartabsize(ptr, ptr + col,
 							       (colnr_T)vcol);
 #ifdef FEAT_MBYTE
 				    if (has_mbyte)
@@ -2688,6 +2742,11 @@
 		}
 		if (c < 0)
 		    continue;	/* end of input script reached */
+
+		/* Allow mapping for just typed characters. When we get here c
+		 * is the number of extra bytes and typebuf.tb_len is 1. */
+		for (n = 1; n <= c; ++n)
+		    typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;
 		typebuf.tb_len += c;
 
 		/* buffer full, don't map */
@@ -3648,6 +3707,9 @@
     {
 	if (!did_it)
 	    retval = 2;			    /* no match */
+	else if (*keys == Ctrl_C)
+	    /* If CTRL-C has been unmapped, reuse it for Interrupting. */
+	    mapped_ctrl_c = FALSE;
 	goto theend;
     }
 
@@ -3680,7 +3742,7 @@
 	goto theend;
     }
 
-    /* If CTRL-C has been mapped, don't always use it for Interrupting */
+    /* If CTRL-C has been mapped, don't always use it for Interrupting. */
     if (*keys == Ctrl_C)
 	mapped_ctrl_c = TRUE;
 
diff -Naur vim74.orig/src/globals.h vim74/src/globals.h
--- vim74.orig/src/globals.h	2013-07-04 17:53:44.000000000 +0000
+++ vim74/src/globals.h	2014-10-10 14:53:44.408713721 +0000
@@ -105,10 +105,6 @@
 
 EXTERN int	screen_cleared INIT(= FALSE);	/* screen has been cleared */
 
-#ifdef FEAT_CRYPT
-EXTERN int      use_crypt_method INIT(= 0);
-#endif
-
 /*
  * When '$' is included in 'cpoptions' option set:
  * When a change command is given that deletes only part of a line, a dollar
@@ -386,6 +382,13 @@
 /* When deleting the current buffer, another one must be loaded.  If we know
  * which one is preferred, au_new_curbuf is set to it */
 EXTERN buf_T	*au_new_curbuf INIT(= NULL);
+
+/* When deleting a buffer/window and autocmd_busy is TRUE, do not free the
+ * buffer/window. but link it in the list starting with
+ * au_pending_free_buf/ap_pending_free_win, using b_next/w_next.
+ * Free the buffer/window when autocmd_busy is being set to FALSE. */
+EXTERN buf_T	*au_pending_free_buf INIT(= NULL);
+EXTERN win_T	*au_pending_free_win INIT(= NULL);
 #endif
 
 #ifdef FEAT_MOUSE
@@ -526,6 +529,8 @@
 EXTERN int	clip_autoselectml INIT(= FALSE);
 EXTERN int	clip_html INIT(= FALSE);
 EXTERN regprog_T *clip_exclude_prog INIT(= NULL);
+EXTERN int	clip_did_set_selection INIT(= TRUE);
+EXTERN int	clip_unnamed_saved INIT(= 0);
 #endif
 
 /*
@@ -596,6 +601,7 @@
  * to this when the window is using the global argument list.
  */
 EXTERN alist_T	global_alist;	/* global argument list */
+EXTERN int	max_alist_id INIT(= 0);	    /* the previous argument list id */
 EXTERN int	arg_had_last INIT(= FALSE); /* accessed last file in
 					       global_alist */
 
@@ -662,7 +668,6 @@
 				/* set to TRUE when "-s" commandline argument
 				 * used for ex */
 
-#ifdef FEAT_VISUAL
 EXTERN pos_T	VIsual;		/* start position of active Visual selection */
 EXTERN int	VIsual_active INIT(= FALSE);
 				/* whether Visual mode is active */
@@ -677,7 +682,6 @@
 
 EXTERN int	redo_VIsual_busy INIT(= FALSE);
 				/* TRUE when redoing Visual */
-#endif
 
 #ifdef FEAT_MOUSE
 /*
@@ -752,6 +756,12 @@
  */
 EXTERN pos_T	Insstart;		/* This is where the latest
 					 * insert/append mode started. */
+
+/* This is where the latest insert/append mode started. In contrast to
+ * Insstart, this won't be reset by certain keys and is needed for
+ * op_insert(), to detect correctly where inserting by the user started. */
+EXTERN pos_T	Insstart_orig;
+
 #ifdef FEAT_VREPLACE
 /*
  * Stuff for VREPLACE mode.
@@ -979,11 +989,6 @@
 EXTERN int	readonlymode INIT(= FALSE); /* Set to TRUE for "view" */
 EXTERN int	recoverymode INIT(= FALSE); /* Set to TRUE for "-r" option */
 
-EXTERN struct buffheader stuffbuff	/* stuff buffer */
-#ifdef DO_INIT
-		    = {{NULL, {NUL}}, NULL, 0, 0}
-#endif
-		    ;
 EXTERN typebuf_T typebuf		/* typeahead buffer */
 #ifdef DO_INIT
 		    = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}
@@ -1177,11 +1182,9 @@
 EXTERN int	fill_diff INIT(= '-');
 #endif
 
-#ifdef FEAT_VISUAL
 /* Whether 'keymodel' contains "stopsel" and "startsel". */
 EXTERN int	km_stopsel INIT(= FALSE);
 EXTERN int	km_startsel INIT(= FALSE);
-#endif
 
 #ifdef FEAT_CMDWIN
 EXTERN int	cedit_key INIT(= -1);	/* key value of 'cedit' option */
@@ -1490,6 +1493,7 @@
 EXTERN char_u e_notopen[]	INIT(= N_("E484: Can't open file %s"));
 EXTERN char_u e_notread[]	INIT(= N_("E485: Can't read file %s"));
 EXTERN char_u e_nowrtmsg[]	INIT(= N_("E37: No write since last change (add ! to override)"));
+EXTERN char_u e_nowrtmsg_nobang[]   INIT(= N_("E37: No write since last change"));
 EXTERN char_u e_null[]		INIT(= N_("E38: Null argument"));
 #ifdef FEAT_DIGRAPHS
 EXTERN char_u e_number_exp[]	INIT(= N_("E39: Number expected"));
diff -Naur vim74.orig/src/gui.c vim74/src/gui.c
--- vim74.orig/src/gui.c	2013-06-30 15:41:48.000000000 +0000
+++ vim74/src/gui.c	2014-10-10 14:53:44.415380371 +0000
@@ -3132,11 +3132,9 @@
      */
     if (!mouse_has(checkfor) || checkfor == MOUSE_COMMAND)
     {
-#ifdef FEAT_VISUAL
 	/* Don't do modeless selection in Visual mode. */
 	if (checkfor != MOUSE_NONEF && VIsual_active && (State & NORMAL))
 	    return;
-#endif
 
 	/*
 	 * When 'mousemodel' is "popup", shift-left is translated to right.
diff -Naur vim74.orig/src/gui_beval.c vim74/src/gui_beval.c
--- vim74.orig/src/gui_beval.c	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/gui_beval.c	2014-10-10 14:53:44.432046996 +0000
@@ -1193,11 +1193,13 @@
 	    XmFontList fl;
 
 	    fl = gui_motif_fontset2fontlist(&gui.tooltip_fontset);
-	    if (fl != NULL)
+	    if (fl == NULL)
 	    {
-		XmStringExtent(fl, s, &w, &h);
-		XmFontListFree(fl);
+		XmStringFree(s);
+		return;
 	    }
+	    XmStringExtent(fl, s, &w, &h);
+	    XmFontListFree(fl);
 	}
 	w += gui.border_offset << 1;
 	h += gui.border_offset << 1;
diff -Naur vim74.orig/src/gui_dwrite.cpp vim74/src/gui_dwrite.cpp
--- vim74.orig/src/gui_dwrite.cpp	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/gui_dwrite.cpp	2014-10-10 14:53:44.435380321 +0000
@@ -0,0 +1,901 @@
+/* vi:set ts=8 sts=4 sw=4 noet: */
+/*
+ * Author: MURAOKA Taro <koron.kaoriya@gmail.com>
+ *
+ * Contributors:
+ *  - Ken Takata
+ *
+ * Copyright (C) 2013 MURAOKA Taro <koron.kaoriya@gmail.com>
+ * THIS FILE IS DISTRIBUTED UNDER THE VIM LICENSE.
+ */
+
+#define WIN32_LEAN_AND_MEAN
+
+#ifndef DYNAMIC_DIRECTX
+# if WINVER < 0x0600
+#  error WINVER must be 0x0600 or above to use DirectWrite(DirectX)
+# endif
+#endif
+
+#include <windows.h>
+#include <crtdbg.h>
+#include <assert.h>
+#include <math.h>
+#include <d2d1.h>
+#include <d2d1helper.h>
+#include <dwrite.h>
+
+#include "gui_dwrite.h"
+
+#ifdef __MINGW32__
+# define __maybenull	SAL__maybenull
+# define __in		SAL__in
+# define __out		SAL__out
+#endif
+
+#ifdef DYNAMIC_DIRECTX
+extern "C" HINSTANCE vimLoadLib(char *name);
+
+typedef int (WINAPI *PGETUSERDEFAULTLOCALENAME)(LPWSTR, int);
+typedef HRESULT (WINAPI *PD2D1CREATEFACTORY)(D2D1_FACTORY_TYPE,
+	REFIID, const D2D1_FACTORY_OPTIONS *, void **);
+typedef HRESULT (WINAPI *PDWRITECREATEFACTORY)(DWRITE_FACTORY_TYPE,
+	REFIID, IUnknown **);
+
+static HINSTANCE hD2D1DLL = NULL;
+static HINSTANCE hDWriteDLL = NULL;
+
+static PGETUSERDEFAULTLOCALENAME pGetUserDefaultLocaleName = NULL;
+static PD2D1CREATEFACTORY pD2D1CreateFactory = NULL;
+static PDWRITECREATEFACTORY pDWriteCreateFactory = NULL;
+
+#define GetUserDefaultLocaleName	(*pGetUserDefaultLocaleName)
+#define D2D1CreateFactory		(*pD2D1CreateFactory)
+#define DWriteCreateFactory		(*pDWriteCreateFactory)
+
+    static void
+unload(HINSTANCE &hinst)
+{
+    if (hinst != NULL)
+    {
+	FreeLibrary(hinst);
+	hinst = NULL;
+    }
+}
+#endif // DYNAMIC_DIRECTX
+
+template <class T> inline void SafeRelease(T **ppT)
+{
+    if (*ppT)
+    {
+	(*ppT)->Release();
+	*ppT = NULL;
+    }
+}
+
+struct GdiTextRendererContext
+{
+    // const fields.
+    COLORREF color;
+    FLOAT cellWidth;
+
+    // working fields.
+    FLOAT offsetX;
+};
+
+    static DWRITE_PIXEL_GEOMETRY
+ToPixelGeometry(int value)
+{
+    switch (value)
+    {
+	default:
+	case 0:
+	    return DWRITE_PIXEL_GEOMETRY_FLAT;
+	case 1:
+	    return DWRITE_PIXEL_GEOMETRY_RGB;
+	case 2:
+	    return DWRITE_PIXEL_GEOMETRY_BGR;
+    }
+}
+
+    static int
+ToInt(DWRITE_PIXEL_GEOMETRY value)
+{
+    switch (value)
+    {
+	case DWRITE_PIXEL_GEOMETRY_FLAT:
+	    return 0;
+	case DWRITE_PIXEL_GEOMETRY_RGB:
+	    return 1;
+	case DWRITE_PIXEL_GEOMETRY_BGR:
+	    return 2;
+	default:
+	    return -1;
+    }
+}
+
+    static DWRITE_RENDERING_MODE
+ToRenderingMode(int value)
+{
+    switch (value)
+    {
+	default:
+	case 0:
+	    return DWRITE_RENDERING_MODE_DEFAULT;
+	case 1:
+	    return DWRITE_RENDERING_MODE_ALIASED;
+	case 2:
+	    return DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC;
+	case 3:
+	    return DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL;
+	case 4:
+	    return DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL;
+	case 5:
+	    return DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC;
+	case 6:
+	    return DWRITE_RENDERING_MODE_OUTLINE;
+    }
+}
+
+    static D2D1_TEXT_ANTIALIAS_MODE
+ToTextAntialiasMode(int value)
+{
+    switch (value)
+    {
+	default:
+	case 0:
+	    return D2D1_TEXT_ANTIALIAS_MODE_DEFAULT;
+	case 1:
+	    return D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE;
+	case 2:
+	    return D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE;
+	case 3:
+	    return D2D1_TEXT_ANTIALIAS_MODE_ALIASED;
+    }
+}
+
+    static int
+ToInt(DWRITE_RENDERING_MODE value)
+{
+    switch (value)
+    {
+	case DWRITE_RENDERING_MODE_DEFAULT:
+	    return 0;
+	case DWRITE_RENDERING_MODE_ALIASED:
+	    return 1;
+	case DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC:
+	    return 2;
+	case DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL:
+	    return 3;
+	case DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL:
+	    return 4;
+	case DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC:
+	    return 5;
+	case DWRITE_RENDERING_MODE_OUTLINE:
+	    return 6;
+	default:
+	    return -1;
+    }
+}
+
+class AdjustedGlyphRun : public DWRITE_GLYPH_RUN
+{
+private:
+    FLOAT mDelta;
+    FLOAT *mAdjustedAdvances;
+
+public:
+    AdjustedGlyphRun(
+	    const DWRITE_GLYPH_RUN *glyphRun,
+	    FLOAT cellWidth) :
+	DWRITE_GLYPH_RUN(*glyphRun),
+	mDelta(0.0f),
+	mAdjustedAdvances(new FLOAT[glyphRun->glyphCount])
+    {
+	assert(cellWidth != 0.0f);
+	for (UINT32 i = 0; i < glyphRun->glyphCount; ++i)
+	{
+	    FLOAT orig = glyphRun->glyphAdvances[i];
+	    FLOAT adjusted = adjustToCell(orig, cellWidth);
+	    mAdjustedAdvances[i] = adjusted;
+	    mDelta += adjusted - orig;
+	}
+	glyphAdvances = mAdjustedAdvances;
+    }
+
+    ~AdjustedGlyphRun(void)
+    {
+	delete[] mAdjustedAdvances;
+    }
+
+    FLOAT getDelta(void) const
+    {
+	return mDelta;
+    }
+
+    static FLOAT adjustToCell(FLOAT value, FLOAT cellWidth)
+    {
+	int cellCount = (int)floor(value / cellWidth + 0.5f);
+	if (cellCount < 1)
+	    cellCount = 1;
+	return cellCount * cellWidth;
+    }
+};
+
+class GdiTextRenderer : public IDWriteTextRenderer
+{
+public:
+    GdiTextRenderer(
+	    IDWriteBitmapRenderTarget* bitmapRenderTarget,
+	    IDWriteRenderingParams* renderingParams) :
+	cRefCount_(0),
+	pRenderTarget_(bitmapRenderTarget),
+	pRenderingParams_(renderingParams)
+    {
+	pRenderTarget_->AddRef();
+	pRenderingParams_->AddRef();
+	AddRef();
+    }
+
+    ~GdiTextRenderer()
+    {
+	SafeRelease(&pRenderTarget_);
+	SafeRelease(&pRenderingParams_);
+    }
+
+    IFACEMETHOD(IsPixelSnappingDisabled)(
+	__maybenull void* clientDrawingContext,
+	__out BOOL* isDisabled)
+    {
+	*isDisabled = FALSE;
+	return S_OK;
+    }
+
+    IFACEMETHOD(GetCurrentTransform)(
+	__maybenull void* clientDrawingContext,
+	__out DWRITE_MATRIX* transform)
+    {
+	//forward the render target's transform
+	pRenderTarget_->GetCurrentTransform(transform);
+	return S_OK;
+    }
+
+    IFACEMETHOD(GetPixelsPerDip)(
+	__maybenull void* clientDrawingContext,
+	__out FLOAT* pixelsPerDip)
+    {
+	*pixelsPerDip = pRenderTarget_->GetPixelsPerDip();
+	return S_OK;
+    }
+
+    IFACEMETHOD(DrawGlyphRun)(
+	__maybenull void* clientDrawingContext,
+	FLOAT baselineOriginX,
+	FLOAT baselineOriginY,
+	DWRITE_MEASURING_MODE measuringMode,
+	__in DWRITE_GLYPH_RUN const* glyphRun,
+	__in DWRITE_GLYPH_RUN_DESCRIPTION const* glyphRunDescription,
+	IUnknown* clientDrawingEffect)
+    {
+	HRESULT hr = S_OK;
+
+	GdiTextRendererContext *context =
+	    reinterpret_cast<GdiTextRendererContext*>(clientDrawingContext);
+
+	AdjustedGlyphRun adjustedGlyphRun(glyphRun, context->cellWidth);
+
+	// Pass on the drawing call to the render target to do the real work.
+	RECT dirtyRect = {0};
+
+	hr = pRenderTarget_->DrawGlyphRun(
+		baselineOriginX + context->offsetX,
+		baselineOriginY,
+		measuringMode,
+		&adjustedGlyphRun,
+		pRenderingParams_,
+		context->color,
+		&dirtyRect);
+
+	context->offsetX += adjustedGlyphRun.getDelta();
+
+	return hr;
+    }
+
+    IFACEMETHOD(DrawUnderline)(
+	__maybenull void* clientDrawingContext,
+	FLOAT baselineOriginX,
+	FLOAT baselineOriginY,
+	__in DWRITE_UNDERLINE const* underline,
+	IUnknown* clientDrawingEffect)
+    {
+	return E_NOTIMPL;
+    }
+
+    IFACEMETHOD(DrawStrikethrough)(
+	__maybenull void* clientDrawingContext,
+	FLOAT baselineOriginX,
+	FLOAT baselineOriginY,
+	__in DWRITE_STRIKETHROUGH const* strikethrough,
+	IUnknown* clientDrawingEffect)
+    {
+	return E_NOTIMPL;
+    }
+
+    IFACEMETHOD(DrawInlineObject)(
+	__maybenull void* clientDrawingContext,
+	FLOAT originX,
+	FLOAT originY,
+	IDWriteInlineObject* inlineObject,
+	BOOL isSideways,
+	BOOL isRightToLeft,
+	IUnknown* clientDrawingEffect)
+    {
+	return E_NOTIMPL;
+    }
+
+public:
+    IFACEMETHOD_(unsigned long, AddRef) ()
+    {
+	return InterlockedIncrement(&cRefCount_);
+    }
+
+    IFACEMETHOD_(unsigned long, Release) ()
+    {
+	long newCount = InterlockedDecrement(&cRefCount_);
+
+	if (newCount == 0)
+	{
+	    delete this;
+	    return 0;
+	}
+	return newCount;
+    }
+
+    IFACEMETHOD(QueryInterface)(
+	IID const& riid,
+	void** ppvObject)
+    {
+	if (__uuidof(IDWriteTextRenderer) == riid)
+	{
+	    *ppvObject = this;
+	}
+	else if (__uuidof(IDWritePixelSnapping) == riid)
+	{
+	    *ppvObject = this;
+	}
+	else if (__uuidof(IUnknown) == riid)
+	{
+	    *ppvObject = this;
+	}
+	else
+	{
+	    *ppvObject = NULL;
+	    return E_FAIL;
+	}
+
+	return S_OK;
+    }
+
+private:
+    long cRefCount_;
+    IDWriteBitmapRenderTarget* pRenderTarget_;
+    IDWriteRenderingParams* pRenderingParams_;
+};
+
+struct DWriteContext {
+    FLOAT mDpiScaleX;
+    FLOAT mDpiScaleY;
+    bool mDrawing;
+
+    ID2D1Factory *mD2D1Factory;
+
+    ID2D1DCRenderTarget *mRT;
+    ID2D1SolidColorBrush *mBrush;
+
+    IDWriteFactory *mDWriteFactory;
+    IDWriteGdiInterop *mGdiInterop;
+    IDWriteRenderingParams *mRenderingParams;
+    IDWriteTextFormat *mTextFormat;
+
+    HFONT mLastHFont;
+    DWRITE_FONT_WEIGHT mFontWeight;
+    DWRITE_FONT_STYLE mFontStyle;
+
+    D2D1_TEXT_ANTIALIAS_MODE mTextAntialiasMode;
+
+    // METHODS
+
+    DWriteContext();
+
+    virtual ~DWriteContext();
+
+    HRESULT SetLOGFONT(const LOGFONTW &logFont, float fontSize);
+
+    void SetFont(HFONT hFont);
+
+    void SetFont(const LOGFONTW &logFont);
+
+    void DrawText(HDC hdc, const WCHAR* text, int len,
+	int x, int y, int w, int h, int cellWidth, COLORREF color);
+
+    float PixelsToDipsX(int x);
+
+    float PixelsToDipsY(int y);
+
+    void SetRenderingParams(
+	    const DWriteRenderingParams *params);
+
+    DWriteRenderingParams *GetRenderingParams(
+	    DWriteRenderingParams *params);
+};
+
+DWriteContext::DWriteContext() :
+    mDpiScaleX(1.f),
+    mDpiScaleY(1.f),
+    mDrawing(false),
+    mD2D1Factory(NULL),
+    mRT(NULL),
+    mBrush(NULL),
+    mDWriteFactory(NULL),
+    mGdiInterop(NULL),
+    mRenderingParams(NULL),
+    mTextFormat(NULL),
+    mLastHFont(NULL),
+    mFontWeight(DWRITE_FONT_WEIGHT_NORMAL),
+    mFontStyle(DWRITE_FONT_STYLE_NORMAL),
+    mTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_DEFAULT)
+{
+    HRESULT hr;
+
+    HDC screen = ::GetDC(0);
+    mDpiScaleX = ::GetDeviceCaps(screen, LOGPIXELSX) / 96.0f;
+    mDpiScaleY = ::GetDeviceCaps(screen, LOGPIXELSY) / 96.0f;
+    ::ReleaseDC(0, screen);
+
+    hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED,
+	    __uuidof(ID2D1Factory), NULL,
+	    reinterpret_cast<void**>(&mD2D1Factory));
+    _RPT2(_CRT_WARN, "D2D1CreateFactory: hr=%p p=%p\n", hr, mD2D1Factory);
+
+    if (SUCCEEDED(hr))
+    {
+	D2D1_RENDER_TARGET_PROPERTIES props = {
+	    D2D1_RENDER_TARGET_TYPE_DEFAULT,
+	    { DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_IGNORE },
+	    0, 0,
+	    D2D1_RENDER_TARGET_USAGE_NONE,
+	    D2D1_FEATURE_LEVEL_DEFAULT
+	};
+	hr = mD2D1Factory->CreateDCRenderTarget(&props, &mRT);
+	_RPT2(_CRT_WARN, "CreateDCRenderTarget: hr=%p p=%p\n", hr, mRT);
+    }
+
+    if (SUCCEEDED(hr))
+    {
+	hr = mRT->CreateSolidColorBrush(
+		D2D1::ColorF(D2D1::ColorF::Black),
+		&mBrush);
+	_RPT2(_CRT_WARN, "CreateSolidColorBrush: hr=%p p=%p\n", hr, mBrush);
+    }
+
+    if (SUCCEEDED(hr))
+    {
+	hr = DWriteCreateFactory(
+		DWRITE_FACTORY_TYPE_SHARED,
+		__uuidof(IDWriteFactory),
+		reinterpret_cast<IUnknown**>(&mDWriteFactory));
+	_RPT2(_CRT_WARN, "DWriteCreateFactory: hr=%p p=%p\n", hr,
+		mDWriteFactory);
+    }
+
+    if (SUCCEEDED(hr))
+    {
+	hr = mDWriteFactory->GetGdiInterop(&mGdiInterop);
+	_RPT2(_CRT_WARN, "GetGdiInterop: hr=%p p=%p\n", hr, mGdiInterop);
+    }
+
+    if (SUCCEEDED(hr))
+    {
+	hr = mDWriteFactory->CreateRenderingParams(&mRenderingParams);
+	_RPT2(_CRT_WARN, "CreateRenderingParams: hr=%p p=%p\n", hr,
+		mRenderingParams);
+    }
+}
+
+DWriteContext::~DWriteContext()
+{
+    SafeRelease(&mTextFormat);
+    SafeRelease(&mRenderingParams);
+    SafeRelease(&mGdiInterop);
+    SafeRelease(&mDWriteFactory);
+    SafeRelease(&mBrush);
+    SafeRelease(&mRT);
+    SafeRelease(&mD2D1Factory);
+}
+
+    HRESULT
+DWriteContext::SetLOGFONT(const LOGFONTW &logFont, float fontSize)
+{
+    // Most of this function is copy from: http://msdn.microsoft.com/en-us/library/windows/desktop/dd941783(v=vs.85).aspx
+    HRESULT hr = S_OK;
+
+    IDWriteFont *font = NULL;
+    IDWriteFontFamily *fontFamily = NULL;
+    IDWriteLocalizedStrings *localizedFamilyNames = NULL;
+
+    if (SUCCEEDED(hr))
+    {
+	hr = mGdiInterop->CreateFontFromLOGFONT(&logFont, &font);
+    }
+
+    // Get the font family to which this font belongs.
+    if (SUCCEEDED(hr))
+    {
+	hr = font->GetFontFamily(&fontFamily);
+    }
+
+    // Get the family names. This returns an object that encapsulates one or
+    // more names with the same meaning but in different languages.
+    if (SUCCEEDED(hr))
+    {
+	hr = fontFamily->GetFamilyNames(&localizedFamilyNames);
+    }
+
+    // Get the family name at index zero. If we were going to display the name
+    // we'd want to try to find one that matched the use locale, but for
+    // purposes of creating a text format object any language will do.
+
+    wchar_t familyName[100];
+    if (SUCCEEDED(hr))
+    {
+	hr = localizedFamilyNames->GetString(0, familyName,
+		ARRAYSIZE(familyName));
+    }
+
+    if (SUCCEEDED(hr))
+    {
+	// If no font size was passed in use the lfHeight of the LOGFONT.
+	if (fontSize == 0)
+	{
+	    // Convert from pixels to DIPs.
+	    fontSize = PixelsToDipsY(logFont.lfHeight);
+	    if (fontSize < 0)
+	    {
+		// Negative lfHeight represents the size of the em unit.
+		fontSize = -fontSize;
+	    }
+	    else
+	    {
+		// Positive lfHeight represents the cell height (ascent +
+		// descent).
+		DWRITE_FONT_METRICS fontMetrics;
+		font->GetMetrics(&fontMetrics);
+
+		// Convert the cell height (ascent + descent) from design units
+		// to ems.
+		float cellHeight = static_cast<float>(
+			fontMetrics.ascent + fontMetrics.descent)
+					       / fontMetrics.designUnitsPerEm;
+
+		// Divide the font size by the cell height to get the font em
+		// size.
+		fontSize /= cellHeight;
+	    }
+	}
+    }
+
+    // The text format includes a locale name. Ideally, this would be the
+    // language of the text, which may or may not be the same as the primary
+    // language of the user. However, for our purposes the user locale will do.
+    wchar_t localeName[LOCALE_NAME_MAX_LENGTH];
+    if (SUCCEEDED(hr))
+    {
+	if (GetUserDefaultLocaleName(localeName, LOCALE_NAME_MAX_LENGTH) == 0)
+	    hr = HRESULT_FROM_WIN32(GetLastError());
+    }
+
+    if (SUCCEEDED(hr))
+    {
+	// Create the text format object.
+	hr = mDWriteFactory->CreateTextFormat(
+		familyName,
+		NULL, // no custom font collection
+		font->GetWeight(),
+		font->GetStyle(),
+		font->GetStretch(),
+		fontSize,
+		localeName,
+		&mTextFormat);
+    }
+
+    if (SUCCEEDED(hr))
+    {
+	mFontWeight = static_cast<DWRITE_FONT_WEIGHT>(logFont.lfWeight);
+	mFontStyle = logFont.lfItalic ? DWRITE_FONT_STYLE_ITALIC
+	    : DWRITE_FONT_STYLE_NORMAL;
+    }
+
+    SafeRelease(&localizedFamilyNames);
+    SafeRelease(&fontFamily);
+    SafeRelease(&font);
+
+    return hr;
+}
+
+    void
+DWriteContext::SetFont(HFONT hFont)
+{
+    if (mLastHFont != hFont)
+    {
+	LOGFONTW lf;
+	if (GetObjectW(hFont, sizeof(lf), &lf))
+	{
+	    SetFont(lf);
+	    mLastHFont = hFont;
+	}
+    }
+}
+
+    void
+DWriteContext::SetFont(const LOGFONTW &logFont)
+{
+    SafeRelease(&mTextFormat);
+    mLastHFont = NULL;
+
+    HRESULT hr = SetLOGFONT(logFont, 0.f);
+
+    if (SUCCEEDED(hr))
+	hr = mTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
+
+    if (SUCCEEDED(hr))
+	hr = mTextFormat->SetParagraphAlignment(
+		DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
+
+    if (SUCCEEDED(hr))
+	hr = mTextFormat->SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP);
+}
+
+    void
+DWriteContext::DrawText(HDC hdc, const WCHAR* text, int len,
+	int x, int y, int w, int h, int cellWidth, COLORREF color)
+{
+    HRESULT hr = S_OK;
+    IDWriteBitmapRenderTarget *bmpRT = NULL;
+
+    // Skip when any fonts are not set.
+    if (mTextFormat == NULL)
+	return;
+
+    // Check possibility of zero divided error.
+    if (cellWidth == 0 || mDpiScaleX == 0.0f || mDpiScaleY == 0.0f)
+	return;
+
+    if (SUCCEEDED(hr))
+	hr = mGdiInterop->CreateBitmapRenderTarget(hdc, w, h, &bmpRT);
+
+    if (SUCCEEDED(hr))
+    {
+	IDWriteTextLayout *textLayout = NULL;
+
+	HDC memdc = bmpRT->GetMemoryDC();
+	BitBlt(memdc, 0, 0, w, h, hdc, x, y, SRCCOPY);
+
+	hr = mDWriteFactory->CreateGdiCompatibleTextLayout(
+		text, len, mTextFormat, PixelsToDipsX(w),
+		PixelsToDipsY(h), mDpiScaleX, NULL, TRUE, &textLayout);
+
+	if (SUCCEEDED(hr))
+	{
+	    DWRITE_TEXT_RANGE textRange = { 0, len };
+	    textLayout->SetFontWeight(mFontWeight, textRange);
+	    textLayout->SetFontStyle(mFontStyle, textRange);
+	}
+
+	if (SUCCEEDED(hr))
+	{
+	    GdiTextRenderer *renderer = new GdiTextRenderer(bmpRT,
+		    mRenderingParams);
+	    GdiTextRendererContext data = {
+		color,
+		PixelsToDipsX(cellWidth),
+		0.0f
+	    };
+	    textLayout->Draw(&data, renderer, 0, 0);
+	    SafeRelease(&renderer);
+	}
+
+	BitBlt(hdc, x, y, w, h, memdc, 0, 0, SRCCOPY);
+
+	SafeRelease(&textLayout);
+    }
+
+    SafeRelease(&bmpRT);
+}
+
+    float
+DWriteContext::PixelsToDipsX(int x)
+{
+    return x / mDpiScaleX;
+}
+
+    float
+DWriteContext::PixelsToDipsY(int y)
+{
+    return y / mDpiScaleY;
+}
+
+    void
+DWriteContext::SetRenderingParams(
+	const DWriteRenderingParams *params)
+{
+    if (mDWriteFactory == NULL)
+	return;
+
+    IDWriteRenderingParams *renderingParams = NULL;
+    D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode =
+	D2D1_TEXT_ANTIALIAS_MODE_DEFAULT;
+    HRESULT hr;
+    if (params != NULL)
+    {
+	hr = mDWriteFactory->CreateCustomRenderingParams(params->gamma,
+		params->enhancedContrast, params->clearTypeLevel,
+		ToPixelGeometry(params->pixelGeometry),
+		ToRenderingMode(params->renderingMode), &renderingParams);
+	textAntialiasMode = ToTextAntialiasMode(params->textAntialiasMode);
+    }
+    else
+	hr = mDWriteFactory->CreateRenderingParams(&renderingParams);
+    if (SUCCEEDED(hr) && renderingParams != NULL)
+    {
+	SafeRelease(&mRenderingParams);
+	mRenderingParams = renderingParams;
+	mTextAntialiasMode = textAntialiasMode;
+    }
+}
+
+    DWriteRenderingParams *
+DWriteContext::GetRenderingParams(
+	DWriteRenderingParams *params)
+{
+    if (params != NULL && mRenderingParams != NULL)
+    {
+	params->gamma = mRenderingParams->GetGamma();
+	params->enhancedContrast = mRenderingParams->GetEnhancedContrast();
+	params->clearTypeLevel = mRenderingParams->GetClearTypeLevel();
+	params->pixelGeometry = ToInt(mRenderingParams->GetPixelGeometry());
+	params->renderingMode = ToInt(mRenderingParams->GetRenderingMode());
+	params->textAntialiasMode = mTextAntialiasMode;
+    }
+    return params;
+}
+
+////////////////////////////////////////////////////////////////////////////
+// PUBLIC C INTERFACES
+
+    void
+DWrite_Init(void)
+{
+#ifdef DYNAMIC_DIRECTX
+    // Load libraries.
+    hD2D1DLL = vimLoadLib(const_cast<char*>("d2d1.dll"));
+    hDWriteDLL = vimLoadLib(const_cast<char*>("dwrite.dll"));
+    if (hD2D1DLL == NULL || hDWriteDLL == NULL)
+    {
+	DWrite_Final();
+	return;
+    }
+    // Get address of procedures.
+    pGetUserDefaultLocaleName = (PGETUSERDEFAULTLOCALENAME)GetProcAddress(
+	    GetModuleHandle("kernel32.dll"), "GetUserDefaultLocaleName");
+    pD2D1CreateFactory = (PD2D1CREATEFACTORY)GetProcAddress(hD2D1DLL,
+	    "D2D1CreateFactory");
+    pDWriteCreateFactory = (PDWRITECREATEFACTORY)GetProcAddress(hDWriteDLL,
+	    "DWriteCreateFactory");
+#endif
+}
+
+    void
+DWrite_Final(void)
+{
+#ifdef DYNAMIC_DIRECTX
+    pGetUserDefaultLocaleName = NULL;
+    pD2D1CreateFactory = NULL;
+    pDWriteCreateFactory = NULL;
+    unload(hDWriteDLL);
+    unload(hD2D1DLL);
+#endif
+}
+
+    DWriteContext *
+DWriteContext_Open(void)
+{
+#ifdef DYNAMIC_DIRECTX
+    if (pGetUserDefaultLocaleName == NULL || pD2D1CreateFactory == NULL
+	    || pDWriteCreateFactory == NULL)
+	return NULL;
+#endif
+    return new DWriteContext();
+}
+
+    void
+DWriteContext_BeginDraw(DWriteContext *ctx)
+{
+    if (ctx != NULL && ctx->mRT != NULL)
+    {
+	ctx->mRT->BeginDraw();
+	ctx->mRT->SetTransform(D2D1::IdentityMatrix());
+	ctx->mDrawing = true;
+    }
+}
+
+    void
+DWriteContext_BindDC(DWriteContext *ctx, HDC hdc, RECT *rect)
+{
+    if (ctx != NULL && ctx->mRT != NULL)
+    {
+	ctx->mRT->BindDC(hdc, rect);
+	ctx->mRT->SetTextAntialiasMode(ctx->mTextAntialiasMode);
+    }
+}
+
+    void
+DWriteContext_SetFont(DWriteContext *ctx, HFONT hFont)
+{
+    if (ctx != NULL)
+    {
+	ctx->SetFont(hFont);
+    }
+}
+
+    void
+DWriteContext_DrawText(
+	DWriteContext *ctx,
+	HDC hdc,
+	const WCHAR* text,
+	int len,
+	int x,
+	int y,
+	int w,
+	int h,
+	int cellWidth,
+	COLORREF color)
+{
+    if (ctx != NULL)
+	ctx->DrawText(hdc, text, len, x, y, w, h, cellWidth, color);
+}
+
+    void
+DWriteContext_EndDraw(DWriteContext *ctx)
+{
+    if (ctx != NULL && ctx->mRT != NULL)
+    {
+	ctx->mRT->EndDraw();
+	ctx->mDrawing = false;
+    }
+}
+
+    void
+DWriteContext_Close(DWriteContext *ctx)
+{
+    delete ctx;
+}
+
+    void
+DWriteContext_SetRenderingParams(
+	DWriteContext *ctx,
+	const DWriteRenderingParams *params)
+{
+    if (ctx != NULL)
+	ctx->SetRenderingParams(params);
+}
+
+    DWriteRenderingParams *
+DWriteContext_GetRenderingParams(
+	DWriteContext *ctx,
+	DWriteRenderingParams *params)
+{
+    if (ctx != NULL)
+	return ctx->GetRenderingParams(params);
+    else
+	return NULL;
+}
diff -Naur vim74.orig/src/gui_dwrite.h vim74/src/gui_dwrite.h
--- vim74.orig/src/gui_dwrite.h	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/gui_dwrite.h	2014-10-10 14:53:44.435380321 +0000
@@ -0,0 +1,85 @@
+/* vi:set ts=8 sts=4 sw=4 noet: */
+/*
+ * Author: MURAOKA Taro <koron.kaoriya@gmail.com>
+ *
+ * Contributors:
+ *  - Ken Takata
+ *
+ * Copyright (C) 2013 MURAOKA Taro <koron.kaoriya@gmail.com>
+ * THIS FILE IS DISTRIBUTED UNDER THE VIM LICENSE.
+ */
+
+#ifndef GUI_DWRITE_H
+#define GUI_DWRITE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct DWriteContext DWriteContext;
+
+typedef struct DWriteRenderingParams {
+    float gamma;
+    float enhancedContrast;
+    float clearTypeLevel;
+    /*
+     * pixelGeometry:
+     *	0 - DWRITE_PIXEL_GEOMETRY_FLAT
+     *	1 - DWRITE_PIXEL_GEOMETRY_RGB
+     *	2 - DWRITE_PIXEL_GEOMETRY_BGR
+     */
+    int pixelGeometry;
+    /*
+     * renderingMode:
+     *	0 - DWRITE_RENDERING_MODE_DEFAULT
+     *	1 - DWRITE_RENDERING_MODE_ALIASED
+     *	2 - DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC
+     *	3 - DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL
+     *	4 - DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL
+     *	5 - DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC
+     *	6 - DWRITE_RENDERING_MODE_OUTLINE
+     */
+    int renderingMode;
+    /*
+     * antialiasMode:
+     *	0 - D2D1_TEXT_ANTIALIAS_MODE_DEFAULT
+     *	1 - D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE
+     *	2 - D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE
+     *	3 - D2D1_TEXT_ANTIALIAS_MODE_ALIASED
+     */
+    int textAntialiasMode;
+} DWriteRenderingParams;
+
+void DWrite_Init(void);
+void DWrite_Final(void);
+
+DWriteContext *DWriteContext_Open(void);
+void DWriteContext_BeginDraw(DWriteContext *ctx);
+void DWriteContext_BindDC(DWriteContext *ctx, HDC hdc, RECT *rect);
+void DWriteContext_SetFont(DWriteContext *ctx, HFONT hFont);
+void DWriteContext_DrawText(
+	DWriteContext *ctx,
+	HDC hdc,
+	const WCHAR* text,
+	int len,
+	int x,
+	int y,
+	int w,
+	int h,
+	int cellWidth,
+	COLORREF color);
+void DWriteContext_EndDraw(DWriteContext *ctx);
+void DWriteContext_Close(DWriteContext *ctx);
+
+void DWriteContext_SetRenderingParams(
+	DWriteContext *ctx,
+	const DWriteRenderingParams *params);
+
+DWriteRenderingParams *DWriteContext_GetRenderingParams(
+	DWriteContext *ctx,
+	DWriteRenderingParams *params);
+
+#ifdef __cplusplus
+}
+#endif
+#endif/*GUI_DWRITE_H*/
diff -Naur vim74.orig/src/gui_gtk_x11.c vim74/src/gui_gtk_x11.c
--- vim74.orig/src/gui_gtk_x11.c	2013-06-30 15:42:13.000000000 +0000
+++ vim74/src/gui_gtk_x11.c	2014-10-10 14:53:44.452046946 +0000
@@ -732,7 +732,10 @@
 gui_mch_start_blink(void)
 {
     if (blink_timer)
+    {
 	gtk_timeout_remove(blink_timer);
+	blink_timer = 0;
+    }
     /* Only switch blinking on if none of the times is zero */
     if (blink_waittime && blink_ontime && blink_offtime && gui.in_focus)
     {
@@ -2051,6 +2054,7 @@
 
     ssop_flags = save_ssop_flags;
     g_free(mksession_cmdline);
+
     /*
      * Reopen the file and append a command to restore v:this_session,
      * as if this save never happened.	This is to avoid conflicts with
@@ -3139,10 +3143,14 @@
 	gnome_program_init(VIMPACKAGE, VIM_VERSION_SHORT,
 			   LIBGNOMEUI_MODULE, gui_argc, gui_argv, NULL);
 # if defined(FEAT_FLOAT) && defined(LC_NUMERIC)
-	/* Make sure strtod() uses a decimal point, not a comma. Gnome init
-	 * may change it. */
-	if (setlocale(LC_NUMERIC, NULL) != (char *) "C")
-	   setlocale(LC_NUMERIC, "C");
+	{
+	    char *p = setlocale(LC_NUMERIC, NULL);
+
+	    /* Make sure strtod() uses a decimal point, not a comma. Gnome
+	     * init may change it. */
+	    if (p == NULL || strcmp(p, "C") != 0)
+	       setlocale(LC_NUMERIC, "C");
+	}
 # endif
     }
 #endif
@@ -5957,27 +5965,48 @@
 	 * Decide whether we need to scale.  Allow one pixel of border
 	 * width to be cut off, in order to avoid excessive scaling for
 	 * tiny differences in font size.
+	 * Do scale to fit the height to avoid gaps because of linespacing.
 	 */
 	need_scale = (width > SIGN_WIDTH + 2
-		      || height > SIGN_HEIGHT + 2
+		      || height != SIGN_HEIGHT
 		      || (width < 3 * SIGN_WIDTH / 4
 			  && height < 3 * SIGN_HEIGHT / 4));
 	if (need_scale)
 	{
-	    double aspect;
+	    double  aspect;
+	    int	    w = width;
+	    int	    h = height;
 
 	    /* Keep the original aspect ratio */
 	    aspect = (double)height / (double)width;
 	    width  = (double)SIGN_WIDTH * SIGN_ASPECT / aspect;
 	    width  = MIN(width, SIGN_WIDTH);
-	    height = (double)width * aspect;
+	    if (((double)(MAX(height, SIGN_HEIGHT)) /
+		 (double)(MIN(height, SIGN_HEIGHT))) < 1.15)
+	    {
+		/* Change the aspect ratio by at most 15% to fill the
+		 * available space completly. */
+		height = (double)SIGN_HEIGHT * SIGN_ASPECT / aspect;
+		height = MIN(height, SIGN_HEIGHT);
+	    }
+	    else
+		height = (double)width * aspect;
 
-	    /* This doesn't seem to be worth caching, and doing so
-	     * would complicate the code quite a bit. */
-	    sign = gdk_pixbuf_scale_simple(sign, width, height,
-					   GDK_INTERP_BILINEAR);
-	    if (sign == NULL)
-		return; /* out of memory */
+	    if (w == width && h == height)
+	    {
+		/* no change in dimensions; don't decrease reference counter
+		 * (below) */
+		need_scale = FALSE;
+	    }
+	    else
+	    {
+		/* This doesn't seem to be worth caching, and doing so would
+		 * complicate the code quite a bit. */
+		sign = gdk_pixbuf_scale_simple(sign, width, height,
+							 GDK_INTERP_BILINEAR);
+		if (sign == NULL)
+		    return; /* out of memory */
+	    }
 	}
 
 	/* The origin is the upper-left corner of the pixmap.  Therefore
diff -Naur vim74.orig/src/gui_mac.c vim74/src/gui_mac.c
--- vim74.orig/src/gui_mac.c	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/gui_mac.c	2014-10-10 14:53:44.468713571 +0000
@@ -1068,11 +1068,7 @@
     }
  */
 
-
-#ifdef FEAT_VISUAL
     reset_VIsual();
-#endif
-
     fnames = new_fnames_from_AEDesc(&theList, &numFiles, &error);
 
     if (error)
@@ -1142,7 +1138,7 @@
 
     /* Update the screen display */
     update_screen(NOT_VALID);
-#ifdef FEAT_VISUAL
+
     /* Select the text if possible */
     if (gotPosition)
     {
@@ -1160,7 +1156,7 @@
 	    VIsual.col = 0;
 	}
     }
-#endif
+
     setcursor();
     out_flush();
 
diff -Naur vim74.orig/src/gui_w32.c vim74/src/gui_w32.c
--- vim74.orig/src/gui_w32.c	2013-08-04 14:15:37.000000000 +0000
+++ vim74/src/gui_w32.c	2014-10-10 14:53:44.482046870 +0000
@@ -25,6 +25,145 @@
 
 #include "vim.h"
 
+#if defined(FEAT_DIRECTX)
+# include "gui_dwrite.h"
+#endif
+
+#if defined(FEAT_DIRECTX) || defined(PROTO)
+static DWriteContext *s_dwc = NULL;
+static int s_directx_enabled = 0;
+static int s_directx_load_attempted = 0;
+# define IS_ENABLE_DIRECTX() (s_directx_enabled && s_dwc != NULL)
+
+    int
+directx_enabled(void)
+{
+    if (s_dwc != NULL)
+	return 1;
+    else if (s_directx_load_attempted)
+	return 0;
+    /* load DirectX */
+    DWrite_Init();
+    s_directx_load_attempted = 1;
+    s_dwc = DWriteContext_Open();
+    return s_dwc != NULL ? 1 : 0;
+}
+#endif
+
+#if defined(FEAT_RENDER_OPTIONS) || defined(PROTO)
+    int
+gui_mch_set_rendering_options(char_u *s)
+{
+#ifdef FEAT_DIRECTX
+    int	    retval = FAIL;
+    char_u  *p, *q;
+
+    int	    dx_enable = 0;
+    int	    dx_flags = 0;
+    float   dx_gamma = 0.0f;
+    float   dx_contrast = 0.0f;
+    float   dx_level = 0.0f;
+    int	    dx_geom = 0;
+    int	    dx_renmode = 0;
+    int	    dx_taamode = 0;
+
+    /* parse string as rendering options. */
+    for (p = s; p != NULL && *p != NUL; )
+    {
+	char_u  item[256];
+	char_u  name[128];
+	char_u  value[128];
+
+	copy_option_part(&p, item, sizeof(item), ","); 
+	if (p == NULL)
+	    break;
+	q = &item[0];
+	copy_option_part(&q, name, sizeof(name), ":");
+	if (q == NULL)
+	    return FAIL;
+	copy_option_part(&q, value, sizeof(value), ":");
+
+	if (STRCMP(name, "type") == 0)
+	{
+	    if (STRCMP(value, "directx") == 0)
+		dx_enable = 1;
+	    else
+		return FAIL;
+	}
+	else if (STRCMP(name, "gamma") == 0)
+	{
+	    dx_flags |= 1 << 0;
+	    dx_gamma = (float)atof(value);
+	}
+	else if (STRCMP(name, "contrast") == 0)
+	{
+	    dx_flags |= 1 << 1;
+	    dx_contrast = (float)atof(value);
+	}
+	else if (STRCMP(name, "level") == 0)
+	{
+	    dx_flags |= 1 << 2;
+	    dx_level = (float)atof(value);
+	}
+	else if (STRCMP(name, "geom") == 0)
+	{
+	    dx_flags |= 1 << 3;
+	    dx_geom = atoi(value);
+	    if (dx_geom < 0 || dx_geom > 2)
+		return FAIL;
+	}
+	else if (STRCMP(name, "renmode") == 0)
+	{
+	    dx_flags |= 1 << 4;
+	    dx_renmode = atoi(value);
+	    if (dx_renmode < 0 || dx_renmode > 6)
+		return FAIL;
+	}
+	else if (STRCMP(name, "taamode") == 0)
+	{
+	    dx_flags |= 1 << 5;
+	    dx_taamode = atoi(value);
+	    if (dx_taamode < 0 || dx_taamode > 3)
+		return FAIL;
+	}
+	else
+	    return FAIL;
+    }
+
+    /* Enable DirectX/DirectWrite */
+    if (dx_enable)
+    {
+	if (!directx_enabled())
+	    return FAIL;
+	DWriteContext_SetRenderingParams(s_dwc, NULL);
+	if (dx_flags)
+	{
+	    DWriteRenderingParams param;
+	    DWriteContext_GetRenderingParams(s_dwc, &param);
+	    if (dx_flags & (1 << 0))
+		param.gamma = dx_gamma;
+	    if (dx_flags & (1 << 1))
+		param.enhancedContrast = dx_contrast;
+	    if (dx_flags & (1 << 2))
+		param.clearTypeLevel = dx_level;
+	    if (dx_flags & (1 << 3))
+		param.pixelGeometry = dx_geom;
+	    if (dx_flags & (1 << 4))
+		param.renderingMode = dx_renmode;
+	    if (dx_flags & (1 << 5))
+		param.textAntialiasMode = dx_taamode;
+	    DWriteContext_SetRenderingParams(s_dwc, &param);
+	}
+    }
+    s_directx_enabled = dx_enable;
+
+    return OK;
+#else
+    return FAIL;
+#endif
+}
+#endif
+
 /*
  * These are new in Windows ME/XP, only defined in recent compilers.
  */
@@ -396,10 +535,6 @@
 # define pImmSetConversionStatus  ImmSetConversionStatus
 #endif
 
-#ifndef ETO_IGNORELANGUAGE
-# define ETO_IGNORELANGUAGE  0x1000
-#endif
-
 /* multi monitor support */
 typedef struct _MONITORINFOstruct
 {
@@ -1527,6 +1662,14 @@
     if (s_textArea == NULL)
 	return FAIL;
 
+    /* Try loading an icon from $RUNTIMEPATH/bitmaps/vim.ico. */
+    {
+	HANDLE	hIcon = NULL;
+
+	if (mch_icon_load(&hIcon) == OK && hIcon != NULL)
+	    SendMessage(s_hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
+    }
+
 #ifdef FEAT_MENU
     s_menuBar = CreateMenu();
 #endif
@@ -1624,6 +1767,11 @@
     set_vim_var_nr(VV_WINDOWID, HandleToLong(s_hwnd));
 #endif
 
+#ifdef FEAT_RENDER_OPTIONS
+    if (p_rop)
+	(void)gui_mch_set_rendering_options(p_rop);
+#endif
+
 theend:
     /* Display any pending error messages */
     display_errors();
@@ -1695,9 +1843,9 @@
 
     /* compute the size of the outside of the window */
     win_width = width + (GetSystemMetrics(SM_CXFRAME) +
-                         GetSystemMetrics(SM_CXPADDEDBORDER)) * 2;
+			 GetSystemMetrics(SM_CXPADDEDBORDER)) * 2;
     win_height = height + (GetSystemMetrics(SM_CYFRAME) +
-                           GetSystemMetrics(SM_CXPADDEDBORDER)) * 2
+			   GetSystemMetrics(SM_CXPADDEDBORDER)) * 2
 			+ GetSystemMetrics(SM_CYCAPTION)
 #ifdef FEAT_MENU
 			+ gui_mswin_get_menu_height(FALSE)
@@ -2239,6 +2387,9 @@
 #endif
     HPEN	hpen, old_pen;
     int		y;
+#ifdef FEAT_DIRECTX
+    int		font_is_ttf_or_vector = 0;
+#endif
 
 #ifndef MSWIN16_FASTTEXT
     /*
@@ -2326,6 +2477,20 @@
     SetTextColor(s_hdc, gui.currFgColor);
     SelectFont(s_hdc, gui.currFont);
 
+#ifdef FEAT_DIRECTX
+    if (IS_ENABLE_DIRECTX())
+    {
+	TEXTMETRIC tm;
+
+	GetTextMetrics(s_hdc, &tm);
+	if (tm.tmPitchAndFamily & (TMPF_TRUETYPE | TMPF_VECTOR))
+	{
+	    font_is_ttf_or_vector = 1;
+	    DWriteContext_SetFont(s_dwc, (HFONT)gui.currFont);
+	}
+    }
+#endif
+
     if (pad_size != Columns || padding == NULL || padding[0] != gui.char_width)
     {
 	vim_free(padding);
@@ -2339,12 +2504,6 @@
 		padding[i] = gui.char_width;
     }
 
-    /* On NT, tell the font renderer not to "help" us with Hebrew and Arabic
-     * text.  This doesn't work in 9x, so we have to deal with it manually on
-     * those systems. */
-    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT)
-	foptions |= ETO_IGNORELANGUAGE;
-
     /*
      * We have to provide the padding argument because italic and bold versions
      * of fixed-width fonts are often one pixel or so wider than their normal
@@ -2360,6 +2519,14 @@
 	    if (text[n] >= 0x80)
 		break;
 
+#if defined(FEAT_DIRECTX)
+    /* Quick hack to enable DirectWrite.  To use DirectWrite (antialias), it is
+     * required that unicode drawing routine, currently.  So this forces it
+     * enabled. */
+    if (enc_utf8 && IS_ENABLE_DIRECTX())
+	n = 0; /* Keep n < len, to enter block for unicode. */
+#endif
+
     /* Check if the Unicode buffer exists and is big enough.  Create it
      * with the same length as the multi-byte string, the number of wide
      * characters is always equal or smaller. */
@@ -2418,8 +2585,18 @@
 	    i += utfc_ptr2len_len(text + i, len - i);
 	    ++clen;
 	}
-	ExtTextOutW(s_hdc, TEXT_X(col), TEXT_Y(row),
-			   foptions, pcliprect, unicodebuf, wlen, unicodepdy);
+#if defined(FEAT_DIRECTX)
+	if (IS_ENABLE_DIRECTX() && font_is_ttf_or_vector)
+	{
+	    /* Add one to "cells" for italics. */
+	    DWriteContext_DrawText(s_dwc, s_hdc, unicodebuf, wlen,
+		    TEXT_X(col), TEXT_Y(row), FILL_X(cells + 1), FILL_Y(1),
+		    gui.char_width, gui.currFgColor);
+	}
+	else
+#endif
+	    ExtTextOutW(s_hdc, TEXT_X(col), TEXT_Y(row),
+		    foptions, pcliprect, unicodebuf, wlen, unicodepdy);
 	len = cells;	/* used for underlining */
     }
     else if ((enc_codepage > 0 && (int)GetACP() != enc_codepage) || enc_latin9)
@@ -2462,10 +2639,9 @@
 #endif
     {
 #ifdef FEAT_RIGHTLEFT
-	/* If we can't use ETO_IGNORELANGUAGE, we can't tell Windows not to
-	 * mess up RL text, so we have to draw it character-by-character.
-	 * Only do this if RL is on, since it's slow. */
-	if (curwin->w_p_rl && !(foptions & ETO_IGNORELANGUAGE))
+	/* Windows will mess up RL text, so we have to draw it character by
+	 * character.  Only do this if RL is on, since it's slow. */
+	if (curwin->w_p_rl)
 	    RevOut(s_hdc, TEXT_X(col), TEXT_Y(row),
 			 foptions, pcliprect, (char *)text, len, padding);
 	else
@@ -2549,14 +2725,14 @@
 
     *screen_w = workarea_rect.right - workarea_rect.left
 		- (GetSystemMetrics(SM_CXFRAME) +
-                   GetSystemMetrics(SM_CXPADDEDBORDER)) * 2;
+		   GetSystemMetrics(SM_CXPADDEDBORDER)) * 2;
 
     /* FIXME: dirty trick: Because the gui_get_base_height() doesn't include
      * the menubar for MSwin, we subtract it from the screen height, so that
      * the window size can be made to fit on the screen. */
     *screen_h = workarea_rect.bottom - workarea_rect.top
 		- (GetSystemMetrics(SM_CYFRAME) +
-                   GetSystemMetrics(SM_CXPADDEDBORDER)) * 2
+		   GetSystemMetrics(SM_CXPADDEDBORDER)) * 2
 		- GetSystemMetrics(SM_CYCAPTION)
 #ifdef FEAT_MENU
 		- gui_mswin_get_menu_height(FALSE)
@@ -3188,13 +3364,13 @@
 	GetWindowRect(s_hwnd, &rect);
 	maxDialogWidth = rect.right - rect.left
 				   - (GetSystemMetrics(SM_CXFRAME) +
-                                      GetSystemMetrics(SM_CXPADDEDBORDER)) * 2;
+				      GetSystemMetrics(SM_CXPADDEDBORDER)) * 2;
 	if (maxDialogWidth < DLG_MIN_MAX_WIDTH)
 	    maxDialogWidth = DLG_MIN_MAX_WIDTH;
 
 	maxDialogHeight = rect.bottom - rect.top
 				   - (GetSystemMetrics(SM_CYFRAME) +
-                                      GetSystemMetrics(SM_CXPADDEDBORDER)) * 4
+				      GetSystemMetrics(SM_CXPADDEDBORDER)) * 4
 				   - GetSystemMetrics(SM_CYCAPTION);
 	if (maxDialogHeight < DLG_MIN_MAX_HEIGHT)
 	    maxDialogHeight = DLG_MIN_MAX_HEIGHT;
@@ -3351,11 +3527,11 @@
     /* Restrict the size to a maximum.  Causes a scrollbar to show up. */
     if (dlgheight > maxDialogHeight)
     {
-        msgheight = msgheight - (dlgheight - maxDialogHeight);
-        dlgheight = maxDialogHeight;
-        scroll_flag = WS_VSCROLL;
-        /* Make sure scrollbar doesn't appear in the middle of the dialog */
-        messageWidth = dlgwidth - DLG_ICON_WIDTH - 3 * dlgPaddingX;
+	msgheight = msgheight - (dlgheight - maxDialogHeight);
+	dlgheight = maxDialogHeight;
+	scroll_flag = WS_VSCROLL;
+	/* Make sure scrollbar doesn't appear in the middle of the dialog */
+	messageWidth = dlgwidth - DLG_ICON_WIDTH - 3 * dlgPaddingX;
     }
 
     add_word(PixelToDialogY(dlgheight));
diff -Naur vim74.orig/src/gui_w48.c vim74/src/gui_w48.c
--- vim74.orig/src/gui_w48.c	2013-08-10 11:36:45.000000000 +0000
+++ vim74/src/gui_w48.c	2014-10-10 14:53:44.492046845 +0000
@@ -614,6 +614,8 @@
     char_u	string[40];
     int		len = 0;
 
+    dead_key = 0;
+
     len = char_to_string(ch, string, 40, FALSE);
     if (len == 1 && string[0] == Ctrl_C && ctrl_c_interrupts)
     {
@@ -1008,7 +1010,7 @@
     static LPARAM last_lParam = 0L;
 
     /* We sometimes get a mousemove when the mouse didn't move... */
-    if (uMsg == WM_MOUSEMOVE)
+    if (uMsg == WM_MOUSEMOVE || uMsg == WM_NCMOUSEMOVE)
     {
 	if (lParam == last_lParam)
 	    return;
@@ -1788,24 +1790,21 @@
     if (msg.message == WM_KEYDOWN || msg.message == WM_SYSKEYDOWN)
     {
 	vk = (int) msg.wParam;
-	/* handle key after dead key, but ignore shift, alt and control */
-	if (dead_key && vk != VK_SHIFT && vk != VK_MENU && vk != VK_CONTROL)
+	/*
+	 * If a dead key was pressed and the user presses VK_SPACE, VK_BACK, or
+	 * VK_ESCAPE it means that he actually wants to deal with the dead char
+	 * now, so do nothing special and let Windows handle it.
+	 *
+	 * Note that VK_SPACE combines with the dead_key's character and only
+	 * one WM_CHAR will be generated by TranslateMessage(), in the two
+	 * other cases two WM_CHAR will be generated: the dead char and VK_BACK
+	 * or VK_ESCAPE.  That is most likely what the user expects.
+	 */
+	if (dead_key && (vk == VK_SPACE || vk == VK_BACK || vk == VK_ESCAPE))
 	{
 	    dead_key = 0;
-	    /* handle non-alphabetic keys (ones that hopefully cannot generate
-	     * umlaut-characters), unless when control is down */
-	    if (vk < 'A' || vk > 'Z' || (GetKeyState(VK_CONTROL) & 0x8000))
-	    {
-		MSG dm;
-
-		dm.message = msg.message;
-		dm.hwnd = msg.hwnd;
-		dm.wParam = VK_SPACE;
-		MyTranslateMessage(&dm);	/* generate dead character */
-		if (vk != VK_SPACE) /* and send current character once more */
-		    PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
-		return;
-	    }
+	    MyTranslateMessage(&msg);
+	    return;
 	}
 
 	/* Check for CTRL-BREAK */
@@ -2785,6 +2784,10 @@
 
 	out_flush();	    /* make sure all output has been processed */
 	(void)BeginPaint(hwnd, &ps);
+#if defined(FEAT_DIRECTX)
+	if (IS_ENABLE_DIRECTX())
+	    DWriteContext_BeginDraw(s_dwc);
+#endif
 
 #ifdef FEAT_MBYTE
 	/* prevent multi-byte characters from misprinting on an invalid
@@ -2800,9 +2803,20 @@
 #endif
 
 	if (!IsRectEmpty(&ps.rcPaint))
+	{
+#if defined(FEAT_DIRECTX)
+	    if (IS_ENABLE_DIRECTX())
+		DWriteContext_BindDC(s_dwc, s_hdc, &ps.rcPaint);
+#endif
 	    gui_redraw(ps.rcPaint.left, ps.rcPaint.top,
 		    ps.rcPaint.right - ps.rcPaint.left + 1,
 		    ps.rcPaint.bottom - ps.rcPaint.top + 1);
+	}
+
+#if defined(FEAT_DIRECTX)
+	if (IS_ENABLE_DIRECTX())
+	    DWriteContext_EndDraw(s_dwc);
+#endif
 	EndPaint(hwnd, &ps);
     }
 }
@@ -3043,6 +3057,12 @@
     void
 gui_mch_exit(int rc)
 {
+#if defined(FEAT_DIRECTX)
+    DWriteContext_Close(s_dwc);
+    DWrite_Final();
+    s_dwc = NULL;
+#endif
+
     ReleaseDC(s_textArea, s_hdc);
     DeleteObject(s_brush);
 
@@ -3069,15 +3089,26 @@
     char	*p;
     char	*res;
     char	*charset_name;
+    char	*font_name = lf.lfFaceName;
 
     charset_name = charset_id2name((int)lf.lfCharSet);
-    res = alloc((unsigned)(strlen(lf.lfFaceName) + 20
+#ifdef FEAT_MBYTE
+    /* Convert a font name from the current codepage to 'encoding'.
+     * TODO: Use Wide APIs (including LOGFONTW) instead of ANSI APIs. */
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	int	len;
+	acp_to_enc(lf.lfFaceName, (int)strlen(lf.lfFaceName),
+						(char_u **)&font_name, &len);
+    }
+#endif
+    res = alloc((unsigned)(strlen(font_name) + 20
 		    + (charset_name == NULL ? 0 : strlen(charset_name) + 2)));
     if (res != NULL)
     {
 	p = res;
 	/* make a normal font string out of the lf thing:*/
-	sprintf((char *)p, "%s:h%d", lf.lfFaceName, pixels_to_points(
+	sprintf((char *)p, "%s:h%d", font_name, pixels_to_points(
 			 lf.lfHeight < 0 ? -lf.lfHeight : lf.lfHeight, TRUE));
 	while (*p)
 	{
@@ -3102,6 +3133,10 @@
 	}
     }
 
+#ifdef FEAT_MBYTE
+    if (font_name != lf.lfFaceName)
+	vim_free(font_name);
+#endif
     return res;
 }
 
@@ -3693,9 +3728,7 @@
     DragQueryPoint(hDrop, &pt);
     MapWindowPoints(s_hwnd, s_textArea, &pt, 1);
 
-# ifdef FEAT_VISUAL
     reset_VIsual();
-# endif
 
     fnames = (char_u **)alloc(cFiles * sizeof(char_u *));
 
diff -Naur vim74.orig/src/if_lua.c vim74/src/if_lua.c
--- vim74.orig/src/if_lua.c	2013-06-23 10:55:02.000000000 +0000
+++ vim74/src/if_lua.c	2014-10-10 14:53:44.525380095 +0000
@@ -734,7 +734,7 @@
     if (li == NULL) return 0;
     if (lua_isnil(L, 3)) /* remove? */
     {
-	list_remove(l, li, li);
+	vimlist_remove(l, li, li);
 	clear_tv(&li->li_tv);
 	vim_free(li);
     }
diff -Naur vim74.orig/src/if_perl.xs vim74/src/if_perl.xs
--- vim74.orig/src/if_perl.xs	2013-08-02 17:28:50.000000000 +0000
+++ vim74/src/if_perl.xs	2014-10-10 14:53:44.542046720 +0000
@@ -14,7 +14,8 @@
 #define IN_PERL_FILE	/* don't include if_perl.pro from proto.h */
 
 /*
- * Currently 32-bit version of ActivePerl is built with VC6.
+ * Currently 32-bit version of ActivePerl is built with VC6 (or MinGW since
+ * ActivePerl 5.18).
  * (http://community.activestate.com/faq/windows-compilers-perl-modules)
  * It means that time_t should be 32-bit. However the default size of
  * time_t is 64-bit since VC8. So we have to define _USE_32BIT_TIME_T.
@@ -23,8 +24,31 @@
 # define _USE_32BIT_TIME_T
 #endif
 
+/*
+ * Prevent including winsock.h.  perl.h tries to detect whether winsock.h is
+ * already included before including winsock2.h, because winsock2.h isn't
+ * compatible with winsock.h.  However the detection doesn't work with some
+ * versions of MinGW.  If WIN32_LEAN_AND_MEAN is defined, windows.h will not
+ * include winsock.h.
+ */
+#ifdef WIN32
+# define WIN32_LEAN_AND_MEAN
+#endif
+
 #include "vim.h"
 
+/* Work around for perl-5.18.
+ * Don't include "perl\lib\CORE\inline.h" for now,
+ * include it after Perl_sv_free2 is defined. */
+#ifdef DYNAMIC_PERL
+# define PERL_NO_INLINE_FUNCTIONS
+#endif
+
+/* Work around for using MSVC and ActivePerl 5.18. */
+#ifdef _MSC_VER
+# define __inline__ __inline
+#endif
+
 #include <EXTERN.h>
 #include <perl.h>
 #include <XSUB.h>
@@ -81,10 +105,6 @@
 # define PERL5101_OR_LATER
 #endif
 
-#if (PERL_REVISION == 5) && (PERL_VERSION >= 18)
-# define PERL5180_OR_LATER
-#endif
-
 #ifndef pTHX
 #    define pTHX void
 #    define pTHX_
@@ -118,6 +138,8 @@
 #endif
 typedef int XSINIT_t;
 typedef int XSUBADDR_t;
+#endif
+#ifndef USE_ITHREADS
 typedef int perl_key;
 #endif
 
@@ -145,11 +167,9 @@
 # define perl_free dll_perl_free
 # define Perl_get_context dll_Perl_get_context
 # define Perl_croak dll_Perl_croak
-# ifndef PERL5180_OR_LATER
 # ifdef PERL5101_OR_LATER
 #  define Perl_croak_xs_usage dll_Perl_croak_xs_usage
 # endif
-# endif
 # ifndef PROTO
 #  define Perl_croak_nocontext dll_Perl_croak_nocontext
 #  define Perl_call_argv dll_Perl_call_argv
@@ -171,6 +191,9 @@
 # define Perl_pop_scope dll_Perl_pop_scope
 # define Perl_push_scope dll_Perl_push_scope
 # define Perl_save_int dll_Perl_save_int
+# if (PERL_REVISION == 5) && (PERL_VERSION >= 20)
+#  define Perl_save_strlen dll_Perl_save_strlen
+# endif
 # define Perl_stack_grow dll_Perl_stack_grow
 # define Perl_set_context dll_Perl_set_context
 # if (PERL_REVISION == 5) && (PERL_VERSION >= 14)
@@ -246,7 +269,9 @@
 # define Perl_Iscopestack_ix_ptr dll_Perl_Iscopestack_ix_ptr
 # define Perl_Iunitcheckav_ptr dll_Perl_Iunitcheckav_ptr
 # if (PERL_REVISION == 5) && (PERL_VERSION >= 14)
-#  define PL_thr_key *dll_PL_thr_key
+#  ifdef USE_ITHREADS
+#   define PL_thr_key *dll_PL_thr_key
+#  endif
 # endif
 
 /*
@@ -262,10 +287,13 @@
 static int (*perl_parse)(PerlInterpreter*, XSINIT_t, int, char**, char**);
 static void* (*Perl_get_context)(void);
 static void (*Perl_croak)(pTHX_ const char*, ...);
-#ifndef PERL5180_OR_LATER
 #ifdef PERL5101_OR_LATER
+/* Perl-5.18 has a different Perl_croak_xs_usage signature. */
+# if (PERL_REVISION == 5) && (PERL_VERSION >= 18)
+static void (*Perl_croak_xs_usage)(const CV *const, const char *const params);
+# else
 static void (*Perl_croak_xs_usage)(pTHX_ const CV *const, const char *const params);
-#endif
+# endif
 #endif
 static void (*Perl_croak_nocontext)(const char*, ...);
 static I32 (*Perl_dowantarray)(pTHX);
@@ -286,6 +314,9 @@
 static void (*Perl_pop_scope)(pTHX);
 static void (*Perl_push_scope)(pTHX);
 static void (*Perl_save_int)(pTHX_ int*);
+#if (PERL_REVISION == 5) && (PERL_VERSION >= 20)
+static void (*Perl_save_strlen)(pTHX_ STRLEN* ptr);
+#endif
 static SV** (*Perl_stack_grow)(pTHX_ SV**, SV**p, int);
 static SV** (*Perl_set_context)(void*);
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 14)
@@ -337,7 +368,12 @@
 static XPV** (*Perl_TXpv_ptr)(register PerlInterpreter*);
 static STRLEN* (*Perl_Tna_ptr)(register PerlInterpreter*);
 #else
+/* Perl-5.18 has a different Perl_sv_free2 signature. */
+# if (PERL_REVISION == 5) && (PERL_VERSION >= 18)
+static void (*Perl_sv_free2)(pTHX_ SV*, const U32);
+# else
 static void (*Perl_sv_free2)(pTHX_ SV*);
+# endif
 static void (*Perl_sys_init)(int* argc, char*** argv);
 static void (*Perl_sys_term)(void);
 static void (*Perl_call_list)(pTHX_ I32, AV*);
@@ -360,7 +396,9 @@
 #endif
 
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 14)
+# ifdef USE_ITHREADS
 static perl_key* dll_PL_thr_key;
+# endif
 #else
 static GV** (*Perl_Idefgv_ptr)(register PerlInterpreter*);
 static GV** (*Perl_Ierrgv_ptr)(register PerlInterpreter*);
@@ -384,12 +422,12 @@
     {"perl_parse", (PERL_PROC*)&perl_parse},
     {"Perl_get_context", (PERL_PROC*)&Perl_get_context},
     {"Perl_croak", (PERL_PROC*)&Perl_croak},
-#ifndef PERL5180_OR_LATER
 #ifdef PERL5101_OR_LATER
     {"Perl_croak_xs_usage", (PERL_PROC*)&Perl_croak_xs_usage},
 #endif
-#endif
+#ifdef PERL_IMPLICIT_CONTEXT
     {"Perl_croak_nocontext", (PERL_PROC*)&Perl_croak_nocontext},
+#endif
     {"Perl_dowantarray", (PERL_PROC*)&Perl_dowantarray},
     {"Perl_free_tmps", (PERL_PROC*)&Perl_free_tmps},
     {"Perl_gv_stashpv", (PERL_PROC*)&Perl_gv_stashpv},
@@ -408,6 +446,9 @@
     {"Perl_pop_scope", (PERL_PROC*)&Perl_pop_scope},
     {"Perl_push_scope", (PERL_PROC*)&Perl_push_scope},
     {"Perl_save_int", (PERL_PROC*)&Perl_save_int},
+#if (PERL_REVISION == 5) && (PERL_VERSION >= 20)
+    {"Perl_save_strlen", (PERL_PROC*)&Perl_save_strlen},
+#endif
     {"Perl_stack_grow", (PERL_PROC*)&Perl_stack_grow},
     {"Perl_set_context", (PERL_PROC*)&Perl_set_context},
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 14)
@@ -481,7 +522,9 @@
 # endif
 #endif
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 14)
+#  ifdef USE_ITHREADS
     {"PL_thr_key", (PERL_PROC*)&dll_PL_thr_key},
+#  endif
 #else
     {"Perl_Idefgv_ptr", (PERL_PROC*)&Perl_Idefgv_ptr},
     {"Perl_Ierrgv_ptr", (PERL_PROC*)&Perl_Ierrgv_ptr},
@@ -492,6 +535,14 @@
     {"", NULL},
 };
 
+/* Work around for perl-5.18.
+ * The definitions of S_SvREFCNT_inc and S_SvREFCNT_dec are needed, so include
+ * "perl\lib\CORE\inline.h", after Perl_sv_free2 is defined.
+ * The linker won't complain about undefined __impl_Perl_sv_free2. */
+#if (PERL_REVISION == 5) && (PERL_VERSION >= 18)
+# include <inline.h>
+#endif
+
 /*
  * Make all runtime-links of perl.
  *
diff -Naur vim74.orig/src/if_py_both.h vim74/src/if_py_both.h
--- vim74.orig/src/if_py_both.h	2013-07-24 15:09:19.000000000 +0000
+++ vim74/src/if_py_both.h	2014-10-10 14:53:44.552046695 +0000
@@ -13,6 +13,11 @@
  * Common code for if_python.c and if_python3.c.
  */
 
+#ifdef __BORLANDC__
+/* Disable Warning W8060: Possibly incorrect assignment in function ... */
+# pragma warn -8060
+#endif
+
 static char_u e_py_systemexit[]	= "E880: Can't handle SystemExit of %s exception in vim";
 
 #if PY_VERSION_HEX < 0x02050000
@@ -31,8 +36,9 @@
 #define PyErr_SET_STRING(exc, str) PyErr_SetString(exc, _(str))
 #define PyErr_SetVim(str) PyErr_SetString(VimError, str)
 #define PyErr_SET_VIM(str) PyErr_SET_STRING(VimError, str)
-#define PyErr_FORMAT(exc, str, tail) PyErr_Format(exc, _(str), tail)
-#define PyErr_VIM_FORMAT(str, tail) PyErr_FORMAT(VimError, str, tail)
+#define PyErr_FORMAT(exc, str, arg) PyErr_Format(exc, _(str), arg)
+#define PyErr_FORMAT2(exc, str, arg1, arg2) PyErr_Format(exc, _(str), arg1,arg2)
+#define PyErr_VIM_FORMAT(str, arg) PyErr_FORMAT(VimError, str, arg)
 
 #define Py_TYPE_NAME(obj) (obj->ob_type->tp_name == NULL \
 	? "(NULL)" \
@@ -230,7 +236,7 @@
 	if (*result <= 0)
 	{
 	    PyErr_SET_STRING(PyExc_ValueError,
-		    N_("number must be greater then zero"));
+		    N_("number must be greater than zero"));
 	    return -1;
 	}
     }
@@ -558,16 +564,40 @@
     /* Keyboard interrupt should be preferred over anything else */
     if (got_int)
     {
-	did_throw = got_int = FALSE;
+	if (did_throw)
+	    discard_current_exception();
+	got_int = FALSE;
 	PyErr_SetNone(PyExc_KeyboardInterrupt);
 	return -1;
     }
+    else if (msg_list != NULL && *msg_list != NULL)
+    {
+	int	should_free;
+	char_u	*msg;
+
+	msg = get_exception_string(*msg_list, ET_ERROR, NULL, &should_free);
+
+	if (msg == NULL)
+	{
+	    PyErr_NoMemory();
+	    return -1;
+	}
+
+	PyErr_SetVim((char *) msg);
+
+	free_global_msglist();
+
+	if (should_free)
+	    vim_free(msg);
+
+	return -1;
+    }
     else if (!did_throw)
 	return (PyErr_Occurred() ? -1 : 0);
     /* Python exception is preferred over vim one; unlikely to occur though */
     else if (PyErr_Occurred())
     {
-	did_throw = FALSE;
+	discard_current_exception();
 	return -1;
     }
     /* Finally transform VimL exception to python one */
@@ -1587,8 +1617,9 @@
     }
     else if (flags & DICT_FLAG_RETURN_BOOL)
     {
-	Py_INCREF(Py_True);
-	return Py_True;
+	ret = Py_True;
+	Py_INCREF(ret);
+	return ret;
     }
 
     di = dict_lookup(hi);
@@ -1624,6 +1655,9 @@
     PyObject	*rObj = _DictionaryItem(self, keyObject, DICT_FLAG_RETURN_BOOL);
     int		ret;
 
+    if (rObj == NULL)
+	return -1;
+
     ret = (rObj == Py_True);
 
     Py_DECREF(rObj);
@@ -1885,11 +1919,17 @@
     }
     else
     {
-	PyObject	*obj;
+	PyObject	*obj = NULL;
 
-	if (!PyArg_ParseTuple(args, "O", &obj))
+	if (!PyArg_ParseTuple(args, "|O", &obj))
 	    return NULL;
 
+	if (obj == NULL)
+	{
+	    Py_INCREF(Py_None);
+	    return Py_None;
+	}
+
 	if (PyObject_HasAttrString(obj, "keys"))
 	    return DictionaryUpdate(self, NULL, obj);
 	else
@@ -2071,8 +2111,6 @@
 };
 
 static PyTypeObject ListType;
-static PySequenceMethods ListAsSeq;
-static PyMappingMethods ListAsMapping;
 
 typedef struct
 {
@@ -2216,7 +2254,7 @@
 }
 
     static PyObject *
-ListItem(ListObject *self, Py_ssize_t index)
+ListIndex(ListObject *self, Py_ssize_t index)
 {
     listitem_T	*li;
 
@@ -2236,164 +2274,110 @@
     return ConvertToPyObject(&li->li_tv);
 }
 
-#define PROC_RANGE \
-    if (last < 0) {\
-	if (last < -size) \
-	    last = 0; \
-	else \
-	    last += size; \
-    } \
-    if (first < 0) \
-	first = 0; \
-    if (first > size) \
-	first = size; \
-    if (last > size) \
-	last = size;
-
     static PyObject *
-ListSlice(ListObject *self, Py_ssize_t first, Py_ssize_t last)
+ListSlice(ListObject *self, Py_ssize_t first, Py_ssize_t step,
+	  Py_ssize_t slicelen)
 {
     PyInt	i;
-    PyInt	size = ListLength(self);
-    PyInt	n;
     PyObject	*list;
-    int		reversed = 0;
 
-    PROC_RANGE
-    if (first >= last)
-	first = last;
+    if (step == 0)
+    {
+	PyErr_SET_STRING(PyExc_ValueError, N_("slice step cannot be zero"));
+	return NULL;
+    }
 
-    n = last-first;
-    list = PyList_New(n);
+    list = PyList_New(slicelen);
     if (list == NULL)
 	return NULL;
 
-    for (i = 0; i < n; ++i)
+    for (i = 0; i < slicelen; ++i)
     {
-	PyObject	*item = ListItem(self, first + i);
+	PyObject	*item;
+
+	item = ListIndex(self, first + i*step);
 	if (item == NULL)
 	{
 	    Py_DECREF(list);
 	    return NULL;
 	}
 
-	PyList_SET_ITEM(list, ((reversed)?(n-i-1):(i)), item);
+	PyList_SET_ITEM(list, i, item);
     }
 
     return list;
 }
 
-typedef struct
-{
-    listwatch_T	lw;
-    list_T	*list;
-} listiterinfo_T;
-
-    static void
-ListIterDestruct(listiterinfo_T *lii)
-{
-    list_rem_watch(lii->list, &lii->lw);
-    PyMem_Free(lii);
-}
-
-    static PyObject *
-ListIterNext(listiterinfo_T **lii)
-{
-    PyObject	*ret;
-
-    if (!((*lii)->lw.lw_item))
-	return NULL;
-
-    if (!(ret = ConvertToPyObject(&((*lii)->lw.lw_item->li_tv))))
-	return NULL;
-
-    (*lii)->lw.lw_item = (*lii)->lw.lw_item->li_next;
-
-    return ret;
-}
-
     static PyObject *
-ListIter(ListObject *self)
+ListItem(ListObject *self, PyObject* idx)
 {
-    listiterinfo_T	*lii;
-    list_T	*l = self->list;
-
-    if (!(lii = PyMem_New(listiterinfo_T, 1)))
+#if PY_MAJOR_VERSION < 3
+    if (PyInt_Check(idx))
     {
-	PyErr_NoMemory();
-	return NULL;
+	long _idx = PyInt_AsLong(idx);
+	return ListIndex(self, _idx);
     }
-
-    list_add_watch(l, &lii->lw);
-    lii->lw.lw_item = l->lv_first;
-    lii->list = l;
-
-    return IterNew(lii,
-	    (destructorfun) ListIterDestruct, (nextfun) ListIterNext,
-	    NULL, NULL);
-}
-
-    static int
-ListAssItem(ListObject *self, Py_ssize_t index, PyObject *obj)
-{
-    typval_T	tv;
-    list_T	*l = self->list;
-    listitem_T	*li;
-    Py_ssize_t	length = ListLength(self);
-
-    if (l->lv_lock)
+    else
+#endif
+    if (PyLong_Check(idx))
     {
-	RAISE_LOCKED_LIST;
-	return -1;
+	long _idx = PyLong_AsLong(idx);
+	return ListIndex(self, _idx);
     }
-    if (index > length || (index == length && obj == NULL))
+    else if (PySlice_Check(idx))
     {
-	PyErr_SET_STRING(PyExc_IndexError, N_("list index out of range"));
-	return -1;
-    }
+	Py_ssize_t start, stop, step, slicelen;
 
-    if (obj == NULL)
+	if (PySlice_GetIndicesEx((PySliceObject_T *)idx, ListLength(self),
+				 &start, &stop, &step, &slicelen) < 0)
+	    return NULL;
+	return ListSlice(self, start, step, slicelen);
+    }
+    else
     {
-	li = list_find(l, (long) index);
-	list_remove(l, li, li);
-	clear_tv(&li->li_tv);
-	vim_free(li);
-	return 0;
+	RAISE_INVALID_INDEX_TYPE(idx);
+	return NULL;
     }
+}
 
-    if (ConvertFromPyObject(obj, &tv) == -1)
-	return -1;
-
-    if (index == length)
+    static void
+list_restore(Py_ssize_t numadded, Py_ssize_t numreplaced, Py_ssize_t slicelen,
+	list_T *l, listitem_T **lis, listitem_T *lastaddedli)
+{
+    while (numreplaced--)
     {
-	if (list_append_tv(l, &tv) == FAIL)
-	{
-	    clear_tv(&tv);
-	    PyErr_SET_VIM(N_("failed to add item to list"));
-	    return -1;
-	}
+	list_insert(l, lis[numreplaced], lis[slicelen + numreplaced]);
+	listitem_remove(l, lis[slicelen + numreplaced]);
     }
-    else
+    while (numadded--)
     {
-	li = list_find(l, (long) index);
-	clear_tv(&li->li_tv);
-	copy_tv(&tv, &li->li_tv);
-	clear_tv(&tv);
+	listitem_T	*next;
+
+	next = lastaddedli->li_prev;
+	listitem_remove(l, lastaddedli);
+	lastaddedli = next;
     }
-    return 0;
 }
 
     static int
-ListAssSlice(ListObject *self, Py_ssize_t first, Py_ssize_t last, PyObject *obj)
+ListAssSlice(ListObject *self, Py_ssize_t first,
+	     Py_ssize_t step, Py_ssize_t slicelen, PyObject *obj)
 {
-    PyInt	size = ListLength(self);
     PyObject	*iterator;
     PyObject	*item;
     listitem_T	*li;
+    listitem_T	*lastaddedli = NULL;
     listitem_T	*next;
     typval_T	v;
     list_T	*l = self->list;
     PyInt	i;
+    PyInt	j;
+    PyInt	numreplaced = 0;
+    PyInt	numadded = 0;
+    PyInt	size;
+    listitem_T	**lis = NULL;
+
+    size = ListLength(self);
 
     if (l->lv_lock)
     {
@@ -2401,7 +2385,42 @@
 	return -1;
     }
 
-    PROC_RANGE
+    if (step == 0)
+    {
+	PyErr_SET_STRING(PyExc_ValueError, N_("slice step cannot be zero"));
+	return -1;
+    }
+
+    if (step != 1 && slicelen == 0)
+    {
+	/* Nothing to do. Only error out if obj has some items. */
+	int		ret = 0;
+
+	if (obj == NULL)
+	    return 0;
+
+	if (!(iterator = PyObject_GetIter(obj)))
+	    return -1;
+
+	if ((item = PyIter_Next(iterator)))
+	{
+	    PyErr_FORMAT(PyExc_ValueError,
+		    N_("attempt to assign sequence of size greater than %d "
+			"to extended slice"), 0);
+	    Py_DECREF(item);
+	    ret = -1;
+	}
+	Py_DECREF(iterator);
+	return ret;
+    }
+
+    if (obj != NULL)
+	/* XXX May allocate zero bytes. */
+	if (!(lis = PyMem_New(listitem_T *, slicelen * 2)))
+	{
+	    PyErr_NoMemory();
+	    return -1;
+	}
 
     if (first == size)
 	li = NULL;
@@ -2412,17 +2431,33 @@
 	{
 	    PyErr_VIM_FORMAT(N_("internal error: no vim list item %d"),
 		    (int)first);
+	    if (obj != NULL)
+		PyMem_Free(lis);
 	    return -1;
 	}
-	if (last > first)
+	i = slicelen;
+	while (i-- && li != NULL)
 	{
-	    i = last - first;
-	    while (i-- && li != NULL)
-	    {
-		next = li->li_next;
+	    j = step;
+	    next = li;
+	    if (step > 0)
+		while (next != NULL && ((next = next->li_next) != NULL) && --j);
+	    else
+		while (next != NULL && ((next = next->li_prev) != NULL) && ++j);
+
+	    if (obj == NULL)
 		listitem_remove(l, li);
-		li = next;
-	    }
+	    else
+		lis[slicelen - i - 1] = li;
+
+	    li = next;
+	}
+	if (li == NULL && i != -1)
+	{
+	    PyErr_SET_VIM(N_("internal error: not enough list items"));
+	    if (obj != NULL)
+		PyMem_Free(lis);
+	    return -1;
 	}
     }
 
@@ -2430,33 +2465,172 @@
 	return 0;
 
     if (!(iterator = PyObject_GetIter(obj)))
+    {
+	PyMem_Free(lis);
 	return -1;
+    }
 
+    i = 0;
     while ((item = PyIter_Next(iterator)))
     {
 	if (ConvertFromPyObject(item, &v) == -1)
 	{
 	    Py_DECREF(iterator);
 	    Py_DECREF(item);
+	    PyMem_Free(lis);
 	    return -1;
 	}
 	Py_DECREF(item);
-	if (list_insert_tv(l, &v, li) == FAIL)
+	if (list_insert_tv(l, &v, numreplaced < slicelen
+				    ? lis[numreplaced]
+				    : li) == FAIL)
 	{
 	    clear_tv(&v);
 	    PyErr_SET_VIM(N_("internal error: failed to add item to list"));
+	    list_restore(numadded, numreplaced, slicelen, l, lis, lastaddedli);
+	    PyMem_Free(lis);
 	    return -1;
 	}
+	if (numreplaced < slicelen)
+	{
+	    lis[slicelen + numreplaced] = lis[numreplaced]->li_prev;
+	    vimlist_remove(l, lis[numreplaced], lis[numreplaced]);
+	    numreplaced++;
+	}
+	else
+	{
+	    if (li)
+		lastaddedli = li->li_prev;
+	    else
+		lastaddedli = l->lv_last;
+	    numadded++;
+	}
 	clear_tv(&v);
+	if (step != 1 && i >= slicelen)
+	{
+	    Py_DECREF(iterator);
+	    PyErr_FORMAT(PyExc_ValueError,
+		    N_("attempt to assign sequence of size greater than %d "
+			"to extended slice"), (int) slicelen);
+	    list_restore(numadded, numreplaced, slicelen, l, lis, lastaddedli);
+	    PyMem_Free(lis);
+	    return -1;
+	}
+	++i;
     }
     Py_DECREF(iterator);
 
+    if (step != 1 && i != slicelen)
+    {
+	PyErr_FORMAT2(PyExc_ValueError,
+		N_("attempt to assign sequence of size %d to extended slice "
+		    "of size %d"), (int) i, (int) slicelen);
+	list_restore(numadded, numreplaced, slicelen, l, lis, lastaddedli);
+	PyMem_Free(lis);
+	return -1;
+    }
+
     if (PyErr_Occurred())
+    {
+	list_restore(numadded, numreplaced, slicelen, l, lis, lastaddedli);
+	PyMem_Free(lis);
 	return -1;
+    }
+
+    for (i = 0; i < numreplaced; i++)
+	listitem_free(lis[i]);
+    if (step == 1)
+	for (i = numreplaced; i < slicelen; i++)
+	    listitem_remove(l, lis[i]);
+
+    PyMem_Free(lis);
 
     return 0;
 }
 
+    static int
+ListAssIndex(ListObject *self, Py_ssize_t index, PyObject *obj)
+{
+    typval_T	tv;
+    list_T	*l = self->list;
+    listitem_T	*li;
+    Py_ssize_t	length = ListLength(self);
+
+    if (l->lv_lock)
+    {
+	RAISE_LOCKED_LIST;
+	return -1;
+    }
+    if (index > length || (index == length && obj == NULL))
+    {
+	PyErr_SET_STRING(PyExc_IndexError, N_("list index out of range"));
+	return -1;
+    }
+
+    if (obj == NULL)
+    {
+	li = list_find(l, (long) index);
+	vimlist_remove(l, li, li);
+	clear_tv(&li->li_tv);
+	vim_free(li);
+	return 0;
+    }
+
+    if (ConvertFromPyObject(obj, &tv) == -1)
+	return -1;
+
+    if (index == length)
+    {
+	if (list_append_tv(l, &tv) == FAIL)
+	{
+	    clear_tv(&tv);
+	    PyErr_SET_VIM(N_("failed to add item to list"));
+	    return -1;
+	}
+    }
+    else
+    {
+	li = list_find(l, (long) index);
+	clear_tv(&li->li_tv);
+	copy_tv(&tv, &li->li_tv);
+	clear_tv(&tv);
+    }
+    return 0;
+}
+
+    static Py_ssize_t
+ListAssItem(ListObject *self, PyObject *idx, PyObject *obj)
+{
+#if PY_MAJOR_VERSION < 3
+    if (PyInt_Check(idx))
+    {
+	long _idx = PyInt_AsLong(idx);
+	return ListAssIndex(self, _idx, obj);
+    }
+    else
+#endif
+    if (PyLong_Check(idx))
+    {
+	long _idx = PyLong_AsLong(idx);
+	return ListAssIndex(self, _idx, obj);
+    }
+    else if (PySlice_Check(idx))
+    {
+	Py_ssize_t start, stop, step, slicelen;
+
+	if (PySlice_GetIndicesEx((PySliceObject_T *)idx, ListLength(self),
+				 &start, &stop, &step, &slicelen) < 0)
+	    return -1;
+	return ListAssSlice(self, start, step, slicelen,
+		obj);
+    }
+    else
+    {
+	RAISE_INVALID_INDEX_TYPE(idx);
+	return -1;
+    }
+}
+
     static PyObject *
 ListConcatInPlace(ListObject *self, PyObject *obj)
 {
@@ -2483,6 +2657,56 @@
     return (PyObject *)(self);
 }
 
+typedef struct
+{
+    listwatch_T	lw;
+    list_T	*list;
+} listiterinfo_T;
+
+    static void
+ListIterDestruct(listiterinfo_T *lii)
+{
+    list_rem_watch(lii->list, &lii->lw);
+    PyMem_Free(lii);
+}
+
+    static PyObject *
+ListIterNext(listiterinfo_T **lii)
+{
+    PyObject	*ret;
+
+    if (!((*lii)->lw.lw_item))
+	return NULL;
+
+    if (!(ret = ConvertToPyObject(&((*lii)->lw.lw_item->li_tv))))
+	return NULL;
+
+    (*lii)->lw.lw_item = (*lii)->lw.lw_item->li_next;
+
+    return ret;
+}
+
+    static PyObject *
+ListIter(ListObject *self)
+{
+    listiterinfo_T	*lii;
+    list_T	*l = self->list;
+
+    if (!(lii = PyMem_New(listiterinfo_T, 1)))
+    {
+	PyErr_NoMemory();
+	return NULL;
+    }
+
+    list_add_watch(l, &lii->lw);
+    lii->lw.lw_item = l->lv_first;
+    lii->list = l;
+
+    return IterNew(lii,
+	    (destructorfun) ListIterDestruct, (nextfun) ListIterNext,
+	    NULL, NULL);
+}
+
 static char *ListAttrs[] = {
     "locked",
     NULL
@@ -2530,6 +2754,25 @@
     }
 }
 
+static PySequenceMethods ListAsSeq = {
+    (lenfunc)		ListLength,	 /* sq_length,	  len(x)   */
+    (binaryfunc)	0,		 /* RangeConcat, sq_concat,  x+y   */
+    0,					 /* RangeRepeat, sq_repeat,  x*n   */
+    (PyIntArgFunc)	ListIndex,	 /* sq_item,	  x[i]	   */
+    0,					 /* was_sq_slice,     x[i:j]   */
+    (PyIntObjArgProc)	ListAssIndex,	 /* sq_as_item,  x[i]=v   */
+    0,					 /* was_sq_ass_slice, x[i:j]=v */
+    0,					 /* sq_contains */
+    (binaryfunc)	ListConcatInPlace,/* sq_inplace_concat */
+    0,					 /* sq_inplace_repeat */
+};
+
+static PyMappingMethods ListAsMapping = {
+    /* mp_length	*/ (lenfunc) ListLength,
+    /* mp_subscript     */ (binaryfunc) ListItem,
+    /* mp_ass_subscript */ (objobjargproc) ListAssItem,
+};
+
 static struct PyMethodDef ListMethods[] = {
     {"extend",	(PyCFunction)ListConcatInPlace,	METH_O,		""},
     {"__dir__",	(PyCFunction)ListDir,		METH_NOARGS,	""},
@@ -2708,10 +2951,10 @@
 typedef struct
 {
     PyObject_HEAD
-    int opt_type;
-    void *from;
-    checkfun Check;
-    PyObject *fromObj;
+    int		opt_type;
+    void	*from;
+    checkfun	Check;
+    PyObject	*fromObj;
 } OptionsObject;
 
     static int
@@ -2831,6 +3074,69 @@
 }
 
     static int
+OptionsContains(OptionsObject *self, PyObject *keyObject)
+{
+    char_u	*key;
+    PyObject	*todecref;
+
+    if (!(key = StringToChars(keyObject, &todecref)))
+	return -1;
+
+    if (*key == NUL)
+    {
+	Py_XDECREF(todecref);
+	return 0;
+    }
+
+    if (get_option_value_strict(key, NULL, NULL, self->opt_type, NULL))
+    {
+	Py_XDECREF(todecref);
+	return 1;
+    }
+    else
+    {
+	Py_XDECREF(todecref);
+	return 0;
+    }
+}
+
+typedef struct
+{
+    void	*lastoption;
+    int		opt_type;
+} optiterinfo_T;
+
+    static PyObject *
+OptionsIterNext(optiterinfo_T **oii)
+{
+    char_u	*name;
+
+    if ((name = option_iter_next(&((*oii)->lastoption), (*oii)->opt_type)))
+	return PyString_FromString((char *)name);
+
+    return NULL;
+}
+
+    static PyObject *
+OptionsIter(OptionsObject *self)
+{
+    optiterinfo_T	*oii;
+
+    if (!(oii = PyMem_New(optiterinfo_T, 1)))
+    {
+	PyErr_NoMemory();
+	return NULL;
+    }
+
+    oii->opt_type = self->opt_type;
+    oii->lastoption = NULL;
+
+    return IterNew(oii,
+	    (destructorfun) PyMem_Free, (nextfun) OptionsIterNext,
+	    NULL, NULL);
+}
+
+    static int
 set_option_value_err(char_u *key, int numval, char_u *stringval, int opt_flags)
 {
     char_u	*errmsg;
@@ -2973,11 +3279,14 @@
     else
     {
 	char_u		*val;
-	PyObject	*todecref;
+	PyObject	*todecref2;
 
-	if ((val = StringToChars(valObject, &todecref)))
+	if ((val = StringToChars(valObject, &todecref2)))
+	{
 	    ret = set_option_value_for(key, 0, val, opt_flags,
 				    self->opt_type, self->from);
+	    Py_XDECREF(todecref2);
+	}
 	else
 	    ret = -1;
     }
@@ -2987,6 +3296,19 @@
     return ret;
 }
 
+static PySequenceMethods OptionsAsSeq = {
+    0,					/* sq_length */
+    0,					/* sq_concat */
+    0,					/* sq_repeat */
+    0,					/* sq_item */
+    0,					/* sq_slice */
+    0,					/* sq_ass_item */
+    0,					/* sq_ass_slice */
+    (objobjproc) OptionsContains,	/* sq_contains */
+    0,					/* sq_inplace_concat */
+    0,					/* sq_inplace_repeat */
+};
+
 static PyMappingMethods OptionsAsMapping = {
     (lenfunc)       NULL,
     (binaryfunc)    OptionsItem,
@@ -3874,7 +4196,9 @@
 		    break;
 		}
 	    }
-	    if (buf == curbuf)
+	    if (buf == curbuf && (save_curwin != NULL || save_curbuf == NULL))
+		/* Using an existing window for the buffer, adjust the cursor
+		 * position. */
 		py_fix_cursor((linenr_T)lo, (linenr_T)hi, (linenr_T)-n);
 	    if (save_curbuf == NULL)
 		/* Only adjust marks if we managed to switch to a window that
@@ -5877,8 +6201,10 @@
     vim_memset(&OptionsType, 0, sizeof(OptionsType));
     OptionsType.tp_name = "vim.options";
     OptionsType.tp_basicsize = sizeof(OptionsObject);
+    OptionsType.tp_as_sequence = &OptionsAsSeq;
     OptionsType.tp_flags = Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC;
     OptionsType.tp_doc = "object for manipulating options";
+    OptionsType.tp_iter = (getiterfunc)OptionsIter;
     OptionsType.tp_as_mapping = &OptionsAsMapping;
     OptionsType.tp_dealloc = (destructor)OptionsDestructor;
     OptionsType.tp_traverse = (traverseproc)OptionsTraverse;
diff -Naur vim74.orig/src/if_python.c vim74/src/if_python.c
--- vim74.orig/src/if_python.c	2013-07-09 19:40:11.000000000 +0000
+++ vim74/src/if_python.c	2014-10-10 14:53:44.555380019 +0000
@@ -196,6 +196,7 @@
 # define PyTuple_Size dll_PyTuple_Size
 # define PyTuple_GetItem dll_PyTuple_GetItem
 # define PyTuple_Type (*dll_PyTuple_Type)
+# define PySlice_GetIndicesEx dll_PySlice_GetIndicesEx
 # define PyImport_ImportModule dll_PyImport_ImportModule
 # define PyDict_New dll_PyDict_New
 # define PyDict_GetItemString dll_PyDict_GetItemString
@@ -241,6 +242,7 @@
 # define PySys_GetObject dll_PySys_GetObject
 # define PySys_SetArgv dll_PySys_SetArgv
 # define PyType_Type (*dll_PyType_Type)
+# define PySlice_Type (*dll_PySlice_Type)
 # define PyType_Ready (*dll_PyType_Ready)
 # define PyType_GenericAlloc dll_PyType_GenericAlloc
 # define Py_BuildValue dll_Py_BuildValue
@@ -293,6 +295,9 @@
 #  define PyCObject_FromVoidPtr dll_PyCObject_FromVoidPtr
 #  define PyCObject_AsVoidPtr dll_PyCObject_AsVoidPtr
 # endif
+# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000
+#  define Py_NoSiteFlag (*dll_Py_NoSiteFlag)
+# endif
 
 /*
  * Pointers for dynamic link
@@ -341,6 +346,9 @@
 static PyInt(*dll_PyTuple_Size)(PyObject *);
 static PyObject*(*dll_PyTuple_GetItem)(PyObject *, PyInt);
 static PyTypeObject* dll_PyTuple_Type;
+static int (*dll_PySlice_GetIndicesEx)(PySliceObject *r, PyInt length,
+		     PyInt *start, PyInt *stop, PyInt *step,
+		     PyInt *slicelen);
 static PyObject*(*dll_PyImport_ImportModule)(const char *);
 static PyObject*(*dll_PyDict_New)(void);
 static PyObject*(*dll_PyDict_GetItemString)(PyObject *, const char *);
@@ -359,7 +367,7 @@
 static PyObject *(*dll_PyRun_String)(char *, int, PyObject *, PyObject *);
 static PyObject* (*dll_PyObject_GetAttrString)(PyObject *, const char *);
 static int (*dll_PyObject_HasAttrString)(PyObject *, const char *);
-static PyObject* (*dll_PyObject_SetAttrString)(PyObject *, const char *, PyObject *);
+static int (*dll_PyObject_SetAttrString)(PyObject *, const char *, PyObject *);
 static PyObject* (*dll_PyObject_CallFunctionObjArgs)(PyObject *, ...);
 static PyObject* (*dll_PyObject_CallFunction)(PyObject *, char *, ...);
 static PyObject* (*dll_PyObject_Call)(PyObject *, PyObject *, PyObject *);
@@ -382,6 +390,7 @@
 static PyObject *(*dll_PySys_GetObject)(char *);
 static int(*dll_PySys_SetArgv)(int, char **);
 static PyTypeObject* dll_PyType_Type;
+static PyTypeObject* dll_PySlice_Type;
 static int (*dll_PyType_Ready)(PyTypeObject *type);
 static PyObject* (*dll_PyType_GenericAlloc)(PyTypeObject *type, PyInt nitems);
 static PyObject*(*dll_Py_BuildValue)(char *, ...);
@@ -434,6 +443,9 @@
 static PyObject* (*dll_PyCObject_FromVoidPtr)(void *cobj, void (*destr)(void *));
 static void* (*dll_PyCObject_AsVoidPtr)(PyObject *);
 # endif
+# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000
+static int* dll_Py_NoSiteFlag;
+# endif
 
 static HINSTANCE hinstPython = 0; /* Instance of python.dll */
 
@@ -521,6 +533,7 @@
     {"PyTuple_GetItem", (PYTHON_PROC*)&dll_PyTuple_GetItem},
     {"PyTuple_Size", (PYTHON_PROC*)&dll_PyTuple_Size},
     {"PyTuple_Type", (PYTHON_PROC*)&dll_PyTuple_Type},
+    {"PySlice_GetIndicesEx", (PYTHON_PROC*)&dll_PySlice_GetIndicesEx},
     {"PyImport_ImportModule", (PYTHON_PROC*)&dll_PyImport_ImportModule},
     {"PyDict_GetItemString", (PYTHON_PROC*)&dll_PyDict_GetItemString},
     {"PyDict_Next", (PYTHON_PROC*)&dll_PyDict_Next},
@@ -562,6 +575,7 @@
     {"PySys_GetObject", (PYTHON_PROC*)&dll_PySys_GetObject},
     {"PySys_SetArgv", (PYTHON_PROC*)&dll_PySys_SetArgv},
     {"PyType_Type", (PYTHON_PROC*)&dll_PyType_Type},
+    {"PySlice_Type", (PYTHON_PROC*)&dll_PySlice_Type},
     {"PyType_Ready", (PYTHON_PROC*)&dll_PyType_Ready},
     {"PyType_GenericAlloc", (PYTHON_PROC*)&dll_PyType_GenericAlloc},
     {"Py_FindMethod", (PYTHON_PROC*)&dll_Py_FindMethod},
@@ -605,7 +619,7 @@
 #  endif
 # endif
 # if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02050000 \
-	&& SIZEOF_SIZE_T != SIZEOF_INT
+	&& SIZEOF_SIZE_T != VIM_SIZEOF_INT
 #  ifdef Py_DEBUG
     {"Py_InitModule4TraceRefs_64", (PYTHON_PROC*)&dll_Py_InitModule4},
 #  else
@@ -625,6 +639,9 @@
     {"PyCObject_FromVoidPtr", (PYTHON_PROC*)&dll_PyCObject_FromVoidPtr},
     {"PyCObject_AsVoidPtr", (PYTHON_PROC*)&dll_PyCObject_AsVoidPtr},
 # endif
+# if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000
+    {"Py_NoSiteFlag", (PYTHON_PROC*)&dll_Py_NoSiteFlag},
+# endif
     {"", NULL},
 };
 
@@ -795,6 +812,8 @@
 # define PY_STRSAVE(s) ((char_u *) py_memsave(s, STRLEN(s) + 1))
 #endif
 
+typedef PySliceObject PySliceObject_T;
+
 /*
  * Include the code shared with if_python3.c
  */
@@ -891,6 +910,10 @@
 {
     if (!initialised)
     {
+#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000
+	PyObject *site;
+#endif
+
 #ifdef DYNAMIC_PYTHON
 	if (!python_enabled(TRUE))
 	{
@@ -905,11 +928,29 @@
 
 	init_structs();
 
+#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000
+	/* Disable implicit 'import site', because it may cause Vim to exit
+	 * when it can't be found. */
+	Py_NoSiteFlag++;
+#endif
+
 #if !defined(MACOS) || defined(MACOS_X_UNIX)
 	Py_Initialize();
 #else
 	PyMac_Initialize();
 #endif
+
+#if defined(PY_VERSION_HEX) && PY_VERSION_HEX >= 0x02070000
+	/* 'import site' explicitly. */
+	site = PyImport_ImportModule("site");
+	if (site == NULL)
+	{
+	    EMSG(_("E887: Sorry, this command is disabled, the Python's site module could not be loaded."));
+	    goto fail;
+	}
+	Py_DECREF(site);
+#endif
+
 	/* Initialise threads, and below save the state using
 	 * PyEval_SaveThread.  Without the call to PyEval_SaveThread, thread
 	 * specific state (such as the system trace hook), will be lost
@@ -1472,21 +1513,6 @@
     return Py_FindMethod(DictionaryMethods, self, name);
 }
 
-static PySequenceMethods ListAsSeq = {
-    (PyInquiry)			ListLength,
-    (binaryfunc)		0,
-    (PyIntArgFunc)		0,
-    (PyIntArgFunc)		ListItem,
-    (PyIntIntArgFunc)		ListSlice,
-    (PyIntObjArgProc)		ListAssItem,
-    (PyIntIntObjArgProc)	ListAssSlice,
-    (objobjproc)		0,
-#if PY_MAJOR_VERSION >= 2
-    (binaryfunc)		ListConcatInPlace,
-    0,
-#endif
-};
-
     static PyObject *
 ListGetattr(PyObject *self, char *name)
 {
diff -Naur vim74.orig/src/if_python3.c vim74/src/if_python3.c
--- vim74.orig/src/if_python3.c	2013-07-09 19:53:21.000000000 +0000
+++ vim74/src/if_python3.c	2014-10-10 14:53:44.568713319 +0000
@@ -97,6 +97,19 @@
 #define Py_ssize_t_fmt "n"
 #define Py_bytes_fmt "y"
 
+#define PyIntArgFunc	ssizeargfunc
+#define PyIntObjArgProc	ssizeobjargproc
+
+/*
+ * PySlice_GetIndicesEx(): first argument type changed from PySliceObject
+ * to PyObject in Python 3.2 or later.
+ */
+#if PY_VERSION_HEX >= 0x030200f0
+typedef PyObject PySliceObject_T;
+#else
+typedef PySliceObject PySliceObject_T;
+#endif
+
 #if defined(DYNAMIC_PYTHON3) || defined(PROTO)
 
 # ifndef WIN3264
@@ -291,8 +304,9 @@
 static PyObject* (*py3_PyTuple_GetItem)(PyObject *, Py_ssize_t);
 static int (*py3_PyMapping_Check)(PyObject *);
 static PyObject* (*py3_PyMapping_Keys)(PyObject *);
-static int (*py3_PySlice_GetIndicesEx)(PyObject *r, Py_ssize_t length,
-		     Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength);
+static int (*py3_PySlice_GetIndicesEx)(PySliceObject_T *r, Py_ssize_t length,
+		     Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step,
+		     Py_ssize_t *slicelen);
 static PyObject* (*py3_PyErr_NoMemory)(void);
 static void (*py3_Py_Finalize)(void);
 static void (*py3_PyErr_SetString)(PyObject *, const char *);
@@ -302,7 +316,7 @@
 static PyObject* (*py3_PyRun_String)(char *, int, PyObject *, PyObject *);
 static PyObject* (*py3_PyObject_GetAttrString)(PyObject *, const char *);
 static int (*py3_PyObject_HasAttrString)(PyObject *, const char *);
-static PyObject* (*py3_PyObject_SetAttrString)(PyObject *, const char *, PyObject *);
+static int (*py3_PyObject_SetAttrString)(PyObject *, const char *, PyObject *);
 static PyObject* (*py3_PyObject_CallFunctionObjArgs)(PyObject *, ...);
 static PyObject* (*py3__PyObject_CallFunction_SizeT)(PyObject *, char *, ...);
 static PyObject* (*py3_PyObject_Call)(PyObject *, PyObject *, PyObject *);
@@ -1186,7 +1200,7 @@
 	if (CheckBuffer((BufferObject *) self))
 	    return NULL;
 
-	if (PySlice_GetIndicesEx((PyObject *)idx,
+	if (PySlice_GetIndicesEx((PySliceObject_T *)idx,
 	      (Py_ssize_t)((BufferObject *)(self))->buf->b_ml.ml_line_count,
 	      &start, &stop,
 	      &step, &slicelen) < 0)
@@ -1218,7 +1232,7 @@
 	if (CheckBuffer((BufferObject *) self))
 	    return -1;
 
-	if (PySlice_GetIndicesEx((PyObject *)idx,
+	if (PySlice_GetIndicesEx((PySliceObject_T *)idx,
 	      (Py_ssize_t)((BufferObject *)(self))->buf->b_ml.ml_line_count,
 	      &start, &stop,
 	      &step, &slicelen) < 0)
@@ -1302,7 +1316,7 @@
     {
 	Py_ssize_t start, stop, step, slicelen;
 
-	if (PySlice_GetIndicesEx((PyObject *)idx,
+	if (PySlice_GetIndicesEx((PySliceObject_T *)idx,
 		((RangeObject *)(self))->end-((RangeObject *)(self))->start+1,
 		&start, &stop,
 		&step, &slicelen) < 0)
@@ -1329,7 +1343,7 @@
     {
 	Py_ssize_t start, stop, step, slicelen;
 
-	if (PySlice_GetIndicesEx((PyObject *)idx,
+	if (PySlice_GetIndicesEx((PySliceObject_T *)idx,
 		((RangeObject *)(self))->end-((RangeObject *)(self))->start+1,
 		&start, &stop,
 		&step, &slicelen) < 0)
@@ -1478,76 +1492,6 @@
 /* List object - Definitions
  */
 
-static PySequenceMethods ListAsSeq = {
-    (lenfunc)		ListLength,	 /* sq_length,	  len(x)   */
-    (binaryfunc)	0,		 /* RangeConcat, sq_concat,  x+y   */
-    (ssizeargfunc)	0,		 /* RangeRepeat, sq_repeat,  x*n   */
-    (ssizeargfunc)	ListItem,	 /* sq_item,	  x[i]	   */
-    (void *)		0,		 /* was_sq_slice,     x[i:j]   */
-    (ssizeobjargproc)	ListAssItem,	 /* sq_as_item,  x[i]=v   */
-    (void *)		0,		 /* was_sq_ass_slice, x[i:j]=v */
-    0,					 /* sq_contains */
-    (binaryfunc)	ListConcatInPlace,/* sq_inplace_concat */
-    0,					 /* sq_inplace_repeat */
-};
-
-static PyObject *ListSubscript(PyObject *, PyObject *);
-static Py_ssize_t ListAsSubscript(PyObject *, PyObject *, PyObject *);
-
-static PyMappingMethods ListAsMapping = {
-    /* mp_length	*/ (lenfunc) ListLength,
-    /* mp_subscript     */ (binaryfunc) ListSubscript,
-    /* mp_ass_subscript */ (objobjargproc) ListAsSubscript,
-};
-
-    static PyObject *
-ListSubscript(PyObject *self, PyObject* idx)
-{
-    if (PyLong_Check(idx))
-    {
-	long _idx = PyLong_AsLong(idx);
-	return ListItem((ListObject *)(self), _idx);
-    }
-    else if (PySlice_Check(idx))
-    {
-	Py_ssize_t start, stop, step, slicelen;
-
-	if (PySlice_GetIndicesEx(idx, ListLength((ListObject *)(self)),
-				 &start, &stop, &step, &slicelen) < 0)
-	    return NULL;
-	return ListSlice((ListObject *)(self), start, stop);
-    }
-    else
-    {
-	RAISE_INVALID_INDEX_TYPE(idx);
-	return NULL;
-    }
-}
-
-    static Py_ssize_t
-ListAsSubscript(PyObject *self, PyObject *idx, PyObject *obj)
-{
-    if (PyLong_Check(idx))
-    {
-	long _idx = PyLong_AsLong(idx);
-	return ListAssItem((ListObject *)(self), _idx, obj);
-    }
-    else if (PySlice_Check(idx))
-    {
-	Py_ssize_t start, stop, step, slicelen;
-
-	if (PySlice_GetIndicesEx(idx, ListLength((ListObject *)(self)),
-				 &start, &stop, &step, &slicelen) < 0)
-	    return -1;
-	return ListAssSlice((ListObject *)(self), start, stop, obj);
-    }
-    else
-    {
-	RAISE_INVALID_INDEX_TYPE(idx);
-	return -1;
-    }
-}
-
     static PyObject *
 ListGetattro(PyObject *self, PyObject *nameobj)
 {
diff -Naur vim74.orig/src/if_ruby.c vim74/src/if_ruby.c
--- vim74.orig/src/if_ruby.c	2013-05-20 10:47:48.000000000 +0000
+++ vim74/src/if_ruby.c	2014-10-10 14:53:44.572046644 +0000
@@ -88,14 +88,20 @@
 # define rb_int2big rb_int2big_stub
 #endif
 
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20 \
-	&& SIZEOF_INT < SIZEOF_LONG
-/* Ruby 2.0 defines a number of static functions which use rb_fix2int and
- * rb_num2int if SIZEOF_INT < SIZEOF_LONG (64bit) */
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19 \
+	&& VIM_SIZEOF_INT < VIM_SIZEOF_LONG
+/* Ruby 1.9 defines a number of static functions which use rb_fix2int and
+ * rb_num2int if VIM_SIZEOF_INT < VIM_SIZEOF_LONG (64bit) */
 # define rb_fix2int rb_fix2int_stub
 # define rb_num2int rb_num2int_stub
 #endif
 
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 21
+/* Ruby 2.1 adds new GC called RGenGC and RARRAY_PTR uses
+ * rb_gc_writebarrier_unprotect_promoted if USE_RGENGC  */
+#  define rb_gc_writebarrier_unprotect_promoted rb_gc_writebarrier_unprotect_promoted_stub
+# endif
+
 #include <ruby.h>
 #ifdef RUBY19_OR_LATER
 # include <ruby/encoding.h>
@@ -196,9 +202,11 @@
 # define rb_hash_new			dll_rb_hash_new
 # define rb_inspect			dll_rb_inspect
 # define rb_int2inum			dll_rb_int2inum
-# if SIZEOF_INT < SIZEOF_LONG /* 64 bits only */
-#  define rb_fix2int			dll_rb_fix2int
-#  define rb_num2int			dll_rb_num2int
+# if VIM_SIZEOF_INT < VIM_SIZEOF_LONG /* 64 bits only */
+#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER <= 18
+#   define rb_fix2int			dll_rb_fix2int
+#   define rb_num2int			dll_rb_num2int
+#  endif
 #  define rb_num2uint			dll_rb_num2uint
 # endif
 # define rb_lastline_get			dll_rb_lastline_get
@@ -304,7 +312,7 @@
 static VALUE (*dll_rb_hash_new) (void);
 static VALUE (*dll_rb_inspect) (VALUE);
 static VALUE (*dll_rb_int2inum) (long);
-# if SIZEOF_INT < SIZEOF_LONG /* 64 bits only */
+# if VIM_SIZEOF_INT < VIM_SIZEOF_LONG /* 64 bits only */
 static long (*dll_rb_fix2int) (VALUE);
 static long (*dll_rb_num2int) (VALUE);
 static unsigned long (*dll_rb_num2uint) (VALUE);
@@ -373,6 +381,10 @@
 static void* (*ruby_process_options)(int, char**);
 # endif
 
+# if defined(USE_RGENGC) && USE_RGENGC
+static void (*dll_rb_gc_writebarrier_unprotect_promoted)(VALUE);
+# endif
+
 # if defined(RUBY19_OR_LATER) && !defined(PROTO)
 SIGNED_VALUE rb_num2long_stub(VALUE x)
 {
@@ -382,8 +394,8 @@
 {
     return dll_rb_int2big(x);
 }
-#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20 \
-	&& SIZEOF_INT < SIZEOF_LONG
+#  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 19 \
+	&& VIM_SIZEOF_INT < VIM_SIZEOF_LONG
 long rb_fix2int_stub(VALUE x)
 {
     return dll_rb_fix2int(x);
@@ -406,6 +418,13 @@
 #  endif
 # endif
 
+# if defined(USE_RGENGC) && USE_RGENGC
+void rb_gc_writebarrier_unprotect_promoted_stub(VALUE obj)
+{
+    return dll_rb_gc_writebarrier_unprotect_promoted(obj);
+}
+# endif
+
 static HINSTANCE hinstRuby = NULL; /* Instance of ruby.dll */
 
 /*
@@ -449,7 +468,7 @@
     {"rb_hash_new", (RUBY_PROC*)&dll_rb_hash_new},
     {"rb_inspect", (RUBY_PROC*)&dll_rb_inspect},
     {"rb_int2inum", (RUBY_PROC*)&dll_rb_int2inum},
-# if SIZEOF_INT < SIZEOF_LONG /* 64 bits only */
+# if VIM_SIZEOF_INT < VIM_SIZEOF_LONG /* 64 bits only */
     {"rb_fix2int", (RUBY_PROC*)&dll_rb_fix2int},
     {"rb_num2int", (RUBY_PROC*)&dll_rb_num2int},
     {"rb_num2uint", (RUBY_PROC*)&dll_rb_num2uint},
@@ -521,6 +540,9 @@
 #  endif
     {"ruby_init_stack", (RUBY_PROC*)&dll_ruby_init_stack},
 # endif
+# if defined(USE_RGENGC) && USE_RGENGC
+    {"rb_gc_writebarrier_unprotect_promoted", (RUBY_PROC*)&dll_rb_gc_writebarrier_unprotect_promoted},
+# endif
     {"", NULL},
 };
 
diff -Naur vim74.orig/src/if_tcl.c vim74/src/if_tcl.c
--- vim74.orig/src/if_tcl.c	2013-08-02 17:31:15.000000000 +0000
+++ vim74/src/if_tcl.c	2014-10-10 14:53:44.578713294 +0000
@@ -165,6 +165,7 @@
  */
 static HANDLE hTclLib = NULL;
 Tcl_Interp* (*dll_Tcl_CreateInterp)();
+void (*dll_Tcl_FindExecutable)(const void *);
 
 /*
  * Table of name to function pointer of tcl.
@@ -175,6 +176,7 @@
     TCL_PROC* ptr;
 } tcl_funcname_table[] = {
     {"Tcl_CreateInterp", (TCL_PROC*)&dll_Tcl_CreateInterp},
+    {"Tcl_FindExecutable", (TCL_PROC*)&dll_Tcl_FindExecutable},
     {NULL, NULL},
 };
 
@@ -248,11 +250,12 @@
     {
 	Tcl_Interp *interp;
 
+	dll_Tcl_FindExecutable(find_executable_arg);
+
 	if (interp = dll_Tcl_CreateInterp())
 	{
 	    if (Tcl_InitStubs(interp, DYNAMIC_TCL_VER, 0))
 	    {
-		Tcl_FindExecutable(find_executable_arg);
 		Tcl_DeleteInterp(interp);
 		stubs_initialized = TRUE;
 	    }
diff -Naur vim74.orig/src/installman.sh vim74/src/installman.sh
--- vim74.orig/src/installman.sh	2010-05-15 11:04:07.000000000 +0000
+++ vim74/src/installman.sh	2014-10-10 14:53:44.588713269 +0000
@@ -43,10 +43,13 @@
    fi
 fi
 
+# Note: setting LC_ALL to C is required to avoid illegal byte errors from sed
+# on some systems.
+
 if test $what = "install"; then
    # vim.1
    echo installing $destdir/$exename.1
-   sed -e s+/usr/local/lib/vim+$vimloc+ \
+   LC_ALL=C sed -e s+/usr/local/lib/vim+$vimloc+ \
 	   -e s+$vimloc/doc+$helpsubloc+ \
 	   -e s+$vimloc/print+$printsubloc+ \
 	   -e s+$vimloc/syntax+$synsubloc+ \
@@ -64,7 +67,7 @@
 
    # vimtutor.1
    echo installing $destdir/$exename""tutor.1
-   sed -e s+/usr/local/lib/vim+$vimloc+ \
+   LC_ALL=C sed -e s+/usr/local/lib/vim+$vimloc+ \
 	   -e s+$vimloc/tutor+$tutorsubloc+ \
 	   $helpsource/vimtutor$langadd.1 > $destdir/$exename""tutor.1
    chmod $manmod $destdir/$exename""tutor.1
@@ -76,7 +79,7 @@
 
    # evim.1
    echo installing $destdir/$evimname.1
-   sed -e s+/usr/local/lib/vim+$vimloc+ \
+   LC_ALL=C sed -e s+/usr/local/lib/vim+$vimloc+ \
 	   -e s+$vimloc/evim.vim+$scriptloc/evim.vim+ \
 	   $helpsource/evim$langadd.1 > $destdir/$evimname.1
    chmod $manmod $destdir/$evimname.1
diff -Naur vim74.orig/src/macros.h vim74/src/macros.h
--- vim74.orig/src/macros.h	2013-06-12 15:07:32.000000000 +0000
+++ vim74/src/macros.h	2014-10-10 14:53:44.612046544 +0000
@@ -264,7 +264,7 @@
 # define mb_ptr_adv(p)	    p += has_mbyte ? (*mb_ptr2len)(p) : 1
 /* Advance multi-byte pointer, do not skip over composing chars. */
 # define mb_cptr_adv(p)	    p += enc_utf8 ? utf_ptr2len(p) : has_mbyte ? (*mb_ptr2len)(p) : 1
-/* Backup multi-byte pointer. */
+/* Backup multi-byte pointer. Only use with "p" > "s" ! */
 # define mb_ptr_back(s, p)  p -= has_mbyte ? ((*mb_head_off)(s, p - 1) + 1) : 1
 /* get length of multi-byte char, not including composing chars */
 # define mb_cptr2len(p)	    (enc_utf8 ? utf_ptr2len(p) : (*mb_ptr2len)(p))
diff -Naur vim74.orig/src/main.c vim74/src/main.c
--- vim74.orig/src/main.c	2013-07-03 10:36:49.000000000 +0000
+++ vim74/src/main.c	2014-10-10 14:53:44.622046519 +0000
@@ -178,6 +178,14 @@
      */
     mch_early_init();
 
+#if defined(WIN32) && defined(FEAT_MBYTE)
+    /*
+     * MingW expands command line arguments, which confuses our code to
+     * convert when 'encoding' changes.  Get the unexpanded arguments.
+     */
+    argc = get_cmd_argsW(&argv);
+#endif
+
     /* Many variables are in "params" so that we can pass them to invoked
      * functions without a lot of arguments.  "argc" and "argv" are also
      * copied, so that they can be changed. */
@@ -322,6 +330,7 @@
     init_yank();		/* init yank buffers */
 
     alist_init(&global_alist);	/* Init the argument list to empty. */
+    global_alist.id = 0;
 
     /*
      * Set the default values for the options.
@@ -702,6 +711,11 @@
 	TIME_MSG("reading viminfo");
     }
 #endif
+#ifdef FEAT_EVAL
+    /* It's better to make v:oldfiles an empty list than NULL. */
+    if (get_vim_var_list(VV_OLDFILES) == NULL)
+	set_vim_var_list(VV_OLDFILES, list_alloc());
+#endif
 
 #ifdef FEAT_QUICKFIX
     /*
@@ -812,7 +826,7 @@
     starttermcap();	    /* start termcap if not done by wait_return() */
     TIME_MSG("start termcap");
 #if defined(FEAT_TERMRESPONSE) && defined(FEAT_MBYTE)
-    may_req_ambiguous_character_width();
+    may_req_ambiguous_char_width();
 #endif
 
 #ifdef FEAT_MOUSE
@@ -840,8 +854,7 @@
 #ifdef FEAT_CRYPT
     if (params.ask_for_key)
     {
-	(void)blowfish_self_test();
-	(void)get_crypt_key(TRUE, TRUE);
+	(void)crypt_get_key(TRUE, TRUE);
 	TIME_MSG("getting crypt key");
     }
 #endif
@@ -945,8 +958,17 @@
     if (p_im)
 	need_start_insertmode = TRUE;
 
+#ifdef FEAT_CLIPBOARD
+    if (clip_unnamed)
+       /* do not overwrite system clipboard while starting up */
+       clip_did_set_selection = -1;
+#endif
 #ifdef FEAT_AUTOCMD
     apply_autocmds(EVENT_VIMENTER, NULL, NULL, FALSE, curbuf);
+# ifdef FEAT_CLIPBOARD
+    if (clip_did_set_selection < 0)
+       clip_did_set_selection = TRUE;
+# endif
     TIME_MSG("VimEnter autocommands");
 #endif
 
@@ -1048,13 +1070,11 @@
     /* Setup to catch a terminating error from the X server.  Just ignore
      * it, restore the state and continue.  This might not always work
      * properly, but at least we don't exit unexpectedly when the X server
-     * exists while Vim is running in a console. */
+     * exits while Vim is running in a console. */
     if (!cmdwin && !noexmode && SETJMP(x_jump_env))
     {
 	State = NORMAL;
-# ifdef FEAT_VISUAL
 	VIsual_active = FALSE;
-# endif
 	got_int = TRUE;
 	need_wait_return = FALSE;
 	global_busy = FALSE;
@@ -1091,11 +1111,7 @@
 		check_timestamps(FALSE);
 	    if (need_wait_return)	/* if wait_return still needed ... */
 		wait_return(FALSE);	/* ... call it now */
-	    if (need_start_insertmode && goto_im()
-#ifdef FEAT_VISUAL
-		    && !VIsual_active
-#endif
-		    )
+	    if (need_start_insertmode && goto_im() && !VIsual_active)
 	    {
 		need_start_insertmode = FALSE;
 		stuffReadbuff((char_u *)"i");	/* start insert mode next */
@@ -1197,7 +1213,7 @@
 		diff_need_scrollbind = FALSE;
 	    }
 #endif
-#if defined(FEAT_FOLDING) && defined(FEAT_VISUAL)
+#if defined(FEAT_FOLDING)
 	    /* Include a closed fold completely in the Visual area. */
 	    foldAdjustVisual();
 #endif
@@ -1223,12 +1239,9 @@
 	    update_topline();
 	    validate_cursor();
 
-#ifdef FEAT_VISUAL
 	    if (VIsual_active)
 		update_curbuf(INVERTED);/* update inverted part */
-	    else
-#endif
-		if (must_redraw)
+	    else if (must_redraw)
 		update_screen(0);
 	    else if (redraw_cmdline || clear_cmdline)
 		showmode();
@@ -1245,9 +1258,9 @@
 		char_u *p;
 
 		/* msg_attr_keep() will set keep_msg to NULL, must free the
-		 * string here. */
+		 * string here. Don't reset keep_msg, msg_attr_keep() uses it
+		 * to check for duplicates. */
 		p = keep_msg;
-		keep_msg = NULL;
 		msg_attr(p, keep_msg_attr);
 		vim_free(p);
 	    }
@@ -1500,6 +1513,9 @@
     if (garbage_collect_at_exit)
 	garbage_collect();
 #endif
+#if defined(WIN32) && defined(FEAT_MBYTE)
+    free_cmd_argsW();
+#endif
 
     mch_exit(exitval);
 }
@@ -1606,6 +1622,7 @@
 
 #ifdef FEAT_EVAL
     set_vim_var_string(VV_PROGNAME, initstr, -1);
+    set_vim_var_string(VV_PROGPATH, (char_u *)parmp->argv[0], -1);
 #endif
 
     if (TOLOWER_ASC(initstr[0]) == 'r')
@@ -2727,6 +2744,7 @@
     int		arg_idx;		/* index in argument list */
     int		i;
     int		advance = TRUE;
+    win_T	*win;
 
 # ifdef FEAT_AUTOCMD
     /*
@@ -2816,24 +2834,22 @@
 # ifdef FEAT_AUTOCMD
     --autocmd_no_enter;
 # endif
+
+    /* make the first window the current window */
+    win = firstwin;
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-    /*
-     * Avoid making a preview window the current window.
-     */
-    if (firstwin->w_p_pvw)
+    /* Avoid making a preview window the current window. */
+    while (win->w_p_pvw)
     {
-       win_T   *win;
-
-       for (win = firstwin; win != NULL; win = win->w_next)
-           if (!win->w_p_pvw)
-           {
-               firstwin = win;
-               break;
-           }
+	win = win->w_next;
+	if (win == NULL)
+	{
+	    win = firstwin;
+	    break;
+	}
     }
 #endif
-    /* make the first window the current window */
-    win_enter(firstwin, FALSE);
+    win_enter(win, FALSE);
 
 # ifdef FEAT_AUTOCMD
     --autocmd_no_leave;
diff -Naur vim74.orig/src/mark.c vim74/src/mark.c
--- vim74.orig/src/mark.c	2013-08-02 15:22:10.000000000 +0000
+++ vim74/src/mark.c	2014-10-10 14:53:44.625379844 +0000
@@ -98,7 +98,6 @@
 	return OK;
     }
 
-#ifdef FEAT_VISUAL
     if (c == '<' || c == '>')
     {
 	if (c == '<')
@@ -110,7 +109,6 @@
 	    curbuf->b_visual.vi_mode = 'v';
 	return OK;
     }
-#endif
 
 #ifndef EBCDIC
     if (c > 'z')	    /* some islower() and isupper() cannot handle
@@ -340,9 +338,7 @@
     int		*fnum;
 {
     pos_T		*posp;
-#ifdef FEAT_VISUAL
     pos_T		*startp, *endp;
-#endif
     static pos_T	pos_copy;
 
     posp = NULL;
@@ -403,7 +399,6 @@
 	curwin->w_cursor = pos;
 	listcmd_busy = slcb;
     }
-#ifdef FEAT_VISUAL
     else if (c == '<' || c == '>')	/* start/end of visual area */
     {
 	startp = &buf->b_visual.vi_start;
@@ -428,7 +423,6 @@
 #endif
 	}
     }
-#endif
     else if (ASCII_ISLOWER(c))		/* normal named mark */
     {
 	posp = &(buf->b_namedm[c - 'a']);
@@ -757,10 +751,8 @@
     show_one_mark(']', arg, &curbuf->b_op_end, NULL, TRUE);
     show_one_mark('^', arg, &curbuf->b_last_insert, NULL, TRUE);
     show_one_mark('.', arg, &curbuf->b_last_change, NULL, TRUE);
-#ifdef FEAT_VISUAL
     show_one_mark('<', arg, &curbuf->b_visual.vi_start, NULL, TRUE);
     show_one_mark('>', arg, &curbuf->b_visual.vi_end, NULL, TRUE);
-#endif
     show_one_mark(-1, arg, NULL, NULL, FALSE);
 }
 
@@ -892,10 +884,8 @@
 		    case '.': curbuf->b_last_change.lnum = 0; break;
 		    case '[': curbuf->b_op_start.lnum    = 0; break;
 		    case ']': curbuf->b_op_end.lnum      = 0; break;
-#ifdef FEAT_VISUAL
 		    case '<': curbuf->b_visual.vi_start.lnum = 0; break;
 		    case '>': curbuf->b_visual.vi_end.lnum   = 0; break;
-#endif
 		    case ' ': break;
 		    default:  EMSG2(_(e_invarg2), p);
 			      return;
@@ -1085,11 +1075,9 @@
 	    one_adjust_nodel(&(curbuf->b_changelist[i].lnum));
 #endif
 
-#ifdef FEAT_VISUAL
 	/* Visual area */
 	one_adjust_nodel(&(curbuf->b_visual.vi_start.lnum));
 	one_adjust_nodel(&(curbuf->b_visual.vi_end.lnum));
-#endif
 
 #ifdef FEAT_QUICKFIX
 	/* quickfix marks */
@@ -1136,14 +1124,12 @@
 		    if (win->w_tagstack[i].fmark.fnum == fnum)
 			one_adjust_nodel(&(win->w_tagstack[i].fmark.mark.lnum));
 
-#ifdef FEAT_VISUAL
 	    /* the displayed Visual area */
 	    if (win->w_old_cursor_lnum != 0)
 	    {
 		one_adjust_nodel(&(win->w_old_cursor_lnum));
 		one_adjust_nodel(&(win->w_old_visual_lnum));
 	    }
-#endif
 
 	    /* topline and cursor position for windows with the same buffer
 	     * other than the current window */
@@ -1260,11 +1246,9 @@
 	col_adjust(&(curbuf->b_changelist[i]));
 #endif
 
-#ifdef FEAT_VISUAL
     /* Visual area */
     col_adjust(&(curbuf->b_visual.vi_start));
     col_adjust(&(curbuf->b_visual.vi_end));
-#endif
 
     /* previous context mark */
     col_adjust(&(curwin->w_pcmark));
@@ -1374,7 +1358,8 @@
 set_last_cursor(win)
     win_T	*win;
 {
-    win->w_buffer->b_last_cursor = win->w_cursor;
+    if (win->w_buffer != NULL)
+	win->w_buffer->b_last_cursor = win->w_cursor;
 }
 
 #if defined(EXITFREE) || defined(PROTO)
diff -Naur vim74.orig/src/mbyte.c vim74/src/mbyte.c
--- vim74.orig/src/mbyte.c	2013-07-05 18:07:21.000000000 +0000
+++ vim74/src/mbyte.c	2014-10-10 14:53:44.632046494 +0000
@@ -83,10 +83,18 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <windows.h>
+# if defined(FEAT_GUI) || defined(FEAT_XCLIPBOARD)
+#  include <X11/Xwindows.h>
+#  define WINBYTE wBYTE
+# else
+#  include <windows.h>
+#  define WINBYTE BYTE
+# endif
 # ifdef WIN32
 #  undef WIN32	    /* Some windows.h define WIN32, we don't want that here. */
 # endif
+#else
+# define WINBYTE BYTE
 #endif
 
 #if (defined(WIN3264) || defined(WIN32UNIX)) && !defined(__MINGW32__)
@@ -698,9 +706,9 @@
 	    /* enc_dbcs is set by setting 'fileencoding'.  It becomes a Windows
 	     * CodePage identifier, which we can pass directly in to Windows
 	     * API */
-	    n = IsDBCSLeadByteEx(enc_dbcs, (BYTE)i) ? 2 : 1;
+	    n = IsDBCSLeadByteEx(enc_dbcs, (WINBYTE)i) ? 2 : 1;
 #else
-# if defined(MACOS) || defined(__amigaos4__)
+# if defined(MACOS) || defined(__amigaos4__) || defined(__ANDROID__)
 	    /*
 	     * if mblen() is not available, character which MSB is turned on
 	     * are treated as leading byte character. (note : This assumption
@@ -947,8 +955,8 @@
 		{
 		    case 0x2121: /* ZENKAKU space */
 			return 0;
-		    case 0x2122: /* KU-TEN (Japanese comma) */
-		    case 0x2123: /* TOU-TEN (Japanese period) */
+		    case 0x2122: /* TOU-TEN (Japanese comma) */
+		    case 0x2123: /* KU-TEN (Japanese period) */
 		    case 0x2124: /* ZENKAKU comma */
 		    case 0x2125: /* ZENKAKU period */
 			return 1;
@@ -2477,9 +2485,9 @@
     /* sorted list of non-overlapping intervals */
     static struct clinterval
     {
-	unsigned short first;
-	unsigned short last;
-	unsigned short class;
+	unsigned int first;
+	unsigned int last;
+	unsigned int class;
     } classes[] =
     {
 	{0x037e, 0x037e, 1},		/* Greek question mark */
@@ -2529,6 +2537,7 @@
 	{0x2900, 0x2998, 1},		/* arrows, brackets, etc. */
 	{0x29d8, 0x29db, 1},
 	{0x29fc, 0x29fd, 1},
+	{0x2e00, 0x2e7f, 1},		/* supplemental punctuation */
 	{0x3000, 0x3000, 0},		/* ideographic space */
 	{0x3001, 0x3020, 1},		/* ideographic punctuation */
 	{0x3030, 0x3030, 1},
@@ -2544,6 +2553,10 @@
 	{0xff1a, 0xff20, 1},		/* half/fullwidth ASCII */
 	{0xff3b, 0xff40, 1},		/* half/fullwidth ASCII */
 	{0xff5b, 0xff65, 1},		/* half/fullwidth ASCII */
+	{0x20000, 0x2a6df, 0x4e00},	/* CJK Ideographs */
+	{0x2a700, 0x2b73f, 0x4e00},	/* CJK Ideographs */
+	{0x2b740, 0x2b81f, 0x4e00},	/* CJK Ideographs */
+	{0x2f800, 0x2fa1f, 0x4e00},	/* CJK Ideographs */
     };
     int bot = 0;
     int top = sizeof(classes) / sizeof(struct clinterval) - 1;
@@ -2563,9 +2576,9 @@
     while (top >= bot)
     {
 	mid = (bot + top) / 2;
-	if (classes[mid].last < c)
+	if (classes[mid].last < (unsigned int)c)
 	    bot = mid + 1;
-	else if (classes[mid].first > c)
+	else if (classes[mid].first > (unsigned int)c)
 	    top = mid - 1;
 	else
 	    return (int)classes[mid].class;
diff -Naur vim74.orig/src/memfile.c vim74/src/memfile.c
--- vim74.orig/src/memfile.c	2013-05-23 20:22:22.000000000 +0000
+++ vim74/src/memfile.c	2014-10-10 14:53:44.638713143 +0000
@@ -1358,7 +1358,7 @@
 	if (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)
 	    fcntl(mfp->mf_fd, F_SETFD, fdflags | FD_CLOEXEC);
 #endif
-#ifdef HAVE_SELINUX
+#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)
 	mch_copy_sec(fname, mfp->mf_fname);
 #endif
 	mch_hide(mfp->mf_fname);    /* try setting the 'hidden' flag */
diff -Naur vim74.orig/src/memline.c vim74/src/memline.c
--- vim74.orig/src/memline.c	2013-05-06 02:01:02.000000000 +0000
+++ vim74/src/memline.c	2014-10-10 14:53:44.645379793 +0000
@@ -63,6 +63,15 @@
 #define BLOCK0_ID1     '0'		    /* block 0 id 1 */
 #define BLOCK0_ID1_C0  'c'		    /* block 0 id 1 'cm' 0 */
 #define BLOCK0_ID1_C1  'C'		    /* block 0 id 1 'cm' 1 */
+#define BLOCK0_ID1_C2  'd'		    /* block 0 id 1 'cm' 2 */
+
+#if defined(FEAT_CRYPT)
+static int id1_codes[] = {
+    BLOCK0_ID1_C0,  /* CRYPT_M_ZIP */
+    BLOCK0_ID1_C1,  /* CRYPT_M_BF */
+    BLOCK0_ID1_C2,  /* CRYPT_M_BF2 */
+};
+#endif
 
 /*
  * pointer to a block, used in a pointer block
@@ -151,7 +160,7 @@
 struct block0
 {
     char_u	b0_id[2];	/* id for block 0: BLOCK0_ID0 and BLOCK0_ID1,
-				 * BLOCK0_ID1_C0, BLOCK0_ID1_C1 */
+				 * BLOCK0_ID1_C0, BLOCK0_ID1_C1, etc. */
     char_u	b0_version[10];	/* Vim version string */
     char_u	b0_page_size[4];/* number of bytes per page */
     char_u	b0_mtime[4];	/* last modification time of file */
@@ -226,6 +235,7 @@
 } upd_block0_T;
 
 #ifdef FEAT_CRYPT
+static void ml_set_mfp_crypt __ARGS((buf_T *buf));
 static void ml_set_b0_crypt __ARGS((buf_T *buf, ZERO_BL *b0p));
 #endif
 static int ml_check_b0_id __ARGS((ZERO_BL *b0p));
@@ -256,7 +266,7 @@
 static char_u *make_percent_swname __ARGS((char_u *dir, char_u *name));
 #endif
 #ifdef FEAT_CRYPT
-static void ml_crypt_prepare __ARGS((memfile_T *mfp, off_t offset, int reading));
+static cryptstate_T *ml_crypt_prepare __ARGS((memfile_T *mfp, off_t offset, int reading));
 #endif
 #ifdef FEAT_BYTEOFF
 static void ml_updatechunk __ARGS((buf_T *buf, long line, long len, int updtype));
@@ -289,6 +299,9 @@
     buf->b_ml.ml_chunksize = NULL;
 #endif
 
+    if (cmdmod.noswapfile)
+	buf->b_p_swf = FALSE;
+
     /*
      * When 'updatecount' is non-zero swap file may be opened later.
      */
@@ -356,8 +369,7 @@
 	b0p->b0_hname[B0_HNAME_SIZE - 1] = NUL;
 	long_to_char(mch_get_pid(), b0p->b0_pid);
 #ifdef FEAT_CRYPT
-	if (*buf->b_p_key != NUL)
-	    ml_set_b0_crypt(buf, b0p);
+	ml_set_b0_crypt(buf, b0p);
 #endif
     }
 
@@ -422,6 +434,25 @@
 
 #if defined(FEAT_CRYPT) || defined(PROTO)
 /*
+ * Prepare encryption for "buf" for the current key and method.
+ */
+    static void
+ml_set_mfp_crypt(buf)
+    buf_T	*buf;
+{
+    if (*buf->b_p_key != NUL)
+    {
+	int method_nr = crypt_get_method_nr(buf);
+
+	if (method_nr > CRYPT_M_ZIP)
+	{
+	    /* Generate a seed and store it in the memfile. */
+	    sha2_seed(buf->b_ml.ml_mfp->mf_seed, MF_SEED_LEN, NULL, 0);
+	}
+    }
+}
+
+/*
  * Prepare encryption for "buf" with block 0 "b0p".
  */
     static void
@@ -433,11 +464,11 @@
 	b0p->b0_id[1] = BLOCK0_ID1;
     else
     {
-	if (get_crypt_method(buf) == 0)
-	    b0p->b0_id[1] = BLOCK0_ID1_C0;
-	else
+	int method_nr = crypt_get_method_nr(buf);
+
+	b0p->b0_id[1] = id1_codes[method_nr];
+	if (method_nr > CRYPT_M_ZIP)
 	{
-	    b0p->b0_id[1] = BLOCK0_ID1_C1;
 	    /* Generate a seed and store it in block 0 and in the memfile. */
 	    sha2_seed(&b0p->b0_seed, MF_SEED_LEN, NULL, 0);
 	    mch_memmove(buf->b_ml.ml_mfp->mf_seed, &b0p->b0_seed, MF_SEED_LEN);
@@ -606,7 +637,7 @@
 	 * When 'updatecount' is 0 and 'noswapfile' there is no swap file.
 	 * For help files we will make a swap file now.
 	 */
-	if (p_uc != 0)
+	if (p_uc != 0 && !cmdmod.noswapfile)
 	    ml_open_file(buf);	    /* create a swap file */
 	return;
     }
@@ -719,7 +750,7 @@
     char_u	*dirp;
 
     mfp = buf->b_ml.ml_mfp;
-    if (mfp == NULL || mfp->mf_fd >= 0 || !buf->b_p_swf)
+    if (mfp == NULL || mfp->mf_fd >= 0 || !buf->b_p_swf || cmdmod.noswapfile)
 	return;		/* nothing to do */
 
 #ifdef FEAT_SPELL
@@ -841,8 +872,11 @@
     for (buf = firstbuf; buf != NULL; buf = buf->b_next)
 	ml_close(buf, del_file && ((buf->b_flags & BF_PRESERVED) == 0
 				 || vim_strchr(p_cpo, CPO_PRESERVE) == NULL));
+#ifdef FEAT_SPELL
+    spell_delete_wordlist();	/* delete the internal wordlist */
+#endif
 #ifdef TEMPDIRNAMES
-    vim_deltempdir();	    /* delete created temp directory */
+    vim_deltempdir();		/* delete created temp directory */
 #endif
 }
 
@@ -881,7 +915,8 @@
     if (b0p->b0_id[0] != BLOCK0_ID0
 	    || (b0p->b0_id[1] != BLOCK0_ID1
 		&& b0p->b0_id[1] != BLOCK0_ID1_C0
-		&& b0p->b0_id[1] != BLOCK0_ID1_C1)
+		&& b0p->b0_id[1] != BLOCK0_ID1_C1
+		&& b0p->b0_id[1] != BLOCK0_ID1_C2)
 	    )
 	return FAIL;
     return OK;
@@ -900,8 +935,19 @@
     ZERO_BL	*b0p;
 
     mfp = buf->b_ml.ml_mfp;
-    if (mfp == NULL || (hp = mf_get(mfp, (blocknr_T)0, 1)) == NULL)
+    if (mfp == NULL)
+	return;
+    hp = mf_get(mfp, (blocknr_T)0, 1);
+    if (hp == NULL)
+    {
+#ifdef FEAT_CRYPT
+	/* Possibly update the seed in the memfile before there is a block0. */
+	if (what == UB_CRYPT)
+	    ml_set_mfp_crypt(buf);
+#endif
 	return;
+    }
+
     b0p = (ZERO_BL *)(hp->bh_data);
     if (ml_check_b0_id(b0p) == FAIL)
 	EMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
@@ -1249,14 +1295,12 @@
     }
 
 #ifdef FEAT_CRYPT
-    if (b0p->b0_id[1] == BLOCK0_ID1_C0)
-	b0_cm = 0;
-    else if (b0p->b0_id[1] == BLOCK0_ID1_C1)
-    {
-	b0_cm = 1;
+    for (i = 0; i < (int)(sizeof(id1_codes) / sizeof(int)); ++i)
+	if (id1_codes[i] == b0p->b0_id[1])
+	    b0_cm = i;
+    if (b0_cm > 0)
 	mch_memmove(mfp->mf_seed, &b0p->b0_seed, MF_SEED_LEN);
-    }
-    set_crypt_method(buf, b0_cm);
+    crypt_set_cm_option(buf, b0_cm < 0 ? 0 : b0_cm);
 #else
     if (b0p->b0_id[1] != BLOCK0_ID1)
     {
@@ -1383,7 +1427,7 @@
 	}
 	else
 	    smsg((char_u *)_(need_key_msg), fname_used);
-	buf->b_p_key = get_crypt_key(FALSE, FALSE);
+	buf->b_p_key = crypt_get_key(FALSE, FALSE);
 	if (buf->b_p_key == NULL)
 	    buf->b_p_key = curbuf->b_p_key;
 	else if (*buf->b_p_key == NUL)
@@ -4014,6 +4058,13 @@
     else
 	retval = concat_fnames(dname, tail, TRUE);
 
+#ifdef WIN3264
+    if (retval != NULL)
+	for (t = gettail(retval); *t != NUL; mb_ptr_adv(t))
+	    if (*t == ':')
+		*t = '%';
+#endif
+
     return retval;
 }
 
@@ -4137,12 +4188,29 @@
 #ifndef SHORT_FNAME
     int		r;
 #endif
+    char_u	*buf_fname = buf->b_fname;
 
 #if !defined(SHORT_FNAME) \
-		     && ((!defined(UNIX) && !defined(OS2)) || defined(ARCHIE))
+		&& ((!defined(UNIX) && !defined(OS2)) || defined(ARCHIE))
 # define CREATE_DUMMY_FILE
     FILE	*dummyfd = NULL;
 
+# ifdef WIN3264
+    if (buf_fname != NULL && !mch_isFullName(buf_fname)
+				       && vim_strchr(gettail(buf_fname), ':'))
+    {
+	char_u *t;
+
+	buf_fname = vim_strsave(buf_fname);
+	if (buf_fname == NULL)
+	    buf_fname = buf->b_fname;
+	else
+	    for (t = gettail(buf_fname); *t != NUL; mb_ptr_adv(t))
+		if (*t == ':')
+		    *t = '%';
+    }
+# endif
+
     /*
      * If we start editing a new file, e.g. "test.doc", which resides on an
      * MSDOS compatible filesystem, it is possible that the file
@@ -4150,9 +4218,9 @@
      * this problem we temporarily create "test.doc".  Don't do this when the
      * check below for a 8.3 file name is used.
      */
-    if (!(buf->b_p_sn || buf->b_shortname) && buf->b_fname != NULL
-					     && mch_getperm(buf->b_fname) < 0)
-	dummyfd = mch_fopen((char *)buf->b_fname, "w");
+    if (!(buf->b_p_sn || buf->b_shortname) && buf_fname != NULL
+					     && mch_getperm(buf_fname) < 0)
+	dummyfd = mch_fopen((char *)buf_fname, "w");
 #endif
 
     /*
@@ -4171,7 +4239,7 @@
     if (dir_name == NULL)	    /* out of memory */
 	fname = NULL;
     else
-	fname = makeswapname(buf->b_fname, buf->b_ffname, buf, dir_name);
+	fname = makeswapname(buf_fname, buf->b_ffname, buf, dir_name);
 
     for (;;)
     {
@@ -4204,7 +4272,7 @@
 	     * It either contains two dots, is longer than 8 chars, or starts
 	     * with a dot.
 	     */
-	    tail = gettail(buf->b_fname);
+	    tail = gettail(buf_fname);
 	    if (       vim_strchr(tail, '.') != NULL
 		    || STRLEN(tail) > (size_t)8
 		    || *gettail(fname) == '.')
@@ -4273,7 +4341,7 @@
 		    {
 			buf->b_shortname = TRUE;
 			vim_free(fname);
-			fname = makeswapname(buf->b_fname, buf->b_ffname,
+			fname = makeswapname(buf_fname, buf->b_ffname,
 							       buf, dir_name);
 			continue;	/* try again with b_shortname set */
 		    }
@@ -4344,7 +4412,7 @@
 		{
 		    buf->b_shortname = TRUE;
 		    vim_free(fname);
-		    fname = makeswapname(buf->b_fname, buf->b_ffname,
+		    fname = makeswapname(buf_fname, buf->b_ffname,
 							       buf, dir_name);
 		    continue;	    /* try again with '.' replaced with '_' */
 		}
@@ -4356,7 +4424,7 @@
 	     * viewing a help file or when the path of the file is different
 	     * (happens when all .swp files are in one directory).
 	     */
-	    if (!recoverymode && buf->b_fname != NULL
+	    if (!recoverymode && buf_fname != NULL
 				&& !buf->b_help && !(buf->b_flags & BF_DUMMY))
 	    {
 		int		fd;
@@ -4433,7 +4501,7 @@
 		    {
 			fclose(dummyfd);
 			dummyfd = NULL;
-			mch_remove(buf->b_fname);
+			mch_remove(buf_fname);
 			did_use_dummy = TRUE;
 		    }
 #endif
@@ -4448,7 +4516,7 @@
 		     * user anyway.
 		     */
 		    if (swap_exists_action != SEA_NONE
-			    && has_autocmd(EVENT_SWAPEXISTS, buf->b_fname, buf))
+			    && has_autocmd(EVENT_SWAPEXISTS, buf_fname, buf))
 			choice = do_swapexists(buf, fname);
 
 		    if (choice == 0)
@@ -4549,7 +4617,7 @@
 #ifdef CREATE_DUMMY_FILE
 		    /* Going to try another name, need the dummy file again. */
 		    if (did_use_dummy)
-			dummyfd = mch_fopen((char *)buf->b_fname, "w");
+			dummyfd = mch_fopen((char *)buf_fname, "w");
 #endif
 		}
 	    }
@@ -4581,9 +4649,13 @@
     if (dummyfd != NULL)	/* file has been created temporarily */
     {
 	fclose(dummyfd);
-	mch_remove(buf->b_fname);
+	mch_remove(buf_fname);
     }
 #endif
+#ifdef WIN3264
+    if (buf_fname != buf->b_fname)
+	vim_free(buf_fname);
+#endif
     return fname;
 }
 
@@ -4782,6 +4854,7 @@
     char_u	*text_start;
     char_u	*new_data;
     int		text_len;
+    cryptstate_T *state;
 
     if (dp->db_id != DATA_ID)
 	return data;
@@ -4797,10 +4870,9 @@
     mch_memmove(new_data, dp, head_end - (char_u *)dp);
 
     /* Encrypt the text. */
-    crypt_push_state();
-    ml_crypt_prepare(mfp, offset, FALSE);
-    crypt_encode(text_start, text_len, new_data + dp->db_txt_start);
-    crypt_pop_state();
+    state = ml_crypt_prepare(mfp, offset, FALSE);
+    crypt_encode(state, text_start, text_len, new_data + dp->db_txt_start);
+    crypt_free_state(state);
 
     /* Clear the gap. */
     if (head_end < text_start)
@@ -4823,6 +4895,7 @@
     char_u	*head_end;
     char_u	*text_start;
     int		text_len;
+    cryptstate_T *state;
 
     if (dp->db_id == DATA_ID)
     {
@@ -4835,17 +4908,17 @@
 	    return;  /* data was messed up */
 
 	/* Decrypt the text in place. */
-	crypt_push_state();
-	ml_crypt_prepare(mfp, offset, TRUE);
-	crypt_decode(text_start, text_len);
-	crypt_pop_state();
+	state = ml_crypt_prepare(mfp, offset, TRUE);
+	crypt_decode_inplace(state, text_start, text_len);
+	crypt_free_state(state);
     }
 }
 
 /*
  * Prepare for encryption/decryption, using the key, seed and offset.
+ * Return an allocated cryptstate_T *.
  */
-    static void
+    static cryptstate_T *
 ml_crypt_prepare(mfp, offset, reading)
     memfile_T	*mfp;
     off_t	offset;
@@ -4853,38 +4926,37 @@
 {
     buf_T	*buf = mfp->mf_buffer;
     char_u	salt[50];
-    int		method;
+    int		method_nr;
     char_u	*key;
     char_u	*seed;
 
     if (reading && mfp->mf_old_key != NULL)
     {
 	/* Reading back blocks with the previous key/method/seed. */
-	method = mfp->mf_old_cm;
+	method_nr = mfp->mf_old_cm;
 	key = mfp->mf_old_key;
 	seed = mfp->mf_old_seed;
     }
     else
     {
-	method = get_crypt_method(buf);
+	method_nr = crypt_get_method_nr(buf);
 	key = buf->b_p_key;
 	seed = mfp->mf_seed;
     }
 
-    use_crypt_method = method;  /* select pkzip or blowfish */
-    if (method == 0)
+    if (method_nr == CRYPT_M_ZIP)
     {
+	/* For PKzip: Append the offset to the key, so that we use a different
+	 * key for every block. */
 	vim_snprintf((char *)salt, sizeof(salt), "%s%ld", key, (long)offset);
-	crypt_init_keys(salt);
-    }
-    else
-    {
-	/* Using blowfish, add salt and seed. We use the byte offset of the
-	 * block for the salt. */
-	vim_snprintf((char *)salt, sizeof(salt), "%ld", (long)offset);
-	bf_key_init(key, salt, (int)STRLEN(salt));
-	bf_ofb_init(seed, MF_SEED_LEN);
+	return crypt_create(method_nr, salt, NULL, 0, NULL, 0);
     }
+
+    /* Using blowfish or better: add salt and seed. We use the byte offset
+     * of the block for the salt. */
+    vim_snprintf((char *)salt, sizeof(salt), "%ld", (long)offset);
+    return crypt_create(method_nr, key, salt, (int)STRLEN(salt),
+							   seed, MF_SEED_LEN);
 }
 
 #endif
diff -Naur vim74.orig/src/menu.c vim74/src/menu.c
--- vim74.orig/src/menu.c	2011-04-11 13:17:21.000000000 +0000
+++ vim74/src/menu.c	2014-10-10 14:53:44.648713118 +0000
@@ -1640,7 +1640,6 @@
 	idx = MENU_INDEX_INSERT;
     else if (state & CMDLINE)
 	idx = MENU_INDEX_CMDLINE;
-#ifdef FEAT_VISUAL
     else if (VIsual_active)
     {
 	if (VIsual_select)
@@ -1648,7 +1647,6 @@
 	else
 	    idx = MENU_INDEX_VISUAL;
     }
-#endif
     else if (state == HITRETURN || state == ASKMORE)
 	idx = MENU_INDEX_CMDLINE;
     else if (finish_op)
@@ -1811,14 +1809,12 @@
     static int
 get_menu_mode()
 {
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	if (VIsual_select)
 	    return MENU_INDEX_SELECT;
 	return MENU_INDEX_VISUAL;
     }
-#endif
     if (State & INSERT)
 	return MENU_INDEX_INSERT;
     if ((State & CMDLINE) || State == ASKMORE || State == HITRETURN)
diff -Naur vim74.orig/src/message.c vim74/src/message.c
--- vim74.orig/src/message.c	2013-08-09 18:30:45.000000000 +0000
+++ vim74/src/message.c	2014-10-10 14:53:44.655379768 +0000
@@ -887,6 +887,8 @@
     int		oldState;
     int		tmpState;
     int		had_got_int;
+    int		save_Recording;
+    FILE	*save_scriptout;
 
     if (redraw == TRUE)
 	must_redraw = CLEAR;
@@ -957,11 +959,21 @@
 	     * typeahead buffer. */
 	    ++no_mapping;
 	    ++allow_keys;
+
+	    /* Temporarily disable Recording. If Recording is active, the
+	     * character will be recorded later, since it will be added to the
+	     * typebuf after the loop */
+	    save_Recording = Recording;
+	    save_scriptout = scriptout;
+	    Recording = FALSE;
+	    scriptout = NULL;
 	    c = safe_vgetc();
 	    if (had_got_int && !global_busy)
 		got_int = FALSE;
 	    --no_mapping;
 	    --allow_keys;
+	    Recording = save_Recording;
+	    scriptout = save_scriptout;
 
 #ifdef FEAT_CLIPBOARD
 	    /* Strange way to allow copying (yanking) a modeless selection at
@@ -4364,7 +4376,7 @@
 		    {
 			/* Don't put the #if inside memchr(), it can be a
 			 * macro. */
-#if SIZEOF_INT <= 2
+#if VIM_SIZEOF_INT <= 2
 			char *q = memchr(str_arg, '\0', precision);
 #else
 			/* memchr on HP does not like n > 2^31  !!! */
diff -Naur vim74.orig/src/misc1.c vim74/src/misc1.c
--- vim74.orig/src/misc1.c	2013-08-03 15:29:33.000000000 +0000
+++ vim74/src/misc1.c	2014-10-10 14:53:44.665379743 +0000
@@ -32,7 +32,7 @@
     int
 get_indent()
 {
-    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts);
+    return get_indent_str(ml_get_curline(), (int)curbuf->b_p_ts, FALSE);
 }
 
 /*
@@ -42,7 +42,7 @@
 get_indent_lnum(lnum)
     linenr_T	lnum;
 {
-    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts);
+    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);
 }
 
 #if defined(FEAT_FOLDING) || defined(PROTO)
@@ -55,7 +55,7 @@
     buf_T	*buf;
     linenr_T	lnum;
 {
-    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts);
+    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);
 }
 #endif
 
@@ -64,16 +64,24 @@
  * 'tabstop' at "ts"
  */
     int
-get_indent_str(ptr, ts)
+get_indent_str(ptr, ts, list)
     char_u	*ptr;
     int		ts;
+    int		list; /* if TRUE, count only screen size for tabs */
 {
     int		count = 0;
 
     for ( ; *ptr; ++ptr)
     {
-	if (*ptr == TAB)    /* count a tab for what it is worth */
-	    count += ts - (count % ts);
+	if (*ptr == TAB)
+	{
+	    if (!list || lcs_tab1)    /* count a tab for what it is worth */
+		count += ts - (count % ts);
+	    else
+		/* In list mode, when tab is not set, count screen char width
+		 * for Tab, displays: ^I */
+		count += ptr2cells(ptr);
+	}
 	else if (*ptr == ' ')
 	    ++count;		/* count a space for one */
 	else
@@ -303,10 +311,18 @@
 	ml_replace(curwin->w_cursor.lnum, newline, FALSE);
 	if (flags & SIN_CHANGED)
 	    changed_bytes(curwin->w_cursor.lnum, 0);
-	/* Correct saved cursor position if it's after the indent. */
-	if (saved_cursor.lnum == curwin->w_cursor.lnum
-				&& saved_cursor.col >= (colnr_T)(p - oldline))
-	    saved_cursor.col += ind_len - (colnr_T)(p - oldline);
+	/* Correct saved cursor position if it is in this line. */
+	if (saved_cursor.lnum == curwin->w_cursor.lnum)
+	{
+	    if (saved_cursor.col >= (colnr_T)(p - oldline))
+		/* cursor was after the indent, adjust for the number of
+		 * bytes added/removed */
+		saved_cursor.col += ind_len - (colnr_T)(p - oldline);
+	    else if (saved_cursor.col >= (colnr_T)(s - newline))
+		/* cursor was in the indent, and is now after it, put it back
+		 * at the start of the indent (replacing spaces with TAB) */
+		saved_cursor.col = (colnr_T)(s - newline);
+	}
 	retval = TRUE;
     }
     else
@@ -468,6 +484,61 @@
     return (int)col;
 }
 
+#if defined(FEAT_LINEBREAK) || defined(PROTO)
+/*
+ * Return appropriate space number for breakindent, taking influencing
+ * parameters into account. Window must be specified, since it is not
+ * necessarily always the current one.
+ */
+    int
+get_breakindent_win(wp, line)
+    win_T	*wp;
+    char_u	*line; /* start of the line */
+{
+    static int	    prev_indent = 0;  /* cached indent value */
+    static long	    prev_ts     = 0L; /* cached tabstop value */
+    static char_u   *prev_line = NULL; /* cached pointer to line */
+    static int	    prev_tick = 0;   /* changedtick of cached value */
+    int		    bri = 0;
+    /* window width minus window margin space, i.e. what rests for text */
+    const int	    eff_wwidth = W_WIDTH(wp)
+			    - ((wp->w_p_nu || wp->w_p_rnu)
+				&& (vim_strchr(p_cpo, CPO_NUMCOL) == NULL)
+						? number_width(wp) + 1 : 0);
+
+    /* used cached indent, unless pointer or 'tabstop' changed */
+    if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts
+				  || prev_tick != wp->w_buffer->b_changedtick)
+    {
+	prev_line = line;
+	prev_ts = wp->w_buffer->b_p_ts;
+	prev_tick = wp->w_buffer->b_changedtick;
+	prev_indent = get_indent_str(line,
+				     (int)wp->w_buffer->b_p_ts, wp->w_p_list);
+    }
+    bri = prev_indent + wp->w_p_brishift;
+
+    /* indent minus the length of the showbreak string */
+    if (wp->w_p_brisbr)
+	bri -= vim_strsize(p_sbr);
+
+    /* Add offset for number column, if 'n' is in 'cpoptions' */
+    bri += win_col_off2(wp);
+
+    /* never indent past left window margin */
+    if (bri < 0)
+	bri = 0;
+    /* always leave at least bri_min characters on the left,
+     * if text width is sufficient */
+    else if (bri > eff_wwidth - wp->w_p_brimin)
+	bri = (eff_wwidth - wp->w_p_brimin < 0)
+			    ? 0 : eff_wwidth - wp->w_p_brimin;
+
+    return bri;
+}
+#endif
+
+
 #if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)
 
 static int cin_is_cinword __ARGS((char_u *line));
@@ -670,7 +741,7 @@
 	/*
 	 * count white space on current line
 	 */
-	newindent = get_indent_str(saved_line, (int)curbuf->b_p_ts);
+	newindent = get_indent_str(saved_line, (int)curbuf->b_p_ts, FALSE);
 	if (newindent == 0 && !(flags & OPENLINE_COM_LIST))
 	    newindent = second_line_indent; /* for ^^D command in insert mode */
 
@@ -1193,7 +1264,7 @@
 					|| do_si
 #endif
 							   )
-			newindent = get_indent_str(leader, (int)curbuf->b_p_ts);
+			newindent = get_indent_str(leader, (int)curbuf->b_p_ts, FALSE);
 
 		    /* Add the indent offset */
 		    if (newindent + off < 0)
@@ -1397,7 +1468,7 @@
 #ifdef FEAT_SMARTINDENT
 	if (did_si)
 	{
-	    int        sw = (int)get_sw_value();
+	    int sw = (int)get_sw_value(curbuf);
 
 	    if (p_sr)
 		newindent -= newindent % sw;
@@ -1581,9 +1652,9 @@
 
 #if defined(FEAT_COMMENTS) || defined(PROTO)
 /*
- * get_leader_len() returns the length of the prefix of the given string
- * which introduces a comment.	If this string is not a comment then 0 is
- * returned.
+ * get_leader_len() returns the length in bytes of the prefix of the given
+ * string which introduces a comment.  If this string is not a comment then
+ * 0 is returned.
  * When "flags" is not NULL, it is set to point to the flags of the recognized
  * comment leader.
  * "backward" must be true for the "O" command.
@@ -1986,6 +2057,7 @@
     char_u	*s;
     int		lines = 0;
     int		width;
+    char_u	*line;
 
 #ifdef FEAT_DIFF
     /* Check for filler lines above this buffer line.  When folded the result
@@ -2001,12 +2073,12 @@
 	return lines + 1;
 #endif
 
-    s = ml_get_buf(wp->w_buffer, lnum, FALSE);
+    line = s = ml_get_buf(wp->w_buffer, lnum, FALSE);
 
     col = 0;
     while (*s != NUL && --column >= 0)
     {
-	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL);
+	col += win_lbr_chartabsize(wp, line, s, (colnr_T)col, NULL);
 	mb_ptr_adv(s);
     }
 
@@ -2018,7 +2090,7 @@
      * 'ts') -- webb.
      */
     if (*s == TAB && (State & NORMAL) && (!wp->w_p_list || lcs_tab1))
-	col += win_lbr_chartabsize(wp, s, (colnr_T)col, NULL) - 1;
+	col += win_lbr_chartabsize(wp, line, s, (colnr_T)col, NULL) - 1;
 
     /*
      * Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.
@@ -3117,6 +3189,9 @@
 	    if (hasAnyFolding(wp))
 		set_topline(wp, wp->w_topline);
 #endif
+	    /* relative numbering may require updating more */
+	    if (wp->w_p_rnu)
+		redraw_win_later(wp, SOME_VALID);
 	}
     }
 
@@ -4800,9 +4875,9 @@
 
     if (fname == NULL)
 	return (char_u *)"";
-    for (p1 = p2 = fname; *p2; )	/* find last part of path */
+    for (p1 = p2 = get_past_head(fname); *p2; )	/* find last part of path */
     {
-	if (vim_ispathsep(*p2))
+	if (vim_ispathsep_nocolon(*p2))
 	    p1 = p2 + 1;
 	mb_ptr_adv(p2);
     }
@@ -4921,7 +4996,8 @@
 }
 
 /*
- * return TRUE if 'c' is a path separator.
+ * Return TRUE if 'c' is a path separator.
+ * Note that for MS-Windows this includes the colon.
  */
     int
 vim_ispathsep(c)
@@ -4944,6 +5020,20 @@
 #endif
 }
 
+/*
+ * Like vim_ispathsep(c), but exclude the colon for MS-Windows.
+ */
+    int
+vim_ispathsep_nocolon(c)
+    int c;
+{
+    return vim_ispathsep(c)
+#ifdef BACKSLASH_IN_FILENAME
+	&& c != ':'
+#endif
+	;
+}
+
 #if defined(FEAT_SEARCHPATH) || defined(PROTO)
 /*
  * return TRUE if 'c' is a path list separator.
@@ -5168,11 +5258,18 @@
 #if defined(FEAT_CINDENT) || defined(FEAT_SYN_HL)
 
 static char_u	*skip_string __ARGS((char_u *p));
+static pos_T *ind_find_start_comment __ARGS((void));
 
 /*
  * Find the start of a comment, not knowing if we are in a comment right now.
  * Search starts at w_cursor.lnum and goes backwards.
  */
+    static pos_T *
+ind_find_start_comment()	    /* XXX */
+{
+    return find_start_comment(curbuf->b_ind_maxcomment);
+}
+
     pos_T *
 find_start_comment(ind_maxcomment)	    /* XXX */
     int		ind_maxcomment;
@@ -5286,11 +5383,12 @@
 static char_u	*cin_skipcomment __ARGS((char_u *));
 static int	cin_nocode __ARGS((char_u *));
 static pos_T	*find_line_comment __ARGS((void));
+static int	cin_has_js_key __ARGS((char_u *text));
 static int	cin_islabel_skip __ARGS((char_u **));
 static int	cin_isdefault __ARGS((char_u *));
 static char_u	*after_label __ARGS((char_u *l));
 static int	get_indent_nolabel __ARGS((linenr_T lnum));
-static int	skip_label __ARGS((linenr_T, char_u **pp, int ind_maxcomment));
+static int	skip_label __ARGS((linenr_T, char_u **pp));
 static int	cin_first_id_amount __ARGS((void));
 static int	cin_get_equal_amount __ARGS((linenr_T lnum));
 static int	cin_ispreproc __ARGS((char_u *));
@@ -5299,28 +5397,27 @@
 static int	cin_islinecomment __ARGS((char_u *));
 static int	cin_isterminated __ARGS((char_u *, int, int));
 static int	cin_isinit __ARGS((void));
-static int	cin_isfuncdecl __ARGS((char_u **, linenr_T, linenr_T, int, int));
+static int	cin_isfuncdecl __ARGS((char_u **, linenr_T, linenr_T));
 static int	cin_isif __ARGS((char_u *));
 static int	cin_iselse __ARGS((char_u *));
 static int	cin_isdo __ARGS((char_u *));
-static int	cin_iswhileofdo __ARGS((char_u *, linenr_T, int));
+static int	cin_iswhileofdo __ARGS((char_u *, linenr_T));
 static int	cin_is_if_for_while_before_offset __ARGS((char_u *line, int *poffset));
-static int	cin_iswhileofdo_end __ARGS((int terminated, int	ind_maxparen, int ind_maxcomment));
+static int	cin_iswhileofdo_end __ARGS((int terminated));
 static int	cin_isbreak __ARGS((char_u *));
 static int	cin_is_cpp_baseclass __ARGS((colnr_T *col));
-static int	get_baseclass_amount __ARGS((int col, int ind_maxparen, int ind_maxcomment, int ind_cpp_baseclass));
+static int	get_baseclass_amount __ARGS((int col));
 static int	cin_ends_in __ARGS((char_u *, char_u *, char_u *));
 static int	cin_starts_with __ARGS((char_u *s, char *word));
 static int	cin_skip2pos __ARGS((pos_T *trypos));
-static pos_T	*find_start_brace __ARGS((int));
-static pos_T	*find_match_paren __ARGS((int, int));
-static int	corr_ind_maxparen __ARGS((int ind_maxparen, pos_T *startpos));
+static pos_T	*find_start_brace __ARGS((void));
+static pos_T	*find_match_paren __ARGS((int));
+static pos_T	*find_match_char __ARGS((int c, int ind_maxparen));
+static int	corr_ind_maxparen __ARGS((pos_T *startpos));
 static int	find_last_paren __ARGS((char_u *l, int start, int end));
-static int	find_match __ARGS((int lookfor, linenr_T ourscope, int ind_maxparen, int ind_maxcomment));
+static int	find_match __ARGS((int lookfor, linenr_T ourscope));
 static int	cin_is_cpp_namespace __ARGS((char_u *));
 
-static int	ind_hash_comment = 0;   /* # starts a comment */
-
 /*
  * Skip over white space and C comments within the line.
  * Also skip over Perl/shell comments if desired.
@@ -5337,7 +5434,7 @@
 
 	/* Perl/shell # comment comment continues until eol.  Require a space
 	 * before # to avoid recognizing $#array. */
-	if (ind_hash_comment != 0 && s != prev_s && *s == '#')
+	if (curbuf->b_ind_hash_comment != 0 && s != prev_s && *s == '#')
 	{
 	    s += STRLEN(s);
 	    break;
@@ -5400,7 +5497,38 @@
 }
 
 /*
+ * Return TRUE if "text" starts with "key:".
+ */
+    static int
+cin_has_js_key(text)
+    char_u *text;
+{
+    char_u *s = skipwhite(text);
+    int	    quote = -1;
+
+    if (*s == '\'' || *s == '"')
+    {
+	/* can be 'key': or "key": */
+	quote = *s;
+	++s;
+    }
+    if (!vim_isIDc(*s))	    /* need at least one ID character */
+	return FALSE;
+
+    while (vim_isIDc(*s))
+	++s;
+    if (*s == quote)
+	++s;
+
+    s = cin_skipcomment(s);
+
+    /* "::" is not a label, it's C++ */
+    return (*s == ':' && s[1] != ':');
+}
+
+/*
  * Check if string matches "label:"; move to character after ':' if true.
+ * "*s" must point to the start of the label, if there is one.
  */
     static int
 cin_islabel_skip(s)
@@ -5423,8 +5551,7 @@
  * Note: curwin->w_cursor must be where we are looking for the label.
  */
     int
-cin_islabel(ind_maxcomment)		/* XXX */
-    int		ind_maxcomment;
+cin_islabel()		/* XXX */
 {
     char_u	*s;
 
@@ -5458,7 +5585,7 @@
 	     * If we're in a comment now, skip to the start of the comment.
 	     */
 	    curwin->w_cursor.col = 0;
-	    if ((trypos = find_start_comment(ind_maxcomment)) != NULL) /* XXX */
+	    if ((trypos = ind_find_start_comment()) != NULL) /* XXX */
 		curwin->w_cursor = *trypos;
 
 	    line = ml_get_curline();
@@ -5704,10 +5831,9 @@
  *		^
  */
     static int
-skip_label(lnum, pp, ind_maxcomment)
+skip_label(lnum, pp)
     linenr_T	lnum;
     char_u	**pp;
-    int		ind_maxcomment;
 {
     char_u	*l;
     int		amount;
@@ -5717,8 +5843,7 @@
     curwin->w_cursor.lnum = lnum;
     l = ml_get_curline();
 				    /* XXX */
-    if (cin_iscase(l, FALSE) || cin_isscopedecl(l)
-					       || cin_islabel(ind_maxcomment))
+    if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel())
     {
 	amount = get_indent_nolabel(lnum);
 	l = after_label(ml_get_curline());
@@ -5962,12 +6087,10 @@
  * "min_lnum" is the line before which we will not be looking.
  */
     static int
-cin_isfuncdecl(sp, first_lnum, min_lnum, ind_maxparen, ind_maxcomment)
+cin_isfuncdecl(sp, first_lnum, min_lnum)
     char_u	**sp;
     linenr_T	first_lnum;
     linenr_T	min_lnum;
-    int		ind_maxparen;
-    int		ind_maxcomment;
 {
     char_u	*s;
     linenr_T	lnum = first_lnum;
@@ -5981,7 +6104,7 @@
 	s = *sp;
 
     if (find_last_paren(s, '(', ')')
-	&& (trypos = find_match_paren(ind_maxparen, ind_maxcomment)) != NULL)
+	&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
     {
 	lnum = trypos->lnum;
 	if (lnum < min_lnum)
@@ -6089,10 +6212,9 @@
  * ')' and ';'. The condition may be spread over several lines.
  */
     static int
-cin_iswhileofdo(p, lnum, ind_maxparen)	    /* XXX */
+cin_iswhileofdo(p, lnum)	    /* XXX */
     char_u	*p;
     linenr_T	lnum;
-    int		ind_maxparen;
 {
     pos_T	cursor_save;
     pos_T	*trypos;
@@ -6112,7 +6234,8 @@
 	    ++p;
 	    ++curwin->w_cursor.col;
 	}
-	if ((trypos = findmatchlimit(NULL, 0, 0, ind_maxparen)) != NULL
+	if ((trypos = findmatchlimit(NULL, 0, 0,
+					      curbuf->b_ind_maxparen)) != NULL
 		&& *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')
 	    retval = TRUE;
 	curwin->w_cursor = cursor_save;
@@ -6175,10 +6298,8 @@
  * Adjust the cursor to the line with "while".
  */
     static int
-cin_iswhileofdo_end(terminated, ind_maxparen, ind_maxcomment)
+cin_iswhileofdo_end(terminated)
     int	    terminated;
-    int	    ind_maxparen;
-    int	    ind_maxcomment;
 {
     char_u	*line;
     char_u	*p;
@@ -6202,7 +6323,7 @@
 		 * before the matching '('.  XXX */
 		i = (int)(p - line);
 		curwin->w_cursor.col = i;
-		trypos = find_match_paren(ind_maxparen, ind_maxcomment);
+		trypos = find_match_paren(curbuf->b_ind_maxparen);
 		if (trypos != NULL)
 		{
 		    s = cin_skipcomment(ml_get(trypos->lnum));
@@ -6394,11 +6515,8 @@
 }
 
     static int
-get_baseclass_amount(col, ind_maxparen, ind_maxcomment, ind_cpp_baseclass)
+get_baseclass_amount(col)
     int		col;
-    int		ind_maxparen;
-    int		ind_maxcomment;
-    int		ind_cpp_baseclass;
 {
     int		amount;
     colnr_T	vcol;
@@ -6408,11 +6526,10 @@
     {
 	amount = get_indent();
 	if (find_last_paren(ml_get_curline(), '(', ')')
-		&& (trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
+		&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
 	    amount = get_indent_lnum(trypos->lnum); /* XXX */
 	if (!cin_ends_in(ml_get_curline(), (char_u *)",", NULL))
-	    amount += ind_cpp_baseclass;
+	    amount += curbuf->b_ind_cpp_baseclass;
     }
     else
     {
@@ -6420,8 +6537,8 @@
 	getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);
 	amount = (int)vcol;
     }
-    if (amount < ind_cpp_baseclass)
-	amount = ind_cpp_baseclass;
+    if (amount < curbuf->b_ind_cpp_baseclass)
+	amount = curbuf->b_ind_cpp_baseclass;
     return amount;
 }
 
@@ -6505,8 +6622,7 @@
 /* }	    */
 
     static pos_T *
-find_start_brace(ind_maxcomment)	    /* XXX */
-    int		ind_maxcomment;
+find_start_brace()	    /* XXX */
 {
     pos_T	cursor_save;
     pos_T	*trypos;
@@ -6522,7 +6638,7 @@
 	pos = NULL;
 	/* ignore the { if it's in a // or / *  * / comment */
 	if ((colnr_T)cin_skip2pos(trypos) == trypos->col
-		&& (pos = find_start_comment(ind_maxcomment)) == NULL) /* XXX */
+		       && (pos = ind_find_start_comment()) == NULL) /* XXX */
 	    break;
 	if (pos != NULL)
 	    curwin->w_cursor.lnum = pos->lnum;
@@ -6532,20 +6648,27 @@
 }
 
 /*
- * Find the matching '(', failing if it is in a comment.
+ * Find the matching '(', ignoring it if it is in a comment.
  * Return NULL if no match found.
  */
     static pos_T *
-find_match_paren(ind_maxparen, ind_maxcomment)	    /* XXX */
+find_match_paren(ind_maxparen)	    /* XXX */
+    int		ind_maxparen;
+{
+    return find_match_char('(', ind_maxparen);
+}
+
+    static pos_T *
+find_match_char(c, ind_maxparen)	    /* XXX */
+    int		c;
     int		ind_maxparen;
-    int		ind_maxcomment;
 {
     pos_T	cursor_save;
     pos_T	*trypos;
     static pos_T pos_copy;
 
     cursor_save = curwin->w_cursor;
-    if ((trypos = findmatchlimit(NULL, '(', 0, ind_maxparen)) != NULL)
+    if ((trypos = findmatchlimit(NULL, c, 0, ind_maxparen)) != NULL)
     {
 	/* check if the ( is in a // comment */
 	if ((colnr_T)cin_skip2pos(trypos) > trypos->col)
@@ -6555,7 +6678,7 @@
 	    pos_copy = *trypos;	    /* copy trypos, findmatch will change it */
 	    trypos = &pos_copy;
 	    curwin->w_cursor = *trypos;
-	    if (find_start_comment(ind_maxcomment) != NULL) /* XXX */
+	    if (ind_find_start_comment() != NULL) /* XXX */
 		trypos = NULL;
 	}
     }
@@ -6564,21 +6687,46 @@
 }
 
 /*
+ * Find the matching '(', ignoring it if it is in a comment or before an
+ * unmatched {.
+ * Return NULL if no match found.
+ */
+    static pos_T *
+find_match_paren_after_brace(ind_maxparen)	    /* XXX */
+    int		ind_maxparen;
+{
+    pos_T	*trypos = find_match_paren(ind_maxparen);
+
+    if (trypos != NULL)
+    {
+	pos_T	*tryposBrace = find_start_brace();
+
+	/* If both an unmatched '(' and '{' is found.  Ignore the '('
+	 * position if the '{' is further down. */
+	if (tryposBrace != NULL
+		&& (trypos->lnum != tryposBrace->lnum
+		    ? trypos->lnum < tryposBrace->lnum
+		    : trypos->col < tryposBrace->col))
+	    trypos = NULL;
+    }
+    return trypos;
+}
+
+/*
  * Return ind_maxparen corrected for the difference in line number between the
  * cursor position and "startpos".  This makes sure that searching for a
  * matching paren above the cursor line doesn't find a match because of
  * looking a few lines further.
  */
     static int
-corr_ind_maxparen(ind_maxparen, startpos)
-    int		ind_maxparen;
+corr_ind_maxparen(startpos)
     pos_T	*startpos;
 {
     long	n = (long)startpos->lnum - (long)curwin->w_cursor.lnum;
 
-    if (n > 0 && n < ind_maxparen / 2)
-	return ind_maxparen - (int)n;
-    return ind_maxparen;
+    if (n > 0 && n < curbuf->b_ind_maxparen / 2)
+	return curbuf->b_ind_maxparen - (int)n;
+    return curbuf->b_ind_maxparen;
 }
 
 /*
@@ -6616,201 +6764,229 @@
     return retval;
 }
 
-    int
-get_c_indent()
+/*
+ * Parse 'cinoptions' and set the values in "curbuf".
+ * Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.
+ */
+    void
+parse_cino(buf)
+    buf_T	*buf;
 {
-    int sw = (int)get_sw_value();
+    char_u	*p;
+    char_u	*l;
+    char_u	*digits;
+    int		n;
+    int		divider;
+    int		fraction = 0;
+    int		sw = (int)get_sw_value(buf);
 
     /*
-     * spaces from a block's opening brace the prevailing indent for that
-     * block should be
+     * Set the default values.
      */
+    /* Spaces from a block's opening brace the prevailing indent for that
+     * block should be. */
+    buf->b_ind_level = sw;
 
-    int ind_level = sw;
+    /* Spaces from the edge of the line an open brace that's at the end of a
+     * line is imagined to be. */
+    buf->b_ind_open_imag = 0;
 
-    /*
-     * spaces from the edge of the line an open brace that's at the end of a
-     * line is imagined to be.
-     */
-    int ind_open_imag = 0;
+    /* Spaces from the prevailing indent for a line that is not preceded by
+     * an opening brace. */
+    buf->b_ind_no_brace = 0;
 
-    /*
-     * spaces from the prevailing indent for a line that is not preceded by
-     * an opening brace.
-     */
-    int ind_no_brace = 0;
+    /* Column where the first { of a function should be located }. */
+    buf->b_ind_first_open = 0;
 
-    /*
-     * column where the first { of a function should be located }
-     */
-    int ind_first_open = 0;
+    /* Spaces from the prevailing indent a leftmost open brace should be
+     * located. */
+    buf->b_ind_open_extra = 0;
 
-    /*
-     * spaces from the prevailing indent a leftmost open brace should be
-     * located
-     */
-    int ind_open_extra = 0;
-
-    /*
-     * spaces from the matching open brace (real location for one at the left
+    /* Spaces from the matching open brace (real location for one at the left
      * edge; imaginary location from one that ends a line) the matching close
-     * brace should be located
-     */
-    int ind_close_extra = 0;
+     * brace should be located. */
+    buf->b_ind_close_extra = 0;
 
-    /*
-     * spaces from the edge of the line an open brace sitting in the leftmost
-     * column is imagined to be
-     */
-    int ind_open_left_imag = 0;
+    /* Spaces from the edge of the line an open brace sitting in the leftmost
+     * column is imagined to be. */
+    buf->b_ind_open_left_imag = 0;
 
-    /*
-     * Spaces jump labels should be shifted to the left if N is non-negative,
-     * otherwise the jump label will be put to column 1.
-     */
-    int ind_jump_label = -1;
+    /* Spaces jump labels should be shifted to the left if N is non-negative,
+     * otherwise the jump label will be put to column 1. */
+    buf->b_ind_jump_label = -1;
 
-    /*
-     * spaces from the switch() indent a "case xx" label should be located
-     */
-    int ind_case = sw;
+    /* Spaces from the switch() indent a "case xx" label should be located. */
+    buf->b_ind_case = sw;
 
-    /*
-     * spaces from the "case xx:" code after a switch() should be located
-     */
-    int ind_case_code = sw;
+    /* Spaces from the "case xx:" code after a switch() should be located. */
+    buf->b_ind_case_code = sw;
 
-    /*
-     * lineup break at end of case in switch() with case label
-     */
-    int ind_case_break = 0;
+    /* Lineup break at end of case in switch() with case label. */
+    buf->b_ind_case_break = 0;
 
-    /*
-     * spaces from the class declaration indent a scope declaration label
-     * should be located
-     */
-    int ind_scopedecl = sw;
+    /* Spaces from the class declaration indent a scope declaration label
+     * should be located. */
+    buf->b_ind_scopedecl = sw;
 
-    /*
-     * spaces from the scope declaration label code should be located
-     */
-    int ind_scopedecl_code = sw;
+    /* Spaces from the scope declaration label code should be located. */
+    buf->b_ind_scopedecl_code = sw;
 
-    /*
-     * amount K&R-style parameters should be indented
-     */
-    int ind_param = sw;
+    /* Amount K&R-style parameters should be indented. */
+    buf->b_ind_param = sw;
 
-    /*
-     * amount a function type spec should be indented
-     */
-    int ind_func_type = sw;
+    /* Amount a function type spec should be indented. */
+    buf->b_ind_func_type = sw;
 
-    /*
-     * amount a cpp base class declaration or constructor initialization
-     * should be indented
-     */
-    int ind_cpp_baseclass = sw;
+    /* Amount a cpp base class declaration or constructor initialization
+     * should be indented. */
+    buf->b_ind_cpp_baseclass = sw;
 
-    /*
-     * additional spaces beyond the prevailing indent a continuation line
-     * should be located
-     */
-    int ind_continuation = sw;
+    /* additional spaces beyond the prevailing indent a continuation line
+     * should be located. */
+    buf->b_ind_continuation = sw;
 
-    /*
-     * spaces from the indent of the line with an unclosed parentheses
-     */
-    int ind_unclosed = sw * 2;
+    /* Spaces from the indent of the line with an unclosed parentheses. */
+    buf->b_ind_unclosed = sw * 2;
 
-    /*
-     * spaces from the indent of the line with an unclosed parentheses, which
-     * itself is also unclosed
-     */
-    int ind_unclosed2 = sw;
+    /* Spaces from the indent of the line with an unclosed parentheses, which
+     * itself is also unclosed. */
+    buf->b_ind_unclosed2 = sw;
 
-    /*
-     * suppress ignoring spaces from the indent of a line starting with an
-     * unclosed parentheses.
-     */
-    int ind_unclosed_noignore = 0;
+    /* Suppress ignoring spaces from the indent of a line starting with an
+     * unclosed parentheses. */
+    buf->b_ind_unclosed_noignore = 0;
 
-    /*
-     * If the opening paren is the last nonwhite character on the line, and
-     * ind_unclosed_wrapped is nonzero, use this indent relative to the outer
-     * context (for very long lines).
-     */
-    int ind_unclosed_wrapped = 0;
+    /* If the opening paren is the last nonwhite character on the line, and
+     * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer
+     * context (for very long lines). */
+    buf->b_ind_unclosed_wrapped = 0;
 
-    /*
-     * suppress ignoring white space when lining up with the character after
-     * an unclosed parentheses.
-     */
-    int ind_unclosed_whiteok = 0;
+    /* Suppress ignoring white space when lining up with the character after
+     * an unclosed parentheses. */
+    buf->b_ind_unclosed_whiteok = 0;
 
-    /*
-     * indent a closing parentheses under the line start of the matching
-     * opening parentheses.
-     */
-    int ind_matching_paren = 0;
+    /* Indent a closing parentheses under the line start of the matching
+     * opening parentheses. */
+    buf->b_ind_matching_paren = 0;
 
-    /*
-     * indent a closing parentheses under the previous line.
-     */
-    int ind_paren_prev = 0;
+    /* Indent a closing parentheses under the previous line. */
+    buf->b_ind_paren_prev = 0;
 
-    /*
-     * Extra indent for comments.
-     */
-    int ind_comment = 0;
+    /* Extra indent for comments. */
+    buf->b_ind_comment = 0;
 
-    /*
-     * spaces from the comment opener when there is nothing after it.
-     */
-    int ind_in_comment = 3;
+    /* Spaces from the comment opener when there is nothing after it. */
+    buf->b_ind_in_comment = 3;
 
-    /*
-     * boolean: if non-zero, use ind_in_comment even if there is something
-     * after the comment opener.
-     */
-    int ind_in_comment2 = 0;
+    /* Boolean: if non-zero, use b_ind_in_comment even if there is something
+     * after the comment opener. */
+    buf->b_ind_in_comment2 = 0;
 
-    /*
-     * max lines to search for an open paren
-     */
-    int ind_maxparen = 20;
+    /* Max lines to search for an open paren. */
+    buf->b_ind_maxparen = 20;
 
-    /*
-     * max lines to search for an open comment
-     */
-    int ind_maxcomment = 70;
+    /* Max lines to search for an open comment. */
+    buf->b_ind_maxcomment = 70;
 
-    /*
-     * handle braces for java code
-     */
-    int	ind_java = 0;
+    /* Handle braces for java code. */
+    buf->b_ind_java = 0;
 
-    /*
-     * not to confuse JS object properties with labels
-     */
-    int ind_js = 0;
+    /* Not to confuse JS object properties with labels. */
+    buf->b_ind_js = 0;
 
-    /*
-     * handle blocked cases correctly
-     */
-    int ind_keep_case_label = 0;
+    /* Handle blocked cases correctly. */
+    buf->b_ind_keep_case_label = 0;
 
-    /*
-     * handle C++ namespace
-     */
-    int ind_cpp_namespace = 0;
+    /* Handle C++ namespace. */
+    buf->b_ind_cpp_namespace = 0;
 
-    /*
-     * handle continuation lines containing conditions of if(), for() and
-     * while()
-     */
-    int ind_if_for_while = 0;
+    /* Handle continuation lines containing conditions of if(), for() and
+     * while(). */
+    buf->b_ind_if_for_while = 0;
 
+    for (p = buf->b_p_cino; *p; )
+    {
+	l = p++;
+	if (*p == '-')
+	    ++p;
+	digits = p;	    /* remember where the digits start */
+	n = getdigits(&p);
+	divider = 0;
+	if (*p == '.')	    /* ".5s" means a fraction */
+	{
+	    fraction = atol((char *)++p);
+	    while (VIM_ISDIGIT(*p))
+	    {
+		++p;
+		if (divider)
+		    divider *= 10;
+		else
+		    divider = 10;
+	    }
+	}
+	if (*p == 's')	    /* "2s" means two times 'shiftwidth' */
+	{
+	    if (p == digits)
+		n = sw;	/* just "s" is one 'shiftwidth' */
+	    else
+	    {
+		n *= sw;
+		if (divider)
+		    n += (sw * fraction + divider / 2) / divider;
+	    }
+	    ++p;
+	}
+	if (l[1] == '-')
+	    n = -n;
+
+	/* When adding an entry here, also update the default 'cinoptions' in
+	 * doc/indent.txt, and add explanation for it! */
+	switch (*l)
+	{
+	    case '>': buf->b_ind_level = n; break;
+	    case 'e': buf->b_ind_open_imag = n; break;
+	    case 'n': buf->b_ind_no_brace = n; break;
+	    case 'f': buf->b_ind_first_open = n; break;
+	    case '{': buf->b_ind_open_extra = n; break;
+	    case '}': buf->b_ind_close_extra = n; break;
+	    case '^': buf->b_ind_open_left_imag = n; break;
+	    case 'L': buf->b_ind_jump_label = n; break;
+	    case ':': buf->b_ind_case = n; break;
+	    case '=': buf->b_ind_case_code = n; break;
+	    case 'b': buf->b_ind_case_break = n; break;
+	    case 'p': buf->b_ind_param = n; break;
+	    case 't': buf->b_ind_func_type = n; break;
+	    case '/': buf->b_ind_comment = n; break;
+	    case 'c': buf->b_ind_in_comment = n; break;
+	    case 'C': buf->b_ind_in_comment2 = n; break;
+	    case 'i': buf->b_ind_cpp_baseclass = n; break;
+	    case '+': buf->b_ind_continuation = n; break;
+	    case '(': buf->b_ind_unclosed = n; break;
+	    case 'u': buf->b_ind_unclosed2 = n; break;
+	    case 'U': buf->b_ind_unclosed_noignore = n; break;
+	    case 'W': buf->b_ind_unclosed_wrapped = n; break;
+	    case 'w': buf->b_ind_unclosed_whiteok = n; break;
+	    case 'm': buf->b_ind_matching_paren = n; break;
+	    case 'M': buf->b_ind_paren_prev = n; break;
+	    case ')': buf->b_ind_maxparen = n; break;
+	    case '*': buf->b_ind_maxcomment = n; break;
+	    case 'g': buf->b_ind_scopedecl = n; break;
+	    case 'h': buf->b_ind_scopedecl_code = n; break;
+	    case 'j': buf->b_ind_java = n; break;
+	    case 'J': buf->b_ind_js = n; break;
+	    case 'l': buf->b_ind_keep_case_label = n; break;
+	    case '#': buf->b_ind_hash_comment = n; break;
+	    case 'N': buf->b_ind_cpp_namespace = n; break;
+	    case 'k': buf->b_ind_if_for_while = n; break;
+	}
+	if (*p == ',')
+	    ++p;
+    }
+}
+
+    int
+get_c_indent()
+{
     pos_T	cur_curpos;
     int		amount;
     int		scope_amount;
@@ -6820,6 +6996,7 @@
     char_u	*linecopy;
     pos_T	*trypos;
     pos_T	*tryposBrace = NULL;
+    pos_T	tryposBraceCopy;
     pos_T	our_paren_pos;
     char_u	*start;
     int		start_brace;
@@ -6842,13 +7019,11 @@
 #define LOOKFOR_NOBREAK		8
 #define LOOKFOR_CPP_BASECLASS	9
 #define LOOKFOR_ENUM_OR_INIT	10
+#define LOOKFOR_JS_KEY		11
+#define LOOKFOR_NO_COMMA	12
 
     int		whilelevel;
     linenr_T	lnum;
-    char_u	*options;
-    char_u	*digits;
-    int		fraction = 0;	    /* init for GCC */
-    int		divider;
     int		n;
     int		iscase;
     int		lookfor_break;
@@ -6856,84 +7031,10 @@
     int		cont_amount = 0;    /* amount for continuation line */
     int		original_line_islabel;
     int		added_to_amount = 0;
+    int		js_cur_has_key = 0;
 
-    for (options = curbuf->b_p_cino; *options; )
-    {
-	l = options++;
-	if (*options == '-')
-	    ++options;
-	digits = options;	    /* remember where the digits start */
-	n = getdigits(&options);
-	divider = 0;
-	if (*options == '.')	    /* ".5s" means a fraction */
-	{
-	    fraction = atol((char *)++options);
-	    while (VIM_ISDIGIT(*options))
-	    {
-		++options;
-		if (divider)
-		    divider *= 10;
-		else
-		    divider = 10;
-	    }
-	}
-	if (*options == 's')	    /* "2s" means two times 'shiftwidth' */
-	{
-	    if (options == digits)
-		n = sw;	/* just "s" is one 'shiftwidth' */
-	    else
-	    {
-		n *= sw;
-		if (divider)
-		    n += (sw * fraction + divider / 2) / divider;
-	    }
-	    ++options;
-	}
-	if (l[1] == '-')
-	    n = -n;
-	/* When adding an entry here, also update the default 'cinoptions' in
-	 * doc/indent.txt, and add explanation for it! */
-	switch (*l)
-	{
-	    case '>': ind_level = n; break;
-	    case 'e': ind_open_imag = n; break;
-	    case 'n': ind_no_brace = n; break;
-	    case 'f': ind_first_open = n; break;
-	    case '{': ind_open_extra = n; break;
-	    case '}': ind_close_extra = n; break;
-	    case '^': ind_open_left_imag = n; break;
-	    case 'L': ind_jump_label = n; break;
-	    case ':': ind_case = n; break;
-	    case '=': ind_case_code = n; break;
-	    case 'b': ind_case_break = n; break;
-	    case 'p': ind_param = n; break;
-	    case 't': ind_func_type = n; break;
-	    case '/': ind_comment = n; break;
-	    case 'c': ind_in_comment = n; break;
-	    case 'C': ind_in_comment2 = n; break;
-	    case 'i': ind_cpp_baseclass = n; break;
-	    case '+': ind_continuation = n; break;
-	    case '(': ind_unclosed = n; break;
-	    case 'u': ind_unclosed2 = n; break;
-	    case 'U': ind_unclosed_noignore = n; break;
-	    case 'W': ind_unclosed_wrapped = n; break;
-	    case 'w': ind_unclosed_whiteok = n; break;
-	    case 'm': ind_matching_paren = n; break;
-	    case 'M': ind_paren_prev = n; break;
-	    case ')': ind_maxparen = n; break;
-	    case '*': ind_maxcomment = n; break;
-	    case 'g': ind_scopedecl = n; break;
-	    case 'h': ind_scopedecl_code = n; break;
-	    case 'j': ind_java = n; break;
-	    case 'J': ind_js = n; break;
-	    case 'l': ind_keep_case_label = n; break;
-	    case '#': ind_hash_comment = n; break;
-	    case 'N': ind_cpp_namespace = n; break;
-	    case 'k': ind_if_for_while = n; break;
-	}
-	if (*options == ',')
-	    ++options;
-    }
+    /* make a copy, value is changed below */
+    int		ind_continuation = curbuf->b_ind_continuation;
 
     /* remember where the cursor was when we started */
     cur_curpos = curwin->w_cursor;
@@ -6967,22 +7068,21 @@
 
     curwin->w_cursor.col = 0;
 
-    original_line_islabel = cin_islabel(ind_maxcomment);  /* XXX */
+    original_line_islabel = cin_islabel();  /* XXX */
 
     /*
      * #defines and so on always go at the left when included in 'cinkeys'.
      */
     if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))
-    {
-	amount = 0;
-    }
+	amount = curbuf->b_ind_hash_comment;
 
     /*
      * Is it a non-case label?	Then that goes at the left margin too unless:
      *  - JS flag is set.
      *  - 'L' item has a positive value.
      */
-    else if (original_line_islabel && !ind_js && ind_jump_label < 0)
+    else if (original_line_islabel && !curbuf->b_ind_js
+					      && curbuf->b_ind_jump_label < 0)
     {
 	amount = 0;
     }
@@ -7004,7 +7104,8 @@
      * comment, try using the 'comments' option.
      */
     else if (!cin_iscomment(theline)
-	    && (trypos = find_start_comment(ind_maxcomment)) != NULL) /* XXX */
+			       && (trypos = ind_find_start_comment()) != NULL)
+	/* XXX */
     {
 	int	lead_start_len = 2;
 	int	lead_middle_len = 1;
@@ -7138,7 +7239,7 @@
 	    }
 	    if (amount == -1)			    /* use the comment opener */
 	    {
-		if (!ind_in_comment2)
+		if (!curbuf->b_ind_in_comment2)
 		{
 		    start = ml_get(trypos->lnum);
 		    look = start + trypos->col + 2; /* skip / and * */
@@ -7147,18 +7248,28 @@
 		}
 		getvcol(curwin, trypos, &col, NULL, NULL);
 		amount = col;
-		if (ind_in_comment2 || *look == NUL)
-		    amount += ind_in_comment;
+		if (curbuf->b_ind_in_comment2 || *look == NUL)
+		    amount += curbuf->b_ind_in_comment;
 	    }
 	}
     }
 
     /*
+     * Are we looking at a ']' that has a match?
+     */
+    else if (*skipwhite(theline) == ']'
+	    && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL)
+    {
+	/* align with the line containing the '['. */
+	amount = get_indent_lnum(trypos->lnum);
+    }
+
+    /*
      * Are we inside parentheses or braces?
      */						    /* XXX */
-    else if (((trypos = find_match_paren(ind_maxparen, ind_maxcomment)) != NULL
-		&& ind_java == 0)
-	    || (tryposBrace = find_start_brace(ind_maxcomment)) != NULL
+    else if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL
+		&& curbuf->b_ind_java == 0)
+	    || (tryposBrace = find_start_brace()) != NULL
 	    || trypos != NULL)
     {
       if (trypos != NULL && tryposBrace != NULL)
@@ -7179,7 +7290,7 @@
 	 * If the matching paren is more than one line away, use the indent of
 	 * a previous non-empty line that matches the same paren.
 	 */
-	if (theline[0] == ')' && ind_paren_prev)
+	if (theline[0] == ')' && curbuf->b_ind_paren_prev)
 	{
 	    /* Line up with the start of the matching paren line. */
 	    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);  /* XXX */
@@ -7198,7 +7309,7 @@
 		curwin->w_cursor.lnum = lnum;
 
 		/* Skip a comment. XXX */
-		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
+		if ((trypos = ind_find_start_comment()) != NULL)
 		{
 		    lnum = trypos->lnum + 1;
 		    continue;
@@ -7206,8 +7317,7 @@
 
 		/* XXX */
 		if ((trypos = find_match_paren(
-				corr_ind_maxparen(ind_maxparen, &cur_curpos),
-						      ind_maxcomment)) != NULL
+			corr_ind_maxparen(&cur_curpos))) != NULL
 			&& trypos->lnum == our_paren_pos.lnum
 			&& trypos->col == our_paren_pos.col)
 		{
@@ -7235,7 +7345,7 @@
 	    int	    ignore_paren_col = 0;
 	    int	    is_if_for_while = 0;
 
-	    if (ind_if_for_while)
+	    if (curbuf->b_ind_if_for_while)
 	    {
 		/* Look for the outermost opening parenthesis on this line
 		 * and check whether it belongs to an "if", "for" or "while". */
@@ -7250,7 +7360,7 @@
 		    curwin->w_cursor.lnum = outermost.lnum;
 		    curwin->w_cursor.col = outermost.col;
 
-		    trypos = find_match_paren(ind_maxparen, ind_maxcomment);
+		    trypos = find_match_paren(curbuf->b_ind_maxparen);
 		} while (trypos && trypos->lnum == outermost.lnum);
 
 		curwin->w_cursor = cursor_save;
@@ -7261,7 +7371,7 @@
 		    cin_is_if_for_while_before_offset(line, &outermost.col);
 	    }
 
-	    amount = skip_label(our_paren_pos.lnum, &look, ind_maxcomment);
+	    amount = skip_label(our_paren_pos.lnum, &look);
 	    look = skipwhite(look);
 	    if (*look == '(')
 	    {
@@ -7275,7 +7385,8 @@
 		line = ml_get_curline();
 		look_col = (int)(look - line);
 		curwin->w_cursor.col = look_col + 1;
-		if ((trypos = findmatchlimit(NULL, ')', 0, ind_maxparen))
+		if ((trypos = findmatchlimit(NULL, ')', 0,
+						      curbuf->b_ind_maxparen))
 								      != NULL
 			  && trypos->lnum == our_paren_pos.lnum
 			  && trypos->col < our_paren_pos.col)
@@ -7284,24 +7395,25 @@
 		curwin->w_cursor.lnum = save_lnum;
 		look = ml_get(our_paren_pos.lnum) + look_col;
 	    }
-	    if (theline[0] == ')' || (ind_unclosed == 0 && is_if_for_while == 0)
-		    || (!ind_unclosed_noignore && *look == '('
+	    if (theline[0] == ')' || (curbuf->b_ind_unclosed == 0
+						      && is_if_for_while == 0)
+		    || (!curbuf->b_ind_unclosed_noignore && *look == '('
 						    && ignore_paren_col == 0))
 	    {
 		/*
 		 * If we're looking at a close paren, line up right there;
 		 * otherwise, line up with the next (non-white) character.
-		 * When ind_unclosed_wrapped is set and the matching paren is
+		 * When b_ind_unclosed_wrapped is set and the matching paren is
 		 * the last nonwhite character of the line, use either the
 		 * indent of the current line or the indentation of the next
-		 * outer paren and add ind_unclosed_wrapped (for very long
+		 * outer paren and add b_ind_unclosed_wrapped (for very long
 		 * lines).
 		 */
 		if (theline[0] != ')')
 		{
 		    cur_amount = MAXCOL;
 		    l = ml_get(our_paren_pos.lnum);
-		    if (ind_unclosed_wrapped
+		    if (curbuf->b_ind_unclosed_wrapped
 				       && cin_ends_in(l, (char_u *)"(", NULL))
 		    {
 			/* look for opening unmatched paren, indent one level
@@ -7323,9 +7435,9 @@
 			}
 
 			our_paren_pos.col = 0;
-			amount += n * ind_unclosed_wrapped;
+			amount += n * curbuf->b_ind_unclosed_wrapped;
 		    }
-		    else if (ind_unclosed_whiteok)
+		    else if (curbuf->b_ind_unclosed_whiteok)
 			our_paren_pos.col++;
 		    else
 		    {
@@ -7351,12 +7463,12 @@
 		}
 	    }
 
-	    if (theline[0] == ')' && ind_matching_paren)
+	    if (theline[0] == ')' && curbuf->b_ind_matching_paren)
 	    {
 		/* Line up with the start of the matching paren line. */
 	    }
-	    else if ((ind_unclosed == 0 && is_if_for_while == 0)
-		     || (!ind_unclosed_noignore
+	    else if ((curbuf->b_ind_unclosed == 0 && is_if_for_while == 0)
+		     || (!curbuf->b_ind_unclosed_noignore
 				    && *look == '(' && ignore_paren_col == 0))
 	    {
 		if (cur_amount != MAXCOL)
@@ -7364,39 +7476,40 @@
 	    }
 	    else
 	    {
-		/* Add ind_unclosed2 for each '(' before our matching one, but
-		 * ignore (void) before the line (ignore_paren_col). */
+		/* Add b_ind_unclosed2 for each '(' before our matching one,
+		 * but ignore (void) before the line (ignore_paren_col). */
 		col = our_paren_pos.col;
 		while ((int)our_paren_pos.col > ignore_paren_col)
 		{
 		    --our_paren_pos.col;
 		    switch (*ml_get_pos(&our_paren_pos))
 		    {
-			case '(': amount += ind_unclosed2;
+			case '(': amount += curbuf->b_ind_unclosed2;
 				  col = our_paren_pos.col;
 				  break;
-			case ')': amount -= ind_unclosed2;
+			case ')': amount -= curbuf->b_ind_unclosed2;
 				  col = MAXCOL;
 				  break;
 		    }
 		}
 
-		/* Use ind_unclosed once, when the first '(' is not inside
+		/* Use b_ind_unclosed once, when the first '(' is not inside
 		 * braces */
 		if (col == MAXCOL)
-		    amount += ind_unclosed;
+		    amount += curbuf->b_ind_unclosed;
 		else
 		{
 		    curwin->w_cursor.lnum = our_paren_pos.lnum;
 		    curwin->w_cursor.col = col;
-		    if (find_match_paren(ind_maxparen, ind_maxcomment) != NULL)
-			amount += ind_unclosed2;
+		    if (find_match_paren_after_brace(curbuf->b_ind_maxparen)
+								      != NULL)
+			amount += curbuf->b_ind_unclosed2;
 		    else
 		    {
 			if (is_if_for_while)
-			    amount += ind_if_for_while;
+			    amount += curbuf->b_ind_if_for_while;
 			else
-			    amount += ind_unclosed;
+			    amount += curbuf->b_ind_unclosed;
 		    }
 		}
 		/*
@@ -7414,16 +7527,19 @@
 
 	/* add extra indent for a comment */
 	if (cin_iscomment(theline))
-	    amount += ind_comment;
+	    amount += curbuf->b_ind_comment;
       }
-
-      /*
-       * Are we at least inside braces, then?
-       */
       else
       {
+	/*
+	 * We are inside braces, there is a { before this line at the position
+	 * stored in tryposBrace.
+	 * Make a copy of tryposBrace, it may point to pos_copy inside
+	 * find_start_brace(), which may be changed somewhere.
+	 */
+	tryposBraceCopy = *tryposBrace;
+	tryposBrace = &tryposBraceCopy;
 	trypos = tryposBrace;
-
 	ourscope = trypos->lnum;
 	start = ml_get(ourscope);
 
@@ -7445,39 +7561,40 @@
 	}
 	else
 	{
-	    /*
-	     * that opening brace might have been on a continuation
-	     * line.  if so, find the start of the line.
-	     */
+	    /* That opening brace might have been on a continuation
+	     * line.  if so, find the start of the line. */
 	    curwin->w_cursor.lnum = ourscope;
 
-	    /*
-	     * position the cursor over the rightmost paren, so that
-	     * matching it will take us back to the start of the line.
-	     */
+	    /* Position the cursor over the rightmost paren, so that
+	     * matching it will take us back to the start of the line. */
 	    lnum = ourscope;
 	    if (find_last_paren(start, '(', ')')
-		    && (trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
+			&& (trypos = find_match_paren(curbuf->b_ind_maxparen))
+								      != NULL)
 		lnum = trypos->lnum;
 
-	    /*
-	     * It could have been something like
+	    /* It could have been something like
 	     *	   case 1: if (asdf &&
 	     *			ldfd) {
 	     *		    }
 	     */
-	    if (ind_js || (ind_keep_case_label
-			   && cin_iscase(skipwhite(ml_get_curline()), FALSE)))
+	    if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)
+			   && cin_iscase(skipwhite(ml_get_curline()), FALSE))
 		amount = get_indent();
+	    else if (curbuf->b_ind_js)
+		amount = get_indent_lnum(lnum);
 	    else
-		amount = skip_label(lnum, &l, ind_maxcomment);
+		amount = skip_label(lnum, &l);
 
 	    start_brace = BRACE_AT_END;
 	}
 
+	/* For Javascript check if the line starts with "key:". */
+	if (curbuf->b_ind_js)
+	    js_cur_has_key = cin_has_js_key(theline);
+
 	/*
-	 * if we're looking at a closing brace, that's where
+	 * If we're looking at a closing brace, that's where
 	 * we want to be.  otherwise, add the amount of room
 	 * that an indent is supposed to be.
 	 */
@@ -7487,7 +7604,7 @@
 	     * they may want closing braces to line up with something
 	     * other than the open brace.  indulge them, if so.
 	     */
-	    amount += ind_close_extra;
+	    amount += curbuf->b_ind_close_extra;
 	}
 	else
 	{
@@ -7500,14 +7617,12 @@
 	    lookfor = LOOKFOR_INITIAL;
 	    if (cin_iselse(theline))
 		lookfor = LOOKFOR_IF;
-	    else if (cin_iswhileofdo(theline, cur_curpos.lnum, ind_maxparen))
-								    /* XXX */
+	    else if (cin_iswhileofdo(theline, cur_curpos.lnum)) /* XXX */
 		lookfor = LOOKFOR_DO;
 	    if (lookfor != LOOKFOR_INITIAL)
 	    {
 		curwin->w_cursor.lnum = cur_curpos.lnum;
-		if (find_match(lookfor, ourscope, ind_maxparen,
-							ind_maxcomment) == OK)
+		if (find_match(lookfor, ourscope) == OK)
 		{
 		    amount = get_indent();	/* XXX */
 		    goto theend;
@@ -7524,12 +7639,12 @@
 	    /*
 	     * if the '{' is  _really_ at the left margin, use the imaginary
 	     * location of a left-margin brace.  Otherwise, correct the
-	     * location for ind_open_extra.
+	     * location for b_ind_open_extra.
 	     */
 
 	    if (start_brace == BRACE_IN_COL0)	    /* '{' is in column 0 */
 	    {
-		amount = ind_open_left_imag;
+		amount = curbuf->b_ind_open_left_imag;
 		lookfor_cpp_namespace = TRUE;
 	    }
 	    else if (start_brace == BRACE_AT_START &&
@@ -7542,16 +7657,16 @@
 	    {
 		if (start_brace == BRACE_AT_END)    /* '{' is at end of line */
 		{
-		    amount += ind_open_imag;
+		    amount += curbuf->b_ind_open_imag;
 
 		    l = skipwhite(ml_get_curline());
 		    if (cin_is_cpp_namespace(l))
-			amount += ind_cpp_namespace;
+			amount += curbuf->b_ind_cpp_namespace;
 		}
 		else
 		{
-		    /* Compensate for adding ind_open_extra later. */
-		    amount -= ind_open_extra;
+		    /* Compensate for adding b_ind_open_extra later. */
+		    amount -= curbuf->b_ind_open_extra;
 		    if (amount < 0)
 			amount = 0;
 		}
@@ -7562,20 +7677,22 @@
 	    if (cin_iscase(theline, FALSE))	/* it's a switch() label */
 	    {
 		lookfor = LOOKFOR_CASE;	/* find a previous switch() label */
-		amount += ind_case;
+		amount += curbuf->b_ind_case;
 	    }
 	    else if (cin_isscopedecl(theline))	/* private:, ... */
 	    {
 		lookfor = LOOKFOR_SCOPEDECL;	/* class decl is this block */
-		amount += ind_scopedecl;
+		amount += curbuf->b_ind_scopedecl;
 	    }
 	    else
 	    {
-		if (ind_case_break && cin_isbreak(theline))	/* break; ... */
+		if (curbuf->b_ind_case_break && cin_isbreak(theline))
+		    /* break; ... */
 		    lookfor_break = TRUE;
 
 		lookfor = LOOKFOR_INITIAL;
-		amount += ind_level;	/* ind_level from start of block */
+		/* b_ind_level from start of block */
+		amount += curbuf->b_ind_level;
 	    }
 	    scope_amount = amount;
 	    whilelevel = 0;
@@ -7584,7 +7701,7 @@
 	     * Search backwards.  If we find something we recognize, line up
 	     * with that.
 	     *
-	     * if we're looking at an open brace, indent
+	     * If we're looking at an open brace, indent
 	     * the usual amount relative to the conditional
 	     * that opens the block.
 	     */
@@ -7613,14 +7730,14 @@
 		    {
 			if (curwin->w_cursor.lnum == 0
 				|| curwin->w_cursor.lnum
-						    < ourscope - ind_maxparen)
+					  < ourscope - curbuf->b_ind_maxparen)
 			{
-			    /* nothing found (abuse ind_maxparen as limit)
-			     * assume terminated line (i.e. a variable
+			    /* nothing found (abuse curbuf->b_ind_maxparen as
+			     * limit) assume terminated line (i.e. a variable
 			     * initialization) */
 			    if (cont_amount > 0)
 				amount = cont_amount;
-			    else if (!ind_js)
+			    else if (!curbuf->b_ind_js)
 				amount += ind_continuation;
 			    break;
 			}
@@ -7631,7 +7748,7 @@
 			 * If we're in a comment now, skip to the start of the
 			 * comment.
 			 */
-			trypos = find_start_comment(ind_maxcomment);
+			trypos = ind_find_start_comment();
 			if (trypos != NULL)
 			{
 			    curwin->w_cursor.lnum = trypos->lnum + 1;
@@ -7656,8 +7773,7 @@
 			 * (it's a variable declaration).
 			 */
 			if (start_brace != BRACE_IN_COL0
-				|| !cin_isfuncdecl(&l, curwin->w_cursor.lnum,
-					     0, ind_maxparen, ind_maxcomment))
+			     || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))
 			{
 			    /* if the line is terminated with another ','
 			     * it is a continued variable initialization.
@@ -7688,11 +7804,11 @@
 			     */					/* XXX */
 			    trypos = NULL;
 			    if (find_last_paren(l, '(', ')'))
-				trypos = find_match_paren(ind_maxparen,
-					ind_maxcomment);
+				trypos = find_match_paren(
+						      curbuf->b_ind_maxparen);
 
 			    if (trypos == NULL && find_last_paren(l, '{', '}'))
-				trypos = find_start_brace(ind_maxcomment);
+				trypos = find_start_brace();
 
 			    if (trypos != NULL)
 			    {
@@ -7727,8 +7843,8 @@
 			    amount = scope_amount;
 			    if (theline[0] == '{')
 			    {
-				amount += ind_open_extra;
-				added_to_amount = ind_open_extra;
+				amount += curbuf->b_ind_open_extra;
+				added_to_amount = curbuf->b_ind_open_extra;
 			    }
 			}
 
@@ -7750,7 +7866,7 @@
 
 			    /* If we're in a comment now, skip to the start of
 			     * the comment. */
-			    trypos = find_start_comment(ind_maxcomment);
+			    trypos = ind_find_start_comment();
 			    if (trypos != NULL)
 			    {
 				curwin->w_cursor.lnum = trypos->lnum + 1;
@@ -7765,7 +7881,8 @@
 			    /* Finally the actual check for "namespace". */
 			    if (cin_is_cpp_namespace(l))
 			    {
-				amount += ind_cpp_namespace - added_to_amount;
+				amount += curbuf->b_ind_cpp_namespace
+							    - added_to_amount;
 				break;
 			    }
 
@@ -7779,7 +7896,7 @@
 		/*
 		 * If we're in a comment now, skip to the start of the comment.
 		 */					    /* XXX */
-		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
+		if ((trypos = ind_find_start_comment()) != NULL)
 		{
 		    curwin->w_cursor.lnum = trypos->lnum + 1;
 		    curwin->w_cursor.col = 0;
@@ -7833,8 +7950,8 @@
 			 * Check that this case label is not for another
 			 * switch()
 			 */				    /* XXX */
-			if ((trypos = find_start_brace(ind_maxcomment)) ==
-					     NULL || trypos->lnum == ourscope)
+			if ((trypos = find_start_brace()) == NULL
+						  || trypos->lnum == ourscope)
 			{
 			    amount = get_indent();	/* XXX */
 			    break;
@@ -7877,9 +7994,10 @@
 			if (l != NULL && cin_is_cinword(l))
 			{
 			    if (theline[0] == '{')
-				amount += ind_open_extra;
+				amount += curbuf->b_ind_open_extra;
 			    else
-				amount += ind_level + ind_no_brace;
+				amount += curbuf->b_ind_level
+						     + curbuf->b_ind_no_brace;
 			}
 			break;
 		    }
@@ -7893,8 +8011,10 @@
 		     * ->   y = 1;
 		     */
 		    scope_amount = get_indent() + (iscase    /* XXX */
-					? ind_case_code : ind_scopedecl_code);
-		    lookfor = ind_case_break ? LOOKFOR_NOBREAK : LOOKFOR_ANY;
+					? curbuf->b_ind_case_code
+					: curbuf->b_ind_scopedecl_code);
+		    lookfor = curbuf->b_ind_case_break
+					      ? LOOKFOR_NOBREAK : LOOKFOR_ANY;
 		    continue;
 		}
 
@@ -7904,8 +8024,8 @@
 		 */
 		if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)
 		{
-		    if (find_last_paren(l, '{', '}') && (trypos =
-				    find_start_brace(ind_maxcomment)) != NULL)
+		    if (find_last_paren(l, '{', '}')
+				     && (trypos = find_start_brace()) != NULL)
 		    {
 			curwin->w_cursor.lnum = trypos->lnum + 1;
 			curwin->w_cursor.col = 0;
@@ -7916,7 +8036,7 @@
 		/*
 		 * Ignore jump labels with nothing after them.
 		 */
-		if (!ind_js && cin_islabel(ind_maxcomment))
+		if (!curbuf->b_ind_js && cin_islabel())
 		{
 		    l = after_label(ml_get_curline());
 		    if (l == NULL || cin_nocode(l))
@@ -7939,7 +8059,7 @@
 		 * constructor initialization?
 		 */						    /* XXX */
 		n = FALSE;
-		if (lookfor != LOOKFOR_TERM && ind_cpp_baseclass > 0)
+		if (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0)
 		{
 		    n = cin_is_cpp_baseclass(&col);
 		    l = ml_get_curline();
@@ -7962,8 +8082,7 @@
 		    }
 		    else
 								     /* XXX */
-			amount = get_baseclass_amount(col, ind_maxparen,
-					   ind_maxcomment, ind_cpp_baseclass);
+			amount = get_baseclass_amount(col);
 		    break;
 		}
 		else if (lookfor == LOOKFOR_CPP_BASECLASS)
@@ -7990,6 +8109,41 @@
 		 */
 		terminated = cin_isterminated(l, FALSE, TRUE);
 
+		if (js_cur_has_key)
+		{
+		    js_cur_has_key = 0; /* only check the first line */
+		    if (curbuf->b_ind_js && terminated == ',')
+		    {
+			/* For Javascript we might be inside an object:
+			 *   key: something,  <- align with this
+			 *   key: something
+			 * or:
+			 *   key: something +  <- align with this
+			 *       something,
+			 *   key: something
+			 */
+			lookfor = LOOKFOR_JS_KEY;
+		    }
+		}
+		if (lookfor == LOOKFOR_JS_KEY && cin_has_js_key(l))
+		{
+		    amount = get_indent();
+		    break;
+		}
+		if (lookfor == LOOKFOR_NO_COMMA)
+		{
+		    if (terminated != ',')
+			/* line below current line is the one that starts a
+			 * (possibly broken) line ending in a comma. */
+			break;
+		    amount = get_indent();
+		    if (curwin->w_cursor.lnum - 1 == ourscope)
+			/* line above is start of the scope, thus current line
+			 * is the one that stars a (possibly broken) line
+			 * ending in a comma. */
+			break;
+		}
+
 		if (terminated == 0 || (lookfor != LOOKFOR_UNTERM
 							&& terminated == ','))
 		{
@@ -8001,13 +8155,16 @@
 		     *		    bar )
 		     */
 		    /*
-		     * position the cursor over the rightmost paren, so that
+		     * Position the cursor over the rightmost paren, so that
 		     * matching it will take us back to the start of the line.
+		     * Ignore a match before the start of the block.
 		     */
 		    (void)find_last_paren(l, '(', ')');
-		    trypos = find_match_paren(
-				 corr_ind_maxparen(ind_maxparen, &cur_curpos),
-							      ind_maxcomment);
+		    trypos = find_match_paren(corr_ind_maxparen(&cur_curpos));
+		    if (trypos != NULL && (trypos->lnum < tryposBrace->lnum
+				|| (trypos->lnum == tryposBrace->lnum
+				    && trypos->col < tryposBrace->col)))
+			trypos = NULL;
 
 		    /*
 		     * If we are looking for ',', we also look for matching
@@ -8015,7 +8172,7 @@
 		     */
 		    if (trypos == NULL && terminated == ','
 					      && find_last_paren(l, '{', '}'))
-			trypos = find_start_brace(ind_maxcomment);
+			trypos = find_start_brace();
 
 		    if (trypos != NULL)
 		    {
@@ -8058,11 +8215,10 @@
 		     * Get indent and pointer to text for current line,
 		     * ignoring any jump label.	    XXX
 		     */
-		    if (!ind_js)
-			cur_amount = skip_label(curwin->w_cursor.lnum,
-							  &l, ind_maxcomment);
-		    else
+		    if (curbuf->b_ind_js)
 			cur_amount = get_indent();
+		    else
+			cur_amount = skip_label(curwin->w_cursor.lnum, &l);
 		    /*
 		     * If this is just above the line we are indenting, and it
 		     * starts with a '{', line it up with this line.
@@ -8075,16 +8231,16 @@
 		    {
 			amount = cur_amount;
 			/*
-			 * Only add ind_open_extra when the current line
+			 * Only add b_ind_open_extra when the current line
 			 * doesn't start with a '{', which must have a match
 			 * in the same line (scope is the same).  Probably:
 			 *	{ 1, 2 },
 			 * ->	{ 3, 4 }
 			 */
 			if (*skipwhite(l) != '{')
-			    amount += ind_open_extra;
+			    amount += curbuf->b_ind_open_extra;
 
-			if (ind_cpp_baseclass)
+			if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js)
 			{
 			    /* have to look back, whether it is a cpp base
 			     * class declaration or initialization */
@@ -8132,10 +8288,11 @@
 			 */
 			amount = cur_amount;
 			if (theline[0] == '{')
-			    amount += ind_open_extra;
+			    amount += curbuf->b_ind_open_extra;
 			if (lookfor != LOOKFOR_TERM)
 			{
-			    amount += ind_level + ind_no_brace;
+			    amount += curbuf->b_ind_level
+						     + curbuf->b_ind_no_brace;
 			    break;
 			}
 
@@ -8169,10 +8326,9 @@
 				curwin->w_cursor.col =
 					  (colnr_T)(l - ml_get_curline()) + 1;
 
-			    if ((trypos = find_start_brace(ind_maxcomment))
-								       == NULL
-				    || find_match(LOOKFOR_IF, trypos->lnum,
-					ind_maxparen, ind_maxcomment) == FAIL)
+			    if ((trypos = find_start_brace()) == NULL
+				       || find_match(LOOKFOR_IF, trypos->lnum)
+								      == FAIL)
 				break;
 			}
 		    }
@@ -8209,7 +8365,7 @@
 			     * enumerations/initializations. */
 			    if (terminated == ',')
 			    {
-				if (ind_cpp_baseclass == 0)
+				if (curbuf->b_ind_cpp_baseclass == 0)
 				    break;
 
 				lookfor = LOOKFOR_CPP_BASECLASS;
@@ -8244,8 +8400,41 @@
 			     */
 			    if (lookfor == LOOKFOR_INITIAL && terminated == ',')
 			    {
-				lookfor = LOOKFOR_ENUM_OR_INIT;
-				cont_amount = cin_first_id_amount();
+				if (curbuf->b_ind_js)
+				{
+				    /* Search for a line ending in a comma
+				     * and line up with the line below it
+				     * (could be the current line).
+				     * some = [
+				     *     1,     <- line up here
+				     *     2,
+				     * some = [
+				     *     3 +    <- line up here
+				     *       4 *
+				     *        5,
+				     *     6,
+				     */
+				    lookfor = LOOKFOR_NO_COMMA;
+				    amount = get_indent();	    /* XXX */
+				    trypos = find_match_char('[',
+						      curbuf->b_ind_maxparen);
+				    if (trypos != NULL)
+				    {
+					if (trypos->lnum
+						 == curwin->w_cursor.lnum - 1)
+					{
+					    /* Current line is first inside
+					     * [], line up with it. */
+					    break;
+					}
+					ourscope = trypos->lnum;
+				    }
+				}
+				else
+				{
+				    lookfor = LOOKFOR_ENUM_OR_INIT;
+				    cont_amount = cin_first_id_amount();
+				}
 			    }
 			    else
 			    {
@@ -8255,7 +8444,8 @@
 								/* XXX */
 				    cont_amount = cin_get_equal_amount(
 						       curwin->w_cursor.lnum);
-				if (lookfor != LOOKFOR_TERM)
+				if (lookfor != LOOKFOR_TERM
+						 && lookfor != LOOKFOR_JS_KEY)
 				    lookfor = LOOKFOR_UNTERM;
 			    }
 			}
@@ -8266,9 +8456,7 @@
 		 * Check if we are after a while (cond);
 		 * If so: Ignore until the matching "do".
 		 */
-							/* XXX */
-		else if (cin_iswhileofdo_end(terminated, ind_maxparen,
-							      ind_maxcomment))
+		else if (cin_iswhileofdo_end(terminated)) /* XXX */
 		{
 		    /*
 		     * Found an unterminated line after a while ();, line up
@@ -8292,7 +8480,7 @@
 			lookfor = LOOKFOR_TERM;
 			amount = get_indent();	    /* XXX */
 			if (theline[0] == '{')
-			    amount += ind_open_extra;
+			    amount += curbuf->b_ind_open_extra;
 		    }
 		    ++whilelevel;
 		}
@@ -8385,8 +8573,8 @@
 term_again:
 			l = ml_get_curline();
 			if (find_last_paren(l, '(', ')')
-				&& (trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
+				&& (trypos = find_match_paren(
+					   curbuf->b_ind_maxparen)) != NULL)
 			{
 			    /*
 			     * Check if we are on a case label now.  This is
@@ -8413,21 +8601,21 @@
 			 *	stat;
 			 * }
 			 */
-			iscase = (ind_keep_case_label && cin_iscase(l, FALSE));
+			iscase = (curbuf->b_ind_keep_case_label
+						     && cin_iscase(l, FALSE));
 
 			/*
 			 * Get indent and pointer to text for current line,
 			 * ignoring any jump label.
 			 */
-			amount = skip_label(curwin->w_cursor.lnum,
-							  &l, ind_maxcomment);
+			amount = skip_label(curwin->w_cursor.lnum, &l);
 
 			if (theline[0] == '{')
-			    amount += ind_open_extra;
-			/* See remark above: "Only add ind_open_extra.." */
+			    amount += curbuf->b_ind_open_extra;
+			/* See remark above: "Only add b_ind_open_extra.." */
 			l = skipwhite(l);
 			if (*l == '{')
-			    amount -= ind_open_extra;
+			    amount -= curbuf->b_ind_open_extra;
 			lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;
 
 			/*
@@ -8443,10 +8631,9 @@
 				&& cin_iselse(l)
 				&& whilelevel == 0)
 			{
-			    if ((trypos = find_start_brace(ind_maxcomment))
-								       == NULL
-				    || find_match(LOOKFOR_IF, trypos->lnum,
-					ind_maxparen, ind_maxcomment) == FAIL)
+			    if ((trypos = find_start_brace()) == NULL
+				       || find_match(LOOKFOR_IF, trypos->lnum)
+								      == FAIL)
 				break;
 			    continue;
 			}
@@ -8456,9 +8643,8 @@
 			 * that block.
 			 */
 			l = ml_get_curline();
-			if (find_last_paren(l, '{', '}')
-				&& (trypos = find_start_brace(ind_maxcomment))
-							    != NULL) /* XXX */
+			if (find_last_paren(l, '{', '}') /* XXX */
+				     && (trypos = find_start_brace()) != NULL)
 			{
 			    curwin->w_cursor = *trypos;
 			    /* if not "else {" check for terminated again */
@@ -8477,24 +8663,22 @@
 
       /* add extra indent for a comment */
       if (cin_iscomment(theline))
-	  amount += ind_comment;
+	  amount += curbuf->b_ind_comment;
 
       /* subtract extra left-shift for jump labels */
-      if (ind_jump_label > 0 && original_line_islabel)
-	  amount -= ind_jump_label;
+      if (curbuf->b_ind_jump_label > 0 && original_line_islabel)
+	  amount -= curbuf->b_ind_jump_label;
     }
-
-    /*
-     * ok -- we're not inside any sort of structure at all!
-     *
-     * this means we're at the top level, and everything should
-     * basically just match where the previous line is, except
-     * for the lines immediately following a function declaration,
-     * which are K&R-style parameters and need to be indented.
-     */
     else
     {
 	/*
+	 * ok -- we're not inside any sort of structure at all!
+	 *
+	 * This means we're at the top level, and everything should
+	 * basically just match where the previous line is, except
+	 * for the lines immediately following a function declaration,
+	 * which are K&R-style parameters and need to be indented.
+	 *
 	 * if our line starts with an open brace, forget about any
 	 * prevailing indent and make sure it looks like the start
 	 * of a function
@@ -8502,7 +8686,7 @@
 
 	if (theline[0] == '{')
 	{
-	    amount = ind_first_open;
+	    amount = curbuf->b_ind_first_open;
 	}
 
 	/*
@@ -8519,11 +8703,10 @@
 		&& !cin_ends_in(theline, (char_u *)":", NULL)
 		&& !cin_ends_in(theline, (char_u *)",", NULL)
 		&& cin_isfuncdecl(NULL, cur_curpos.lnum + 1,
-				  cur_curpos.lnum + 1,
-				  ind_maxparen, ind_maxcomment)
+				  cur_curpos.lnum + 1)
 		&& !cin_isterminated(theline, FALSE, TRUE))
 	{
-	    amount = ind_func_type;
+	    amount = curbuf->b_ind_func_type;
 	}
 	else
 	{
@@ -8542,7 +8725,7 @@
 		/*
 		 * If we're in a comment now, skip to the start of the comment.
 		 */						/* XXX */
-		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
+		if ((trypos = ind_find_start_comment()) != NULL)
 		{
 		    curwin->w_cursor.lnum = trypos->lnum + 1;
 		    curwin->w_cursor.col = 0;
@@ -8554,7 +8737,7 @@
 		 * constructor initialization?
 		 */						    /* XXX */
 		n = FALSE;
-		if (ind_cpp_baseclass != 0 && theline[0] != '{')
+		if (curbuf->b_ind_cpp_baseclass != 0 && theline[0] != '{')
 		{
 		    n = cin_is_cpp_baseclass(&col);
 		    l = ml_get_curline();
@@ -8562,8 +8745,7 @@
 		if (n)
 		{
 								     /* XXX */
-		    amount = get_baseclass_amount(col, ind_maxparen,
-					   ind_maxcomment, ind_cpp_baseclass);
+		    amount = get_baseclass_amount(col);
 		    break;
 		}
 
@@ -8594,8 +8776,8 @@
 		{
 		    /* take us back to opening paren */
 		    if (find_last_paren(l, '(', ')')
-			    && (trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
+			    && (trypos = find_match_paren(
+					     curbuf->b_ind_maxparen)) != NULL)
 			curwin->w_cursor = *trypos;
 
 		    /* For a line ending in ',' that is a continuation line go
@@ -8626,8 +8808,7 @@
 		 * If the line looks like a function declaration, and we're
 		 * not in a comment, put it the left margin.
 		 */
-		if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0,
-				   ind_maxparen, ind_maxcomment))  /* XXX */
+		if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0))  /* XXX */
 		    break;
 		l = ml_get_curline();
 
@@ -8648,6 +8829,18 @@
 		    break;
 
 		/*
+		 * If the previous line ends on '[' we are probably in an
+		 * array constant:
+		 * something = [
+		 *     234,  <- extra indent
+		 */
+		if (cin_ends_in(l, (char_u *)"[", NULL))
+		{
+		    amount = get_indent() + ind_continuation;
+		    break;
+		}
+
+		/*
 		 * Find a line only has a semicolon that belongs to a previous
 		 * line ending in '}', e.g. before an #endif.  Don't increase
 		 * indent then.
@@ -8675,10 +8868,9 @@
 		 * line (and the ones that follow) needs to be indented as
 		 * parameters.
 		 */
-		if (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0,
-				   ind_maxparen, ind_maxcomment))
+		if (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))
 		{
-		    amount = ind_param;
+		    amount = curbuf->b_ind_param;
 		    break;
 		}
 
@@ -8707,8 +8899,7 @@
 		 */
 		find_last_paren(l, '(', ')');
 
-		if ((trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
+		if ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
 		    curwin->w_cursor = *trypos;
 		amount = get_indent();	    /* XXX */
 		break;
@@ -8716,7 +8907,7 @@
 
 	    /* add extra indent for a comment */
 	    if (cin_iscomment(theline))
-		amount += ind_comment;
+		amount += curbuf->b_ind_comment;
 
 	    /* add extra indent if the previous line ended in a backslash:
 	     *	      "asdfasdf\
@@ -8751,11 +8942,9 @@
 }
 
     static int
-find_match(lookfor, ourscope, ind_maxparen, ind_maxcomment)
+find_match(lookfor, ourscope)
     int		lookfor;
     linenr_T	ourscope;
-    int		ind_maxparen;
-    int		ind_maxcomment;
 {
     char_u	*look;
     pos_T	*theirscope;
@@ -8785,13 +8974,13 @@
 	if (cin_iselse(look)
 		|| cin_isif(look)
 		|| cin_isdo(look)			    /* XXX */
-		|| cin_iswhileofdo(look, curwin->w_cursor.lnum, ind_maxparen))
+		|| cin_iswhileofdo(look, curwin->w_cursor.lnum))
 	{
 	    /*
 	     * if we've gone outside the braces entirely,
 	     * we must be out of scope...
 	     */
-	    theirscope = find_start_brace(ind_maxcomment);  /* XXX */
+	    theirscope = find_start_brace();  /* XXX */
 	    if (theirscope == NULL)
 		break;
 
@@ -8829,7 +9018,7 @@
 	     * if it was a "while" then we need to go back to
 	     * another "do", so increment whilelevel.  XXX
 	     */
-	    if (cin_iswhileofdo(look, curwin->w_cursor.lnum, ind_maxparen))
+	    if (cin_iswhileofdo(look, curwin->w_cursor.lnum))
 	    {
 		++whilelevel;
 		continue;
@@ -8926,7 +9115,7 @@
 {
     char_u	buf[LSIZE];
     int		len;
-    char_u	*word = p_lispwords;
+    char_u	*word = *curbuf->b_p_lw != NUL ? curbuf->b_p_lw : p_lispwords;
 
     while (*word != NUL)
     {
@@ -9046,10 +9235,12 @@
 		amount = 2;
 	    else
 	    {
+		char_u *line = that;
+
 		amount = 0;
 		while (*that && col)
 		{
-		    amount += lbr_chartabsize_adv(&that, (colnr_T)amount);
+		    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);
 		    col--;
 		}
 
@@ -9072,7 +9263,7 @@
 
 		    while (vim_iswhite(*that))
 		    {
-			amount += lbr_chartabsize(that, (colnr_T)amount);
+			amount += lbr_chartabsize(line, that, (colnr_T)amount);
 			++that;
 		    }
 
@@ -9110,15 +9301,16 @@
 							       && !quotecount)
 				    --parencount;
 				if (*that == '\\' && *(that+1) != NUL)
-				    amount += lbr_chartabsize_adv(&that,
-							     (colnr_T)amount);
-				amount += lbr_chartabsize_adv(&that,
-							     (colnr_T)amount);
+				    amount += lbr_chartabsize_adv(
+						line, &that, (colnr_T)amount);
+				amount += lbr_chartabsize_adv(
+						line, &that, (colnr_T)amount);
 			    }
 			}
 			while (vim_iswhite(*that))
 			{
-			    amount += lbr_chartabsize(that, (colnr_T)amount);
+			    amount += lbr_chartabsize(
+						 line, that, (colnr_T)amount);
 			    that++;
 			}
 			if (!*that || *that == ';')
@@ -9174,6 +9366,8 @@
 /*
  * Preserve files and exit.
  * When called IObuff must contain a message.
+ * NOTE: This may be called from deathtrap() in a signal handler, avoid unsafe
+ * functions, such as allocating memory.
  */
     void
 preserve_exit()
@@ -9196,7 +9390,7 @@
     {
 	if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)
 	{
-	    OUT_STR(_("Vim: preserving files...\n"));
+	    OUT_STR("Vim: preserving files...\n");
 	    screen_start();	    /* don't know where cursor is now */
 	    out_flush();
 	    ml_sync_all(FALSE, FALSE);	/* preserve all swap files */
@@ -9206,7 +9400,7 @@
 
     ml_close_all(FALSE);	    /* close all memfiles, without deleting */
 
-    OUT_STR(_("Vim: Finished.\n"));
+    OUT_STR("Vim: Finished.\n");
 
     getout(1);
 }
@@ -10381,9 +10575,6 @@
 {
     char_u	*curdir;
     garray_T	path_ga;
-    char_u	*files = NULL;
-    char_u	*s;	/* start */
-    char_u	*e;	/* end */
     char_u	*paths = NULL;
 
     if ((curdir = alloc((unsigned)MAXPATHL)) == NULL)
@@ -10396,37 +10587,13 @@
     if (path_ga.ga_len == 0)
 	return 0;
 
-    paths = ga_concat_strings(&path_ga);
+    paths = ga_concat_strings(&path_ga, ",");
     ga_clear_strings(&path_ga);
     if (paths == NULL)
 	return 0;
 
-    files = globpath(paths, pattern, (flags & EW_ICASE) ? WILD_ICASE : 0);
+    globpath(paths, pattern, gap, (flags & EW_ICASE) ? WILD_ICASE : 0);
     vim_free(paths);
-    if (files == NULL)
-	return 0;
-
-    /* Copy each path in files into gap */
-    s = e = files;
-    while (*s != NUL)
-    {
-	while (*e != '\n' && *e != NUL)
-	    e++;
-	if (*e == NUL)
-	{
-	    addfile(gap, s, flags);
-	    break;
-	}
-	else
-	{
-	    /* *e is '\n' */
-	    *e = NUL;
-	    addfile(gap, s, flags);
-	    e++;
-	    s = e;
-	}
-    }
-    vim_free(files);
 
     return gap->ga_len;
 }
@@ -10601,7 +10768,7 @@
 		    vim_free(p);
 		    ga_clear_strings(&ga);
 		    i = mch_expand_wildcards(num_pat, pat, num_file, file,
-								       flags);
+							 flags|EW_KEEPDOLLAR);
 		    recursive = FALSE;
 		    return i;
 		}
@@ -10710,7 +10877,7 @@
     else
 #endif
 	buffer = get_cmd_output(cmd, NULL,
-				      (flags & EW_SILENT) ? SHELL_SILENT : 0);
+				(flags & EW_SILENT) ? SHELL_SILENT : 0, NULL);
     vim_free(cmd);
     if (buffer == NULL)
 	return 0;
@@ -10773,7 +10940,7 @@
 	return;
 
     /* If the file isn't executable, may not add it.  Do accept directories. */
-    if (!isdir && (flags & EW_EXEC) && !mch_can_exe(f))
+    if (!isdir && (flags & EW_EXEC) && !mch_can_exe(f, NULL))
 	return;
 
     /* Make room for another item in the file list. */
@@ -10810,13 +10977,16 @@
 
 /*
  * Get the stdout of an external command.
+ * If "ret_len" is NULL replace NUL characters with NL.  When "ret_len" is not
+ * NULL store the length there.
  * Returns an allocated string, or NULL for error.
  */
     char_u *
-get_cmd_output(cmd, infile, flags)
+get_cmd_output(cmd, infile, flags, ret_len)
     char_u	*cmd;
     char_u	*infile;	/* optional input file name */
     int		flags;		/* can be SHELL_SILENT */
+    int		*ret_len;
 {
     char_u	*tempname;
     char_u	*command;
@@ -10886,7 +11056,7 @@
 	vim_free(buffer);
 	buffer = NULL;
     }
-    else
+    else if (ret_len == NULL)
     {
 	/* Change NUL into SOH, otherwise the string is truncated. */
 	for (i = 0; i < len; ++i)
@@ -10895,6 +11065,8 @@
 
 	buffer[len] = NUL;	/* make sure the buffer is terminated */
     }
+    else
+	*ret_len = len;
 
 done:
     vim_free(tempname);
@@ -10936,3 +11108,41 @@
 {
     return (p_im && stuff_empty() && typebuf_typed());
 }
+
+/*
+ * Returns the isolated name of the shell in allocated memory:
+ * - Skip beyond any path.  E.g., "/usr/bin/csh -f" -> "csh -f".
+ * - Remove any argument.  E.g., "csh -f" -> "csh".
+ * But don't allow a space in the path, so that this works:
+ *   "/usr/bin/csh --rcfile ~/.cshrc"
+ * But don't do that for Windows, it's common to have a space in the path.
+ */
+    char_u *
+get_isolated_shell_name()
+{
+    char_u *p;
+
+#ifdef WIN3264
+    p = gettail(p_sh);
+    p = vim_strnsave(p, (int)(skiptowhite(p) - p));
+#else
+    p = skiptowhite(p_sh);
+    if (*p == NUL)
+    {
+	/* No white space, use the tail. */
+	p = vim_strsave(gettail(p_sh));
+    }
+    else
+    {
+	char_u  *p1, *p2;
+
+	/* Find the last path separator before the space. */
+	p1 = p_sh;
+	for (p2 = p_sh; p2 < p; mb_ptr_adv(p2))
+	    if (vim_ispathsep(*p2))
+		p1 = p2 + 1;
+	p = vim_strnsave(p1, (int)(p - p1));
+    }
+#endif
+    return p;
+}
diff -Naur vim74.orig/src/misc2.c vim74/src/misc2.c
--- vim74.orig/src/misc2.c	2013-07-07 14:03:35.000000000 +0000
+++ vim74/src/misc2.c	2014-10-10 14:53:44.672046393 +0000
@@ -31,9 +31,7 @@
     if (virtual_op != MAYBE)
 	return virtual_op;
     return (ve_flags == VE_ALL
-# ifdef FEAT_VISUAL
 	    || ((ve_flags & VE_BLOCK) && VIsual_active && VIsual_mode == Ctrl_V)
-# endif
 	    || ((ve_flags & VE_INSERT) && (State & INSERT)));
 }
 
@@ -149,9 +147,7 @@
 
     one_more = (State & INSERT)
 		    || restart_edit != NUL
-#ifdef FEAT_VISUAL
 		    || (VIsual_active && *p_sel != 'o')
-#endif
 #ifdef FEAT_VIRTUALEDIT
 		    || ((ve_flags & VE_ONEMORE) && wcol < MAXCOL)
 #endif
@@ -205,10 +201,10 @@
 	{
 	    /* Count a tab for what it's worth (if list mode not on) */
 #ifdef FEAT_LINEBREAK
-	    csize = win_lbr_chartabsize(curwin, ptr, col, &head);
+	    csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);
 	    mb_ptr_adv(ptr);
 #else
-	    csize = lbr_chartabsize_adv(&ptr, col);
+	    csize = lbr_chartabsize_adv(line, &ptr, col);
 #endif
 	    col += csize;
 	}
@@ -487,7 +483,7 @@
 	{
 	    while (lnum > cursor)
 	    {
-		(void)hasFolding(lnum, &lnum, NULL);
+		(void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);
 		/* if lnum and cursor are in the same fold,
 		 * now lnum <= cursor */
 		if (lnum > cursor)
@@ -499,7 +495,7 @@
 	{
 	    while (lnum < cursor)
 	    {
-		(void)hasFolding(lnum, NULL, &lnum);
+		(void)hasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);
 		/* if lnum and cursor are in the same fold,
 		 * now lnum >= cursor */
 		if (lnum < cursor)
@@ -570,9 +566,7 @@
 	 * - in Visual mode and 'selection' isn't "old"
 	 * - 'virtualedit' is set */
 	if ((State & INSERT) || restart_edit
-#ifdef FEAT_VISUAL
 		|| (VIsual_active && *p_sel != 'o')
-#endif
 #ifdef FEAT_VIRTUALEDIT
 		|| (ve_flags & VE_ONEMORE)
 #endif
@@ -627,9 +621,7 @@
 adjust_cursor_col()
 {
     if (curwin->w_cursor.col > 0
-# ifdef FEAT_VISUAL
 	    && (!VIsual_active || *p_sel == 'o')
-# endif
 	    && gchar_cursor() == NUL)
 	--curwin->w_cursor.col;
 }
@@ -1048,7 +1040,8 @@
     entered = TRUE;
 
 # ifdef FEAT_AUTOCMD
-    block_autocmds();	    /* don't want to trigger autocommands here */
+    /* Don't want to trigger autocommands from here on. */
+    block_autocmds();
 # endif
 
 # ifdef FEAT_WINDOWS
@@ -1369,12 +1362,14 @@
  * Escape a newline, depending on the 'shell' option.
  * When "do_special" is TRUE also replace "!", "%", "#" and things starting
  * with "<" like "<cfile>".
+ * When "do_newline" is FALSE do not escape newline unless it is csh shell.
  * Returns the result in allocated memory, NULL if we have run out.
  */
     char_u *
-vim_strsave_shellescape(string, do_special)
+vim_strsave_shellescape(string, do_special, do_newline)
     char_u	*string;
     int		do_special;
+    int		do_newline;
 {
     unsigned	length;
     char_u	*p;
@@ -1403,7 +1398,8 @@
 # endif
 	if (*p == '\'')
 	    length += 3;		/* ' => '\'' */
-	if (*p == '\n' || (*p == '!' && (csh_like || do_special)))
+	if ((*p == '\n' && (csh_like || do_newline))
+		|| (*p == '!' && (csh_like || do_special)))
 	{
 	    ++length;			/* insert backslash */
 	    if (csh_like && do_special)
@@ -1454,7 +1450,8 @@
 		++p;
 		continue;
 	    }
-	    if (*p == '\n' || (*p == '!' && (csh_like || do_special)))
+	    if ((*p == '\n' && (csh_like || do_newline))
+		    || (*p == '!' && (csh_like || do_special)))
 	    {
 		*d++ = '\\';
 		if (csh_like && do_special)
@@ -2091,29 +2088,37 @@
 
 /*
  * For a growing array that contains a list of strings: concatenate all the
- * strings with a separating comma.
+ * strings with a separating "sep".
  * Returns NULL when out of memory.
  */
     char_u *
-ga_concat_strings(gap)
+ga_concat_strings(gap, sep)
     garray_T *gap;
+    char     *sep;
 {
     int		i;
     int		len = 0;
+    int		sep_len = (int)STRLEN(sep);
     char_u	*s;
+    char_u	*p;
 
     for (i = 0; i < gap->ga_len; ++i)
-	len += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + 1;
+	len += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + sep_len;
 
     s = alloc(len + 1);
     if (s != NULL)
     {
 	*s = NUL;
+	p = s;
 	for (i = 0; i < gap->ga_len; ++i)
 	{
-	    if (*s != NUL)
-		STRCAT(s, ",");
-	    STRCAT(s, ((char_u **)(gap->ga_data))[i]);
+	    if (p != s)
+	    {
+		STRCPY(p, sep);
+		p += sep_len;
+	    }
+	    STRCPY(p, ((char_u **)(gap->ga_data))[i]);
+	    p += STRLEN(p);
 	}
     }
     return s;
@@ -2152,7 +2157,8 @@
     }
 }
 
-#if (defined(UNIX) && !defined(USE_SYSTEM)) || defined(WIN3264)
+#if (defined(UNIX) && !defined(USE_SYSTEM)) || defined(WIN3264) \
+	|| defined(PROTO)
 /*
  * Append the text in "gap" below the cursor line and clear "gap".
  */
@@ -2465,6 +2471,7 @@
     {K_SNR,		(char_u *)"SNR"},
 #endif
     {K_PLUG,		(char_u *)"Plug"},
+    {K_CURSORHOLD,	(char_u *)"CursorHold"},
     {0,			NULL}
 };
 
@@ -3286,17 +3293,14 @@
 {
     if (State & NORMAL)
     {
-#ifdef FEAT_VISUAL
 	if (VIsual_active)
 	{
 	    if (VIsual_select)
 		return SELECTMODE;
 	    return VISUAL;
 	}
-	else
-#endif
-	    if (finish_op)
-		return OP_PENDING;
+	else if (finish_op)
+	    return OP_PENDING;
     }
     return State;
 }
@@ -3734,7 +3738,6 @@
     }
     if (finish_op)
 	return SHAPE_IDX_O;
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	if (*p_sel == 'e')
@@ -3742,7 +3745,6 @@
 	else
 	    return SHAPE_IDX_V;
     }
-#endif
     return SHAPE_IDX_N;
 }
 #endif
@@ -3803,322 +3805,6 @@
 #endif /* CURSOR_SHAPE */
 
 
-#ifdef FEAT_CRYPT
-/*
- * Optional encryption support.
- * Mohsin Ahmed, mosh@sasi.com, 98-09-24
- * Based on zip/crypt sources.
- *
- * NOTE FOR USA: Since 2000 exporting this code from the USA is allowed to
- * most countries.  There are a few exceptions, but that still should not be a
- * problem since this code was originally created in Europe and India.
- *
- * Blowfish addition originally made by Mohsin Ahmed,
- * http://www.cs.albany.edu/~mosh 2010-03-14
- * Based on blowfish by Bruce Schneier (http://www.schneier.com/blowfish.html)
- * and sha256 by Christophe Devine.
- */
-
-/* from zip.h */
-
-typedef unsigned short ush;	/* unsigned 16-bit value */
-typedef unsigned long  ulg;	/* unsigned 32-bit value */
-
-static void make_crc_tab __ARGS((void));
-
-static ulg crc_32_tab[256];
-
-/*
- * Fill the CRC table.
- */
-    static void
-make_crc_tab()
-{
-    ulg		s,t,v;
-    static int	done = FALSE;
-
-    if (done)
-	return;
-    for (t = 0; t < 256; t++)
-    {
-	v = t;
-	for (s = 0; s < 8; s++)
-	    v = (v >> 1) ^ ((v & 1) * (ulg)0xedb88320L);
-	crc_32_tab[t] = v;
-    }
-    done = TRUE;
-}
-
-#define CRC32(c, b) (crc_32_tab[((int)(c) ^ (b)) & 0xff] ^ ((c) >> 8))
-
-static ulg keys[3]; /* keys defining the pseudo-random sequence */
-
-/*
- * Return the next byte in the pseudo-random sequence.
- */
-#define DECRYPT_BYTE_ZIP(t) { \
-    ush temp; \
- \
-    temp = (ush)keys[2] | 2; \
-    t = (int)(((unsigned)(temp * (temp ^ 1U)) >> 8) & 0xff); \
-}
-
-/*
- * Update the encryption keys with the next byte of plain text.
- */
-#define UPDATE_KEYS_ZIP(c) { \
-    keys[0] = CRC32(keys[0], (c)); \
-    keys[1] += keys[0] & 0xff; \
-    keys[1] = keys[1] * 134775813L + 1; \
-    keys[2] = CRC32(keys[2], (int)(keys[1] >> 24)); \
-}
-
-static int crypt_busy = 0;
-static ulg saved_keys[3];
-static int saved_crypt_method;
-
-/*
- * Return int value for crypt method string:
- * 0 for "zip", the old method.  Also for any non-valid value.
- * 1 for "blowfish".
- */
-    int
-crypt_method_from_string(s)
-    char_u  *s;
-{
-    return *s == 'b' ? 1 : 0;
-}
-
-/*
- * Get the crypt method for buffer "buf" as a number.
- */
-    int
-get_crypt_method(buf)
-    buf_T *buf;
-{
-    return crypt_method_from_string(*buf->b_p_cm == NUL ? p_cm : buf->b_p_cm);
-}
-
-/*
- * Set the crypt method for buffer "buf" to "method" using the int value as
- * returned by crypt_method_from_string().
- */
-    void
-set_crypt_method(buf, method)
-    buf_T   *buf;
-    int	    method;
-{
-    free_string_option(buf->b_p_cm);
-    buf->b_p_cm = vim_strsave((char_u *)(method == 0 ? "zip" : "blowfish"));
-}
-
-/*
- * Prepare for initializing encryption.  If already doing encryption then save
- * the state.
- * Must always be called symmetrically with crypt_pop_state().
- */
-    void
-crypt_push_state()
-{
-    if (crypt_busy == 1)
-    {
-	/* save the state */
-	if (use_crypt_method == 0)
-	{
-	    saved_keys[0] = keys[0];
-	    saved_keys[1] = keys[1];
-	    saved_keys[2] = keys[2];
-	}
-	else
-	    bf_crypt_save();
-	saved_crypt_method = use_crypt_method;
-    }
-    else if (crypt_busy > 1)
-	EMSG2(_(e_intern2), "crypt_push_state()");
-    ++crypt_busy;
-}
-
-/*
- * End encryption.  If doing encryption before crypt_push_state() then restore
- * the saved state.
- * Must always be called symmetrically with crypt_push_state().
- */
-    void
-crypt_pop_state()
-{
-    --crypt_busy;
-    if (crypt_busy == 1)
-    {
-	use_crypt_method = saved_crypt_method;
-	if (use_crypt_method == 0)
-	{
-	    keys[0] = saved_keys[0];
-	    keys[1] = saved_keys[1];
-	    keys[2] = saved_keys[2];
-	}
-	else
-	    bf_crypt_restore();
-    }
-}
-
-/*
- * Encrypt "from[len]" into "to[len]".
- * "from" and "to" can be equal to encrypt in place.
- */
-    void
-crypt_encode(from, len, to)
-    char_u	*from;
-    size_t	len;
-    char_u	*to;
-{
-    size_t	i;
-    int		ztemp, t;
-
-    if (use_crypt_method == 0)
-	for (i = 0; i < len; ++i)
-	{
-	    ztemp = from[i];
-	    DECRYPT_BYTE_ZIP(t);
-	    UPDATE_KEYS_ZIP(ztemp);
-	    to[i] = t ^ ztemp;
-	}
-    else
-	bf_crypt_encode(from, len, to);
-}
-
-/*
- * Decrypt "ptr[len]" in place.
- */
-    void
-crypt_decode(ptr, len)
-    char_u	*ptr;
-    long	len;
-{
-    char_u *p;
-
-    if (use_crypt_method == 0)
-	for (p = ptr; p < ptr + len; ++p)
-	{
-	    ush temp;
-
-	    temp = (ush)keys[2] | 2;
-	    temp = (int)(((unsigned)(temp * (temp ^ 1U)) >> 8) & 0xff);
-	    UPDATE_KEYS_ZIP(*p ^= temp);
-	}
-    else
-	bf_crypt_decode(ptr, len);
-}
-
-/*
- * Initialize the encryption keys and the random header according to
- * the given password.
- * If "passwd" is NULL or empty, don't do anything.
- */
-    void
-crypt_init_keys(passwd)
-    char_u *passwd;		/* password string with which to modify keys */
-{
-    if (passwd != NULL && *passwd != NUL)
-    {
-	if (use_crypt_method == 0)
-	{
-	    char_u *p;
-
-	    make_crc_tab();
-	    keys[0] = 305419896L;
-	    keys[1] = 591751049L;
-	    keys[2] = 878082192L;
-	    for (p = passwd; *p!= NUL; ++p)
-	    {
-		UPDATE_KEYS_ZIP((int)*p);
-	    }
-	}
-	else
-	    bf_crypt_init_keys(passwd);
-    }
-}
-
-/*
- * Free an allocated crypt key.  Clear the text to make sure it doesn't stay
- * in memory anywhere.
- */
-    void
-free_crypt_key(key)
-    char_u *key;
-{
-    char_u *p;
-
-    if (key != NULL)
-    {
-	for (p = key; *p != NUL; ++p)
-	    *p = 0;
-	vim_free(key);
-    }
-}
-
-/*
- * Ask the user for a crypt key.
- * When "store" is TRUE, the new key is stored in the 'key' option, and the
- * 'key' option value is returned: Don't free it.
- * When "store" is FALSE, the typed key is returned in allocated memory.
- * Returns NULL on failure.
- */
-    char_u *
-get_crypt_key(store, twice)
-    int		store;
-    int		twice;	    /* Ask for the key twice. */
-{
-    char_u	*p1, *p2 = NULL;
-    int		round;
-
-    for (round = 0; ; ++round)
-    {
-	cmdline_star = TRUE;
-	cmdline_row = msg_row;
-	p1 = getcmdline_prompt(NUL, round == 0
-		? (char_u *)_("Enter encryption key: ")
-		: (char_u *)_("Enter same key again: "), 0, EXPAND_NOTHING,
-		NULL);
-	cmdline_star = FALSE;
-
-	if (p1 == NULL)
-	    break;
-
-	if (round == twice)
-	{
-	    if (p2 != NULL && STRCMP(p1, p2) != 0)
-	    {
-		MSG(_("Keys don't match!"));
-		free_crypt_key(p1);
-		free_crypt_key(p2);
-		p2 = NULL;
-		round = -1;		/* do it again */
-		continue;
-	    }
-
-	    if (store)
-	    {
-		set_option_value((char_u *)"key", 0L, p1, OPT_LOCAL);
-		free_crypt_key(p1);
-		p1 = curbuf->b_p_key;
-	    }
-	    break;
-	}
-	p2 = p1;
-    }
-
-    /* since the user typed this, no need to wait for return */
-    if (msg_didout)
-	msg_putchar('\n');
-    need_wait_return = FALSE;
-    msg_didout = FALSE;
-
-    free_crypt_key(p2);
-    return p1;
-}
-
-#endif /* FEAT_CRYPT */
-
 /* TODO: make some #ifdef for this */
 /*--------[ file searching ]-------------------------------------------------*/
 /*
@@ -4695,8 +4381,8 @@
 	else
 	{
 	    char_u *p =  gettail(search_ctx->ffsc_fix_path);
-	    char_u *wc_path = NUL;
-	    char_u *temp = NUL;
+	    char_u *wc_path = NULL;
+	    char_u *temp = NULL;
 	    int    len = 0;
 
 	    if (p > search_ctx->ffsc_fix_path)
@@ -6496,13 +6182,15 @@
 get4c(fd)
     FILE	*fd;
 {
-    int		n;
-
-    n = getc(fd);
-    n = (n << 8) + getc(fd);
-    n = (n << 8) + getc(fd);
-    n = (n << 8) + getc(fd);
-    return n;
+    /* Use unsigned rather than int otherwise result is undefined
+     * when left-shift sets the MSB. */
+    unsigned	n;
+
+    n = (unsigned)getc(fd);
+    n = (n << 8) + (unsigned)getc(fd);
+    n = (n << 8) + (unsigned)getc(fd);
+    n = (n << 8) + (unsigned)getc(fd);
+    return (int)n;
 }
 
 /*
@@ -6586,8 +6274,23 @@
     FILE	*fd;
     time_t	the_time;
 {
+    char_u	buf[8];
+
+    time_to_bytes(the_time, buf);
+    fwrite(buf, (size_t)8, (size_t)1, fd);
+}
+
+/*
+ * Write time_t to "buf[8]".
+ */
+    void
+time_to_bytes(the_time, buf)
+    time_t	the_time;
+    char_u	*buf;
+{
     int		c;
     int		i;
+    int		bi = 0;
     time_t	wtime = the_time;
 
     /* time_t can be up to 8 bytes in size, more than long_u, thus we
@@ -6601,7 +6304,7 @@
     {
 	if (i + 1 > (int)sizeof(time_t))
 	    /* ">>" doesn't work well when shifting more bits than avail */
-	    putc(0, fd);
+	    buf[bi++] = 0;
 	else
 	{
 #if defined(SIZEOF_TIME_T) && SIZEOF_TIME_T > 4
@@ -6609,7 +6312,7 @@
 #else
 	    c = (int)((long_u)wtime >> (i * 8));
 #endif
-	    putc(c, fd);
+	    buf[bi++] = c;
 	}
     }
 }
diff -Naur vim74.orig/src/move.c vim74/src/move.c
--- vim74.orig/src/move.c	2012-11-28 17:15:42.000000000 +0000
+++ vim74/src/move.c	2014-10-10 14:53:44.682046368 +0000
@@ -20,6 +20,7 @@
 #include "vim.h"
 
 static void comp_botline __ARGS((win_T *wp));
+static void redraw_for_cursorline __ARGS((win_T *wp));
 static int scrolljump_value __ARGS((void));
 static int check_top_offset __ARGS((void));
 static void curs_rows __ARGS((win_T *wp, int do_botline));
@@ -106,6 +107,7 @@
 #ifdef FEAT_FOLDING
 	    wp->w_cline_folded = folded;
 #endif
+	    redraw_for_cursorline(wp);
 	    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);
 	}
 	if (done + n > wp->w_height)
@@ -124,6 +126,27 @@
 }
 
 /*
+ * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is
+ * set.
+ */
+    static void
+redraw_for_cursorline(wp)
+    win_T *wp;
+{
+    if ((wp->w_p_rnu
+#ifdef FEAT_SYN_HL
+		|| wp->w_p_cul
+#endif
+		)
+	    && (wp->w_valid & VALID_CROW) == 0
+# ifdef FEAT_INS_EXPAND
+	    && !pum_visible()
+# endif
+	    )
+	redraw_win_later(wp, SOME_VALID);
+}
+
+/*
  * Update curwin->w_topline and redraw if necessary.
  * Used to update the screen before printing a message.
  */
@@ -160,6 +183,18 @@
     if (!screen_valid(TRUE))
 	return;
 
+    /* If the window height is zero just use the cursor line. */
+    if (curwin->w_height == 0)
+    {
+	curwin->w_topline = curwin->w_cursor.lnum;
+	curwin->w_botline = curwin->w_topline;
+	curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
+#ifdef FEAT_SCROLLBIND
+	curwin->w_scbind_pos = 1;
+#endif
+	return;
+    }
+
     check_cursor_moved(curwin);
     if (curwin->w_valid & VALID_TOPLINE)
 	return;
@@ -772,6 +807,7 @@
 	}
     }
 
+    redraw_for_cursorline(curwin);
     wp->w_valid |= VALID_CROW|VALID_CHEIGHT;
 
     /* validate botline too, if update_screen doesn't do it */
@@ -1172,22 +1208,15 @@
     if (prev_skipcol != curwin->w_skipcol)
 	redraw_later(NOT_VALID);
 
-    /* Redraw when w_row changes and 'relativenumber' is set */
-    if (((curwin->w_valid & VALID_WROW) == 0 && (curwin->w_p_rnu
-#ifdef FEAT_SYN_HL
-	/* or when w_row changes and 'cursorline' is set. */
-						|| curwin->w_p_cul
-#endif
-	))
 #ifdef FEAT_SYN_HL
-	/* or when w_virtcol changes and 'cursorcolumn' is set */
-	|| (curwin->w_p_cuc && (curwin->w_valid & VALID_VIRTCOL) == 0)
-#endif
-	)
+    /* Redraw when w_virtcol changes and 'cursorcolumn' is set */
+    if (curwin->w_p_cuc && (curwin->w_valid & VALID_VIRTCOL) == 0
 # ifdef FEAT_INS_EXPAND
-	    if (!pum_visible())
+	    && !pum_visible()
 # endif
-		redraw_later(SOME_VALID);
+	)
+	redraw_later(SOME_VALID);
+#endif
 
     curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;
 }
@@ -2101,6 +2130,9 @@
     int		used;
     lineoff_T	loff;
     lineoff_T	boff;
+#ifdef FEAT_DIFF
+    linenr_T	old_topline = curwin->w_topline;
+#endif
 
     loff.lnum = boff.lnum = curwin->w_cursor.lnum;
 #ifdef FEAT_FOLDING
@@ -2156,6 +2188,8 @@
 	curwin->w_topline = topline;
 #ifdef FEAT_DIFF
     curwin->w_topfill = topfill;
+    if (old_topline > curwin->w_topline + curwin->w_height)
+	curwin->w_botfill = FALSE;
     check_topfill(curwin, FALSE);
 #endif
     curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
@@ -2492,8 +2526,8 @@
 		    }
 		    comp_botline(curwin);
 		    curwin->w_cursor.lnum = curwin->w_botline - 1;
-		    curwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|
-			    VALID_WROW|VALID_CROW);
+		    curwin->w_valid &=
+			    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);
 		}
 		else
 		{
@@ -2852,17 +2886,13 @@
     win_T	*old_curwin = curwin;
     buf_T	*old_curbuf = curbuf;
     int		restart_edit_save;
-# ifdef FEAT_VISUAL
     int		old_VIsual_select = VIsual_select;
     int		old_VIsual_active = VIsual_active;
-# endif
 
     /*
      * loop through the cursorbound windows
      */
-# ifdef FEAT_VISUAL
     VIsual_select = VIsual_active = 0;
-# endif
     for (curwin = firstwin; curwin; curwin = curwin->w_next)
     {
 	curbuf = curwin->w_buffer;
@@ -2911,10 +2941,8 @@
     /*
      * reset current-window
      */
-# ifdef FEAT_VISUAL
     VIsual_select = old_VIsual_select;
     VIsual_active = old_VIsual_active;
-# endif
     curwin = old_curwin;
     curbuf = old_curbuf;
 }
diff -Naur vim74.orig/src/netbeans.c vim74/src/netbeans.c
--- vim74.orig/src/netbeans.c	2012-06-20 17:56:18.000000000 +0000
+++ vim74/src/netbeans.c	2014-10-10 14:53:44.695379668 +0000
@@ -2232,11 +2232,9 @@
 
 	    nb_set_curbuf(buf->bufp);
 
-#ifdef FEAT_VISUAL
 	    /* Don't want Visual mode now. */
 	    if (VIsual_active)
 		end_visual_mode();
-#endif
 #ifdef NBDEBUG
 	    s = args;
 #endif
diff -Naur vim74.orig/src/normal.c vim74/src/normal.c
--- vim74.orig/src/normal.c	2013-07-14 11:24:37.000000000 +0000
+++ vim74/src/normal.c	2014-10-10 14:53:44.705379643 +0000
@@ -14,17 +14,15 @@
 
 #include "vim.h"
 
-#ifdef FEAT_VISUAL
 /*
  * The Visual area is remembered for reselection.
  */
 static int	resel_VIsual_mode = NUL;	/* 'v', 'V', or Ctrl-V */
 static linenr_T	resel_VIsual_line_count;	/* number of lines */
 static colnr_T	resel_VIsual_vcol;		/* nr of cols or end col */
-static int	VIsual_mode_orig = NUL;         /* type of Visual mode, that user entered */
+static int	VIsual_mode_orig = NUL;		/* saved Visual mode */
 
 static int	restart_VIsual_select = 0;
-#endif
 
 #ifdef FEAT_EVAL
 static void	set_vcount_ca __ARGS((cmdarg_T *cap, int *set_prevcount));
@@ -37,7 +35,7 @@
 static int	find_command __ARGS((int cmdchar));
 static void	op_colon __ARGS((oparg_T *oap));
 static void	op_function __ARGS((oparg_T *oap));
-#if defined(FEAT_MOUSE) && defined(FEAT_VISUAL)
+#if defined(FEAT_MOUSE)
 static void	find_start_of_word __ARGS((pos_T *));
 static void	find_end_of_word __ARGS((pos_T *));
 static int	get_mouse_class __ARGS((char_u *p));
@@ -48,9 +46,7 @@
 static int	checkclearopq __ARGS((oparg_T *oap));
 static void	clearop __ARGS((oparg_T *oap));
 static void	clearopbeep __ARGS((oparg_T *oap));
-#ifdef FEAT_VISUAL
 static void	unshift_special __ARGS((cmdarg_T *cap));
-#endif
 #ifdef FEAT_CMDL_INFO
 static void	del_from_showcmd __ARGS((int));
 #endif
@@ -117,25 +113,19 @@
 #ifdef FEAT_VREPLACE
 static void	nv_vreplace __ARGS((cmdarg_T *cap));
 #endif
-#ifdef FEAT_VISUAL
 static void	v_swap_corners __ARGS((int cmdchar));
-#endif
 static void	nv_replace __ARGS((cmdarg_T *cap));
 static void	n_swapchar __ARGS((cmdarg_T *cap));
 static void	nv_cursormark __ARGS((cmdarg_T *cap, int flag, pos_T *pos));
-#ifdef FEAT_VISUAL
 static void	v_visop __ARGS((cmdarg_T *cap));
-#endif
 static void	nv_subst __ARGS((cmdarg_T *cap));
 static void	nv_abbrev __ARGS((cmdarg_T *cap));
 static void	nv_optrans __ARGS((cmdarg_T *cap));
 static void	nv_gomark __ARGS((cmdarg_T *cap));
 static void	nv_pcmark __ARGS((cmdarg_T *cap));
 static void	nv_regname __ARGS((cmdarg_T *cap));
-#ifdef FEAT_VISUAL
 static void	nv_visual __ARGS((cmdarg_T *cap));
 static void	n_start_visual_mode __ARGS((int c));
-#endif
 static void	nv_window __ARGS((cmdarg_T *cap));
 static void	nv_suspend __ARGS((cmdarg_T *cap));
 static void	nv_g_cmd __ARGS((cmdarg_T *cap));
@@ -155,11 +145,9 @@
 static void	nv_wordcmd __ARGS((cmdarg_T *cap));
 static void	nv_beginline __ARGS((cmdarg_T *cap));
 static void	adjust_cursor __ARGS((oparg_T *oap));
-#ifdef FEAT_VISUAL
 static void	adjust_for_sel __ARGS((cmdarg_T *cap));
 static int	unadjust_for_sel __ARGS((void));
 static void	nv_select __ARGS((cmdarg_T *cap));
-#endif
 static void	nv_goto __ARGS((cmdarg_T *cap));
 static void	nv_normal __ARGS((cmdarg_T *cap));
 static void	nv_esc __ARGS((cmdarg_T *oap));
@@ -248,24 +236,14 @@
     {Ctrl_N,	nv_down,	NV_STS,			FALSE},
     {Ctrl_O,	nv_ctrlo,	0,			0},
     {Ctrl_P,	nv_up,		NV_STS,			FALSE},
-#ifdef FEAT_VISUAL
     {Ctrl_Q,	nv_visual,	0,			FALSE},
-#else
-    {Ctrl_Q,	nv_ignore,	0,			0},
-#endif
     {Ctrl_R,	nv_redo,	0,			0},
     {Ctrl_S,	nv_ignore,	0,			0},
     {Ctrl_T,	nv_tagpop,	NV_NCW,			0},
     {Ctrl_U,	nv_halfpage,	0,			0},
-#ifdef FEAT_VISUAL
     {Ctrl_V,	nv_visual,	0,			FALSE},
     {'V',	nv_visual,	0,			FALSE},
     {'v',	nv_visual,	0,			FALSE},
-#else
-    {Ctrl_V,	nv_error,	0,			0},
-    {'V',	nv_error,	0,			0},
-    {'v',	nv_error,	0,			0},
-#endif
     {Ctrl_W,	nv_window,	0,			0},
     {Ctrl_X,	nv_addsub,	0,			0},
     {Ctrl_Y,	nv_scroll_line,	0,			FALSE},
@@ -427,9 +405,7 @@
     {K_HELP,	nv_help,	NV_NCW,			0},
     {K_F1,	nv_help,	NV_NCW,			0},
     {K_XF1,	nv_help,	NV_NCW,			0},
-#ifdef FEAT_VISUAL
     {K_SELECT,	nv_select,	0,			0},
-#endif
 #ifdef FEAT_GUI
     {K_VER_SCROLLBAR, nv_ver_scrollbar, 0,		0},
     {K_HOR_SCROLLBAR, nv_hor_scrollbar, 0,		0},
@@ -579,11 +555,9 @@
 #ifdef FEAT_CMDL_INFO
     int		need_flushbuf;		/* need to call out_flush() */
 #endif
-#ifdef FEAT_VISUAL
     pos_T	old_pos;		/* cursor position before command */
     int		mapped_len;
     static int	old_mapped_len = 0;
-#endif
     int		idx;
 #ifdef FEAT_EVAL
     int		set_prevcount = FALSE;
@@ -643,9 +617,7 @@
     }
 #endif
 
-#ifdef FEAT_VISUAL
     mapped_len = typebuf_maplen();
-#endif
 
     State = NORMAL_BUSY;
 #ifdef USE_ON_FLY_SCROLL
@@ -655,8 +627,8 @@
 #ifdef FEAT_EVAL
     /* Set v:count here, when called from main() and not a stuffed
      * command, so that v:count can be used in an expression mapping
-     * when there is no count. */
-    if (toplevel && stuff_empty())
+     * when there is no count. Do set it for redo. */
+    if (toplevel && readbuf1_empty())
 	set_vcount_ca(&ca, &set_prevcount);
 #endif
 
@@ -666,7 +638,6 @@
     c = safe_vgetc();
     LANGMAP_ADJUST(c, TRUE);
 
-#ifdef FEAT_VISUAL
     /*
      * If a mapping was started in Visual or Select mode, remember the length
      * of the mapping.  This is used below to not return to Insert mode for as
@@ -677,12 +648,10 @@
     else if (old_mapped_len
 		|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))
 	old_mapped_len = typebuf_maplen();
-#endif
 
     if (c == NUL)
 	c = K_ZERO;
 
-#ifdef FEAT_VISUAL
     /*
      * In Select mode, typed text replaces the selection.
      */
@@ -703,16 +672,13 @@
 	msg_nowait = TRUE;	/* don't delay going to insert mode */
 	old_mapped_len = 0;	/* do go to Insert mode */
     }
-#endif
 
 #ifdef FEAT_CMDL_INFO
     need_flushbuf = add_to_showcmd(c);
 #endif
 
 getcount:
-#ifdef FEAT_VISUAL
     if (!(VIsual_active && VIsual_select))
-#endif
     {
 	/*
 	 * Handle a count before a command and compute ca.count0.
@@ -736,8 +702,8 @@
 #ifdef FEAT_EVAL
 	    /* Set v:count here, when called from main() and not a stuffed
 	     * command, so that v:count can be used in an expression mapping
-	     * right after the count. */
-	    if (toplevel && stuff_empty())
+	     * right after the count. Do set it for redo. */
+	    if (toplevel && readbuf1_empty())
 		set_vcount_ca(&ca, &set_prevcount);
 #endif
 	    if (ctrl_w)
@@ -819,8 +785,9 @@
 #ifdef FEAT_EVAL
     /*
      * Only set v:count when called from main() and not a stuffed command.
+     * Do set it for redo.
      */
-    if (toplevel && stuff_empty())
+    if (toplevel && readbuf1_empty())
 	set_vcount(ca.count0, ca.count1, set_prevcount);
 #endif
 
@@ -845,7 +812,7 @@
 
     if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW))
     {
-	/* This command is not allowed while editing a ccmdline: beep. */
+	/* This command is not allowed while editing a cmdline: beep. */
 	clearopbeep(oap);
 	text_locked_msg();
 	goto normal_end;
@@ -855,7 +822,6 @@
 	goto normal_end;
 #endif
 
-#ifdef FEAT_VISUAL
     /*
      * In Visual/Select mode, a few keys are handled in a special way.
      */
@@ -891,7 +857,6 @@
 	    }
 	}
     }
-#endif
 
 #ifdef FEAT_RIGHTLEFT
     if (curwin->w_p_rl && KeyTyped && !KeyStuffed
@@ -929,11 +894,7 @@
 		    && !Recording
 		    && !Exec_reg)
 		|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')
-		    && (oap->op_type != OP_NOP
-#ifdef FEAT_VISUAL
-			|| VIsual_active
-#endif
-		       ))))
+		    && (oap->op_type != OP_NOP || VIsual_active))))
     {
 	int	*cp;
 	int	repl = FALSE;	/* get character for replace mode */
@@ -962,11 +923,8 @@
 #ifdef FEAT_CMDL_INFO
 	    need_flushbuf |= add_to_showcmd(ca.nchar);
 #endif
-	    /* For "gn" from redo, need to get one more char to determine the
-	     * operator */
 	    if (ca.nchar == 'r' || ca.nchar == '\'' || ca.nchar == '`'
-						       || ca.nchar == Ctrl_BSL
-		  || ((ca.nchar == 'n' || ca.nchar == 'N') && !stuff_empty()))
+						       || ca.nchar == Ctrl_BSL)
 	    {
 		cp = &ca.extra_char;	/* need to get a third character */
 		if (ca.nchar != 'r')
@@ -1118,7 +1076,10 @@
 #ifdef FEAT_MBYTE
 	    /* When getting a text character and the next character is a
 	     * multi-byte character, it could be a composing character.
-	     * However, don't wait for it to arrive. */
+	     * However, don't wait for it to arrive. Also, do enable mapping,
+	     * because if it's put back with vungetc() it's too late to apply
+	     * mapping. */
+	    --no_mapping;
 	    while (enc_utf8 && lang && (c = vpeekc()) > 0
 				 && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))
 	    {
@@ -1133,6 +1094,7 @@
 		else
 		    ca.ncharC2 = c;
 	    }
+	    ++no_mapping;
 #endif
 	}
 	--no_mapping;
@@ -1170,7 +1132,6 @@
 	msg_col = 0;
     }
 
-#ifdef FEAT_VISUAL
     old_pos = curwin->w_cursor;		/* remember where cursor was */
 
     /* When 'keymodel' contains "startsel" some keys start Select/Visual
@@ -1190,7 +1151,6 @@
 	    mod_mask &= ~MOD_MASK_SHIFT;
 	}
     }
-#endif
 
     /*
      * Execute the command!
@@ -1222,12 +1182,10 @@
 #endif
     }
 
-#ifdef FEAT_VISUAL
     /* Get the length of mapped chars again after typing a count, second
      * character or "z333<cr>". */
     if (old_mapped_len > 0)
 	old_mapped_len = typebuf_maplen();
-#endif
 
     /*
      * If an operation is pending, handle it...
@@ -1249,11 +1207,9 @@
     if (       ((p_smd
 		    && msg_silent == 0
 		    && (restart_edit != 0
-#ifdef FEAT_VISUAL
 			|| (VIsual_active
 			    && old_pos.lnum == curwin->w_cursor.lnum
 			    && old_pos.col == curwin->w_cursor.col)
-#endif
 		       )
 		    && (clear_cmdline
 			|| redraw_cmdline)
@@ -1261,9 +1217,7 @@
 		    && !msg_nowait
 		    && KeyTyped)
 		|| (restart_edit != 0
-#ifdef FEAT_VISUAL
 		    && !VIsual_active
-#endif
 		    && (msg_scroll
 			|| emsg_on_display)))
 	    && oap->regname == 0
@@ -1370,36 +1324,24 @@
      * May switch from Visual to Select mode after CTRL-O command.
      */
     if (       oap->op_type == OP_NOP
-#ifdef FEAT_VISUAL
 	    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
 		|| restart_VIsual_select == 1)
-#else
-	    && restart_edit != 0
-#endif
 	    && !(ca.retval & CA_COMMAND_BUSY)
 	    && stuff_empty()
 	    && oap->regname == 0)
     {
-#ifdef FEAT_VISUAL
 	if (restart_VIsual_select == 1)
 	{
 	    VIsual_select = TRUE;
 	    showmode();
 	    restart_VIsual_select = 0;
 	}
-#endif
-	if (restart_edit != 0
-#ifdef FEAT_VISUAL
-		&& !VIsual_active && old_mapped_len == 0
-#endif
-		)
+	if (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)
 	    (void)edit(restart_edit, FALSE, 1L);
     }
 
-#ifdef FEAT_VISUAL
     if (restart_VIsual_select == 2)
 	restart_VIsual_select = 1;
-#endif
 
     /* Save count before an operator for next time. */
     opcount = ca.opcount;
@@ -1438,18 +1380,23 @@
     pos_T	old_cursor;
     int		empty_region_error;
     int		restart_edit_save;
+#ifdef FEAT_LINEBREAK
+    int		lbr_saved = curwin->w_p_lbr;
+#endif
 
-#ifdef FEAT_VISUAL
     /* The visual area is remembered for redo */
     static int	    redo_VIsual_mode = NUL; /* 'v', 'V', or Ctrl-V */
     static linenr_T redo_VIsual_line_count; /* number of lines */
     static colnr_T  redo_VIsual_vcol;	    /* number of cols or end column */
     static long	    redo_VIsual_count;	    /* count for Visual operator */
-# ifdef FEAT_VIRTUALEDIT
+#ifdef FEAT_VIRTUALEDIT
     int		    include_line_break = FALSE;
-# endif
 #endif
 
+#ifdef FEAT_LINEBREAK
+    curwin->w_p_lbr = FALSE;	/* Avoid a problem with unwanted linebreaks in
+				 * block mode. */
+#endif
 #if defined(FEAT_CLIPBOARD)
     /*
      * Yank the visual area into the GUI selection register before we operate
@@ -1461,10 +1408,8 @@
     if ((clip_star.available || clip_plus.available)
 	    && oap->op_type != OP_NOP
 	    && !gui_yank
-# ifdef FEAT_VISUAL
 	    && VIsual_active
 	    && !redo_VIsual_busy
-# endif
 	    && oap->regname == 0)
 	clip_auto_select();
 #endif
@@ -1473,13 +1418,8 @@
     /*
      * If an operation is pending, handle it...
      */
-    if ((finish_op
-#ifdef FEAT_VISUAL
-		|| VIsual_active
-#endif
-		) && oap->op_type != OP_NOP)
+    if ((finish_op || VIsual_active) && oap->op_type != OP_NOP)
     {
-#ifdef FEAT_VISUAL
 	oap->is_VIsual = VIsual_active;
 	if (oap->motion_force == 'V')
 	    oap->motion_type = MLINE;
@@ -1503,17 +1443,14 @@
 	    VIsual_select = FALSE;
 	    VIsual_reselect = FALSE;
 	}
-#endif
 
 	/* Only redo yank when 'y' flag is in 'cpoptions'. */
 	/* Never redo "zf" (define fold). */
 	if ((vim_strchr(p_cpo, CPO_YANK) != NULL || oap->op_type != OP_YANK)
-#ifdef FEAT_VISUAL
 		&& ((!VIsual_active || oap->motion_force)
 		    /* Also redo Operator-pending Visual mode mappings */
 		    || (VIsual_active && cap->cmdchar == ':'
 						 && oap->op_type != OP_COLON))
-#endif
 		&& cap->cmdchar != 'D'
 #ifdef FEAT_FOLDING
 		&& oap->op_type != OP_FOLD
@@ -1556,7 +1493,6 @@
 	    }
 	}
 
-#ifdef FEAT_VISUAL
 	if (redo_VIsual_busy)
 	{
 	    /* Redo of an operation on a Visual area. Use the same size from
@@ -1641,7 +1577,6 @@
 	    if (VIsual_mode == 'V')
 		oap->start.col = 0;
 	}
-#endif /* FEAT_VISUAL */
 
 	/*
 	 * Set oap->start to the first position of the operated text, oap->end
@@ -1692,7 +1627,6 @@
 	virtual_op = virtual_active();
 #endif
 
-#ifdef FEAT_VISUAL
 	if (VIsual_active || redo_VIsual_busy)
 	{
 	    if (VIsual_mode == Ctrl_V)	/* block mode */
@@ -1797,10 +1731,9 @@
 		 * otherwise it might be the second char of the operator. */
 		if (cap->cmdchar == 'g' && (cap->nchar == 'n'
 							|| cap->nchar == 'N'))
-		    /* "gn" and "gN" are a bit different */
-		    prep_redo(oap->regname, 0L, NUL, cap->cmdchar, cap->nchar,
-					get_op_char(oap->op_type),
-					get_extra_op_char(oap->op_type));
+		    prep_redo(oap->regname, cap->count0,
+			    get_op_char(oap->op_type), get_extra_op_char(oap->op_type),
+			    oap->motion_force, cap->cmdchar, cap->nchar);
 		else if (cap->cmdchar != ':')
 		    prep_redo(oap->regname, 0L, NUL, 'v',
 					get_op_char(oap->op_type),
@@ -1829,9 +1762,9 @@
 	    {
 		oap->motion_type = MCHAR;
 		if (VIsual_mode != Ctrl_V && *ml_get_pos(&(oap->end)) == NUL
-# ifdef FEAT_VIRTUALEDIT
+#ifdef FEAT_VIRTUALEDIT
 			&& (include_line_break || !virtual_op)
-# endif
+#endif
 			)
 		{
 		    oap->inclusive = FALSE;
@@ -1843,9 +1776,9 @@
 			{
 			    ++oap->end.lnum;
 			    oap->end.col = 0;
-# ifdef FEAT_VIRTUALEDIT
+#ifdef FEAT_VIRTUALEDIT
 			    oap->end.coladd = 0;
-# endif
+#endif
 			    ++oap->line_count;
 			}
 			else
@@ -1871,10 +1804,10 @@
 	    if (!gui_yank)
 	    {
 		VIsual_active = FALSE;
-# ifdef FEAT_MOUSE
+#ifdef FEAT_MOUSE
 		setmouse();
 		mouse_dragging = 0;
-# endif
+#endif
 		if (mode_displayed)
 		    clear_cmdline = TRUE;   /* unshow visual mode later */
 #ifdef FEAT_CMDL_INFO
@@ -1889,7 +1822,6 @@
 		    redraw_curbuf_later(INVERTED);
 	    }
 	}
-#endif
 
 #ifdef FEAT_MBYTE
 	/* Include the trailing byte of a multi-byte char. */
@@ -1924,16 +1856,14 @@
 	empty_region_error = (oap->empty
 				&& vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);
 
-#ifdef FEAT_VISUAL
 	/* Force a redraw when operating on an empty Visual region, when
 	 * 'modifiable is off or creating a fold. */
 	if (oap->is_VIsual && (oap->empty || !curbuf->b_p_ma
-# ifdef FEAT_FOLDING
+#ifdef FEAT_FOLDING
 		    || oap->op_type == OP_FOLD
-# endif
+#endif
 		    ))
 	    redraw_curbuf_later(INVERTED);
-#endif
 
 	/*
 	 * If the end of an operator is in column one while oap->motion_type
@@ -1946,10 +1876,8 @@
 		&& oap->inclusive == FALSE
 		&& !(cap->retval & CA_NO_ADJ_OP_END)
 		&& oap->end.col == 0
-#ifdef FEAT_VISUAL
 		&& (!oap->is_VIsual || *p_sel == 'o')
 		&& !oap->block_mode
-#endif
 		&& oap->line_count > 1)
 	{
 	    oap->end_adjusted = TRUE;	    /* remember that we did this */
@@ -1974,11 +1902,7 @@
 	{
 	case OP_LSHIFT:
 	case OP_RSHIFT:
-	    op_shift(oap, TRUE,
-#ifdef FEAT_VISUAL
-		    oap->is_VIsual ? (int)cap->count1 :
-#endif
-		    1);
+	    op_shift(oap, TRUE, oap->is_VIsual ? (int)cap->count1 : 1);
 	    auto_format(FALSE, TRUE);
 	    break;
 
@@ -1991,15 +1915,14 @@
 		beep_flush();
 	    else
 	    {
-		(void)do_join(oap->line_count, oap->op_type == OP_JOIN, TRUE, TRUE);
+		(void)do_join(oap->line_count, oap->op_type == OP_JOIN,
+							    TRUE, TRUE, TRUE);
 		auto_format(FALSE, TRUE);
 	    }
 	    break;
 
 	case OP_DELETE:
-#ifdef FEAT_VISUAL
 	    VIsual_reselect = FALSE;	    /* don't reselect now */
-#endif
 	    if (empty_region_error)
 	    {
 		vim_beep();
@@ -2029,9 +1952,7 @@
 	    break;
 
 	case OP_CHANGE:
-#ifdef FEAT_VISUAL
 	    VIsual_reselect = FALSE;	    /* don't reselect now */
-#endif
 	    if (empty_region_error)
 	    {
 		vim_beep();
@@ -2129,9 +2050,7 @@
 
 	case OP_INSERT:
 	case OP_APPEND:
-#ifdef FEAT_VISUAL
 	    VIsual_reselect = FALSE;	/* don't reselect now */
-#endif
 #ifdef FEAT_VISUALEXTRA
 	    if (empty_region_error)
 	    {
@@ -2161,9 +2080,7 @@
 	    break;
 
 	case OP_REPLACE:
-#ifdef FEAT_VISUAL
 	    VIsual_reselect = FALSE;	/* don't reselect now */
-#endif
 #ifdef FEAT_VISUALEXTRA
 	    if (empty_region_error)
 #endif
@@ -2223,11 +2140,12 @@
 	{
 	    curwin->w_cursor = old_cursor;
 	}
-#ifdef FEAT_VISUAL
 	oap->block_mode = FALSE;
-#endif
 	clearop(oap);
     }
+#ifdef FEAT_LINEBREAK
+    curwin->w_p_lbr = lbr_saved;
+#endif
 }
 
 /*
@@ -2238,11 +2156,9 @@
     oparg_T	*oap;
 {
     stuffcharReadbuff(':');
-#ifdef FEAT_VISUAL
     if (oap->is_VIsual)
 	stuffReadbuff((char_u *)"'<,'>");
     else
-#endif
     {
 	/*
 	 * Make the range look nice, so it can be repeated.
@@ -2407,14 +2323,12 @@
     pos_T	save_cursor;
 #endif
     win_T	*old_curwin = curwin;
-#ifdef FEAT_VISUAL
     static pos_T orig_cursor;
     colnr_T	leftcol, rightcol;
     pos_T	end_visual;
     int		diff;
     int		old_active = VIsual_active;
     int		old_mode = VIsual_mode;
-#endif
     int		regname;
 
 #if defined(FEAT_FOLDING)
@@ -2435,15 +2349,12 @@
 	if (!gui.in_use)
 #endif
 	{
-#ifdef FEAT_VISUAL
 	    if (VIsual_active)
 	    {
 		if (!mouse_has(MOUSE_VISUAL))
 		    return FALSE;
 	    }
-	    else
-#endif
-		if (State == NORMAL && !mouse_has(MOUSE_NORMAL))
+	    else if (State == NORMAL && !mouse_has(MOUSE_NORMAL))
 		return FALSE;
 	}
 
@@ -2512,14 +2423,6 @@
 	}
     }
 
-#ifndef FEAT_VISUAL
-    /*
-     * ALT is only used for starting/extending Visual mode.
-     */
-    if ((mod_mask & MOD_MASK_ALT))
-	return FALSE;
-#endif
-
     /*
      * CTRL right mouse button does CTRL-T
      */
@@ -2589,7 +2492,6 @@
 		return FALSE;
 	    }
 
-#ifdef FEAT_VISUAL
 	    /*
 	     * If visual was active, yank the highlighted text and put it
 	     * before the mouse pointer position.
@@ -2610,7 +2512,6 @@
 		do_always = TRUE;	/* ignore 'mouse' setting next time */
 		return FALSE;
 	    }
-#endif
 	    /*
 	     * The rest is below jump_to_mouse()
 	     */
@@ -2764,7 +2665,6 @@
 		{
 		    /* First set the cursor position before showing the popup
 		     * menu. */
-#ifdef FEAT_VISUAL
 		    if (VIsual_active)
 		    {
 			pos_T    m_pos;
@@ -2803,16 +2703,11 @@
 		    }
 		    else
 			jump_flags = MOUSE_MAY_STOP_VIS;
-#endif
 		}
 		if (jump_flags)
 		{
 		    jump_flags = jump_to_mouse(jump_flags, NULL, which_button);
-		    update_curbuf(
-#ifdef FEAT_VISUAL
-			    VIsual_active ? INVERTED :
-#endif
-			    VALID);
+		    update_curbuf(VIsual_active ? INVERTED : VALID);
 		    setcursor();
 		    out_flush();    /* Update before showing popup menu */
 		}
@@ -2835,7 +2730,6 @@
 	}
     }
 
-#ifdef FEAT_VISUAL
     if ((State & (NORMAL | INSERT))
 			    && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))
     {
@@ -2875,7 +2769,6 @@
 		jump_flags |= MOUSE_MAY_VIS;
 	}
     }
-#endif
 
     /*
      * If an operator is pending, ignore all drags and releases until the
@@ -2944,7 +2837,6 @@
     }
 #endif
 
-#ifdef FEAT_VISUAL
     /* Set global flag that we are extending the Visual area with mouse
      * dragging; temporarily minimize 'scrolloff'. */
     if (VIsual_active && is_drag && p_so)
@@ -3043,7 +2935,6 @@
      */
     else if ((State & INSERT) && VIsual_active)
 	stuffcharReadbuff(Ctrl_O);
-#endif
 
     /*
      * Middle mouse click: Put text before cursor.
@@ -3121,11 +3012,7 @@
      */
     else if ((mod_mask & MOD_MASK_SHIFT))
     {
-	if (State & INSERT
-#ifdef FEAT_VISUAL
-		|| (VIsual_active && VIsual_select)
-#endif
-		)
+	if ((State & INSERT) || (VIsual_active && VIsual_select))
 	    stuffcharReadbuff(Ctrl_O);
 	if (which_button == MOUSE_LEFT)
 	    stuffcharReadbuff('*');
@@ -3156,7 +3043,6 @@
 # endif
     }
 #endif
-#ifdef FEAT_VISUAL
     else if ((mod_mask & MOD_MASK_MULTI_CLICK) && (State & (NORMAL | INSERT))
 	     && mouse_has(MOUSE_VISUAL))
     {
@@ -3270,12 +3156,10 @@
 	    || (VIsual_active && p_smd && msg_silent == 0
 				 && (!old_active || VIsual_mode != old_mode)))
 	redraw_cmdline = TRUE;
-#endif
 
     return moved;
 }
 
-#ifdef FEAT_VISUAL
 /*
  * Move "pos" back to the start of the word it's in.
  */
@@ -3375,10 +3259,8 @@
 	return 1;
     return c;
 }
-#endif /* FEAT_VISUAL */
 #endif /* FEAT_MOUSE */
 
-#if defined(FEAT_VISUAL) || defined(PROTO)
 /*
  * Check if  highlighting for visual mode is possible, give a warning message
  * if not.
@@ -3471,7 +3353,6 @@
 	VIsual_reselect = FALSE;
     }
 }
-#endif /* FEAT_VISUAL */
 
 #if defined(FEAT_BEVAL)
 static int find_is_eval_item __ARGS((char_u *ptr, int *colp, int *nbp, int dir));
@@ -3805,11 +3686,7 @@
 checkclearopq(oap)
     oparg_T	*oap;
 {
-    if (oap->op_type == OP_NOP
-#ifdef FEAT_VISUAL
-	    && !VIsual_active
-#endif
-	    )
+    if (oap->op_type == OP_NOP && !VIsual_active)
 	return FALSE;
     clearopbeep(oap);
     return TRUE;
@@ -3833,7 +3710,6 @@
     beep_flush();
 }
 
-#ifdef FEAT_VISUAL
 /*
  * Remove the shift modifier from a special key.
  */
@@ -3852,18 +3728,13 @@
     }
     cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);
 }
-#endif
 
 #if defined(FEAT_CMDL_INFO) || defined(PROTO)
 /*
  * Routines for displaying a partly typed command
  */
 
-#ifdef FEAT_VISUAL	/* need room for size of Visual area */
-# define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30
-#else
-# define SHOWCMD_BUFLEN SHOWCMD_COLS + 1
-#endif
+#define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30
 static char_u	showcmd_buf[SHOWCMD_BUFLEN];
 static char_u	old_showcmd_buf[SHOWCMD_BUFLEN];  /* For push_showcmd() */
 static int	showcmd_is_clear = TRUE;
@@ -3877,7 +3748,6 @@
     if (!p_sc)
 	return;
 
-#ifdef FEAT_VISUAL
     if (VIsual_active && !char_avail())
     {
 	int		cursor_bot = lt(VIsual, curwin->w_cursor);
@@ -3963,7 +3833,6 @@
 	showcmd_visual = TRUE;
     }
     else
-#endif
     {
 	showcmd_buf[0] = NUL;
 	showcmd_visual = FALSE;
@@ -4025,6 +3894,8 @@
 #endif
 
     p = transchar(c);
+    if (*p == ' ')
+	STRCPY(p, "<20>");
     old_len = (int)STRLEN(showcmd_buf);
     extra_len = (int)STRLEN(p);
     overflow = old_len + extra_len - SHOWCMD_COLS;
@@ -4204,10 +4075,8 @@
     int		want_hor;
     win_T	*old_curwin = curwin;
     buf_T	*old_curbuf = curbuf;
-#ifdef FEAT_VISUAL
     int		old_VIsual_select = VIsual_select;
     int		old_VIsual_active = VIsual_active;
-#endif
     colnr_T	tgt_leftcol = curwin->w_leftcol;
     long	topline;
     long	y;
@@ -4224,9 +4093,7 @@
     /*
      * loop through the scrollbound windows and scroll accordingly
      */
-#ifdef FEAT_VISUAL
     VIsual_select = VIsual_active = 0;
-#endif
     for (curwin = firstwin; curwin; curwin = curwin->w_next)
     {
 	curbuf = curwin->w_buffer;
@@ -4281,10 +4148,8 @@
     /*
      * reset current-window
      */
-#ifdef FEAT_VISUAL
     VIsual_select = old_VIsual_select;
     VIsual_active = old_VIsual_active;
-#endif
     curwin = old_curwin;
     curbuf = old_curbuf;
 }
@@ -4646,18 +4511,29 @@
     }
 #endif
 
-    coladvance(curwin->w_curswant);
+    if (virtual_active() && atend)
+	coladvance(MAXCOL);
+    else
+	coladvance(curwin->w_curswant);
 
 #if defined(FEAT_LINEBREAK) || defined(FEAT_MBYTE)
     if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)
     {
+	colnr_T virtcol;
+
 	/*
 	 * Check for landing on a character that got split at the end of the
 	 * last line.  We want to advance a screenline, not end up in the same
 	 * screenline or move two screenlines.
 	 */
 	validate_virtcol();
-	if (curwin->w_virtcol > curwin->w_curswant
+	virtcol = curwin->w_virtcol;
+# if defined(FEAT_LINEBREAK)
+	if (virtcol > (colnr_T)width1 && *p_sbr != NUL)
+	    virtcol -= vim_strsize(p_sbr);
+# endif
+
+	if (virtcol > curwin->w_curswant
 		&& (curwin->w_curswant < (colnr_T)width1
 		    ? (curwin->w_curswant > (colnr_T)width1 / 2)
 		    : ((curwin->w_curswant - width1) % width2
@@ -5237,17 +5113,19 @@
 
 		    if (checkclearop(cap->oap))
 			break;
-# ifdef FEAT_VISUAL
 		    if (VIsual_active && get_visual_text(cap, &ptr, &len)
 								      == FAIL)
 			return;
-# endif
 		    if (ptr == NULL)
 		    {
 			pos_T	pos = curwin->w_cursor;
 
-			/* Find bad word under the cursor. */
+			/* Find bad word under the cursor.  When 'spell' is
+			 * off this fails and find_ident_under_cursor() is
+			 * used below. */
+			emsg_off++;
 			len = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);
+			emsg_off--;
 			if (len != 0 && curwin->w_cursor.col <= pos.col)
 			    ptr = ml_get_pos(&curwin->w_cursor);
 			curwin->w_cursor = pos;
@@ -5405,12 +5283,9 @@
     /*
      * Ignore 'Q' in Visual mode, just give a beep.
      */
-#ifdef FEAT_VISUAL
     if (VIsual_active)
 	vim_beep();
-    else
-#endif
-	if (!checkclearop(cap->oap))
+    else if (!checkclearop(cap->oap))
 	do_exmode(FALSE);
 }
 
@@ -5424,11 +5299,9 @@
     int	    old_p_im;
     int	    cmd_result;
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
 	nv_operator(cap);
     else
-#endif
     {
 	if (cap->oap->op_type != OP_NOP)
 	{
@@ -5488,15 +5361,12 @@
 nv_ctrlg(cap)
     cmdarg_T *cap;
 {
-#ifdef FEAT_VISUAL
     if (VIsual_active)	/* toggle Selection/Visual mode */
     {
 	VIsual_select = !VIsual_select;
 	showmode();
     }
-    else
-#endif
-	if (!checkclearop(cap->oap))
+    else if (!checkclearop(cap->oap))
 	/* print full name if count given or :cd used */
 	fileinfo((int)cap->count0, FALSE, TRUE);
 }
@@ -5508,14 +5378,12 @@
 nv_ctrlh(cap)
     cmdarg_T *cap;
 {
-#ifdef FEAT_VISUAL
     if (VIsual_active && VIsual_select)
     {
 	cap->cmdchar = 'x';	/* BS key behaves like 'x' in Select mode */
 	v_visop(cap);
     }
     else
-#endif
 	nv_left(cap);
 }
 
@@ -5552,7 +5420,6 @@
 nv_ctrlo(cap)
     cmdarg_T	*cap;
 {
-#ifdef FEAT_VISUAL
     if (VIsual_active && VIsual_select)
     {
 	VIsual_select = FALSE;
@@ -5560,7 +5427,6 @@
 	restart_VIsual_select = 2;	/* restart Select mode later */
     }
     else
-#endif
     {
 	cap->count1 = -cap->count1;
 	nv_pcmark(cap);
@@ -5669,10 +5535,8 @@
      */
     if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')
     {
-#ifdef FEAT_VISUAL
 	if (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)
 	    return;
-#endif
 	if (checkclearopq(cap->oap))
 	    return;
     }
@@ -5784,7 +5648,7 @@
     {
 	/* Escape the argument properly for a shell command */
 	ptr = vim_strnsave(ptr, n);
-	p = vim_strsave_shellescape(ptr, TRUE);
+	p = vim_strsave_shellescape(ptr, TRUE, TRUE);
 	vim_free(ptr);
 	if (p == NULL)
 	{
@@ -5866,7 +5730,6 @@
     vim_free(buf);
 }
 
-#if defined(FEAT_VISUAL) || defined(PROTO)
 /*
  * Get visually selected text, within one line only.
  * Returns FAIL if more than one line selected.
@@ -5911,7 +5774,6 @@
     reset_VIsual_and_resel();
     return OK;
 }
-#endif
 
 /*
  * CTRL-T: backwards in tag stack
@@ -6034,11 +5896,7 @@
     cmdarg_T	*cap;
 {
     long	n;
-#ifdef FEAT_VISUAL
-    int		PAST_LINE;
-#else
-# define PAST_LINE 0
-#endif
+    int		past_line;
 
     if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))
     {
@@ -6051,25 +5909,21 @@
 
     cap->oap->motion_type = MCHAR;
     cap->oap->inclusive = FALSE;
-#ifdef FEAT_VISUAL
-    PAST_LINE = (VIsual_active && *p_sel != 'o');
+    past_line = (VIsual_active && *p_sel != 'o');
 
-# ifdef FEAT_VIRTUALEDIT
+#ifdef FEAT_VIRTUALEDIT
     /*
-     * In virtual mode, there's no such thing as "PAST_LINE", as lines are
-     * (theoretically) infinitely long.
+     * In virtual edit mode, there's no such thing as "past_line", as lines
+     * are (theoretically) infinitely long.
      */
     if (virtual_active())
-	PAST_LINE = 0;
-# endif
+	past_line = 0;
 #endif
 
     for (n = cap->count1; n > 0; --n)
     {
-	if ((!PAST_LINE && oneright() == FAIL)
-#ifdef FEAT_VISUAL
-		|| (PAST_LINE && *ml_get_cursor() == NUL)
-#endif
+	if ((!past_line && oneright() == FAIL)
+		|| (past_line && *ml_get_cursor() == NUL)
 		)
 	{
 	    /*
@@ -6117,26 +5971,24 @@
 	    }
 	    break;
 	}
-#ifdef FEAT_VISUAL
-	else if (PAST_LINE)
+	else if (past_line)
 	{
 	    curwin->w_set_curswant = TRUE;
-# ifdef FEAT_VIRTUALEDIT
+#ifdef FEAT_VIRTUALEDIT
 	    if (virtual_active())
 		oneright();
 	    else
-# endif
+#endif
 	    {
-# ifdef FEAT_MBYTE
+#ifdef FEAT_MBYTE
 		if (has_mbyte)
 		    curwin->w_cursor.col +=
 					 (*mb_ptr2len)(ml_get_cursor());
 		else
-# endif
+#endif
 		    ++curwin->w_cursor.col;
 	    }
 	}
-#endif
     }
 #ifdef FEAT_FOLDING
     if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped
@@ -6196,8 +6048,17 @@
 			    || cap->oap->op_type == OP_CHANGE)
 			&& !lineempty(curwin->w_cursor.lnum))
 		{
-		    if (*ml_get_cursor() != NUL)
-			++curwin->w_cursor.col;
+		    char_u *cp = ml_get_cursor();
+
+		    if (*cp != NUL)
+		    {
+#ifdef FEAT_MBYTE
+			if (has_mbyte)
+			    curwin->w_cursor.col += (*mb_ptr2len)(cp);
+			else
+#endif
+			    ++curwin->w_cursor.col;
+		    }
 		    cap->retval |= CA_NO_ADJ_OP_END;
 		}
 		continue;
@@ -6488,9 +6349,7 @@
 	else
 	    curwin->w_cursor.coladd = 0;
 #endif
-#ifdef FEAT_VISUAL
 	adjust_for_sel(cap);
-#endif
 #ifdef FEAT_FOLDING
 	if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
 	    foldOpenCursor();
@@ -6736,10 +6595,54 @@
     {
 	if (!checkclearop(cap->oap))
 	{
+	    int	    dir = (cap->cmdchar == ']' && cap->nchar == 'p')
+							 ? FORWARD : BACKWARD;
+	    int	    regname = cap->oap->regname;
+	    int	    was_visual = VIsual_active;
+	    int	    line_count = curbuf->b_ml.ml_line_count;
+	    pos_T   start, end;
+
+	    if (VIsual_active)
+	    {
+		start = ltoreq(VIsual, curwin->w_cursor)
+						  ? VIsual : curwin->w_cursor;
+		end =  equalpos(start,VIsual) ? curwin->w_cursor : VIsual;
+		curwin->w_cursor = (dir == BACKWARD ? start : end);
+	    }
+# ifdef FEAT_CLIPBOARD
+	    adjust_clip_reg(&regname);
+# endif
 	    prep_redo_cmd(cap);
-	    do_put(cap->oap->regname,
-	      (cap->cmdchar == ']' && cap->nchar == 'p') ? FORWARD : BACKWARD,
-						  cap->count1, PUT_FIXINDENT);
+
+	    do_put(regname, dir, cap->count1, PUT_FIXINDENT);
+	    if (was_visual)
+	    {
+		VIsual = start;
+		curwin->w_cursor = end;
+		if (dir == BACKWARD)
+		{
+		    /* adjust lines */
+		    VIsual.lnum += curbuf->b_ml.ml_line_count - line_count;
+		    curwin->w_cursor.lnum +=
+				      curbuf->b_ml.ml_line_count - line_count;
+		}
+
+		VIsual_active = TRUE;
+		if (VIsual_mode == 'V')
+		{
+		    /* delete visually selected lines */
+		    cap->cmdchar = 'd';
+		    cap->nchar = NUL;
+		    cap->oap->regname = regname;
+		    nv_operator(cap);
+		    do_pending_operator(cap, 0, FALSE);
+		}
+		if (VIsual_active)
+		{
+		    end_visual_mode();
+		    redraw_later(SOME_VALID);
+		}
+	    }
 	}
     }
 
@@ -6873,9 +6776,7 @@
 #ifdef FEAT_VIRTUALEDIT
 	    curwin->w_cursor.coladd = 0;
 #endif
-#ifdef FEAT_VISUAL
 	    adjust_for_sel(cap);
-#endif
 	}
     }
 #ifdef FEAT_FOLDING
@@ -6964,11 +6865,7 @@
 nv_undo(cap)
     cmdarg_T	*cap;
 {
-    if (cap->oap->op_type == OP_LOWER
-#ifdef FEAT_VISUAL
-	    || VIsual_active
-#endif
-	    )
+    if (cap->oap->op_type == OP_LOWER || VIsual_active)
     {
 	/* translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu" */
 	cap->cmdchar = 'g';
@@ -7026,16 +6923,21 @@
 	return;
     }
 
-#ifdef FEAT_VISUAL
     /* Visual mode "r" */
     if (VIsual_active)
     {
 	if (got_int)
 	    reset_VIsual();
+	if (had_ctrl_v)
+	{
+	    if (cap->nchar == '\r')
+		cap->nchar = -1;
+	    else if (cap->nchar == '\n')
+		cap->nchar = -2;
+	}
 	nv_operator(cap);
 	return;
     }
-#endif
 
 #ifdef FEAT_VIRTUALEDIT
     /* Break tabs, etc. */
@@ -7203,7 +7105,6 @@
     }
 }
 
-#ifdef FEAT_VISUAL
 /*
  * 'o': Exchange start and end of Visual area.
  * 'O': same, but in block mode exchange left and right corners.
@@ -7256,7 +7157,6 @@
 	curwin->w_set_curswant = TRUE;
     }
 }
-#endif /* FEAT_VISUAL */
 
 /*
  * "R" (cap->arg is FALSE) and "gR" (cap->arg is TRUE).
@@ -7265,7 +7165,6 @@
 nv_Replace(cap)
     cmdarg_T	    *cap;
 {
-#ifdef FEAT_VISUAL
     if (VIsual_active)		/* "R" is replace lines */
     {
 	cap->cmdchar = 'c';
@@ -7274,9 +7173,7 @@
 	VIsual_mode = 'V';
 	nv_operator(cap);
     }
-    else
-#endif
-	if (!checkclearopq(cap->oap))
+    else if (!checkclearopq(cap->oap))
     {
 	if (!curbuf->b_p_ma)
 	    EMSG(_(e_modifiable));
@@ -7299,16 +7196,13 @@
 nv_vreplace(cap)
     cmdarg_T	*cap;
 {
-# ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	cap->cmdchar = 'r';
 	cap->nchar = cap->extra_char;
 	nv_replace(cap);	/* Do same as "r" in Visual mode for now */
     }
-    else
-# endif
-	if (!checkclearopq(cap->oap))
+    else if (!checkclearopq(cap->oap))
     {
 	if (!curbuf->b_p_ma)
 	    EMSG(_(e_modifiable));
@@ -7455,7 +7349,6 @@
     curwin->w_set_curswant = TRUE;
 }
 
-#ifdef FEAT_VISUAL
 /*
  * Handle commands that are operators in Visual mode.
  */
@@ -7480,7 +7373,6 @@
     cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);
     nv_operator(cap);
 }
-#endif
 
 /*
  * "s" and "S" commands.
@@ -7489,7 +7381,6 @@
 nv_subst(cap)
     cmdarg_T	*cap;
 {
-#ifdef FEAT_VISUAL
     if (VIsual_active)	/* "vs" and "vS" are the same as "vc" */
     {
 	if (cap->cmdchar == 'S')
@@ -7501,7 +7392,6 @@
 	nv_operator(cap);
     }
     else
-#endif
 	nv_optrans(cap);
 }
 
@@ -7515,12 +7405,10 @@
     if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)
 	cap->cmdchar = 'x';		/* DEL key behaves like 'x' */
 
-#ifdef FEAT_VISUAL
     /* in Visual mode these commands are operators */
     if (VIsual_active)
 	v_visop(cap);
     else
-#endif
 	nv_optrans(cap);
 }
 
@@ -7688,7 +7576,6 @@
 	clearopbeep(cap->oap);
 }
 
-#ifdef FEAT_VISUAL
 /*
  * Handle "v", "V" and "CTRL-V" commands.
  * Also for "gh", "gH" and "g^H" commands: Always start Select mode, cap->arg
@@ -7880,7 +7767,6 @@
     }
 }
 
-#endif /* FEAT_VISUAL */
 
 /*
  * CTRL-W: Window commands
@@ -7905,10 +7791,8 @@
     cmdarg_T	*cap;
 {
     clearop(cap->oap);
-#ifdef FEAT_VISUAL
     if (VIsual_active)
 	end_visual_mode();		/* stop Visual mode */
-#endif
     do_cmdline_cmd((char_u *)"st");
 }
 
@@ -7920,9 +7804,7 @@
     cmdarg_T	*cap;
 {
     oparg_T	*oap = cap->oap;
-#ifdef FEAT_VISUAL
     pos_T	tpos;
-#endif
     int		i;
     int		flag = FALSE;
 
@@ -7955,7 +7837,6 @@
 	do_cmdline_cmd((char_u *)"%s//~/&");
 	break;
 
-#ifdef FEAT_VISUAL
     /*
      * "gv": Reselect the previous Visual area.  If Visual already active,
      *	     exchange previous and current Visual area.
@@ -8056,7 +7937,6 @@
 	cap->arg = TRUE;
 	nv_visual(cap);
 	break;
-#endif /* FEAT_VISUAL */
 
     /* "gn", "gN" visually select next/previous search match
      * "gn" selects next match
@@ -8064,9 +7944,7 @@
      */
     case 'N':
     case 'n':
-#ifdef FEAT_VISUAL
 	if (!current_search(cap->count1, cap->nchar == 'n'))
-#endif
 	    clearopbeep(oap);
 	break;
 
@@ -8188,9 +8066,7 @@
 				    && vim_iswhite(ptr[curwin->w_cursor.col]))
 		--curwin->w_cursor.col;
 	    curwin->w_set_curswant = TRUE;
-#ifdef FEAT_VISUAL
 	    adjust_for_sel(cap);
-#endif
 	}
 	break;
 
@@ -8587,11 +8463,7 @@
     cmdarg_T	*cap;
 {
     /* In Visual mode and typing "gUU" triggers an operator */
-    if (cap->oap->op_type == OP_UPPER
-#ifdef FEAT_VISUAL
-	    || VIsual_active
-#endif
-	    )
+    if (cap->oap->op_type == OP_UPPER || VIsual_active)
     {
 	/* translate "gUU" to "gUgU" */
 	cap->cmdchar = 'g';
@@ -8613,11 +8485,7 @@
 nv_tilde(cap)
     cmdarg_T	*cap;
 {
-    if (!p_to
-#ifdef FEAT_VISUAL
-	    && !VIsual_active
-#endif
-	    && cap->oap->op_type != OP_TILDE)
+    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)
 	n_swapchar(cap);
     else
 	nv_operator(cap);
@@ -8836,9 +8704,7 @@
 	clearopbeep(cap->oap);
     else
     {
-#ifdef FEAT_VISUAL
 	adjust_for_sel(cap);
-#endif
 #ifdef FEAT_FOLDING
 	if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
 	    foldOpenCursor();
@@ -8861,9 +8727,7 @@
      * - 'virtualedit' is not "all" and not "onemore".
      */
     if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL
-#ifdef FEAT_VISUAL
 		&& (!VIsual_active || *p_sel == 'o')
-#endif
 #ifdef FEAT_VIRTUALEDIT
 		&& !virtual_active() && (ve_flags & VE_ONEMORE) == 0
 #endif
@@ -8898,7 +8762,6 @@
 			       one-character line). */
 }
 
-#ifdef FEAT_VISUAL
 /*
  * In exclusive Visual mode, may include the last character.
  */
@@ -8909,11 +8772,11 @@
     if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
 	    && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor))
     {
-# ifdef FEAT_MBYTE
+#ifdef FEAT_MBYTE
 	if (has_mbyte)
 	    inc_cursor();
 	else
-# endif
+#endif
 	    ++curwin->w_cursor.col;
 	cap->oap->inclusive = FALSE;
     }
@@ -8974,7 +8837,6 @@
     }
 }
 
-#endif
 
 /*
  * "G", "gg", CTRL-END, CTRL-HOME.
@@ -9025,13 +8887,11 @@
 	if (cmdwin_type != 0)
 	    cmdwin_result = Ctrl_C;
 #endif
-#ifdef FEAT_VISUAL
 	if (VIsual_active)
 	{
 	    end_visual_mode();		/* stop Visual */
 	    redraw_curbuf_later(INVERTED);
 	}
-#endif
 	/* CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set. */
 	if (cap->nchar == Ctrl_G && p_im)
 	    restart_edit = 'a';
@@ -9062,9 +8922,7 @@
 #ifdef FEAT_CMDWIN
 		&& cmdwin_type == 0
 #endif
-#ifdef FEAT_VISUAL
 		&& !VIsual_active
-#endif
 		&& no_reason)
 	    MSG(_("Type  :quit<Enter>  to exit Vim"));
 
@@ -9082,7 +8940,6 @@
 #endif
     }
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	end_visual_mode();	/* stop Visual */
@@ -9090,10 +8947,8 @@
 	curwin->w_set_curswant = TRUE;
 	redraw_curbuf_later(INVERTED);
     }
-    else
-#endif
-	if (no_reason)
-	    vim_beep();
+    else if (no_reason)
+	vim_beep();
     clearop(cap->oap);
 
     /* A CTRL-C is often used at the start of a menu.  When 'insertmode' is
@@ -9117,20 +8972,13 @@
     if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)
 	cap->cmdchar = 'i';
 
-#ifdef FEAT_VISUAL
     /* in Visual mode "A" and "I" are an operator */
     if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))
 	v_visop(cap);
 
     /* in Visual mode and after an operator "a" and "i" are for text objects */
-    else
-#endif
-	if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')
-	    && (cap->oap->op_type != OP_NOP
-#ifdef FEAT_VISUAL
-		|| VIsual_active
-#endif
-		))
+    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')
+	    && (cap->oap->op_type != OP_NOP || VIsual_active))
     {
 #ifdef FEAT_TEXTOBJ
 	nv_object(cap);
@@ -9397,12 +9245,9 @@
 nv_join(cap)
     cmdarg_T *cap;
 {
-#ifdef FEAT_VISUAL
     if (VIsual_active)	/* join the visual lines */
 	nv_operator(cap);
-    else
-#endif
-	if (!checkclearop(cap->oap))
+    else if (!checkclearop(cap->oap))
     {
 	if (cap->count0 <= 1)
 	    cap->count0 = 2;	    /* default for join is two lines! */
@@ -9413,7 +9258,7 @@
 	{
 	    prep_redo(cap->oap->regname, cap->count0,
 			 NUL, cap->cmdchar, NUL, NUL, cap->nchar);
-	    (void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE);
+	    (void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);
 	}
     }
 }
@@ -9425,12 +9270,10 @@
 nv_put(cap)
     cmdarg_T  *cap;
 {
-#ifdef FEAT_VISUAL
     int		regname = 0;
     void	*reg1 = NULL, *reg2 = NULL;
     int		empty = FALSE;
     int		was_visual = FALSE;
-#endif
     int		dir;
     int		flags = 0;
 
@@ -9456,7 +9299,6 @@
 	if (cap->cmdchar == 'g')
 	    flags |= PUT_CURSEND;
 
-#ifdef FEAT_VISUAL
 	if (VIsual_active)
 	{
 	    /* Putting in Visual mode: The put text replaces the selected
@@ -9466,14 +9308,14 @@
 	     */
 	    was_visual = TRUE;
 	    regname = cap->oap->regname;
-# ifdef FEAT_CLIPBOARD
+#ifdef FEAT_CLIPBOARD
 	    adjust_clip_reg(&regname);
-# endif
-           if (regname == 0 || regname == '"'
+#endif
+	   if (regname == 0 || regname == '"'
 				     || VIM_ISDIGIT(regname) || regname == '-'
-# ifdef FEAT_CLIPBOARD
+#ifdef FEAT_CLIPBOARD
 		    || (clip_unnamed && (regname == '*' || regname == '+'))
-# endif
+#endif
 
 		    )
 	    {
@@ -9518,11 +9360,11 @@
 		/* cursor is at the end of the line or end of file, put
 		 * forward. */
 		dir = FORWARD;
+	    /* May have been reset in do_put(). */
+	    VIsual_active = TRUE;
 	}
-#endif
 	do_put(cap->oap->regname, dir, cap->count1, flags);
 
-#ifdef FEAT_VISUAL
 	/* If a register was saved, put it back now. */
 	if (reg2 != NULL)
 	    put_register(regname, reg2);
@@ -9549,7 +9391,6 @@
 		coladvance((colnr_T)MAXCOL);
 	    }
 	}
-#endif
 	auto_format(FALSE, TRUE);
     }
 }
@@ -9570,11 +9411,9 @@
     }
     else
 #endif
-#ifdef FEAT_VISUAL
     if (VIsual_active)  /* switch start and end of visual */
 	v_swap_corners(cap->cmdchar);
     else
-#endif
 	n_opencmd(cap);
 }
 
diff -Naur vim74.orig/src/ops.c vim74/src/ops.c
--- vim74.orig/src/ops.c	2013-08-09 17:34:32.000000000 +0000
+++ vim74/src/ops.c	2014-10-10 14:53:44.712046292 +0000
@@ -57,9 +57,7 @@
     char_u	**y_array;	/* pointer to array of line pointers */
     linenr_T	y_size;		/* number of lines in y_array */
     char_u	y_type;		/* MLINE, MCHAR or MBLOCK */
-#ifdef FEAT_VISUAL
     colnr_T	y_width;	/* only set if y_type == MBLOCK */
-#endif
 } y_regs[NUM_REGISTERS];
 
 static struct yankreg	*y_current;	    /* ptr to current yankreg */
@@ -107,19 +105,15 @@
 static int	yank_copy_line __ARGS((struct block_def *bd, long y_idx));
 #ifdef FEAT_CLIPBOARD
 static void	copy_yank_reg __ARGS((struct yankreg *reg));
-# if defined(FEAT_VISUAL) || defined(FEAT_EVAL)
 static void	may_set_selection __ARGS((void));
-# endif
 #endif
 static void	dis_msg __ARGS((char_u *p, int skip_esc));
 #if defined(FEAT_COMMENTS) || defined(PROTO)
 static char_u	*skip_comment __ARGS((char_u *line, int process, int include_space, int *is_comment));
 #endif
-#ifdef FEAT_VISUAL
 static void	block_prep __ARGS((oparg_T *oap, struct block_def *, linenr_T, int));
-#endif
 #if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)
-static void	str_to_reg __ARGS((struct yankreg *y_ptr, int type, char_u *str, long len, long blocklen));
+static void	str_to_reg __ARGS((struct yankreg *y_ptr, int yank_type, char_u *str, long len, long blocklen, int str_list));
 #endif
 static int	ends_in_white __ARGS((linenr_T lnum));
 #ifdef FEAT_COMMENTS
@@ -187,7 +181,6 @@
     return i;
 }
 
-#if defined(FEAT_VISUAL) || defined(PROTO)
 /*
  * Return TRUE if operator "op" always works on whole lines.
  */
@@ -197,7 +190,6 @@
 {
     return opchars[op][2];
 }
-#endif
 
 /*
  * Get first operator command character.
@@ -232,18 +224,14 @@
     long	    i;
     int		    first_char;
     char_u	    *s;
-#ifdef FEAT_VISUAL
     int		    block_col = 0;
-#endif
 
     if (u_save((linenr_T)(oap->start.lnum - 1),
 				       (linenr_T)(oap->end.lnum + 1)) == FAIL)
 	return;
 
-#ifdef FEAT_VISUAL
     if (oap->block_mode)
 	block_col = curwin->w_cursor.col;
-#endif
 
     for (i = oap->line_count; --i >= 0; )
     {
@@ -272,15 +260,12 @@
     foldOpenCursor();
 #endif
 
-#ifdef FEAT_VISUAL
     if (oap->block_mode)
     {
 	curwin->w_cursor.lnum = oap->start.lnum;
 	curwin->w_cursor.col = block_col;
     }
-    else
-#endif
-	if (curs_top)	    /* put cursor on first line, for ">>" */
+    else if (curs_top)	    /* put cursor on first line, for ">>" */
     {
 	curwin->w_cursor.lnum = oap->start.lnum;
 	beginline(BL_SOL | BL_FIX);   /* shift_line() may have set cursor.col */
@@ -336,7 +321,7 @@
 {
     int		count;
     int		i, j;
-    int		p_sw = (int)get_sw_value();
+    int		p_sw = (int)get_sw_value(curbuf);
 
     count = get_indent();	/* get current indent */
 
@@ -392,7 +377,7 @@
     int			total;
     char_u		*newp, *oldp;
     int			oldcol = curwin->w_cursor.col;
-    int			p_sw = (int)get_sw_value();
+    int			p_sw = (int)get_sw_value(curbuf);
     int			p_ts = (int)curbuf->b_p_ts;
     struct block_def	bd;
     int			incr;
@@ -435,7 +420,9 @@
 	}
 	for ( ; vim_iswhite(*bd.textstart); )
 	{
-	    incr = lbr_chartabsize_adv(&bd.textstart, (colnr_T)(bd.start_vcol));
+	    /* TODO: is passing bd.textstart for start of the line OK? */
+	    incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart,
+						    (colnr_T)(bd.start_vcol));
 	    total += incr;
 	    bd.start_vcol += incr;
 	}
@@ -495,7 +482,7 @@
 
 	while (vim_iswhite(*non_white))
 	{
-	    incr = lbr_chartabsize_adv(&non_white, non_white_col);
+	    incr = lbr_chartabsize_adv(bd.textstart, &non_white, non_white_col);
 	    non_white_col += incr;
 	}
 
@@ -520,7 +507,11 @@
 	    verbatim_copy_width -= bd.start_char_vcols;
 	while (verbatim_copy_width < destination_col)
 	{
-	    incr = lbr_chartabsize(verbatim_copy_end, verbatim_copy_width);
+	    char_u *line = verbatim_copy_end;
+
+	    /* TODO: is passing verbatim_copy_end for start of the line OK? */
+	    incr = lbr_chartabsize(line, verbatim_copy_end,
+							 verbatim_copy_width);
 	    if (verbatim_copy_width + incr > destination_col)
 		break;
 	    verbatim_copy_width += incr;
@@ -618,6 +609,26 @@
 	    }
 	}
 
+#ifdef FEAT_MBYTE
+	if (has_mbyte && spaces > 0)
+	{
+	    /* Avoid starting halfway a multi-byte character. */
+	    if (b_insert)
+	    {
+		int off = (*mb_head_off)(oldp, oldp + offset + spaces);
+		spaces -= off;
+		count -= off;
+	    }
+	    else
+	    {
+		int off = (*mb_off_next)(oldp, oldp + offset);
+		offset += off;
+		spaces = 0;
+		count = 0;
+	    }
+	}
+#endif
+
 	newp = alloc_check((unsigned)(STRLEN(oldp)) + s_len + count + 1);
 	if (newp == NULL)
 	    continue;
@@ -733,14 +744,10 @@
      * there is no change still need to remove the Visual highlighting. */
     if (last_changed != 0)
 	changed_lines(first_changed, 0,
-#ifdef FEAT_VISUAL
 		oap->is_VIsual ? start_lnum + oap->line_count :
-#endif
 		last_changed + 1, 0L);
-#ifdef FEAT_VISUAL
     else if (oap->is_VIsual)
 	redraw_curbuf_later(INVERTED);
-#endif
 
     if (oap->line_count > p_report)
     {
@@ -948,7 +955,6 @@
 }
 #endif
 
-#if defined(FEAT_VISUAL) || defined(PROTO)
 /*
  * Obtain the contents of a "normal" register. The register is made empty.
  * The returned pointer has allocated memory, use put_register() later.
@@ -1016,10 +1022,10 @@
     *y_current = *(struct yankreg *)reg;
     vim_free(reg);
 
-# ifdef FEAT_CLIPBOARD
+#ifdef FEAT_CLIPBOARD
     /* Send text written to clipboard register to the clipboard. */
     may_set_selection();
-# endif
+#endif
 }
 
     void
@@ -1034,7 +1040,6 @@
     vim_free(reg);
     *y_current = tmp;
 }
-#endif
 
 #if defined(FEAT_MOUSE) || defined(PROTO)
 /*
@@ -1612,9 +1617,15 @@
 {
     /* If no reg. specified, and "unnamed" or "unnamedplus" is in 'clipboard',
      * use '*' or '+' reg, respectively. "unnamedplus" prevails. */
-    if (*rp == 0 && clip_unnamed != 0)
-	*rp = ((clip_unnamed & CLIP_UNNAMED_PLUS) && clip_plus.available)
+    if (*rp == 0 && (clip_unnamed != 0 || clip_unnamed_saved != 0))
+    {
+	if (clip_unnamed != 0)
+	    *rp = ((clip_unnamed & CLIP_UNNAMED_PLUS) && clip_plus.available)
 								  ? '+' : '*';
+	else
+	    *rp = ((clip_unnamed_saved & CLIP_UNNAMED_PLUS) && clip_plus.available)
+								  ? '+' : '*';
+    }
     if (!clip_star.available && *rp == '*')
 	*rp = 0;
     if (!clip_plus.available && *rp == '+')
@@ -1634,10 +1645,8 @@
     int			n;
     linenr_T		lnum;
     char_u		*ptr;
-#ifdef FEAT_VISUAL
     char_u		*newp, *oldp;
     struct block_def	bd;
-#endif
     linenr_T		old_lcount = curbuf->b_ml.ml_line_count;
     int			did_yank = FALSE;
     int			orig_regname = oap->regname;
@@ -1670,10 +1679,8 @@
      * delete linewise.  Don't do this for the change command or Visual mode.
      */
     if (       oap->motion_type == MCHAR
-#ifdef FEAT_VISUAL
 	    && !oap->is_VIsual
 	    && !oap->block_mode
-#endif
 	    && oap->line_count > 1
 	    && oap->motion_force == NUL
 	    && oap->op_type == OP_DELETE)
@@ -1787,7 +1794,6 @@
 	}
     }
 
-#ifdef FEAT_VISUAL
     /*
      * block mode delete
      */
@@ -1838,9 +1844,7 @@
 						       oap->end.lnum + 1, 0L);
 	oap->line_count = 0;	    /* no lines deleted */
     }
-    else
-#endif
-	if (oap->motion_type == MLINE)
+    else if (oap->motion_type == MLINE)
     {
 	if (oap->op_type == OP_CHANGE)
 	{
@@ -1924,13 +1928,10 @@
 		return FAIL;
 
 	    /* if 'cpoptions' contains '$', display '$' at end of change */
-	    if (	   vim_strchr(p_cpo, CPO_DOLLAR) != NULL
+	    if (       vim_strchr(p_cpo, CPO_DOLLAR) != NULL
 		    && oap->op_type == OP_CHANGE
 		    && oap->end.lnum == curwin->w_cursor.lnum
-#ifdef FEAT_VISUAL
-		    && !oap->is_VIsual
-#endif
-		    )
+		    && !oap->is_VIsual)
 		display_dollar(oap->end.col - !oap->inclusive);
 
 	    n = oap->end.col - oap->start.col + 1 - !oap->inclusive;
@@ -1967,11 +1968,8 @@
 	    }
 	    else
 	    {
-		(void)del_bytes((long)n, !virtual_op, oap->op_type == OP_DELETE
-#ifdef FEAT_VISUAL
-				    && !oap->is_VIsual
-#endif
-							);
+		(void)del_bytes((long)n, !virtual_op,
+				oap->op_type == OP_DELETE && !oap->is_VIsual);
 	    }
 	}
 	else				/* delete characters between lines */
@@ -2008,15 +2006,12 @@
 	    {
 		/* delete from start of line until op_end */
 		curwin->w_cursor.col = 0;
-		(void)del_bytes((long)n, !virtual_op, oap->op_type == OP_DELETE
-#ifdef FEAT_VISUAL
-					&& !oap->is_VIsual
-#endif
-							    );
+		(void)del_bytes((long)n, !virtual_op,
+				oap->op_type == OP_DELETE && !oap->is_VIsual);
 		curwin->w_cursor = curpos;	/* restore curwin->w_cursor */
 	    }
 	    if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
-		(void)do_join(2, FALSE, FALSE, FALSE);
+		(void)do_join(2, FALSE, FALSE, FALSE, FALSE);
 	}
     }
 
@@ -2025,14 +2020,12 @@
 #ifdef FEAT_VIRTUALEDIT
 setmarks:
 #endif
-#ifdef FEAT_VISUAL
     if (oap->block_mode)
     {
 	curbuf->b_op_end.lnum = oap->end.lnum;
 	curbuf->b_op_end.col = oap->start.col;
     }
     else
-#endif
 	curbuf->b_op_end = oap->start;
     curbuf->b_op_start = oap->start;
 
@@ -2074,10 +2067,15 @@
     char_u		*newp, *oldp;
     size_t		oldlen;
     struct block_def	bd;
+    char_u		*after_p = NULL;
+    int			had_ctrl_v_cr = (c == -1 || c == -2);
 
     if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)
 	return OK;	    /* nothing to do */
 
+    if (had_ctrl_v_cr)
+	c = (c == -1 ? '\r' : '\n');
+
 #ifdef FEAT_MBYTE
     if (has_mbyte)
 	mb_adjust_opend(oap);
@@ -2164,25 +2162,44 @@
 	    /* insert pre-spaces */
 	    copy_spaces(newp + bd.textcol, (size_t)bd.startspaces);
 	    /* insert replacement chars CHECK FOR ALLOCATED SPACE */
-#ifdef FEAT_MBYTE
-	    if (has_mbyte)
+	    /* -1/-2 is used for entering CR literally. */
+	    if (had_ctrl_v_cr || (c != '\r' && c != '\n'))
 	    {
-		n = (int)STRLEN(newp);
-		while (--num_chars >= 0)
-		    n += (*mb_char2bytes)(c, newp + n);
+#ifdef FEAT_MBYTE
+		if (has_mbyte)
+		{
+		    n = (int)STRLEN(newp);
+		    while (--num_chars >= 0)
+			n += (*mb_char2bytes)(c, newp + n);
+		}
+		else
+#endif
+		    copy_chars(newp + STRLEN(newp), (size_t)numc, c);
+		if (!bd.is_short)
+		{
+		    /* insert post-spaces */
+		    copy_spaces(newp + STRLEN(newp), (size_t)bd.endspaces);
+		    /* copy the part after the changed part */
+		    STRMOVE(newp + STRLEN(newp), oldp);
+		}
 	    }
 	    else
-#endif
-		copy_chars(newp + STRLEN(newp), (size_t)numc, c);
-	    if (!bd.is_short)
 	    {
-		/* insert post-spaces */
-		copy_spaces(newp + STRLEN(newp), (size_t)bd.endspaces);
-		/* copy the part after the changed part */
-		STRMOVE(newp + STRLEN(newp), oldp);
+		/* Replacing with \r or \n means splitting the line. */
+		after_p = alloc_check(
+				   (unsigned)(oldlen + 1 + n - STRLEN(newp)));
+		if (after_p != NULL)
+		    STRMOVE(after_p, oldp);
 	    }
 	    /* replace the line */
 	    ml_replace(curwin->w_cursor.lnum, newp, FALSE);
+	    if (after_p != NULL)
+	    {
+		ml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);
+		appended_lines_mark(curwin->w_cursor.lnum, 1L);
+		oap->end.lnum++;
+		vim_free(after_p);
+	    }
 	}
     }
     else
@@ -2294,9 +2311,7 @@
     oparg_T	*oap;
 {
     pos_T		pos;
-#ifdef FEAT_VISUAL
     struct block_def	bd;
-#endif
     int			did_change = FALSE;
 
     if (u_save((linenr_T)(oap->start.lnum - 1),
@@ -2304,7 +2319,6 @@
 	return;
 
     pos = oap->start;
-#ifdef FEAT_VISUAL
     if (oap->block_mode)		    /* Visual block mode */
     {
 	for (; pos.lnum <= oap->end.lnum; ++pos.lnum)
@@ -2316,7 +2330,7 @@
 	    one_change = swapchars(oap->op_type, &pos, bd.textlen);
 	    did_change |= one_change;
 
-# ifdef FEAT_NETBEANS_INTG
+#ifdef FEAT_NETBEANS_INTG
 	    if (netbeans_active() && one_change)
 	    {
 		char_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);
@@ -2326,13 +2340,12 @@
 		netbeans_inserted(curbuf, pos.lnum, bd.textcol,
 						&ptr[bd.textcol], bd.textlen);
 	    }
-# endif
+#endif
 	}
 	if (did_change)
 	    changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);
     }
     else				    /* not block mode */
-#endif
     {
 	if (oap->motion_type == MLINE)
 	{
@@ -2388,11 +2401,9 @@
 	}
     }
 
-#ifdef FEAT_VISUAL
     if (!did_change && oap->is_VIsual)
 	/* No change: need to remove the Visual selection */
 	redraw_curbuf_later(INVERTED);
-#endif
 
     /*
      * Set '[ and '] marks.
@@ -2617,6 +2628,47 @@
     {
 	struct block_def	bd2;
 
+	/* The user may have moved the cursor before inserting something, try
+	 * to adjust the block for that. */
+	if (oap->start.lnum == curbuf->b_op_start_orig.lnum && !bd.is_MAX)
+	{
+	    if (oap->op_type == OP_INSERT
+		    && oap->start.col
+#ifdef FEAT_VIRTUALEDIT
+			    + oap->start.coladd
+#endif
+			!= curbuf->b_op_start_orig.col
+#ifdef FEAT_VIRTUALEDIT
+			    + curbuf->b_op_start_orig.coladd
+#endif
+			)
+	    {
+		oap->start.col = curbuf->b_op_start_orig.col;
+		pre_textlen -= getviscol2(oap->start.col, oap->start.coladd)
+							    - oap->start_vcol;
+		oap->start_vcol = getviscol2(oap->start.col, oap->start.coladd);
+	    }
+	    else if (oap->op_type == OP_APPEND
+		      && oap->end.col
+#ifdef FEAT_VIRTUALEDIT
+			    + oap->end.coladd
+#endif
+			>= curbuf->b_op_start_orig.col
+#ifdef FEAT_VIRTUALEDIT
+			    + curbuf->b_op_start_orig.coladd
+#endif
+			)
+	    {
+		oap->start.col = curbuf->b_op_start_orig.col;
+		/* reset pre_textlen to the value of OP_INSERT */
+		pre_textlen += bd.textlen;
+		pre_textlen -= getviscol2(oap->start.col, oap->start.coladd)
+							    - oap->start_vcol;
+		oap->start_vcol = getviscol2(oap->start.col, oap->start.coladd);
+		oap->op_type = OP_INSERT;
+	    }
+	}
+
 	/*
 	 * Spaces and tabs in the indent may have changed to other spaces and
 	 * tabs.  Get the starting column again and correct the length.
@@ -2953,10 +3005,8 @@
     if (       oap->motion_type == MCHAR
 	    && oap->start.col == 0
 	    && !oap->inclusive
-#ifdef FEAT_VISUAL
 	    && (!oap->is_VIsual || *p_sel == 'o')
 	    && !oap->block_mode
-#endif
 	    && oap->end.col == 0
 	    && yanklines > 1)
     {
@@ -2967,9 +3017,7 @@
 
     y_current->y_size = yanklines;
     y_current->y_type = yanktype;   /* set the yank register type */
-#ifdef FEAT_VISUAL
     y_current->y_width = 0;
-#endif
     y_current->y_array = (char_u **)lalloc_clear((long_u)(sizeof(char_u *) *
 							    yanklines), TRUE);
 
@@ -2982,7 +3030,6 @@
     y_idx = 0;
     lnum = oap->start.lnum;
 
-#ifdef FEAT_VISUAL
     if (oap->block_mode)
     {
 	/* Visual block mode */
@@ -2992,19 +3039,16 @@
 	if (curwin->w_curswant == MAXCOL && y_current->y_width > 0)
 	    y_current->y_width--;
     }
-#endif
 
     for ( ; lnum <= yankendlnum; lnum++, y_idx++)
     {
 	switch (y_current->y_type)
 	{
-#ifdef FEAT_VISUAL
 	    case MBLOCK:
 		block_prep(oap, &bd, lnum, FALSE);
 		if (yank_copy_line(&bd, y_idx) == FAIL)
 		    goto fail;
 		break;
-#endif
 
 	    case MLINE:
 		if ((y_current->y_array[y_idx] =
@@ -3138,12 +3182,12 @@
 	vim_free(y_current->y_array);
 	y_current = curr;
     }
+    if (curwin->w_p_rnu)
+	redraw_later(SOME_VALID);	/* cursor moved to start */
     if (mess)			/* Display message about yank? */
     {
 	if (yanktype == MCHAR
-#ifdef FEAT_VISUAL
 		&& !oap->block_mode
-#endif
 		&& yanklines == 1)
 	    yanklines = 0;
 	/* Some versions of Vi use ">=" here, some don't...  */
@@ -3153,17 +3197,13 @@
 	    update_topline_redraw();
 	    if (yanklines == 1)
 	    {
-#ifdef FEAT_VISUAL
 		if (oap->block_mode)
 		    MSG(_("block of 1 line yanked"));
 		else
-#endif
 		    MSG(_("1 line yanked"));
 	    }
-#ifdef FEAT_VISUAL
 	    else if (oap->block_mode)
 		smsg((char_u *)_("block of %ld lines yanked"), yanklines);
-#endif
 	    else
 		smsg((char_u *)_("%ld lines yanked"), yanklines);
 	}
@@ -3174,11 +3214,7 @@
      */
     curbuf->b_op_start = oap->start;
     curbuf->b_op_end = oap->end;
-    if (yanktype == MLINE
-#ifdef FEAT_VISUAL
-		&& !oap->block_mode
-#endif
-       )
+    if (yanktype == MLINE && !oap->block_mode)
     {
 	curbuf->b_op_start.col = 0;
 	curbuf->b_op_end.col = MAXCOL;
@@ -3193,7 +3229,7 @@
     if (clip_star.available
 	    && (curr == &(y_regs[STAR_REGISTER])
 		|| (!deleting && oap->regname == 0
-					   && (clip_unnamed & CLIP_UNNAMED))))
+		   && ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))
     {
 	if (curr != &(y_regs[STAR_REGISTER]))
 	    /* Copy the text from register 0 to the clipboard register. */
@@ -3214,7 +3250,8 @@
     if (clip_plus.available
 	    && (curr == &(y_regs[PLUS_REGISTER])
 		|| (!deleting && oap->regname == 0
-				      && (clip_unnamed & CLIP_UNNAMED_PLUS))))
+		  && ((clip_unnamed | clip_unnamed_saved) &
+		      CLIP_UNNAMED_PLUS))))
     {
 	if (curr != &(y_regs[PLUS_REGISTER]))
 	    /* Copy the text from register 0 to the clipboard register. */
@@ -3315,7 +3352,6 @@
     long	i;			/* index in y_array[] */
     int		y_type;
     long	y_size;
-#ifdef FEAT_VISUAL
     int		oldlen;
     long	y_width = 0;
     colnr_T	vcol;
@@ -3323,7 +3359,6 @@
     int		incr = 0;
     long	j;
     struct block_def bd;
-#endif
     char_u	**y_array = NULL;
     long	nr_lines = 0;
     pos_T	new_cursor;
@@ -3432,14 +3467,11 @@
 	get_yank_register(regname, FALSE);
 
 	y_type = y_current->y_type;
-#ifdef FEAT_VISUAL
 	y_width = y_current->y_width;
-#endif
 	y_size = y_current->y_size;
 	y_array = y_current->y_array;
     }
 
-#ifdef FEAT_VISUAL
     if (y_type == MLINE)
     {
 	if (flags & PUT_LINE_SPLIT)
@@ -3470,7 +3502,6 @@
 	curbuf->b_op_start = curwin->w_cursor;	/* default for '[ mark */
 	curbuf->b_op_end = curwin->w_cursor;	/* default for '] mark */
     }
-#endif
 
     if (flags & PUT_LINE)	/* :put command or "p" in Visual line mode. */
 	y_type = MLINE;
@@ -3482,7 +3513,6 @@
 	goto end;
     }
 
-#ifdef FEAT_VISUAL
     if (y_type == MBLOCK)
     {
 	lnum = curwin->w_cursor.lnum + y_size + 1;
@@ -3491,9 +3521,7 @@
 	if (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)
 	    goto end;
     }
-    else
-#endif
-	if (y_type == MLINE)
+    else if (y_type == MLINE)
     {
 	lnum = curwin->w_cursor.lnum;
 #ifdef FEAT_FOLDING
@@ -3545,7 +3573,6 @@
     lnum = curwin->w_cursor.lnum;
     col = curwin->w_cursor.col;
 
-#ifdef FEAT_VISUAL
     /*
      * Block mode
      */
@@ -3623,7 +3650,7 @@
 	    for (ptr = oldp; vcol < col && *ptr; )
 	    {
 		/* Count a tab for what it's worth (if list mode not on) */
-		incr = lbr_chartabsize_adv(&ptr, (colnr_T)vcol);
+		incr = lbr_chartabsize_adv(oldp, &ptr, (colnr_T)vcol);
 		vcol += incr;
 	    }
 	    bd.textcol = (colnr_T)(ptr - oldp);
@@ -3657,7 +3684,7 @@
 	    /* calculate number of spaces required to fill right side of block*/
 	    spaces = y_width + 1;
 	    for (j = 0; j < yanklen; j++)
-		spaces -= lbr_chartabsize(&y_array[i][j], 0);
+		spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);
 	    if (spaces < 0)
 		spaces = 0;
 
@@ -3727,7 +3754,6 @@
 	    curwin->w_cursor.lnum = lnum;
     }
     else
-#endif
     {
 	/*
 	 * Character or Line mode
@@ -3776,25 +3802,35 @@
 	 */
 	if (y_type == MCHAR && y_size == 1)
 	{
-	    totlen = count * yanklen;
-	    if (totlen)
-	    {
-		oldp = ml_get(lnum);
-		newp = alloc_check((unsigned)(STRLEN(oldp) + totlen + 1));
-		if (newp == NULL)
-		    goto end;		/* alloc() will give error message */
-		mch_memmove(newp, oldp, (size_t)col);
-		ptr = newp + col;
-		for (i = 0; i < count; ++i)
+	    do {
+		totlen = count * yanklen;
+		if (totlen > 0)
 		{
-		    mch_memmove(ptr, y_array[0], (size_t)yanklen);
-		    ptr += yanklen;
+		    oldp = ml_get(lnum);
+		    newp = alloc_check((unsigned)(STRLEN(oldp) + totlen + 1));
+		    if (newp == NULL)
+			goto end;	/* alloc() gave an error message */
+		    mch_memmove(newp, oldp, (size_t)col);
+		    ptr = newp + col;
+		    for (i = 0; i < count; ++i)
+		    {
+			mch_memmove(ptr, y_array[0], (size_t)yanklen);
+			ptr += yanklen;
+		    }
+		    STRMOVE(ptr, oldp + col);
+		    ml_replace(lnum, newp, FALSE);
+		    /* Place cursor on last putted char. */
+		    if (lnum == curwin->w_cursor.lnum)
+		    {
+			/* make sure curwin->w_virtcol is updated */
+			changed_cline_bef_curs();
+			curwin->w_cursor.col += (colnr_T)(totlen - 1);
+		    }
 		}
-		STRMOVE(ptr, oldp + col);
-		ml_replace(lnum, newp, FALSE);
-		/* Put cursor on last putted char. */
-		curwin->w_cursor.col += (colnr_T)(totlen - 1);
-	    }
+		if (VIsual_active)
+		    lnum++;
+	    } while (VIsual_active && lnum <= curbuf->b_visual.vi_end.lnum);
+
 	    curbuf->b_op_end = curwin->w_cursor;
 	    /* For "CTRL-O p" in Insert mode, put cursor after last char */
 	    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))
@@ -3955,6 +3991,8 @@
     if (regname == '=')
 	vim_free(y_array);
 
+    VIsual_active = FALSE;
+
     /* If the cursor is past the end of the line put it at the end. */
     adjust_cursor_eol();
 }
@@ -4005,7 +4043,8 @@
 #  endif
 # endif
 # ifdef FEAT_CINDENT
-	(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE))
+	(curbuf->b_p_cin && in_cinkeys('#', ' ', TRUE)
+					   && curbuf->b_ind_hash_comment == 0)
 # endif
 	;
 }
@@ -4319,17 +4358,20 @@
 /*
  * Join 'count' lines (minimal 2) at cursor position.
  * When "save_undo" is TRUE save lines for undo first.
- * Set "use_formatoptions" to FALSE when e.g. processing
- * backspace and comment leaders should not be removed.
+ * Set "use_formatoptions" to FALSE when e.g. processing backspace and comment
+ * leaders should not be removed.
+ * When setmark is TRUE, sets the '[ and '] mark, else, the caller is expected
+ * to set those marks.
  *
  * return FAIL for failure, OK otherwise
  */
     int
-do_join(count, insert_space, save_undo, use_formatoptions)
+do_join(count, insert_space, save_undo, use_formatoptions, setmark)
     long    count;
     int	    insert_space;
     int	    save_undo;
     int	    use_formatoptions UNUSED;
+    int	    setmark;
 {
     char_u	*curr = NULL;
     char_u      *curr_start = NULL;
@@ -4380,6 +4422,12 @@
     for (t = 0; t < count; ++t)
     {
 	curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t));
+	if (t == 0 && setmark)
+	{
+	    /* Set the '[ mark. */
+	    curwin->w_buffer->b_op_start.lnum = curwin->w_cursor.lnum;
+	    curwin->w_buffer->b_op_start.col  = (colnr_T)STRLEN(curr);
+	}
 #if defined(FEAT_COMMENTS) || defined(PROTO)
 	if (remove_comments)
 	{
@@ -4496,6 +4544,13 @@
     }
     ml_replace(curwin->w_cursor.lnum, newp, FALSE);
 
+    if (setmark)
+    {
+	/* Set the '] mark. */
+	curwin->w_buffer->b_op_end.lnum = curwin->w_cursor.lnum;
+	curwin->w_buffer->b_op_end.col  = (colnr_T)STRLEN(newp);
+    }
+
     /* Only report the change in the first line here, del_lines() will report
      * the deleted line. */
     changed_lines(curwin->w_cursor.lnum, currsize,
@@ -4631,11 +4686,9 @@
 	return;
     curwin->w_cursor = oap->start;
 
-#ifdef FEAT_VISUAL
     if (oap->is_VIsual)
 	/* When there is no change: need to remove the Visual selection */
 	redraw_curbuf_later(INVERTED);
-#endif
 
     /* Set '[ mark at the start of the formatted area */
     curbuf->b_op_start = oap->start;
@@ -4667,7 +4720,6 @@
 	saved_cursor.lnum = 0;
     }
 
-#ifdef FEAT_VISUAL
     if (oap->is_VIsual)
     {
 	win_T	*wp;
@@ -4685,7 +4737,6 @@
 	    }
 	}
     }
-#endif
 }
 
 #if defined(FEAT_EVAL) || defined(PROTO)
@@ -4696,11 +4747,9 @@
 op_formatexpr(oap)
     oparg_T	*oap;
 {
-# ifdef FEAT_VISUAL
     if (oap->is_VIsual)
 	/* When there is no change: need to remove the Visual selection */
 	redraw_curbuf_later(INVERTED);
-# endif
 
     if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)
 	/* As documented: when 'formatexpr' returns non-zero fall back to
@@ -4971,7 +5020,7 @@
 
 	    /*
 	     * When still in same paragraph, join the lines together.  But
-	     * first delete the comment leader from the second line.
+	     * first delete the leader from the second line.
 	     */
 	    if (!is_end_par)
 	    {
@@ -4981,13 +5030,27 @@
 		if (line_count < 0 && u_save_cursor() == FAIL)
 		    break;
 #ifdef FEAT_COMMENTS
-		(void)del_bytes((long)next_leader_len, FALSE, FALSE);
 		if (next_leader_len > 0)
+		{
+		    (void)del_bytes((long)next_leader_len, FALSE, FALSE);
 		    mark_col_adjust(curwin->w_cursor.lnum, (colnr_T)0, 0L,
 						      (long)-next_leader_len);
+		} else
 #endif
+		    if (second_indent > 0)  /* the "leader" for FO_Q_SECOND */
+		{
+		    char_u *p = ml_get_curline();
+		    int indent = (int)(skipwhite(p) - p);
+
+		    if (indent > 0)
+		    {
+			(void)del_bytes(indent, FALSE, FALSE);
+			mark_col_adjust(curwin->w_cursor.lnum,
+					       (colnr_T)0, 0L, (long)-indent);
+		    }
+		}
 		curwin->w_cursor.lnum--;
-		if (do_join(2, TRUE, FALSE, FALSE) == FAIL)
+		if (do_join(2, TRUE, FALSE, FALSE, FALSE) == FAIL)
 		{
 		    beep_flush();
 		    break;
@@ -5126,7 +5189,6 @@
     return FALSE;
 }
 
-#ifdef FEAT_VISUAL
 /*
  * prepare a few things for block mode yank/delete/tilde
  *
@@ -5174,7 +5236,7 @@
     while (bdp->start_vcol < oap->start_vcol && *pstart)
     {
 	/* Count a tab for what it's worth (if list mode not on) */
-	incr = lbr_chartabsize(pstart, (colnr_T)bdp->start_vcol);
+	incr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);
 	bdp->start_vcol += incr;
 #ifdef FEAT_VISUALEXTRA
 	if (vim_iswhite(*pstart))
@@ -5243,7 +5305,10 @@
 	    {
 		/* Count a tab for what it's worth (if list mode not on) */
 		prev_pend = pend;
-		incr = lbr_chartabsize_adv(&pend, (colnr_T)bdp->end_vcol);
+		/* TODO: is passing prev_pend for start of the line OK?
+		 * perhaps it should be "line". */
+		incr = lbr_chartabsize_adv(prev_pend, &pend,
+						      (colnr_T)bdp->end_vcol);
 		bdp->end_vcol += incr;
 	    }
 	    if (bdp->end_vcol <= oap->end_vcol
@@ -5285,7 +5350,6 @@
     bdp->textcol = (colnr_T) (pstart - line);
     bdp->textstart = pstart;
 }
-#endif /* FEAT_VISUAL */
 
 #ifdef FEAT_RIGHTLEFT
 static void reverse_line __ARGS((char_u *s));
@@ -5636,19 +5700,13 @@
 	str = skipwhite(skiptowhite(str));
 	if (STRNCMP(str, "CHAR", 4) == 0)
 	    y_current->y_type = MCHAR;
-#ifdef FEAT_VISUAL
 	else if (STRNCMP(str, "BLOCK", 5) == 0)
 	    y_current->y_type = MBLOCK;
-#endif
 	else
 	    y_current->y_type = MLINE;
 	/* get the block width; if it's missing we get a zero, which is OK */
 	str = skipwhite(skiptowhite(str));
-#ifdef FEAT_VISUAL
 	y_current->y_width = getdigits(&str);
-#else
-	(void)getdigits(&str);
-#endif
     }
 
     while (!(eof = viminfo_readline(virp))
@@ -5756,11 +5814,9 @@
 	    case MCHAR:
 		type = (char_u *)"CHAR";
 		break;
-#ifdef FEAT_VISUAL
 	    case MBLOCK:
 		type = (char_u *)"BLOCK";
 		break;
-#endif
 	    default:
 		sprintf((char *)IObuff, _("E574: Unknown register type %d"),
 							    y_regs[i].y_type);
@@ -5774,13 +5830,7 @@
 	fprintf(fp, "\"%c", c);
 	if (c == execreg_lastc)
 	    fprintf(fp, "@");
-	fprintf(fp, "\t%s\t%d\n", type,
-#ifdef FEAT_VISUAL
-		    (int)y_regs[i].y_width
-#else
-		    0
-#endif
-		    );
+	fprintf(fp, "\t%s\t%d\n", type, (int)y_regs[i].y_width);
 
 	/* If max_num_lines < 0, then we save ALL the lines in the register */
 	if (max_num_lines > 0 && num_lines > max_num_lines)
@@ -5927,10 +5977,8 @@
 {
     struct yankreg *old_y_previous, *old_y_current;
     pos_T	old_cursor;
-#ifdef FEAT_VISUAL
     pos_T	old_visual;
     int		old_visual_mode;
-#endif
     colnr_T	old_curswant;
     int		old_set_curswant;
     pos_T	old_op_start, old_op_end;
@@ -5951,10 +5999,8 @@
 	old_set_curswant = curwin->w_set_curswant;
 	old_op_start = curbuf->b_op_start;
 	old_op_end = curbuf->b_op_end;
-#ifdef FEAT_VISUAL
 	old_visual = VIsual;
 	old_visual_mode = VIsual_mode;
-#endif
 	clear_oparg(&oa);
 	oa.regname = (cbd == &clip_plus ? '+' : '*');
 	oa.op_type = OP_YANK;
@@ -5972,10 +6018,8 @@
 	curwin->w_set_curswant = old_set_curswant;
 	curbuf->b_op_start = old_op_start;
 	curbuf->b_op_end = old_op_end;
-#ifdef FEAT_VISUAL
 	VIsual = old_visual;
 	VIsual_mode = old_visual_mode;
-#endif
     }
     else
     {
@@ -6005,7 +6049,7 @@
 
     clip_free_selection(cbd);
 
-    str_to_reg(y_ptr, type, str, len, 0L);
+    str_to_reg(y_ptr, type, str, len, 0L, FALSE);
 }
 
 /*
@@ -6078,7 +6122,6 @@
 }
 
 
-# if defined(FEAT_VISUAL) || defined(FEAT_EVAL)
 /*
  * If we have written to a clipboard register, send the text to the clipboard.
  */
@@ -6096,7 +6139,6 @@
 	clip_gen_set_selection(&clip_plus);
     }
 }
-# endif
 
 #endif /* FEAT_CLIPBOARD || PROTO */
 
@@ -6115,7 +6157,7 @@
     curr = y_current;
     y_current = &y_regs[TILDE_REGISTER];
     free_yank_all();
-    str_to_reg(y_current, MCHAR, str, len, 0L);
+    str_to_reg(y_current, MCHAR, str, len, 0L, FALSE);
     y_current = curr;
 }
 #endif
@@ -6154,30 +6196,63 @@
     regname = may_get_selection(regname);
 #endif
 
-    /* Should we check for a valid name? */
+    if (regname != NUL && !valid_yank_reg(regname, FALSE))
+        return MAUTO;
+
     get_yank_register(regname, FALSE);
 
     if (y_current->y_array != NULL)
     {
-#ifdef FEAT_VISUAL
 	if (reglen != NULL && y_current->y_type == MBLOCK)
 	    *reglen = y_current->y_width;
-#endif
 	return y_current->y_type;
     }
     return MAUTO;
 }
 
+static char_u *getreg_wrap_one_line __ARGS((char_u *s, int flags));
+
+/*
+ * When "flags" has GREG_LIST return a list with text "s".
+ * Otherwise just return "s".
+ */
+    static char_u *
+getreg_wrap_one_line(s, flags)
+    char_u	*s;
+    int		flags;
+{
+    if (flags & GREG_LIST)
+    {
+	list_T *list = list_alloc();
+
+	if (list != NULL)
+	{
+	    if (list_append_string(list, NULL, -1) == FAIL)
+	    {
+		list_free(list, TRUE);
+		return NULL;
+	    }
+	    list->lv_first->li_tv.vval.v_string = s;
+	}
+	return (char_u *)list;
+    }
+    return s;
+}
+
 /*
  * Return the contents of a register as a single allocated string.
  * Used for "@r" in expressions and for getreg().
  * Returns NULL for error.
+ * Flags:
+ *	GREG_NO_EXPR	Do not allow expression register
+ *	GREG_EXPR_SRC	For the expression register: return expression itself,
+ *			not the result of its evaluation.
+ *	GREG_LIST	Return a list of lines in place of a single string.
  */
     char_u *
-get_reg_contents(regname, allowexpr, expr_src)
+get_reg_contents(regname, flags)
     int		regname;
-    int		allowexpr;	/* allow "=" register */
-    int		expr_src;	/* get expression for "=" register */
+    int		flags;
 {
     long	i;
     char_u	*retval;
@@ -6187,13 +6262,11 @@
     /* Don't allow using an expression register inside an expression */
     if (regname == '=')
     {
-	if (allowexpr)
-	{
-	    if (expr_src)
-		return get_expr_line_src();
-	    return get_expr_line();
-	}
-	return NULL;
+	if (flags & GREG_NO_EXPR)
+	    return NULL;
+	if (flags & GREG_EXPR_SRC)
+	    return getreg_wrap_one_line(get_expr_line_src(), flags);
+	return getreg_wrap_one_line(get_expr_line(), flags);
     }
 
     if (regname == '@')	    /* "@@" is used for unnamed register */
@@ -6211,15 +6284,33 @@
     {
 	if (retval == NULL)
 	    return NULL;
-	if (!allocated)
-	    retval = vim_strsave(retval);
-	return retval;
+	if (allocated)
+	    return getreg_wrap_one_line(retval, flags);
+	return getreg_wrap_one_line(vim_strsave(retval), flags);
     }
 
     get_yank_register(regname, FALSE);
     if (y_current->y_array == NULL)
 	return NULL;
 
+    if (flags & GREG_LIST)
+    {
+	list_T	*list = list_alloc();
+	int	error = FALSE;
+
+	if (list == NULL)
+	    return NULL;
+	for (i = 0; i < y_current->y_size; ++i)
+	    if (list_append_string(list, y_current->y_array[i], -1) == FAIL)
+		error = TRUE;
+	if (error)
+	{
+	    list_free(list, TRUE);
+	    return NULL;
+	}
+	return (char_u *)list;
+    }
+
     /*
      * Compute length of resulting string.
      */
@@ -6261,6 +6352,47 @@
     return retval;
 }
 
+    static int
+init_write_reg(name, old_y_previous, old_y_current, must_append, yank_type)
+    int		    name;
+    struct yankreg  **old_y_previous;
+    struct yankreg  **old_y_current;
+    int		    must_append;
+    int		    *yank_type UNUSED;
+{
+    if (!valid_yank_reg(name, TRUE))	    /* check for valid reg name */
+    {
+	emsg_invreg(name);
+	return FAIL;
+    }
+
+    /* Don't want to change the current (unnamed) register */
+    *old_y_previous = y_previous;
+    *old_y_current = y_current;
+
+    get_yank_register(name, TRUE);
+    if (!y_append && !must_append)
+	free_yank_all();
+    return OK;
+}
+
+    static void
+finish_write_reg(name, old_y_previous, old_y_current)
+    int		    name;
+    struct yankreg  *old_y_previous;
+    struct yankreg  *old_y_current;
+{
+# ifdef FEAT_CLIPBOARD
+    /* Send text of clipboard register to the clipboard. */
+    may_set_selection();
+# endif
+
+    /* ':let @" = "val"' should change the meaning of the "" register */
+    if (name != '"')
+	y_previous = old_y_previous;
+    y_current = old_y_current;
+}
+
 /*
  * Store string "str" in register "name".
  * "maxlen" is the maximum number of bytes to use, -1 for all bytes.
@@ -6281,6 +6413,51 @@
 }
 
     void
+write_reg_contents_lst(name, strings, maxlen, must_append, yank_type, block_len)
+    int		name;
+    char_u	**strings;
+    int		maxlen UNUSED;
+    int		must_append;
+    int		yank_type;
+    long	block_len;
+{
+    struct yankreg  *old_y_previous, *old_y_current;
+
+    if (name == '/'
+#ifdef FEAT_EVAL
+	    || name == '='
+#endif
+	    )
+    {
+	char_u	*s;
+
+	if (strings[0] == NULL)
+	    s = (char_u *)"";
+	else if (strings[1] != NULL)
+	{
+	    EMSG(_("E883: search pattern and expression register may not "
+			"contain two or more lines"));
+	    return;
+	}
+	else
+	    s = strings[0];
+	write_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);
+	return;
+    }
+
+    if (name == '_')	    /* black hole: nothing to do */
+	return;
+
+    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,
+		&yank_type) == FAIL)
+	return;
+
+    str_to_reg(y_current, yank_type, (char_u *) strings, -1, block_len, TRUE);
+
+    finish_write_reg(name, old_y_previous, old_y_current);
+}
+
+    void
 write_reg_contents_ex(name, str, maxlen, must_append, yank_type, block_len)
     int		name;
     char_u	*str;
@@ -6317,45 +6494,22 @@
 	    s = concat_str(get_expr_line_src(), p);
 	    vim_free(p);
 	    p = s;
-
 	}
 	set_expr_line(p);
 	return;
     }
 #endif
 
-    if (!valid_yank_reg(name, TRUE))	    /* check for valid reg name */
-    {
-	emsg_invreg(name);
-	return;
-    }
-
     if (name == '_')	    /* black hole: nothing to do */
 	return;
 
-    /* Don't want to change the current (unnamed) register */
-    old_y_previous = y_previous;
-    old_y_current = y_current;
-
-    get_yank_register(name, TRUE);
-    if (!y_append && !must_append)
-	free_yank_all();
-#ifndef FEAT_VISUAL
-    /* Just in case - make sure we don't use MBLOCK */
-    if (yank_type == MBLOCK)
-	yank_type = MAUTO;
-#endif
-    str_to_reg(y_current, yank_type, str, len, block_len);
+    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,
+		&yank_type) == FAIL)
+	return;
 
-# ifdef FEAT_CLIPBOARD
-    /* Send text of clipboard register to the clipboard. */
-    may_set_selection();
-# endif
+    str_to_reg(y_current, yank_type, str, len, block_len, FALSE);
 
-    /* ':let @" = "val"' should change the meaning of the "" register */
-    if (name != '"')
-	y_previous = old_y_previous;
-    y_current = old_y_current;
+    finish_write_reg(name, old_y_previous, old_y_current);
 }
 #endif	/* FEAT_EVAL */
 
@@ -6365,12 +6519,13 @@
  * is appended.
  */
     static void
-str_to_reg(y_ptr, yank_type, str, len, blocklen)
+str_to_reg(y_ptr, yank_type, str, len, blocklen, str_list)
     struct yankreg	*y_ptr;		/* pointer to yank register */
     int			yank_type;	/* MCHAR, MLINE, MBLOCK, MAUTO */
     char_u		*str;		/* string to put in register */
     long		len;		/* length of string */
     long		blocklen;	/* width of Visual block */
+    int			str_list;	/* TRUE if str is char_u ** */
 {
     int		type;			/* MCHAR, MLINE or MBLOCK */
     int		lnum;
@@ -6381,16 +6536,16 @@
     int		extraline = 0;		/* extra line at the end */
     int		append = FALSE;		/* append to last line in register */
     char_u	*s;
+    char_u	**ss;
     char_u	**pp;
-#ifdef FEAT_VISUAL
     long	maxlen;
-#endif
 
     if (y_ptr->y_array == NULL)		/* NULL means empty register */
 	y_ptr->y_size = 0;
 
     if (yank_type == MAUTO)
-	type = ((len > 0 && (str[len - 1] == NL || str[len - 1] == CAR))
+	type = ((str_list || (len > 0 && (str[len - 1] == NL
+					    || str[len - 1] == CAR)))
 							     ? MLINE : MCHAR);
     else
 	type = yank_type;
@@ -6399,18 +6554,26 @@
      * Count the number of lines within the string
      */
     newlines = 0;
-    for (i = 0; i < len; i++)
-	if (str[i] == '\n')
-	    ++newlines;
-    if (type == MCHAR || len == 0 || str[len - 1] != '\n')
+    if (str_list)
     {
-	extraline = 1;
-	++newlines;	/* count extra newline at the end */
+	for (ss = (char_u **) str; *ss != NULL; ++ss)
+	    ++newlines;
     }
-    if (y_ptr->y_size > 0 && y_ptr->y_type == MCHAR)
+    else
     {
-	append = TRUE;
-	--newlines;	/* uncount newline when appending first line */
+	for (i = 0; i < len; i++)
+	    if (str[i] == '\n')
+		++newlines;
+	if (type == MCHAR || len == 0 || str[len - 1] != '\n')
+	{
+	    extraline = 1;
+	    ++newlines;	/* count extra newline at the end */
+	}
+	if (y_ptr->y_size > 0 && y_ptr->y_type == MCHAR)
+	{
+	    append = TRUE;
+	    --newlines;	/* uncount newline when appending first line */
+	}
     }
 
     /*
@@ -6425,58 +6588,65 @@
 	pp[lnum] = y_ptr->y_array[lnum];
     vim_free(y_ptr->y_array);
     y_ptr->y_array = pp;
-#ifdef FEAT_VISUAL
     maxlen = 0;
-#endif
 
     /*
      * Find the end of each line and save it into the array.
      */
-    for (start = 0; start < len + extraline; start += i + 1)
+    if (str_list)
     {
-	for (i = start; i < len; ++i)	/* find the end of the line */
-	    if (str[i] == '\n')
-		break;
-	i -= start;			/* i is now length of line */
-#ifdef FEAT_VISUAL
-	if (i > maxlen)
-	    maxlen = i;
-#endif
-	if (append)
+	for (ss = (char_u **) str; *ss != NULL; ++ss, ++lnum)
 	{
-	    --lnum;
-	    extra = (int)STRLEN(y_ptr->y_array[lnum]);
+	    i = (long)STRLEN(*ss);
+	    pp[lnum] = vim_strnsave(*ss, i);
+	    if (i > maxlen)
+		maxlen = i;
 	}
-	else
-	    extra = 0;
-	s = alloc((unsigned)(i + extra + 1));
-	if (s == NULL)
-	    break;
-	if (extra)
-	    mch_memmove(s, y_ptr->y_array[lnum], (size_t)extra);
-	if (append)
-	    vim_free(y_ptr->y_array[lnum]);
-	if (i)
-	    mch_memmove(s + extra, str + start, (size_t)i);
-	extra += i;
-	s[extra] = NUL;
-	y_ptr->y_array[lnum++] = s;
-	while (--extra >= 0)
-	{
-	    if (*s == NUL)
-		*s = '\n';	    /* replace NUL with newline */
-	    ++s;
+    }
+    else
+    {
+	for (start = 0; start < len + extraline; start += i + 1)
+	{
+	    for (i = start; i < len; ++i)	/* find the end of the line */
+		if (str[i] == '\n')
+		    break;
+	    i -= start;			/* i is now length of line */
+	    if (i > maxlen)
+		maxlen = i;
+	    if (append)
+	    {
+		--lnum;
+		extra = (int)STRLEN(y_ptr->y_array[lnum]);
+	    }
+	    else
+		extra = 0;
+	    s = alloc((unsigned)(i + extra + 1));
+	    if (s == NULL)
+		break;
+	    if (extra)
+		mch_memmove(s, y_ptr->y_array[lnum], (size_t)extra);
+	    if (append)
+		vim_free(y_ptr->y_array[lnum]);
+	    if (i)
+		mch_memmove(s + extra, str + start, (size_t)i);
+	    extra += i;
+	    s[extra] = NUL;
+	    y_ptr->y_array[lnum++] = s;
+	    while (--extra >= 0)
+	    {
+		if (*s == NUL)
+		    *s = '\n';	    /* replace NUL with newline */
+		++s;
+	    }
+	    append = FALSE;		    /* only first line is appended */
 	}
-	append = FALSE;		    /* only first line is appended */
     }
     y_ptr->y_type = type;
     y_ptr->y_size = lnum;
-# ifdef FEAT_VISUAL
     if (type == MBLOCK)
 	y_ptr->y_width = (blocklen < 0 ? maxlen - 1 : blocklen);
     else
 	y_ptr->y_width = 0;
-# endif
 }
 #endif /* FEAT_CLIPBOARD || FEAT_EVAL || PROTO */
 
@@ -6570,12 +6740,10 @@
     long	word_count_cursor = 0;
     int		eol_size;
     long	last_check = 100000L;
-#ifdef FEAT_VISUAL
     long	line_count_selected = 0;
     pos_T	min_pos, max_pos;
     oparg_T	oparg;
     struct block_def	bd;
-#endif
 
     /*
      * Compute the length of the file in characters.
@@ -6591,7 +6759,6 @@
 	else
 	    eol_size = 1;
 
-#ifdef FEAT_VISUAL
 	if (VIsual_active)
 	{
 	    if (lt(VIsual, curwin->w_cursor))
@@ -6635,7 +6802,6 @@
 	    }
 	    line_count_selected = max_pos.lnum - min_pos.lnum + 1;
 	}
-#endif
 
 	for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)
 	{
@@ -6648,7 +6814,6 @@
 		last_check = byte_count + 100000L;
 	    }
 
-#ifdef FEAT_VISUAL
 	    /* Do extra processing for VIsual mode. */
 	    if (VIsual_active
 		    && lnum >= min_pos.lnum && lnum <= max_pos.lnum)
@@ -6659,13 +6824,13 @@
 		switch (VIsual_mode)
 		{
 		    case Ctrl_V:
-# ifdef FEAT_VIRTUALEDIT
+#ifdef FEAT_VIRTUALEDIT
 			virtual_op = virtual_active();
-# endif
+#endif
 			block_prep(&oparg, &bd, lnum, 0);
-# ifdef FEAT_VIRTUALEDIT
+#ifdef FEAT_VIRTUALEDIT
 			virtual_op = MAYBE;
-# endif
+#endif
 			s = bd.textstart;
 			len = (long)bd.textlen;
 			break;
@@ -6697,7 +6862,6 @@
 		}
 	    }
 	    else
-#endif
 	    {
 		/* In non-visual mode, check for the line the cursor is on */
 		if (lnum == curwin->w_cursor.lnum)
@@ -6719,7 +6883,6 @@
 	if (!curbuf->b_p_eol && curbuf->b_p_bin)
 	    byte_count -= eol_size;
 
-#ifdef FEAT_VISUAL
 	if (VIsual_active)
 	{
 	    if (VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL)
@@ -6750,13 +6913,13 @@
 			byte_count_cursor, byte_count);
 	}
 	else
-#endif
 	{
 	    p = ml_get_curline();
 	    validate_virtcol();
 	    col_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,
 		    (int)curwin->w_virtcol + 1);
-	    col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));
+	    col_print(buf2, sizeof(buf2), (int)STRLEN(p),
+				linetabsize(p));
 
 	    if (char_count_cursor == byte_count_cursor
 		    && char_count == byte_count)
diff -Naur vim74.orig/src/option.c vim74/src/option.c
--- vim74.orig/src/option.c	2013-07-17 19:39:13.000000000 +0000
+++ vim74/src/option.c	2014-10-10 14:53:44.725379592 +0000
@@ -56,6 +56,7 @@
  */
 #define PV_AI		OPT_BUF(BV_AI)
 #define PV_AR		OPT_BOTH(OPT_BUF(BV_AR))
+#define PV_BKC		OPT_BOTH(OPT_BUF(BV_BKC))
 #ifdef FEAT_QUICKFIX
 # define PV_BH		OPT_BUF(BV_BH)
 # define PV_BT		OPT_BUF(BV_BT)
@@ -134,6 +135,7 @@
 #define PV_KP		OPT_BOTH(OPT_BUF(BV_KP))
 #ifdef FEAT_LISP
 # define PV_LISP	OPT_BUF(BV_LISP)
+# define PV_LW		OPT_BOTH(OPT_BUF(BV_LW))
 #endif
 #define PV_MA		OPT_BUF(BV_MA)
 #define PV_ML		OPT_BUF(BV_ML)
@@ -187,6 +189,10 @@
 #ifdef FEAT_ARABIC
 # define PV_ARAB	OPT_WIN(WV_ARAB)
 #endif
+#ifdef FEAT_LINEBREAK
+# define PV_BRI		OPT_WIN(WV_BRI)
+# define PV_BRIOPT	OPT_WIN(WV_BRIOPT)
+#endif
 #ifdef FEAT_DIFF
 # define PV_DIFF	OPT_WIN(WV_DIFF)
 #endif
@@ -234,6 +240,7 @@
 #ifdef FEAT_STL_OPT
 # define PV_STL		OPT_BOTH(OPT_WIN(WV_STL))
 #endif
+#define PV_UL		OPT_BOTH(OPT_BUF(BV_UL))
 #ifdef FEAT_WINDOWS
 # define PV_WFH		OPT_WIN(WV_WFH)
 #endif
@@ -576,7 +583,7 @@
 			    (char_u *)&p_bk, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"backupcopy",  "bkc",  P_STRING|P_VIM|P_COMMA|P_NODUP,
-			    (char_u *)&p_bkc, PV_NONE,
+			    (char_u *)&p_bkc, PV_BKC,
 #ifdef UNIX
 			    {(char_u *)"yes", (char_u *)"auto"}
 #else
@@ -646,6 +653,24 @@
 			    {(char_u *)0L, (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+    {"breakindent",   "bri",  P_BOOL|P_VI_DEF|P_VIM|P_RWIN,
+#ifdef FEAT_LINEBREAK
+			    (char_u *)VAR_WIN, PV_BRI,
+			    {(char_u *)FALSE, (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)0L, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
+    {"breakindentopt", "briopt", P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_COMMA|P_NODUP,
+#ifdef FEAT_LINEBREAK
+			    (char_u *)VAR_WIN, PV_BRIOPT,
+			    {(char_u *)"", (char_u *)NULL}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)"", (char_u *)NULL}
+#endif
+			    SCRIPTID_INIT},
     {"browsedir",   "bsdir",P_STRING|P_VI_DEF,
 #ifdef FEAT_BROWSE
 			    (char_u *)&p_bsdir, PV_NONE,
@@ -1390,7 +1415,7 @@
 			    SCRIPTID_INIT},
     {"history",	    "hi",   P_NUM|P_VIM,
 			    (char_u *)&p_hi, PV_NONE,
-			    {(char_u *)0L, (char_u *)20L} SCRIPTID_INIT},
+			    {(char_u *)0L, (char_u *)50L} SCRIPTID_INIT},
     {"hkmap",	    "hk",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_hkmap, PV_NONE,
@@ -1627,11 +1652,7 @@
 #endif
 			    SCRIPTID_INIT},
     {"keymodel",    "km",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_VISUAL
 			    (char_u *)&p_km, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_kp, PV_KP,
@@ -1654,7 +1675,7 @@
 #endif
 #endif
 				(char_u *)0L} SCRIPTID_INIT},
-    {"langmap",     "lmap", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
+    {"langmap",     "lmap", P_STRING|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
 #ifdef FEAT_LANGMAP
 			    (char_u *)&p_langmap, PV_NONE,
 			    {(char_u *)"",	/* unmatched } */
@@ -1717,7 +1738,7 @@
 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"lispwords",   "lw",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_LISP
-			    (char_u *)&p_lispwords, PV_NONE,
+			    (char_u *)&p_lispwords, PV_LW,
 			    {(char_u *)LISPWORD_VALUE, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
@@ -2104,6 +2125,15 @@
     {"remap",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_remap, PV_NONE,
 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
+    {"renderoptions", "rop", P_STRING|P_COMMA|P_RCLR|P_VI_DEF,
+#ifdef FEAT_RENDER_OPTIONS
+			    (char_u *)&p_rop, PV_NONE,
+			    {(char_u *)"", (char_u *)0L}
+#else
+			    (char_u *)NULL, PV_NONE,
+			    {(char_u *)NULL, (char_u *)0L}
+#endif
+			    SCRIPTID_INIT},
     {"report",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)&p_report, PV_NONE,
 			    {(char_u *)2L, (char_u *)0L} SCRIPTID_INIT},
@@ -2188,19 +2218,11 @@
 			    (char_u *)&p_secure, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"selection",   "sel",  P_STRING|P_VI_DEF,
-#ifdef FEAT_VISUAL
 			    (char_u *)&p_sel, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
 			    {(char_u *)"inclusive", (char_u *)0L}
 			    SCRIPTID_INIT},
     {"selectmode",  "slm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
-#ifdef FEAT_VISUAL
 			    (char_u *)&p_slm, PV_NONE,
-#else
-			    (char_u *)NULL, PV_NONE,
-#endif
 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"sessionoptions", "ssop", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SESSION
@@ -2683,7 +2705,7 @@
 #endif
 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"undolevels",  "ul",   P_NUM|P_VI_DEF,
-			    (char_u *)&p_ul, PV_NONE,
+			    (char_u *)&p_ul, PV_UL,
 			    {
 #if defined(UNIX) || defined(WIN3264) || defined(OS2) || defined(VMS)
 			    (char_u *)1000L,
@@ -2968,7 +2990,7 @@
 static char *(p_nf_values[]) = {"octal", "hex", "alpha", NULL};
 static char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};
 #ifdef FEAT_CRYPT
-static char *(p_cm_values[]) = {"zip", "blowfish", NULL};
+static char *(p_cm_values[]) = {"zip", "blowfish", "blowfish2", NULL};
 #endif
 #ifdef FEAT_CMDL_COMPL
 static char *(p_wop_values[]) = {"tagfile", NULL};
@@ -2977,13 +2999,9 @@
 static char *(p_wak_values[]) = {"yes", "menu", "no", NULL};
 #endif
 static char *(p_mousem_values[]) = {"extend", "popup", "popup_setpos", "mac", NULL};
-#ifdef FEAT_VISUAL
 static char *(p_sel_values[]) = {"inclusive", "exclusive", "old", NULL};
 static char *(p_slm_values[]) = {"mouse", "key", "cmd", NULL};
-#endif
-#ifdef FEAT_VISUAL
 static char *(p_km_values[]) = {"startsel", "stopsel", NULL};
-#endif
 #ifdef FEAT_BROWSE
 static char *(p_bsdir_values[]) = {"current", "last", "buffer", NULL};
 #endif
@@ -3066,6 +3084,7 @@
 static char_u *get_varp_scope __ARGS((struct vimoption *p, int opt_flags));
 static char_u *get_varp __ARGS((struct vimoption *));
 static void option_value2string __ARGS((struct vimoption *, int opt_flags));
+static void check_winopt __ARGS((winopt_T *wop));
 static int wc_use_keyname __ARGS((char_u *varp, long *wcp));
 #ifdef FEAT_LANGMAP
 static void langmap_init __ARGS((void));
@@ -3079,6 +3098,9 @@
 static int opt_strings_flags __ARGS((char_u *val, char **values, unsigned *flagp, int list));
 static int check_opt_strings __ARGS((char_u *val, char **values, int));
 static int check_opt_wim __ARGS((void));
+#ifdef FEAT_LINEBREAK
+static int briopt_check __ARGS((win_T *wp));
+#endif
 
 /*
  * Initialize the options, first part.
@@ -3313,6 +3335,7 @@
 
     curbuf->b_p_initialized = TRUE;
     curbuf->b_p_ar = -1;	/* no local 'autoread' value */
+    curbuf->b_p_ul = NO_LOCAL_UNDOLEVEL;
     check_buf_options(curbuf);
     check_win_options(curwin);
     check_options();
@@ -3623,6 +3646,9 @@
 #else
 	win_comp_scroll(curwin);
 #endif
+#ifdef FEAT_CINDENT
+    parse_cino(curbuf);
+#endif
 }
 
 /*
@@ -3817,37 +3843,7 @@
     else
 	do_sp = !(options[idx_sp].flags & P_WAS_SET);
 #endif
-
-    /*
-     * Isolate the name of the shell:
-     * - Skip beyond any path.  E.g., "/usr/bin/csh -f" -> "csh -f".
-     * - Remove any argument.  E.g., "csh -f" -> "csh".
-     * But don't allow a space in the path, so that this works:
-     *   "/usr/bin/csh --rcfile ~/.cshrc"
-     * But don't do that for Windows, it's common to have a space in the path.
-     */
-#ifdef WIN3264
-    p = gettail(p_sh);
-    p = vim_strnsave(p, (int)(skiptowhite(p) - p));
-#else
-    p = skiptowhite(p_sh);
-    if (*p == NUL)
-    {
-	/* No white space, use the tail. */
-	p = vim_strsave(gettail(p_sh));
-    }
-    else
-    {
-	char_u  *p1, *p2;
-
-	/* Find the last path separator before the space. */
-	p1 = p_sh;
-	for (p2 = p_sh; p2 < p; mb_ptr_adv(p2))
-	    if (vim_ispathsep(*p2))
-		p1 = p2 + 1;
-	p = vim_strnsave(p1, (int)(p - p1));
-    }
-#endif
+    p = get_isolated_shell_name();
     if (p != NULL)
     {
 	/*
@@ -3888,6 +3884,7 @@
 		    || fnamecmp(p, "zsh") == 0
 		    || fnamecmp(p, "zsh-beta") == 0
 		    || fnamecmp(p, "bash") == 0
+		    || fnamecmp(p, "fish") == 0
 #  ifdef WIN3264
 		    || fnamecmp(p, "cmd") == 0
 		    || fnamecmp(p, "sh.exe") == 0
@@ -4512,8 +4509,16 @@
 						((flags & P_VI_DEF) || cp_val)
 						 ?  VI_DEFAULT : VIM_DEFAULT];
 			else if (nextchar == '<')
-			    value = *(long *)get_varp_scope(&(options[opt_idx]),
-								  OPT_GLOBAL);
+			{
+			    /* For 'undolevels' NO_LOCAL_UNDOLEVEL means to
+			     * use the global value. */
+			    if ((long *)varp == &curbuf->b_p_ul
+						    && opt_flags == OPT_LOCAL)
+				value = NO_LOCAL_UNDOLEVEL;
+			    else
+				value = *(long *)get_varp_scope(
+					     &(options[opt_idx]), OPT_GLOBAL);
+			}
 			else if (((long *)varp == &p_wc
 				    || (long *)varp == &p_wcm)
 				&& (*arg == '<'
@@ -5290,6 +5295,9 @@
     /* set cedit_key */
     (void)check_cedit();
 #endif
+#ifdef FEAT_LINEBREAK
+    briopt_check(curwin);
+#endif
 }
 
 /*
@@ -5372,6 +5380,7 @@
 #ifdef FEAT_CINDENT
     check_string_option(&buf->b_p_cink);
     check_string_option(&buf->b_p_cino);
+    parse_cino(buf);
 #endif
 #ifdef FEAT_AUTOCMD
     check_string_option(&buf->b_p_ft);
@@ -5401,6 +5410,10 @@
     check_string_option(&buf->b_p_dict);
     check_string_option(&buf->b_p_tsr);
 #endif
+#ifdef FEAT_LISP
+    check_string_option(&buf->b_p_lw);
+#endif
+    check_string_option(&buf->b_p_bkc);
 }
 
 /*
@@ -5718,17 +5731,32 @@
     }
 
     /* 'backupcopy' */
-    else if (varp == &p_bkc)
+    else if (gvarp == &p_bkc)
     {
-	if (opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, TRUE) != OK)
-	    errmsg = e_invarg;
-	if (((bkc_flags & BKC_AUTO) != 0)
-		+ ((bkc_flags & BKC_YES) != 0)
-		+ ((bkc_flags & BKC_NO) != 0) != 1)
+	char_u		*bkc = p_bkc;
+	unsigned int	*flags = &bkc_flags;
+
+	if (opt_flags & OPT_LOCAL)
 	{
-	    /* Must have exactly one of "auto", "yes"  and "no". */
-	    (void)opt_strings_flags(oldval, p_bkc_values, &bkc_flags, TRUE);
-	    errmsg = e_invarg;
+	    bkc = curbuf->b_p_bkc;
+	    flags = &curbuf->b_bkc_flags;
+	}
+
+	if ((opt_flags & OPT_LOCAL) && *bkc == NUL)
+	    /* make the local value empty: use the global value */
+	    *flags = 0;
+	else
+	{
+	    if (opt_strings_flags(bkc, p_bkc_values, flags, TRUE) != OK)
+		errmsg = e_invarg;
+	    if ((((int)*flags & BKC_AUTO) != 0)
+		    + (((int)*flags & BKC_YES) != 0)
+		    + (((int)*flags & BKC_NO) != 0) != 1)
+	    {
+		/* Must have exactly one of "auto", "yes"  and "no". */
+		(void)opt_strings_flags(oldval, p_bkc_values, flags, TRUE);
+		errmsg = e_invarg;
+	    }
 	}
     }
 
@@ -5739,6 +5767,14 @@
 		     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)
 	    errmsg = (char_u *)N_("E589: 'backupext' and 'patchmode' are equal");
     }
+#ifdef FEAT_LINEBREAK
+    /* 'breakindentopt' */
+    else if (varp == &curwin->w_p_briopt)
+    {
+	if (briopt_check(curwin) == FAIL)
+	    errmsg = e_invarg;
+    }
+#endif
 
     /*
      * 'isident', 'iskeyword', 'isprint or 'isfname' option: refill chartab[]
@@ -6127,7 +6163,7 @@
 # endif
 	if (STRCMP(curbuf->b_p_key, oldval) != 0)
 	    /* Need to update the swapfile. */
-	    ml_set_crypt_key(curbuf, oldval, get_crypt_method(curbuf));
+	    ml_set_crypt_key(curbuf, oldval, crypt_get_method_nr(curbuf));
     }
 
     else if (gvarp == &p_cm)
@@ -6138,7 +6174,7 @@
 	    p = p_cm;
 	if (check_opt_strings(p, p_cm_values, TRUE) != OK)
 	    errmsg = e_invarg;
-	else if (get_crypt_method(curbuf) > 0 && blowfish_self_test() == FAIL)
+	else if (crypt_self_test() == FAIL)
 	    errmsg = e_invarg;
 	else
 	{
@@ -6150,6 +6186,14 @@
 		p_cm = vim_strsave((char_u *)"zip");
 		new_value_alloced = TRUE;
 	    }
+	    /* When using ":set cm=name" the local value is going to be empty.
+	     * Do that here, otherwise the crypt functions will still use the
+	     * local value. */
+	    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)
+	    {
+		free_string_option(curbuf->b_p_cm);
+		curbuf->b_p_cm = empty_option;
+	    }
 
 	    /* Need to update the swapfile when the effective method changed.
 	     * Set "s" to the effective old value, "p" to the effective new
@@ -6164,7 +6208,7 @@
 		p = curbuf->b_p_cm;
 	    if (STRCMP(s, p) != 0)
 		ml_set_crypt_key(curbuf, curbuf->b_p_key,
-						 crypt_method_from_string(s));
+						crypt_method_nr_from_name(s));
 
 	    /* If the global value changes need to update the swapfile for all
 	     * buffers using that value. */
@@ -6175,7 +6219,7 @@
 		for (buf = firstbuf; buf != NULL; buf = buf->b_next)
 		    if (buf != curbuf && *buf->b_p_cm == NUL)
 			ml_set_crypt_key(buf, buf->b_p_key,
-					    crypt_method_from_string(oldval));
+					   crypt_method_nr_from_name(oldval));
 	    }
 	}
     }
@@ -6563,7 +6607,6 @@
     }
 #endif
 
-#ifdef FEAT_VISUAL
     /* 'selection' */
     else if (varp == &p_sel)
     {
@@ -6578,7 +6621,6 @@
 	if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)
 	    errmsg = e_invarg;
     }
-#endif
 
 #ifdef FEAT_BROWSE
     /* 'browsedir' */
@@ -6590,7 +6632,6 @@
     }
 #endif
 
-#ifdef FEAT_VISUAL
     /* 'keymodel' */
     else if (varp == &p_km)
     {
@@ -6602,7 +6643,6 @@
 	    km_startsel = (vim_strchr(p_km, 'a') != NULL);
 	}
     }
-#endif
 
     /* 'mousemodel' */
     else if (varp == &p_mousem)
@@ -6990,6 +7030,23 @@
     }
 #endif
 
+#ifdef FEAT_CINDENT
+    /* 'cinoptions' */
+    else if (gvarp == &p_cino)
+    {
+	/* TODO: recognize errors */
+	parse_cino(curbuf);
+    }
+#endif
+
+#if defined(FEAT_RENDER_OPTIONS)
+    else if (varp == &p_rop && gui.in_use)
+    {
+	if (!gui_mch_set_rendering_options(p_rop))
+	    errmsg = e_invarg;
+    }
+#endif
+
     /* Options that are a list of flags. */
     else
     {
@@ -7102,6 +7159,11 @@
 	if (varp == &(curwin->w_s->b_p_spl))
 	{
 	    char_u	fname[200];
+	    char_u	*q = curwin->w_s->b_p_spl;
+
+	    /* Skip the first name if it is "cjk". */
+	    if (STRNCMP(q, "cjk,", 4) == 0)
+		q += 4;
 
 	    /*
 	     * Source the spell/LANG.vim in 'runtimepath'.
@@ -7109,11 +7171,10 @@
 	     * Use the first name in 'spelllang' up to '_region' or
 	     * '.encoding'.
 	     */
-	    for (p = curwin->w_s->b_p_spl; *p != NUL; ++p)
+	    for (p = q; *p != NUL; ++p)
 		if (vim_strchr((char_u *)"_.,", *p) != NULL)
 		    break;
-	    vim_snprintf((char *)fname, 200, "spell/%.*s.vim",
-				 (int)(p - curwin->w_s->b_p_spl), curwin->w_s->b_p_spl);
+	    vim_snprintf((char *)fname, 200, "spell/%.*s.vim", (int)(p - q), q);
 	    source_runtime(fname, TRUE);
 	}
 #endif
@@ -7791,7 +7852,7 @@
     /* when 'hlsearch' is set or reset: reset no_hlsearch */
     else if ((int *)varp == &p_hls)
     {
-	no_hlsearch = FALSE;
+	SET_NO_HLSEARCH(FALSE);
     }
 #endif
 
@@ -8338,14 +8399,24 @@
 	    curwin->w_p_fdc = 12;
 	}
     }
+#endif /* FEAT_FOLDING */
 
+#if defined(FEAT_FOLDING) || defined(FEAT_CINDENT)
     /* 'shiftwidth' or 'tabstop' */
     else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)
     {
+# ifdef FEAT_FOLDING
 	if (foldmethodIsIndent(curwin))
 	    foldUpdateAll(curwin);
+# endif
+# ifdef FEAT_CINDENT
+	/* When 'shiftwidth' changes, or it's zero and 'tabstop' changes:
+	 * parse 'cinoptions'. */
+	if (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0)
+	    parse_cino(curbuf);
+# endif
     }
-#endif /* FEAT_FOLDING */
+#endif
 
 #ifdef FEAT_MBYTE
     /* 'maxcombine' */
@@ -8467,6 +8538,13 @@
 	u_sync(TRUE);
 	p_ul = value;
     }
+    else if (pp == &curbuf->b_p_ul)
+    {
+	/* use the old value, otherwise u_sync() may not work properly */
+	curbuf->b_p_ul = old_value;
+	u_sync(TRUE);
+	curbuf->b_p_ul = value;
+    }
 
 #ifdef FEAT_LINEBREAK
     /* 'numberwidth' must be positive */
@@ -8599,6 +8677,11 @@
 	errmsg = e_positive;
 	p_hi = 0;
     }
+    else if (p_hi > 10000)
+    {
+	errmsg = e_invarg;
+	p_hi = 10000;
+    }
     if (p_re < 0 || p_re > 2)
     {
 	errmsg = e_invarg;
@@ -8820,7 +8903,7 @@
 }
 #endif
 
-#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)
 /*
  * Returns the option attributes and its value. Unlike the above function it
  * will return either global value or local value of the option depending on
@@ -8833,7 +8916,8 @@
  * opt_type). Uses
  *
  * Returned flags:
- *       0 hidden or unknown option
+ *       0 hidden or unknown option, also option that does not have requested
+ *	   type (see SREQ_* in vim.h)
  *  see SOPT_* in vim.h for other flags
  *
  * Possible opt_type values: see SREQ_* in vim.h
@@ -8956,6 +9040,69 @@
 
     return r;
 }
+
+/*
+ * Iterate over options. First argument is a pointer to a pointer to a
+ * structure inside options[] array, second is option type like in the above
+ * function.
+ *
+ * If first argument points to NULL it is assumed that iteration just started
+ * and caller needs the very first value.
+ * If first argument points to the end marker function returns NULL and sets
+ * first argument to NULL.
+ *
+ * Returns full option name for current option on each call.
+ */
+    char_u *
+option_iter_next(option, opt_type)
+    void	**option;
+    int		opt_type;
+{
+    struct vimoption	*ret = NULL;
+    do
+    {
+	if (*option == NULL)
+	    *option = (void *) options;
+	else if (((struct vimoption *) (*option))->fullname == NULL)
+	{
+	    *option = NULL;
+	    return NULL;
+	}
+	else
+	    *option = (void *) (((struct vimoption *) (*option)) + 1);
+
+	ret = ((struct vimoption *) (*option));
+
+	/* Hidden option */
+	if (ret->var == NULL)
+	{
+	    ret = NULL;
+	    continue;
+	}
+
+	switch (opt_type)
+	{
+	    case SREQ_GLOBAL:
+		if (!(ret->indir == PV_NONE || ret->indir & PV_BOTH))
+		    ret = NULL;
+		break;
+	    case SREQ_BUF:
+		if (!(ret->indir & PV_BUF))
+		    ret = NULL;
+		break;
+	    case SREQ_WIN:
+		if (!(ret->indir & PV_WIN))
+		    ret = NULL;
+		break;
+	    default:
+		EMSG2(_(e_intern2), "option_iter_next()");
+		return NULL;
+	}
+    }
+    while (ret == NULL);
+
+    return (char_u *)ret->fullname;
+}
 #endif
 
 /*
@@ -9700,7 +9847,6 @@
 /*
  * Unset local option value, similar to ":set opt<".
  */
-
     void
 unset_global_local_option(name, from)
     char_u	*name;
@@ -9728,6 +9874,10 @@
 	case PV_AR:
 	    buf->b_p_ar = -1;
 	    break;
+	case PV_BKC:
+	    clear_string_option(&buf->b_p_bkc);
+	    buf->b_bkc_flags = 0;
+	    break;
 	case PV_TAGS:
 	    clear_string_option(&buf->b_p_tags);
 	    break;
@@ -9773,6 +9923,14 @@
 	    clear_string_option(&((win_T *)from)->w_p_stl);
 	    break;
 #endif
+	case PV_UL:
+	    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;
+	    break;
+#ifdef FEAT_LISP
+	case PV_LW:
+	    clear_string_option(&buf->b_p_lw);
+	    break;
+#endif
     }
 }
 
@@ -9821,6 +9979,11 @@
 #ifdef FEAT_STL_OPT
 	    case PV_STL:  return (char_u *)&(curwin->w_p_stl);
 #endif
+	    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);
+#ifdef FEAT_LISP
+	    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);
+#endif
+	    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);
 	}
 	return NULL; /* "cannot happen" */
     }
@@ -9853,6 +10016,8 @@
 				    ? (char_u *)&(curbuf->b_p_ar) : p->var;
 	case PV_TAGS:	return *curbuf->b_p_tags != NUL
 				    ? (char_u *)&(curbuf->b_p_tags) : p->var;
+	case PV_BKC:	return *curbuf->b_p_bkc != NUL
+				    ? (char_u *)&(curbuf->b_p_bkc) : p->var;
 #ifdef FEAT_FIND_ID
 	case PV_DEF:	return *curbuf->b_p_def != NUL
 				    ? (char_u *)&(curbuf->b_p_def) : p->var;
@@ -9885,6 +10050,12 @@
 	case PV_STL:	return *curwin->w_p_stl != NUL
 				    ? (char_u *)&(curwin->w_p_stl) : p->var;
 #endif
+	case PV_UL:	return curbuf->b_p_ul != NO_LOCAL_UNDOLEVEL
+				    ? (char_u *)&(curbuf->b_p_ul) : p->var;
+#ifdef FEAT_LISP
+	case PV_LW:	return *curbuf->b_p_lw != NUL
+				    ? (char_u *)&(curbuf->b_p_lw) : p->var;
+#endif
 
 #ifdef FEAT_ARABIC
 	case PV_ARAB:	return (char_u *)&(curwin->w_p_arab);
@@ -9937,6 +10108,8 @@
 	case PV_WRAP:	return (char_u *)&(curwin->w_p_wrap);
 #ifdef FEAT_LINEBREAK
 	case PV_LBR:	return (char_u *)&(curwin->w_p_lbr);
+	case PV_BRI:	return (char_u *)&(curwin->w_p_bri);
+	case PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);
 #endif
 #ifdef FEAT_SCROLLBIND
 	case PV_SCBIND: return (char_u *)&(curwin->w_p_scb);
@@ -10090,6 +10263,9 @@
     wp_to->w_farsi = wp_from->w_farsi;
 #  endif
 # endif
+#if defined(FEAT_LINEBREAK)
+    briopt_check(wp_to);
+#endif
 }
 #endif
 
@@ -10126,6 +10302,8 @@
 #endif
 #ifdef FEAT_LINEBREAK
     to->wo_lbr = from->wo_lbr;
+    to->wo_bri = from->wo_bri;
+    to->wo_briopt = vim_strsave(from->wo_briopt);
 #endif
 #ifdef FEAT_SCROLLBIND
     to->wo_scb = from->wo_scb;
@@ -10187,7 +10365,7 @@
 /*
  * Check for NULL pointers in a winopt_T and replace them with empty_option.
  */
-    void
+    static void
 check_winopt(wop)
     winopt_T	*wop UNUSED;
 {
@@ -10213,6 +10391,9 @@
 #ifdef FEAT_CONCEAL
     check_string_option(&wop->wo_cocu);
 #endif
+#ifdef FEAT_LINEBREAK
+    check_string_option(&wop->wo_briopt);
+#endif
 }
 
 /*
@@ -10232,6 +10413,9 @@
 # endif
     clear_string_option(&wop->wo_fmr);
 #endif
+#ifdef FEAT_LINEBREAK
+    clear_string_option(&wop->wo_briopt);
+#endif
 #ifdef FEAT_RIGHTLEFT
     clear_string_option(&wop->wo_rlc);
 #endif
@@ -10425,6 +10609,9 @@
 	    /* options that are normally global but also have a local value
 	     * are not copied, start using the global value */
 	    buf->b_p_ar = -1;
+	    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;
+	    buf->b_p_bkc = empty_option;
+	    buf->b_bkc_flags = 0;
 #ifdef FEAT_QUICKFIX
 	    buf->b_p_gp = empty_option;
 	    buf->b_p_mp = empty_option;
@@ -10457,6 +10644,9 @@
 #ifdef FEAT_PERSISTENT_UNDO
 	    buf->b_p_udf = p_udf;
 #endif
+#ifdef FEAT_LISP
+	    buf->b_p_lw = empty_option;
+#endif
 
 	    /*
 	     * Don't copy the options set by ex_help(), use the saved values,
@@ -11729,9 +11919,10 @@
  * 'tabstop' value when 'shiftwidth' is zero.
  */
     long
-get_sw_value()
+get_sw_value(buf)
+    buf_T *buf;
 {
-    return curbuf->b_p_sw ? curbuf->b_p_sw : curbuf->b_p_ts;
+    return buf->b_p_sw ? buf->b_p_sw : buf->b_p_ts;
 }
 
 /*
@@ -11741,7 +11932,7 @@
     long
 get_sts_value()
 {
-    return curbuf->b_p_sts < 0 ? get_sw_value() : curbuf->b_p_sts;
+    return curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;
 }
 
 /*
@@ -11841,3 +12032,60 @@
 	    ++ptr;
     }
 }
+
+#if defined(FEAT_LINEBREAK) || defined(PROTO)
+/*
+ * This is called when 'breakindentopt' is changed and when a window is
+ * initialized.
+ */
+    static int
+briopt_check(wp)
+    win_T *wp;
+{
+    char_u	*p;
+    int		bri_shift = 0;
+    long	bri_min = 20;
+    int		bri_sbr = FALSE;
+
+    p = wp->w_p_briopt;
+    while (*p != NUL)
+    {
+	if (STRNCMP(p, "shift:", 6) == 0
+		 && ((p[6] == '-' && VIM_ISDIGIT(p[7])) || VIM_ISDIGIT(p[6])))
+	{
+	    p += 6;
+	    bri_shift = getdigits(&p);
+	}
+	else if (STRNCMP(p, "min:", 4) == 0 && VIM_ISDIGIT(p[4]))
+	{
+	    p += 4;
+	    bri_min = getdigits(&p);
+	}
+	else if (STRNCMP(p, "sbr", 3) == 0)
+	{
+	    p += 3;
+	    bri_sbr = TRUE;
+	}
+	if (*p != ',' && *p != NUL)
+	    return FAIL;
+	if (*p == ',')
+	    ++p;
+    }
+
+    wp->w_p_brishift = bri_shift;
+    wp->w_p_brimin   = bri_min;
+    wp->w_p_brisbr   = bri_sbr;
+
+    return OK;
+}
+#endif
+
+/*
+ * Get the local or global value of 'backupcopy'.
+ */
+    unsigned int
+get_bkc_value(buf)
+    buf_T *buf;
+{
+    return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;
+}
diff -Naur vim74.orig/src/option.h vim74/src/option.h
--- vim74.orig/src/option.h	2013-06-26 16:41:39.000000000 +0000
+++ vim74/src/option.h	2014-10-10 14:53:44.728712917 +0000
@@ -31,9 +31,9 @@
 #     define DFLT_EFM	"%A%p^,%C%%CC-%t-%m,%Cat line number %l in file %f,%f|%l| %m"
 #    else /* Unix, probably */
 #     ifdef EBCDIC
-#define DFLT_EFM	"%*[^ ] %*[^ ] %f:%l%*[ ]%m,%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory `%f',%X%*\\a[%*\\d]: Leaving directory `%f',%DMaking %*\\a in %f,%f|%l| %m"
+#define DFLT_EFM	"%*[^ ] %*[^ ] %f:%l%*[ ]%m,%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory %*[`']%f',%X%*\\a[%*\\d]: Leaving directory %*[`']%f',%DMaking %*\\a in %f,%f|%l| %m"
 #     else
-#define DFLT_EFM	"%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c:,%-GIn file included from %f:%l:%c\\,,%-GIn file included from %f:%l:%c,%-GIn file included from %f:%l,%-G%*[ ]from %f:%l:%c,%-G%*[ ]from %f:%l:,%-G%*[ ]from %f:%l\\,,%-G%*[ ]from %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory `%f',%X%*\\a[%*\\d]: Leaving directory `%f',%D%*\\a: Entering directory `%f',%X%*\\a: Leaving directory `%f',%DMaking %*\\a in %f,%f|%l| %m"
+#define DFLT_EFM	"%*[^\"]\"%f\"%*\\D%l: %m,\"%f\"%*\\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c:,%-GIn file included from %f:%l:%c\\,,%-GIn file included from %f:%l:%c,%-GIn file included from %f:%l,%-G%*[ ]from %f:%l:%c,%-G%*[ ]from %f:%l:,%-G%*[ ]from %f:%l\\,,%-G%*[ ]from %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\, line %l%*\\D%c%*[^ ] %m,%D%*\\a[%*\\d]: Entering directory %*[`']%f',%X%*\\a[%*\\d]: Leaving directory %*[`']%f',%D%*\\a: Entering directory %*[`']%f',%X%*\\a: Leaving directory %*[`']%f',%DMaking %*\\a in %f,%f|%l| %m"
 #     endif
 #    endif
 #   endif
@@ -212,7 +212,8 @@
 #define SHM_SEARCH	's'		/* no search hit bottom messages */
 #define SHM_ATTENTION	'A'		/* no ATTENTION messages */
 #define SHM_INTRO	'I'		/* intro messages */
-#define SHM_ALL		"rmfixlnwaWtToOsAI" /* all possible flags for 'shm' */
+#define SHM_COMPLETIONMENU  'c'		/* completion menu messages */
+#define SHM_ALL		"rmfixlnwaWtToOsAIc" /* all possible flags for 'shm' */
 
 /* characters for p_go: */
 #define GO_ASEL		'a'		/* autoselect */
@@ -326,7 +327,7 @@
 EXTERN char_u	*p_bg;		/* 'background' */
 EXTERN int	p_bk;		/* 'backup' */
 EXTERN char_u	*p_bkc;		/* 'backupcopy' */
-EXTERN unsigned	bkc_flags;
+EXTERN unsigned	bkc_flags;	/* flags from 'backupcopy' */
 #ifdef IN_OPTION_C
 static char *(p_bkc_values[]) = {"yes", "auto", "no", "breaksymlink", "breakhardlink", NULL};
 #endif
@@ -572,9 +573,7 @@
 EXTERN char_u	*p_isp;		/* 'isprint' */
 EXTERN int	p_js;		/* 'joinspaces' */
 EXTERN char_u	*p_kp;		/* 'keywordprg' */
-#ifdef FEAT_VISUAL
 EXTERN char_u	*p_km;		/* 'keymodel' */
-#endif
 #ifdef FEAT_LANGMAP
 EXTERN char_u	*p_langmap;	/* 'langmap'*/
 #endif
@@ -656,6 +655,9 @@
 #endif
 EXTERN int	p_remap;	/* 'remap' */
 EXTERN long	p_re;		/* 'regexpengine' */
+#ifdef FEAT_RENDER_OPTIONS
+EXTERN char_u	*p_rop;		/* 'renderoptions' */
+#endif
 EXTERN long	p_report;	/* 'report' */
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 EXTERN long	p_pvh;		/* 'previewheight' */
@@ -681,10 +683,8 @@
 #endif
 EXTERN char_u	*p_sections;	/* 'sections' */
 EXTERN int	p_secure;	/* 'secure' */
-#ifdef FEAT_VISUAL
 EXTERN char_u	*p_sel;		/* 'selection' */
 EXTERN char_u	*p_slm;		/* 'selectmode' */
-#endif
 #ifdef FEAT_SESSION
 EXTERN char_u	*p_ssop;	/* 'sessionoptions' */
 EXTERN unsigned	ssop_flags;
@@ -918,6 +918,9 @@
     , BV_AR
 #ifdef FEAT_QUICKFIX
     , BV_BH
+#endif
+    , BV_BKC
+#ifdef FEAT_QUICKFIX
     , BV_BT
     , BV_EFM
     , BV_GP
@@ -990,6 +993,7 @@
     , BV_KP
 #ifdef FEAT_LISP
     , BV_LISP
+    , BV_LW
 #endif
     , BV_MA
     , BV_ML
@@ -1031,6 +1035,7 @@
     , BV_TW
     , BV_TX
     , BV_UDF
+    , BV_UL
     , BV_WM
     , BV_COUNT	    /* must be the last one */
 };
@@ -1053,6 +1058,10 @@
 #ifdef FEAT_CURSORBIND
     , WV_CRBIND
 #endif
+#ifdef FEAT_LINEBREAK
+    , WV_BRI
+    , WV_BRIOPT
+#endif
 #ifdef FEAT_DIFF
     , WV_DIFF
 #endif
@@ -1109,3 +1118,6 @@
     , WV_WRAP
     , WV_COUNT	    /* must be the last one */
 };
+
+/* Value for b_p_ul indicating the global value must be used. */
+#define NO_LOCAL_UNDOLEVEL -123456
diff -Naur vim74.orig/src/os_amiga.c vim74/src/os_amiga.c
--- vim74.orig/src/os_amiga.c	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/os_amiga.c	2014-10-10 14:53:44.732046242 +0000
@@ -884,8 +884,9 @@
  * Return -1 if unknown.
  */
     int
-mch_can_exe(name)
+mch_can_exe(name, path)
     char_u	*name;
+    char_u	**path;
 {
     /* TODO */
     return -1;
diff -Naur vim74.orig/src/os_dos.h vim74/src/os_dos.h
--- vim74.orig/src/os_dos.h	2013-06-12 18:09:44.000000000 +0000
+++ vim74/src/os_dos.h	2014-10-10 14:53:44.738712892 +0000
@@ -109,7 +109,7 @@
 #endif
 
 #ifndef DFLT_BDIR
-# define DFLT_BDIR	".,c:\\tmp,c:\\temp"	/* default for 'backupdir' */
+# define DFLT_BDIR	".,$TEMP,c:\\tmp,c:\\temp" /* default for 'backupdir' */
 #endif
 
 #ifndef DFLT_VDIR
@@ -117,7 +117,7 @@
 #endif
 
 #ifndef DFLT_DIR
-# define DFLT_DIR	".,c:\\tmp,c:\\temp"	/* default for 'directory' */
+# define DFLT_DIR	".,$TEMP,c:\\tmp,c:\\temp" /* default for 'directory' */
 #endif
 
 #define DFLT_ERRORFILE		"errors.err"
diff -Naur vim74.orig/src/os_mac.h vim74/src/os_mac.h
--- vim74.orig/src/os_mac.h	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/os_mac.h	2014-10-10 14:53:44.742046217 +0000
@@ -16,6 +16,11 @@
 # define OPAQUE_TOOLBOX_STRUCTS 0
 #endif
 
+/* Include MAC_OS_X_VERSION_* macros */
+#ifdef HAVE_AVAILABILITYMACROS_H
+# include <AvailabilityMacros.h>
+#endif
+
 /*
  * Macintosh machine-dependent things.
  *
@@ -263,7 +268,7 @@
 #endif
 
 /* Some "prep work" definition to be able to compile the MacOS X
- * version with os_unix.x instead of os_mac.c. Based on the result
+ * version with os_unix.c instead of os_mac.c. Based on the result
  * of ./configure for console MacOS X.
  */
 
diff -Naur vim74.orig/src/os_msdos.c vim74/src/os_msdos.c
--- vim74.orig/src/os_msdos.c	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/os_msdos.c	2014-10-10 14:53:44.762046167 +0000
@@ -2270,9 +2270,7 @@
 		default:
 		case 'L':	type = MLINE;	break;
 		case 'C':	type = MCHAR;	break;
-#ifdef FEAT_VISUAL
 		case 'B':	type = MBLOCK;	break;
-#endif
 	    }
 	}
 
@@ -2799,9 +2797,7 @@
 	    default:
 	    case MLINE:	    clip_sel_type = "L";	break;
 	    case MCHAR:	    clip_sel_type = "C";	break;
-#ifdef FEAT_VISUAL
 	    case MBLOCK:    clip_sel_type = "B";	break;
-#endif
 	}
 
 	movedata(
@@ -2949,14 +2945,17 @@
  * Return -1 if unknown.
  */
     int
-mch_can_exe(name)
+mch_can_exe(name, path)
     char_u	*name;
+    char_u	**path;
 {
     char	*p;
 
     p = searchpath(name);
     if (p == NULL || mch_isdir(p))
 	return FALSE;
+    if (path != NULL)
+	*path = vim_strsave(p);
     return TRUE;
 }
 
diff -Naur vim74.orig/src/os_mswin.c vim74/src/os_mswin.c
--- vim74.orig/src/os_mswin.c	2013-06-16 14:41:11.000000000 +0000
+++ vim74/src/os_mswin.c	2014-10-10 14:53:44.765379492 +0000
@@ -277,10 +277,6 @@
     AnsiUpperBuff(toupper_tab, 256);
     AnsiLowerBuff(tolower_tab, 256);
 #endif
-
-#if defined(FEAT_MBYTE) && !defined(FEAT_GUI)
-    (void)get_cmd_argsW(NULL);
-#endif
 }
 
 
@@ -456,7 +452,14 @@
     int
 mch_isFullName(char_u *fname)
 {
+#ifdef FEAT_MBYTE
+    /* WinNT and later can use _MAX_PATH wide characters for a pathname, which
+     * means that the maximum pathname is _MAX_PATH * 3 bytes when 'enc' is
+     * UTF-8. */
+    char szName[_MAX_PATH * 3 + 1];
+#else
     char szName[_MAX_PATH + 1];
+#endif
 
     /* A name like "d:/foo" and "//server/share" is absolute */
     if ((fname[0] && fname[1] == ':' && (fname[2] == '/' || fname[2] == '\\'))
@@ -464,7 +467,7 @@
 	return TRUE;
 
     /* A name that can't be made absolute probably isn't absolute. */
-    if (mch_FullName(fname, szName, _MAX_PATH, FALSE) == FAIL)
+    if (mch_FullName(fname, szName, sizeof(szName) - 1, FALSE) == FAIL)
 	return FALSE;
 
     return pathcmp(fname, szName, -1) == 0;
@@ -491,6 +494,104 @@
     }
 }
 
+#if (defined(_MSC_VER) && (_MSC_VER >= 1300)) || defined(__MINGW32__)
+# define OPEN_OH_ARGTYPE intptr_t
+#else
+# define OPEN_OH_ARGTYPE long
+#endif
+
+    static int
+stat_symlink_aware(const char *name, struct stat *stp)
+{
+#if defined(_MSC_VER) && _MSC_VER < 1700
+    /* Work around for VC10 or earlier. stat() can't handle symlinks properly.
+     * VC9 or earlier: stat() doesn't support a symlink at all. It retrieves
+     * status of a symlink itself.
+     * VC10: stat() supports a symlink to a normal file, but it doesn't support
+     * a symlink to a directory (always returns an error). */
+    WIN32_FIND_DATA	findData;
+    HANDLE		hFind, h;
+    DWORD		attr = 0;
+    BOOL		is_symlink = FALSE;
+
+    hFind = FindFirstFile(name, &findData);
+    if (hFind != INVALID_HANDLE_VALUE)
+    {
+	attr = findData.dwFileAttributes;
+	if ((attr & FILE_ATTRIBUTE_REPARSE_POINT)
+		&& (findData.dwReserved0 == IO_REPARSE_TAG_SYMLINK))
+	    is_symlink = TRUE;
+	FindClose(hFind);
+    }
+    if (is_symlink)
+    {
+	h = CreateFile(name, FILE_READ_ATTRIBUTES,
+		FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+		OPEN_EXISTING,
+		(attr & FILE_ATTRIBUTE_DIRECTORY)
+					    ? FILE_FLAG_BACKUP_SEMANTICS : 0,
+		NULL);
+	if (h != INVALID_HANDLE_VALUE)
+	{
+	    int	    fd, n;
+
+	    fd = _open_osfhandle((OPEN_OH_ARGTYPE)h, _O_RDONLY);
+	    n = _fstat(fd, (struct _stat*)stp);
+	    _close(fd);
+	    return n;
+	}
+    }
+#endif
+    return stat(name, stp);
+}
+
+#ifdef FEAT_MBYTE
+    static int
+wstat_symlink_aware(const WCHAR *name, struct _stat *stp)
+{
+# if defined(_MSC_VER) && _MSC_VER < 1700
+    /* Work around for VC10 or earlier. _wstat() can't handle symlinks properly.
+     * VC9 or earlier: _wstat() doesn't support a symlink at all. It retrieves
+     * status of a symlink itself.
+     * VC10: _wstat() supports a symlink to a normal file, but it doesn't
+     * support a symlink to a directory (always returns an error). */
+    int			n;
+    BOOL		is_symlink = FALSE;
+    HANDLE		hFind, h;
+    DWORD		attr = 0;
+    WIN32_FIND_DATAW	findDataW;
+
+    hFind = FindFirstFileW(name, &findDataW);
+    if (hFind != INVALID_HANDLE_VALUE)
+    {
+	attr = findDataW.dwFileAttributes;
+	if ((attr & FILE_ATTRIBUTE_REPARSE_POINT)
+		&& (findDataW.dwReserved0 == IO_REPARSE_TAG_SYMLINK))
+	    is_symlink = TRUE;
+	FindClose(hFind);
+    }
+    if (is_symlink)
+    {
+	h = CreateFileW(name, FILE_READ_ATTRIBUTES,
+		FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+		OPEN_EXISTING,
+		(attr & FILE_ATTRIBUTE_DIRECTORY)
+					    ? FILE_FLAG_BACKUP_SEMANTICS : 0,
+		NULL);
+	if (h != INVALID_HANDLE_VALUE)
+	{
+	    int	    fd;
+
+	    fd = _open_osfhandle((OPEN_OH_ARGTYPE)h, _O_RDONLY);
+	    n = _fstat(fd, stp);
+	    _close(fd);
+	    return n;
+	}
+    }
+# endif
+    return _wstat(name, stp);
+}
+#endif
 
 /*
  * stat() can't handle a trailing '/' or '\', remove it first.
@@ -498,15 +599,36 @@
     int
 vim_stat(const char *name, struct stat *stp)
 {
+#ifdef FEAT_MBYTE
+    /* WinNT and later can use _MAX_PATH wide characters for a pathname, which
+     * means that the maximum pathname is _MAX_PATH * 3 bytes when 'enc' is
+     * UTF-8. */
+    char	buf[_MAX_PATH * 3 + 1];
+#else
     char	buf[_MAX_PATH + 1];
+#endif
     char	*p;
 
-    vim_strncpy((char_u *)buf, (char_u *)name, _MAX_PATH);
+    vim_strncpy((char_u *)buf, (char_u *)name, sizeof(buf) - 1);
     p = buf + strlen(buf);
     if (p > buf)
 	mb_ptr_back(buf, p);
+
+    /* Remove trailing '\\' except root path. */
     if (p > buf && (*p == '\\' || *p == '/') && p[-1] != ':')
 	*p = NUL;
+
+    if ((buf[0] == '\\' && buf[1] == '\\') || (buf[0] == '/' && buf[1] == '/'))
+    {
+	/* UNC root path must be followed by '\\'. */
+	p = vim_strpbrk(buf + 2, "\\/");
+	if (p != NULL)
+	{
+	    p = vim_strpbrk(p + 1, "\\/");
+	    if (p == NULL)
+		STRCAT(buf, "\\");
+	}
+    }
 #ifdef FEAT_MBYTE
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
 # ifdef __BORLANDC__
@@ -520,9 +642,9 @@
 
 	if (wp != NULL)
 	{
-	    n = _wstat(wp, (struct _stat *)stp);
+	    n = wstat_symlink_aware(wp, (struct _stat *)stp);
 	    vim_free(wp);
-	    if (n >= 0)
+	    if (n >= 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
 		return n;
 	    /* Retry with non-wide function (for Windows 98). Can't use
 	     * GetLastError() here and it's unclear what errno gets set to if
@@ -530,7 +652,7 @@
 	}
     }
 #endif
-    return stat(buf, stp);
+    return stat_symlink_aware(buf, stp);
 }
 
 #if defined(FEAT_GUI_MSWIN) || defined(PROTO)
@@ -689,8 +811,8 @@
 	{
 	    n = _wchdir(p);
 	    vim_free(p);
-	    if (n == 0)
-		return 0;
+	    if (n == 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
+		return n;
 	    /* Retry with non-wide function (for Windows 98). */
 	}
     }
@@ -806,6 +928,33 @@
 }
 # endif
 
+/*
+ * Passed to do_in_runtimepath() to load a vim.ico file.
+ */
+    static void
+mch_icon_load_cb(char_u *fname, void *cookie)
+{
+    HANDLE *h = (HANDLE *)cookie;
+
+    *h = LoadImage(NULL,
+		   fname,
+		   IMAGE_ICON,
+		   64,
+		   64,
+		   LR_LOADFROMFILE | LR_LOADMAP3DCOLORS);
+}
+
+/*
+ * Try loading an icon file from 'runtimepath'.
+ */
+    int
+mch_icon_load(iconp)
+    HANDLE *iconp;
+{
+    return do_in_runtimepath((char_u *)"bitmaps/vim.ico",
+					      FALSE, mch_icon_load_cb, iconp);
+}
+
     int
 mch_libcall(
     char_u	*libname,
@@ -1486,11 +1635,33 @@
 	char_u	*printer_name = (char_u *)devname + devname->wDeviceOffset;
 	char_u	*port_name = (char_u *)devname +devname->wOutputOffset;
 	char_u	*text = _("to %s on %s");
+#ifdef FEAT_MBYTE
+	char_u  *printer_name_orig = printer_name;
+	char_u	*port_name_orig = port_name;
+
+	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+	{
+	    char_u  *to_free = NULL;
+	    int     maxlen;
 
+	    acp_to_enc(printer_name, STRLEN(printer_name), &to_free, &maxlen);
+	    if (to_free != NULL)
+		printer_name = to_free;
+	    acp_to_enc(port_name, STRLEN(port_name), &to_free, &maxlen);
+	    if (to_free != NULL)
+		port_name = to_free;
+	}
+#endif
 	prt_name = alloc((unsigned)(STRLEN(printer_name) + STRLEN(port_name)
 							     + STRLEN(text)));
 	if (prt_name != NULL)
 	    wsprintf(prt_name, text, printer_name, port_name);
+#ifdef FEAT_MBYTE
+	if (printer_name != printer_name_orig)
+	    vim_free(printer_name);
+	if (port_name != port_name_orig)
+	    vim_free(port_name);
+#endif
     }
     GlobalUnlock(prt_dlg.hDevNames);
 
@@ -1524,16 +1695,22 @@
      */
     psettings->chars_per_line = prt_get_cpl();
     psettings->lines_per_page = prt_get_lpp();
-    psettings->n_collated_copies = (prt_dlg.Flags & PD_COLLATE)
-							? prt_dlg.nCopies : 1;
-    psettings->n_uncollated_copies = (prt_dlg.Flags & PD_COLLATE)
-							? 1 : prt_dlg.nCopies;
-
-    if (psettings->n_collated_copies == 0)
+    if (prt_dlg.Flags & PD_USEDEVMODECOPIESANDCOLLATE)
+    {
+	psettings->n_collated_copies = (prt_dlg.Flags & PD_COLLATE)
+						    ? prt_dlg.nCopies : 1;
+	psettings->n_uncollated_copies = (prt_dlg.Flags & PD_COLLATE)
+						    ? 1 : prt_dlg.nCopies;
+
+	if (psettings->n_collated_copies == 0)
+	    psettings->n_collated_copies = 1;
+
+	if (psettings->n_uncollated_copies == 0)
+	    psettings->n_uncollated_copies = 1;
+    } else {
 	psettings->n_collated_copies = 1;
-
-    if (psettings->n_uncollated_copies == 0)
 	psettings->n_uncollated_copies = 1;
+    }
 
     psettings->jobname = jobname;
 
@@ -1761,9 +1938,13 @@
     IPersistFile	*ppf = NULL;
     OLECHAR		wsz[MAX_PATH];
     WIN32_FIND_DATA	ffd; // we get those free of charge
-    TCHAR		buf[MAX_PATH]; // could have simply reused 'wsz'...
+    CHAR		buf[MAX_PATH]; // could have simply reused 'wsz'...
     char_u		*rfname = NULL;
     int			len;
+# ifdef FEAT_MBYTE
+    IShellLinkW		*pslw = NULL;
+    WIN32_FIND_DATAW	ffdw; // we get those free of charge
+# endif
 
     /* Check if the file name ends in ".lnk". Avoid calling
      * CoCreateInstance(), it's quite slow. */
@@ -1775,18 +1956,61 @@
 
     CoInitialize(NULL);
 
+# ifdef FEAT_MBYTE
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	// create a link manager object and request its interface
+	hr = CoCreateInstance(
+		&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
+		&IID_IShellLinkW, (void**)&pslw);
+	if (hr == S_OK)
+	{
+	    WCHAR	*p = enc_to_utf16(fname, NULL);
+
+	    if (p != NULL)
+	    {
+		// Get a pointer to the IPersistFile interface.
+		hr = pslw->lpVtbl->QueryInterface(
+			pslw, &IID_IPersistFile, (void**)&ppf);
+		if (hr != S_OK)
+		    goto shortcut_errorw;
+
+		// "load" the name and resolve the link
+		hr = ppf->lpVtbl->Load(ppf, p, STGM_READ);
+		if (hr != S_OK)
+		    goto shortcut_errorw;
+#  if 0  // This makes Vim wait a long time if the target does not exist.
+		hr = pslw->lpVtbl->Resolve(pslw, NULL, SLR_NO_UI);
+		if (hr != S_OK)
+		    goto shortcut_errorw;
+#  endif
+
+		// Get the path to the link target.
+		ZeroMemory(wsz, MAX_PATH * sizeof(WCHAR));
+		hr = pslw->lpVtbl->GetPath(pslw, wsz, MAX_PATH, &ffdw, 0);
+		if (hr == S_OK && wsz[0] != NUL)
+		    rfname = utf16_to_enc(wsz, NULL);
+
+shortcut_errorw:
+		vim_free(p);
+		goto shortcut_end;
+	    }
+	}
+	/* Retry with non-wide function (for Windows 98). */
+    }
+# endif
     // create a link manager object and request its interface
     hr = CoCreateInstance(
 	    &CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
 	    &IID_IShellLink, (void**)&psl);
     if (hr != S_OK)
-	goto shortcut_error;
+	goto shortcut_end;
 
     // Get a pointer to the IPersistFile interface.
     hr = psl->lpVtbl->QueryInterface(
 	    psl, &IID_IPersistFile, (void**)&ppf);
     if (hr != S_OK)
-	goto shortcut_error;
+	goto shortcut_end;
 
     // full path string must be in Unicode.
     MultiByteToWideChar(CP_ACP, 0, fname, -1, wsz, MAX_PATH);
@@ -1794,12 +2018,12 @@
     // "load" the name and resolve the link
     hr = ppf->lpVtbl->Load(ppf, wsz, STGM_READ);
     if (hr != S_OK)
-	goto shortcut_error;
-#if 0  // This makes Vim wait a long time if the target doesn't exist.
+	goto shortcut_end;
+# if 0  // This makes Vim wait a long time if the target doesn't exist.
     hr = psl->lpVtbl->Resolve(psl, NULL, SLR_NO_UI);
     if (hr != S_OK)
-	goto shortcut_error;
-#endif
+	goto shortcut_end;
+# endif
 
     // Get the path to the link target.
     ZeroMemory(buf, MAX_PATH);
@@ -1807,12 +2031,16 @@
     if (hr == S_OK && buf[0] != NUL)
 	rfname = vim_strsave(buf);
 
-shortcut_error:
+shortcut_end:
     // Release all interface pointers (both belong to the same object)
     if (ppf != NULL)
 	ppf->lpVtbl->Release(ppf);
     if (psl != NULL)
 	psl->lpVtbl->Release(psl);
+# ifdef FEAT_MBYTE
+    if (pslw != NULL)
+	pslw->lpVtbl->Release(pslw);
+# endif
 
     CoUninitialize();
     return rfname;
@@ -2690,12 +2918,27 @@
 {
     char_u	*p;
     int		i;
+    int		ret = FAIL;
     static LOGFONT *lastlf = NULL;
+#ifdef FEAT_MBYTE
+    char_u	*acpname = NULL;
+#endif
 
     *lf = s_lfDefault;
     if (name == NULL)
 	return OK;
 
+#ifdef FEAT_MBYTE
+    /* Convert 'name' from 'encoding' to the current codepage, because
+     * lf->lfFaceName uses the current codepage.
+     * TODO: Use Wide APIs instead of ANSI APIs. */
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	int	len;
+	enc_to_acp(name, (int)strlen(name), &acpname, &len);
+	name = acpname;
+    }
+#endif
     if (STRCMP(name, "*") == 0)
     {
 #if defined(FEAT_GUI_W32)
@@ -2710,10 +2953,9 @@
 	cf.lpLogFont = lf;
 	cf.nFontType = 0 ; //REGULAR_FONTTYPE;
 	if (ChooseFont(&cf))
-	    goto theend;
-#else
-	return FAIL;
+	    ret = OK;
 #endif
+	goto theend;
     }
 
     /*
@@ -2722,7 +2964,7 @@
     for (p = name; *p && *p != ':'; p++)
     {
 	if (p - name + 1 > LF_FACESIZE)
-	    return FAIL;			/* Name too long */
+	    goto theend;			/* Name too long */
 	lf->lfFaceName[p - name] = *p;
     }
     if (p != name)
@@ -2750,7 +2992,7 @@
 		did_replace = TRUE;
 	    }
 	if (!did_replace || init_logfont(lf) == FAIL)
-	    return FAIL;
+	    goto theend;
     }
 
     while (*p == ':')
@@ -2811,25 +3053,27 @@
 			    p[-1], name);
 		    EMSG(IObuff);
 		}
-		return FAIL;
+		goto theend;
 	}
 	while (*p == ':')
 	    p++;
     }
+    ret = OK;
 
-#if defined(FEAT_GUI_W32)
 theend:
-#endif
     /* ron: init lastlf */
-    if (printer_dc == NULL)
+    if (ret == OK && printer_dc == NULL)
     {
 	vim_free(lastlf);
 	lastlf = (LOGFONT *)alloc(sizeof(LOGFONT));
 	if (lastlf != NULL)
 	    mch_memmove(lastlf, lf, sizeof(LOGFONT));
     }
+#ifdef FEAT_MBYTE
+    vim_free(acpname);
+#endif
 
-    return OK;
+    return ret;
 }
 
 #endif /* defined(FEAT_GUI) || defined(FEAT_PRINTER) */
diff -Naur vim74.orig/src/os_os2_cfg.h vim74/src/os_os2_cfg.h
--- vim74.orig/src/os_os2_cfg.h	2010-05-15 11:04:11.000000000 +0000
+++ vim74/src/os_os2_cfg.h	2014-10-10 14:53:44.768712817 +0000
@@ -47,7 +47,7 @@
 #undef UNIX	/* define always by current configure script */
 
 /* Defined to the size of an int */
-#define SIZEOF_INT 4
+#define VIM_SIZEOF_INT 4
 
 /*
  * If we cannot trust one of the following from the libraries, we use our
diff -Naur vim74.orig/src/os_qnx.c vim74/src/os_qnx.c
--- vim74.orig/src/os_qnx.c	2011-09-21 17:48:08.000000000 +0000
+++ vim74/src/os_qnx.c	2014-10-10 14:53:44.768712817 +0000
@@ -78,9 +78,7 @@
 		default: /* fallthrough to line type */
 		case 'L': type = MLINE; break;
 		case 'C': type = MCHAR; break;
-#ifdef FEAT_VISUAL
 		case 'B': type = MBLOCK; break;
-#endif
 	    }
 	    is_type_set = TRUE;
 	}
@@ -143,9 +141,7 @@
 		default: /* fallthrough to MLINE */
 		case MLINE:	*vim_clip = 'L'; break;
 		case MCHAR:	*vim_clip = 'C'; break;
-#ifdef FEAT_VISUAL
 		case MBLOCK:	*vim_clip = 'B'; break;
-#endif
 	    }
 
 	    vim_strncpy(text_clip, str, len);
diff -Naur vim74.orig/src/os_unix.c vim74/src/os_unix.c
--- vim74.orig/src/os_unix.c	2013-07-03 14:32:32.000000000 +0000
+++ vim74/src/os_unix.c	2014-10-10 14:53:44.778712792 +0000
@@ -46,6 +46,14 @@
 static int selinux_enabled = -1;
 #endif
 
+#ifdef HAVE_SMACK
+# include <attr/xattr.h>
+# include <linux/xattr.h>
+# ifndef SMACK_LABEL_LEN
+#  define SMACK_LABEL_LEN 1024
+# endif
+#endif
+
 /*
  * Use this prototype for select, some include files have a wrong prototype
  */
@@ -168,7 +176,7 @@
 static pid_t wait4pid __ARGS((pid_t, waitstatus *));
 
 static int  WaitForChar __ARGS((long));
-#if defined(__BEOS__)
+#if defined(__BEOS__) || defined(VMS)
 int  RealWaitForChar __ARGS((int, long, int *));
 #else
 static int  RealWaitForChar __ARGS((int, long, int *));
@@ -435,7 +443,6 @@
 	/* Process the queued netbeans messages. */
 	netbeans_parse_messages();
 #endif
-#ifndef VMS  /* VMS: must try reading, WaitForChar() does nothing. */
 	/*
 	 * We want to be interrupted by the winch signal
 	 * or by an event on the monitored file descriptors.
@@ -446,7 +453,6 @@
 		handle_resize();
 	    return 0;
 	}
-#endif
 
 	/* If input was put directly in typeahead buffer bail out here. */
 	if (typebuf_changed(tb_change_cnt))
@@ -804,6 +810,10 @@
  * completely full.
  */
 
+#if defined(HAVE_AVAILABILITYMACROS_H)
+# include <AvailabilityMacros.h>
+#endif
+
 #ifndef SIGSTKSZ
 # define SIGSTKSZ 8000    /* just a guess of how much stack is needed... */
 #endif
@@ -957,8 +967,10 @@
 
 /*
  * This function handles deadly signals.
- * It tries to preserve any swap file and exit properly.
+ * It tries to preserve any swap files and exit properly.
  * (partly from Elvis).
+ * NOTE: Avoid unsafe functions, such as allocating memory, they can result in
+ * a deadlock.
  */
     static RETSIGTYPE
 deathtrap SIGDEFARG(sigarg)
@@ -1090,18 +1102,23 @@
     }
     if (entered == 2)
     {
-	OUT_STR(_("Vim: Double signal, exiting\n"));
+	/* No translation, it may call malloc(). */
+	OUT_STR("Vim: Double signal, exiting\n");
 	out_flush();
 	getout(1);
     }
 
+    /* No translation, it may call malloc(). */
 #ifdef SIGHASARG
-    sprintf((char *)IObuff, _("Vim: Caught deadly signal %s\n"),
+    sprintf((char *)IObuff, "Vim: Caught deadly signal %s\n",
 							 signal_info[i].name);
 #else
-    sprintf((char *)IObuff, _("Vim: Caught deadly signal\n"));
+    sprintf((char *)IObuff, "Vim: Caught deadly signal\n");
 #endif
-    preserve_exit();		    /* preserve files and exit */
+
+    /* Preserve files and exit.  This sets the really_exiting flag to prevent
+     * calling free(). */
+    preserve_exit();
 
 #ifdef NBDEBUG
     reset_signals();
@@ -2789,6 +2806,84 @@
 }
 #endif /* HAVE_SELINUX */
 
+#if defined(HAVE_SMACK) && !defined(PROTO)
+/*
+ * Copy security info from "from_file" to "to_file".
+ */
+    void
+mch_copy_sec(from_file, to_file)
+    char_u	*from_file;
+    char_u	*to_file;
+{
+    static const char * const smack_copied_attributes[] =
+	{
+	    XATTR_NAME_SMACK,
+	    XATTR_NAME_SMACKEXEC,
+	    XATTR_NAME_SMACKMMAP
+	};
+
+    char	buffer[SMACK_LABEL_LEN];
+    const char	*name;
+    int		index;
+    int		ret;
+    ssize_t	size;
+
+    if (from_file == NULL)
+	return;
+
+    for (index = 0 ; index < (int)(sizeof(smack_copied_attributes)
+			      / sizeof(smack_copied_attributes)[0]) ; index++)
+    {
+	/* get the name of the attribute to copy */
+	name = smack_copied_attributes[index];
+
+	/* get the value of the attribute in buffer */
+	size = getxattr((char*)from_file, name, buffer, sizeof(buffer));
+	if (size >= 0)
+	{
+	    /* copy the attribute value of buffer */
+	    ret = setxattr((char*)to_file, name, buffer, (size_t)size, 0);
+	    if (ret < 0)
+	    {
+		MSG_PUTS(_("Could not set security context "));
+		MSG_PUTS(name);
+		MSG_PUTS(_(" for "));
+		msg_outtrans(to_file);
+		msg_putchar('\n');
+	    }
+	}
+	else
+	{
+	    /* what reason of not having the attribute value? */
+	    switch (errno)
+	    {
+		case ENOTSUP:
+		    /* extended attributes aren't supported or enabled */
+		    /* should a message be echoed? not sure... */
+		    return; /* leave because it isn't usefull to continue */
+
+		case ERANGE:
+		default:
+		    /* no enough size OR unexpected error */
+		    MSG_PUTS(_("Could not get security context "));
+		    MSG_PUTS(name);
+		    MSG_PUTS(_(" for "));
+		    msg_outtrans(from_file);
+		    MSG_PUTS(_(". Removing it!\n"));
+		    /* FALLTHROUGH to remove the attribute */
+
+		case ENODATA:
+		    /* no attribute of this name */
+		    ret = removexattr((char*)to_file, name);
+		    /* Silently ignore errors, apparently this happens when
+		     * smack is not actually being used. */
+		    break;
+	    }
+	}
+    }
+}
+#endif /* HAVE_SMACK */
+
 /*
  * Return a pointer to the ACL of file "fname" in allocated memory.
  * Return NULL if the ACL is not available for whatever reason.
@@ -2956,7 +3051,26 @@
 
     if (stat((char *)name, &st))
 	return 0;
+#ifdef VMS
+    /* Like on Unix system file can have executable rights but not necessarily
+     * be an executable, but on Unix is not a default for an ordianry file to
+     * have an executable flag - on VMS it is in most cases.
+     * Therefore, this check does not have any sense - let keep us to the
+     * conventions instead:
+     * *.COM and *.EXE files are the executables - the rest are not. This is
+     * not ideal but better then it was.
+     */
+    int vms_executable = 0;
+    if (S_ISREG(st.st_mode) && mch_access((char *)name, X_OK) == 0)
+    {
+	if (strstr(vms_tolower((char*)name),".exe") != NULL
+		|| strstr(vms_tolower((char*)name),".com")!= NULL)
+	    vms_executable = 1;
+    }
+    return vms_executable;
+#else
     return S_ISREG(st.st_mode) && mch_access((char *)name, X_OK) == 0;
+#endif
 }
 
 /*
@@ -2964,8 +3078,9 @@
  * Return -1 if unknown.
  */
     int
-mch_can_exe(name)
+mch_can_exe(name, path)
     char_u	*name;
+    char_u	**path;
 {
     char_u	*buf;
     char_u	*p, *e;
@@ -2974,7 +3089,20 @@
     /* If it's an absolute or relative path don't need to use $PATH. */
     if (mch_isFullName(name) || (name[0] == '.' && (name[1] == '/'
 				      || (name[1] == '.' && name[2] == '/'))))
-	return executable_file(name);
+    {
+	if (executable_file(name))
+	{
+	    if (path != NULL)
+	    {
+		if (name[0] == '.')
+		    *path = FullName_save(name, TRUE);
+		else
+		    *path = vim_strsave(name);
+	    }
+	    return TRUE;
+	}
+	return FALSE;
+    }
 
     p = (char_u *)getenv("PATH");
     if (p == NULL || *p == NUL)
@@ -3002,7 +3130,16 @@
 	STRCAT(buf, name);
 	retval = executable_file(buf);
 	if (retval == 1)
+	{
+	    if (path != NULL)
+	    {
+		if (buf[0] == '.')
+		    *path = FullName_save(buf, TRUE);
+		else
+		    *path = vim_strsave(buf);
+	    }
 	    break;
+	}
 
 	if (*e != ':')
 	    break;
@@ -3574,7 +3711,7 @@
 # endif
 
 # ifdef FEAT_MOUSE_JSB
-    /* conflicts with xterm mouse: "\033[" and "\033[M" ??? */
+    /* Conflicts with xterm mouse: "\033[" and "\033[M" ??? */
     if (!use_xterm_mouse()
 #  ifdef FEAT_GUI
 	    && !gui.in_use
@@ -3601,7 +3738,7 @@
 # endif
 
 # ifdef FEAT_MOUSE_DEC
-    /* conflicts with xterm mouse: "\033[" and "\033[M" */
+    /* Conflicts with xterm mouse: "\033[" and "\033[M" */
     if (!use_xterm_mouse()
 #  ifdef FEAT_GUI
 	    && !gui.in_use
@@ -3613,7 +3750,7 @@
 	del_mouse_termcode(KS_DEC_MOUSE);
 # endif
 # ifdef FEAT_MOUSE_PTERM
-    /* same as the dec mouse */
+    /* same conflict as the dec mouse */
     if (!use_xterm_mouse()
 #  ifdef FEAT_GUI
 	    && !gui.in_use
@@ -3625,7 +3762,7 @@
 	del_mouse_termcode(KS_PTERM_MOUSE);
 # endif
 # ifdef FEAT_MOUSE_URXVT
-    /* same as the dec mouse */
+    /* same conflict as the dec mouse */
     if (use_xterm_mouse() == 3
 #  ifdef FEAT_GUI
 	    && !gui.in_use
@@ -3646,7 +3783,7 @@
 	del_mouse_termcode(KS_URXVT_MOUSE);
 # endif
 # ifdef FEAT_MOUSE_SGR
-    /* same as the dec mouse */
+    /* There is no conflict with xterm mouse */
     if (use_xterm_mouse() == 4
 #  ifdef FEAT_GUI
 	    && !gui.in_use
@@ -5028,6 +5165,7 @@
     return avail;
 }
 
+#ifndef VMS
 /*
  * Wait "msec" msec until a character is available from file descriptor "fd".
  * "msec" == 0 will check for characters once.
@@ -5327,13 +5465,7 @@
 	}
 # endif
 
-# ifdef OLD_VMS
-	/* Old VMS as v6.2 and older have broken select(). It waits more than
-	 * required. Should not be used */
-	ret = 0;
-# else
 	ret = select(maxfd + 1, &rfds, NULL, &efds, tvp);
-# endif
 # ifdef EINTR
 	if (ret == -1 && errno == EINTR)
 	{
@@ -5455,8 +5587,6 @@
     return (ret > 0);
 }
 
-#ifndef VMS
-
 #ifndef NO_EXPANDPATH
 /*
  * Expand a path into all matching files and/or directories.  Handles "*",
@@ -5569,7 +5699,7 @@
 		    continue;
 
 		/* Skip files that are not executable if we check for that. */
-		if (!dir && (flags & EW_EXEC) && !mch_can_exe(p))
+		if (!dir && (flags & EW_EXEC) && !mch_can_exe(p, NULL))
 		    continue;
 
 		if (--files_free == 0)
@@ -5809,10 +5939,12 @@
 			*p++ = '\\';
 		    ++j;
 		}
-		else if (!intick && vim_strchr(SHELL_SPECIAL,
-							   pat[i][j]) != NULL)
+		else if (!intick
+			 && ((flags & EW_KEEPDOLLAR) == 0 || pat[i][j] != '$')
+			      && vim_strchr(SHELL_SPECIAL, pat[i][j]) != NULL)
 		    /* Put a backslash before a special character, but not
-		     * when inside ``. */
+		     * when inside ``. And not for $var when EW_KEEPDOLLAR is
+		     * set. */
 		    *p++ = '\\';
 
 		/* Copy one character. */
@@ -5979,7 +6111,7 @@
 	{
 	    /* If there is a NUL, set did_find_nul, else set check_spaces */
 	    buffer[len] = NUL;
-	    if (len && (int)STRLEN(buffer) < (int)len - 1)
+	    if (len && (int)STRLEN(buffer) < (int)len)
 		did_find_nul = TRUE;
 	    else
 		check_spaces = TRUE;
@@ -6067,7 +6199,7 @@
 	    continue;
 
 	/* Skip files that are not executable if we check for that. */
-	if (!dir && (flags & EW_EXEC) && !mch_can_exe((*file)[i]))
+	if (!dir && (flags & EW_EXEC) && !mch_can_exe((*file)[i], NULL))
 	    continue;
 
 	p = alloc((unsigned)(STRLEN((*file)[i]) + 1 + dir));
@@ -6294,7 +6426,7 @@
 
 /* Reads gpm event and adds special keys to input buf. Returns length of
  * generated key sequence.
- * This function is made after gui_send_mouse_event
+ * This function is styled after gui_send_mouse_event().
  */
     static int
 mch_gpm_process()
diff -Naur vim74.orig/src/os_unix.h vim74/src/os_unix.h
--- vim74.orig/src/os_unix.h	2013-06-12 18:09:44.000000000 +0000
+++ vim74/src/os_unix.h	2014-10-10 14:53:44.782046117 +0000
@@ -225,6 +225,8 @@
 # include <starlet.h>
 # include <socket.h>
 # include <lib$routines.h>
+# include <libdef.h>
+# include <libdtdef.h>
 
 # ifdef FEAT_GUI_GTK
 #  include "gui_gtk_vms.h"
@@ -300,7 +302,7 @@
 #  define USR_VIMRC_FILE2	"$HOME/vimfiles/vimrc"
 # else
 #  ifdef VMS
-#   define USR_VIMRC_FILE2	"sys$login:vimfiles:vimrc"
+#   define USR_VIMRC_FILE2	"sys$login:vimfiles/vimrc"
 #  else
 #    define USR_VIMRC_FILE2	"~/.vim/vimrc"
 #  endif
@@ -327,7 +329,7 @@
 #  define USR_GVIMRC_FILE2	"$HOME/vimfiles/gvimrc"
 # else
 #  ifdef VMS
-#   define USR_GVIMRC_FILE2	"sys$login:vimfiles:gvimrc"
+#   define USR_GVIMRC_FILE2	"sys$login:vimfiles/gvimrc"
 #  else
 #   define USR_GVIMRC_FILE2	"~/.vim/gvimrc"
 #  endif
@@ -563,7 +565,9 @@
 # endif
 #endif
 
-#define HAVE_DUP		/* have dup() */
+#ifndef HAVE_DUP
+# define HAVE_DUP		/* have dup() */
+#endif
 #define HAVE_ST_MODE		/* have stat.st_mode */
 
 /* We have three kinds of ACL support. */
diff -Naur vim74.orig/src/os_vms.c vim74/src/os_vms.c
--- vim74.orig/src/os_vms.c	2010-06-26 04:03:31.000000000 +0000
+++ vim74/src/os_vms.c	2014-10-10 14:53:44.788712767 +0000
@@ -11,6 +11,23 @@
 
 #include	"vim.h"
 
+/* define _generic_64 for use in time functions */
+#ifndef VAX
+#   include <gen64def.h>
+#else
+/* based on Alpha's gen64def.h; the file is absent on VAX */
+typedef struct _generic_64 {
+#   pragma __nomember_alignment
+    __union  {                          /* You can treat me as...  */
+	/* long long is not available on VAXen */
+	/* unsigned __int64 gen64$q_quadword; ...a single 64-bit value, or */
+
+	unsigned int gen64$l_longword [2]; /* ...two 32-bit values, or */
+	unsigned short int gen64$w_word [4]; /* ...four 16-bit values */
+    } gen64$r_quad_overlay;
+} GENERIC_64;
+#endif
+
 typedef struct
 {
     char	class;
@@ -279,6 +296,18 @@
 }
 
 /*
+ * Convert string to lowercase - most often filename
+ */
+    char *
+vms_tolower( char *name )
+{
+    int i,nlen = strlen(name);
+    for (i = 0; i < nlen; i++)
+	name[i] = TOLOWER_ASC(name[i]);
+    return name;
+}
+
+/*
  * Convert VMS system() or lib$spawn() return code to Unix-like exit value.
  */
     int
@@ -344,13 +373,12 @@
 vms_wproc(char *name, int val)
 {
     int i;
-    int nlen;
     static int vms_match_alloced = 0;
 
-    if (val != DECC$K_FILE) /* Directories and foreign non VMS files are not
-			       counting  */
+    if (val == DECC$K_FOREIGN ) /* foreign non VMS files are not counting */
 	return 1;
 
+    /* accept all DECC$K_FILE and DECC$K_DIRECTORY */
     if (vms_match_num == 0) {
 	/* first time through, setup some things */
 	if (NULL == vms_fmatch) {
@@ -366,12 +394,9 @@
 	}
     }
 
+    /* make matches look uniform */
     vms_remove_version(name);
-
-    /* convert filename to lowercase */
-    nlen = strlen(name);
-    for (i = 0; i < nlen; i++)
-	name[i] = TOLOWER_ASC(name[i]);
+    name=vms_tolower(name);
 
     /* if name already exists, don't add it */
     for (i = 0; i<vms_match_num; i++) {
@@ -411,6 +436,7 @@
 {
     int		i, cnt = 0;
     char_u	buf[MAXPATHL];
+    char       *result;
     int		dir;
     int files_alloced, files_free;
 
@@ -432,8 +458,13 @@
 	    STRCPY(buf,pat[i]);
 
 	vms_match_num = 0; /* reset collection counter */
-	cnt = decc$to_vms(decc$translate_vms(vms_fixfilename(buf)), vms_wproc, 1, 0);
-						      /* allow wild, no dir */
+	result = decc$translate_vms(vms_fixfilename(buf));
+	if ( (int) result == 0 || (int) result == -1  ) {
+	    cnt = 0;
+	}
+        else {
+	    cnt = decc$to_vms(result, vms_wproc, 1 /*allow wild*/ , (flags & EW_DIR ? 0:1 ) /*allow directory*/) ;
+	}
 	if (cnt > 0)
 	    cnt = vms_match_num;
 
@@ -452,7 +483,7 @@
 		continue;
 
 	    /* Skip files that are not executable if we check for that. */
-	    if (!dir && (flags & EW_EXEC) && !mch_can_exe(vms_fmatch[i]))
+	    if (!dir && (flags & EW_EXEC) && !mch_can_exe(vms_fmatch[i], NULL))
 		continue;
 
 	    /* allocate memory for pointers */
@@ -480,10 +511,18 @@
 mch_expandpath(garray_T *gap, char_u *path, int flags)
 {
     int		i,cnt = 0;
-    vms_match_num = 0;
+    char       *result;
 
-    cnt = decc$to_vms(decc$translate_vms(vms_fixfilename(path)), vms_wproc, 1, 0);
-						      /* allow wild, no dir */
+    vms_match_num = 0;
+    /* the result from the decc$translate_vms needs to be handled */
+    /* otherwise it might create ACCVIO error in decc$to_vms      */
+    result = decc$translate_vms(vms_fixfilename(path));
+    if ( (int) result == 0 || (int) result == -1  ) {
+        cnt = 0;
+    }
+    else {
+        cnt = decc$to_vms(result, vms_wproc, 1 /*allow_wild*/, (flags & EW_DIR ? 0:1 ) /*allow directory*/);
+    }
     if (cnt > 0)
 	cnt = vms_match_num;
     for (i = 0; i < cnt; i++)
@@ -504,6 +543,7 @@
     char *end_of_dir;
     char ch;
     int len;
+    char *out_str=out;
 
     /* copy vms filename portion up to last colon
      * (node and/or disk)
@@ -585,7 +625,6 @@
 	*end_of_dir = ']';
 }
 
-
 /*
  * for decc$to_vms in vms_fixfilename
  */
@@ -669,3 +708,99 @@
     }
     return ;
 }
+
+struct typeahead_st {
+    unsigned short numchars;
+    unsigned char  firstchar;
+    unsigned char  reserved0;
+    unsigned long  reserved1;
+} typeahead;
+
+/*
+ * Wait "msec" msec until a character is available from file descriptor "fd".
+ * "msec" == 0 will check for characters once.
+ * "msec" == -1 will block until a character is available.
+ */
+    int
+RealWaitForChar(fd, msec, check_for_gpm)
+    int		fd UNUSED; /* always read from iochan */
+    long	msec;
+    int		*check_for_gpm UNUSED;
+{
+    int status;
+    struct _generic_64 time_curr;
+    struct _generic_64 time_diff;
+    struct _generic_64 time_out;
+    unsigned int convert_operation = LIB$K_DELTA_SECONDS_F;
+    float sec =(float) msec/1000;
+
+    /* make sure the iochan is set */
+    if (!iochan)
+	get_tty();
+
+    if (sec > 0) {
+        /* time-out specified; convert it to absolute time */
+	/* sec>0 requirement of lib$cvtf_to_internal_time()*/
+
+        /* get current time (number of 100ns ticks since the VMS Epoch) */
+        status = sys$gettim(&time_curr);
+        if (status != SS$_NORMAL)
+            return 0; /* error */
+        /* construct the delta time */
+#if __G_FLOAT==0
+# ifndef VAX
+	/* IEEE is default on IA64, but can be used on Alpha too - but not on VAX */
+        status = lib$cvts_to_internal_time(
+                &convert_operation, &sec, &time_diff);
+# endif
+#else   /* default on Alpha and VAX  */
+        status = lib$cvtf_to_internal_time(
+		&convert_operation, &sec, &time_diff);
+#endif
+        if (status != LIB$_NORMAL)
+            return 0; /* error */
+        /* add them up */
+        status = lib$add_times(
+                &time_curr,
+                &time_diff,
+                &time_out);
+        if (status != LIB$_NORMAL)
+            return 0; /* error */
+    }
+
+    while (TRUE) {
+        /* select() */
+        status = sys$qiow(0, iochan, IO$_SENSEMODE | IO$M_TYPEAHDCNT, iosb,
+                0, 0, &typeahead, 8, 0, 0, 0, 0);
+	if (status != SS$_NORMAL || (iosb[0] & 0xFFFF) != SS$_NORMAL)
+            return 0; /* error */
+
+        if (typeahead.numchars)
+            return 1; /* ready to read */
+
+        /* there's nothing to read; what now? */
+        if (msec == 0) {
+            /* immediate time-out; return impatiently */
+            return 0;
+        }
+        else if (msec < 0) {
+            /* no time-out; wait on indefinitely */
+            continue;
+        }
+        else {
+            /* time-out needs to be checked */
+            status = sys$gettim(&time_curr);
+            if (status != SS$_NORMAL)
+                return 0; /* error */
+
+            status = lib$sub_times(
+                    &time_out,
+                    &time_curr,
+                    &time_diff);
+            if (status != LIB$_NORMAL)
+                return 0; /* error, incl. time_diff < 0 (i.e. time-out) */
+
+            /* otherwise wait some more */
+        }
+    }
+}
diff -Naur vim74.orig/src/os_vms_conf.h vim74/src/os_vms_conf.h
--- vim74.orig/src/os_vms_conf.h	2010-07-28 17:07:48.000000000 +0000
+++ vim74/src/os_vms_conf.h	2014-10-10 14:53:44.792046091 +0000
@@ -23,7 +23,7 @@
 #define HAVE_DATE_TIME
 
 /* Defined to the size of an int */
-#define SIZEOF_INT 4
+#define VIM_SIZEOF_INT 4
 
 /* #undef USEBCOPY */
 #define USEMEMMOVE
@@ -166,8 +166,6 @@
 #undef  HAVE_SYS_TIME_H
 #undef  HAVE_LOCALE_H
 #define BROKEN_LOCALE
-#undef  HAVE_ICONV_H
-#undef  HAVE_ICONV
 #undef  DYNAMIC_ICONV
 #undef	HAVE_STRFTIME
 #else
@@ -177,12 +175,18 @@
 #define HAVE_SYS_TIME_H
 #define HAVE_LOCALE_H
 #define BROKEN_LOCALE
-#undef  HAVE_ICONV_H
-#undef  HAVE_ICONV
 #undef  DYNAMIC_ICONV
 #define	HAVE_STRFTIME
 #endif
 
+#if defined(USE_ICONV)
+#define HAVE_ICONV_H
+#define HAVE_ICONV
+#else
+#undef HAVE_ICONV_H
+#undef HAVE_ICONV
+#endif
+
 /* GUI support defines */
 #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK)
 #define HAVE_X11
diff -Naur vim74.orig/src/os_win16.h vim74/src/os_win16.h
--- vim74.orig/src/os_win16.h	2013-05-06 02:06:04.000000000 +0000
+++ vim74/src/os_win16.h	2014-10-10 14:53:44.802046066 +0000
@@ -55,8 +55,8 @@
 
 #define FNAME_ILLEGAL "\"*?><|" /* illegal characters in a file name */
 
-#ifndef SIZEOF_INT
-# define SIZEOF_INT 2
+#ifndef VIM_SIZEOF_INT
+# define VIM_SIZEOF_INT 2
 #endif
 
 typedef long off_t;
diff -Naur vim74.orig/src/os_win32.c vim74/src/os_win32.c
--- vim74.orig/src/os_win32.c	2013-08-10 10:39:12.000000000 +0000
+++ vim74/src/os_win32.c	2014-10-10 14:53:44.805379391 +0000
@@ -78,16 +78,6 @@
 # endif
 #endif
 
-/*
- * Reparse Point
- */
-#ifndef FILE_ATTRIBUTE_REPARSE_POINT
-# define FILE_ATTRIBUTE_REPARSE_POINT	0x00000400
-#endif
-#ifndef IO_REPARSE_TAG_SYMLINK
-# define IO_REPARSE_TAG_SYMLINK		0xA000000C
-#endif
-
 /* Record all output and all keyboard & mouse input */
 /* #define MCH_WRITE_DUMP */
 
@@ -242,6 +232,94 @@
 
 static char_u *exe_path = NULL;
 
+static BOOL win8_or_later = FALSE;
+
+/*
+ * Version of ReadConsoleInput() that works with IME.
+ * Works around problems on Windows 8.
+ */
+    static BOOL
+read_console_input(
+    HANDLE	    hInput,
+    INPUT_RECORD    *lpBuffer,
+    DWORD	    nLength,
+    LPDWORD	    lpEvents)
+{
+    enum
+    {
+	IRSIZE = 10
+    };
+    static INPUT_RECORD s_irCache[IRSIZE];
+    static DWORD s_dwIndex = 0;
+    static DWORD s_dwMax = 0;
+    DWORD dwEvents;
+    int head;
+    int tail;
+    int i;
+
+    if (!win8_or_later)
+    {
+	if (nLength == -1)
+	    return PeekConsoleInput(hInput, lpBuffer, 1, lpEvents);
+	return ReadConsoleInput(hInput, lpBuffer, 1, &dwEvents);
+    }
+
+    if (s_dwMax == 0)
+    {
+	if (nLength == -1)
+	    return PeekConsoleInput(hInput, lpBuffer, 1, lpEvents);
+	if (!ReadConsoleInput(hInput, s_irCache, IRSIZE, &dwEvents))
+	    return FALSE;
+	s_dwIndex = 0;
+	s_dwMax = dwEvents;
+	if (dwEvents == 0)
+	{
+	    *lpEvents = 0;
+	    return TRUE;
+	}
+
+	if (s_dwMax > 1)
+	{
+	    head = 0;
+	    tail = s_dwMax - 1;
+	    while (head != tail)
+	    {
+		if (s_irCache[head].EventType == WINDOW_BUFFER_SIZE_EVENT
+			&& s_irCache[head + 1].EventType
+						  == WINDOW_BUFFER_SIZE_EVENT)
+		{
+		    /* Remove duplicate event to avoid flicker. */
+		    for (i = head; i < tail; ++i)
+			s_irCache[i] = s_irCache[i + 1];
+		    --tail;
+		    continue;
+		}
+		head++;
+	    }
+	    s_dwMax = tail + 1;
+	}
+    }
+
+    *lpBuffer = s_irCache[s_dwIndex];
+    if (nLength != -1 && ++s_dwIndex >= s_dwMax)
+	s_dwMax = 0;
+    *lpEvents = 1;
+    return TRUE;
+}
+
+/*
+ * Version of PeekConsoleInput() that works with IME.
+ */
+    static BOOL
+peek_console_input(
+    HANDLE	    hInput,
+    INPUT_RECORD    *lpBuffer,
+    DWORD	    nLength,
+    LPDWORD	    lpEvents)
+{
+    return read_console_input(hInput, lpBuffer, -1, lpEvents);
+}
+
     static void
 get_exe_name(void)
 {
@@ -526,10 +604,10 @@
     static BOOL
 win32_enable_privilege(LPTSTR lpszPrivilege, BOOL bEnable)
 {
-    BOOL             bResult;
-    LUID             luid;
-    HANDLE           hToken;
-    TOKEN_PRIVILEGES tokenPrivileges;
+    BOOL		bResult;
+    LUID		luid;
+    HANDLE		hToken;
+    TOKEN_PRIVILEGES	tokenPrivileges;
 
     if (!OpenProcessToken(GetCurrentProcess(),
 		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
@@ -541,7 +619,7 @@
 	return FALSE;
     }
 
-    tokenPrivileges.PrivilegeCount           = 1;
+    tokenPrivileges.PrivilegeCount	     = 1;
     tokenPrivileges.Privileges[0].Luid       = luid;
     tokenPrivileges.Privileges[0].Attributes = bEnable ?
 						    SE_PRIVILEGE_ENABLED : 0;
@@ -573,6 +651,10 @@
 
 	g_PlatformId = ovi.dwPlatformId;
 
+	if ((ovi.dwMajorVersion == 6 && ovi.dwMinorVersion >= 2)
+		|| ovi.dwMajorVersion > 6)
+	    win8_or_later = TRUE;
+
 #ifdef HAVE_ACL
 	/*
 	 * Load the ADVAPI runtime if we are on anything
@@ -1127,7 +1209,7 @@
 			INPUT_RECORD ir;
 			MOUSE_EVENT_RECORD* pmer2 = &ir.Event.MouseEvent;
 
-			PeekConsoleInput(g_hConIn, &ir, 1, &cRecords);
+			peek_console_input(g_hConIn, &ir, 1, &cRecords);
 
 			if (cRecords == 0 || ir.EventType != MOUSE_EVENT
 				|| !(pmer2->dwButtonState & LEFT_RIGHT))
@@ -1136,7 +1218,7 @@
 			{
 			    if (pmer2->dwEventFlags != MOUSE_MOVED)
 			    {
-				ReadConsoleInput(g_hConIn, &ir, 1, &cRecords);
+				read_console_input(g_hConIn, &ir, 1, &cRecords);
 
 				return decode_mouse_event(pmer2);
 			    }
@@ -1144,10 +1226,10 @@
 				     s_yOldMouse == pmer2->dwMousePosition.Y)
 			    {
 				/* throw away spurious mouse move */
-				ReadConsoleInput(g_hConIn, &ir, 1, &cRecords);
+				read_console_input(g_hConIn, &ir, 1, &cRecords);
 
 				/* are there any more mouse events in queue? */
-				PeekConsoleInput(g_hConIn, &ir, 1, &cRecords);
+				peek_console_input(g_hConIn, &ir, 1, &cRecords);
 
 				if (cRecords==0 || ir.EventType != MOUSE_EVENT)
 				    break;
@@ -1384,7 +1466,7 @@
 	}
 
 	cRecords = 0;
-	PeekConsoleInput(g_hConIn, &ir, 1, &cRecords);
+	peek_console_input(g_hConIn, &ir, 1, &cRecords);
 
 #ifdef FEAT_MBYTE_IME
 	if (State & CMDLINE && msg_row == Rows - 1)
@@ -1415,7 +1497,7 @@
 		if (ir.Event.KeyEvent.uChar.UnicodeChar == 0
 			&& ir.Event.KeyEvent.wVirtualKeyCode == 13)
 		{
-		    ReadConsoleInput(g_hConIn, &ir, 1, &cRecords);
+		    read_console_input(g_hConIn, &ir, 1, &cRecords);
 		    continue;
 		}
 #endif
@@ -1424,7 +1506,7 @@
 		    return TRUE;
 	    }
 
-	    ReadConsoleInput(g_hConIn, &ir, 1, &cRecords);
+	    read_console_input(g_hConIn, &ir, 1, &cRecords);
 
 	    if (ir.EventType == FOCUS_EVENT)
 		handle_focus_event(ir);
@@ -1494,7 +1576,7 @@
 	    return 0;
 # endif
 #endif
-	if (ReadConsoleInput(g_hConIn, &ir, 1, &cRecords) == 0)
+	if (read_console_input(g_hConIn, &ir, 1, &cRecords) == 0)
 	{
 	    if (did_create_conin)
 		read_error_exit();
@@ -1703,13 +1785,14 @@
 #endif
 	    {
 		int	n = 1;
+		int     conv = FALSE;
 
-		/* A key may have one or two bytes. */
 		typeahead[typeaheadlen] = c;
 		if (ch2 != NUL)
 		{
-		    typeahead[typeaheadlen + 1] = ch2;
-		    ++n;
+		    typeahead[typeaheadlen + 1] = 3;
+		    typeahead[typeaheadlen + 2] = ch2;
+		    n += 2;
 		}
 #ifdef FEAT_MBYTE
 		/* Only convert normal characters, not special keys.  Need to
@@ -1718,6 +1801,7 @@
 		if (input_conv.vc_type != CONV_NONE
 						&& (ch2 == NUL || c != K_NUL))
 		{
+		    conv = TRUE;
 		    typeaheadlen -= unconverted;
 		    n = convert_input_safe(typeahead + typeaheadlen,
 				n + unconverted, TYPEAHEADLEN - typeaheadlen,
@@ -1725,6 +1809,24 @@
 		}
 #endif
 
+		if (conv)
+		{
+		    char_u *p = typeahead + typeaheadlen;
+		    char_u *e = typeahead + TYPEAHEADLEN;
+
+		    while (*p && p < e)
+		    {
+			if (*p == K_NUL)
+			{
+			    ++p;
+			    mch_memmove(p + 1, p, ((size_t)(e - p)) - 1);
+			    *p = 3;
+			    ++n;
+			}
+			++p;
+		    }
+		}
+
 		/* Use the ALT key to set the 8th bit of the character
 		 * when it's one byte, the 8th bit isn't set yet and not
 		 * using a double-byte encoding (would become a lead
@@ -1800,10 +1902,12 @@
  * TODO: Should somehow check if it's really executable.
  */
     static int
-executable_exists(char *name)
+executable_exists(char *name, char_u **path)
 {
     char	*dum;
     char	fname[_MAX_PATH];
+    char	*curpath, *newpath;
+    long	n;
 
 #ifdef FEAT_MBYTE
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
@@ -1811,11 +1915,19 @@
 	WCHAR	*p = enc_to_utf16(name, NULL);
 	WCHAR	fnamew[_MAX_PATH];
 	WCHAR	*dumw;
-	long	n;
+	WCHAR	*wcurpath, *wnewpath;
 
 	if (p != NULL)
 	{
-	    n = (long)SearchPathW(NULL, p, NULL, _MAX_PATH, fnamew, &dumw);
+	    wcurpath = _wgetenv(L"PATH");
+	    wnewpath = (WCHAR*)alloc((unsigned)(wcslen(wcurpath) + 3)
+							    * sizeof(WCHAR));
+	    if (wnewpath == NULL)
+		return FALSE;
+	    wcscpy(wnewpath, L".;");
+	    wcscat(wnewpath, wcurpath);
+	    n = (long)SearchPathW(wnewpath, p, NULL, _MAX_PATH, fnamew, &dumw);
+	    vim_free(wnewpath);
 	    vim_free(p);
 	    if (n > 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
 	    {
@@ -1823,16 +1935,29 @@
 		    return FALSE;
 		if (GetFileAttributesW(fnamew) & FILE_ATTRIBUTE_DIRECTORY)
 		    return FALSE;
+		if (path != NULL)
+		    *path = utf16_to_enc(fnamew, NULL);
 		return TRUE;
 	    }
 	    /* Retry with non-wide function (for Windows 98). */
 	}
     }
 #endif
-    if (SearchPath(NULL, name, NULL, _MAX_PATH, fname, &dum) == 0)
+
+    curpath = getenv("PATH");
+    newpath = (char*)alloc((unsigned)(STRLEN(curpath) + 3));
+    if (newpath == NULL)
+	return FALSE;
+    STRCPY(newpath, ".;");
+    STRCAT(newpath, curpath);
+    n = (long)SearchPath(newpath, name, NULL, _MAX_PATH, fname, &dum);
+    vim_free(newpath);
+    if (n == 0)
 	return FALSE;
     if (mch_isdir(fname))
 	return FALSE;
+    if (path != NULL)
+	*path = vim_strsave(fname);
     return TRUE;
 }
 
@@ -1914,7 +2039,7 @@
 	    vimrun_path = (char *)vim_strsave(vimrun_location);
 	    s_dont_use_vimrun = FALSE;
 	}
-	else if (executable_exists("vimrun.exe"))
+	else if (executable_exists("vimrun.exe", NULL))
 	    s_dont_use_vimrun = FALSE;
 
 	/* Don't give the warning for a missing vimrun.exe right now, but only
@@ -1928,7 +2053,7 @@
      * If "finstr.exe" doesn't exist, use "grep -n" for 'grepprg'.
      * Otherwise the default "findstr /n" is used.
      */
-    if (!executable_exists("findstr.exe"))
+    if (!executable_exists("findstr.exe", NULL))
 	set_option_value((char_u *)"grepprg", 0, (char_u *)"grep -n", 0);
 
 #ifdef FEAT_CLIPBOARD
@@ -2321,7 +2446,8 @@
 	return;
 
     /* Extract the first icon contained in the Vim executable. */
-    g_hVimIcon = ExtractIcon(NULL, exe_name, 0);
+    if (mch_icon_load((HANDLE *)&g_hVimIcon) == FAIL || g_hVimIcon == NULL)
+	g_hVimIcon = ExtractIcon(NULL, exe_name, 0);
     if (g_hVimIcon != NULL)
 	g_fCanChangeIcon = TRUE;
 }
@@ -2500,9 +2626,125 @@
 }
 
 
+#ifdef FEAT_MBYTE
+/*
+ * fname_casew(): Wide version of fname_case().  Set the case of the file name,
+ * if it already exists.  When "len" is > 0, also expand short to long
+ * filenames.
+ * Return FAIL if wide functions are not available, OK otherwise.
+ * NOTE: much of this is identical to fname_case(), keep in sync!
+ */
+    static int
+fname_casew(
+    WCHAR	*name,
+    int		len)
+{
+    WCHAR		szTrueName[_MAX_PATH + 2];
+    WCHAR		szTrueNameTemp[_MAX_PATH + 2];
+    WCHAR		*ptrue, *ptruePrev;
+    WCHAR		*porig, *porigPrev;
+    int			flen;
+    WIN32_FIND_DATAW	fb;
+    HANDLE		hFind = INVALID_HANDLE_VALUE;
+    int			c;
+    int			slen;
+
+    flen = (int)wcslen(name);
+    if (flen > _MAX_PATH)
+	return OK;
+
+    /* slash_adjust(name) not needed, already adjusted by fname_case(). */
+
+    /* Build the new name in szTrueName[] one component at a time. */
+    porig = name;
+    ptrue = szTrueName;
+
+    if (iswalpha(porig[0]) && porig[1] == L':')
+    {
+	/* copy leading drive letter */
+	*ptrue++ = *porig++;
+	*ptrue++ = *porig++;
+    }
+    *ptrue = NUL;	    /* in case nothing follows */
+
+    while (*porig != NUL)
+    {
+	/* copy \ characters */
+	while (*porig == psepc)
+	    *ptrue++ = *porig++;
+
+	ptruePrev = ptrue;
+	porigPrev = porig;
+	while (*porig != NUL && *porig != psepc)
+	{
+	    *ptrue++ = *porig++;
+	}
+	*ptrue = NUL;
+
+	/* To avoid a slow failure append "\*" when searching a directory,
+	 * server or network share. */
+	wcscpy(szTrueNameTemp, szTrueName);
+	slen = (int)wcslen(szTrueNameTemp);
+	if (*porig == psepc && slen + 2 < _MAX_PATH)
+	    wcscpy(szTrueNameTemp + slen, L"\\*");
+
+	/* Skip "", "." and "..". */
+	if (ptrue > ptruePrev
+		&& (ptruePrev[0] != L'.'
+		    || (ptruePrev[1] != NUL
+			&& (ptruePrev[1] != L'.' || ptruePrev[2] != NUL)))
+		&& (hFind = FindFirstFileW(szTrueNameTemp, &fb))
+						      != INVALID_HANDLE_VALUE)
+	{
+	    c = *porig;
+	    *porig = NUL;
+
+	    /* Only use the match when it's the same name (ignoring case) or
+	     * expansion is allowed and there is a match with the short name
+	     * and there is enough room. */
+	    if (_wcsicoll(porigPrev, fb.cFileName) == 0
+		    || (len > 0
+			&& (_wcsicoll(porigPrev, fb.cAlternateFileName) == 0
+			    && (int)(ptruePrev - szTrueName)
+					   + (int)wcslen(fb.cFileName) < len)))
+	    {
+		wcscpy(ptruePrev, fb.cFileName);
+
+		/* Look for exact match and prefer it if found.  Must be a
+		 * long name, otherwise there would be only one match. */
+		while (FindNextFileW(hFind, &fb))
+		{
+		    if (*fb.cAlternateFileName != NUL
+			    && (wcscoll(porigPrev, fb.cFileName) == 0
+				|| (len > 0
+				    && (_wcsicoll(porigPrev,
+						   fb.cAlternateFileName) == 0
+				    && (int)(ptruePrev - szTrueName)
+					 + (int)wcslen(fb.cFileName) < len))))
+		    {
+			wcscpy(ptruePrev, fb.cFileName);
+			break;
+		    }
+		}
+	    }
+	    FindClose(hFind);
+	    *porig = c;
+	    ptrue = ptruePrev + wcslen(ptruePrev);
+	}
+	else if (hFind == INVALID_HANDLE_VALUE
+		&& GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
+	    return FAIL;
+    }
+
+    wcscpy(name, szTrueName);
+    return OK;
+}
+#endif
+
 /*
  * fname_case(): Set the case of the file name, if it already exists.
  * When "len" is > 0, also expand short to long filenames.
+ * NOTE: much of this is identical to fname_casew(), keep in sync!
  */
     void
 fname_case(
@@ -2520,11 +2762,45 @@
     int			slen;
 
     flen = (int)STRLEN(name);
-    if (flen == 0 || flen > _MAX_PATH)
+    if (flen == 0)
 	return;
 
     slash_adjust(name);
 
+#ifdef FEAT_MBYTE
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	WCHAR	*p = enc_to_utf16(name, NULL);
+
+	if (p != NULL)
+	{
+	    char_u	*q;
+	    WCHAR	buf[_MAX_PATH + 1];
+
+	    wcsncpy(buf, p, _MAX_PATH);
+	    buf[_MAX_PATH] = L'\0';
+	    vim_free(p);
+
+	    if (fname_casew(buf, (len > 0) ? _MAX_PATH : 0) == OK)
+	    {
+		q = utf16_to_enc(buf, NULL);
+		if (q != NULL)
+		{
+		    vim_strncpy(name, q, (len > 0) ? len - 1 : flen);
+		    vim_free(q);
+		    return;
+		}
+	    }
+	}
+	/* Retry with non-wide function (for Windows 98). */
+    }
+#endif
+
+    /* If 'enc' is utf-8, flen can be larger than _MAX_PATH.
+     * So we should check this after calling wide function. */
+    if (flen > _MAX_PATH)
+	return;
+
     /* Build the new name in szTrueName[] one component at a time. */
     porig = name;
     ptrue = szTrueName;
@@ -2534,8 +2810,8 @@
 	/* copy leading drive letter */
 	*ptrue++ = *porig++;
 	*ptrue++ = *porig++;
-	*ptrue = NUL;	    /* in case nothing follows */
     }
+    *ptrue = NUL;	    /* in case nothing follows */
 
     while (*porig != NUL)
     {
@@ -2629,6 +2905,28 @@
     char szUserName[256 + 1];	/* UNLEN is 256 */
     DWORD cch = sizeof szUserName;
 
+#ifdef FEAT_MBYTE
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	WCHAR wszUserName[256 + 1];	/* UNLEN is 256 */
+	DWORD wcch = sizeof(wszUserName) / sizeof(WCHAR);
+
+	if (GetUserNameW(wszUserName, &wcch))
+	{
+	    char_u  *p = utf16_to_enc(wszUserName, NULL);
+
+	    if (p != NULL)
+	    {
+		vim_strncpy(s, p, len - 1);
+		vim_free(p);
+		return OK;
+	    }
+	}
+	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+	    return FAIL;
+	/* Retry with non-wide function (for Windows 98). */
+    }
+#endif
     if (GetUserName(szUserName, &cch))
     {
 	vim_strncpy(s, szUserName, len - 1);
@@ -2649,6 +2947,28 @@
 {
     DWORD cch = len;
 
+#ifdef FEAT_MBYTE
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	WCHAR wszHostName[256 + 1];
+	DWORD wcch = sizeof(wszHostName) / sizeof(WCHAR);
+
+	if (GetComputerNameW(wszHostName, &wcch))
+	{
+	    char_u  *p = utf16_to_enc(wszHostName, NULL);
+
+	    if (p != NULL)
+	    {
+		vim_strncpy(s, p, len - 1);
+		vim_free(p);
+		return;
+	    }
+	}
+	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+	    return;
+	/* Retry with non-wide function (for Windows 98). */
+    }
+#endif
     if (!GetComputerName(s, &cch))
 	vim_strncpy(s, "PC (Win32 Vim)", len - 1);
 }
@@ -2695,6 +3015,8 @@
 		return OK;
 	    }
 	}
+	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+	    return FAIL;
 	/* Retry with non-wide function (for Windows 98). */
     }
 #endif
@@ -2702,18 +3024,17 @@
 }
 
 /*
- * get file permissions for `name'
- * -1 : error
- * else mode_t
+ * Get file permissions for "name".
+ * Return mode_t or -1 for error.
  */
     long
 mch_getperm(char_u *name)
 {
     struct stat st;
-    int n;
+    int		n;
 
     n = mch_stat(name, &st);
-    return n == 0 ? (int)st.st_mode : -1;
+    return n == 0 ? (long)(unsigned short)st.st_mode : -1L;
 }
 
 
@@ -2736,7 +3057,7 @@
 	{
 	    n = _wchmod(p, perm);
 	    vim_free(p);
-	    if (n == -1 && GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+	    if (n == -1 && g_PlatformId == VER_PLATFORM_WIN32_NT)
 		return FAIL;
 	    /* Retry with non-wide function (for Windows 98). */
 	}
@@ -2955,8 +3276,7 @@
  * -1 : error
  * else FILE_ATTRIBUTE_* defined in winnt.h
  */
-    static
-    int
+    static int
 win32_getattrs(char_u *name)
 {
     int		attr;
@@ -3055,7 +3375,7 @@
  * Return -1 if unknown.
  */
     int
-mch_can_exe(char_u *name)
+mch_can_exe(char_u *name, char_u **path)
 {
     char_u	buf[_MAX_PATH];
     int		len = (int)STRLEN(name);
@@ -3068,7 +3388,7 @@
      * this with a Unix-shell like 'shell'. */
     if (vim_strchr(gettail(name), '.') != NULL
 			       || strstr((char *)gettail(p_sh), "sh") != NULL)
-	if (executable_exists((char *)name))
+	if (executable_exists((char *)name, path))
 	    return TRUE;
 
     /*
@@ -3090,7 +3410,7 @@
 	}
 	else
 	    copy_option_part(&p, buf + len, _MAX_PATH - len, ";");
-	if (executable_exists((char *)buf))
+	if (executable_exists((char *)buf, path))
 	    return TRUE;
     }
     return FALSE;
@@ -3107,6 +3427,9 @@
 {
     HANDLE	hFile;
     int		type;
+#ifdef FEAT_MBYTE
+    WCHAR	*wn = NULL;
+#endif
 
     /* We can't open a file with a name "\\.\con" or "\\.\prn" and trying to
      * read from it later will cause Vim to hang.  Thus return NODE_WRITABLE
@@ -3114,14 +3437,41 @@
     if (STRNCMP(name, "\\\\.\\", 4) == 0)
 	return NODE_WRITABLE;
 
-    hFile = CreateFile(name,		/* file name */
-		GENERIC_WRITE,		/* access mode */
-		0,			/* share mode */
-		NULL,			/* security descriptor */
-		OPEN_EXISTING,		/* creation disposition */
-		0,			/* file attributes */
-		NULL);			/* handle to template file */
+#ifdef FEAT_MBYTE
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	wn = enc_to_utf16(name, NULL);
+	if (wn != NULL)
+	{
+	    hFile = CreateFileW(wn,	/* file name */
+			GENERIC_WRITE,	/* access mode */
+			0,		/* share mode */
+			NULL,		/* security descriptor */
+			OPEN_EXISTING,	/* creation disposition */
+			0,		/* file attributes */
+			NULL);		/* handle to template file */
+	    if (hFile == INVALID_HANDLE_VALUE
+			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
+	    {
+		/* Retry with non-wide function (for Windows 98). */
+		vim_free(wn);
+		wn = NULL;
+	    }
+	}
+    }
+    if (wn == NULL)
+#endif
+	hFile = CreateFile(name,	/* file name */
+		    GENERIC_WRITE,	/* access mode */
+		    0,			/* share mode */
+		    NULL,		/* security descriptor */
+		    OPEN_EXISTING,	/* creation disposition */
+		    0,			/* file attributes */
+		    NULL);		/* handle to template file */
 
+#ifdef FEAT_MBYTE
+    vim_free(wn);
+#endif
     if (hFile == INVALID_HANDLE_VALUE)
 	return NODE_NORMAL;
 
@@ -3618,6 +3968,50 @@
 }
 #endif /* FEAT_GUI_W32 */
 
+    static BOOL
+vim_create_process(
+    char		*cmd,
+    BOOL		inherit_handles,
+    DWORD		flags,
+    STARTUPINFO		*si,
+    PROCESS_INFORMATION *pi)
+{
+#  ifdef FEAT_MBYTE
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	WCHAR	*wcmd = enc_to_utf16(cmd, NULL);
+
+	if (wcmd != NULL)
+	{
+	    BOOL ret;
+	    ret = CreateProcessW(
+		NULL,			/* Executable name */
+		wcmd,			/* Command to execute */
+		NULL,			/* Process security attributes */
+		NULL,			/* Thread security attributes */
+		inherit_handles,	/* Inherit handles */
+		flags,			/* Creation flags */
+		NULL,			/* Environment */
+		NULL,			/* Current directory */
+		(LPSTARTUPINFOW)si,	/* Startup information */
+		pi);			/* Process information */
+	    vim_free(wcmd);
+	    return ret;
+	}
+    }
+#endif
+    return CreateProcess(
+	NULL,			/* Executable name */
+	cmd,			/* Command to execute */
+	NULL,			/* Process security attributes */
+	NULL,			/* Thread security attributes */
+	inherit_handles,	/* Inherit handles */
+	flags,			/* Creation flags */
+	NULL,			/* Environment */
+	NULL,			/* Current directory */
+	si,			/* Startup information */
+	pi);			/* Process information */
+}
 
 
 #if defined(FEAT_GUI_W32) || defined(PROTO)
@@ -3664,18 +4058,8 @@
 	cmd += 3;
 
     /* Now, run the command */
-    CreateProcess(NULL,			/* Executable name */
-		  cmd,			/* Command to execute */
-		  NULL,			/* Process security attributes */
-		  NULL,			/* Thread security attributes */
-		  FALSE,		/* Inherit handles */
-		  CREATE_DEFAULT_ERROR_MODE |	/* Creation flags */
-			CREATE_NEW_CONSOLE,
-		  NULL,			/* Environment */
-		  NULL,			/* Current directory */
-		  &si,			/* Startup information */
-		  &pi);			/* Process information */
-
+    vim_create_process(cmd, FALSE,
+	    CREATE_DEFAULT_ERROR_MODE |	CREATE_NEW_CONSOLE, &si, &pi);
 
     /* Wait for the command to terminate before continuing */
     if (g_PlatformId != VER_PLATFORM_WIN32s)
@@ -4007,22 +4391,11 @@
 	    p = cmd;
     }
 
-    /* Now, run the command */
-    CreateProcess(NULL,			/* Executable name */
-		  p,			/* Command to execute */
-		  NULL,			/* Process security attributes */
-		  NULL,			/* Thread security attributes */
-
-		  // this command can be litigious, handle inheritance was
-		  // deactivated for pending temp file, but, if we deactivate
-		  // it, the pipes don't work for some reason.
-		  TRUE,			/* Inherit handles, first deactivated,
-					 * but needed */
-		  CREATE_DEFAULT_ERROR_MODE, /* Creation flags */
-		  NULL,			/* Environment */
-		  NULL,			/* Current directory */
-		  &si,			/* Startup information */
-		  &pi);			/* Process information */
+    /* Now, run the command.
+     * About "Inherit handles" being TRUE: this command can be litigious,
+     * handle inheritance was deactivated for pending temp file, but, if we
+     * deactivate it, the pipes don't work for some reason. */
+     vim_create_process(p, TRUE, CREATE_DEFAULT_ERROR_MODE, &si, &pi);
 
     if (p != cmd)
 	vim_free(p);
@@ -4049,10 +4422,10 @@
     {
 	MSG	msg;
 
-	if (PeekMessage(&msg, (HWND)NULL, 0, 0, PM_REMOVE))
+	if (pPeekMessage(&msg, (HWND)NULL, 0, 0, PM_REMOVE))
 	{
 	    TranslateMessage(&msg);
-	    DispatchMessage(&msg);
+	    pDispatchMessage(&msg);
 	}
 
 	/* write pipe information in the window */
@@ -4240,7 +4613,25 @@
 }
 #else
 
-# define mch_system(c, o) system(c)
+# ifdef FEAT_MBYTE
+    static int
+mch_system(char *cmd, int options)
+{
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	WCHAR	*wcmd = enc_to_utf16(cmd, NULL);
+	if (wcmd != NULL)
+	{
+	    int ret = _wsystem(wcmd);
+	    vim_free(wcmd);
+	    return ret;
+	}
+    }
+    return system(cmd);
+}
+# else
+#  define mch_system(c, o) system(c)
+# endif
 
 #endif
 
@@ -4325,6 +4716,7 @@
 	    DWORD		flags = CREATE_NEW_CONSOLE;
 	    char_u		*p;
 
+	    ZeroMemory(&si, sizeof(si));
 	    si.cb = sizeof(si);
 	    si.lpReserved = NULL;
 	    si.lpDesktop = NULL;
@@ -4408,16 +4800,7 @@
 	     * inherit our handles which causes unpleasant dangling swap
 	     * files if we exit before the spawned process
 	     */
-	    if (CreateProcess(NULL,		// Executable name
-		    newcmd,			// Command to execute
-		    NULL,			// Process security attributes
-		    NULL,			// Thread security attributes
-		    FALSE,			// Inherit handles
-		    flags,			// Creation flags
-		    NULL,			// Environment
-		    NULL,			// Current directory
-		    &si,			// Startup information
-		    &pi))			// Process information
+	    if (vim_create_process(newcmd, FALSE, flags, &si, &pi))
 		x = 0;
 	    else
 	    {
@@ -4430,9 +4813,9 @@
 	    if (newcmd != cmdbase)
 		vim_free(newcmd);
 
-	    if (si.hStdInput != NULL)
+	    if (si.dwFlags == STARTF_USESTDHANDLES && si.hStdInput != NULL)
 	    {
-		/* Close the handle to \\.\NUL */
+		/* Close the handle to \\.\NUL created above. */
 		CloseHandle(si.hStdInput);
 	    }
 	    /* Close the handles to the subprocess, so that it goes away */
@@ -5716,7 +6099,7 @@
 	{
 	    f = _wopen(wn, flags, mode);
 	    vim_free(wn);
-	    if (f >= 0)
+	    if (f >= 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
 		return f;
 	    /* Retry with non-wide function (for Windows 98). Can't use
 	     * GetLastError() here and it's unclear what errno gets set to if
@@ -5767,7 +6150,7 @@
 	_set_fmode(oldMode);
 # endif
 
-	if (f != NULL)
+	if (f != NULL || g_PlatformId == VER_PLATFORM_WIN32_NT)
 	    return f;
 	/* Retry with non-wide function (for Windows 98). Can't use
 	 * GetLastError() here and it's unclear what errno gets set to if
@@ -6080,6 +6463,7 @@
     int		argc = 0;
     int		i;
 
+    free_cmd_argsW();
     ArglistW = CommandLineToArgvW(GetCommandLineW(), &nArgsW);
     if (ArglistW != NULL)
     {
@@ -6102,6 +6486,7 @@
 		    while (i > 0)
 			free(argv[--i]);
 		    free(argv);
+		    argv = NULL;
 		    argc = 0;
 		}
 	    }
@@ -6111,7 +6496,11 @@
     global_argc = argc;
     global_argv = argv;
     if (argc > 0)
+    {
+	if (used_file_indexes != NULL)
+	    free(used_file_indexes);
 	used_file_indexes = malloc(argc * sizeof(int));
+    }
 
     if (argvp != NULL)
 	*argvp = argv;
diff -Naur vim74.orig/src/os_win32.h vim74/src/os_win32.h
--- vim74.orig/src/os_win32.h	2013-07-21 15:53:13.000000000 +0000
+++ vim74/src/os_win32.h	2014-10-10 14:53:44.812046041 +0000
@@ -68,7 +68,7 @@
 #endif
 
 #define USE_FNAME_CASE		/* adjust case of file names */
-#if !defined(FEAT_CLIPBOARD) && defined(FEAT_VISUAL) && defined(FEAT_MOUSE)
+#if !defined(FEAT_CLIPBOARD) && defined(FEAT_MOUSE)
 # define FEAT_CLIPBOARD		/* include clipboard support */
 #endif
 #if defined(__DATE__) && defined(__TIME__)
@@ -130,6 +130,19 @@
 # define DFLT_MAXMEMTOT	(5*1024)    /* use up to 5 Mbyte for Vim */
 #endif
 
+/*
+ * Reparse Point
+ */
+#ifndef FILE_ATTRIBUTE_REPARSE_POINT
+# define FILE_ATTRIBUTE_REPARSE_POINT	0x00000400
+#endif
+#ifndef IO_REPARSE_TAG_MOUNT_POINT
+# define IO_REPARSE_TAG_MOUNT_POINT	0xA0000003
+#endif
+#ifndef IO_REPARSE_TAG_SYMLINK
+# define IO_REPARSE_TAG_SYMLINK		0xA000000C
+#endif
+
 #if defined(_MSC_VER) || defined(__BORLANDC__)
     /* Support for __try / __except.  All versions of MSVC and Borland C are
      * expected to have this.  Any other compilers that support it? */
diff -Naur vim74.orig/src/osdef.sh vim74/src/osdef.sh
--- vim74.orig/src/osdef.sh	2010-05-15 11:04:08.000000000 +0000
+++ vim74/src/osdef.sh	2014-10-10 14:53:44.812046041 +0000
@@ -47,11 +47,7 @@
 #endif
 EOF
 
-# Mac uses precompiled headers, but we need real headers here.
-case `uname` in
-    Darwin)	$CC -I. -I$srcdir -E -no-cpp-precomp osdef0.c >osdef0.cc;;
-    *)		$CC -I. -I$srcdir -E osdef0.c >osdef0.cc;;
-esac
+$CC -I. -I$srcdir -E osdef0.c >osdef0.cc
 
 # insert a space in front of each line, so that a function name at the
 # start of the line is matched with "[)*, 	]\1[ 	(]"
diff -Naur vim74.orig/src/po/Makefile vim74/src/po/Makefile
--- vim74.orig/src/po/Makefile	2013-06-23 11:26:12.000000000 +0000
+++ vim74/src/po/Makefile	2014-10-10 14:53:44.825379341 +0000
@@ -1,5 +1,8 @@
 # Makefile for the Vim message translations.
 
+# Include stuff found by configure.
+include ../auto/config.mk
+
 # TODO make this configurable
 # Note: ja.sjis, *.cp1250 and zh_CN.cp936 are only for MS-Windows, they are
 # not installed on Unix
@@ -133,7 +136,7 @@
 # tools 0.10.37, which use a slightly different .po file format that is not
 # compatible with Solaris (and old gettext implementations) unless these are
 # set.  gettext 0.10.36 will not work!
-MSGFMT = OLD_PO_FILE_INPUT=yes msgfmt -v
+MSGFMTCMD = OLD_PO_FILE_INPUT=yes $(MSGFMT) -v
 XGETTEXT = OLD_PO_FILE_INPUT=yes OLD_PO_FILE_OUTPUT=yes xgettext
 MSGMERGE = OLD_PO_FILE_INPUT=yes OLD_PO_FILE_OUTPUT=yes msgmerge
 
@@ -142,7 +145,7 @@
 .PHONY: all install uninstall prefixcheck converted check clean checkclean distclean update-po $(LANGUAGES) $(CONVERTED)
 
 .po.mo:
-	$(MSGFMT) -o $@ $<
+	$(MSGFMTCMD) -o $@ $<
 
 .po.ck:
 	$(VIM) -u NONE -e -X -S check.vim -c "if error == 0 | q | endif" -c cq $<
diff -Naur vim74.orig/src/po/ca.po vim74/src/po/ca.po
--- vim74.orig/src/po/ca.po	2012-01-18 18:40:35.000000000 +0000
+++ vim74/src/po/ca.po	2014-10-10 14:53:44.842045966 +0000
@@ -448,7 +448,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Una llista noms es pot comparar amb una llista"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Operaci no vlida en llistes"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/de.po vim74/src/po/de.po
--- vim74.orig/src/po/de.po	2013-01-23 12:04:20.000000000 +0000
+++ vim74/src/po/de.po	2014-10-10 14:53:44.862045916 +0000
@@ -426,7 +426,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Kann nur eine Liste mit einer Liste vergleichen"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Unzulssige Operation fr Listen"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/eo.po vim74/src/po/eo.po
--- vim74.orig/src/po/eo.po	2013-05-27 18:40:27.000000000 +0000
+++ vim74/src/po/eo.po	2014-10-10 14:53:44.878712540 +0000
@@ -23,8 +23,8 @@
 msgstr ""
 "Project-Id-Version: Vim(Esperanto)\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2013-05-27 04:50+0200\n"
-"PO-Revision-Date: 2013-05-27 04:55+0200\n"
+"POT-Creation-Date: 2014-03-21 23:15+0100\n"
+"PO-Revision-Date: 2014-03-21 23:16+0100\n"
 "Last-Translator: Dominique PELL <dominique.pelle@gmail.com>\n"
 "Language-Team: \n"
 "Language: eo\n"
@@ -93,6 +93,9 @@
 msgid "%d buffers wiped out"
 msgstr "%d bufroj detruitaj"
 
+msgid "E90: Cannot unload last buffer"
+msgstr "E90: Ne eblas malargi la lastan bufron"
+
 msgid "E84: No modified buffer found"
 msgstr "E84: Neniu modifita bufro trovita"
 
@@ -116,9 +119,6 @@
 "E89: Neniu skribo de post la lasta ano de la bufro %ld (aldonu ! por "
 "transpasi)"
 
-msgid "E90: Cannot unload last buffer"
-msgstr "E90: Ne eblas malargi la lastan bufron"
-
 msgid "W14: Warning: List of file names overflow"
 msgstr "W14: Averto: Listo de dosiernomoj troas"
 
@@ -153,6 +153,9 @@
 msgid "[Read errors]"
 msgstr "[Eraroj de legado]"
 
+msgid "[RO]"
+msgstr "[Nurlegebla]"
+
 msgid "[readonly]"
 msgstr "[nurlegebla]"
 
@@ -437,6 +440,9 @@
 msgid "E461: Illegal variable name: %s"
 msgstr "E461: Nevalida nomo de variablo: %s"
 
+msgid "E806: using Float as a String"
+msgstr "E806: uzo de Glitpunktnombro kiel eno"
+
 msgid "E687: Less targets than List items"
 msgstr "E687: Malpli da celoj ol Listeroj"
 
@@ -485,7 +491,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Eblas nur kompari Liston kun Listo"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Nevalida operacio de Listoj"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
@@ -596,13 +602,13 @@
 msgid "&Ok"
 msgstr "&Bone"
 
-msgid "extend() argument"
-msgstr "argumento de extend()"
-
 #, c-format
 msgid "E737: Key already exists: %s"
 msgstr "E737: losilo jam ekzistas: %s"
 
+msgid "extend() argument"
+msgstr "argumento de extend()"
+
 msgid "map() argument"
 msgstr "argumento de map()"
 
@@ -700,9 +706,6 @@
 msgid "E731: using Dictionary as a String"
 msgstr "E731: uzo de Vortaro kiel eno"
 
-msgid "E806: using Float as a String"
-msgstr "E806: uzo de Glitpunktnombro kiel eno"
-
 #, c-format
 msgid "E706: Variable type mismatch for: %s"
 msgstr "E706: Nekongrua datumtipo de variablo: %s"
@@ -1664,9 +1667,6 @@
 msgid "[character special]"
 msgstr "[speciala signo]"
 
-msgid "[RO]"
-msgstr "[Nurlegebla]"
-
 msgid "[CR missing]"
 msgstr "[CR mankas]"
 
@@ -2268,32 +2268,28 @@
 msgstr "Tiparo '%s' ne estas egallara"
 
 #, c-format
-msgid "E253: Fontset name: %s\n"
-msgstr "E253: Nomo de tiparo: %s\n"
+msgid "E253: Fontset name: %s"
+msgstr "E253: Nomo de tiparo: %s"
 
 #, c-format
-msgid "Font0: %s\n"
-msgstr "Font0: %s\n"
+msgid "Font0: %s"
+msgstr "Font0: %s"
 
 #, c-format
-msgid "Font1: %s\n"
-msgstr "Font1: %s\n"
+msgid "Font1: %s"
+msgstr "Font1: %s"
 
 #, c-format
-msgid "Font%ld width is not twice that of font0\n"
-msgstr "Font%ld ne estas duoble pli lara ol font0\n"
+msgid "Font%ld width is not twice that of font0"
+msgstr "Font%ld ne estas duoble pli lara ol font0"
 
 #, c-format
-msgid "Font0 width: %ld\n"
-msgstr "Laro de font0: %ld\n"
+msgid "Font0 width: %ld"
+msgstr "Laro de font0: %ld"
 
 #, c-format
-msgid ""
-"Font1 width: %ld\n"
-"\n"
-msgstr ""
-"Laro de Font1: %ld\n"
-"\n"
+msgid "Font1 width: %ld"
+msgstr "Laro de Font1: %ld"
 
 msgid "Invalid font specification"
 msgstr "Nevalida tiparo specifita"
@@ -2482,6 +2478,9 @@
 msgid "E622: Could not fork for cscope"
 msgstr "E622: Ne eblis forki cscope"
 
+msgid "cs_create_connection setpgid failed"
+msgstr "plenumo de cs_create_connection-setgpid fiaskis"
+
 msgid "cs_create_connection exec failed"
 msgstr "plenumo de cs_create_connection fiaskis"
 
@@ -2649,9 +2648,6 @@
 msgid "E836: This Vim cannot execute :python after using :py3"
 msgstr "E836: Vim ne povas plenumi :python post uzo de :py3"
 
-msgid "only string keys are allowed"
-msgstr "nur enaj losiloj estas permeseblaj"
-
 msgid ""
 "E263: Sorry, this command is disabled, the Python library could not be "
 "loaded."
@@ -2665,9 +2661,6 @@
 msgid "E837: This Vim cannot execute :py3 after using :python"
 msgstr "E837: Vim ne povas plenumi :py3  post uzo de :python"
 
-msgid "index must be int or slice"
-msgstr "indekso devas esti 'int' a 'slice'"
-
 msgid "E265: $_ must be an instance of String"
 msgstr "E265: $_ devas esti apero de eno"
 
@@ -4009,13 +4002,6 @@
 msgid "Beep!"
 msgstr "Bip!"
 
-msgid "Vim: preserving files...\n"
-msgstr "Vim: konservo de dosieroj...\n"
-
-#. close all memfiles, without deleting
-msgid "Vim: Finished.\n"
-msgstr "Vim: Finita.\n"
-
 msgid "ERROR: "
 msgstr "ERARO: "
 
@@ -4529,17 +4515,6 @@
 msgid "E245: Illegal char '%c' in font name \"%s\""
 msgstr "E245: Nevalida signo '%c' en nomo de tiparo \"%s\""
 
-msgid "Vim: Double signal, exiting\n"
-msgstr "Vim: Duobla signalo, eliranta\n"
-
-#, c-format
-msgid "Vim: Caught deadly signal %s\n"
-msgstr "Vim: Kaptis mortigantan signalon %s\n"
-
-#, c-format
-msgid "Vim: Caught deadly signal\n"
-msgstr "Vim: Kaptis mortigantan signalon\n"
-
 #, c-format
 msgid "Opening the X display took %ld msec"
 msgstr "Malfermo de vidigo X daris %ld msek"
@@ -4769,6 +4744,21 @@
 msgid "E55: Unmatched %s)"
 msgstr "E55: Neekvilibra %s"
 
+msgid "E66: \\z( not allowed here"
+msgstr "E66: \\z( estas nepermesebla tie"
+
+# DP: vidu http://www.thefreedictionary.com/et+al.
+msgid "E67: \\z1 et al. not allowed here"
+msgstr "E67: \\z1 kaj aliaj estas nepermeseblaj tie"
+
+#, c-format
+msgid "E69: Missing ] after %s%%["
+msgstr "E69: Mankas ] post %s%%["
+
+#, c-format
+msgid "E70: Empty %s%%[]"
+msgstr "E70: Malplena %s%%[]"
+
 msgid "E339: Pattern too long"
 msgstr "E339: ablono tro longa"
 
@@ -4808,25 +4798,10 @@
 msgid "E65: Illegal back reference"
 msgstr "E65: Nevalida retro-referenco"
 
-msgid "E66: \\z( not allowed here"
-msgstr "E66: \\z( estas permesebla tie"
-
-# DP: vidu http://www.thefreedictionary.com/et+al.
-msgid "E67: \\z1 et al. not allowed here"
-msgstr "E67: \\z1 kaj aliaj estas nepermeseblaj tie"
-
 msgid "E68: Invalid character after \\z"
 msgstr "E68: Nevalida signo post \\z"
 
 #, c-format
-msgid "E69: Missing ] after %s%%["
-msgstr "E69: Mankas ] post %s%%["
-
-#, c-format
-msgid "E70: Empty %s%%[]"
-msgstr "E70: Malplena %s%%[]"
-
-#, c-format
 msgid "E678: Invalid character after %s%%[dxouU]"
 msgstr "E678: Nevalida signo post %s%%[dxouU]"
 
@@ -4848,17 +4823,25 @@
 "E864: \\%#= povas nur esti sekvita de 0, 1, a 2. La atomata motoro de "
 "regulesprimo estos uzata "
 
+msgid "E865: (NFA) Regexp end encountered prematurely"
+msgstr "E865: (NFA) Trovis finon de regulesprimo tro frue"
+
 #, c-format
 msgid "E866: (NFA regexp) Misplaced %c"
 msgstr "E866: (NFA-regulesprimo) Mispoziciigita %c"
 
-msgid "E865: (NFA) Regexp end encountered prematurely"
-msgstr "E865: (NFA) Trovis finon de regulesprimo tro frue"
+#, c-format
+msgid "E877: (NFA regexp) Invalid character class: %ld"
+msgstr "E877: (NFA-regulesprimo) Nevalida klaso de signo: %ld"
 
 #, c-format
 msgid "E867: (NFA) Unknown operator '\\z%c'"
 msgstr "E867: (NFA) Nekonata operatoro '\\z%c'"
 
+#, c-format
+msgid "E867: (NFA) Unknown operator '\\%%%c'"
+msgstr "E867: (NFA) Nekonata operatoro '\\%%%c'"
+
 #. should never happen
 msgid "E868: Error building NFA with equivalence class!"
 msgstr "E868: Eraro dum prekomputado de NFA kun ekvivalentoklaso!"
@@ -4870,14 +4853,19 @@
 msgid "E870: (NFA regexp) Error reading repetition limits"
 msgstr "E870: (NFS-regulesprimo) Eraro dum legado de limoj de ripeto"
 
+#. Can't have a multi follow a multi.
 msgid "E871: (NFA regexp) Can't have a multi follow a multi !"
 msgstr ""
 "E871: (NFA-regulesprimo) Ne povas havi mult-selekton tuj post alia mult-"
 "selekto!"
 
+#. Too many `('
 msgid "E872: (NFA regexp) Too many '('"
 msgstr "E872: (NFA-regulesprimo) tro da '('"
 
+msgid "E879: (NFA regexp) Too many \\z("
+msgstr "E879: (NFA-regulesprimo) tro da \\z("
+
 msgid "E873: (NFA regexp) proper termination error"
 msgstr "E873: (NFA-regulesprimo) propra end-eraro"
 
@@ -4894,17 +4882,8 @@
 msgid "E876: (NFA regexp) Not enough space to store the whole NFA "
 msgstr "E876: (NFA-regulesprimo) ne sufia spaco por enmomorigi la tutan NFA "
 
-msgid "E999: (NFA regexp internal error) Should not process NOT node !"
-msgstr ""
-"E999: (interna eraro de NFA-regulesprimo) Ne devus procezi nodon 'NOT'!"
-
-#. should not be here :P
-msgid "E877: (NFA regexp) Invalid character class "
-msgstr "E877: (NFA-regulesprimo) Nevalida klaso de signo "
-
-#, c-format
-msgid "(NFA) COULD NOT OPEN %s !"
-msgstr "(NFA) NE POVIS MALFERMI %s!"
+msgid "E878: (NFA) Could not allocate memory for branch traversal!"
+msgstr "E878: (NFA) Ne povis asigni memoron por traigi branojn!"
 
 msgid ""
 "Could not open temporary log file for writing, displaying on stderr ... "
@@ -4912,8 +4891,9 @@
 "Ne povis malfermi provizoran protokolan dosieron por skribi, nun montras sur "
 "stderr ..."
 
-msgid "E878: (NFA) Could not allocate memory for branch traversal!"
-msgstr "E878: (NFA) Ne povis asigni memoron por traigi branojn!"
+#, c-format
+msgid "(NFA) COULD NOT OPEN %s !"
+msgstr "(NFA) NE POVIS MALFERMI %s!"
 
 msgid "Could not open temporary log file for writing "
 msgstr "Ne povis malfermi la provizoran protokolan dosieron por skribi "
@@ -5354,12 +5334,12 @@
 msgstr "E765: 'spellfile' ne havas %ld rikordojn"
 
 #, c-format
-msgid "Word removed from %s"
-msgstr "Vorto fortirita el %s"
+msgid "Word '%.*s' removed from %s"
+msgstr "Vorto '%.*s' fortirita el %s"
 
 #, c-format
-msgid "Word added to %s"
-msgstr "Vorto aldonita al %s"
+msgid "Word '%.*s' added to %s"
+msgstr "Vorto '%.*s' aldonita al %s"
 
 msgid "E763: Word characters differ between spell files"
 msgstr "E763: Signoj de vorto malsamas tra literumaj dosieroj"
@@ -5413,6 +5393,9 @@
 msgid "E783: duplicate char in MAP entry"
 msgstr "E783: ripetita signo en rikordo MAP"
 
+msgid "No Syntax items defined for this buffer"
+msgstr "Neniu sintaksa elemento difinita por tiu bufro"
+
 #, c-format
 msgid "E390: Illegal argument: %s"
 msgstr "E390: Nevalida argumento: %s"
@@ -5421,9 +5404,6 @@
 msgid "E391: No such syntax cluster: %s"
 msgstr "E391: Nenia sintaksa fasko: %s"
 
-msgid "No Syntax items defined for this buffer"
-msgstr "Neniu sintaksa elemento difinita por tiu bufro"
-
 msgid "syncing on C-style comments"
 msgstr "sinkronigo per C-stilaj komentoj"
 
@@ -5549,6 +5529,11 @@
 msgid "E410: Invalid :syntax subcommand: %s"
 msgstr "E410: Nevalida \":syntax\" subkomando: %s"
 
+msgid ""
+"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN"
+msgstr ""
+"  TOTALO    NOMBRO  KONGRUO PLEJ MALRAPID  MEZA   NOMO               ABLONO"
+
 msgid "E679: recursive loop loading syncolor.vim"
 msgstr "E679: rekursia buklo dum argo de syncolor.vim"
 
@@ -5744,8 +5729,8 @@
 
 #. This happens when the FileChangedRO autocommand changes the
 #. * file in a way it becomes shorter.
-msgid "E834: Line count changed unexpectedly"
-msgstr "E834: Nombro de linioj aniis neatendite"
+msgid "E881: Line count changed unexpectedly"
+msgstr "E881: Nombro de linioj aniis neatendite"
 
 #. must display the prompt
 msgid "No undo possible; continue anyway"
@@ -6474,6 +6459,9 @@
 msgid "E37: No write since last change (add ! to override)"
 msgstr "E37: Neniu skribo de post lasta ano (aldonu ! por transpasi)"
 
+msgid "E37: No write since last change"
+msgstr "E37: Neniu skribo de post lasta ano"
+
 msgid "E38: Null argument"
 msgstr "E38: Nula argumento"
 
@@ -6631,107 +6619,168 @@
 msgid "Need encryption key for \"%s\""
 msgstr "losilo de ifrado bezonata por \"%s\""
 
-msgid "can't delete OutputObject attributes"
-msgstr "ne eblas forvii atributojn de OutputObject"
+msgid "empty keys are not allowed"
+msgstr "malplenaj losiloj nepermeseblaj"
+
+msgid "dictionary is locked"
+msgstr "vortaro estas losita"
+
+msgid "list is locked"
+msgstr "listo estas losita"
+
+#, c-format
+msgid "failed to add key '%s' to dictionary"
+msgstr "aldono de losilo '%s' al vortaro fiaskis"
+
+#, c-format
+msgid "index must be int or slice, not %s"
+msgstr "indekso devas esti 'int' a 'slice', ne %s"
+
+#, c-format
+msgid "expected str() or unicode() instance, but got %s"
+msgstr "atendis aperon de str() a unicode(), sed ricevis %s"
+
+#, c-format
+msgid "expected bytes() or str() instance, but got %s"
+msgstr "atendis aperon de bytes() a str(), sed ricevis %s"
+
+#, c-format
+msgid ""
+"expected int(), long() or something supporting coercing to long(), but got %s"
+msgstr "atendis int(), long() a ion konverteblan al long(), sed ricevis %s"
+
+#, c-format
+msgid "expected int() or something supporting coercing to int(), but got %s"
+msgstr "atendis int() a ion konverteblan al int(), sed ricevis %s"
+
+msgid "value is too large to fit into C int type"
+msgstr "valoro estas tro grada por C-tipo 'int'"
 
-msgid "softspace must be an integer"
-msgstr "malmolspaceto (softspace) devas esti entjero"
+msgid "value is too small to fit into C int type"
+msgstr "valoro estas tro malgranda por C-tipo 'int'"
 
-msgid "invalid attribute"
-msgstr "nevalida atributo"
+msgid "number must be greater than zero"
+msgstr "nombro devas esti pli granda ol nul"
 
-msgid "writelines() requires list of strings"
-msgstr "writelines() bezonas liston de enoj"
+msgid "number must be greater or equal to zero"
+msgstr "nombro devas esti egala a pli granda ol nul"
+
+msgid "can't delete OutputObject attributes"
+msgstr "ne eblas forvii atributojn de OutputObject"
+
+#, c-format
+msgid "invalid attribute: %s"
+msgstr "nevalida atributo: %s"
 
 msgid "E264: Python: Error initialising I/O objects"
 msgstr "E264: Pitono: Eraro de pravalorizo de eneligaj objektoj"
 
-msgid "empty keys are not allowed"
-msgstr "malplenaj losiloj nepermeseblaj"
+msgid "failed to change directory"
+msgstr "ne povis ani dosierujon"
 
-msgid "Cannot delete DictionaryObject attributes"
-msgstr "ne eblas forvii atributojn de DictionaryObject"
+#, c-format
+msgid "expected 3-tuple as imp.find_module() result, but got %s"
+msgstr "atendis 3-opon kiel rezulto de imp.find_module(), sed ricevis %s"
 
-msgid "Cannot modify fixed dictionary"
-msgstr "Ne eblas ani fiksan vortaron"
+#, c-format
+msgid "expected 3-tuple as imp.find_module() result, but got tuple of size %d"
+msgstr "atendis 3-opon kiel rezulto de imp.find_module(), sed ricevis %d-opon"
 
-msgid "Cannot set this attribute"
-msgstr "Ne eblas agordi tiun atributon"
+msgid "internal error: imp.find_module returned tuple with NULL"
+msgstr "interna eraro: imp.find_module liveris opon kun NULL"
 
-msgid "dict is locked"
-msgstr "vortaro estas losita"
+msgid "cannot delete vim.Dictionary attributes"
+msgstr "ne eblas forvii atributojn de 'vim.Dictionary'"
+
+msgid "cannot modify fixed dictionary"
+msgstr "ne eblas ani fiksan vortaron"
 
-msgid "failed to add key to dictionary"
-msgstr "aldono de losilo al vortaro fiaskis"
+#, c-format
+msgid "cannot set attribute %s"
+msgstr "ne eblas agordi atributon %s"
+
+msgid "hashtab changed during iteration"
+msgstr "hakettabelo aniis dum iteracio"
+
+#, c-format
+msgid "expected sequence element of size 2, but got sequence of size %d"
+msgstr "atendis 2-longan sekvencon, sed ricevis %d-longan sekvencon"
+
+msgid "list constructor does not accept keyword arguments"
+msgstr "konstruilo de listo ne akceptas losilvortajn argumentojn"
 
 msgid "list index out of range"
 msgstr "indekso de listo ekster limoj"
 
-msgid "internal error: failed to get vim list item"
-msgstr "interna eraro: obteno de vim-a listero fiaskis"
+#. No more suitable format specifications in python-2.3
+#, c-format
+msgid "internal error: failed to get vim list item %d"
+msgstr "interna eraro: obteno de vim-a listero %d fiaskis"
 
-msgid "list is locked"
-msgstr "listo estas losita"
+msgid "slice step cannot be zero"
+msgstr "pao de sekco ne povas esti nul"
 
-msgid "Failed to add item to list"
-msgstr "Aldono de listero fiaskis"
+#, c-format
+msgid "attempt to assign sequence of size greater than %d to extended slice"
+msgstr "provis valorizi sekvencon kun pli ol %d eroj en etendita sekco"
 
-msgid "internal error: no vim list item"
-msgstr "interna eraro: neniu vim-a listero"
+#, c-format
+msgid "internal error: no vim list item %d"
+msgstr "interna eraro: neniu vim-a listero %d"
 
-msgid "can only assign lists to slice"
-msgstr "nur eblas pravalorizi listojn al segmento"
+msgid "internal error: not enough list items"
+msgstr "interna eraro: ne sufiaj listeroj"
 
 msgid "internal error: failed to add item to list"
 msgstr "interna eraro: aldono de listero fiaskis"
 
-msgid "can only concatenate with lists"
-msgstr "eblas nur kunmeti kun listoj"
+#, c-format
+msgid "attempt to assign sequence of size %d to extended slice of size %d"
+msgstr "provis valorizi sekvencon kun %d eroj al etendita sekco kun %d eroj"
+
+msgid "failed to add item to list"
+msgstr "aldono de listero fiaskis"
 
-msgid "cannot delete vim.dictionary attributes"
-msgstr "ne eblas forvii atributojn de 'vim.dictionary'"
+msgid "cannot delete vim.List attributes"
+msgstr "ne eblas forvii atributojn de 'vim.List'"
 
 msgid "cannot modify fixed list"
 msgstr "ne eblas ani fiksan liston"
 
-msgid "cannot set this attribute"
-msgstr "ne eblas agordi tiun atributon"
+#, c-format
+msgid "unnamed function %s does not exist"
+msgstr "sennoma funkcio %s ne ekzistas"
+
+#, c-format
+msgid "function %s does not exist"
+msgstr "funkcio %s ne ekzistas"
 
-msgid "'self' argument must be a dictionary"
-msgstr "argumento 'self' devas esti vortaro"
+msgid "function constructor does not accept keyword arguments"
+msgstr "konstruilo de funkcio ne akceptas losilvortajn argumentojn"
 
-msgid "failed to run function"
-msgstr "fiaskis ruli funkcion"
+#, c-format
+msgid "failed to run function %s"
+msgstr "fiaskis ruli funkcion %s"
 
 msgid "unable to get option value"
 msgstr "fiaskis akiri valoron de opcio"
 
-msgid "unable to unset global option"
-msgstr "ne povis malalti mallokan opcion"
-
-msgid "unable to unset option without global value"
-msgstr "ne povis malalti opcion sen malloka valoro"
+msgid "internal error: unknown option type"
+msgstr "interna eraro: nekonata tipo de opcio"
 
-msgid "object must be integer"
-msgstr "objekto devas esti entjero."
-
-msgid "object must be string"
-msgstr "objekto devas esti eno"
-
-msgid "attempt to refer to deleted tab page"
-msgstr "provo de referenco al forviita langeto"
+msgid "problem while switching windows"
+msgstr "problemo dum salto al vindozoj"
 
 #, c-format
-msgid "<tabpage object (deleted) at %p>"
-msgstr "<langeta objekto (forviita) e %p>"
+msgid "unable to unset global option %s"
+msgstr "ne povis malalti mallokan opcion %s"
 
 #, c-format
-msgid "<tabpage object (unknown) at %p>"
-msgstr "<langeta objekto (nekonata) e %p>"
+msgid "unable to unset option %s which does not have global value"
+msgstr "ne povis malalti opcion %s, kiu ne havas mallokan valoron"
 
-#, c-format
-msgid "<tabpage %d>"
-msgstr "<langeto %d>"
+msgid "attempt to refer to deleted tab page"
+msgstr "provo de referenco al forviita langeto"
 
 msgid "no such tab page"
 msgstr "ne estas tia langeto"
@@ -6739,45 +6788,35 @@
 msgid "attempt to refer to deleted window"
 msgstr "provo de referenco al forviita fenestro"
 
-msgid "readonly attribute"
-msgstr "nurlegebla atributo"
+msgid "readonly attribute: buffer"
+msgstr "nurlegebla atributo: buffer"
 
 msgid "cursor position outside buffer"
 msgstr "kursoro poziciita ekster bufro"
 
-#, c-format
-msgid "<window object (deleted) at %p>"
-msgstr "<fenestra objekto (forviita) e %p>"
-
-#, c-format
-msgid "<window object (unknown) at %p>"
-msgstr "<objekta fenestro (nekonata) e %p>"
-
-#, c-format
-msgid "<window %d>"
-msgstr "<fenestro %d>"
-
 msgid "no such window"
 msgstr "ne estas tia fenestro"
 
 msgid "attempt to refer to deleted buffer"
 msgstr "provo de referenco al forviita bufro"
 
-#, c-format
-msgid "<buffer object (deleted) at %p>"
-msgstr "<bufra objekto (forviita) e %p>"
+msgid "failed to rename buffer"
+msgstr "ne povis renomi bufron"
 
-msgid "key must be integer"
-msgstr "losilo devas esti entjero."
+msgid "mark name must be a single character"
+msgstr "nomo de marko devas esti unuopa signo"
 
-msgid "expected vim.buffer object"
-msgstr "atendis objekton vim.buffer"
+#, c-format
+msgid "expected vim.Buffer object, but got %s"
+msgstr "atendis objekton vim.Buffer, sed ricevis %s"
 
-msgid "failed to switch to given buffer"
-msgstr "ne povis salti al la specifita bufro"
+#, c-format
+msgid "failed to switch to buffer %d"
+msgstr "ne povis salti al la bufro %d"
 
-msgid "expected vim.window object"
-msgstr "atendis objekton vim.window"
+#, c-format
+msgid "expected vim.Window object, but got %s"
+msgstr "atendis objekton vim.window, sed ricevis %s"
 
 msgid "failed to find window in the current tab page"
 msgstr "ne povis trovi vindozon en la nuna langeto"
@@ -6785,8 +6824,9 @@
 msgid "did not switch to the specified window"
 msgstr "ne saltis al la specifita vindozo"
 
-msgid "expected vim.tabpage object"
-msgstr "atendis objekton vim.tabpage"
+#, c-format
+msgid "expected vim.TabPage object, but got %s"
+msgstr "atendis objekton vim.TabPage, sed ricevis %s"
 
 msgid "did not switch to the specified tab page"
 msgstr "ne saltis al la specifita langeto"
@@ -6800,26 +6840,34 @@
 msgid "E859: Failed to convert returned python object to vim value"
 msgstr "E859: Konverto de revena python-objekto al vim-valoro fiaskis"
 
-msgid "unable to convert to vim structure"
-msgstr "ne povis konverti al vim-strukturo"
+#, c-format
+msgid "unable to convert %s to vim dictionary"
+msgstr "ne povis konverti %s al vim-vortaro"
+
+#, c-format
+msgid "unable to convert %s to vim structure"
+msgstr "ne povis konverti %s al vim-strukturo"
 
-msgid "NULL reference passed"
-msgstr "NULL-referenco argumento"
+msgid "internal error: NULL reference passed"
+msgstr "interna eraro: NULL-referenco argumento"
 
 msgid "internal error: invalid value type"
 msgstr "interna eraro: nevalida tipo de valoro"
 
-#~ msgid "E863: return value must be an instance of str"
-#~ msgstr "E863: elira valoro devas esti apero de str"
-
-#~ msgid "E860: Eval did not return a valid python 3 object"
-#~ msgstr "E860: Eval ne revenis kun valida python3-objekto"
-
-#~ msgid "E861: Failed to convert returned python 3 object to vim value"
-#~ msgstr "E861: Konverto de revena python3-objekto al vim-valoro fiaskis"
-
-#~ msgid "Only boolean objects are allowed"
-#~ msgstr "Nur buleaj objektoj estas permeseblaj"
+msgid ""
+"Failed to set path hook: sys.path_hooks is not a list\n"
+"You should now do the following:\n"
+"- append vim.path_hook to sys.path_hooks\n"
+"- append vim.VIM_SPECIAL_PATH to sys.path\n"
+msgstr ""
+"Fiaskis valorizi sys.path_hooks: sys.path_hooks ne estas listo\n"
+"Vi nun devas fari tion:\n"
+"- postaldoni vim.path_hook al sys.path_hooks\n"
+"- postaldoni vim.VIM_SPECIAL_PATH al sys.path\n"
 
-#~ msgid "no such key in dictionary"
-#~ msgstr "tiu losilo ne ekzistas en vortaro"
+msgid ""
+"Failed to set path: sys.path is not a list\n"
+"You should now append vim.VIM_SPECIAL_PATH to sys.path"
+msgstr ""
+"Ne povis agordi servojon: sys.path ne estas listo\n"
+"Vi nun devas aldoni vim.VIM_SPECIAL_PATH al sys.path"
diff -Naur vim74.orig/src/po/es.po vim74/src/po/es.po
--- vim74.orig/src/po/es.po	2011-05-19 10:45:41.000000000 +0000
+++ vim74/src/po/es.po	2014-10-10 14:53:44.888712515 +0000
@@ -582,8 +582,8 @@
 msgstr "E691: Solo se puede comparar una lista con otra lista"
 
 #: eval.c:4298
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: Operacin invlida para listas"
+msgid "E692: Invalid operation for List"
+msgstr "E692: Operacin invlida para lista"
 
 #: eval.c:4325
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/fi.po vim74/src/po/fi.po
--- vim74.orig/src/po/fi.po	2013-04-20 13:49:08.000000000 +0000
+++ vim74/src/po/fi.po	2014-10-10 14:53:44.898712490 +0000
@@ -471,7 +471,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Listaa voi verrata vain listaan"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Virheellinen toiminto listalle"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/fr.po vim74/src/po/fr.po
--- vim74.orig/src/po/fr.po	2013-05-27 08:41:50.000000000 +0000
+++ vim74/src/po/fr.po	2014-10-10 14:53:44.918712440 +0000
@@ -543,8 +543,8 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Une Liste ne peut tre compare qu'avec une Liste"
 
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: Opration invalide avec les Listes"
+msgid "E692: Invalid operation for List"
+msgstr "E692: Opration invalide avec les Liste"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
 msgstr "E735: Un Dictionnaire ne peut tre compar qu'avec un Dictionnaire"
diff -Naur vim74.orig/src/po/ga.po vim74/src/po/ga.po
--- vim74.orig/src/po/ga.po	2011-05-19 10:46:33.000000000 +0000
+++ vim74/src/po/ga.po	2014-10-10 14:53:44.928712415 +0000
@@ -443,7 +443,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Is fidir Liosta a chur i gcomparid le Liosta eile amhin"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Oibrocht neamhbhail ar Liosta"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/it.po vim74/src/po/it.po
--- vim74.orig/src/po/it.po	2013-08-10 11:31:45.000000000 +0000
+++ vim74/src/po/it.po	2014-10-10 14:53:44.945379039 +0000
@@ -477,7 +477,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Posso confrontare una Lista solo con un'altra Lista"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Operazione non valida per Liste"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/ja.euc-jp.po vim74/src/po/ja.euc-jp.po
--- vim74.orig/src/po/ja.euc-jp.po	2013-07-06 10:53:48.000000000 +0000
+++ vim74/src/po/ja.euc-jp.po	2014-10-10 14:53:44.955379014 +0000
@@ -3,7 +3,7 @@
 # Do ":help uganda"  in Vim to read copying and usage conditions.
 # Do ":help credits" in Vim to see a list of people who contributed.
 #
-# Last Change: 2013 Jul 06
+# Last Change: 2014 May 13
 #
 # Copyright (C) 2001-13 MURAOKA Taro <koron.kaoriya@gmail.com>
 # THIS FILE IS DISTRIBUTED UNDER THE VIM LICENSE.
@@ -479,7 +479,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: "
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/ja.po vim74/src/po/ja.po
--- vim74.orig/src/po/ja.po	2013-07-06 06:04:57.000000000 +0000
+++ vim74/src/po/ja.po	2014-10-10 14:53:44.965378989 +0000
@@ -3,7 +3,7 @@
 # Do ":help uganda"  in Vim to read copying and usage conditions.
 # Do ":help credits" in Vim to see a list of people who contributed.
 #
-# Last Change: 2013 Jul 06
+# Last Change: 2014 May 13
 #
 # Copyright (C) 2001-13 MURAOKA Taro <koron.kaoriya@gmail.com>
 # THIS FILE IS DISTRIBUTED UNDER THE VIM LICENSE.
@@ -479,7 +479,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: "
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/ja.sjis.po vim74/src/po/ja.sjis.po
--- vim74.orig/src/po/ja.sjis.po	2013-08-10 12:28:27.000000000 +0000
+++ vim74/src/po/ja.sjis.po	2014-10-10 14:53:44.975378964 +0000
@@ -3,7 +3,7 @@
 # Do ":help uganda"  in Vim to read copying and usage conditions.
 # Do ":help credits" in Vim to see a list of people who contributed.
 #
-# Last Change: 2013 Jul 06
+# Last Change: 2014 May 13
 #
 # Copyright (C) 2001-13 MURAOKA Taro <koron.kaoriya@gmail.com>
 # THIS FILE IS DISTRIBUTED UNDER THE VIM LICENSE.
@@ -479,7 +479,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Xg^Xg^r"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Xg^"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/ko.UTF-8.po vim74/src/po/ko.UTF-8.po
--- vim74.orig/src/po/ko.UTF-8.po	2011-05-19 10:47:30.000000000 +0000
+++ vim74/src/po/ko.UTF-8.po	2014-10-10 14:53:44.982045614 +0000
@@ -462,7 +462,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: List List   "
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: List   "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/ko.po vim74/src/po/ko.po
--- vim74.orig/src/po/ko.po	2011-05-19 10:47:53.000000000 +0000
+++ vim74/src/po/ko.po	2014-10-10 14:53:44.988712264 +0000
@@ -462,7 +462,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: List List   "
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: List   "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/nb.po vim74/src/po/nb.po
--- vim74.orig/src/po/nb.po	2011-05-19 11:12:47.000000000 +0000
+++ vim74/src/po/nb.po	2014-10-10 14:53:44.992045589 +0000
@@ -456,8 +456,8 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Kan bare sammenligne liste med liste"
 
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: Ugyldig operasjon for lister"
+msgid "E692: Invalid operation for List"
+msgstr "E692: Ugyldig operasjon for liste"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
 msgstr "E735: Kan bare sammenligne ordliste med ordliste"
diff -Naur vim74.orig/src/po/nl.po vim74/src/po/nl.po
--- vim74.orig/src/po/nl.po	2013-07-09 12:55:16.000000000 +0000
+++ vim74/src/po/nl.po	2014-10-10 14:53:45.002045564 +0000
@@ -458,8 +458,8 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: List kan alleen met een Lijst worden vergeleken"
 
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: ongeldige bewerking voor Listen"
+msgid "E692: Invalid operation for List"
+msgstr "E692: ongeldige bewerking voor List"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
 msgstr "E735: Dictionary kan alleen met Woordenboek worden vergeleken"
diff -Naur vim74.orig/src/po/no.po vim74/src/po/no.po
--- vim74.orig/src/po/no.po	2011-05-19 10:48:14.000000000 +0000
+++ vim74/src/po/no.po	2014-10-10 14:53:45.008712214 +0000
@@ -456,8 +456,8 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Kan bare sammenligne liste med liste"
 
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: Ugyldig operasjon for lister"
+msgid "E692: Invalid operation for List"
+msgstr "E692: Ugyldig operasjon for liste"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
 msgstr "E735: Kan bare sammenligne ordliste med ordliste"
diff -Naur vim74.orig/src/po/pl.UTF-8.po vim74/src/po/pl.UTF-8.po
--- vim74.orig/src/po/pl.UTF-8.po	2013-07-09 12:25:44.000000000 +0000
+++ vim74/src/po/pl.UTF-8.po	2014-10-10 14:53:45.015378864 +0000
@@ -12,9 +12,10 @@
 "POT-Creation-Date: 2013-07-06 19:33+0200\n"
 "PO-Revision-Date: 2010-08-10 18:15+0200\n"
 "Last-Translator: Mikolaj Machowski <mikmach@wp.pl>\n"
+"Language-Team: \n"
 "Language: pl\n"
 "MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Type: text/plain; charset=utf-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: Lokalize 1.0\n"
 "Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 "
@@ -475,7 +476,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: List mog porwna tylko z List"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Nieprawidowa operacja dla Listy"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/pl.cp1250.po vim74/src/po/pl.cp1250.po
--- vim74.orig/src/po/pl.cp1250.po	2013-08-10 12:28:27.000000000 +0000
+++ vim74/src/po/pl.cp1250.po	2014-10-10 14:53:45.028712163 +0000
@@ -12,9 +12,10 @@
 "POT-Creation-Date: 2013-07-06 19:33+0200\n"
 "PO-Revision-Date: 2010-08-10 18:15+0200\n"
 "Last-Translator: Mikolaj Machowski <mikmach@wp.pl>\n"
+"Language-Team: \n"
 "Language: pl\n"
 "MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=CP1250\n"
+"Content-Type: text/plain; charset=cp1250\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: Lokalize 1.0\n"
 "Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 "
@@ -475,7 +476,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: List mog porwna tylko z List"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Nieprawidowa operacja dla Listy"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/pl.po vim74/src/po/pl.po
--- vim74.orig/src/po/pl.po	2013-07-09 12:25:10.000000000 +0000
+++ vim74/src/po/pl.po	2014-10-10 14:53:45.042045463 +0000
@@ -12,6 +12,7 @@
 "POT-Creation-Date: 2013-07-06 19:33+0200\n"
 "PO-Revision-Date: 2010-08-10 18:15+0200\n"
 "Last-Translator: Mikolaj Machowski <mikmach@wp.pl>\n"
+"Language-Team: \n"
 "Language: pl\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=ISO-8859-2\n"
@@ -475,7 +476,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: List mog porwna tylko z List"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692: Nieprawidowa operacja dla Listy"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/pt_BR.po vim74/src/po/pt_BR.po
--- vim74.orig/src/po/pt_BR.po	2011-05-19 10:49:11.000000000 +0000
+++ vim74/src/po/pt_BR.po	2014-10-10 14:53:45.048712113 +0000
@@ -438,8 +438,8 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Uma Lista s pode ser comparada com outra Lista"
 
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: Operao invlida para Listas"
+msgid "E692: Invalid operation for List"
+msgstr "E692: Operao invlida para Lista"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
 msgstr "E735: Um Dicionrio s pode ser comparado com outro Dicionrio"
diff -Naur vim74.orig/src/po/ru.cp1251.po vim74/src/po/ru.cp1251.po
--- vim74.orig/src/po/ru.cp1251.po	2013-08-10 12:28:27.000000000 +0000
+++ vim74/src/po/ru.cp1251.po	2014-10-10 14:53:45.055378763 +0000
@@ -3,14 +3,14 @@
 #       Vim ":help uganda"
 #
 # vassily "vr" ragosin <vrr@users.sourceforge.net>, 2004
-# Sergey Alyoshin <alyoshin.s@gmail.com>, 2013
+# Sergey Alyoshin <alyoshin.s@gmail.com>, 2013-2014
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: vim_7.4_ru\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2013-07-08 00:47+0400\n"
-"PO-Revision-Date: 2013-07-08 00:47+0400\n"
+"POT-Creation-Date: 2014-03-24 12:18+0400\n"
+"PO-Revision-Date: 2014-03-24 12:18 +0400\n"
 "Last-Translator: Sergey Alyoshin <alyoshin.s@gmail.com>\n"
 "Language-Team: \n"
 "Language: Russian\n"
@@ -79,6 +79,9 @@
 msgid "%d buffers wiped out"
 msgstr "  : %d"
 
+msgid "E90: Cannot unload last buffer"
+msgstr "E90:      "
+
 msgid "E84: No modified buffer found"
 msgstr "E84:    "
 
@@ -101,9 +104,6 @@
 msgstr ""
 "E89:    %ld   ( !,   )"
 
-msgid "E90: Cannot unload last buffer"
-msgstr "E90:      "
-
 msgid "W14: Warning: List of file names overflow"
 msgstr "W14: :    "
 
@@ -474,7 +474,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691:      "
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692:    "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
@@ -569,7 +569,7 @@
 msgstr "E808:       "
 
 msgid "add() argument"
-msgstr " add()"
+msgstr " add()"
 
 msgid "E699: Too many arguments"
 msgstr "E699:   "
@@ -590,13 +590,13 @@
 msgstr "E737:   : %s"
 
 msgid "extend() argument"
-msgstr " extend()"
+msgstr " extend()"
 
 msgid "map() argument"
-msgstr " map()"
+msgstr " map()"
 
 msgid "filter() argument"
-msgstr " filter()"
+msgstr " filter()"
 
 #, c-format
 msgid "+-%s%3ld lines: "
@@ -617,7 +617,7 @@
 msgstr " inputrestore()  ,   inputsave()"
 
 msgid "insert() argument"
-msgstr " insert()"
+msgstr " insert()"
 
 msgid "E786: Range not allowed"
 msgstr "E786:   "
@@ -645,19 +645,19 @@
 msgstr "E277:   "
 
 msgid "remove() argument"
-msgstr " remove()"
+msgstr " remove()"
 
 msgid "E655: Too many symbolic links (cycle?)"
 msgstr "E655:     (?)"
 
 msgid "reverse() argument"
-msgstr " reverse()"
+msgstr " reverse()"
 
 msgid "E258: Unable to send to client"
 msgstr "E258:    "
 
 msgid "sort() argument"
-msgstr " sort()"
+msgstr " sort()"
 
 msgid "E702: Sort compare function failed"
 msgstr "E702:      "
@@ -709,7 +709,7 @@
 
 #, c-format
 msgid "E741: Value is locked: %s"
-msgstr "E741:  : %s"
+msgstr "E741:  %s "
 
 msgid "Unknown"
 msgstr ""
@@ -1540,7 +1540,7 @@
 #. Give up for a ":catch" after ":finally" and ignore it.
 #. * Just parse.
 msgid "E604: :catch after :finally"
-msgstr "E604: :catch  :finally"
+msgstr "E604: :catch  :finally"
 
 msgid "E606: :finally without :try"
 msgstr "E606: :finally  :try"
@@ -4019,13 +4019,6 @@
 msgid "Beep!"
 msgstr "-!"
 
-msgid "Vim: preserving files...\n"
-msgstr "Vim:  ...\n"
-
-#. close all memfiles, without deleting
-msgid "Vim: Finished.\n"
-msgstr "Vim: .\n"
-
 msgid "ERROR: "
 msgstr ": "
 
@@ -4541,17 +4534,6 @@
 msgid "E245: Illegal char '%c' in font name \"%s\""
 msgstr "E245:   '%c'    \"%s\""
 
-msgid "Vim: Double signal, exiting\n"
-msgstr "Vim:  ,  \n"
-
-#, c-format
-msgid "Vim: Caught deadly signal %s\n"
-msgstr "Vim:    %s\n"
-
-#, c-format
-msgid "Vim: Caught deadly signal\n"
-msgstr "Vim:   \n"
-
 #, c-format
 msgid "Opening the X display took %ld msec"
 msgstr "  X  %ld msec"
@@ -4859,12 +4841,16 @@
 "E864:  \\%#=    0, 1  2.   "
 " "
 
+msgid "E865: (NFA) Regexp end encountered prematurely"
+msgstr "E865: ()    "
+
 #, c-format
 msgid "E866: (NFA regexp) Misplaced %c"
 msgstr "E866: (.  )  %c"
 
-msgid "E865: (NFA) Regexp end encountered prematurely"
-msgstr "E865: ()    "
+#, c-format
+msgid "E877: (NFA regexp) Invalid character class: %ld"
+msgstr "E877: (.  )   : %ld"
 
 #, c-format
 msgid "E867: (NFA) Unknown operator '\\z%c'"
@@ -5368,12 +5354,12 @@
 msgstr "E765: 'spellfile'   %ld "
 
 #, c-format
-msgid "Word removed from %s"
-msgstr "   %s"
+msgid "Word '%.*s' removed from %s"
+msgstr " '%.*s'   %s"
 
 #, c-format
-msgid "Word added to %s"
-msgstr "   %s"
+msgid "Word '%.*s' added to %s"
+msgstr " '%.*s'   %s"
 
 msgid "E763: Word characters differ between spell files"
 msgstr "E763:      "
@@ -5763,8 +5749,8 @@
 
 #. This happens when the FileChangedRO autocommand changes the
 #. * file in a way it becomes shorter.
-msgid "E834: Line count changed unexpectedly"
-msgstr "E834:    "
+msgid "E881: Line count changed unexpectedly"
+msgstr "E881:    "
 
 #. must display the prompt
 msgid "No undo possible; continue anyway"
@@ -6479,6 +6465,9 @@
 msgid "E37: No write since last change (add ! to override)"
 msgstr "E37:    ( !,   )"
 
+msgid "E37: No write since last change"
+msgstr "E37:   "
+
 msgid "E38: Null argument"
 msgstr "E38:  "
 
@@ -6678,7 +6667,7 @@
 msgid "value is too small to fit into C int type"
 msgstr "      C"
 
-msgid "number must be greater then zero"
+msgid "number must be greater than zero"
 msgstr "    "
 
 msgid "number must be greater or equal to zero"
@@ -6740,16 +6729,34 @@
 msgid "internal error: failed to get vim list item %d"
 msgstr " :     VIM- %d"
 
-msgid "failed to add item to list"
-msgstr "    "
+msgid "slice step cannot be zero"
+msgstr "     "
+
+#, c-format
+msgid "attempt to assign sequence of size greater than %d to extended slice"
+msgstr ""
+"      %d   "
+""
 
 #, c-format
 msgid "internal error: no vim list item %d"
 msgstr " :   VIM- %d"
 
+msgid "internal error: not enough list items"
+msgstr " :   "
+
 msgid "internal error: failed to add item to list"
 msgstr " :      "
 
+#, c-format
+msgid "attempt to assign sequence of size %d to extended slice of size %d"
+msgstr ""
+"    %d    "
+" %d"
+
+msgid "failed to add item to list"
+msgstr "    "
+
 msgid "cannot delete vim.List attributes"
 msgstr "   vim.List"
 
diff -Naur vim74.orig/src/po/ru.po vim74/src/po/ru.po
--- vim74.orig/src/po/ru.po	2013-07-09 12:36:10.000000000 +0000
+++ vim74/src/po/ru.po	2014-10-10 14:53:45.068712063 +0000
@@ -3,14 +3,14 @@
 #       Vim ":help uganda"
 #
 # vassily "vr" ragosin <vrr@users.sourceforge.net>, 2004
-# Sergey Alyoshin <alyoshin.s@gmail.com>, 2013
+# Sergey Alyoshin <alyoshin.s@gmail.com>, 2013-2014
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: vim_7.4_ru\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2013-07-08 00:47+0400\n"
-"PO-Revision-Date: 2013-07-08 00:47+0400\n"
+"POT-Creation-Date: 2014-03-24 12:18+0400\n"
+"PO-Revision-Date: 2014-03-24 12:18 +0400\n"
 "Last-Translator: Sergey Alyoshin <alyoshin.s@gmail.com>\n"
 "Language-Team: \n"
 "Language: Russian\n"
@@ -79,6 +79,9 @@
 msgid "%d buffers wiped out"
 msgstr "  : %d"
 
+msgid "E90: Cannot unload last buffer"
+msgstr "E90:      "
+
 msgid "E84: No modified buffer found"
 msgstr "E84:    "
 
@@ -101,9 +104,6 @@
 msgstr ""
 "E89:    %ld   ( !,   )"
 
-msgid "E90: Cannot unload last buffer"
-msgstr "E90:      "
-
 msgid "W14: Warning: List of file names overflow"
 msgstr "W14: :    "
 
@@ -474,7 +474,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691:      "
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692:    "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
@@ -569,7 +569,7 @@
 msgstr "E808:       "
 
 msgid "add() argument"
-msgstr " add()"
+msgstr " add()"
 
 msgid "E699: Too many arguments"
 msgstr "E699:   "
@@ -590,13 +590,13 @@
 msgstr "E737:   : %s"
 
 msgid "extend() argument"
-msgstr " extend()"
+msgstr " extend()"
 
 msgid "map() argument"
-msgstr " map()"
+msgstr " map()"
 
 msgid "filter() argument"
-msgstr " filter()"
+msgstr " filter()"
 
 #, c-format
 msgid "+-%s%3ld lines: "
@@ -617,7 +617,7 @@
 msgstr " inputrestore()  ,   inputsave()"
 
 msgid "insert() argument"
-msgstr " insert()"
+msgstr " insert()"
 
 msgid "E786: Range not allowed"
 msgstr "E786:   "
@@ -645,19 +645,19 @@
 msgstr "E277:   "
 
 msgid "remove() argument"
-msgstr " remove()"
+msgstr " remove()"
 
 msgid "E655: Too many symbolic links (cycle?)"
 msgstr "E655:     (?)"
 
 msgid "reverse() argument"
-msgstr " reverse()"
+msgstr " reverse()"
 
 msgid "E258: Unable to send to client"
 msgstr "E258:    "
 
 msgid "sort() argument"
-msgstr " sort()"
+msgstr " sort()"
 
 msgid "E702: Sort compare function failed"
 msgstr "E702:      "
@@ -709,7 +709,7 @@
 
 #, c-format
 msgid "E741: Value is locked: %s"
-msgstr "E741:  : %s"
+msgstr "E741:  %s "
 
 msgid "Unknown"
 msgstr ""
@@ -1540,7 +1540,7 @@
 #. Give up for a ":catch" after ":finally" and ignore it.
 #. * Just parse.
 msgid "E604: :catch after :finally"
-msgstr "E604: :catch  :finally"
+msgstr "E604: :catch  :finally"
 
 msgid "E606: :finally without :try"
 msgstr "E606: :finally  :try"
@@ -4019,13 +4019,6 @@
 msgid "Beep!"
 msgstr "-!"
 
-msgid "Vim: preserving files...\n"
-msgstr "Vim:  ...\n"
-
-#. close all memfiles, without deleting
-msgid "Vim: Finished.\n"
-msgstr "Vim: .\n"
-
 msgid "ERROR: "
 msgstr ": "
 
@@ -4541,17 +4534,6 @@
 msgid "E245: Illegal char '%c' in font name \"%s\""
 msgstr "E245:   '%c'    \"%s\""
 
-msgid "Vim: Double signal, exiting\n"
-msgstr "Vim:  ,  \n"
-
-#, c-format
-msgid "Vim: Caught deadly signal %s\n"
-msgstr "Vim:    %s\n"
-
-#, c-format
-msgid "Vim: Caught deadly signal\n"
-msgstr "Vim:   \n"
-
 #, c-format
 msgid "Opening the X display took %ld msec"
 msgstr "  X  %ld msec"
@@ -4859,12 +4841,16 @@
 "E864:  \\%#=    0, 1  2.   "
 " "
 
+msgid "E865: (NFA) Regexp end encountered prematurely"
+msgstr "E865: ()    "
+
 #, c-format
 msgid "E866: (NFA regexp) Misplaced %c"
 msgstr "E866: (.  )  %c"
 
-msgid "E865: (NFA) Regexp end encountered prematurely"
-msgstr "E865: ()    "
+#, c-format
+msgid "E877: (NFA regexp) Invalid character class: %ld"
+msgstr "E877: (.  )   : %ld"
 
 #, c-format
 msgid "E867: (NFA) Unknown operator '\\z%c'"
@@ -5368,12 +5354,12 @@
 msgstr "E765: 'spellfile'   %ld "
 
 #, c-format
-msgid "Word removed from %s"
-msgstr "   %s"
+msgid "Word '%.*s' removed from %s"
+msgstr " '%.*s'   %s"
 
 #, c-format
-msgid "Word added to %s"
-msgstr "   %s"
+msgid "Word '%.*s' added to %s"
+msgstr " '%.*s'   %s"
 
 msgid "E763: Word characters differ between spell files"
 msgstr "E763:      "
@@ -5763,8 +5749,8 @@
 
 #. This happens when the FileChangedRO autocommand changes the
 #. * file in a way it becomes shorter.
-msgid "E834: Line count changed unexpectedly"
-msgstr "E834:    "
+msgid "E881: Line count changed unexpectedly"
+msgstr "E881:    "
 
 #. must display the prompt
 msgid "No undo possible; continue anyway"
@@ -6479,6 +6465,9 @@
 msgid "E37: No write since last change (add ! to override)"
 msgstr "E37:    ( !,   )"
 
+msgid "E37: No write since last change"
+msgstr "E37:   "
+
 msgid "E38: Null argument"
 msgstr "E38:  "
 
@@ -6678,7 +6667,7 @@
 msgid "value is too small to fit into C int type"
 msgstr "      C"
 
-msgid "number must be greater then zero"
+msgid "number must be greater than zero"
 msgstr "    "
 
 msgid "number must be greater or equal to zero"
@@ -6740,16 +6729,34 @@
 msgid "internal error: failed to get vim list item %d"
 msgstr " :     VIM- %d"
 
-msgid "failed to add item to list"
-msgstr "    "
+msgid "slice step cannot be zero"
+msgstr "     "
+
+#, c-format
+msgid "attempt to assign sequence of size greater than %d to extended slice"
+msgstr ""
+"      %d   "
+""
 
 #, c-format
 msgid "internal error: no vim list item %d"
 msgstr " :   VIM- %d"
 
+msgid "internal error: not enough list items"
+msgstr " :   "
+
 msgid "internal error: failed to add item to list"
 msgstr " :      "
 
+#, c-format
+msgid "attempt to assign sequence of size %d to extended slice of size %d"
+msgstr ""
+"    %d    "
+" %d"
+
+msgid "failed to add item to list"
+msgstr "    "
+
 msgid "cannot delete vim.List attributes"
 msgstr "   vim.List"
 
diff -Naur vim74.orig/src/po/sk.cp1250.po vim74/src/po/sk.cp1250.po
--- vim74.orig/src/po/sk.cp1250.po	2013-08-10 12:28:27.000000000 +0000
+++ vim74/src/po/sk.cp1250.po	2014-10-10 14:53:45.082045363 +0000
@@ -414,8 +414,8 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Porovnva mono iba Zoznam so Zoznamom (List with List)"
 
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: Neplatn opercia pre Zoznamy (Lists)"
+msgid "E692: Invalid operation for List"
+msgstr "E692: Neplatn opercia pre Zoznamy (List)"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
 msgstr "E735: Porovnva mono iba Slovnk so Slovnkom (Dictionary with Dictionary)"
diff -Naur vim74.orig/src/po/sk.po vim74/src/po/sk.po
--- vim74.orig/src/po/sk.po	2011-05-19 10:50:14.000000000 +0000
+++ vim74/src/po/sk.po	2014-10-10 14:53:45.092045338 +0000
@@ -414,8 +414,8 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Porovnva mono iba Zoznam so Zoznamom (List with List)"
 
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: Neplatn opercia pre Zoznamy (Lists)"
+msgid "E692: Invalid operation for List"
+msgstr "E692: Neplatn opercia pre Zoznamy (List)"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
 msgstr "E735: Porovnva mono iba Slovnk so Slovnkom (Dictionary with Dictionary)"
diff -Naur vim74.orig/src/po/sv.po vim74/src/po/sv.po
--- vim74.orig/src/po/sv.po	2011-05-19 10:50:27.000000000 +0000
+++ vim74/src/po/sv.po	2014-10-10 14:53:45.098711988 +0000
@@ -433,8 +433,8 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691: Kan bara jmfra Lista med Lista"
 
-msgid "E692: Invalid operation for Lists"
-msgstr "E692: Ogiltig operation fr Listor"
+msgid "E692: Invalid operation for List"
+msgstr "E692: Ogiltig operation fr Lista"
 
 msgid "E735: Can only compare Dictionary with Dictionary"
 msgstr "E735: Kan bara jmfra Tabell med Tabell"
diff -Naur vim74.orig/src/po/uk.cp1251.po vim74/src/po/uk.cp1251.po
--- vim74.orig/src/po/uk.cp1251.po	2013-08-10 12:28:27.000000000 +0000
+++ vim74/src/po/uk.cp1251.po	2014-10-10 14:53:45.108711962 +0000
@@ -2,19 +2,17 @@
 # Ukrainian Vim translation [uk]
 #
 # Copyright (C) 2001 Bohdan Vlasyuk <bohdan@vstu.edu.ua>
+# Bohdan donated this work to be distributed with Vim under the Vim license.
 #
 # Thanks to:
 #   Dmytro Kovalov <dmytro.kovalov@nssmb.com> for useful suggestions
 #   Dmytro O. Redchuk <dor@kiev-online.net> for viminfo bug
 #
-# Please, see readme at htpp://www.vstu.edu.ua/~bohdan/vim before any
-# complains, and even if you won't complain, read it anyway.
-#
 msgid ""
 msgstr ""
-"Project-Id-Version: vim 7.3\n"
+"Project-Id-Version: vim 7.4\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2013-01-17 10:06+0200\n"
+"POT-Creation-Date: 2013-09-29 09:05+0300\n"
 "PO-Revision-Date: 2010-06-18 21:53+0300\n"
 "Last-Translator:   <sakhnik@gmail.com>\n"
 "Language-Team: Bohdan Vlasyuk <bohdan@vstu.edu.ua>\n"
@@ -141,6 +139,9 @@
 msgid "[Read errors]"
 msgstr "[ ]"
 
+msgid "[RO]"
+msgstr "[RO]"
+
 msgid "[readonly]"
 msgstr "[ ]"
 
@@ -428,6 +429,10 @@
 msgid "E461: Illegal variable name: %s"
 msgstr "E461:   : %s"
 
+# msgstr "E373: "
+msgid "E806: using Float as a String"
+msgstr "E806: Float   String"
+
 msgid "E687: Less targets than List items"
 msgstr "E687:  ,   "
 
@@ -477,7 +482,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691:      "
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692:    "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
@@ -594,16 +599,16 @@
 msgid "&Ok"
 msgstr "&O:"
 
-# msgstr "E14: "
-msgid "extend() argument"
-msgstr " extend()"
-
 # msgstr "E226: "
 #, c-format
 msgid "E737: Key already exists: %s"
 msgstr "E737:   : %s"
 
 # msgstr "E14: "
+msgid "extend() argument"
+msgstr " extend()"
+
+# msgstr "E14: "
 msgid "map() argument"
 msgstr " map()"
 
@@ -710,10 +715,6 @@
 msgid "E731: using Dictionary as a String"
 msgstr "E731: Dictionary   String"
 
-# msgstr "E373: "
-msgid "E806: using Float as a String"
-msgstr "E806: Float   String"
-
 #, c-format
 msgid "E706: Variable type mismatch for: %s"
 msgstr "E706:   : %s"
@@ -752,6 +753,9 @@
 msgid "E124: Missing '(': %s"
 msgstr "E124:  '(': %s"
 
+msgid "E862: Cannot use g: here"
+msgstr "E862:     g:"
+
 #, c-format
 msgid "E125: Illegal argument: %s"
 msgstr "E125:  : %s"
@@ -1152,6 +1156,10 @@
 msgid "Pattern found in every line: %s"
 msgstr "    : %s"
 
+#, c-format
+msgid "Pattern not found: %s"
+msgstr "  : %s"
+
 msgid ""
 "\n"
 "# Last Substitute String:\n"
@@ -1332,7 +1340,8 @@
 msgstr "E183:       "
 
 msgid "E841: Reserved name, cannot be used for user defined command"
-msgstr "E841:  ,      "
+msgstr ""
+"E841:  ,      "
 
 # msgstr "E183: "
 #, c-format
@@ -1686,9 +1695,6 @@
 msgid "[character special]"
 msgstr "[. ]"
 
-msgid "[RO]"
-msgstr "[RO]"
-
 msgid "[CR missing]"
 msgstr "[ CR]"
 
@@ -1940,8 +1946,7 @@
 
 #, c-format
 msgid "W16: Warning: Mode of file \"%s\" has changed since editing started"
-msgstr ""
-"W16: :   %s    "
+msgstr "W16: :   %s    "
 
 msgid "See \":help W16\" for more info."
 msgstr ". :help W16  ."
@@ -2308,32 +2313,28 @@
 msgstr " '%s'   "
 
 #, c-format
-msgid "E253: Fontset name: %s\n"
-msgstr "E253:   : %s\n"
+msgid "E253: Fontset name: %s"
+msgstr "E253:   : %s"
 
 #, c-format
-msgid "Font0: %s\n"
-msgstr "0: %s\n"
+msgid "Font0: %s"
+msgstr "0: %s"
 
 #, c-format
-msgid "Font1: %s\n"
-msgstr "1: %s\n"
+msgid "Font1: %s"
+msgstr "1: %s"
 
 #, c-format
-msgid "Font%ld width is not twice that of font0\n"
-msgstr " %ld       0\n"
+msgid "Font%ld width is not twice that of font0"
+msgstr " %ld      0"
 
 #, c-format
-msgid "Font0 width: %ld\n"
-msgstr " 0: %ld\n"
+msgid "Font0 width: %ld"
+msgstr " 0: %ld"
 
 #, c-format
-msgid ""
-"Font1 width: %ld\n"
-"\n"
-msgstr ""
-" 1: %ld\n"
-"\n"
+msgid "Font1 width: %ld"
+msgstr " 1: %ld"
 
 msgid "Invalid font specification"
 msgstr "  "
@@ -2526,6 +2527,9 @@
 msgid "E622: Could not fork for cscope"
 msgstr "E622:      cscope"
 
+msgid "cs_create_connection setpgid failed"
+msgstr "cs_create_connection:  setpgid"
+
 msgid "cs_create_connection exec failed"
 msgstr "cs_create_connection:    "
 
@@ -2672,6 +2676,9 @@
 msgid "string cannot contain newlines"
 msgstr "   "
 
+msgid "error converting Scheme values to Vim"
+msgstr "    Scheme  Vim"
+
 msgid "Vim error: ~a"
 msgstr " Vim: ~a"
 
@@ -2693,9 +2700,6 @@
 msgid "E837: This Vim cannot execute :py3 after using :python"
 msgstr "E837: Python:    :py  :py3   "
 
-msgid "only string keys are allowed"
-msgstr "   "
-
 msgid ""
 "E263: Sorry, this command is disabled, the Python library could not be "
 "loaded."
@@ -2703,28 +2707,12 @@
 "E263: ,   ,  Python    "
 "."
 
-msgid "E860: Eval did not return a valid python 3 object"
-msgstr "E860: Eval     python 3"
-
-msgid "E861: Failed to convert returned python 3 object to vim value"
-msgstr "E861:     python 3   vim"
-
-#, c-format
-msgid "<buffer object (deleted) at %p>"
-msgstr "<'  ()   %p>"
-
 msgid "E836: This Vim cannot execute :python after using :py3"
 msgstr "E836: Python:    :py  :py3   "
 
 msgid "E659: Cannot invoke Python recursively"
 msgstr "E659:     Python"
 
-msgid "E858: Eval did not return a valid python object"
-msgstr "E858: Eval     python"
-
-msgid "E859: Failed to convert returned python object to vim value"
-msgstr "E859:     python   vim"
-
 msgid "E265: $_ must be an instance of String"
 msgstr "E265: $_    String"
 
@@ -2942,8 +2930,7 @@
 msgstr "   "
 
 msgid "Too many \"+command\", \"-c command\" or \"--cmd command\" arguments"
-msgstr ""
-"   +, -c   --cmd "
+msgstr "   +, -c   --cmd "
 
 # msgstr "E14: "
 msgid "Invalid argument for"
@@ -3483,8 +3470,7 @@
 # msgstr "E302: "
 #, c-format
 msgid "E303: Unable to open swap file for \"%s\", recovery impossible"
-msgstr ""
-"E303:       %s,  "
+msgstr "E303:       %s,  "
 
 msgid "E304: ml_upd_block0(): Didn't get block 0??"
 msgstr "E304: ml_upd_block0():   0??"
@@ -4092,13 +4078,6 @@
 msgid "Beep!"
 msgstr "!"
 
-msgid "Vim: preserving files...\n"
-msgstr "Vim:  ...\n"
-
-#. close all memfiles, without deleting
-msgid "Vim: Finished.\n"
-msgstr "Vim: .\n"
-
 msgid "ERROR: "
 msgstr ": "
 
@@ -4628,17 +4607,6 @@
 msgid "E245: Illegal char '%c' in font name \"%s\""
 msgstr "E245:   %c    %s"
 
-msgid "Vim: Double signal, exiting\n"
-msgstr "Vim:   , \n"
-
-#, c-format
-msgid "Vim: Caught deadly signal %s\n"
-msgstr "Vim:    (%s)\n"
-
-#, c-format
-msgid "Vim: Caught deadly signal\n"
-msgstr "Vim:   \n"
-
 #, c-format
 msgid "Opening the X display took %ld msec"
 msgstr "   X  %ld "
@@ -4861,19 +4829,9 @@
 msgid "E369: invalid item in %s%%[]"
 msgstr "E369:    %s%%[]"
 
-# msgstr "E382: "
-msgid "E339: Pattern too long"
-msgstr "E339:   "
-
-msgid "E50: Too many \\z("
-msgstr "E50:  \\z("
-
 #, c-format
-msgid "E51: Too many %s("
-msgstr "E51:  %s("
-
-msgid "E52: Unmatched \\z("
-msgstr "E52:   \\z("
+msgid "E769: Missing ] after %s["
+msgstr "E769:  ]  %s["
 
 #, c-format
 msgid "E53: Unmatched %s%%("
@@ -4887,6 +4845,36 @@
 msgid "E55: Unmatched %s)"
 msgstr "E55:   %s)"
 
+# msgstr "E406: "
+msgid "E66: \\z( not allowed here"
+msgstr "E66: \\z(   "
+
+# msgstr "E406: "
+msgid "E67: \\z1 et al. not allowed here"
+msgstr "E67: \\z1  .   "
+
+#, c-format
+msgid "E69: Missing ] after %s%%["
+msgstr "E69:  ]  %s%%["
+
+#, c-format
+msgid "E70: Empty %s%%[]"
+msgstr "E70: %s%%[] "
+
+# msgstr "E382: "
+msgid "E339: Pattern too long"
+msgstr "E339:   "
+
+msgid "E50: Too many \\z("
+msgstr "E50:  \\z("
+
+#, c-format
+msgid "E51: Too many %s("
+msgstr "E51:  %s("
+
+msgid "E52: Unmatched \\z("
+msgstr "E52:   \\z("
+
 #, c-format
 msgid "E59: invalid character after %s@"
 msgstr "E59:    %s@"
@@ -4916,26 +4904,10 @@
 msgid "E65: Illegal back reference"
 msgstr "E65:   "
 
-# msgstr "E406: "
-msgid "E66: \\z( not allowed here"
-msgstr "E66: \\z(   "
-
-# msgstr "E406: "
-msgid "E67: \\z1 et al. not allowed here"
-msgstr "E67: \\z1  .   "
-
 msgid "E68: Invalid character after \\z"
 msgstr "E68:    \\z"
 
 #, c-format
-msgid "E69: Missing ] after %s%%["
-msgstr "E69:  ]  %s%%["
-
-#, c-format
-msgid "E70: Empty %s%%[]"
-msgstr "E70: %s%%[] "
-
-#, c-format
 msgid "E678: Invalid character after %s%%[dxouU]"
 msgstr "E678:    %s%%[dxouU]"
 
@@ -4943,10 +4915,6 @@
 msgid "E71: Invalid character after %s%%"
 msgstr "E71:    %s%%"
 
-#, c-format
-msgid "E769: Missing ] after %s["
-msgstr "E769:  ]  %s["
-
 # msgstr "E64: "
 #, c-format
 msgid "E554: Syntax error in %s{...}"
@@ -4955,6 +4923,80 @@
 msgid "External submatches:\n"
 msgstr " -:\n"
 
+msgid ""
+"E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be "
+"used "
+msgstr ""
+"E864:  \\%#=    0, 1, or 2.     "
+
+#, c-format
+msgid "E866: (NFA regexp) Misplaced %c"
+msgstr "E866: (NFA regexp)    %c"
+
+msgid "E865: (NFA) Regexp end encountered prematurely"
+msgstr "E865: (NFA)     "
+
+#, c-format
+msgid "E867: (NFA) Unknown operator '\\z%c'"
+msgstr "E867: (NFA)   '\\z%c'"
+
+#, c-format
+msgid "E867: (NFA) Unknown operator '\\%%%c'"
+msgstr "E867: (NFA)   '\\%%%c'"
+
+#. should never happen
+msgid "E868: Error building NFA with equivalence class!"
+msgstr "E868:    NFA   !"
+
+#, c-format
+msgid "E869: (NFA) Unknown operator '\\@%c'"
+msgstr "E869: (NFA)   '\\@%c'"
+
+msgid "E870: (NFA regexp) Error reading repetition limits"
+msgstr "E870: (NFA regexp)     "
+
+#. Can't have a multi follow a multi.
+msgid "E871: (NFA regexp) Can't have a multi follow a multi !"
+msgstr "E871: (NFA regexp)      !"
+
+#. Too many `('
+msgid "E872: (NFA regexp) Too many '('"
+msgstr "E872: (NFA regexp)  '('"
+
+msgid "E879: (NFA regexp) Too many \\z("
+msgstr "E879: (NFA regexp)  \\z("
+
+msgid "E873: (NFA regexp) proper termination error"
+msgstr "E873: (NFA regexp)   "
+
+msgid "E874: (NFA) Could not pop the stack !"
+msgstr "E874: (NFA)  !"
+
+msgid ""
+"E875: (NFA regexp) (While converting from postfix to NFA), too many states "
+"left on stack"
+msgstr ""
+"E875: (NFA regexp) (      NFA)  "
+"   "
+
+msgid "E876: (NFA regexp) Not enough space to store the whole NFA "
+msgstr "E876: (NFA regexp)  ,    NFA "
+
+msgid "E878: (NFA) Could not allocate memory for branch traversal!"
+msgstr "E878: (NFA)       !"
+
+msgid ""
+"Could not open temporary log file for writing, displaying on stderr ... "
+msgstr ""
+"       ,   stderr ... "
+
+#, c-format
+msgid "(NFA) COULD NOT OPEN %s !"
+msgstr "(NFA)    %s!"
+
+msgid "Could not open temporary log file for writing "
+msgstr "        "
+
 msgid " VREPLACE"
 msgstr "  "
 
@@ -5110,7 +5152,8 @@
 
 #, c-format
 msgid "Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""
-msgstr ":      %s_%s.spl  %s_ascii.spl"
+msgstr ""
+":      %s_%s.spl  %s_ascii.spl"
 
 #, c-format
 msgid "Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""
@@ -5396,12 +5439,12 @@
 msgstr "E765: 'spellfile'   %ld "
 
 #, c-format
-msgid "Word removed from %s"
-msgstr "   %s"
+msgid "Word '%.*s' removed from %s"
+msgstr " '%.*s'   %s"
 
 #, c-format
-msgid "Word added to %s"
-msgstr "   %s"
+msgid "Word '%.*s' added to %s"
+msgstr " '%.*s'   %s"
 
 msgid "E763: Word characters differ between spell files"
 msgstr "E763:       "
@@ -5457,6 +5500,10 @@
 msgid "E783: duplicate char in MAP entry"
 msgstr "E783:     MAP"
 
+# msgstr "E391: "
+msgid "No Syntax items defined for this buffer"
+msgstr "     "
+
 #, c-format
 msgid "E390: Illegal argument: %s"
 msgstr "E390:  : %s"
@@ -5465,10 +5512,6 @@
 msgid "E391: No such syntax cluster: %s"
 msgstr "E391:    : %s"
 
-# msgstr "E391: "
-msgid "No Syntax items defined for this buffer"
-msgstr "     "
-
 msgid "syncing on C-style comments"
 msgstr "    "
 
@@ -5603,6 +5646,11 @@
 msgid "E410: Invalid :syntax subcommand: %s"
 msgstr "E410:   :syntax: %s"
 
+msgid ""
+"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN"
+msgstr ""
+"       -   .  .   .                 "
+
 msgid "E679: recursive loop loading syncolor.vim"
 msgstr "E679:    syncolor.vim"
 
@@ -6734,112 +6782,246 @@
 msgid "Need encryption key for \"%s\""
 msgstr " %s  : "
 
+# msgstr "E406: "
+msgid "empty keys are not allowed"
+msgstr "   "
+
+msgid "dictionary is locked"
+msgstr " "
+
+msgid "list is locked"
+msgstr " "
+
+#, c-format
+msgid "failed to add key '%s' to dictionary"
+msgstr "    '%s'  "
+
+#, c-format
+msgid "index must be int or slice, not %s"
+msgstr "     ,  %s"
+
+#, c-format
+msgid "expected str() or unicode() instance, but got %s"
+msgstr "  str()  unicode(),   %s"
+
+#, c-format
+msgid "expected bytes() or str() instance, but got %s"
+msgstr "  bytes()  str(),   %s"
+
+#, c-format
+msgid ""
+"expected int(), long() or something supporting coercing to long(), but got %s"
+msgstr ""
+" int(), long()  ,     long(),   %s"
+
+#, c-format
+msgid "expected int() or something supporting coercing to int(), but got %s"
+msgstr " int()  ,     int(),   %s"
+
+msgid "value is too large to fit into C int type"
+msgstr " ,     C int"
+
+msgid "value is too small to fit into C int type"
+msgstr " ,     C int"
+
+msgid "number must be greater then zero"
+msgstr "   ,  "
+
+msgid "number must be greater or equal to zero"
+msgstr "    ,  "
+
 msgid "can't delete OutputObject attributes"
 msgstr "    OutputObject"
 
-msgid "softspace must be an integer"
-msgstr "softspace   "
-
 # msgstr "E180: "
-msgid "invalid attribute"
-msgstr " "
-
-msgid "writelines() requires list of strings"
-msgstr " writelines()   "
+#, c-format
+msgid "invalid attribute: %s"
+msgstr " : %s"
 
 msgid "E264: Python: Error initialising I/O objects"
 msgstr "E264: Python:   ' /"
 
-msgid "no such buffer"
-msgstr "  "
+msgid "failed to change directory"
+msgstr "   "
 
-# msgstr "E406: "
-msgid "empty keys are not allowed"
-msgstr "   "
+#, c-format
+msgid "expected 3-tuple as imp.find_module() result, but got %s"
+msgstr " 3-   imp.find_module(),   %s"
 
-msgid "failed to add key to dictionary"
-msgstr "     "
+#, c-format
+msgid "expected 3-tuple as imp.find_module() result, but got tuple of size %d"
+msgstr " 3-   imp.find_module(),   %d"
 
-msgid "Cannot delete DictionaryObject attributes"
-msgstr "    DictionaryObject"
+msgid "internal error: imp.find_module returned tuple with NULL"
+msgstr " : imp.find_module    NULL"
 
-msgid "Cannot modify fixed dictionary"
-msgstr "    "
+msgid "cannot delete vim.Dictionary attributes"
+msgstr "    vim.Dictionary"
 
-msgid "Only boolean objects are allowed"
-msgstr "   "
+msgid "cannot modify fixed dictionary"
+msgstr "    "
 
-msgid "Cannot set this attribute"
-msgstr "    "
+#, c-format
+msgid "cannot set attribute %s"
+msgstr "    %s"
 
-msgid "no such key in dictionary"
-msgstr "    "
+msgid "hashtab changed during iteration"
+msgstr "-    "
 
-msgid "dict is locked"
-msgstr " "
+#, c-format
+msgid "expected sequence element of size 2, but got sequence of size %d"
+msgstr "   2,     %d"
 
-msgid "internal error: failed to get vim list item"
-msgstr " :      vim"
+msgid "list constructor does not accept keyword arguments"
+msgstr "     "
 
-msgid "list is locked"
-msgstr " "
+msgid "list index out of range"
+msgstr "   "
 
-msgid "Failed to add item to list"
-msgstr "     "
+#. No more suitable format specifications in python-2.3
+#, c-format
+msgid "internal error: failed to get vim list item %d"
+msgstr " :      vim %d"
 
-msgid "internal error: no vim list item"
-msgstr " :    vim"
+msgid "failed to add item to list"
+msgstr "     "
 
-msgid "can only assign lists to slice"
-msgstr "    "
+#, c-format
+msgid "internal error: no vim list item %d"
+msgstr " :    vim %d"
 
 msgid "internal error: failed to add item to list"
 msgstr " :      "
 
-msgid "can only concatenate with lists"
-msgstr "    "
+msgid "cannot delete vim.List attributes"
+msgstr "    vim.List"
+
+msgid "cannot modify fixed list"
+msgstr "    "
+
+# msgstr "E428: "
+#, c-format
+msgid "unnamed function %s does not exist"
+msgstr "  %s  "
+
+# msgstr "E428: "
+#, c-format
+msgid "function %s does not exist"
+msgstr " %s  "
+
+msgid "function constructor does not accept keyword arguments"
+msgstr "     "
+
+#, c-format
+msgid "failed to run function %s"
+msgstr "    %s"
+
+msgid "unable to get option value"
+msgstr "    "
+
+msgid "internal error: unknown option type"
+msgstr " :   "
+
+msgid "problem while switching windows"
+msgstr "   "
+
+#, c-format
+msgid "unable to unset global option %s"
+msgstr "     %s"
 
-msgid "Cannot modify fixed list"
-msgstr "    "
+#, c-format
+msgid "unable to unset option %s which does not have global value"
+msgstr "    %s,     "
 
-msgid "'self' argument must be a dictionary"
-msgstr " self   "
+msgid "attempt to refer to deleted tab page"
+msgstr "    "
 
-msgid "failed to run function"
-msgstr "   "
+msgid "no such tab page"
+msgstr "  "
 
 msgid "attempt to refer to deleted window"
 msgstr "    "
 
-msgid "readonly attribute"
-msgstr "  "
+msgid "readonly attribute: buffer"
+msgstr "   : "
 
 msgid "cursor position outside buffer"
 msgstr "   "
 
+msgid "no such window"
+msgstr "  "
+
+msgid "attempt to refer to deleted buffer"
+msgstr "    "
+
+msgid "failed to rename buffer"
+msgstr "   "
+
+msgid "mark name must be a single character"
+msgstr "     "
+
 #, c-format
-msgid "<window object (deleted) at %p>"
-msgstr "<'  ()   %p>"
+msgid "expected vim.Buffer object, but got %s"
+msgstr "  vim.Buffer,   %s"
 
 #, c-format
-msgid "<window object (unknown) at %p>"
-msgstr "<'  ()   %p>"
+msgid "failed to switch to buffer %d"
+msgstr "     %d"
 
 #, c-format
-msgid "<window %d>"
-msgstr "< %d>"
+msgid "expected vim.Window object, but got %s"
+msgstr "  vim.Window,   %s"
 
-msgid "no such window"
-msgstr "  "
+msgid "failed to find window in the current tab page"
+msgstr "      "
 
-msgid "attempt to refer to deleted buffer"
-msgstr "    "
+msgid "did not switch to the specified window"
+msgstr "    "
+
+#, c-format
+msgid "expected vim.TabPage object, but got %s"
+msgstr "  vim.TabPage,   %s"
 
-msgid "unable to convert to vim structure"
-msgstr "     vim"
+msgid "did not switch to the specified tab page"
+msgstr "    "
 
-msgid "NULL reference passed"
-msgstr "  NULL"
+msgid "failed to run the code"
+msgstr "   "
+
+msgid "E858: Eval did not return a valid python object"
+msgstr "E858: Eval     python"
+
+msgid "E859: Failed to convert returned python object to vim value"
+msgstr "E859:     python   vim"
+
+#, c-format
+msgid "unable to convert %s to vim dictionary"
+msgstr "   %s   vim"
+
+#, c-format
+msgid "unable to convert %s to vim structure"
+msgstr "   %s   vim"
+
+msgid "internal error: NULL reference passed"
+msgstr " :   NULL"
 
 msgid "internal error: invalid value type"
 msgstr " :   "
+
+msgid ""
+"Failed to set path hook: sys.path_hooks is not a list\n"
+"You should now do the following:\n"
+"- append vim.path_hook to sys.path_hooks\n"
+"- append vim.VIM_SPECIAL_PATH to sys.path\n"
+msgstr ""
+"    : sys.path_hooks  \n"
+"   :\n"
+"-  vim.path_hook  sys.path_hooks\n"
+"-  vim.VIM_SPECIAL_PATH  sys.path\n"
+
+msgid ""
+"Failed to set path: sys.path is not a list\n"
+"You should now append vim.VIM_SPECIAL_PATH to sys.path"
+msgstr ""
+"   : sys.path  \n"
+"   vim.VIM_SPECIAL_PATH  sys.path"
diff -Naur vim74.orig/src/po/uk.po vim74/src/po/uk.po
--- vim74.orig/src/po/uk.po	2013-01-17 12:11:55.000000000 +0000
+++ vim74/src/po/uk.po	2014-10-10 14:53:45.122045262 +0000
@@ -2,19 +2,17 @@
 # Ukrainian Vim translation [uk]
 #
 # Copyright (C) 2001 Bohdan Vlasyuk <bohdan@vstu.edu.ua>
+# Bohdan donated this work to be distributed with Vim under the Vim license.
 #
 # Thanks to:
 #   Dmytro Kovalov <dmytro.kovalov@nssmb.com> for useful suggestions
 #   Dmytro O. Redchuk <dor@kiev-online.net> for viminfo bug
 #
-# Please, see readme at htpp://www.vstu.edu.ua/~bohdan/vim before any
-# complains, and even if you won't complain, read it anyway.
-#
 msgid ""
 msgstr ""
-"Project-Id-Version: vim 7.3\n"
+"Project-Id-Version: vim 7.4\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2013-01-17 10:06+0200\n"
+"POT-Creation-Date: 2013-09-29 09:05+0300\n"
 "PO-Revision-Date: 2010-06-18 21:53+0300\n"
 "Last-Translator:   <sakhnik@gmail.com>\n"
 "Language-Team: Bohdan Vlasyuk <bohdan@vstu.edu.ua>\n"
@@ -141,6 +139,9 @@
 msgid "[Read errors]"
 msgstr "[ ]"
 
+msgid "[RO]"
+msgstr "[RO]"
+
 msgid "[readonly]"
 msgstr "[ ]"
 
@@ -428,6 +429,10 @@
 msgid "E461: Illegal variable name: %s"
 msgstr "E461:   : %s"
 
+# msgstr "E373: "
+msgid "E806: using Float as a String"
+msgstr "E806: Float   String"
+
 msgid "E687: Less targets than List items"
 msgstr "E687:  ,   "
 
@@ -477,7 +482,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691:      "
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692:    "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
@@ -594,16 +599,16 @@
 msgid "&Ok"
 msgstr "&O:"
 
-# msgstr "E14: "
-msgid "extend() argument"
-msgstr " extend()"
-
 # msgstr "E226: "
 #, c-format
 msgid "E737: Key already exists: %s"
 msgstr "E737:   : %s"
 
 # msgstr "E14: "
+msgid "extend() argument"
+msgstr " extend()"
+
+# msgstr "E14: "
 msgid "map() argument"
 msgstr " map()"
 
@@ -710,10 +715,6 @@
 msgid "E731: using Dictionary as a String"
 msgstr "E731: Dictionary   String"
 
-# msgstr "E373: "
-msgid "E806: using Float as a String"
-msgstr "E806: Float   String"
-
 #, c-format
 msgid "E706: Variable type mismatch for: %s"
 msgstr "E706:   : %s"
@@ -752,6 +753,9 @@
 msgid "E124: Missing '(': %s"
 msgstr "E124:  '(': %s"
 
+msgid "E862: Cannot use g: here"
+msgstr "E862:     g:"
+
 #, c-format
 msgid "E125: Illegal argument: %s"
 msgstr "E125:  : %s"
@@ -1152,6 +1156,10 @@
 msgid "Pattern found in every line: %s"
 msgstr "    : %s"
 
+#, c-format
+msgid "Pattern not found: %s"
+msgstr "  : %s"
+
 msgid ""
 "\n"
 "# Last Substitute String:\n"
@@ -1332,7 +1340,8 @@
 msgstr "E183:       "
 
 msgid "E841: Reserved name, cannot be used for user defined command"
-msgstr "E841:  ,      "
+msgstr ""
+"E841:  ,      "
 
 # msgstr "E183: "
 #, c-format
@@ -1686,9 +1695,6 @@
 msgid "[character special]"
 msgstr "[. ]"
 
-msgid "[RO]"
-msgstr "[RO]"
-
 msgid "[CR missing]"
 msgstr "[ CR]"
 
@@ -1940,8 +1946,7 @@
 
 #, c-format
 msgid "W16: Warning: Mode of file \"%s\" has changed since editing started"
-msgstr ""
-"W16: :   %s    "
+msgstr "W16: :   %s    "
 
 msgid "See \":help W16\" for more info."
 msgstr ". :help W16  ."
@@ -2308,32 +2313,28 @@
 msgstr " '%s'   "
 
 #, c-format
-msgid "E253: Fontset name: %s\n"
-msgstr "E253:   : %s\n"
+msgid "E253: Fontset name: %s"
+msgstr "E253:   : %s"
 
 #, c-format
-msgid "Font0: %s\n"
-msgstr "0: %s\n"
+msgid "Font0: %s"
+msgstr "0: %s"
 
 #, c-format
-msgid "Font1: %s\n"
-msgstr "1: %s\n"
+msgid "Font1: %s"
+msgstr "1: %s"
 
 #, c-format
-msgid "Font%ld width is not twice that of font0\n"
-msgstr " %ld       0\n"
+msgid "Font%ld width is not twice that of font0"
+msgstr " %ld      0"
 
 #, c-format
-msgid "Font0 width: %ld\n"
-msgstr " 0: %ld\n"
+msgid "Font0 width: %ld"
+msgstr " 0: %ld"
 
 #, c-format
-msgid ""
-"Font1 width: %ld\n"
-"\n"
-msgstr ""
-" 1: %ld\n"
-"\n"
+msgid "Font1 width: %ld"
+msgstr " 1: %ld"
 
 msgid "Invalid font specification"
 msgstr "  "
@@ -2526,6 +2527,9 @@
 msgid "E622: Could not fork for cscope"
 msgstr "E622:      cscope"
 
+msgid "cs_create_connection setpgid failed"
+msgstr "cs_create_connection:  setpgid"
+
 msgid "cs_create_connection exec failed"
 msgstr "cs_create_connection:    "
 
@@ -2672,6 +2676,9 @@
 msgid "string cannot contain newlines"
 msgstr "   "
 
+msgid "error converting Scheme values to Vim"
+msgstr "    Scheme  Vim"
+
 msgid "Vim error: ~a"
 msgstr " Vim: ~a"
 
@@ -2693,9 +2700,6 @@
 msgid "E837: This Vim cannot execute :py3 after using :python"
 msgstr "E837: Python:    :py  :py3   "
 
-msgid "only string keys are allowed"
-msgstr "   "
-
 msgid ""
 "E263: Sorry, this command is disabled, the Python library could not be "
 "loaded."
@@ -2703,28 +2707,12 @@
 "E263: ,   ,  Python    "
 "."
 
-msgid "E860: Eval did not return a valid python 3 object"
-msgstr "E860: Eval     python 3"
-
-msgid "E861: Failed to convert returned python 3 object to vim value"
-msgstr "E861:     python 3   vim"
-
-#, c-format
-msgid "<buffer object (deleted) at %p>"
-msgstr "<'  ()   %p>"
-
 msgid "E836: This Vim cannot execute :python after using :py3"
 msgstr "E836: Python:    :py  :py3   "
 
 msgid "E659: Cannot invoke Python recursively"
 msgstr "E659:     Python"
 
-msgid "E858: Eval did not return a valid python object"
-msgstr "E858: Eval     python"
-
-msgid "E859: Failed to convert returned python object to vim value"
-msgstr "E859:     python   vim"
-
 msgid "E265: $_ must be an instance of String"
 msgstr "E265: $_    String"
 
@@ -2942,8 +2930,7 @@
 msgstr "   "
 
 msgid "Too many \"+command\", \"-c command\" or \"--cmd command\" arguments"
-msgstr ""
-"   +, -c   --cmd "
+msgstr "   +, -c   --cmd "
 
 # msgstr "E14: "
 msgid "Invalid argument for"
@@ -3483,8 +3470,7 @@
 # msgstr "E302: "
 #, c-format
 msgid "E303: Unable to open swap file for \"%s\", recovery impossible"
-msgstr ""
-"E303:       %s,  "
+msgstr "E303:       %s,  "
 
 msgid "E304: ml_upd_block0(): Didn't get block 0??"
 msgstr "E304: ml_upd_block0():   0??"
@@ -4092,13 +4078,6 @@
 msgid "Beep!"
 msgstr "!"
 
-msgid "Vim: preserving files...\n"
-msgstr "Vim:  ...\n"
-
-#. close all memfiles, without deleting
-msgid "Vim: Finished.\n"
-msgstr "Vim: .\n"
-
 msgid "ERROR: "
 msgstr ": "
 
@@ -4628,17 +4607,6 @@
 msgid "E245: Illegal char '%c' in font name \"%s\""
 msgstr "E245:   %c    %s"
 
-msgid "Vim: Double signal, exiting\n"
-msgstr "Vim:   , \n"
-
-#, c-format
-msgid "Vim: Caught deadly signal %s\n"
-msgstr "Vim:    (%s)\n"
-
-#, c-format
-msgid "Vim: Caught deadly signal\n"
-msgstr "Vim:   \n"
-
 #, c-format
 msgid "Opening the X display took %ld msec"
 msgstr "   X  %ld "
@@ -4861,19 +4829,9 @@
 msgid "E369: invalid item in %s%%[]"
 msgstr "E369:    %s%%[]"
 
-# msgstr "E382: "
-msgid "E339: Pattern too long"
-msgstr "E339:   "
-
-msgid "E50: Too many \\z("
-msgstr "E50:  \\z("
-
 #, c-format
-msgid "E51: Too many %s("
-msgstr "E51:  %s("
-
-msgid "E52: Unmatched \\z("
-msgstr "E52:   \\z("
+msgid "E769: Missing ] after %s["
+msgstr "E769:  ]  %s["
 
 #, c-format
 msgid "E53: Unmatched %s%%("
@@ -4887,6 +4845,36 @@
 msgid "E55: Unmatched %s)"
 msgstr "E55:   %s)"
 
+# msgstr "E406: "
+msgid "E66: \\z( not allowed here"
+msgstr "E66: \\z(   "
+
+# msgstr "E406: "
+msgid "E67: \\z1 et al. not allowed here"
+msgstr "E67: \\z1  .   "
+
+#, c-format
+msgid "E69: Missing ] after %s%%["
+msgstr "E69:  ]  %s%%["
+
+#, c-format
+msgid "E70: Empty %s%%[]"
+msgstr "E70: %s%%[] "
+
+# msgstr "E382: "
+msgid "E339: Pattern too long"
+msgstr "E339:   "
+
+msgid "E50: Too many \\z("
+msgstr "E50:  \\z("
+
+#, c-format
+msgid "E51: Too many %s("
+msgstr "E51:  %s("
+
+msgid "E52: Unmatched \\z("
+msgstr "E52:   \\z("
+
 #, c-format
 msgid "E59: invalid character after %s@"
 msgstr "E59:    %s@"
@@ -4916,26 +4904,10 @@
 msgid "E65: Illegal back reference"
 msgstr "E65:   "
 
-# msgstr "E406: "
-msgid "E66: \\z( not allowed here"
-msgstr "E66: \\z(   "
-
-# msgstr "E406: "
-msgid "E67: \\z1 et al. not allowed here"
-msgstr "E67: \\z1  .   "
-
 msgid "E68: Invalid character after \\z"
 msgstr "E68:    \\z"
 
 #, c-format
-msgid "E69: Missing ] after %s%%["
-msgstr "E69:  ]  %s%%["
-
-#, c-format
-msgid "E70: Empty %s%%[]"
-msgstr "E70: %s%%[] "
-
-#, c-format
 msgid "E678: Invalid character after %s%%[dxouU]"
 msgstr "E678:    %s%%[dxouU]"
 
@@ -4943,10 +4915,6 @@
 msgid "E71: Invalid character after %s%%"
 msgstr "E71:    %s%%"
 
-#, c-format
-msgid "E769: Missing ] after %s["
-msgstr "E769:  ]  %s["
-
 # msgstr "E64: "
 #, c-format
 msgid "E554: Syntax error in %s{...}"
@@ -4955,6 +4923,80 @@
 msgid "External submatches:\n"
 msgstr " -:\n"
 
+msgid ""
+"E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be "
+"used "
+msgstr ""
+"E864:  \\%#=    0, 1, or 2.     "
+
+#, c-format
+msgid "E866: (NFA regexp) Misplaced %c"
+msgstr "E866: (NFA regexp)    %c"
+
+msgid "E865: (NFA) Regexp end encountered prematurely"
+msgstr "E865: (NFA)     "
+
+#, c-format
+msgid "E867: (NFA) Unknown operator '\\z%c'"
+msgstr "E867: (NFA)   '\\z%c'"
+
+#, c-format
+msgid "E867: (NFA) Unknown operator '\\%%%c'"
+msgstr "E867: (NFA)   '\\%%%c'"
+
+#. should never happen
+msgid "E868: Error building NFA with equivalence class!"
+msgstr "E868:    NFA   !"
+
+#, c-format
+msgid "E869: (NFA) Unknown operator '\\@%c'"
+msgstr "E869: (NFA)   '\\@%c'"
+
+msgid "E870: (NFA regexp) Error reading repetition limits"
+msgstr "E870: (NFA regexp)     "
+
+#. Can't have a multi follow a multi.
+msgid "E871: (NFA regexp) Can't have a multi follow a multi !"
+msgstr "E871: (NFA regexp)      !"
+
+#. Too many `('
+msgid "E872: (NFA regexp) Too many '('"
+msgstr "E872: (NFA regexp)  '('"
+
+msgid "E879: (NFA regexp) Too many \\z("
+msgstr "E879: (NFA regexp)  \\z("
+
+msgid "E873: (NFA regexp) proper termination error"
+msgstr "E873: (NFA regexp)   "
+
+msgid "E874: (NFA) Could not pop the stack !"
+msgstr "E874: (NFA)  !"
+
+msgid ""
+"E875: (NFA regexp) (While converting from postfix to NFA), too many states "
+"left on stack"
+msgstr ""
+"E875: (NFA regexp) (      NFA)  "
+"   "
+
+msgid "E876: (NFA regexp) Not enough space to store the whole NFA "
+msgstr "E876: (NFA regexp)  ,    NFA "
+
+msgid "E878: (NFA) Could not allocate memory for branch traversal!"
+msgstr "E878: (NFA)       !"
+
+msgid ""
+"Could not open temporary log file for writing, displaying on stderr ... "
+msgstr ""
+"       ,   stderr ... "
+
+#, c-format
+msgid "(NFA) COULD NOT OPEN %s !"
+msgstr "(NFA)    %s!"
+
+msgid "Could not open temporary log file for writing "
+msgstr "        "
+
 msgid " VREPLACE"
 msgstr "  "
 
@@ -5110,7 +5152,8 @@
 
 #, c-format
 msgid "Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""
-msgstr ":      %s_%s.spl  %s_ascii.spl"
+msgstr ""
+":      %s_%s.spl  %s_ascii.spl"
 
 #, c-format
 msgid "Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""
@@ -5396,12 +5439,12 @@
 msgstr "E765: 'spellfile'   %ld "
 
 #, c-format
-msgid "Word removed from %s"
-msgstr "   %s"
+msgid "Word '%.*s' removed from %s"
+msgstr " '%.*s'   %s"
 
 #, c-format
-msgid "Word added to %s"
-msgstr "   %s"
+msgid "Word '%.*s' added to %s"
+msgstr " '%.*s'   %s"
 
 msgid "E763: Word characters differ between spell files"
 msgstr "E763:       "
@@ -5457,6 +5500,10 @@
 msgid "E783: duplicate char in MAP entry"
 msgstr "E783:     MAP"
 
+# msgstr "E391: "
+msgid "No Syntax items defined for this buffer"
+msgstr "     "
+
 #, c-format
 msgid "E390: Illegal argument: %s"
 msgstr "E390:  : %s"
@@ -5465,10 +5512,6 @@
 msgid "E391: No such syntax cluster: %s"
 msgstr "E391:    : %s"
 
-# msgstr "E391: "
-msgid "No Syntax items defined for this buffer"
-msgstr "     "
-
 msgid "syncing on C-style comments"
 msgstr "    "
 
@@ -5603,6 +5646,11 @@
 msgid "E410: Invalid :syntax subcommand: %s"
 msgstr "E410:   :syntax: %s"
 
+msgid ""
+"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN"
+msgstr ""
+"       -   .  .   .                 "
+
 msgid "E679: recursive loop loading syncolor.vim"
 msgstr "E679:    syncolor.vim"
 
@@ -6734,112 +6782,246 @@
 msgid "Need encryption key for \"%s\""
 msgstr " %s  : "
 
+# msgstr "E406: "
+msgid "empty keys are not allowed"
+msgstr "   "
+
+msgid "dictionary is locked"
+msgstr " "
+
+msgid "list is locked"
+msgstr " "
+
+#, c-format
+msgid "failed to add key '%s' to dictionary"
+msgstr "    '%s'  "
+
+#, c-format
+msgid "index must be int or slice, not %s"
+msgstr "     ,  %s"
+
+#, c-format
+msgid "expected str() or unicode() instance, but got %s"
+msgstr "  str()  unicode(),   %s"
+
+#, c-format
+msgid "expected bytes() or str() instance, but got %s"
+msgstr "  bytes()  str(),   %s"
+
+#, c-format
+msgid ""
+"expected int(), long() or something supporting coercing to long(), but got %s"
+msgstr ""
+" int(), long()  ,     long(),   %s"
+
+#, c-format
+msgid "expected int() or something supporting coercing to int(), but got %s"
+msgstr " int()  ,     int(),   %s"
+
+msgid "value is too large to fit into C int type"
+msgstr " ,     C int"
+
+msgid "value is too small to fit into C int type"
+msgstr " ,     C int"
+
+msgid "number must be greater then zero"
+msgstr "   ,  "
+
+msgid "number must be greater or equal to zero"
+msgstr "    ,  "
+
 msgid "can't delete OutputObject attributes"
 msgstr "    OutputObject"
 
-msgid "softspace must be an integer"
-msgstr "softspace   "
-
 # msgstr "E180: "
-msgid "invalid attribute"
-msgstr " "
-
-msgid "writelines() requires list of strings"
-msgstr " writelines()   "
+#, c-format
+msgid "invalid attribute: %s"
+msgstr " : %s"
 
 msgid "E264: Python: Error initialising I/O objects"
 msgstr "E264: Python:   ' /"
 
-msgid "no such buffer"
-msgstr "  "
+msgid "failed to change directory"
+msgstr "   "
 
-# msgstr "E406: "
-msgid "empty keys are not allowed"
-msgstr "   "
+#, c-format
+msgid "expected 3-tuple as imp.find_module() result, but got %s"
+msgstr " 3-   imp.find_module(),   %s"
 
-msgid "failed to add key to dictionary"
-msgstr "     "
+#, c-format
+msgid "expected 3-tuple as imp.find_module() result, but got tuple of size %d"
+msgstr " 3-   imp.find_module(),   %d"
 
-msgid "Cannot delete DictionaryObject attributes"
-msgstr "    DictionaryObject"
+msgid "internal error: imp.find_module returned tuple with NULL"
+msgstr " : imp.find_module    NULL"
 
-msgid "Cannot modify fixed dictionary"
-msgstr "    "
+msgid "cannot delete vim.Dictionary attributes"
+msgstr "    vim.Dictionary"
 
-msgid "Only boolean objects are allowed"
-msgstr "   "
+msgid "cannot modify fixed dictionary"
+msgstr "    "
 
-msgid "Cannot set this attribute"
-msgstr "    "
+#, c-format
+msgid "cannot set attribute %s"
+msgstr "    %s"
 
-msgid "no such key in dictionary"
-msgstr "    "
+msgid "hashtab changed during iteration"
+msgstr "-    "
 
-msgid "dict is locked"
-msgstr " "
+#, c-format
+msgid "expected sequence element of size 2, but got sequence of size %d"
+msgstr "   2,     %d"
 
-msgid "internal error: failed to get vim list item"
-msgstr " :      vim"
+msgid "list constructor does not accept keyword arguments"
+msgstr "     "
 
-msgid "list is locked"
-msgstr " "
+msgid "list index out of range"
+msgstr "   "
 
-msgid "Failed to add item to list"
-msgstr "     "
+#. No more suitable format specifications in python-2.3
+#, c-format
+msgid "internal error: failed to get vim list item %d"
+msgstr " :      vim %d"
 
-msgid "internal error: no vim list item"
-msgstr " :    vim"
+msgid "failed to add item to list"
+msgstr "     "
 
-msgid "can only assign lists to slice"
-msgstr "    "
+#, c-format
+msgid "internal error: no vim list item %d"
+msgstr " :    vim %d"
 
 msgid "internal error: failed to add item to list"
 msgstr " :      "
 
-msgid "can only concatenate with lists"
-msgstr "    "
+msgid "cannot delete vim.List attributes"
+msgstr "    vim.List"
+
+msgid "cannot modify fixed list"
+msgstr "    "
+
+# msgstr "E428: "
+#, c-format
+msgid "unnamed function %s does not exist"
+msgstr "  %s  "
+
+# msgstr "E428: "
+#, c-format
+msgid "function %s does not exist"
+msgstr " %s  "
+
+msgid "function constructor does not accept keyword arguments"
+msgstr "     "
+
+#, c-format
+msgid "failed to run function %s"
+msgstr "    %s"
+
+msgid "unable to get option value"
+msgstr "    "
+
+msgid "internal error: unknown option type"
+msgstr " :   "
+
+msgid "problem while switching windows"
+msgstr "   "
+
+#, c-format
+msgid "unable to unset global option %s"
+msgstr "     %s"
 
-msgid "Cannot modify fixed list"
-msgstr "    "
+#, c-format
+msgid "unable to unset option %s which does not have global value"
+msgstr "    %s,     "
 
-msgid "'self' argument must be a dictionary"
-msgstr " self   "
+msgid "attempt to refer to deleted tab page"
+msgstr "    "
 
-msgid "failed to run function"
-msgstr "   "
+msgid "no such tab page"
+msgstr "  "
 
 msgid "attempt to refer to deleted window"
 msgstr "    "
 
-msgid "readonly attribute"
-msgstr "  "
+msgid "readonly attribute: buffer"
+msgstr "   : "
 
 msgid "cursor position outside buffer"
 msgstr "   "
 
+msgid "no such window"
+msgstr "  "
+
+msgid "attempt to refer to deleted buffer"
+msgstr "    "
+
+msgid "failed to rename buffer"
+msgstr "   "
+
+msgid "mark name must be a single character"
+msgstr "     "
+
 #, c-format
-msgid "<window object (deleted) at %p>"
-msgstr "<'  ()   %p>"
+msgid "expected vim.Buffer object, but got %s"
+msgstr "  vim.Buffer,   %s"
 
 #, c-format
-msgid "<window object (unknown) at %p>"
-msgstr "<'  ()   %p>"
+msgid "failed to switch to buffer %d"
+msgstr "     %d"
 
 #, c-format
-msgid "<window %d>"
-msgstr "< %d>"
+msgid "expected vim.Window object, but got %s"
+msgstr "  vim.Window,   %s"
 
-msgid "no such window"
-msgstr "  "
+msgid "failed to find window in the current tab page"
+msgstr "      "
 
-msgid "attempt to refer to deleted buffer"
-msgstr "    "
+msgid "did not switch to the specified window"
+msgstr "    "
+
+#, c-format
+msgid "expected vim.TabPage object, but got %s"
+msgstr "  vim.TabPage,   %s"
 
-msgid "unable to convert to vim structure"
-msgstr "     vim"
+msgid "did not switch to the specified tab page"
+msgstr "    "
 
-msgid "NULL reference passed"
-msgstr "  NULL"
+msgid "failed to run the code"
+msgstr "   "
+
+msgid "E858: Eval did not return a valid python object"
+msgstr "E858: Eval     python"
+
+msgid "E859: Failed to convert returned python object to vim value"
+msgstr "E859:     python   vim"
+
+#, c-format
+msgid "unable to convert %s to vim dictionary"
+msgstr "   %s   vim"
+
+#, c-format
+msgid "unable to convert %s to vim structure"
+msgstr "   %s   vim"
+
+msgid "internal error: NULL reference passed"
+msgstr " :   NULL"
 
 msgid "internal error: invalid value type"
 msgstr " :   "
+
+msgid ""
+"Failed to set path hook: sys.path_hooks is not a list\n"
+"You should now do the following:\n"
+"- append vim.path_hook to sys.path_hooks\n"
+"- append vim.VIM_SPECIAL_PATH to sys.path\n"
+msgstr ""
+"    : sys.path_hooks  \n"
+"   :\n"
+"-  vim.path_hook  sys.path_hooks\n"
+"-  vim.VIM_SPECIAL_PATH  sys.path\n"
+
+msgid ""
+"Failed to set path: sys.path is not a list\n"
+"You should now append vim.VIM_SPECIAL_PATH to sys.path"
+msgstr ""
+"   : sys.path  \n"
+"   vim.VIM_SPECIAL_PATH  sys.path"
diff -Naur vim74.orig/src/po/zh_CN.UTF-8.po vim74/src/po/zh_CN.UTF-8.po
--- vim74.orig/src/po/zh_CN.UTF-8.po	2012-04-20 11:48:11.000000000 +0000
+++ vim74/src/po/zh_CN.UTF-8.po	2014-10-10 14:53:45.138711887 +0000
@@ -434,7 +434,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691:  List  List"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692:  List "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/po/zh_CN.cp936.po vim74/src/po/zh_CN.cp936.po
--- vim74.orig/src/po/zh_CN.cp936.po	2013-08-10 12:28:27.000000000 +0000
+++ vim74/src/po/zh_CN.cp936.po	2014-10-10 14:53:45.145378537 +0000
@@ -435,7 +435,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691:  List  List"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692:  List "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
@@ -2896,7 +2896,7 @@
 msgstr "--remote <files>\t Vim  <files>"
 
 msgid "--remote-silent <files>  Same, don't complain if there is no server"
-msgstr "--remote-silent <files>  "
+msgstr "--remote-silent <files>  "
 
 msgid ""
 "--remote-wait <files>  As --remote but wait for files to have been edited"
diff -Naur vim74.orig/src/po/zh_CN.po vim74/src/po/zh_CN.po
--- vim74.orig/src/po/zh_CN.po	2011-05-19 10:52:13.000000000 +0000
+++ vim74/src/po/zh_CN.po	2014-10-10 14:53:45.152045187 +0000
@@ -435,7 +435,7 @@
 msgid "E691: Can only compare List with List"
 msgstr "E691:  List  List"
 
-msgid "E692: Invalid operation for Lists"
+msgid "E692: Invalid operation for List"
 msgstr "E692:  List "
 
 msgid "E735: Can only compare Dictionary with Dictionary"
diff -Naur vim74.orig/src/popupmnu.c vim74/src/popupmnu.c
--- vim74.orig/src/popupmnu.c	2011-08-17 16:04:28.000000000 +0000
+++ vim74/src/popupmnu.c	2014-10-10 14:53:45.165378487 +0000
@@ -282,6 +282,10 @@
     int		round;
     int		n;
 
+    /* Never display more than we have */
+    if (pum_first > pum_size - pum_height)
+	pum_first = pum_size - pum_height;
+
     if (pum_scrollbar)
     {
 	thumb_heigth = pum_height * pum_height / pum_size;
@@ -563,7 +567,9 @@
 	    g_do_tagpreview = 3;
 	    if (p_pvh > 0 && p_pvh < g_do_tagpreview)
 		g_do_tagpreview = p_pvh;
+	    ++RedrawingDisabled;
 	    resized = prepare_tagpreview(FALSE);
+	    --RedrawingDisabled;
 	    g_do_tagpreview = 0;
 
 	    if (curwin->w_p_pvw)
@@ -637,6 +643,12 @@
 
 		    if (curwin != curwin_save && win_valid(curwin_save))
 		    {
+			/* When the first completion is done and the preview
+			 * window is not resized, skip the preview window's
+			 * status line redrawing. */
+			if (ins_compl_active() && !resized)
+			    curwin->w_redr_status = FALSE;
+
 			/* Return cursor to where we were */
 			validate_cursor();
 			redraw_later(SOME_VALID);
@@ -672,10 +684,6 @@
 #endif
     }
 
-    /* Never display more than we have */
-    if (pum_first > pum_size - pum_height)
-	pum_first = pum_size - pum_height;
-
     if (!resized)
 	pum_redraw();
 
diff -Naur vim74.orig/src/proto/blowfish.pro vim74/src/proto/blowfish.pro
--- vim74.orig/src/proto/blowfish.pro	2013-08-10 11:37:06.000000000 +0000
+++ vim74/src/proto/blowfish.pro	2014-10-10 14:53:45.168711812 +0000
@@ -1,10 +1,6 @@
 /* blowfish.c */
-void bf_key_init __ARGS((char_u *password, char_u *salt, int salt_len));
-void bf_ofb_init __ARGS((char_u *iv, int iv_len));
-void bf_crypt_encode __ARGS((char_u *from, size_t len, char_u *to));
-void bf_crypt_decode __ARGS((char_u *ptr, long len));
-void bf_crypt_init_keys __ARGS((char_u *passwd));
-void bf_crypt_save __ARGS((void));
-void bf_crypt_restore __ARGS((void));
+void crypt_blowfish_encode __ARGS((cryptstate_T *state, char_u *from, size_t len, char_u *to));
+void crypt_blowfish_decode __ARGS((cryptstate_T *state, char_u *from, size_t len, char_u *to));
+void crypt_blowfish_init __ARGS((cryptstate_T *state, char_u *key, char_u *salt, int salt_len, char_u *seed, int seed_len));
 int blowfish_self_test __ARGS((void));
 /* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/charset.pro vim74/src/proto/charset.pro
--- vim74.orig/src/proto/charset.pro	2013-08-10 11:37:07.000000000 +0000
+++ vim74/src/proto/charset.pro	2014-10-10 14:53:45.175378462 +0000
@@ -16,7 +16,7 @@
 int chartabsize __ARGS((char_u *p, colnr_T col));
 int linetabsize __ARGS((char_u *s));
 int linetabsize_col __ARGS((int startcol, char_u *s));
-int win_linetabsize __ARGS((win_T *wp, char_u *p, colnr_T len));
+int win_linetabsize __ARGS((win_T *wp, char_u *line, colnr_T len));
 int vim_isIDc __ARGS((int c));
 int vim_iswordc __ARGS((int c));
 int vim_iswordc_buf __ARGS((int c, buf_T *buf));
@@ -26,9 +26,9 @@
 int vim_isfilec_or_wc __ARGS((int c));
 int vim_isprintc __ARGS((int c));
 int vim_isprintc_strict __ARGS((int c));
-int lbr_chartabsize __ARGS((unsigned char *s, colnr_T col));
-int lbr_chartabsize_adv __ARGS((char_u **s, colnr_T col));
-int win_lbr_chartabsize __ARGS((win_T *wp, char_u *s, colnr_T col, int *headp));
+int lbr_chartabsize __ARGS((char_u *line, unsigned char *s, colnr_T col));
+int lbr_chartabsize_adv __ARGS((char_u *line, char_u **s, colnr_T col));
+int win_lbr_chartabsize __ARGS((win_T *wp, char_u *line, char_u *s, colnr_T col, int *headp));
 int in_win_border __ARGS((win_T *wp, colnr_T vcol));
 void getvcol __ARGS((win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor, colnr_T *end));
 colnr_T getvcol_nolist __ARGS((pos_T *posp));
diff -Naur vim74.orig/src/proto/crypt.pro vim74/src/proto/crypt.pro
--- vim74.orig/src/proto/crypt.pro	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/proto/crypt.pro	2014-10-10 14:53:45.175378462 +0000
@@ -0,0 +1,24 @@
+/* crypt.c */
+int crypt_method_nr_from_name __ARGS((char_u *name));
+int crypt_method_nr_from_magic __ARGS((char *ptr, int len));
+int crypt_works_inplace __ARGS((cryptstate_T *state));
+int crypt_get_method_nr __ARGS((buf_T *buf));
+int crypt_whole_undofile __ARGS((int method_nr));
+int crypt_get_header_len __ARGS((int method_nr));
+void crypt_set_cm_option __ARGS((buf_T *buf, int method_nr));
+int crypt_self_test __ARGS((void));
+cryptstate_T *crypt_create __ARGS((int method_nr, char_u *key, char_u *salt, int salt_len, char_u *seed, int seed_len));
+cryptstate_T *crypt_create_from_header __ARGS((int method_nr, char_u *key, char_u *header));
+cryptstate_T *crypt_create_from_file __ARGS((FILE *fp, char_u *key));
+cryptstate_T *crypt_create_for_writing __ARGS((int method_nr, char_u *key, char_u **header, int *header_len));
+void crypt_free_state __ARGS((cryptstate_T *state));
+long crypt_encode_alloc __ARGS((cryptstate_T *state, char_u *from, size_t len, char_u **newptr));
+long crypt_decode_alloc __ARGS((cryptstate_T *state, char_u *ptr, long len, char_u **newptr));
+void crypt_encode __ARGS((cryptstate_T *state, char_u *from, size_t len, char_u *to));
+void crypt_decode __ARGS((cryptstate_T *state, char_u *from, size_t len, char_u *to));
+void crypt_encode_inplace __ARGS((cryptstate_T *state, char_u *buf, size_t len));
+void crypt_decode_inplace __ARGS((cryptstate_T *state, char_u *buf, size_t len));
+void crypt_free_key __ARGS((char_u *key));
+char_u *crypt_get_key __ARGS((int store, int twice));
+void crypt_append_msg __ARGS((buf_T *buf));
+/* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/crypt_zip.pro vim74/src/proto/crypt_zip.pro
--- vim74.orig/src/proto/crypt_zip.pro	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/proto/crypt_zip.pro	2014-10-10 14:53:45.175378462 +0000
@@ -0,0 +1,5 @@
+/* crypt_zip.c */
+void crypt_zip_init __ARGS((cryptstate_T *state, char_u *key, char_u *salt, int salt_len, char_u *seed, int seed_len));
+void crypt_zip_encode __ARGS((cryptstate_T *state, char_u *from, size_t len, char_u *to));
+void crypt_zip_decode __ARGS((cryptstate_T *state, char_u *from, size_t len, char_u *to));
+/* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/eval.pro vim74/src/proto/eval.pro
--- vim74.orig/src/proto/eval.pro	2013-08-10 11:37:09.000000000 +0000
+++ vim74/src/proto/eval.pro	2014-10-10 14:53:45.182045111 +0000
@@ -59,7 +59,8 @@
 int list_append_dict __ARGS((list_T *list, dict_T *dict));
 int list_append_string __ARGS((list_T *l, char_u *str, int len));
 int list_insert_tv __ARGS((list_T *l, typval_T *tv, listitem_T *item));
-void list_remove __ARGS((list_T *l, listitem_T *item, listitem_T *item2));
+void vimlist_remove __ARGS((list_T *l, listitem_T *item, listitem_T *item2));
+void list_insert __ARGS((list_T *l, listitem_T *ni, listitem_T *item));
 int garbage_collect __ARGS((void));
 void set_ref_in_ht __ARGS((hashtab_T *ht, int copyID));
 void set_ref_in_list __ARGS((list_T *l, int copyID));
diff -Naur vim74.orig/src/proto/ex_cmds.pro vim74/src/proto/ex_cmds.pro
--- vim74.orig/src/proto/ex_cmds.pro	2013-08-10 11:37:09.000000000 +0000
+++ vim74/src/proto/ex_cmds.pro	2014-10-10 14:53:45.185378436 +0000
@@ -44,6 +44,7 @@
 void free_old_sub __ARGS((void));
 int prepare_tagpreview __ARGS((int undo_sync));
 void ex_help __ARGS((exarg_T *eap));
+void ex_helpclose __ARGS((exarg_T *eap));
 char_u *check_help_lang __ARGS((char_u *arg));
 int help_heuristic __ARGS((char_u *matched_string, int offset, int wrong_case));
 int find_help_tags __ARGS((char_u *arg, int *num_matches, char_u ***matches, int keep_lang));
diff -Naur vim74.orig/src/proto/ex_cmds2.pro vim74/src/proto/ex_cmds2.pro
--- vim74.orig/src/proto/ex_cmds2.pro	2013-08-10 11:37:10.000000000 +0000
+++ vim74/src/proto/ex_cmds2.pro	2014-10-10 14:53:45.185378436 +0000
@@ -35,7 +35,7 @@
 int prof_def_func __ARGS((void));
 int autowrite __ARGS((buf_T *buf, int forceit));
 void autowrite_all __ARGS((void));
-int check_changed __ARGS((buf_T *buf, int checkaw, int mult_win, int forceit, int allbuf));
+int check_changed __ARGS((buf_T *buf, int flags));
 void browse_save_fname __ARGS((buf_T *buf));
 void dialog_changed __ARGS((buf_T *buf, int checkall));
 int can_abandon __ARGS((buf_T *buf, int forceit));
diff -Naur vim74.orig/src/proto/ex_docmd.pro vim74/src/proto/ex_docmd.pro
--- vim74.orig/src/proto/ex_docmd.pro	2013-08-10 11:37:10.000000000 +0000
+++ vim74/src/proto/ex_docmd.pro	2014-10-10 14:53:45.188711761 +0000
@@ -54,4 +54,5 @@
 int put_line __ARGS((FILE *fd, char *s));
 void dialog_msg __ARGS((char_u *buff, char *format, char_u *fname));
 char_u *get_behave_arg __ARGS((expand_T *xp, int idx));
+void ex_may_print __ARGS((exarg_T *eap));
 /* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/ex_eval.pro vim74/src/proto/ex_eval.pro
--- vim74.orig/src/proto/ex_eval.pro	2013-08-10 11:37:10.000000000 +0000
+++ vim74/src/proto/ex_eval.pro	2014-10-10 14:53:45.188711761 +0000
@@ -4,8 +4,10 @@
 int should_abort __ARGS((int retcode));
 int aborted_in_try __ARGS((void));
 int cause_errthrow __ARGS((char_u *mesg, int severe, int *ignore));
+void free_global_msglist __ARGS((void));
 void do_errthrow __ARGS((struct condstack *cstack, char_u *cmdname));
 int do_intthrow __ARGS((struct condstack *cstack));
+char_u *get_exception_string __ARGS((void *value, int type, char_u *cmdname, int *should_free));
 void discard_current_exception __ARGS((void));
 void report_make_pending __ARGS((int pending, void *value));
 void report_resume_pending __ARGS((int pending, void *value));
diff -Naur vim74.orig/src/proto/ex_getln.pro vim74/src/proto/ex_getln.pro
--- vim74.orig/src/proto/ex_getln.pro	2013-08-10 11:37:11.000000000 +0000
+++ vim74/src/proto/ex_getln.pro	2014-10-10 14:53:45.192045086 +0000
@@ -32,7 +32,7 @@
 void set_cmd_context __ARGS((expand_T *xp, char_u *str, int len, int col));
 int expand_cmdline __ARGS((expand_T *xp, char_u *str, int col, int *matchcount, char_u ***matches));
 int ExpandGeneric __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file, char_u *((*func)(expand_T *, int)), int escaped));
-char_u *globpath __ARGS((char_u *path, char_u *file, int expand_options));
+void globpath __ARGS((char_u *path, char_u *file, garray_T *ga, int expand_options));
 void init_history __ARGS((void));
 int get_histtype __ARGS((char_u *name));
 void add_to_history __ARGS((int histype, char_u *new_entry, int in_map, int sep));
diff -Naur vim74.orig/src/proto/fileio.pro vim74/src/proto/fileio.pro
--- vim74.orig/src/proto/fileio.pro	2013-08-10 11:37:11.000000000 +0000
+++ vim74/src/proto/fileio.pro	2014-10-10 14:53:45.192045086 +0000
@@ -4,8 +4,6 @@
 int prep_exarg __ARGS((exarg_T *eap, buf_T *buf));
 void set_file_options __ARGS((int set_options, exarg_T *eap));
 void set_forced_fenc __ARGS((exarg_T *eap));
-int prepare_crypt_read __ARGS((FILE *fp));
-char_u *prepare_crypt_write __ARGS((buf_T *buf, int *lenp));
 int check_file_readonly __ARGS((char_u *fname, int perm));
 int buf_write __ARGS((buf_T *buf, char_u *fname, char_u *sfname, linenr_T start, linenr_T end, exarg_T *eap, int append, int forceit, int reset_changed, int filtering));
 void msg_add_fname __ARGS((buf_T *buf, char_u *fname));
@@ -49,6 +47,8 @@
 int has_textchanged __ARGS((void));
 int has_textchangedI __ARGS((void));
 int has_insertcharpre __ARGS((void));
+int has_cmdundefined __ARGS((void));
+int has_funcundefined __ARGS((void));
 void block_autocmds __ARGS((void));
 void unblock_autocmds __ARGS((void));
 int is_autocmd_blocked __ARGS((void));
diff -Naur vim74.orig/src/proto/getchar.pro vim74/src/proto/getchar.pro
--- vim74.orig/src/proto/getchar.pro	2013-08-10 11:37:12.000000000 +0000
+++ vim74/src/proto/getchar.pro	2014-10-10 14:53:45.195378411 +0000
@@ -1,8 +1,9 @@
 /* getchar.c */
-void free_buff __ARGS((struct buffheader *buf));
+void free_buff __ARGS((buffheader_T *buf));
 char_u *get_recorded __ARGS((void));
 char_u *get_inserted __ARGS((void));
 int stuff_empty __ARGS((void));
+int readbuf1_empty __ARGS((void));
 void typeahead_noflush __ARGS((int c));
 void flush_buffers __ARGS((int flush_typeahead));
 void ResetRedobuff __ARGS((void));
@@ -14,6 +15,7 @@
 void AppendCharToRedobuff __ARGS((int c));
 void AppendNumberToRedobuff __ARGS((long n));
 void stuffReadbuff __ARGS((char_u *s));
+void stuffRedoReadbuff __ARGS((char_u *s));
 void stuffReadbuffLen __ARGS((char_u *s, long len));
 void stuffReadbuffSpec __ARGS((char_u *s));
 void stuffcharReadbuff __ARGS((int c));
diff -Naur vim74.orig/src/proto/gui_w32.pro vim74/src/proto/gui_w32.pro
--- vim74.orig/src/proto/gui_w32.pro	2013-08-10 11:37:36.000000000 +0000
+++ vim74/src/proto/gui_w32.pro	2014-10-10 14:53:45.212045036 +0000
@@ -1,4 +1,6 @@
 /* gui_w32.c */
+int directx_enabled __ARGS((void));
+int gui_mch_set_rendering_options __ARGS((char_u *s));
 void gui_mch_set_blinking __ARGS((long wait, long on, long off));
 void gui_mch_stop_blink __ARGS((void));
 void gui_mch_start_blink __ARGS((void));
diff -Naur vim74.orig/src/proto/misc1.pro vim74/src/proto/misc1.pro
--- vim74.orig/src/proto/misc1.pro	2013-08-10 11:37:20.000000000 +0000
+++ vim74/src/proto/misc1.pro	2014-10-10 14:53:45.245378286 +0000
@@ -2,9 +2,10 @@
 int get_indent __ARGS((void));
 int get_indent_lnum __ARGS((linenr_T lnum));
 int get_indent_buf __ARGS((buf_T *buf, linenr_T lnum));
-int get_indent_str __ARGS((char_u *ptr, int ts));
+int get_indent_str __ARGS((char_u *ptr, int ts, int list));
 int set_indent __ARGS((int size, int flags));
 int get_number_indent __ARGS((linenr_T lnum));
+int get_breakindent_win __ARGS((win_T *wp, char_u *ptr));
 int open_line __ARGS((int dir, int flags, int second_line_indent));
 int get_leader_len __ARGS((char_u *line, char_u **flags, int backward, int include_space));
 int get_last_leader_offset __ARGS((char_u *line, char_u **flags));
@@ -69,6 +70,7 @@
 char_u *getnextcomp __ARGS((char_u *fname));
 char_u *get_past_head __ARGS((char_u *path));
 int vim_ispathsep __ARGS((int c));
+int vim_ispathsep_nocolon __ARGS((int c));
 int vim_ispathlistsep __ARGS((int c));
 void shorten_dir __ARGS((char_u *str));
 int dir_of_file_exists __ARGS((char_u *fname));
@@ -80,9 +82,10 @@
 char_u *FullName_save __ARGS((char_u *fname, int force));
 pos_T *find_start_comment __ARGS((int ind_maxcomment));
 void do_c_expr_indent __ARGS((void));
-int cin_islabel __ARGS((int ind_maxcomment));
+int cin_islabel __ARGS((void));
 int cin_iscase __ARGS((char_u *s, int strict));
 int cin_isscopedecl __ARGS((char_u *s));
+void parse_cino __ARGS((buf_T *buf));
 int get_c_indent __ARGS((void));
 int get_expr_indent __ARGS((void));
 int get_lisp_indent __ARGS((void));
@@ -98,7 +101,8 @@
 void remove_duplicates __ARGS((garray_T *gap));
 int gen_expand_wildcards __ARGS((int num_pat, char_u **pat, int *num_file, char_u ***file, int flags));
 void addfile __ARGS((garray_T *gap, char_u *f, int flags));
-char_u *get_cmd_output __ARGS((char_u *cmd, char_u *infile, int flags));
+char_u *get_cmd_output __ARGS((char_u *cmd, char_u *infile, int flags, int *ret_len));
 void FreeWild __ARGS((int count, char_u **files));
 int goto_im __ARGS((void));
+char_u *get_isolated_shell_name __ARGS((void));
 /* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/misc2.pro vim74/src/proto/misc2.pro
--- vim74.orig/src/proto/misc2.pro	2013-08-10 11:37:20.000000000 +0000
+++ vim74/src/proto/misc2.pro	2014-10-10 14:53:45.248711611 +0000
@@ -32,7 +32,7 @@
 char_u *vim_strsave_escaped __ARGS((char_u *string, char_u *esc_chars));
 char_u *vim_strsave_escaped_ext __ARGS((char_u *string, char_u *esc_chars, int cc, int bsl));
 int csh_like_shell __ARGS((void));
-char_u *vim_strsave_shellescape __ARGS((char_u *string, int do_special));
+char_u *vim_strsave_shellescape __ARGS((char_u *string, int do_special, int do_newline));
 char_u *vim_strsave_up __ARGS((char_u *string));
 char_u *vim_strnsave_up __ARGS((char_u *string, int len));
 void vim_strup __ARGS((char_u *p));
@@ -55,7 +55,7 @@
 void ga_init __ARGS((garray_T *gap));
 void ga_init2 __ARGS((garray_T *gap, int itemsize, int growsize));
 int ga_grow __ARGS((garray_T *gap, int n));
-char_u *ga_concat_strings __ARGS((garray_T *gap));
+char_u *ga_concat_strings __ARGS((garray_T *gap, char *sep));
 void ga_concat __ARGS((garray_T *gap, char_u *s));
 void ga_append __ARGS((garray_T *gap, int c));
 void append_ga_line __ARGS((garray_T *gap));
@@ -84,16 +84,6 @@
 char_u *parse_shape_opt __ARGS((int what));
 int get_shape_idx __ARGS((int mouse));
 void update_mouseshape __ARGS((int shape_idx));
-int crypt_method_from_string __ARGS((char_u *s));
-int get_crypt_method __ARGS((buf_T *buf));
-void set_crypt_method __ARGS((buf_T *buf, int method));
-void crypt_push_state __ARGS((void));
-void crypt_pop_state __ARGS((void));
-void crypt_encode __ARGS((char_u *from, size_t len, char_u *to));
-void crypt_decode __ARGS((char_u *ptr, long len));
-void crypt_init_keys __ARGS((char_u *passwd));
-void free_crypt_key __ARGS((char_u *key));
-char_u *get_crypt_key __ARGS((int store, int twice));
 void *vim_findfile_init __ARGS((char_u *path, char_u *filename, char_u *stopdirs, int level, int free_visited, int find_what, void *search_ctx_arg, int tagfile, char_u *rel_fname));
 char_u *vim_findfile_stopdir __ARGS((char_u *buf));
 void vim_findfile_cleanup __ARGS((void *ctx));
@@ -116,5 +106,6 @@
 char_u *read_string __ARGS((FILE *fd, int cnt));
 int put_bytes __ARGS((FILE *fd, long_u nr, int len));
 void put_time __ARGS((FILE *fd, time_t the_time));
+void time_to_bytes __ARGS((time_t the_time, char_u *buf));
 int has_non_ascii __ARGS((char_u *s));
 /* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/ops.pro vim74/src/proto/ops.pro
--- vim74.orig/src/proto/ops.pro	2013-08-10 11:37:22.000000000 +0000
+++ vim74/src/proto/ops.pro	2014-10-10 14:53:45.252044936 +0000
@@ -37,7 +37,7 @@
 int preprocs_left __ARGS((void));
 int get_register_name __ARGS((int num));
 void ex_display __ARGS((exarg_T *eap));
-int do_join __ARGS((long count, int insert_space, int save_undo, int use_formatoptions));
+int do_join __ARGS((long count, int insert_space, int save_undo, int use_formatoptions, int setmark));
 void op_format __ARGS((oparg_T *oap, int keep_cursor));
 void op_formatexpr __ARGS((oparg_T *oap));
 int fex_format __ARGS((linenr_T lnum, long count, int c));
@@ -53,9 +53,10 @@
 int clip_convert_selection __ARGS((char_u **str, long_u *len, VimClipboard *cbd));
 void dnd_yank_drag_data __ARGS((char_u *str, long len));
 char_u get_reg_type __ARGS((int regname, long *reglen));
-char_u *get_reg_contents __ARGS((int regname, int allowexpr, int expr_src));
+char_u *get_reg_contents __ARGS((int regname, int flags));
 void write_reg_contents __ARGS((int name, char_u *str, int maxlen, int must_append));
 void write_reg_contents_ex __ARGS((int name, char_u *str, int maxlen, int must_append, int yank_type, long block_len));
+void write_reg_contents_lst __ARGS((int name, char_u **strings, int maxlen, int must_append, int yank_type, long block_len));
 void clear_oparg __ARGS((oparg_T *oap));
 void cursor_pos_info __ARGS((void));
 /* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/option.pro vim74/src/proto/option.pro
--- vim74.orig/src/proto/option.pro	2013-08-10 11:37:22.000000000 +0000
+++ vim74/src/proto/option.pro	2014-10-10 14:53:45.255378261 +0000
@@ -23,6 +23,7 @@
 char_u *check_stl_option __ARGS((char_u *s));
 int get_option_value __ARGS((char_u *name, long *numval, char_u **stringval, int opt_flags));
 int get_option_value_strict __ARGS((char_u *name, long *numval, char_u **stringval, int opt_type, void *from));
+char_u *option_iter_next __ARGS((void **option, int opt_type));
 char_u *set_option_value __ARGS((char_u *name, long number, char_u *string, int opt_flags));
 char_u *get_term_code __ARGS((char_u *tname));
 char_u *get_highlight_default __ARGS((void));
@@ -39,7 +40,6 @@
 void win_copy_options __ARGS((win_T *wp_from, win_T *wp_to));
 void copy_winopt __ARGS((winopt_T *from, winopt_T *to));
 void check_win_options __ARGS((win_T *win));
-void check_winopt __ARGS((winopt_T *wop));
 void clear_winopt __ARGS((winopt_T *wop));
 void buf_copy_options __ARGS((buf_T *buf, int flags));
 void reset_modifiable __ARGS((void));
@@ -59,7 +59,8 @@
 void save_file_ff __ARGS((buf_T *buf));
 int file_ff_differs __ARGS((buf_T *buf, int ignore_empty));
 int check_ff_value __ARGS((char_u *p));
-long get_sw_value __ARGS((void));
+long get_sw_value __ARGS((buf_T *buf));
 long get_sts_value __ARGS((void));
 void find_mps_values __ARGS((int *initc, int *findc, int *backwards, int switchit));
+unsigned int get_bkc_value __ARGS((buf_T *buf));
 /* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/os_amiga.pro vim74/src/proto/os_amiga.pro
--- vim74.orig/src/proto/os_amiga.pro	2013-08-10 11:37:37.000000000 +0000
+++ vim74/src/proto/os_amiga.pro	2014-10-10 14:53:45.255378261 +0000
@@ -26,7 +26,7 @@
 void mch_hide __ARGS((char_u *name));
 int mch_isdir __ARGS((char_u *name));
 int mch_mkdir __ARGS((char_u *name));
-int mch_can_exe __ARGS((char_u *name));
+int mch_can_exe __ARGS((char_u *name, char_u **path));
 int mch_nodetype __ARGS((char_u *name));
 void mch_early_init __ARGS((void));
 void mch_exit __ARGS((int r));
diff -Naur vim74.orig/src/proto/os_msdos.pro vim74/src/proto/os_msdos.pro
--- vim74.orig/src/proto/os_msdos.pro	2013-08-10 11:37:37.000000000 +0000
+++ vim74/src/proto/os_msdos.pro	2014-10-10 14:53:45.262044910 +0000
@@ -38,7 +38,7 @@
 int mch_setperm __ARGS((char_u *name, long perm));
 void mch_hide __ARGS((char_u *name));
 int mch_isdir __ARGS((char_u *name));
-int mch_can_exe __ARGS((char_u *name));
+int mch_can_exe __ARGS((char_u *name, char_u **path));
 int mch_nodetype __ARGS((char_u *name));
 int mch_dirname __ARGS((char_u *buf, int len));
 int mch_remove __ARGS((char_u *name));
diff -Naur vim74.orig/src/proto/os_mswin.pro vim74/src/proto/os_mswin.pro
--- vim74.orig/src/proto/os_mswin.pro	2013-08-10 11:37:39.000000000 +0000
+++ vim74/src/proto/os_mswin.pro	2014-10-10 14:53:45.262044910 +0000
@@ -21,6 +21,7 @@
 int mch_chdir __ARGS((char *path));
 int can_end_termcap_mode __ARGS((int give_msg));
 int mch_screenmode __ARGS((char_u *arg));
+int mch_icon_load __ARGS((HANDLE *iconp));
 int mch_libcall __ARGS((char_u *libname, char_u *funcname, char_u *argstring, int argint, char_u **string_result, int *number_result));
 void DumpPutS __ARGS((const char *psz));
 int mch_get_winpos __ARGS((int *x, int *y));
diff -Naur vim74.orig/src/proto/os_unix.pro vim74/src/proto/os_unix.pro
--- vim74.orig/src/proto/os_unix.pro	2013-08-10 11:37:23.000000000 +0000
+++ vim74/src/proto/os_unix.pro	2014-10-10 14:53:45.265378235 +0000
@@ -42,7 +42,7 @@
 void mch_free_acl __ARGS((vim_acl_T aclent));
 void mch_hide __ARGS((char_u *name));
 int mch_isdir __ARGS((char_u *name));
-int mch_can_exe __ARGS((char_u *name));
+int mch_can_exe __ARGS((char_u *name, char_u **path));
 int mch_nodetype __ARGS((char_u *name));
 void mch_early_init __ARGS((void));
 void mch_free_mem __ARGS((void));
diff -Naur vim74.orig/src/proto/os_vms.pro vim74/src/proto/os_vms.pro
--- vim74.orig/src/proto/os_vms.pro	2013-08-10 11:37:40.000000000 +0000
+++ vim74/src/proto/os_vms.pro	2014-10-10 14:53:45.265378235 +0000
@@ -7,6 +7,7 @@
 int vms_sys __ARGS((char *cmd, char *out, char *inp));
 int vms_sys_status __ARGS((int status));
 int vms_read __ARGS((char *inbuf, size_t nbytes));
+char *vms_tolower __ARGS((char *name));
 int mch_expand_wildcards __ARGS((int num_pat, char_u **pat, int *num_file, char_u ***file, int flags));
 int mch_expandpath __ARGS((garray_T *gap, char_u *path, int flags));
 void *vms_fixfilename __ARGS((void *instring));
diff -Naur vim74.orig/src/proto/os_win32.pro vim74/src/proto/os_win32.pro
--- vim74.orig/src/proto/os_win32.pro	2013-08-10 11:37:38.000000000 +0000
+++ vim74/src/proto/os_win32.pro	2014-10-10 14:53:45.268711560 +0000
@@ -26,7 +26,7 @@
 int mch_is_linked __ARGS((char_u *fname));
 int win32_fileinfo __ARGS((char_u *fname, BY_HANDLE_FILE_INFORMATION *info));
 int mch_writable __ARGS((char_u *name));
-int mch_can_exe __ARGS((char_u *name));
+int mch_can_exe __ARGS((char_u *name, char_u **path));
 int mch_nodetype __ARGS((char_u *name));
 vim_acl_T mch_get_acl __ARGS((char_u *fname));
 void mch_set_acl __ARGS((char_u *fname, vim_acl_T acl));
diff -Naur vim74.orig/src/proto/regexp.pro vim74/src/proto/regexp.pro
--- vim74.orig/src/proto/regexp.pro	2013-08-10 11:37:24.000000000 +0000
+++ vim74/src/proto/regexp.pro	2014-10-10 14:53:45.278711535 +0000
@@ -10,6 +10,7 @@
 int vim_regsub __ARGS((regmatch_T *rmp, char_u *source, char_u *dest, int copy, int magic, int backslash));
 int vim_regsub_multi __ARGS((regmmatch_T *rmp, linenr_T lnum, char_u *source, char_u *dest, int copy, int magic, int backslash));
 char_u *reg_submatch __ARGS((int no));
+list_T *reg_submatch_list __ARGS((int no));
 regprog_T *vim_regcomp __ARGS((char_u *expr_arg, int re_flags));
 void vim_regfree __ARGS((regprog_T *prog));
 int vim_regexec __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
diff -Naur vim74.orig/src/proto/spell.pro vim74/src/proto/spell.pro
--- vim74.orig/src/proto/spell.pro	2013-08-10 11:37:26.000000000 +0000
+++ vim74/src/proto/spell.pro	2014-10-10 14:53:45.282044860 +0000
@@ -3,6 +3,7 @@
 int spell_move_to __ARGS((win_T *wp, int dir, int allwords, int curline, hlf_T *attrp));
 void spell_cat_line __ARGS((char_u *buf, char_u *line, int maxlen));
 char_u *did_set_spelllang __ARGS((win_T *wp));
+void spell_delete_wordlist __ARGS((void));
 void spell_free_all __ARGS((void));
 void spell_reload __ARGS((void));
 int spell_check_msm __ARGS((void));
diff -Naur vim74.orig/src/proto/term.pro vim74/src/proto/term.pro
--- vim74.orig/src/proto/term.pro	2013-08-10 11:37:28.000000000 +0000
+++ vim74/src/proto/term.pro	2014-10-10 14:53:45.288711510 +0000
@@ -35,7 +35,7 @@
 void starttermcap __ARGS((void));
 void stoptermcap __ARGS((void));
 void may_req_termresponse __ARGS((void));
-void may_req_ambiguous_character_width __ARGS((void));
+void may_req_ambiguous_char_width __ARGS((void));
 int swapping_screen __ARGS((void));
 void setmouse __ARGS((void));
 int mouse_has __ARGS((int c));
diff -Naur vim74.orig/src/proto/ui.pro vim74/src/proto/ui.pro
--- vim74.orig/src/proto/ui.pro	2013-08-10 11:37:29.000000000 +0000
+++ vim74/src/proto/ui.pro	2014-10-10 14:53:45.288711510 +0000
@@ -14,6 +14,8 @@
 void clip_update_selection __ARGS((VimClipboard *clip));
 void clip_own_selection __ARGS((VimClipboard *cbd));
 void clip_lose_selection __ARGS((VimClipboard *cbd));
+void start_global_changes __ARGS((void));
+void end_global_changes __ARGS((void));
 void clip_auto_select __ARGS((void));
 int clip_isautosel_star __ARGS((void));
 int clip_isautosel_plus __ARGS((void));
diff -Naur vim74.orig/src/proto/winclip.pro vim74/src/proto/winclip.pro
--- vim74.orig/src/proto/winclip.pro	2013-08-10 11:37:39.000000000 +0000
+++ vim74/src/proto/winclip.pro	2014-10-10 14:53:45.295378160 +0000
@@ -11,4 +11,5 @@
 short_u *enc_to_utf16 __ARGS((char_u *str, int *lenp));
 char_u *utf16_to_enc __ARGS((short_u *str, int *lenp));
 void acp_to_enc __ARGS((char_u *str, int str_size, char_u **out, int *outlen));
+void enc_to_acp __ARGS((char_u *str, int str_size, char_u **out, int *outlen));
 /* vim: set ft=c : */
diff -Naur vim74.orig/src/proto/window.pro vim74/src/proto/window.pro
--- vim74.orig/src/proto/window.pro	2013-08-10 11:37:30.000000000 +0000
+++ vim74/src/proto/window.pro	2014-10-10 14:53:45.295378160 +0000
@@ -9,7 +9,7 @@
 void win_equal __ARGS((win_T *next_curwin, int current, int dir));
 void close_windows __ARGS((buf_T *buf, int keep_curwin));
 int one_window __ARGS((void));
-void win_close __ARGS((win_T *win, int free_buf));
+int win_close __ARGS((win_T *win, int free_buf));
 void win_close_othertab __ARGS((win_T *win, int free_buf, tabpage_T *tp));
 void win_free_all __ARGS((void));
 win_T *winframe_remove __ARGS((win_T *win, int *dirp, tabpage_T *tp));
@@ -75,7 +75,7 @@
 void switch_buffer __ARGS((buf_T **save_curbuf, buf_T *buf));
 void restore_buffer __ARGS((buf_T *save_curbuf));
 int win_hasvertsplit __ARGS((void));
-int match_add __ARGS((win_T *wp, char_u *grp, char_u *pat, int prio, int id));
+int match_add __ARGS((win_T *wp, char_u *grp, char_u *pat, int prio, int id, list_T *pos));
 int match_delete __ARGS((win_T *wp, int id, int perr));
 void clear_matches __ARGS((win_T *wp));
 matchitem_T *get_match __ARGS((win_T *wp, int id));
diff -Naur vim74.orig/src/proto.h vim74/src/proto.h
--- vim74.orig/src/proto.h	2013-02-26 13:18:19.000000000 +0000
+++ vim74/src/proto.h	2014-10-10 14:53:45.168711812 +0000
@@ -70,6 +70,8 @@
 
 # ifdef FEAT_CRYPT
 #  include "blowfish.pro"
+#  include "crypt.pro"
+#  include "crypt_zip.pro"
 # endif
 # include "buffer.pro"
 # include "charset.pro"
diff -Naur vim74.orig/src/quickfix.c vim74/src/quickfix.c
--- vim74.orig/src/quickfix.c	2013-07-01 19:16:44.000000000 +0000
+++ vim74/src/quickfix.c	2014-10-10 14:53:45.305378135 +0000
@@ -107,6 +107,7 @@
 };
 
 static int	qf_init_ext __ARGS((qf_info_T *qi, char_u *efile, buf_T *buf, typval_T *tv, char_u *errorformat, int newlist, linenr_T lnumfirst, linenr_T lnumlast, char_u *qf_title));
+static void	qf_store_title __ARGS((qf_info_T *qi, char_u *title));
 static void	qf_new_list __ARGS((qf_info_T *qi, char_u *qf_title));
 static void	ll_free_all __ARGS((qf_info_T **pqi));
 static int	qf_add_entry __ARGS((qf_info_T *qi, qfline_T **prevp, char_u *dir, char_u *fname, int bufnum, char_u *mesg, long lnum, int col, int vis_col, char_u *pattern, int nr, int type, int valid));
@@ -126,7 +127,7 @@
 static win_T	*qf_find_win __ARGS((qf_info_T *qi));
 static buf_T	*qf_find_buf __ARGS((qf_info_T *qi));
 static void	qf_update_buffer __ARGS((qf_info_T *qi));
-static void	qf_set_title __ARGS((qf_info_T *qi));
+static void	qf_set_title_var __ARGS((qf_info_T *qi));
 static void	qf_fill_buffer __ARGS((qf_info_T *qi));
 #endif
 static char_u	*get_mef_name __ARGS((void));
@@ -751,7 +752,10 @@
 		fmt_start = fmt_ptr;
 
 	    if (vim_strchr((char_u *)"AEWI", idx) != NULL)
+	    {
 		multiline = TRUE;	/* start of a multi-line message */
+		multiignore = FALSE;	/* reset continuation */
+	    }
 	    else if (vim_strchr((char_u *)"CZ", idx) != NULL)
 	    {				/* continuation of multi-line msg */
 		if (qfprev == NULL)
@@ -881,6 +885,21 @@
     return retval;
 }
 
+    static void
+qf_store_title(qi, title)
+    qf_info_T	*qi;
+    char_u	*title;
+{
+    if (title != NULL)
+    {
+	char_u *p = alloc((int)STRLEN(title) + 2);
+
+	qi->qf_lists[qi->qf_curlist].qf_title = p;
+	if (p != NULL)
+	    sprintf((char *)p, ":%s", (char *)title);
+    }
+}
+
 /*
  * Prepare for adding a new quickfix list.
  */
@@ -892,7 +911,7 @@
     int		i;
 
     /*
-     * If the current entry is not the last entry, delete entries below
+     * If the current entry is not the last entry, delete entries beyond
      * the current entry.  This makes it possible to browse in a tree-like
      * way with ":grep'.
      */
@@ -913,14 +932,7 @@
     else
 	qi->qf_curlist = qi->qf_listcount++;
     vim_memset(&qi->qf_lists[qi->qf_curlist], 0, (size_t)(sizeof(qf_list_T)));
-    if (qf_title != NULL)
-    {
-	char_u *p = alloc((int)STRLEN(qf_title) + 2);
-
-	qi->qf_lists[qi->qf_curlist].qf_title = p;
-	if (p != NULL)
-	    sprintf((char *)p, ":%s", (char *)qf_title);
-    }
+    qf_store_title(qi, qf_title);
 }
 
 /*
@@ -2161,6 +2173,7 @@
     }
     vim_free(qi->qf_lists[idx].qf_title);
     qi->qf_lists[idx].qf_title = NULL;
+    qi->qf_lists[idx].qf_index = 0;
 }
 
 /*
@@ -2344,9 +2357,7 @@
     else
 	height = QF_WINHEIGHT;
 
-#ifdef FEAT_VISUAL
     reset_VIsual_and_resel();			/* stop Visual mode */
-#endif
 #ifdef FEAT_GUI
     need_mouse_correct = TRUE;
 #endif
@@ -2357,7 +2368,22 @@
     win = qf_find_win(qi);
 
     if (win != NULL && cmdmod.tab == 0)
+    {
 	win_goto(win);
+	if (eap->addr_count != 0)
+	{
+#ifdef FEAT_VERTSPLIT
+	    if (cmdmod.split & WSP_VERT)
+	    {
+		if (height != W_WIDTH(win))
+		    win_setwidth(height);
+	    }
+	    else
+#endif
+	    if (height != win->w_height)
+		win_setheight(height);
+	}
+    }
     else
     {
 	qf_buf = qf_find_buf(qi);
@@ -2428,7 +2454,7 @@
     qf_fill_buffer(qi);
 
     if (qi->qf_lists[qi->qf_curlist].qf_title != NULL)
-	qf_set_title(qi);
+	qf_set_title_var(qi);
 
     curwin->w_cursor.lnum = qi->qf_lists[qi->qf_curlist].qf_index;
     curwin->w_cursor.col = 0;
@@ -2583,7 +2609,7 @@
 	{
 	    curwin_save = curwin;
 	    curwin = win;
-	    qf_set_title(qi);
+	    qf_set_title_var(qi);
 	    curwin = curwin_save;
 
 	}
@@ -2596,7 +2622,7 @@
 }
 
     static void
-qf_set_title(qi)
+qf_set_title_var(qi)
     qf_info_T	*qi;
 {
     set_internal_string_var((char_u *)"w:quickfix_title",
@@ -3829,7 +3855,10 @@
 	     prevp->qf_next != prevp; prevp = prevp->qf_next)
 	    ;
     else if (action == 'r')
+    {
 	qf_free(qi, qi->qf_curlist);
+	qf_store_title(qi, title);
+    }
 
     for (li = list->lv_first; li != NULL; li = li->li_next)
     {
diff -Naur vim74.orig/src/regexp.c vim74/src/regexp.c
--- vim74.orig/src/regexp.c	2013-08-01 16:31:30.000000000 +0000
+++ vim74/src/regexp.c	2014-10-10 14:53:45.312044785 +0000
@@ -244,6 +244,7 @@
 
 #define RE_MARK		207	/* mark cmp  Match mark position */
 #define RE_VISUAL	208	/*	Match Visual area */
+#define RE_COMPOSING	209	/* any composing characters */
 
 /*
  * Magic characters have a special meaning, they don't match literally.
@@ -357,6 +358,8 @@
 static char_u	*regprop __ARGS((char_u *));
 #endif
 
+static int re_mult_next __ARGS((char *what));
+
 static char_u e_missingbracket[] = N_("E769: Missing ] after %s[");
 static char_u e_unmatchedpp[] = N_("E53: Unmatched %s%%(");
 static char_u e_unmatchedp[] = N_("E54: Unmatched %s(");
@@ -2165,9 +2168,13 @@
 #endif
 
 		case 's': ret = regnode(MOPEN + 0);
+			  if (re_mult_next("\\zs") == FAIL)
+			      return NULL;
 			  break;
 
 		case 'e': ret = regnode(MCLOSE + 0);
+			  if (re_mult_next("\\ze") == FAIL)
+			      return NULL;
 			  break;
 
 		default:  EMSG_RET_NULL(_("E68: Invalid character after \\z"));
@@ -2208,6 +2215,10 @@
 		    ret = regnode(RE_VISUAL);
 		    break;
 
+		case 'C':
+		    ret = regnode(RE_COMPOSING);
+		    break;
+
 		/* \%[abc]: Emit as a list of branches, all ending at the last
 		 * branch which matches nothing. */
 		case '[':
@@ -3104,15 +3115,25 @@
 	    if (reg_magic >= MAGIC_OFF)
 	    {
 		char_u *p = regparse + 1;
+		int is_magic_all = (reg_magic == MAGIC_ALL);
 
-		/* ignore \c \C \m and \M after '$' */
+		/* ignore \c \C \m \M \v \V and \Z after '$' */
 		while (p[0] == '\\' && (p[1] == 'c' || p[1] == 'C'
-				|| p[1] == 'm' || p[1] == 'M' || p[1] == 'Z'))
+				|| p[1] == 'm' || p[1] == 'M'
+				|| p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))
+		{
+		    if (p[1] == 'v')
+			is_magic_all = TRUE;
+		    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')
+			is_magic_all = FALSE;
 		    p += 2;
+		}
 		if (p[0] == NUL
 			|| (p[0] == '\\'
 			    && (p[1] == '|' || p[1] == '&' || p[1] == ')'
 				|| p[1] == 'n'))
+			|| (is_magic_all
+			       && (p[0] == '|' || p[0] == '&' || p[0] == ')'))
 			|| reg_magic == MAGIC_ALL)
 		    curchr = Magic('$');
 	    }
@@ -3709,25 +3730,28 @@
 /* TRUE if using multi-line regexp. */
 #define REG_MULTI	(reg_match == NULL)
 
-static int  bt_regexec __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
+static int  bt_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr));
+
 
 /*
  * Match a regexp against a string.
  * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
  * Uses curbuf for line count and 'iskeyword'.
+ * if "line_lbr" is TRUE  consider a "\n" in "line" to be a line break.
  *
  * Return TRUE if there is a match, FALSE if not.
  */
     static int
-bt_regexec(rmp, line, col)
+bt_regexec_nl(rmp, line, col, line_lbr)
     regmatch_T	*rmp;
     char_u	*line;	/* string to match against */
     colnr_T	col;	/* column to start looking for match */
+    int		line_lbr;
 {
     reg_match = rmp;
     reg_mmatch = NULL;
     reg_maxline = 0;
-    reg_line_lbr = FALSE;
+    reg_line_lbr = line_lbr;
     reg_buf = curbuf;
     reg_win = NULL;
     ireg_ic = rmp->rm_ic;
@@ -3738,35 +3762,6 @@
     return (bt_regexec_both(line, col, NULL) != 0);
 }
 
-#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
-	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
-
-static int  bt_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
-
-/*
- * Like vim_regexec(), but consider a "\n" in "line" to be a line break.
- */
-    static int
-bt_regexec_nl(rmp, line, col)
-    regmatch_T	*rmp;
-    char_u	*line;	/* string to match against */
-    colnr_T	col;	/* column to start looking for match */
-{
-    reg_match = rmp;
-    reg_mmatch = NULL;
-    reg_maxline = 0;
-    reg_line_lbr = TRUE;
-    reg_buf = curbuf;
-    reg_win = NULL;
-    ireg_ic = rmp->rm_ic;
-#ifdef FEAT_MBYTE
-    ireg_icombine = FALSE;
-#endif
-    ireg_maxcol = 0;
-    return (bt_regexec_both(line, col, NULL) != 0);
-}
-#endif
-
 static long bt_regexec_multi __ARGS((regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm));
 
 /*
@@ -4146,7 +4141,8 @@
 	    {
 		/* Only accept single line matches. */
 		if (reg_startzpos[i].lnum >= 0
-			&& reg_endzpos[i].lnum == reg_startzpos[i].lnum)
+			&& reg_endzpos[i].lnum == reg_startzpos[i].lnum
+			&& reg_endzpos[i].col >= reg_startzpos[i].col)
 		    re_extmatch_out->matches[i] =
 			vim_strnsave(reg_getline(reg_startzpos[i].lnum)
 						       + reg_startzpos[i].col,
@@ -4179,9 +4175,8 @@
 			    - (*mb_head_off)(regline, reginput - 1), reg_buf);
     return -1;
 }
-
 #endif
-#ifdef FEAT_VISUAL
+
 static int reg_match_visual __ARGS((void));
 
 /*
@@ -4258,7 +4253,6 @@
     }
     return TRUE;
 }
-#endif
 
 #define ADVANCE_REGINPUT() mb_ptr_adv(reginput)
 
@@ -4311,8 +4305,8 @@
    */
   for (;;)
   {
-    /* Some patterns may cause a long time to match, even though they are not
-     * illegal.  E.g., "\([a-z]\+\)\+Q".  Allow breaking them with CTRL-C. */
+    /* Some patterns may take a long time to match, e.g., "\([a-z]\+\)\+Q".
+     * Allow interrupting them with CTRL-C. */
     fast_breakcheck();
 
 #ifdef DEBUG
@@ -4440,9 +4434,7 @@
 	    break;
 
 	  case RE_VISUAL:
-#ifdef FEAT_VISUAL
 	    if (!reg_match_visual())
-#endif
 		status = RA_NOMATCH;
 	    break;
 
@@ -4721,31 +4713,39 @@
 		    /* match empty string always works; happens when "~" is
 		     * empty. */
 		}
-		else if (opnd[1] == NUL
+		else
+		{
+		    if (opnd[1] == NUL
 #ifdef FEAT_MBYTE
 			    && !(enc_utf8 && ireg_ic)
 #endif
 			)
-		    ++reginput;		/* matched a single char */
-		else
-		{
-		    len = (int)STRLEN(opnd);
-		    /* Need to match first byte again for multi-byte. */
-		    if (cstrncmp(opnd, reginput, &len) != 0)
-			status = RA_NOMATCH;
+		    {
+			len = 1;	/* matched a single byte above */
+		    }
+		    else
+		    {
+			/* Need to match first byte again for multi-byte. */
+			len = (int)STRLEN(opnd);
+			if (cstrncmp(opnd, reginput, &len) != 0)
+			    status = RA_NOMATCH;
+		    }
 #ifdef FEAT_MBYTE
-		    /* Check for following composing character. */
-		    else if (enc_utf8
-			       && UTF_COMPOSINGLIKE(reginput, reginput + len))
+		    /* Check for following composing character, unless %C
+		     * follows (skips over all composing chars). */
+		    if (status != RA_NOMATCH
+			    && enc_utf8
+			    && UTF_COMPOSINGLIKE(reginput, reginput + len)
+			    && !ireg_icombine
+			    && OP(next) != RE_COMPOSING)
 		    {
 			/* raaron: This code makes a composing character get
 			 * ignored, which is the correct behavior (sometimes)
 			 * for voweled Hebrew texts. */
-			if (!ireg_icombine)
-			    status = RA_NOMATCH;
+			status = RA_NOMATCH;
 		    }
 #endif
-		    else
+		    if (status != RA_NOMATCH)
 			reginput += len;
 		}
 	    }
@@ -4814,6 +4814,16 @@
 		status = RA_NOMATCH;
 	    break;
 #endif
+	  case RE_COMPOSING:
+#ifdef FEAT_MBYTE
+	    if (enc_utf8)
+	    {
+		/* Skip composing characters. */
+		while (utf_iscomposing(utf_ptr2char(reginput)))
+		    mb_cptr_adv(reginput);
+	    }
+#endif
+	    break;
 
 	  case NOTHING:
 	    break;
@@ -6455,7 +6465,8 @@
 /*
  * Check whether a backreference matches.
  * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.
- * If "bytelen" is not NULL, it is set to the bytelength of the whole match.
+ * If "bytelen" is not NULL, it is set to the byte length of the match in the
+ * last line.
  */
     static int
 match_with_backref(start_lnum, start_col, end_lnum, end_col, bytelen)
@@ -6511,6 +6522,8 @@
 
 	/* Advance to next line. */
 	reg_nextline();
+	if (bytelen != NULL)
+	    *bytelen = 0;
 	++clnum;
 	ccol = 0;
 	if (got_int)
@@ -6998,6 +7011,18 @@
 }
 #endif	    /* DEBUG */
 
+/*
+ * Used in a place where no * or \+ can follow.
+ */
+    static int
+re_mult_next(what)
+    char *what;
+{
+    if (re_multi_type(peekchr()) == MULTI_MULT)
+	EMSG2_RET_FAIL(_("E888: (NFA regexp) cannot repeat %s"), what);
+    return OK;
+}
+
 #ifdef FEAT_MBYTE
 static void mb_decompose __ARGS((int c, int *c1, int *c2, int *c3));
 
@@ -7381,6 +7406,7 @@
     reg_mmatch = NULL;
     reg_maxline = 0;
     reg_buf = curbuf;
+    reg_line_lbr = TRUE;
     return vim_regsub_both(source, dest, copy, magic, backslash);
 }
 #endif
@@ -7400,6 +7426,7 @@
     reg_buf = curbuf;		/* always works on the current buffer! */
     reg_firstlnum = lnum;
     reg_maxline = curbuf->b_ml.ml_line_count - lnum;
+    reg_line_lbr = FALSE;
     return vim_regsub_both(source, dest, copy, magic, backslash);
 }
 
@@ -7898,17 +7925,92 @@
 
     return retval;
 }
+
+/*
+ * Used for the submatch() function with the optional non-zero argument: get
+ * the list of strings from the n'th submatch in allocated memory with NULs
+ * represented in NLs.
+ * Returns a list of allocated strings.  Returns NULL when not in a ":s"
+ * command, for a non-existing submatch and for any error.
+ */
+    list_T *
+reg_submatch_list(no)
+    int		no;
+{
+    char_u	*s;
+    linenr_T	slnum;
+    linenr_T	elnum;
+    colnr_T	scol;
+    colnr_T	ecol;
+    int		i;
+    list_T	*list;
+    int		error = FALSE;
+
+    if (!can_f_submatch || no < 0)
+	return NULL;
+
+    if (submatch_match == NULL)
+    {
+	slnum = submatch_mmatch->startpos[no].lnum;
+	elnum = submatch_mmatch->endpos[no].lnum;
+	if (slnum < 0 || elnum < 0)
+	    return NULL;
+
+	scol = submatch_mmatch->startpos[no].col;
+	ecol = submatch_mmatch->endpos[no].col;
+
+	list = list_alloc();
+	if (list == NULL)
+	    return NULL;
+
+	s = reg_getline_submatch(slnum) + scol;
+	if (slnum == elnum)
+	{
+	    if (list_append_string(list, s, ecol - scol) == FAIL)
+		error = TRUE;
+	}
+	else
+	{
+	    if (list_append_string(list, s, -1) == FAIL)
+		error = TRUE;
+	    for (i = 1; i < elnum - slnum; i++)
+	    {
+		s = reg_getline_submatch(slnum + i);
+		if (list_append_string(list, s, -1) == FAIL)
+		    error = TRUE;
+	    }
+	    s = reg_getline_submatch(elnum);
+	    if (list_append_string(list, s, ecol) == FAIL)
+		error = TRUE;
+	}
+    }
+    else
+    {
+	s = submatch_match->startp[no];
+	if (s == NULL || submatch_match->endp[no] == NULL)
+	    return NULL;
+	list = list_alloc();
+	if (list == NULL)
+	    return NULL;
+	if (list_append_string(list, s,
+				 (int)(submatch_match->endp[no] - s)) == FAIL)
+	    error = TRUE;
+    }
+
+    if (error)
+    {
+	list_free(list, TRUE);
+	return NULL;
+    }
+    return list;
+}
 #endif
 
 static regengine_T bt_regengine =
 {
     bt_regcomp,
     bt_regfree,
-    bt_regexec,
-#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
-	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
     bt_regexec_nl,
-#endif
     bt_regexec_multi
 #ifdef DEBUG
     ,(char_u *)""
@@ -7922,11 +8024,7 @@
 {
     nfa_regcomp,
     nfa_regfree,
-    nfa_regexec,
-#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
-	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
     nfa_regexec_nl,
-#endif
     nfa_regexec_multi
 #ifdef DEBUG
     ,(char_u *)""
@@ -7975,8 +8073,8 @@
 	    regexp_engine = expr[4] - '0';
 	    expr += 5;
 #ifdef DEBUG
-	    EMSG3("New regexp mode selected (%d): %s", regexp_engine,
-						    regname[newengine]);
+	    smsg((char_u *)"New regexp mode selected (%d): %s",
+					   regexp_engine, regname[newengine]);
 #endif
 	}
 	else
@@ -8016,12 +8114,11 @@
 	}
 #endif
 	/*
-	 * If NFA engine failed, then revert to the backtracking engine.
-	 * Except when there was a syntax error, which was properly handled by
-	 * NFA engine.
-	 */
+	 * If the NFA engine failed, the backtracking engine won't work either.
+	 *
 	if (regexp_engine == AUTOMATIC_ENGINE)
 	    prog = bt_regengine.regcomp(expr, re_flags);
+	 */
     }
 
     return prog;
@@ -8051,7 +8148,7 @@
     char_u      *line;  /* string to match against */
     colnr_T     col;    /* column to start looking for match */
 {
-    return rmp->regprog->engine->regexec(rmp, line, col);
+    return rmp->regprog->engine->regexec_nl(rmp, line, col, FALSE);
 }
 
 #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
@@ -8065,7 +8162,7 @@
     char_u *line;
     colnr_T col;
 {
-    return rmp->regprog->engine->regexec_nl(rmp, line, col);
+    return rmp->regprog->engine->regexec_nl(rmp, line, col, TRUE);
 }
 #endif
 
diff -Naur vim74.orig/src/regexp.h vim74/src/regexp.h
--- vim74.orig/src/regexp.h	2013-06-11 08:53:14.000000000 +0000
+++ vim74/src/regexp.h	2014-10-10 14:53:45.315378110 +0000
@@ -149,11 +149,7 @@
 {
     regprog_T	*(*regcomp)(char_u*, int);
     void	(*regfree)(regprog_T *);
-    int		(*regexec)(regmatch_T*, char_u*, colnr_T);
-#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
-	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
-    int		(*regexec_nl)(regmatch_T*, char_u*, colnr_T);
-#endif
+    int		(*regexec_nl)(regmatch_T*, char_u*, colnr_T, int);
     long	(*regexec_multi)(regmmatch_T*, win_T*, buf_T*, linenr_T, colnr_T, proftime_T*);
 #ifdef DEBUG
     char_u	*expr;
diff -Naur vim74.orig/src/regexp_nfa.c vim74/src/regexp_nfa.c
--- vim74.orig/src/regexp_nfa.c	2013-08-01 16:27:51.000000000 +0000
+++ vim74/src/regexp_nfa.c	2014-10-10 14:53:45.322044760 +0000
@@ -29,11 +29,14 @@
 # define NFA_REGEXP_DEBUG_LOG	"nfa_regexp_debug.log"
 #endif
 
+/* Added to NFA_ANY - NFA_NUPPER_IC to include a NL. */
+#define NFA_ADD_NL		31
+
 enum
 {
     NFA_SPLIT = -1024,
     NFA_MATCH,
-    NFA_SKIP_CHAR,		    /* matches a 0-length char */
+    NFA_EMPTY,			    /* matches 0-length */
 
     NFA_START_COLL,		    /* [abc] start */
     NFA_END_COLL,		    /* [abc] end */
@@ -78,6 +81,7 @@
     NFA_COMPOSING,		    /* Next nodes in NFA are part of the
 				       composing multibyte char */
     NFA_END_COMPOSING,		    /* End of a composing char in the NFA */
+    NFA_ANY_COMPOSING,		    /* \%C: Any composing characters. */
     NFA_OPT_CHARS,		    /* \%[abc] */
 
     /* The following are used only in the postfix form, not in the NFA */
@@ -183,6 +187,13 @@
     NFA_NLOWER,		/*	Match non-lowercase char */
     NFA_UPPER,		/*	Match uppercase char */
     NFA_NUPPER,		/*	Match non-uppercase char */
+    NFA_LOWER_IC,	/*	Match [a-z] */
+    NFA_NLOWER_IC,	/*	Match [^a-z] */
+    NFA_UPPER_IC,	/*	Match [A-Z] */
+    NFA_NUPPER_IC,	/*	Match [^A-Z] */
+
+    NFA_FIRST_NL = NFA_ANY + NFA_ADD_NL,
+    NFA_LAST_NL = NFA_NUPPER_IC + NFA_ADD_NL,
 
     NFA_CURSOR,		/*	Match cursor pos */
     NFA_LNUM,		/*	Match line number */
@@ -199,9 +210,6 @@
     NFA_MARK_LT,	/*	Match < mark */
     NFA_VISUAL,		/*	Match Visual area */
 
-    NFA_FIRST_NL = NFA_ANY + ADD_NL,
-    NFA_LAST_NL = NFA_NUPPER + ADD_NL,
-
     /* Character classes [:alnum:] etc */
     NFA_CLASS_ALNUM,
     NFA_CLASS_ALPHA,
@@ -232,7 +240,9 @@
     NFA_UPPER, NFA_NUPPER
 };
 
+static char_u e_nul_found[] = N_("E865: (NFA) Regexp end encountered prematurely");
 static char_u e_misplaced[] = N_("E866: (NFA regexp) Misplaced %c");
+static char_u e_ill_char_class[] = N_("E877: (NFA regexp) Invalid character class: %ld");
 
 /* NFA regexp \ze operator encountered. */
 static int nfa_has_zend;
@@ -302,7 +312,7 @@
 static long nfa_regexec_both __ARGS((char_u *line, colnr_T col));
 static regprog_T *nfa_regcomp __ARGS((char_u *expr, int re_flags));
 static void nfa_regfree __ARGS((regprog_T *prog));
-static int nfa_regexec __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
+static int  nfa_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr));
 static long nfa_regexec_multi __ARGS((regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm));
 static int match_follows __ARGS((nfa_state_T *startstate, int depth));
 static int failure_chance __ARGS((nfa_state_T *state, int depth));
@@ -578,6 +588,8 @@
  * On failure, return 0 (=FAIL)
  * Start points to the first char of the range, while end should point
  * to the closing brace.
+ * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may
+ * need to be interpreted as [a-zA-Z].
  */
     static int
 nfa_recognize_char_class(start, end, extra_newl)
@@ -681,7 +693,7 @@
 	return FAIL;
 
     if (newl == TRUE)
-	extra_newl = ADD_NL;
+	extra_newl = NFA_ADD_NL;
 
     switch (config)
     {
@@ -710,13 +722,13 @@
 	case CLASS_not | CLASS_az | CLASS_AZ:
 	    return extra_newl + NFA_NALPHA;
 	case CLASS_az:
-	   return extra_newl + NFA_LOWER;
+	   return extra_newl + NFA_LOWER_IC;
 	case CLASS_not | CLASS_az:
-	    return extra_newl + NFA_NLOWER;
+	    return extra_newl + NFA_NLOWER_IC;
 	case CLASS_AZ:
-	    return extra_newl + NFA_UPPER;
+	    return extra_newl + NFA_UPPER_IC;
 	case CLASS_not | CLASS_AZ:
-	    return extra_newl + NFA_NUPPER;
+	    return extra_newl + NFA_NUPPER_IC;
     }
     return FAIL;
 }
@@ -733,7 +745,12 @@
 nfa_emit_equi_class(c)
     int	    c;
 {
-#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);
+#define EMIT2(c)    EMIT(c); EMIT(NFA_CONCAT);
+#ifdef FEAT_MBYTE
+# define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);
+#else
+# define EMITMBC(c)
+#endif
 
 #ifdef FEAT_MBYTE
     if (enc_utf8 || STRCMP(p_enc, "latin1") == 0
@@ -744,92 +761,338 @@
 	{
 	    case 'A': case 0300: case 0301: case 0302:
 	    case 0303: case 0304: case 0305:
-		    EMIT2('A');	    EMIT2(0300);    EMIT2(0301);
-		    EMIT2(0302);    EMIT2(0303);    EMIT2(0304);
-		    EMIT2(0305);
+	    CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104) CASEMBC(0x1cd)
+	    CASEMBC(0x1de) CASEMBC(0x1e0) CASEMBC(0x1ea2)
+		    EMIT2('A');	EMIT2(0300); EMIT2(0301); EMIT2(0302);
+		    EMIT2(0303); EMIT2(0304); EMIT2(0305);
+		    EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)
+		    EMITMBC(0x1cd) EMITMBC(0x1de) EMITMBC(0x1e0)
+		    EMITMBC(0x1ea2)
+		    return OK;
+
+	    case 'B': CASEMBC(0x1e02) CASEMBC(0x1e06)
+		    EMIT2('B'); EMITMBC(0x1e02) EMITMBC(0x1e06)
 		    return OK;
 
 	    case 'C': case 0307:
-		    EMIT2('C');	    EMIT2(0307);
+	    CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a) CASEMBC(0x10c)
+		    EMIT2('C'); EMIT2(0307); EMITMBC(0x106) EMITMBC(0x108)
+		    EMITMBC(0x10a) EMITMBC(0x10c)
+		    return OK;
+
+	    case 'D': CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)
+	    CASEMBC(0x1e0e) CASEMBC(0x1e10)
+		    EMIT2('D'); EMITMBC(0x10e) EMITMBC(0x110) EMITMBC(0x1e0a)
+		    EMITMBC(0x1e0e) EMITMBC(0x1e10)
 		    return OK;
 
 	    case 'E': case 0310: case 0311: case 0312: case 0313:
-		    EMIT2('E');	    EMIT2(0310);    EMIT2(0311);
-		    EMIT2(0312);    EMIT2(0313);
+	    CASEMBC(0x112) CASEMBC(0x114) CASEMBC(0x116) CASEMBC(0x118)
+	    CASEMBC(0x11a) CASEMBC(0x1eba) CASEMBC(0x1ebc)
+		    EMIT2('E'); EMIT2(0310); EMIT2(0311); EMIT2(0312);
+		    EMIT2(0313);
+		    EMITMBC(0x112) EMITMBC(0x114) EMITMBC(0x116)
+		    EMITMBC(0x118) EMITMBC(0x11a) EMITMBC(0x1eba)
+		    EMITMBC(0x1ebc)
+		    return OK;
+
+	    case 'F': CASEMBC(0x1e1e)
+		    EMIT2('F'); EMITMBC(0x1e1e)
+		    return OK;
+
+	    case 'G': CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)
+	    CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6) CASEMBC(0x1f4)
+	    CASEMBC(0x1e20)
+		    EMIT2('G'); EMITMBC(0x11c) EMITMBC(0x11e) EMITMBC(0x120)
+		    EMITMBC(0x122) EMITMBC(0x1e4) EMITMBC(0x1e6)
+		    EMITMBC(0x1f4) EMITMBC(0x1e20)
+		    return OK;
+
+	    case 'H': CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)
+	    CASEMBC(0x1e26) CASEMBC(0x1e28)
+		    EMIT2('H'); EMITMBC(0x124) EMITMBC(0x126) EMITMBC(0x1e22)
+		    EMITMBC(0x1e26) EMITMBC(0x1e28)
 		    return OK;
 
 	    case 'I': case 0314: case 0315: case 0316: case 0317:
-		    EMIT2('I');	    EMIT2(0314);    EMIT2(0315);
-		    EMIT2(0316);    EMIT2(0317);
+	    CASEMBC(0x128) CASEMBC(0x12a) CASEMBC(0x12c) CASEMBC(0x12e)
+	    CASEMBC(0x130) CASEMBC(0x1cf) CASEMBC(0x1ec8)
+		    EMIT2('I'); EMIT2(0314); EMIT2(0315); EMIT2(0316);
+		    EMIT2(0317); EMITMBC(0x128) EMITMBC(0x12a)
+		    EMITMBC(0x12c) EMITMBC(0x12e) EMITMBC(0x130)
+		    EMITMBC(0x1cf) EMITMBC(0x1ec8)
+		    return OK;
+
+	    case 'J': CASEMBC(0x134)
+		    EMIT2('J'); EMITMBC(0x134)
+		    return OK;
+
+	    case 'K': CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)
+	    CASEMBC(0x1e34)
+		    EMIT2('K'); EMITMBC(0x136) EMITMBC(0x1e8) EMITMBC(0x1e30)
+		    EMITMBC(0x1e34)
+		    return OK;
+
+	    case 'L': CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)
+	    CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)
+		    EMIT2('L'); EMITMBC(0x139) EMITMBC(0x13b) EMITMBC(0x13d)
+		    EMITMBC(0x13f) EMITMBC(0x141) EMITMBC(0x1e3a)
+		    return OK;
+
+	    case 'M': CASEMBC(0x1e3e) CASEMBC(0x1e40)
+		    EMIT2('M'); EMITMBC(0x1e3e) EMITMBC(0x1e40)
 		    return OK;
 
 	    case 'N': case 0321:
-		    EMIT2('N');	    EMIT2(0321);
+	    CASEMBC(0x143) CASEMBC(0x145) CASEMBC(0x147) CASEMBC(0x1e44)
+	    CASEMBC(0x1e48)
+		    EMIT2('N'); EMIT2(0321); EMITMBC(0x143) EMITMBC(0x145)
+		    EMITMBC(0x147) EMITMBC(0x1e44) EMITMBC(0x1e48)
 		    return OK;
 
 	    case 'O': case 0322: case 0323: case 0324: case 0325:
-	    case 0326:
-		    EMIT2('O');	    EMIT2(0322);    EMIT2(0323);
-		    EMIT2(0324);    EMIT2(0325);    EMIT2(0326);
+	    case 0326: case 0330:
+	    CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150) CASEMBC(0x1a0)
+	    CASEMBC(0x1d1) CASEMBC(0x1ea) CASEMBC(0x1ec) CASEMBC(0x1ece)
+		    EMIT2('O'); EMIT2(0322); EMIT2(0323); EMIT2(0324);
+		    EMIT2(0325); EMIT2(0326); EMIT2(0330);
+		    EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)
+		    EMITMBC(0x1a0) EMITMBC(0x1d1) EMITMBC(0x1ea)
+		    EMITMBC(0x1ec) EMITMBC(0x1ece)
+		    return OK;
+
+	    case 'P': case 0x1e54: case 0x1e56:
+		    EMIT2('P'); EMITMBC(0x1e54) EMITMBC(0x1e56)
+		    return OK;
+
+	    case 'R': CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)
+	    CASEMBC(0x1e58) CASEMBC(0x1e5e)
+		    EMIT2('R'); EMITMBC(0x154) EMITMBC(0x156) EMITMBC(0x158)
+		    EMITMBC(0x1e58) EMITMBC(0x1e5e)
+		    return OK;
+
+	    case 'S': CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)
+	    CASEMBC(0x160) CASEMBC(0x1e60)
+		    EMIT2('S'); EMITMBC(0x15a) EMITMBC(0x15c) EMITMBC(0x15e)
+		    EMITMBC(0x160) EMITMBC(0x1e60)
+		    return OK;
+
+	    case 'T': CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)
+	    CASEMBC(0x1e6a) CASEMBC(0x1e6e)
+		    EMIT2('T'); EMITMBC(0x162) EMITMBC(0x164) EMITMBC(0x166)
+		    EMITMBC(0x1e6a) EMITMBC(0x1e6e)
 		    return OK;
 
 	    case 'U': case 0331: case 0332: case 0333: case 0334:
-		    EMIT2('U');	    EMIT2(0331);    EMIT2(0332);
-		    EMIT2(0333);    EMIT2(0334);
+	    CASEMBC(0x168) CASEMBC(0x16a) CASEMBC(0x16c) CASEMBC(0x16e)
+	    CASEMBC(0x170) CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)
+	    CASEMBC(0x1ee6)
+		    EMIT2('U'); EMIT2(0331); EMIT2(0332); EMIT2(0333);
+		    EMIT2(0334); EMITMBC(0x168) EMITMBC(0x16a)
+		    EMITMBC(0x16c) EMITMBC(0x16e) EMITMBC(0x170)
+		    EMITMBC(0x172) EMITMBC(0x1af) EMITMBC(0x1d3)
+		    EMITMBC(0x1ee6)
+		    return OK;
+
+	    case 'V': CASEMBC(0x1e7c)
+		    EMIT2('V'); EMITMBC(0x1e7c)
+		    return OK;
+
+	    case 'W': CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)
+	    CASEMBC(0x1e84) CASEMBC(0x1e86)
+		    EMIT2('W'); EMITMBC(0x174) EMITMBC(0x1e80) EMITMBC(0x1e82)
+		    EMITMBC(0x1e84) EMITMBC(0x1e86)
+		    return OK;
+
+	    case 'X': CASEMBC(0x1e8a) CASEMBC(0x1e8c)
+		    EMIT2('X'); EMITMBC(0x1e8a) EMITMBC(0x1e8c)
 		    return OK;
 
 	    case 'Y': case 0335:
-		    EMIT2('Y');	    EMIT2(0335);
+	    CASEMBC(0x176) CASEMBC(0x178) CASEMBC(0x1e8e) CASEMBC(0x1ef2)
+	    CASEMBC(0x1ef6) CASEMBC(0x1ef8)
+		    EMIT2('Y'); EMIT2(0335); EMITMBC(0x176) EMITMBC(0x178)
+		    EMITMBC(0x1e8e) EMITMBC(0x1ef2) EMITMBC(0x1ef6)
+		    EMITMBC(0x1ef8)
+		    return OK;
+
+	    case 'Z': CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)
+	    CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)
+		    EMIT2('Z'); EMITMBC(0x179) EMITMBC(0x17b) EMITMBC(0x17d)
+		    EMITMBC(0x1b5) EMITMBC(0x1e90) EMITMBC(0x1e94)
 		    return OK;
 
 	    case 'a': case 0340: case 0341: case 0342:
 	    case 0343: case 0344: case 0345:
-		    EMIT2('a');	    EMIT2(0340);    EMIT2(0341);
-		    EMIT2(0342);    EMIT2(0343);    EMIT2(0344);
-		    EMIT2(0345);
+	    CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105) CASEMBC(0x1ce)
+	    CASEMBC(0x1df) CASEMBC(0x1e1) CASEMBC(0x1ea3)
+		    EMIT2('a'); EMIT2(0340); EMIT2(0341); EMIT2(0342);
+		    EMIT2(0343); EMIT2(0344); EMIT2(0345);
+		    EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)
+		    EMITMBC(0x1ce) EMITMBC(0x1df) EMITMBC(0x1e1)
+		    EMITMBC(0x1ea3)
+		    return OK;
+
+	    case 'b': CASEMBC(0x1e03) CASEMBC(0x1e07)
+		    EMIT2('b'); EMITMBC(0x1e03) EMITMBC(0x1e07)
 		    return OK;
 
 	    case 'c': case 0347:
-		    EMIT2('c');	    EMIT2(0347);
+	    CASEMBC(0x107) CASEMBC(0x109) CASEMBC(0x10b) CASEMBC(0x10d)
+		    EMIT2('c'); EMIT2(0347); EMITMBC(0x107) EMITMBC(0x109)
+		    EMITMBC(0x10b) EMITMBC(0x10d)
+		    return OK;
+
+	    case 'd': CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1d0b)
+	    CASEMBC(0x1e11)
+		    EMIT2('d'); EMITMBC(0x10f) EMITMBC(0x111) EMITMBC(0x1e0b)
+		    EMITMBC(0x01e0f) EMITMBC(0x1e11)
 		    return OK;
 
 	    case 'e': case 0350: case 0351: case 0352: case 0353:
-		    EMIT2('e');	    EMIT2(0350);    EMIT2(0351);
-		    EMIT2(0352);    EMIT2(0353);
+	    CASEMBC(0x113) CASEMBC(0x115) CASEMBC(0x117) CASEMBC(0x119)
+	    CASEMBC(0x11b) CASEMBC(0x1ebb) CASEMBC(0x1ebd)
+		    EMIT2('e'); EMIT2(0350); EMIT2(0351); EMIT2(0352);
+		    EMIT2(0353); EMITMBC(0x113) EMITMBC(0x115)
+		    EMITMBC(0x117) EMITMBC(0x119) EMITMBC(0x11b)
+		    EMITMBC(0x1ebb) EMITMBC(0x1ebd)
+		    return OK;
+
+	    case 'f': CASEMBC(0x1e1f)
+		    EMIT2('f'); EMITMBC(0x1e1f)
+		    return OK;
+
+	    case 'g': CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)
+	    CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7) CASEMBC(0x1f5)
+	    CASEMBC(0x1e21)
+		    EMIT2('g'); EMITMBC(0x11d) EMITMBC(0x11f) EMITMBC(0x121)
+		    EMITMBC(0x123) EMITMBC(0x1e5) EMITMBC(0x1e7)
+		    EMITMBC(0x1f5) EMITMBC(0x1e21)
+		    return OK;
+
+	    case 'h': CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)
+	    CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)
+		    EMIT2('h'); EMITMBC(0x125) EMITMBC(0x127) EMITMBC(0x1e23)
+		    EMITMBC(0x1e27) EMITMBC(0x1e29) EMITMBC(0x1e96)
 		    return OK;
 
 	    case 'i': case 0354: case 0355: case 0356: case 0357:
-		    EMIT2('i');	    EMIT2(0354);    EMIT2(0355);
-		    EMIT2(0356);    EMIT2(0357);
+	    CASEMBC(0x129) CASEMBC(0x12b) CASEMBC(0x12d) CASEMBC(0x12f)
+	    CASEMBC(0x1d0) CASEMBC(0x1ec9)
+		    EMIT2('i'); EMIT2(0354); EMIT2(0355); EMIT2(0356);
+		    EMIT2(0357); EMITMBC(0x129) EMITMBC(0x12b)
+		    EMITMBC(0x12d) EMITMBC(0x12f) EMITMBC(0x1d0)
+		    EMITMBC(0x1ec9)
+		    return OK;
+
+	    case 'j': CASEMBC(0x135) CASEMBC(0x1f0)
+		    EMIT2('j'); EMITMBC(0x135) EMITMBC(0x1f0)
+		    return OK;
+
+	    case 'k': CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)
+	    CASEMBC(0x1e35)
+		    EMIT2('k'); EMITMBC(0x137) EMITMBC(0x1e9) EMITMBC(0x1e31)
+		    EMITMBC(0x1e35)
+		    return OK;
+
+	    case 'l': CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)
+	    CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)
+		    EMIT2('l'); EMITMBC(0x13a) EMITMBC(0x13c) EMITMBC(0x13e)
+		    EMITMBC(0x140) EMITMBC(0x142) EMITMBC(0x1e3b)
+		    return OK;
+
+	    case 'm': CASEMBC(0x1e3f) CASEMBC(0x1e41)
+		    EMIT2('m'); EMITMBC(0x1e3f) EMITMBC(0x1e41)
 		    return OK;
 
 	    case 'n': case 0361:
-		    EMIT2('n');	    EMIT2(0361);
+	    CASEMBC(0x144) CASEMBC(0x146) CASEMBC(0x148) CASEMBC(0x149)
+	    CASEMBC(0x1e45) CASEMBC(0x1e49)
+		    EMIT2('n'); EMIT2(0361); EMITMBC(0x144) EMITMBC(0x146)
+		    EMITMBC(0x148) EMITMBC(0x149) EMITMBC(0x1e45)
+		    EMITMBC(0x1e49)
 		    return OK;
 
 	    case 'o': case 0362: case 0363: case 0364: case 0365:
-	    case 0366:
-		    EMIT2('o');	    EMIT2(0362);    EMIT2(0363);
-		    EMIT2(0364);    EMIT2(0365);    EMIT2(0366);
+	    case 0366: case 0370:
+	    CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151) CASEMBC(0x1a1)
+	    CASEMBC(0x1d2) CASEMBC(0x1eb) CASEMBC(0x1ed) CASEMBC(0x1ecf)
+		    EMIT2('o'); EMIT2(0362); EMIT2(0363); EMIT2(0364);
+		    EMIT2(0365); EMIT2(0366); EMIT2(0370);
+		    EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)
+		    EMITMBC(0x1a1) EMITMBC(0x1d2) EMITMBC(0x1eb)
+		    EMITMBC(0x1ed) EMITMBC(0x1ecf)
+		    return OK;
+
+	    case 'p': CASEMBC(0x1e55) CASEMBC(0x1e57)
+		    EMIT2('p'); EMITMBC(0x1e55) EMITMBC(0x1e57)
+		    return OK;
+
+	    case 'r': CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)
+	    CASEMBC(0x1e59) CASEMBC(0x1e5f)
+		    EMIT2('r'); EMITMBC(0x155) EMITMBC(0x157) EMITMBC(0x159)
+		    EMITMBC(0x1e59) EMITMBC(0x1e5f)
+		    return OK;
+
+	    case 's': CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)
+	    CASEMBC(0x161) CASEMBC(0x1e61)
+		    EMIT2('s'); EMITMBC(0x15b) EMITMBC(0x15d) EMITMBC(0x15f)
+		    EMITMBC(0x161) EMITMBC(0x1e61)
+		    return OK;
+
+	    case 't': CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)
+	    CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)
+		    EMIT2('t'); EMITMBC(0x163) EMITMBC(0x165) EMITMBC(0x167)
+		    EMITMBC(0x1e6b) EMITMBC(0x1e6f) EMITMBC(0x1e97)
 		    return OK;
 
 	    case 'u': case 0371: case 0372: case 0373: case 0374:
-		    EMIT2('u');	    EMIT2(0371);    EMIT2(0372);
-		    EMIT2(0373);    EMIT2(0374);
+	    CASEMBC(0x169) CASEMBC(0x16b) CASEMBC(0x16d) CASEMBC(0x16f)
+	    CASEMBC(0x171) CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)
+	    CASEMBC(0x1ee7)
+		    EMIT2('u'); EMIT2(0371); EMIT2(0372); EMIT2(0373);
+		    EMIT2(0374); EMITMBC(0x169) EMITMBC(0x16b)
+		    EMITMBC(0x16d) EMITMBC(0x16f) EMITMBC(0x171)
+		    EMITMBC(0x173) EMITMBC(0x1b0) EMITMBC(0x1d4)
+		    EMITMBC(0x1ee7)
+		    return OK;
+
+	    case 'v': CASEMBC(0x1e7d)
+		    EMIT2('v'); EMITMBC(0x1e7d)
+		    return OK;
+
+	    case 'w': CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)
+	    CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)
+		    EMIT2('w'); EMITMBC(0x175) EMITMBC(0x1e81) EMITMBC(0x1e83)
+		    EMITMBC(0x1e85) EMITMBC(0x1e87) EMITMBC(0x1e98)
+		    return OK;
+
+	    case 'x': CASEMBC(0x1e8b) CASEMBC(0x1e8d)
+		    EMIT2('x'); EMITMBC(0x1e8b) EMITMBC(0x1e8d)
 		    return OK;
 
 	    case 'y': case 0375: case 0377:
-		    EMIT2('y');	    EMIT2(0375);    EMIT2(0377);
+	    CASEMBC(0x177) CASEMBC(0x1e8f) CASEMBC(0x1e99)
+	    CASEMBC(0x1ef3) CASEMBC(0x1ef7) CASEMBC(0x1ef9)
+		    EMIT2('y'); EMIT2(0375); EMIT2(0377); EMITMBC(0x177)
+		    EMITMBC(0x1e8f) EMITMBC(0x1e99) EMITMBC(0x1ef3)
+		    EMITMBC(0x1ef7) EMITMBC(0x1ef9)
 		    return OK;
 
-	    default:
-		    return FAIL;
+	    case 'z': CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)
+	    CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)
+		    EMIT2('z'); EMITMBC(0x17a) EMITMBC(0x17c) EMITMBC(0x17e)
+		    EMITMBC(0x1b6) EMITMBC(0x1e91) EMITMBC(0x1e95)
+		    return OK;
+
+	    /* default: character itself */
 	}
     }
 
-    EMIT(c);
+    EMIT2(c);
     return OK;
 #undef EMIT2
+#undef EMITMBC
 }
 
 /*
@@ -877,7 +1140,7 @@
     switch (c)
     {
 	case NUL:
-	    EMSG_RET_FAIL(_("E865: (NFA) Regexp end encountered prematurely"));
+	    EMSG_RET_FAIL(_(e_nul_found));
 
 	case Magic('^'):
 	    EMIT(NFA_BOL);
@@ -900,6 +1163,9 @@
 
 	case Magic('_'):
 	    c = no_Magic(getchr());
+	    if (c == NUL)
+		EMSG_RET_FAIL(_(e_nul_found));
+
 	    if (c == '^')	/* "\_^" is start-of-line */
 	    {
 		EMIT(NFA_BOL);
@@ -914,7 +1180,7 @@
 		break;
 	    }
 
-	    extra = ADD_NL;
+	    extra = NFA_ADD_NL;
 
 	    /* "\_[" is collection plus newline */
 	    if (c == '[')
@@ -956,6 +1222,12 @@
 	    p = vim_strchr(classchars, no_Magic(c));
 	    if (p == NULL)
 	    {
+		if (extra == NFA_ADD_NL)
+		{
+		    EMSGN(_(e_ill_char_class), c);
+		    rc_did_emsg = TRUE;
+		    return FAIL;
+		}
 		EMSGN("INTERNAL: Unknown character class char: %ld", c);
 		return FAIL;
 	    }
@@ -970,7 +1242,7 @@
 	    }
 #endif
 	    EMIT(nfa_classcodes[p - classchars]);
-	    if (extra == ADD_NL)
+	    if (extra == NFA_ADD_NL)
 	    {
 		EMIT(NFA_NEWL);
 		EMIT(NFA_OR);
@@ -1051,10 +1323,14 @@
 	    {
 		case 's':
 		    EMIT(NFA_ZSTART);
+		    if (re_mult_next("\\zs") == FAIL)
+			return FAIL;
 		    break;
 		case 'e':
 		    EMIT(NFA_ZEND);
 		    nfa_has_zend = TRUE;
+		    if (re_mult_next("\\ze") == FAIL)
+			return FAIL;
 		    break;
 #ifdef FEAT_SYN_HL
 		case '1':
@@ -1123,8 +1399,9 @@
 			    EMSG2_RET_FAIL(
 			       _("E678: Invalid character after %s%%[dxouU]"),
 				    reg_magic == MAGIC_ALL);
+			/* A NUL is stored in the text as NL */
 			/* TODO: what if a composing character follows? */
-			EMIT(nr);
+			EMIT(nr == 0 ? 0x0a : nr);
 		    }
 		    break;
 
@@ -1146,6 +1423,10 @@
 		    EMIT(NFA_VISUAL);
 		    break;
 
+		case 'C':
+		    EMIT(NFA_ANY_COMPOSING);
+		    break;
+
 		case '[':
 		    {
 			int	    n;
@@ -1240,21 +1521,21 @@
 	    {
 		/*
 		 * Try to reverse engineer character classes. For example,
-		 * recognize that [0-9] stands for  \d and [A-Za-z_] with \h,
+		 * recognize that [0-9] stands for \d and [A-Za-z_] for \h,
 		 * and perform the necessary substitutions in the NFA.
 		 */
 		result = nfa_recognize_char_class(regparse, endp,
-							    extra == ADD_NL);
+							 extra == NFA_ADD_NL);
 		if (result != FAIL)
 		{
-		    if (result >= NFA_DIGIT && result <= NFA_NUPPER)
-			EMIT(result);
-		    else	/* must be char class + newline */
+		    if (result >= NFA_FIRST_NL && result <= NFA_LAST_NL)
 		    {
-			EMIT(result - ADD_NL);
+			EMIT(result - NFA_ADD_NL);
 			EMIT(NFA_NEWL);
 			EMIT(NFA_OR);
 		    }
+		    else
+			EMIT(result);
 		    regparse = endp;
 		    mb_ptr_adv(regparse);
 		    return OK;
@@ -1504,7 +1785,7 @@
 			     * collection, add an OR below. But not for negated
 			     * range. */
 			    if (!negated)
-				extra = ADD_NL;
+				extra = NFA_ADD_NL;
 			}
 			else
 			{
@@ -1537,7 +1818,7 @@
 		    EMIT(NFA_END_COLL);
 
 		/* \_[] also matches \n but it's not negated */
-		if (extra == ADD_NL)
+		if (extra == NFA_ADD_NL)
 		{
 		    EMIT(reg_string ? NL : NFA_NEWL);
 		    EMIT(NFA_OR);
@@ -1744,8 +2025,8 @@
 	    {
 		/* Ignore result of previous call to nfa_regatom() */
 		post_ptr = post_start + my_post_start;
-		/* NFA_SKIP_CHAR has 0-length and works everywhere */
-		EMIT(NFA_SKIP_CHAR);
+		/* NFA_EMPTY is 0-length and works everywhere */
+		EMIT(NFA_EMPTY);
 		return OK;
 	    }
 
@@ -1909,16 +2190,16 @@
 	old_post_pos = (int)(post_ptr - post_start);
 	if (nfa_regconcat() == FAIL)
 	    return FAIL;
-	/* if concat is empty, skip a input char. But do emit a node */
+	/* if concat is empty do emit a node */
 	if (old_post_pos == (int)(post_ptr - post_start))
-	    EMIT(NFA_SKIP_CHAR);
+	    EMIT(NFA_EMPTY);
 	EMIT(NFA_CONCAT);
 	ch = peekchr();
     }
 
-    /* Even if a branch is empty, emit one node for it */
+    /* if a branch is empty, emit one node for it */
     if (old_post_pos == (int)(post_ptr - post_start))
-	EMIT(NFA_SKIP_CHAR);
+	EMIT(NFA_EMPTY);
 
     return OK;
 }
@@ -2011,7 +2292,7 @@
     if (c >= NFA_FIRST_NL && c <= NFA_LAST_NL)
     {
 	addnl = TRUE;
-	c -= ADD_NL;
+	c -= NFA_ADD_NL;
     }
 
     STRCPY(code, "");
@@ -2157,12 +2438,13 @@
 	case NFA_MARK_LT:	STRCPY(code, "NFA_MARK_LT "); break;
 	case NFA_CURSOR:	STRCPY(code, "NFA_CURSOR "); break;
 	case NFA_VISUAL:	STRCPY(code, "NFA_VISUAL "); break;
+	case NFA_ANY_COMPOSING:	STRCPY(code, "NFA_ANY_COMPOSING "); break;
 
 	case NFA_STAR:		STRCPY(code, "NFA_STAR "); break;
 	case NFA_STAR_NONGREEDY: STRCPY(code, "NFA_STAR_NONGREEDY "); break;
 	case NFA_QUEST:		STRCPY(code, "NFA_QUEST"); break;
 	case NFA_QUEST_NONGREEDY: STRCPY(code, "NFA_QUEST_NON_GREEDY"); break;
-	case NFA_SKIP_CHAR:	STRCPY(code, "NFA_SKIP_CHAR"); break;
+	case NFA_EMPTY:		STRCPY(code, "NFA_EMPTY"); break;
 	case NFA_OR:		STRCPY(code, "NFA_OR"); break;
 
 	case NFA_START_COLL:	STRCPY(code, "NFA_START_COLL"); break;
@@ -2217,6 +2499,10 @@
 	case NFA_NLOWER:STRCPY(code, "NFA_NLOWER"); break;
 	case NFA_UPPER:	STRCPY(code, "NFA_UPPER"); break;
 	case NFA_NUPPER:STRCPY(code, "NFA_NUPPER"); break;
+	case NFA_LOWER_IC:  STRCPY(code, "NFA_LOWER_IC"); break;
+	case NFA_NLOWER_IC: STRCPY(code, "NFA_NLOWER_IC"); break;
+	case NFA_UPPER_IC:  STRCPY(code, "NFA_UPPER_IC"); break;
+	case NFA_NUPPER_IC: STRCPY(code, "NFA_NUPPER_IC"); break;
 
 	default:
 	    STRCPY(code, "CHAR(x)");
@@ -2687,6 +2973,11 @@
 	    case NFA_NLOWER:
 	    case NFA_UPPER:
 	    case NFA_NUPPER:
+	    case NFA_LOWER_IC:
+	    case NFA_NLOWER_IC:
+	    case NFA_UPPER_IC:
+	    case NFA_NUPPER_IC:
+	    case NFA_ANY_COMPOSING:
 		/* possibly non-ascii */
 #ifdef FEAT_MBYTE
 		if (has_mbyte)
@@ -2798,7 +3089,7 @@
 	    case NFA_ZSTART:
 	    case NFA_ZEND:
 	    case NFA_OPT_CHARS:
-	    case NFA_SKIP_CHAR:
+	    case NFA_EMPTY:
 	    case NFA_START_PATTERN:
 	    case NFA_END_PATTERN:
 	    case NFA_COMPOSING:
@@ -2996,15 +3287,14 @@
 	    PUSH(frag(e1.start, e2.out));
 	    break;
 
-	case NFA_SKIP_CHAR:
-	    /* Symbol of 0-length, Used in a repetition
-	     * with max/min count of 0 */
+	case NFA_EMPTY:
+	    /* 0-length, used in a repetition with max/min count of 0 */
 	    if (nfa_calc_size == TRUE)
 	    {
 		nstate++;
 		break;
 	    }
-	    s = alloc_state(NFA_SKIP_CHAR, NULL, NULL);
+	    s = alloc_state(NFA_EMPTY, NULL, NULL);
 	    if (s == NULL)
 		goto theend;
 	    PUSH(frag(s, list1(&s->out)));
@@ -3554,6 +3844,7 @@
 static void clear_sub __ARGS((regsub_T *sub));
 static void copy_sub __ARGS((regsub_T *to, regsub_T *from));
 static void copy_sub_off __ARGS((regsub_T *to, regsub_T *from));
+static void copy_ze_off __ARGS((regsub_T *to, regsub_T *from));
 static int sub_equal __ARGS((regsub_T *sub1, regsub_T *sub2));
 static int match_backref __ARGS((regsub_T *sub, int subidx, int *bytelen));
 static int has_state_with_pos __ARGS((nfa_list_T *l, nfa_state_T *state, regsubs_T *subs, nfa_pim_T *pim));
@@ -3641,7 +3932,31 @@
 }
 
 /*
+ * Like copy_sub() but only do the end of the main match if \ze is present.
+ */
+    static void
+copy_ze_off(to, from)
+    regsub_T	*to;
+    regsub_T	*from;
+{
+    if (nfa_has_zend)
+    {
+	if (REG_MULTI)
+	{
+	    if (from->list.multi[0].end.lnum >= 0)
+		to->list.multi[0].end = from->list.multi[0].end;
+	}
+	else
+	{
+	    if (from->list.line[0].end != NULL)
+		to->list.line[0].end = from->list.line[0].end;
+	}
+    }
+}
+
+/*
  * Return TRUE if "sub1" and "sub2" have the same start positions.
+ * When using back-references also check the end position.
  */
     static int
 sub_equal(sub1, sub2)
@@ -3673,6 +3988,23 @@
 	    if (s1 != -1 && sub1->list.multi[i].start.col
 					     != sub2->list.multi[i].start.col)
 		return FALSE;
+
+	    if (nfa_has_backref)
+	    {
+		if (i < sub1->in_use)
+		    s1 = sub1->list.multi[i].end.lnum;
+		else
+		    s1 = -1;
+		if (i < sub2->in_use)
+		    s2 = sub2->list.multi[i].end.lnum;
+		else
+		    s2 = -1;
+		if (s1 != s2)
+		    return FALSE;
+		if (s1 != -1 && sub1->list.multi[i].end.col
+					       != sub2->list.multi[i].end.col)
+		return FALSE;
+	    }
 	}
     }
     else
@@ -3689,6 +4021,19 @@
 		sp2 = NULL;
 	    if (sp1 != sp2)
 		return FALSE;
+	    if (nfa_has_backref)
+	    {
+		if (i < sub1->in_use)
+		    sp1 = sub1->list.line[i].end;
+		else
+		    sp1 = NULL;
+		if (i < sub2->in_use)
+		    sp2 = sub2->list.line[i].end;
+		else
+		    sp2 = NULL;
+		if (sp1 != sp2)
+		    return FALSE;
+	    }
 	}
     }
 
@@ -3765,6 +4110,9 @@
     if (two_unused)
 	/* one is used and two is not: not equal */
 	return FALSE;
+    /* compare the state id */
+    if (one->state->id != two->state->id)
+	return FALSE;
     /* compare the position */
     if (REG_MULTI)
 	return one->end.pos.lnum == two->end.pos.lnum
@@ -3815,6 +4163,7 @@
 		continue;
 
 	    case NFA_ANY:
+	    case NFA_ANY_COMPOSING:
 	    case NFA_IDENT:
 	    case NFA_SIDENT:
 	    case NFA_KWORD:
@@ -3841,6 +4190,10 @@
 	    case NFA_NLOWER:
 	    case NFA_UPPER:
 	    case NFA_NUPPER:
+	    case NFA_LOWER_IC:
+	    case NFA_NLOWER_IC:
+	    case NFA_UPPER_IC:
+	    case NFA_NUPPER_IC:
 	    case NFA_START_COLL:
 	    case NFA_START_NEG_COLL:
 	    case NFA_NEWL:
@@ -3933,7 +4286,7 @@
 	case NFA_MOPEN:
 	case NFA_ZEND:
 	case NFA_SPLIT:
-	case NFA_SKIP_CHAR:
+	case NFA_EMPTY:
 	    /* These nodes are not added themselves but their "out" and/or
 	     * "out1" may be added below.  */
 	    break;
@@ -3979,12 +4332,14 @@
 	     * endless loop for "\(\)*" */
 
 	default:
-	    if (state->lastlist[nfa_ll_index] == l->id)
+	    if (state->lastlist[nfa_ll_index] == l->id && state->c != NFA_SKIP)
 	    {
 		/* This state is already in the list, don't add it again,
 		 * unless it is an MOPEN that is used for a backreference or
-		 * when there is a PIM. */
-		if (!nfa_has_backref && pim == NULL && !l->has_pim)
+		 * when there is a PIM. For NFA_MATCH check the position,
+		 * lower position is preferred. */
+		if (!nfa_has_backref && pim == NULL && !l->has_pim
+						     && state->c != NFA_MATCH)
 		{
 skip_add:
 #ifdef ENABLE_LOG
@@ -4052,7 +4407,7 @@
     switch (state->c)
     {
 	case NFA_MATCH:
-	    nfa_match = TRUE;
+//	    nfa_match = TRUE;
 	    break;
 
 	case NFA_SPLIT:
@@ -4061,7 +4416,7 @@
 	    subs = addstate(l, state->out1, subs, pim, off);
 	    break;
 
-	case NFA_SKIP_CHAR:
+	case NFA_EMPTY:
 	case NFA_NOPEN:
 	case NFA_NCLOSE:
 	    subs = addstate(l, state->out, subs, pim, off);
@@ -4096,7 +4451,7 @@
 		sub = &subs->norm;
 	    }
 #ifdef FEAT_SYN_HL
-	    else if (state->c >= NFA_ZOPEN)
+	    else if (state->c >= NFA_ZOPEN && state->c <= NFA_ZOPEN9)
 	    {
 		subidx = state->c - NFA_ZOPEN;
 		sub = &subs->synt;
@@ -4165,6 +4520,13 @@
 	    }
 
 	    subs = addstate(l, state->out, subs, pim, off);
+	    /* "subs" may have changed, need to set "sub" again */
+#ifdef FEAT_SYN_HL
+	    if (state->c >= NFA_ZOPEN && state->c <= NFA_ZOPEN9)
+		sub = &subs->synt;
+	    else
+#endif
+		sub = &subs->norm;
 
 	    if (save_in_use == -1)
 	    {
@@ -4178,10 +4540,11 @@
 	    break;
 
 	case NFA_MCLOSE:
-	    if (nfa_has_zend)
+	    if (nfa_has_zend && (REG_MULTI
+			? subs->norm.list.multi[0].end.lnum >= 0
+			: subs->norm.list.line[0].end != NULL))
 	    {
-		/* Do not overwrite the position set by \ze. If no \ze
-		 * encountered end will be set in nfa_regtry(). */
+		/* Do not overwrite the position set by \ze. */
 		subs = addstate(l, state->out, subs, pim, off);
 		break;
 	    }
@@ -4213,7 +4576,7 @@
 		sub = &subs->norm;
 	    }
 #ifdef FEAT_SYN_HL
-	    else if (state->c >= NFA_ZCLOSE)
+	    else if (state->c >= NFA_ZCLOSE && state->c <= NFA_ZCLOSE9)
 	    {
 		subidx = state->c - NFA_ZCLOSE;
 		sub = &subs->synt;
@@ -4257,6 +4620,13 @@
 	    }
 
 	    subs = addstate(l, state->out, subs, pim, off);
+	    /* "subs" may have changed, need to set "sub" again */
+#ifdef FEAT_SYN_HL
+	    if (state->c >= NFA_ZCLOSE && state->c <= NFA_ZCLOSE9)
+		sub = &subs->synt;
+	    else
+#endif
+		sub = &subs->norm;
 
 	    if (REG_MULTI)
 		sub->list.multi[subidx].end = save_lpos;
@@ -4419,7 +4789,7 @@
 
 	default:
 	    /* should not be here :P */
-	    EMSGN("E877: (NFA regexp) Invalid character class: %ld", class);
+	    EMSGN(_(e_ill_char_class), class);
 	    return FAIL;
     }
     return FAIL;
@@ -4793,6 +5163,7 @@
 
 	case NFA_MATCH:
 	case NFA_MCLOSE:
+	case NFA_ANY_COMPOSING:
 	    /* empty match works always */
 	    return 0;
 
@@ -5018,6 +5389,7 @@
  * When "nfa_endp" is not NULL it is a required end-of-match position.
  *
  * Return TRUE if there is a match, FALSE otherwise.
+ * When there is a match "submatch" contains the positions.
  * Note: Caller must ensure that: start != NULL.
  */
     static int
@@ -5051,6 +5423,12 @@
 	return FALSE;
     }
 #endif
+    /* Some patterns may take a long time to match, especially when using
+     * recursive_regmatch(). Allow interrupting them with CTRL-C. */
+    fast_breakcheck();
+    if (got_int)
+	return FALSE;
+
     nfa_match = FALSE;
 
     /* Allocate memory for the lists of nodes. */
@@ -5208,6 +5586,12 @@
 	    {
 	    case NFA_MATCH:
 	      {
+#ifdef FEAT_MBYTE
+		/* If the match ends before a composing characters and
+		 * ireg_icombine is not set, that is not really a match. */
+		if (enc_utf8 && !ireg_icombine && utf_iscomposing(curc))
+		    break;
+#endif
 		nfa_match = TRUE;
 		copy_sub(&submatch->norm, &t->subs.norm);
 #ifdef FEAT_SYN_HL
@@ -5278,7 +5662,10 @@
 		log_subsexpr(m);
 #endif
 		nfa_match = TRUE;
-		break;
+		/* See comment above at "goto nextchar". */
+		if (nextlist->n == 0)
+		    clen = 0;
+		goto nextchar;
 
 	    case NFA_START_INVISIBLE:
 	    case NFA_START_INVISIBLE_FIRST:
@@ -5304,9 +5691,13 @@
 		    {
 			int in_use = m->norm.in_use;
 
-			/* Copy submatch info for the recursive call, so that
-			 * \1 can be matched. */
+			/* Copy submatch info for the recursive call, opposite
+			 * of what happens on success below. */
 			copy_sub_off(&m->norm, &t->subs.norm);
+#ifdef FEAT_SYN_HL
+			if (nfa_has_zsubexpr)
+			    copy_sub_off(&m->synt, &t->subs.synt);
+#endif
 
 			/*
 			 * First try matching the invisible match, then what
@@ -5330,6 +5721,9 @@
 			    if (nfa_has_zsubexpr)
 				copy_sub_off(&t->subs.synt, &m->synt);
 #endif
+			    /* If the pattern has \ze and it matched in the
+			     * sub pattern, use it. */
+			    copy_ze_off(&t->subs.norm, &m->norm);
 
 			    /* t->state->out1 is the corresponding
 			     * END_INVISIBLE node; Add its out to the current
@@ -5413,6 +5807,13 @@
 #endif
 		    break;
 		}
+		/* Copy submatch info to the recursive call, opposite of what
+		 * happens afterwards. */
+		copy_sub_off(&m->norm, &t->subs.norm);
+#ifdef FEAT_SYN_HL
+		if (nfa_has_zsubexpr)
+		    copy_sub_off(&m->synt, &t->subs.synt);
+#endif
 
 		/* First try matching the pattern. */
 		result = recursive_regmatch(t->state, NULL, prog,
@@ -5738,6 +6139,23 @@
 		}
 		break;
 
+	    case NFA_ANY_COMPOSING:
+		/* On a composing character skip over it.  Otherwise do
+		 * nothing.  Always matches. */
+#ifdef FEAT_MBYTE
+		if (enc_utf8 && utf_iscomposing(curc))
+		{
+		    add_off = clen;
+		}
+		else
+#endif
+		{
+		    add_here = TRUE;
+		    add_off = 0;
+		}
+		add_state = t->state->out;
+		break;
+
 	    /*
 	     * Character classes like \a for alpha, \d for digit etc.
 	     */
@@ -5872,6 +6290,28 @@
 		ADD_STATE_IF_MATCH(t->state);
 		break;
 
+	    case NFA_LOWER_IC:	/* [a-z] */
+		result = ri_lower(curc) || (ireg_ic && ri_upper(curc));
+		ADD_STATE_IF_MATCH(t->state);
+		break;
+
+	    case NFA_NLOWER_IC:	/* [^a-z] */
+		result = curc != NUL
+			  && !(ri_lower(curc) || (ireg_ic && ri_upper(curc)));
+		ADD_STATE_IF_MATCH(t->state);
+		break;
+
+	    case NFA_UPPER_IC:	/* [A-Z] */
+		result = ri_upper(curc) || (ireg_ic && ri_lower(curc));
+		ADD_STATE_IF_MATCH(t->state);
+		break;
+
+	    case NFA_NUPPER_IC:	/* ^[A-Z] */
+		result = curc != NUL
+			  && !(ri_upper(curc) || (ireg_ic && ri_lower(curc)));
+		ADD_STATE_IF_MATCH(t->state);
+		break;
+
 	    case NFA_BACKREF1:
 	    case NFA_BACKREF2:
 	    case NFA_BACKREF3:
@@ -6032,14 +6472,12 @@
 		break;
 
 	    case NFA_VISUAL:
-#ifdef FEAT_VISUAL
 		result = reg_match_visual();
 		if (result)
 		{
 		    add_here = TRUE;
 		    add_state = t->state->out;
 		}
-#endif
 		break;
 
 	    case NFA_MOPEN1:
@@ -6082,12 +6520,10 @@
 		if (!result && ireg_ic)
 		    result = MB_TOLOWER(c) == MB_TOLOWER(curc);
 #ifdef FEAT_MBYTE
-		/* If there is a composing character which is not being
-		 * ignored there can be no match. Match with composing
-		 * character uses NFA_COMPOSING above. */
-		if (result && enc_utf8 && !ireg_icombine
-						&& clen != utf_char2len(curc))
-		    result = FALSE;
+		/* If ireg_icombine is not set only skip over the character
+		 * itself.  When it is set skip over composing characters. */
+		if (result && enc_utf8 && !ireg_icombine)
+		    clen = utf_char2len(curc);
 #endif
 		ADD_STATE_IF_MATCH(t->state);
 		break;
@@ -6098,6 +6534,7 @@
 	    if (add_state != NULL)
 	    {
 		nfa_pim_T *pim;
+		nfa_pim_T pim_copy;
 
 		if (t->pim.result == NFA_PIM_UNUSED)
 		    pim = NULL;
@@ -6171,6 +6608,15 @@
 		    pim = NULL;
 		}
 
+		/* If "pim" points into l->t it will become invalid when
+		 * adding the state causes the list to be reallocated.  Make a
+		 * local copy to avoid that. */
+		if (pim == &t->pim)
+		{
+		    copy_pim(&pim_copy, pim);
+		    pim = &pim_copy;
+		}
+
 		if (add_here)
 		    addstate_here(thislist, add_state, &t->subs, pim, &listidx);
 		else
@@ -6402,8 +6848,10 @@
 	    {
 		struct multipos *mpos = &subs.synt.list.multi[i];
 
-		/* Only accept single line matches. */
-		if (mpos->start.lnum >= 0 && mpos->start.lnum == mpos->end.lnum)
+		/* Only accept single line matches that are valid. */
+		if (mpos->start.lnum >= 0
+			&& mpos->start.lnum == mpos->end.lnum
+			&& mpos->end.col >= mpos->start.col)
 		    re_extmatch_out->matches[i] =
 			vim_strnsave(reg_getline(mpos->start.lnum)
 							    + mpos->start.col,
@@ -6679,47 +7127,21 @@
  * Match a regexp against a string.
  * "rmp->regprog" is a compiled regexp as returned by nfa_regcomp().
  * Uses curbuf for line count and 'iskeyword'.
+ * If "line_lbr" is TRUE consider a "\n" in "line" to be a line break.
  *
  * Return TRUE if there is a match, FALSE if not.
  */
     static int
-nfa_regexec(rmp, line, col)
-    regmatch_T	*rmp;
-    char_u	*line;	/* string to match against */
-    colnr_T	col;	/* column to start looking for match */
-{
-    reg_match = rmp;
-    reg_mmatch = NULL;
-    reg_maxline = 0;
-    reg_line_lbr = FALSE;
-    reg_buf = curbuf;
-    reg_win = NULL;
-    ireg_ic = rmp->rm_ic;
-#ifdef FEAT_MBYTE
-    ireg_icombine = FALSE;
-#endif
-    ireg_maxcol = 0;
-    return (nfa_regexec_both(line, col) != 0);
-}
-
-#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
-	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
-
-static int  nfa_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
-
-/*
- * Like nfa_regexec(), but consider a "\n" in "line" to be a line break.
- */
-    static int
-nfa_regexec_nl(rmp, line, col)
+nfa_regexec_nl(rmp, line, col, line_lbr)
     regmatch_T	*rmp;
     char_u	*line;	/* string to match against */
     colnr_T	col;	/* column to start looking for match */
+    int		line_lbr;
 {
     reg_match = rmp;
     reg_mmatch = NULL;
     reg_maxline = 0;
-    reg_line_lbr = TRUE;
+    reg_line_lbr = line_lbr;
     reg_buf = curbuf;
     reg_win = NULL;
     ireg_ic = rmp->rm_ic;
@@ -6729,7 +7151,6 @@
     ireg_maxcol = 0;
     return (nfa_regexec_both(line, col) != 0);
 }
-#endif
 
 
 /*
diff -Naur vim74.orig/src/screen.c vim74/src/screen.c
--- vim74.orig/src/screen.c	2013-07-13 10:23:00.000000000 +0000
+++ vim74/src/screen.c	2014-10-10 14:53:45.332044735 +0000
@@ -42,7 +42,7 @@
  *
  * The part of the buffer that is displayed in a window is set with:
  * - w_topline (first buffer line in window)
- * - w_topfill (filler line above the first line)
+ * - w_topfill (filler lines above the first line)
  * - w_leftcol (leftmost window cell in window),
  * - w_skipcol (skipped window cells of first line)
  *
@@ -139,12 +139,13 @@
 static void redraw_custom_statusline __ARGS((win_T *wp));
 #endif
 #ifdef FEAT_SEARCH_EXTRA
-#define SEARCH_HL_PRIORITY 0
+# define SEARCH_HL_PRIORITY 0
 static void start_search_hl __ARGS((void));
 static void end_search_hl __ARGS((void));
 static void init_search_hl __ARGS((win_T *wp));
 static void prepare_search_hl __ARGS((win_T *wp, linenr_T lnum));
-static void next_search_hl __ARGS((win_T *win, match_T *shl, linenr_T lnum, colnr_T mincol));
+static void next_search_hl __ARGS((win_T *win, match_T *shl, linenr_T lnum, colnr_T mincol, matchitem_T *cur));
+static int next_search_hl_pos __ARGS((match_T *shl, linenr_T lnum, posmatch_T *pos, colnr_T mincol));
 #endif
 static void screen_start_highlight __ARGS((int attr));
 static void screen_char __ARGS((unsigned off, int row, int col));
@@ -446,8 +447,6 @@
 #endif
 }
 
-#if defined(FEAT_RUBY) || defined(FEAT_PERL) || defined(FEAT_VISUAL) || \
-    (defined(FEAT_CLIPBOARD) && defined(FEAT_X11)) || defined(PROTO)
 /*
  * update all windows that are editing the current buffer
  */
@@ -458,7 +457,6 @@
     redraw_curbuf_later(type);
     update_screen(type);
 }
-#endif
 
 /*
  * update_screen()
@@ -596,14 +594,12 @@
 		    && curwin->w_botfill == curwin->w_old_botfill
 #endif
 		    && curwin->w_topline == curwin->w_lines[0].wl_lnum)
-#ifdef FEAT_VISUAL
 		|| (type == INVERTED
 		    && VIsual_active
 		    && curwin->w_old_cursor_lnum == curwin->w_cursor.lnum
 		    && curwin->w_old_visual_mode == VIsual_mode
 		    && (curwin->w_valid & VALID_VIRTCOL)
 		    && curwin->w_old_curswant == curwin->w_curswant)
-#endif
 		))
 	curwin->w_redr_type = type;
 
@@ -1030,10 +1026,8 @@
 				   updating.  0 when no mid area updating. */
     int		bot_start = 999;/* first row of the bot area that needs
 				   updating.  999 when no bot area updating */
-#ifdef FEAT_VISUAL
     int		scrolled_down = FALSE;	/* TRUE when scrolled down when
 					   w_topline got smaller a bit */
-#endif
 #ifdef FEAT_SEARCH_EXTRA
     matchitem_T *cur;		/* points to the match list */
     int		top_to_mod = FALSE;    /* redraw above mod_top */
@@ -1354,9 +1348,7 @@
 			    /* Need to update rows that are new, stop at the
 			     * first one that scrolled down. */
 			    top_end = i;
-#ifdef FEAT_VISUAL
 			    scrolled_down = TRUE;
-#endif
 
 			    /* Move the entries that were scrolled, disable
 			     * the entries for the lines to be redrawn. */
@@ -1513,7 +1505,6 @@
 	type = NOT_VALID;
     }
 
-#ifdef FEAT_VISUAL
     /* check if we are updating or removing the inverted part */
     if ((VIsual_active && buf == curwin->w_buffer)
 	    || (wp->w_old_cursor_lnum != 0 && type != NOT_VALID))
@@ -1593,9 +1584,17 @@
 	     */
 	    if (VIsual_mode == Ctrl_V)
 	    {
-		colnr_T	fromc, toc;
+		colnr_T	    fromc, toc;
+#if defined(FEAT_VIRTUALEDIT) && defined(FEAT_LINEBREAK)
+		int	    save_ve_flags = ve_flags;
 
+		if (curwin->w_p_lbr)
+		    ve_flags = VE_ALL;
+#endif
 		getvcols(wp, &VIsual, &curwin->w_cursor, &fromc, &toc);
+#if defined(FEAT_VIRTUALEDIT) && defined(FEAT_LINEBREAK)
+		ve_flags = save_ve_flags;
+#endif
 		++toc;
 		if (curwin->w_curswant == MAXCOL)
 		    toc = MAXCOL;
@@ -1708,7 +1707,6 @@
 	wp->w_old_visual_lnum = 0;
 	wp->w_old_visual_col = 0;
     }
-#endif /* FEAT_VISUAL */
 
 #if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
     /* reset got_int, otherwise regexp won't work */
@@ -1779,8 +1777,10 @@
 					syntax_check_changed(lnum)))
 #endif
 #ifdef FEAT_SEARCH_EXTRA
-				/* match in fixed position might need redraw */
-				||  wp->w_match_head != NULL
+				/* match in fixed position might need redraw
+				 * if lines were inserted or deleted */
+				|| (wp->w_match_head != NULL
+						    && buf->b_mod_xlines != 0)
 #endif
 				)))))
 	{
@@ -2467,8 +2467,8 @@
 	if (len > 0)
 	{
 	    int	    w = number_width(wp);
-	    long num;
-	    char *fmt = "%*ld ";
+	    long    num;
+	    char    *fmt = "%*ld ";
 
 	    if (len > w + 1)
 		len = w + 1;
@@ -2670,7 +2670,6 @@
      * 6. set highlighting for the Visual area an other text.
      * If all folded lines are in the Visual area, highlight the line.
      */
-#ifdef FEAT_VISUAL
     if (VIsual_active && wp->w_buffer == curwin->w_buffer)
     {
 	if (ltoreq(curwin->w_cursor, VIsual))
@@ -2718,7 +2717,6 @@
 	    }
 	}
     }
-#endif
 
 #ifdef FEAT_SYN_HL
     /* Show 'cursorcolumn' in the fold line. */
@@ -2853,6 +2851,7 @@
     char_u	extra[18];		/* "%ld" and 'fdc' must fit in here */
     int		n_extra = 0;		/* number of extra chars */
     char_u	*p_extra = NULL;	/* string of extra chars, plus NUL */
+    char_u	*p_extra_free = NULL;   /* p_extra needs to be freed */
     int		c_extra = NUL;		/* extra chars, all the same */
     int		extra_attr = 0;		/* attributes when n_extra != 0 */
     static char_u *at_end_str = (char_u *)""; /* used for p_extra when
@@ -2876,10 +2875,8 @@
     int		fromcol, tocol;		/* start/end of inverting */
     int		fromcol_prev = -2;	/* start of inverting after cursor */
     int		noinvcur = FALSE;	/* don't invert the cursor */
-#ifdef FEAT_VISUAL
     pos_T	*top, *bot;
     int		lnum_in_visual_area = FALSE;
-#endif
     pos_T	pos;
     long	v;
 
@@ -2944,6 +2941,8 @@
     match_T	*shl;			/* points to search_hl or a match */
     int		shl_flag;		/* flag to indicate whether search_hl
 					   has been processed or not */
+    int		pos_inprogress;		/* marks that position match search is
+					   in progress */
     int		prevcol_hl_flag;	/* flag to indicate whether prevcol
 					   equals startcol of search_hl or one
 					   of the matches */
@@ -2974,10 +2973,15 @@
 # define WL_SIGN	WL_FOLD		/* column for signs */
 #endif
 #define WL_NR		WL_SIGN + 1	/* line number */
+#ifdef FEAT_LINEBREAK
+# define WL_BRI		WL_NR + 1	/* 'breakindent' */
+#else
+# define WL_BRI		WL_NR
+#endif
 #if defined(FEAT_LINEBREAK) || defined(FEAT_DIFF)
-# define WL_SBR		WL_NR + 1	/* 'showbreak' or 'diff' */
+# define WL_SBR		WL_BRI + 1	/* 'showbreak' or 'diff' */
 #else
-# define WL_SBR		WL_NR
+# define WL_SBR		WL_BRI
 #endif
 #define WL_LINE		WL_SBR + 1	/* text in the line */
     int		draw_state = WL_START;	/* what to draw next */
@@ -3090,7 +3094,6 @@
      */
     fromcol = -10;
     tocol = MAXCOL;
-#ifdef FEAT_VISUAL
     if (VIsual_active && wp->w_buffer == curwin->w_buffer)
     {
 					/* Visual is after curwin->w_cursor */
@@ -3183,9 +3186,7 @@
     /*
      * handle 'incsearch' and ":s///c" highlighting
      */
-    else
-#endif /* FEAT_VISUAL */
-	if (highlight_match
+    else if (highlight_match
 	    && wp == curwin
 	    && lnum >= curwin->w_cursor.lnum
 	    && lnum <= curwin->w_cursor.lnum + search_match_lines)
@@ -3316,7 +3317,7 @@
 #endif
 	while (vcol < v && *ptr != NUL)
 	{
-	    c = win_lbr_chartabsize(wp, ptr, (colnr_T)vcol, NULL);
+	    c = win_lbr_chartabsize(wp, line, ptr, (colnr_T)vcol, NULL);
 	    vcol += c;
 #ifdef FEAT_MBYTE
 	    prev_ptr = ptr;
@@ -3324,7 +3325,6 @@
 	    mb_ptr_adv(ptr);
 	}
 
-#if defined(FEAT_SYN_HL) || defined(FEAT_VIRTUALEDIT) || defined(FEAT_VISUAL)
 	/* When:
 	 * - 'cuc' is set, or
 	 * - 'colorcolumn' is set, or
@@ -3333,27 +3333,16 @@
 	 * the end of the line may be before the start of the displayed part.
 	 */
 	if (vcol < v && (
-# ifdef FEAT_SYN_HL
-	     wp->w_p_cuc
-	     || draw_color_col
-#  if defined(FEAT_VIRTUALEDIT) || defined(FEAT_VISUAL)
-	     ||
-#  endif
-# endif
-# ifdef FEAT_VIRTUALEDIT
-	     virtual_active()
-#  ifdef FEAT_VISUAL
-	     ||
-#  endif
-# endif
-# ifdef FEAT_VISUAL
-	     (VIsual_active && wp->w_buffer == curwin->w_buffer)
-# endif
-	     ))
+#ifdef FEAT_SYN_HL
+	     wp->w_p_cuc || draw_color_col ||
+#endif
+#ifdef FEAT_VIRTUALEDIT
+	     virtual_active() ||
+#endif
+	     (VIsual_active && wp->w_buffer == curwin->w_buffer)))
 	{
 	    vcol = v;
 	}
-#endif
 
 	/* Handle a character that's not completely on the screen: Put ptr at
 	 * that character but skip the first few screen characters. */
@@ -3469,44 +3458,43 @@
 	shl->startcol = MAXCOL;
 	shl->endcol = MAXCOL;
 	shl->attr_cur = 0;
-	if (shl->rm.regprog != NULL)
-	{
-	    v = (long)(ptr - line);
-	    next_search_hl(wp, shl, lnum, (colnr_T)v);
+	v = (long)(ptr - line);
+	if (cur != NULL)
+	    cur->pos.cur = 0;
+	next_search_hl(wp, shl, lnum, (colnr_T)v, cur);
 
-	    /* Need to get the line again, a multi-line regexp may have made it
-	     * invalid. */
-	    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
-	    ptr = line + v;
+	/* Need to get the line again, a multi-line regexp may have made it
+	 * invalid. */
+	line = ml_get_buf(wp->w_buffer, lnum, FALSE);
+	ptr = line + v;
 
-	    if (shl->lnum != 0 && shl->lnum <= lnum)
+	if (shl->lnum != 0 && shl->lnum <= lnum)
+	{
+	    if (shl->lnum == lnum)
+		shl->startcol = shl->rm.startpos[0].col;
+	    else
+		shl->startcol = 0;
+	    if (lnum == shl->lnum + shl->rm.endpos[0].lnum
+						- shl->rm.startpos[0].lnum)
+		shl->endcol = shl->rm.endpos[0].col;
+	    else
+		shl->endcol = MAXCOL;
+	    /* Highlight one character for an empty match. */
+	    if (shl->startcol == shl->endcol)
 	    {
-		if (shl->lnum == lnum)
-		    shl->startcol = shl->rm.startpos[0].col;
-		else
-		    shl->startcol = 0;
-		if (lnum == shl->lnum + shl->rm.endpos[0].lnum
-						  - shl->rm.startpos[0].lnum)
-		    shl->endcol = shl->rm.endpos[0].col;
-		else
-		    shl->endcol = MAXCOL;
-		/* Highlight one character for an empty match. */
-		if (shl->startcol == shl->endcol)
-		{
 #ifdef FEAT_MBYTE
-		    if (has_mbyte && line[shl->endcol] != NUL)
-			shl->endcol += (*mb_ptr2len)(line + shl->endcol);
-		    else
+		if (has_mbyte && line[shl->endcol] != NUL)
+		    shl->endcol += (*mb_ptr2len)(line + shl->endcol);
+		else
 #endif
-			++shl->endcol;
-		}
-		if ((long)shl->startcol < v)  /* match at leftcol */
-		{
-		    shl->attr_cur = shl->attr;
-		    search_attr = shl->attr;
-		}
-		area_highlighting = TRUE;
+		    ++shl->endcol;
 	    }
+	    if ((long)shl->startcol < v)  /* match at leftcol */
+	    {
+		shl->attr_cur = shl->attr;
+		search_attr = shl->attr;
+	    }
+	    area_highlighting = TRUE;
 	}
 	if (shl != &search_hl && cur != NULL)
 	    cur = cur->next;
@@ -3518,7 +3506,7 @@
      * when Visual mode is active, because it's not clear what is selected
      * then. */
     if (wp->w_p_cul && lnum == wp->w_cursor.lnum
-					 && !(wp == curwin  && VIsual_active))
+					 && !(wp == curwin && VIsual_active))
     {
 	line_attr = hl_attr(HLF_CUL);
 	area_highlighting = TRUE;
@@ -3583,11 +3571,7 @@
 		draw_state = WL_SIGN;
 		/* Show the sign column when there are any signs in this
 		 * buffer or when using Netbeans. */
-		if (draw_signcolumn(wp)
-# ifdef FEAT_DIFF
-			&& filler_todo <= 0
-# endif
-		   )
+		if (draw_signcolumn(wp))
 		{
 		    int	text_sign;
 # ifdef FEAT_SIGN_ICONS
@@ -3599,7 +3583,11 @@
 		    char_attr = hl_attr(HLF_SC);
 		    n_extra = 2;
 
-		    if (row == startrow)
+		    if (row == startrow
+#ifdef FEAT_DIFF
+			    + filler_lines && filler_todo <= 0
+#endif
+			    )
 		    {
 			text_sign = buf_getsigntype(wp->w_buffer, lnum,
 								   SIGN_TEXT);
@@ -3698,6 +3686,49 @@
 		}
 	    }
 
+#ifdef FEAT_LINEBREAK
+	    if (wp->w_p_brisbr && draw_state == WL_BRI - 1
+					     && n_extra == 0 && *p_sbr != NUL)
+		/* draw indent after showbreak value */
+		draw_state = WL_BRI;
+	    else if (wp->w_p_brisbr && draw_state == WL_SBR && n_extra == 0)
+		/* After the showbreak, draw the breakindent */
+		draw_state = WL_BRI - 1;
+
+	    /* draw 'breakindent': indent wrapped text accordingly */
+	    if (draw_state == WL_BRI - 1 && n_extra == 0)
+	    {
+		draw_state = WL_BRI;
+# ifdef FEAT_DIFF
+# endif
+		if (wp->w_p_bri && n_extra == 0 && row != startrow
+#ifdef FEAT_DIFF
+			&& filler_lines == 0
+#endif
+		   )
+		{
+		    char_attr = 0; /* was: hl_attr(HLF_AT); */
+#ifdef FEAT_DIFF
+		    if (diff_hlf != (hlf_T)0)
+		    {
+			char_attr = hl_attr(diff_hlf);
+			if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
+			    char_attr = hl_combine_attr(char_attr,
+							    hl_attr(HLF_CUL));
+		    }
+#endif
+		    p_extra = NULL;
+		    c_extra = ' ';
+		    n_extra = get_breakindent_win(wp,
+				       ml_get_buf(wp->w_buffer, lnum, FALSE));
+		    /* Correct end of highlighted area for 'breakindent',
+		     * required when 'linebreak' is also set. */
+		    if (tocol == vcol)
+			tocol += n_extra;
+		}
+	    }
+#endif
+
 #if defined(FEAT_LINEBREAK) || defined(FEAT_DIFF)
 	    if (draw_state == WL_SBR - 1 && n_extra == 0)
 	    {
@@ -3735,7 +3766,8 @@
 #ifdef FEAT_SYN_HL
 		    /* combine 'showbreak' with 'cursorline' */
 		    if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
-			char_attr = hl_combine_attr(char_attr, HLF_CLN);
+			char_attr = hl_combine_attr(char_attr,
+							    hl_attr(HLF_CUL));
 #endif
 		}
 # endif
@@ -3822,7 +3854,11 @@
 		    }
 		    else
 			shl = &cur->hl;
-		    while (shl->rm.regprog != NULL)
+		    if (cur != NULL)
+			cur->pos.cur = 0;
+		    pos_inprogress = TRUE;
+		    while (shl->rm.regprog != NULL
+					   || (cur != NULL && pos_inprogress))
 		    {
 			if (shl->startcol != MAXCOL
 				&& v >= (long)shl->startcol
@@ -3830,11 +3866,12 @@
 			{
 			    shl->attr_cur = shl->attr;
 			}
-			else if (v == (long)shl->endcol)
+			else if (v >= (long)shl->endcol && shl->lnum == lnum)
 			{
 			    shl->attr_cur = 0;
-
-			    next_search_hl(wp, shl, lnum, (colnr_T)v);
+			    next_search_hl(wp, shl, lnum, (colnr_T)v, cur);
+			    pos_inprogress = cur == NULL || cur->pos.cur == 0
+							      ? FALSE : TRUE;
 
 			    /* Need to get the line again, a multi-line regexp
 			     * may have made it invalid. */
@@ -3908,6 +3945,8 @@
 							      && n_extra == 0)
 		    diff_hlf = HLF_CHD;		/* changed line */
 		line_attr = hl_attr(diff_hlf);
+		if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
+		    line_attr = hl_combine_attr(line_attr, hl_attr(HLF_CUL));
 	    }
 #endif
 
@@ -4031,6 +4070,11 @@
 	}
 	else
 	{
+	    if (p_extra_free != NULL)
+	    {
+		vim_free(p_extra_free);
+		p_extra_free = NULL;
+	    }
 	    /*
 	     * Get a character from the line itself.
 	     */
@@ -4402,14 +4446,16 @@
 		/*
 		 * Found last space before word: check for line break.
 		 */
-		if (wp->w_p_lbr && vim_isbreak(c) && !vim_isbreak(*ptr)
-							     && !wp->w_p_list)
+		if (wp->w_p_lbr && vim_isbreak(c) && !vim_isbreak(*ptr))
 		{
-		    n_extra = win_lbr_chartabsize(wp, ptr - (
+		    char_u *p = ptr - (
 # ifdef FEAT_MBYTE
 				has_mbyte ? mb_l :
 # endif
-				1), (colnr_T)vcol, NULL) - 1;
+				1);
+		    /* TODO: is passing p for start of the line OK? */
+		    n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol,
+								    NULL) - 1;
 		    c_extra = ' ';
 		    if (vim_iswhite(c))
 		    {
@@ -4418,7 +4464,8 @@
 			    /* See "Tab alignment" below. */
 			    FIX_FOR_BOGUSCOLS;
 #endif
-			c = ' ';
+			if (!wp->w_p_list)
+			    c = ' ';
 		    }
 		}
 #endif
@@ -4458,9 +4505,61 @@
 		 */
 		if (c == TAB && (!wp->w_p_list || lcs_tab1))
 		{
+		    int tab_len = 0;
 		    /* tab amount depends on current column */
-		    n_extra = (int)wp->w_buffer->b_p_ts
+		    tab_len = (int)wp->w_buffer->b_p_ts
 					- vcol % (int)wp->w_buffer->b_p_ts - 1;
+#ifdef FEAT_LINEBREAK
+		    if (!wp->w_p_lbr || !wp->w_p_list)
+#endif
+		    /* tab amount depends on current column */
+			n_extra = tab_len;
+#ifdef FEAT_LINEBREAK
+		    else
+		    {
+			char_u *p;
+			int	len = n_extra;
+			int	i;
+			int	saved_nextra = n_extra;
+
+#ifdef FEAT_CONCEAL
+			if (is_concealing && vcol_off > 0)
+			    /* there are characters to conceal */
+			    tab_len += vcol_off;
+#endif
+			/* if n_extra > 0, it gives the number of chars, to
+			 * use for a tab, else we need to calculate the width
+			 * for a tab */
+#ifdef FEAT_MBYTE
+			len = (tab_len * mb_char2len(lcs_tab2));
+			if (n_extra > 0)
+			    len += n_extra - tab_len;
+#endif
+			c = lcs_tab1;
+			p = alloc((unsigned)(len + 1));
+			vim_memset(p, ' ', len);
+			p[len] = NUL;
+			p_extra_free = p;
+			for (i = 0; i < tab_len; i++)
+			{
+#ifdef FEAT_MBYTE
+			    mb_char2bytes(lcs_tab2, p);
+			    p += mb_char2len(lcs_tab2);
+			    n_extra += mb_char2len(lcs_tab2)
+						 - (saved_nextra > 0 ? 1 : 0);
+#else
+			    p[i] = lcs_tab2;
+#endif
+			}
+			p_extra = p_extra_free;
+#ifdef FEAT_CONCEAL
+			/* n_extra will be increased by FIX_FOX_BOGUSCOLS
+			 * macro below, so need to adjust for that here */
+			if (is_concealing && vcol_off > 0)
+			    n_extra -= vcol_off;
+#endif
+		    }
+#endif
 #ifdef FEAT_CONCEAL
 		    /* Tab alignment should be identical regardless of
 		     * 'conceallevel' value. So tab compensates of all
@@ -4476,8 +4575,13 @@
 		    if (wp->w_p_list)
 		    {
 			c = lcs_tab1;
-			c_extra = lcs_tab2;
-			n_attr = n_extra + 1;
+#ifdef FEAT_LINEBREAK
+			if (wp->w_p_lbr)
+			    c_extra = NUL; /* using p_extra from above */
+			else
+#endif
+			    c_extra = lcs_tab2;
+			n_attr = tab_len + 1;
 			extra_attr = hl_attr(HLF_8);
 			saved_attr2 = char_attr; /* save current attr */
 #ifdef FEAT_MBYTE
@@ -4500,9 +4604,7 @@
 			&& ((wp->w_p_list && lcs_eol > 0)
 			    || ((fromcol >= 0 || fromcol_prev >= 0)
 				&& tocol > vcol
-#ifdef FEAT_VISUAL
 				&& VIsual_mode != Ctrl_V
-#endif
 				&& (
 # ifdef FEAT_RIGHTLEFT
 				    wp->w_p_rl ? (col >= 0) :
@@ -4571,13 +4673,31 @@
 		else if (c != NUL)
 		{
 		    p_extra = transchar(c);
+		    if (n_extra == 0)
+			n_extra = byte2cells(c) - 1;
 #ifdef FEAT_RIGHTLEFT
 		    if ((dy_flags & DY_UHEX) && wp->w_p_rl)
 			rl_mirror(p_extra);	/* reverse "<12>" */
 #endif
-		    n_extra = byte2cells(c) - 1;
 		    c_extra = NUL;
-		    c = *p_extra++;
+#ifdef FEAT_LINEBREAK
+		    if (wp->w_p_lbr)
+		    {
+			char_u *p;
+
+			c = *p_extra;
+			p = alloc((unsigned)n_extra + 1);
+			vim_memset(p, ' ', n_extra);
+			STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);
+			p[n_extra] = NUL;
+			p_extra_free = p_extra = p;
+		    }
+		    else
+#endif
+		    {
+			n_extra = byte2cells(c) - 1;
+			c = *p_extra++;
+		    }
 		    if (!attr_pri)
 		    {
 			n_attr = n_extra + 1;
@@ -4636,7 +4756,12 @@
 		    {
 			diff_hlf = HLF_CHD;
 			if (attr == 0 || char_attr != attr)
+			{
 			    char_attr = hl_attr(diff_hlf);
+			    if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
+				char_attr = hl_combine_attr(char_attr,
+							    hl_attr(HLF_CUL));
+			}
 		    }
 # endif
 		}
@@ -4776,6 +4901,7 @@
 	 * special character (via 'listchars' option "precedes:<char>".
 	 */
 	if (lcs_prec_todo != NUL
+		&& wp->w_p_list
 		&& (wp->w_p_wrap ? wp->w_skipcol > 0 : wp->w_leftcol > 0)
 #ifdef FEAT_DIFF
 		&& filler_todo <= 0
@@ -4854,11 +4980,9 @@
 #endif
 	    if (lcs_eol == lcs_eol_one
 		    && ((area_attr != 0 && vcol == fromcol
-#ifdef FEAT_VISUAL
 			    && (VIsual_mode != Ctrl_V
 				|| lnum == VIsual.lnum
 				|| lnum == curwin->w_cursor.lnum)
-#endif
 			    && c == NUL)
 #ifdef FEAT_SEARCH_EXTRA
 			/* highlight 'hlsearch' match at end of line */
@@ -6653,6 +6777,7 @@
     win_T	*wp;
     int		draw_ruler;	/* TRUE or FALSE */
 {
+    static int	entered = FALSE;
     int		attr;
     int		curattr;
     int		row;
@@ -6671,6 +6796,13 @@
     win_T	*ewp;
     int		p_crb_save;
 
+    /* There is a tiny chance that this gets called recursively: When
+     * redrawing a status line triggers redrawing the ruler or tabline.
+     * Avoid trouble by not allowing recursion. */
+    if (entered)
+	return;
+    entered = TRUE;
+
     /* setup environment for the task at hand */
     if (wp == NULL)
     {
@@ -6746,7 +6878,7 @@
     }
 
     if (maxwidth <= 0)
-	return;
+	goto theend;
 
     /* Temporarily reset 'cursorbind', we don't want a side effect from moving
      * the cursor away and back. */
@@ -6827,6 +6959,9 @@
 	while (col < Columns)
 	    TabPageIdxs[col++] = fillchar;
     }
+
+theend:
+    entered = FALSE;
 }
 
 #endif /* FEAT_STL_OPT */
@@ -6939,15 +7074,16 @@
  * a NUL.
  */
     void
-screen_puts_len(text, len, row, col, attr)
+screen_puts_len(text, textlen, row, col, attr)
     char_u	*text;
-    int		len;
+    int		textlen;
     int		row;
     int		col;
     int		attr;
 {
     unsigned	off;
     char_u	*ptr = text;
+    int		len = textlen;
     int		c;
 #ifdef FEAT_MBYTE
     unsigned	max_off;
@@ -7192,7 +7328,11 @@
 	    col += mbyte_cells;
 	    ptr += mbyte_blen;
 	    if (clear_next_cell)
+	    {
+		/* This only happens at the end, display one space next. */
 		ptr = (char_u *)" ";
+		len = -1;
+	    }
 	}
 	else
 #endif
@@ -7295,6 +7435,8 @@
     match_T	*shl;		/* points to search_hl or a match */
     int		shl_flag;	/* flag to indicate whether search_hl
 				   has been processed or not */
+    int		pos_inprogress;	/* marks that position match search is
+				   in progress */
     int		n;
 
     /*
@@ -7329,10 +7471,16 @@
 		shl->first_lnum = wp->w_topline;
 # endif
 	    }
+	    if (cur != NULL)
+		cur->pos.cur = 0;
+	    pos_inprogress = TRUE;
 	    n = 0;
-	    while (shl->first_lnum < lnum && shl->rm.regprog != NULL)
+	    while (shl->first_lnum < lnum && (shl->rm.regprog != NULL
+					  || (cur != NULL && pos_inprogress)))
 	    {
-		next_search_hl(wp, shl, shl->first_lnum, (colnr_T)n);
+		next_search_hl(wp, shl, shl->first_lnum, (colnr_T)n, cur);
+		pos_inprogress = cur == NULL || cur->pos.cur == 0
+							      ? FALSE : TRUE;
 		if (shl->lnum != 0)
 		{
 		    shl->first_lnum = shl->lnum
@@ -7361,11 +7509,12 @@
  * Careful: Any pointers for buffer lines will become invalid.
  */
     static void
-next_search_hl(win, shl, lnum, mincol)
-    win_T	*win;
-    match_T	*shl;		/* points to search_hl or a match */
-    linenr_T	lnum;
-    colnr_T	mincol;		/* minimal column for a match */
+next_search_hl(win, shl, lnum, mincol, cur)
+    win_T	    *win;
+    match_T	    *shl;	/* points to search_hl or a match */
+    linenr_T	    lnum;
+    colnr_T	    mincol;	/* minimal column for a match */
+    matchitem_T	    *cur;	/* to retrieve match positions if any */
 {
     linenr_T	l;
     colnr_T	matchcol;
@@ -7433,27 +7582,36 @@
 	    matchcol = shl->rm.endpos[0].col;
 
 	shl->lnum = lnum;
-	nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum, matchcol,
+	if (shl->rm.regprog != NULL)
+	{
+	    nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum,
+		    matchcol,
 #ifdef FEAT_RELTIME
-		&(shl->tm)
+		    &(shl->tm)
 #else
-		NULL
+		    NULL
 #endif
-		);
-	if (called_emsg || got_int)
-	{
-	    /* Error while handling regexp: stop using this regexp. */
-	    if (shl == &search_hl)
+		    );
+	    if (called_emsg || got_int)
 	    {
-		/* don't free regprog in the match list, it's a copy */
-		vim_regfree(shl->rm.regprog);
-		no_hlsearch = TRUE;
+		/* Error while handling regexp: stop using this regexp. */
+		if (shl == &search_hl)
+		{
+		    /* don't free regprog in the match list, it's a copy */
+		    vim_regfree(shl->rm.regprog);
+		    SET_NO_HLSEARCH(TRUE);
+		}
+		shl->rm.regprog = NULL;
+		shl->lnum = 0;
+		got_int = FALSE;  /* avoid the "Type :quit to exit Vim"
+				     message */
+		break;
 	    }
-	    shl->rm.regprog = NULL;
-	    shl->lnum = 0;
-	    got_int = FALSE;  /* avoid the "Type :quit to exit Vim" message */
-	    break;
 	}
+	else if (cur != NULL)
+	    nmatched = next_search_hl_pos(shl, lnum, &(cur->pos), matchcol);
+	else
+	    nmatched = 0;
 	if (nmatched == 0)
 	{
 	    shl->lnum = 0;		/* no match found */
@@ -7469,6 +7627,62 @@
 	}
     }
 }
+
+    static int
+next_search_hl_pos(shl, lnum, posmatch, mincol)
+    match_T	    *shl;	/* points to a match */
+    linenr_T	    lnum;
+    posmatch_T	    *posmatch;	/* match positions */
+    colnr_T	    mincol;	/* minimal column for a match */
+{
+    int	    i;
+    int	    bot = -1;
+
+    shl->lnum = 0;
+    for (i = posmatch->cur; i < MAXPOSMATCH; i++)
+    {
+	if (posmatch->pos[i].lnum == 0)
+	    break;
+	if (posmatch->pos[i].col < mincol)
+	    continue;
+	if (posmatch->pos[i].lnum == lnum)
+	{
+	    if (shl->lnum == lnum)
+	    {
+		/* partially sort positions by column numbers
+		 * on the same line */
+		if (posmatch->pos[i].col < posmatch->pos[bot].col)
+		{
+		    llpos_T	tmp = posmatch->pos[i];
+
+		    posmatch->pos[i] = posmatch->pos[bot];
+		    posmatch->pos[bot] = tmp;
+		}
+	    }
+	    else
+	    {
+		bot = i;
+		shl->lnum = lnum;
+	    }
+	}
+    }
+    posmatch->cur = 0;
+    if (shl->lnum == lnum)
+    {
+	colnr_T	start = posmatch->pos[bot].col == 0
+					     ? 0 : posmatch->pos[bot].col - 1;
+	colnr_T	end = posmatch->pos[bot].col == 0
+				    ? MAXCOL : start + posmatch->pos[bot].len;
+
+	shl->rm.startpos[0].lnum = 0;
+	shl->rm.startpos[0].col = start;
+	shl->rm.endpos[0].lnum = 0;
+	shl->rm.endpos[0].col = end;
+	posmatch->cur = bot + 1;
+	return TRUE;
+    }
+    return FALSE;
+}
 #endif
 
       static void
@@ -8853,8 +9067,8 @@
 	{
 	    if (noinvcurs)
 		screen_stop_highlight();
-	    if (row == screen_cur_row && (col > screen_cur_col) &&
-								*T_CRI != NUL)
+	    if (row == screen_cur_row && (col > screen_cur_col)
+							     && *T_CRI != NUL)
 		term_cursor_right(col - screen_cur_col);
 	    else
 		term_windgoto(row, col);
@@ -9648,10 +9862,7 @@
     do_mode = ((p_smd && msg_silent == 0)
 	    && ((State & INSERT)
 		|| restart_edit
-#ifdef FEAT_VISUAL
-		|| VIsual_active
-#endif
-		));
+		|| VIsual_active));
     if (do_mode || Recording)
     {
 	/*
@@ -9704,7 +9915,8 @@
 	    }
 #endif
 #ifdef FEAT_INS_EXPAND
-	    if (edit_submode != NULL)		/* CTRL-X in Insert mode */
+	    /* CTRL-X in Insert mode */
+	    if (edit_submode != NULL && !shortmess(SHM_COMPLETIONMENU))
 	    {
 		/* These messages can get long, avoid a wrap in a narrow
 		 * window.  Prefer showing edit_submode_extra. */
@@ -9779,7 +9991,6 @@
 		if ((State & INSERT) && p_paste)
 		    MSG_PUTS_ATTR(_(" (paste)"), attr);
 
-#ifdef FEAT_VISUAL
 		if (VIsual_active)
 		{
 		    char *p;
@@ -9799,7 +10010,6 @@
 		    }
 		    MSG_PUTS_ATTR(_(p), attr);
 		}
-#endif
 		MSG_PUTS_ATTR(" --", attr);
 	    }
 
@@ -9828,11 +10038,9 @@
 	msg_clr_cmdline();
 
 #ifdef FEAT_CMDL_INFO
-# ifdef FEAT_VISUAL
     /* In Visual mode the size of the selected area must be redrawn. */
     if (VIsual_active)
 	clear_showcmd();
-# endif
 
     /* If the last window has no status line, the ruler is after the mode
      * message and must be redrawn */
@@ -9999,9 +10207,9 @@
 			break;
 		    screen_puts_len(NameBuff, len, 0, col,
 #if defined(FEAT_SYN_HL)
-					   hl_combine_attr(attr, hl_attr(HLF_T))
+					 hl_combine_attr(attr, hl_attr(HLF_T))
 #else
-					   attr
+					 attr
 #endif
 					       );
 		    col += len;
diff -Naur vim74.orig/src/search.c vim74/src/search.c
--- vim74.orig/src/search.c	2013-07-17 17:20:47.000000000 +0000
+++ vim74/src/search.c	2014-10-10 14:53:45.342044709 +0000
@@ -201,7 +201,7 @@
      * Save the currently used pattern in the appropriate place,
      * unless the pattern should not be remembered.
      */
-    if (!(options & SEARCH_KEEP))
+    if (!(options & SEARCH_KEEP) && !cmdmod.keeppatterns)
     {
 	/* search or global command */
 	if (pat_save == RE_SEARCH || pat_save == RE_BOTH)
@@ -289,7 +289,7 @@
 	/* If 'hlsearch' set and search pat changed: need redraw. */
 	if (p_hls)
 	    redraw_all_later(SOME_VALID);
-	no_hlsearch = FALSE;
+	SET_NO_HLSEARCH(FALSE);
 #endif
     }
 }
@@ -333,7 +333,7 @@
 	spats[1] = saved_spats[1];
 	last_idx = saved_last_idx;
 # ifdef FEAT_SEARCH_EXTRA
-	no_hlsearch = saved_no_hlsearch;
+	SET_NO_HLSEARCH(saved_no_hlsearch);
 # endif
     }
 }
@@ -506,7 +506,7 @@
 #endif
 
 /*
- * lowest level search function.
+ * Lowest level search function.
  * Search for 'count'th occurrence of pattern 'pat' in direction 'dir'.
  * Start at position 'pos' and return the found position in 'pos'.
  *
@@ -1148,7 +1148,7 @@
     if (no_hlsearch && !(options & SEARCH_KEEP))
     {
 	redraw_all_later(SOME_VALID);
-	no_hlsearch = FALSE;
+	SET_NO_HLSEARCH(FALSE);
     }
 #endif
 
@@ -1437,7 +1437,7 @@
     curwin->w_set_curswant = TRUE;
 
 end_do_search:
-    if (options & SEARCH_KEEP)
+    if ((options & SEARCH_KEEP) || cmdmod.keeppatterns)
 	spats[0].off = old_off;
     vim_free(strcopy);
 
@@ -1760,6 +1760,9 @@
 #endif
 
     pos = curwin->w_cursor;
+#ifdef FEAT_VIRTUALEDIT
+    pos.coladd = 0;
+#endif
     linep = ml_get(pos.lnum);
 
     cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);
@@ -3195,7 +3198,6 @@
     cls_bigword = bigword;
     clearpos(&start_pos);
 
-#ifdef FEAT_VISUAL
     /* Correct cursor when 'selection' is exclusive */
     if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))
 	dec_cursor();
@@ -3205,7 +3207,6 @@
      * character, select the word and/or white space under the cursor.
      */
     if (!VIsual_active || equalpos(curwin->w_cursor, VIsual))
-#endif
     {
 	/*
 	 * Go to start of current word or white space.
@@ -3242,7 +3243,6 @@
 		include_white = TRUE;
 	}
 
-#ifdef FEAT_VISUAL
 	if (VIsual_active)
 	{
 	    /* should do something when inclusive == FALSE ! */
@@ -3250,7 +3250,6 @@
 	    redraw_curbuf_later(INVERTED);	/* update the inversion */
 	}
 	else
-#endif
 	{
 	    oap->start = start_pos;
 	    oap->motion_type = MCHAR;
@@ -3264,7 +3263,6 @@
     while (count > 0)
     {
 	inclusive = TRUE;
-#ifdef FEAT_VISUAL
 	if (VIsual_active && lt(curwin->w_cursor, VIsual))
 	{
 	    /*
@@ -3285,7 +3283,6 @@
 	    }
 	}
 	else
-#endif
 	{
 	    /*
 	     * Move cursor forward one word and/or white area.
@@ -3331,18 +3328,15 @@
 	    back_in_line();
 	    if (cls() == 0 && curwin->w_cursor.col > 0)
 	    {
-#ifdef FEAT_VISUAL
 		if (VIsual_active)
 		    VIsual = curwin->w_cursor;
 		else
-#endif
 		    oap->start = curwin->w_cursor;
 	    }
 	}
 	curwin->w_cursor = pos;	/* put cursor back at end */
     }
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	if (*p_sel == 'e' && inclusive && ltoreq(VIsual, curwin->w_cursor))
@@ -3354,7 +3348,6 @@
 	}
     }
     else
-#endif
 	oap->inclusive = inclusive;
 
     return OK;
@@ -3381,7 +3374,6 @@
     pos = start_pos;
     findsent(FORWARD, 1L);	/* Find start of next sentence. */
 
-#ifdef FEAT_VISUAL
     /*
      * When the Visual area is bigger than one character: Extend it.
      */
@@ -3468,7 +3460,6 @@
 	}
 	return OK;
     }
-#endif
 
     /*
      * If the cursor started on a blank, check if it is just before the start
@@ -3518,7 +3509,6 @@
 	    find_first_blank(&start_pos);
     }
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	/* Avoid getting stuck with "is" on a single space before a sentence. */
@@ -3531,7 +3521,6 @@
 	redraw_curbuf_later(INVERTED);	/* update the inversion */
     }
     else
-#endif
     {
 	/* include a newline after the sentence, if there is one */
 	if (incl(&curwin->w_cursor) == -1)
@@ -3571,9 +3560,7 @@
     /*
      * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.
      */
-#ifdef FEAT_VISUAL
     if (!VIsual_active || equalpos(VIsual, curwin->w_cursor))
-#endif
     {
 	setpcmark();
 	if (what == '{')		/* ignore indent */
@@ -3584,7 +3571,6 @@
 	    /* cursor on '(' or '{', move cursor just after it */
 	    ++curwin->w_cursor.col;
     }
-#ifdef FEAT_VISUAL
     else if (lt(VIsual, curwin->w_cursor))
     {
 	old_start = VIsual;
@@ -3592,7 +3578,6 @@
     }
     else
 	old_end = VIsual;
-#endif
 
     /*
      * Search backwards for unclosed '(', '{', etc..
@@ -3623,22 +3608,22 @@
 
     /*
      * Try to exclude the '(', '{', ')', '}', etc. when "include" is FALSE.
-     * If the ending '}' is only preceded by indent, skip that indent.
-     * But only if the resulting area is not smaller than what we started with.
+     * If the ending '}', ')' or ']' is only preceded by indent, skip that
+     * indent.  But only if the resulting area is not smaller than what we
+     * started with.
      */
     while (!include)
     {
 	incl(&start_pos);
 	sol = (curwin->w_cursor.col == 0);
 	decl(&curwin->w_cursor);
-	if (what == '{')
-	    while (inindent(1))
-	    {
-		sol = TRUE;
-		if (decl(&curwin->w_cursor) != 0)
-		    break;
-	    }
-#ifdef FEAT_VISUAL
+	while (inindent(1))
+	{
+	    sol = TRUE;
+	    if (decl(&curwin->w_cursor) != 0)
+		break;
+	}
+
 	/*
 	 * In Visual mode, when the resulting area is not bigger than what we
 	 * started with, extend it to the next block, and then exclude again.
@@ -3663,11 +3648,9 @@
 	    curwin->w_cursor = *end_pos;
 	}
 	else
-#endif
 	    break;
     }
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	if (*p_sel == 'e')
@@ -3680,7 +3663,6 @@
 	showmode();
     }
     else
-#endif
     {
 	oap->start = start_pos;
 	oap->motion_type = MCHAR;
@@ -3804,17 +3786,13 @@
     old_pos = curwin->w_cursor;
     old_end = curwin->w_cursor;		    /* remember where we started */
     old_start = old_end;
-#ifdef FEAT_VISUAL
     if (!VIsual_active || *p_sel == 'e')
-#endif
 	decl(&old_end);			    /* old_end is inclusive */
 
     /*
      * If we start on "<aaa>" select that block.
      */
-#ifdef FEAT_VISUAL
     if (!VIsual_active || equalpos(VIsual, curwin->w_cursor))
-#endif
     {
 	setpcmark();
 
@@ -3840,7 +3818,6 @@
 	    old_end = curwin->w_cursor;
 	}
     }
-#ifdef FEAT_VISUAL
     else if (lt(VIsual, curwin->w_cursor))
     {
 	old_start = VIsual;
@@ -3848,7 +3825,6 @@
     }
     else
 	old_end = VIsual;
-#endif
 
 again:
     /*
@@ -3948,7 +3924,6 @@
 	}
     }
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	/* If the end is before the start there is no text between tags, select
@@ -3963,7 +3938,6 @@
 	showmode();
     }
     else
-#endif
     {
 	oap->start = start_pos;
 	oap->motion_type = MCHAR;
@@ -4007,7 +3981,6 @@
 
     start_lnum = curwin->w_cursor.lnum;
 
-#ifdef FEAT_VISUAL
     /*
      * When visual area is more than one line: extend it.
      */
@@ -4061,7 +4034,6 @@
 	curwin->w_cursor.col = 0;
 	return retval;
     }
-#endif
 
     /*
      * First move back to the start_lnum of the paragraph or white lines
@@ -4133,7 +4105,6 @@
 	while (start_lnum > 1 && linewhite(start_lnum - 1))
 	    --start_lnum;
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	/* Problem: when doing "Vipipip" nothing happens in a single white
@@ -4146,7 +4117,6 @@
 	showmode();
     }
     else
-#endif
     {
 	oap->start.lnum = start_lnum;
 	oap->start.col = 0;
@@ -4244,7 +4214,6 @@
     int		col_end;
     int		col_start = curwin->w_cursor.col;
     int		inclusive = FALSE;
-#ifdef FEAT_VISUAL
     int		vis_empty = TRUE;	/* Visual selection <= 1 char */
     int		vis_bef_curs = FALSE;	/* Visual starts before cursor */
     int		inside_quotes = FALSE;	/* Looks like "i'" done before */
@@ -4328,17 +4297,11 @@
 	}
     }
     else
-#endif
 
-    if (line[col_start] == quotechar
-#ifdef FEAT_VISUAL
-	    || !vis_empty
-#endif
-	    )
+    if (line[col_start] == quotechar || !vis_empty)
     {
 	int	first_col = col_start;
 
-#ifdef FEAT_VISUAL
 	if (!vis_empty)
 	{
 	    if (vis_bef_curs)
@@ -4346,7 +4309,7 @@
 	    else
 		first_col = find_prev_quote(line, col_start, quotechar, NULL);
 	}
-#endif
+
 	/* The cursor is on a quote, we don't know if it's the opening or
 	 * closing quote.  Search from the start of the line to find out.
 	 * Also do this when there is a Visual area, a' may leave the cursor
@@ -4403,14 +4366,9 @@
 
     /* Set start position.  After vi" another i" must include the ".
      * For v2i" include the quotes. */
-    if (!include && count < 2
-#ifdef FEAT_VISUAL
-	    && (vis_empty || !inside_quotes)
-#endif
-	    )
+    if (!include && count < 2 && (vis_empty || !inside_quotes))
 	++col_start;
     curwin->w_cursor.col = col_start;
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	/* Set the start of the Visual area when the Visual area was empty, we
@@ -4430,7 +4388,6 @@
 	}
     }
     else
-#endif
     {
 	oap->start = curwin->w_cursor;
 	oap->motion_type = MCHAR;
@@ -4438,14 +4395,10 @@
 
     /* Set end position. */
     curwin->w_cursor.col = col_end;
-    if ((include || count > 1
-#ifdef FEAT_VISUAL
-		/* After vi" another i" must include the ". */
+    if ((include || count > 1 /* After vi" another i" must include the ". */
 		|| (!vis_empty && inside_quotes)
-#endif
 	) && inc_cursor() == 2)
 	inclusive = TRUE;
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	if (vis_empty || vis_bef_curs)
@@ -4477,7 +4430,6 @@
 	}
     }
     else
-#endif
     {
 	/* Set inclusive and other oap's flags. */
 	oap->inclusive = inclusive;
@@ -4488,7 +4440,6 @@
 
 #endif /* FEAT_TEXTOBJ */
 
-#if defined(FEAT_VISUAL) || defined(PROTO)
 static int is_one_char __ARGS((char_u *pattern));
 
 /*
@@ -4541,7 +4492,10 @@
     /* Is the pattern is zero-width? */
     one_char = is_one_char(spats[last_idx].pat);
     if (one_char == -1)
-	return FAIL;  /* invalid pattern */
+    {
+	p_ws = old_p_ws;
+	return FAIL;  /* pattern not found */
+    }
 
     /*
      * The trick is to first search backwards and then search forward again,
@@ -4589,7 +4543,7 @@
 				ml_get(curwin->w_buffer->b_ml.ml_line_count));
 	    }
 	}
-
+	p_ws = old_p_ws;
     }
 
     start_pos = pos;
@@ -4604,7 +4558,6 @@
     if (!VIsual_active)
 	VIsual = start_pos;
 
-    p_ws = old_p_ws;
     curwin->w_cursor = pos;
     VIsual_active = TRUE;
     VIsual_mode = 'v';
@@ -4677,15 +4630,14 @@
 		&& regmatch.startpos[0].lnum == regmatch.endpos[0].lnum
 		&& regmatch.startpos[0].col == regmatch.endpos[0].col);
 
-	if (!result && incl(&pos) == 0 && pos.col == regmatch.endpos[0].col)
-	    result  = TRUE;
+	if (!result && inc(&pos) >= 0 && pos.col == regmatch.endpos[0].col)
+	    result = TRUE;
     }
 
     called_emsg |= save_called_emsg;
     vim_regfree(regmatch.regprog);
     return result;
 }
-#endif /* FEAT_VISUAL */
 
 #if defined(FEAT_LISP) || defined(FEAT_CINDENT) || defined(FEAT_TEXTOBJ) \
 	|| defined(PROTO)
@@ -5559,7 +5511,9 @@
 		spats[idx].off.off = off;
 #ifdef FEAT_SEARCH_EXTRA
 		if (setlast)
-		    no_hlsearch = !hlsearch_on;
+		{
+		    SET_NO_HLSEARCH(!hlsearch_on);
+		}
 #endif
 	    }
 	}
diff -Naur vim74.orig/src/spell.c vim74/src/spell.c
--- vim74.orig/src/spell.c	2013-07-17 15:28:28.000000000 +0000
+++ vim74/src/spell.c	2014-10-10 14:53:45.378711284 +0000
@@ -317,7 +317,7 @@
 
 /* Type used for indexes in the word tree need to be at least 4 bytes.  If int
  * is 8 bytes we could use something smaller, but what? */
-#if SIZEOF_INT > 3
+#if VIM_SIZEOF_INT > 3
 typedef int idx_T;
 #else
 typedef long idx_T;
@@ -754,9 +754,9 @@
 static void clear_spell_chartab __ARGS((spelltab_T *sp));
 static int set_spell_finish __ARGS((spelltab_T	*new_st));
 static int spell_iswordp __ARGS((char_u *p, win_T *wp));
-static int spell_iswordp_nmw __ARGS((char_u *p));
+static int spell_iswordp_nmw __ARGS((char_u *p, win_T *wp));
 #ifdef FEAT_MBYTE
-static int spell_mb_isword_class __ARGS((int cl));
+static int spell_mb_isword_class __ARGS((int cl, win_T *wp));
 static int spell_iswordp_w __ARGS((int *p, win_T *wp));
 #endif
 static int write_spell_prefcond __ARGS((FILE *fd, garray_T *gap));
@@ -1149,7 +1149,7 @@
 
 	/* When we are at a non-word character there is no error, just
 	 * skip over the character (try looking for a word after it). */
-	else if (!spell_iswordp_nmw(ptr))
+	else if (!spell_iswordp_nmw(ptr, wp))
 	{
 	    if (capcol != NULL && wp->w_s->b_cap_prog != NULL)
 	    {
@@ -1561,7 +1561,7 @@
 			 * accept a no-caps word, even when the dictionary
 			 * word specifies ONECAP. */
 			mb_ptr_back(mip->mi_word, p);
-			if (spell_iswordp_nmw(p)
+			if (spell_iswordp_nmw(p, mip->mi_win)
 				? capflags == WF_ONECAP
 				: (flags & WF_ONECAP) != 0
 						     && capflags != WF_ONECAP)
@@ -2180,9 +2180,9 @@
     char_u	*endp;
     hlf_T	attr;
     int		len;
-# ifdef FEAT_SYN_HL
+#ifdef FEAT_SYN_HL
     int		has_syntax = syntax_present(wp);
-# endif
+#endif
     int		col;
     int		can_spell;
     char_u	*buf = NULL;
@@ -2280,7 +2280,7 @@
 						     : p - buf)
 						  > wp->w_cursor.col)))
 		    {
-# ifdef FEAT_SYN_HL
+#ifdef FEAT_SYN_HL
 			if (has_syntax)
 			{
 			    col = (int)(p - buf);
@@ -4234,7 +4234,11 @@
     if (spl_copy == NULL)
 	goto theend;
 
-    /* loop over comma separated language names. */
+#ifdef FEAT_MBYTE
+    wp->w_s->b_cjk = 0;
+#endif
+
+    /* Loop over comma separated language names. */
     for (splp = spl_copy; *splp != NUL; )
     {
 	/* Get one language name. */
@@ -4242,6 +4246,14 @@
 	region = NULL;
 	len = (int)STRLEN(lang);
 
+	if (STRCMP(lang, "cjk") == 0)
+	{
+#ifdef FEAT_MBYTE
+	    wp->w_s->b_cjk = 1;
+#endif
+	    continue;
+	}
+
 	/* If the name ends in ".spl" use it as the name of the spell file.
 	 * If there is a region name let "region" point to it and remove it
 	 * from the name. */
@@ -4496,6 +4508,7 @@
 theend:
     vim_free(spl_copy);
     recursive = FALSE;
+    redraw_win_later(wp, NOT_VALID);
     return ret_msg;
 }
 
@@ -4601,7 +4614,7 @@
     int		past_second = FALSE;	/* past second word char */
 
     /* find first letter */
-    for (p = word; !spell_iswordp_nmw(p); mb_ptr_adv(p))
+    for (p = word; !spell_iswordp_nmw(p, curwin); mb_ptr_adv(p))
 	if (end == NULL ? *p == NUL : p >= end)
 	    return 0;	    /* only non-word characters, illegal word */
 #ifdef FEAT_MBYTE
@@ -4617,7 +4630,7 @@
      * But a word with an upper char only at start is a ONECAP.
      */
     for ( ; end == NULL ? *p != NUL : p < end; mb_ptr_adv(p))
-	if (spell_iswordp_nmw(p))
+	if (spell_iswordp_nmw(p, curwin))
 	{
 	    c = PTR2CHAR(p);
 	    if (!SPELL_ISUPPER(c))
@@ -4689,7 +4702,25 @@
     return flags;
 }
 
-# if defined(FEAT_MBYTE) || defined(EXITFREE) || defined(PROTO)
+/*
+ * Delete the internal wordlist and its .spl file.
+ */
+    void
+spell_delete_wordlist()
+{
+    char_u	fname[MAXPATHL];
+
+    if (int_wordlist != NULL)
+    {
+	mch_remove(int_wordlist);
+	int_wordlist_spl(fname);
+	mch_remove(fname);
+	vim_free(int_wordlist);
+	int_wordlist = NULL;
+    }
+}
+
+#if defined(FEAT_MBYTE) || defined(EXITFREE) || defined(PROTO)
 /*
  * Free all languages.
  */
@@ -4698,7 +4729,6 @@
 {
     slang_T	*slang;
     buf_T	*buf;
-    char_u	fname[MAXPATHL];
 
     /* Go through all buffers and handle 'spelllang'. <VN> */
     for (buf = firstbuf; buf != NULL; buf = buf->b_next)
@@ -4711,24 +4741,16 @@
 	slang_free(slang);
     }
 
-    if (int_wordlist != NULL)
-    {
-	/* Delete the internal wordlist and its .spl file */
-	mch_remove(int_wordlist);
-	int_wordlist_spl(fname);
-	mch_remove(fname);
-	vim_free(int_wordlist);
-	int_wordlist = NULL;
-    }
+    spell_delete_wordlist();
 
     vim_free(repl_to);
     repl_to = NULL;
     vim_free(repl_from);
     repl_from = NULL;
 }
-# endif
+#endif
 
-# if defined(FEAT_MBYTE) || defined(PROTO)
+#if defined(FEAT_MBYTE) || defined(PROTO)
 /*
  * Clear all spelling tables and reload them.
  * Used after 'encoding' is set and when ":mkspell" was used.
@@ -4761,7 +4783,7 @@
 	}
     }
 }
-# endif
+#endif
 
 /*
  * Reload the spell file "fname" if it's loaded.
@@ -4819,6 +4841,7 @@
     unsigned	af_nosuggest;	/* NOSUGGEST ID */
     int		af_pfxpostpone;	/* postpone prefixes without chop string and
 				   without flags */
+    int		af_ignoreextra;	/* IGNOREEXTRA present */
     hashtab_T	af_pref;	/* hashtable for prefixes, affheader_T */
     hashtab_T	af_suff;	/* hashtable for suffixes, affheader_T */
     hashtab_T	af_comp;	/* hashtable for compound flags, compitem_T */
@@ -5583,6 +5606,10 @@
 	    {
 		aff->af_pfxpostpone = TRUE;
 	    }
+	    else if (is_aff_rule(items, itemcnt, "IGNOREEXTRA", 1))
+	    {
+		aff->af_ignoreextra = TRUE;
+	    }
 	    else if ((STRCMP(items[0], "PFX") == 0
 					      || STRCMP(items[0], "SFX") == 0)
 		    && aff_todo == 0
@@ -5690,9 +5717,11 @@
 		int		lasti = 5;
 
 		/* Myspell allows extra text after the item, but that might
-		 * mean mistakes go unnoticed.  Require a comment-starter.
-		 * Hunspell uses a "-" item. */
-		if (itemcnt > lasti && *items[lasti] != '#'
+		 * mean mistakes go unnoticed.  Require a comment-starter,
+		 * unless IGNOREEXTRA is used.  Hunspell uses a "-" item. */
+		if (itemcnt > lasti
+			&& !aff->af_ignoreextra
+			&& *items[lasti] != '#'
 			&& (STRCMP(items[lasti], "-") != 0
 						     || itemcnt != lasti + 1))
 		    smsg((char_u *)_(e_afftrailing), fname, lnum, items[lasti]);
@@ -9479,7 +9508,8 @@
 			if (undo)
 			{
 			    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);
-			    smsg((char_u *)_("Word removed from %s"), NameBuff);
+			    smsg((char_u *)_("Word '%.*s' removed from %s"),
+							 len, word, NameBuff);
 			}
 		    }
 		    fseek(fd, fpos_next, SEEK_SET);
@@ -9525,7 +9555,7 @@
 	    fclose(fd);
 
 	    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);
-	    smsg((char_u *)_("Word added to %s"), NameBuff);
+	    smsg((char_u *)_("Word '%.*s' added to %s"), len, word, NameBuff);
 	}
     }
 
@@ -9906,7 +9936,7 @@
 
 	c = mb_ptr2char(s);
 	if (c > 255)
-	    return spell_mb_isword_class(mb_get_class(s));
+	    return spell_mb_isword_class(mb_get_class(s), wp);
 	return spelltab.st_isw[c];
     }
 #endif
@@ -9919,8 +9949,9 @@
  * Unlike spell_iswordp() this doesn't check for "midword" characters.
  */
     static int
-spell_iswordp_nmw(p)
+spell_iswordp_nmw(p, wp)
     char_u	*p;
+    win_T	*wp;
 {
 #ifdef FEAT_MBYTE
     int		c;
@@ -9929,7 +9960,7 @@
     {
 	c = mb_ptr2char(p);
 	if (c > 255)
-	    return spell_mb_isword_class(mb_get_class(p));
+	    return spell_mb_isword_class(mb_get_class(p), wp);
 	return spelltab.st_isw[c];
     }
 #endif
@@ -9941,11 +9972,16 @@
  * Return TRUE if word class indicates a word character.
  * Only for characters above 255.
  * Unicode subscript and superscript are not considered word characters.
+ * See also dbcs_class() and utf_class() in mbyte.c.
  */
     static int
-spell_mb_isword_class(cl)
-    int cl;
+spell_mb_isword_class(cl, wp)
+    int		cl;
+    win_T	*wp;
 {
+    if (wp->w_s->b_cjk)
+	/* East Asian characters are not considered word characters. */
+	return cl == 2 || cl == 0x2800;
     return cl >= 2 && cl != 0x2070 && cl != 0x2080;
 }
 
@@ -9970,9 +10006,10 @@
     if (*s > 255)
     {
 	if (enc_utf8)
-	    return spell_mb_isword_class(utf_class(*s));
+	    return spell_mb_isword_class(utf_class(*s), wp);
 	if (enc_dbcs)
-	    return dbcs_class((unsigned)*s >> 8, *s & 0xff) >= 2;
+	    return spell_mb_isword_class(
+				dbcs_class((unsigned)*s >> 8, *s & 0xff), wp);
 	return 0;
     }
     return spelltab.st_isw[*s];
@@ -10135,7 +10172,7 @@
 }
 
 /*
- * "z?": Find badly spelled word under or after the cursor.
+ * "z=": Find badly spelled word under or after the cursor.
  * Give suggestions for the properly spelled word.
  * In Visual mode use the highlighted word as the bad word.
  * When "count" is non-zero use that suggestion.
@@ -10162,7 +10199,6 @@
     if (no_spell_checking(curwin))
 	return;
 
-#ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	/* Use the Visually selected text as the bad word.  But reject
@@ -10180,10 +10216,8 @@
 	++badlen;
 	end_visual_mode();
     }
-    else
-#endif
-	/* Find the start of the badly spelled word. */
-	if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0
+    /* Find the start of the badly spelled word. */
+    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0
 	    || curwin->w_cursor.col > prev_cursor.col)
     {
 	/* No bad word or it starts after the cursor: use the word under the
@@ -10192,13 +10226,13 @@
 	line = ml_get_curline();
 	p = line + curwin->w_cursor.col;
 	/* Backup to before start of word. */
-	while (p > line && spell_iswordp_nmw(p))
+	while (p > line && spell_iswordp_nmw(p, curwin))
 	    mb_ptr_back(line, p);
 	/* Forward to start of word. */
-	while (*p != NUL && !spell_iswordp_nmw(p))
+	while (*p != NUL && !spell_iswordp_nmw(p, curwin))
 	    mb_ptr_adv(p);
 
-	if (!spell_iswordp_nmw(p))		/* No word found. */
+	if (!spell_iswordp_nmw(p, curwin))		/* No word found. */
 	{
 	    beep_flush();
 	    return;
@@ -10435,7 +10469,7 @@
 	for (;;)
 	{
 	    mb_ptr_back(line, p);
-	    if (p == line || spell_iswordp_nmw(p))
+	    if (p == line || spell_iswordp_nmw(p, curwin))
 		break;
 	    if (vim_regexec(&regmatch, p, 0)
 					 && regmatch.endp[0] == line + endcol)
@@ -11644,7 +11678,7 @@
 
 		/* When appending a compound word after a word character don't
 		 * use Onecap. */
-		if (p != NULL && spell_iswordp_nmw(p))
+		if (p != NULL && spell_iswordp_nmw(p, curwin))
 		    c &= ~WF_ONECAP;
 		make_case_word(tword + sp->ts_splitoff,
 					      preword + sp->ts_prewordlen, c);
@@ -11894,7 +11928,8 @@
 			 * character when the word ends.  But only when the
 			 * good word can end. */
 			if (((!try_compound && !spell_iswordp_nmw(fword
-							       + sp->ts_fidx))
+							       + sp->ts_fidx,
+							       curwin))
 				    || fword_ends)
 				&& fword[sp->ts_fidx] != NUL
 				&& goodword_ends)
@@ -12007,7 +12042,7 @@
 		/* Normal byte, go one level deeper.  If it's not equal to the
 		 * byte in the bad word adjust the score.  But don't even try
 		 * when the byte was already changed.  And don't try when we
-		 * just deleted this byte, accepting it is always cheaper then
+		 * just deleted this byte, accepting it is always cheaper than
 		 * delete + substitute. */
 		if (c == fword[sp->ts_fidx]
 #ifdef FEAT_MBYTE
@@ -13377,9 +13412,8 @@
 
 	/* Lookup the word "orgnr" one of the two tries. */
 	n = 0;
-	wlen = 0;
 	wordcount = 0;
-	for (;;)
+	for (wlen = 0; wlen < MAXWLEN - 3; ++wlen)
 	{
 	    i = 1;
 	    if (wordcount == orgnr && byts[n + 1] == NUL)
@@ -13393,6 +13427,7 @@
 		if (i > byts[n])	/* safety check */
 		{
 		    STRCPY(theword + wlen, "BAD");
+		    wlen += 3;
 		    goto badword;
 		}
 
@@ -13405,7 +13440,7 @@
 		wordcount += wc;
 	    }
 
-	    theword[wlen++] = byts[n + i];
+	    theword[wlen] = byts[n + i];
 	    n = idxs[n + i];
 	}
 badword:
@@ -14225,7 +14260,7 @@
 	    }
 	    else
 	    {
-		if (spell_iswordp_nmw(s))
+		if (spell_iswordp_nmw(s, curwin))
 		    *t++ = *s;
 		++s;
 	    }
@@ -14520,7 +14555,7 @@
 	    else
 	    {
 		did_white = FALSE;
-		if (!spell_iswordp_nmw(t))
+		if (!spell_iswordp_nmw(t, curwin))
 		    continue;
 	    }
 	}
@@ -15568,11 +15603,21 @@
 ex_spelldump(eap)
     exarg_T *eap;
 {
+    char_u  *spl;
+    long    dummy;
+
     if (no_spell_checking(curwin))
 	return;
+    get_option_value((char_u*)"spl", &dummy, &spl, OPT_LOCAL);
 
-    /* Create a new empty buffer by splitting the window. */
+    /* Create a new empty buffer in a new window. */
     do_cmdline_cmd((char_u *)"new");
+
+    /* enable spelling locally in the new window */
+    set_option_value((char_u*)"spell", TRUE, (char_u*)"", OPT_LOCAL);
+    set_option_value((char_u*)"spl",  dummy,         spl, OPT_LOCAL);
+    vim_free(spl);
+
     if (!bufempty() || !buf_valid(curbuf))
 	return;
 
@@ -16034,7 +16079,7 @@
     for (p = line + startcol; p > line; )
     {
 	mb_ptr_back(line, p);
-	if (spell_iswordp_nmw(p))
+	if (spell_iswordp_nmw(p, curwin))
 	    break;
     }
 
diff -Naur vim74.orig/src/structs.h vim74/src/structs.h
--- vim74.orig/src/structs.h	2013-07-03 13:35:59.000000000 +0000
+++ vim74/src/structs.h	2014-10-10 14:53:45.382044609 +0000
@@ -134,6 +134,12 @@
     int		wo_arab;
 # define w_p_arab w_onebuf_opt.wo_arab	/* 'arabic' */
 #endif
+#ifdef FEAT_LINEBREAK
+    int		wo_bri;
+# define w_p_bri w_onebuf_opt.wo_bri	/* 'breakindent' */
+    char_u	*wo_briopt;
+# define w_p_briopt w_onebuf_opt.wo_briopt /* 'breakindentopt' */
+#endif
 #ifdef FEAT_DIFF
     int		wo_diff;
 # define w_p_diff w_onebuf_opt.wo_diff	/* 'diff' */
@@ -346,9 +352,7 @@
 #endif
     int		uh_flags;	/* see below */
     pos_T	uh_namedm[NMARKS];	/* marks before undo/after redo */
-#ifdef FEAT_VISUAL
     visualinfo_T uh_visual;	/* Visual areas before undo/after redo */
-#endif
     time_t	uh_time;	/* timestamp when the change was made */
     long	uh_save_nr;	/* set when the file was saved after the
 				   changes in this block */
@@ -364,7 +368,7 @@
 /*
  * structures used in undo.c
  */
-#if SIZEOF_INT > 2
+#if VIM_SIZEOF_INT > 2
 # define ALIGN_LONG	/* longword alignment and use filler byte */
 # define ALIGN_SIZE (sizeof(long))
 #else
@@ -471,13 +475,17 @@
     blocknr_T	nt_new_bnum;		/* new, positive, number */
 };
 
+
+typedef struct buffblock buffblock_T;
+typedef struct buffheader buffheader_T;
+
 /*
  * structure used to store one block of the stuff/redo/recording buffers
  */
 struct buffblock
 {
-    struct buffblock	*b_next;	/* pointer to next buffblock */
-    char_u		b_str[1];	/* contents (actually longer) */
+    buffblock_T	*b_next;	/* pointer to next buffblock */
+    char_u	b_str[1];	/* contents (actually longer) */
 };
 
 /*
@@ -485,10 +493,10 @@
  */
 struct buffheader
 {
-    struct buffblock	bh_first;	/* first (dummy) block of list */
-    struct buffblock	*bh_curr;	/* buffblock for appending */
-    int			bh_index;	/* index for reading */
-    int			bh_space;	/* space in bh_curr for appending */
+    buffblock_T	bh_first;	/* first (dummy) block of list */
+    buffblock_T	*bh_curr;	/* buffblock for appending */
+    int		bh_index;	/* index for reading */
+    int		bh_space;	/* space in bh_curr for appending */
 };
 
 /*
@@ -542,6 +550,8 @@
     int		keepmarks;		/* TRUE when ":keepmarks" was used */
     int		keepjumps;		/* TRUE when ":keepjumps" was used */
     int		lockmarks;		/* TRUE when ":lockmarks" was used */
+    int		keeppatterns;		/* TRUE when ":keeppatterns" was used */
+    int		noswapfile;		/* TRUE when ":noswapfile" was used */
 # ifdef FEAT_AUTOCMD
     char_u	*save_ei;		/* saved value of 'eventignore' */
 # endif
@@ -568,7 +578,7 @@
     unsigned	mf_page_size;		/* number of bytes in a page */
     int		mf_dirty;		/* TRUE if there are dirty blocks */
 #ifdef FEAT_CRYPT
-    buf_T	*mf_buffer;		/* bufer this memfile is for */
+    buf_T	*mf_buffer;		/* buffer this memfile is for */
     char_u	mf_seed[MF_SEED_LEN];	/* seed for encryption */
 
     /* Values for key, method and seed used for reading data blocks when
@@ -671,6 +681,7 @@
 {
     garray_T	al_ga;		/* growarray with the array of file names */
     int		al_refcount;	/* number of windows using this arglist */
+    int		id;		/* id of this arglist */
 } alist_T;
 
 /*
@@ -963,7 +974,8 @@
     int			typebuf_valid;	    /* TRUE when save_typebuf valid */
     int			old_char;
     int			old_mod_mask;
-    struct buffheader	save_stuffbuff;
+    buffheader_T	save_readbuf1;
+    buffheader_T	save_readbuf2;
 #ifdef USE_INPUT_BUF
     char_u		*save_inputbuf;
 #endif
@@ -1088,7 +1100,7 @@
 typedef long_u hash_T;		/* Type for hi_hash */
 
 
-#if SIZEOF_INT <= 3		/* use long if int is smaller than 32 bits */
+#if VIM_SIZEOF_INT <= 3		/* use long if int is smaller than 32 bits */
 typedef long	varnumber_T;
 #else
 typedef int	varnumber_T;
@@ -1239,6 +1251,24 @@
 } syn_time_T;
 #endif
 
+#ifdef FEAT_CRYPT
+/*
+ * Structure to hold the type of encryption and the state of encryption or
+ * decryption.
+ */
+typedef struct {
+    int	    method_nr;
+    void    *method_state;  /* method-specific state information */
+} cryptstate_T;
+
+/* values for method_nr */
+# define CRYPT_M_ZIP	0
+# define CRYPT_M_BF	1
+# define CRYPT_M_BF2	2
+# define CRYPT_M_COUNT	3 /* number of crypt methods */
+#endif
+
+
 /*
  * These are items normally related to a buffer.  But when using ":ownsyntax"
  * a window may have its own instance.
@@ -1309,6 +1339,9 @@
     regprog_T	*b_cap_prog;	/* program for 'spellcapcheck' */
     char_u	*b_p_spf;	/* 'spellfile' */
     char_u	*b_p_spl;	/* 'spelllang' */
+# ifdef FEAT_MBYTE
+    int		b_cjk;		/* all CJK letters as OK */
+# endif
 #endif
 #if !defined(FEAT_SYN_HL) && !defined(FEAT_SPELL)
     int		dummy;
@@ -1397,12 +1430,10 @@
 
     pos_T	b_namedm[NMARKS]; /* current named marks (mark.c) */
 
-#ifdef FEAT_VISUAL
     /* These variables are set when VIsual_active becomes FALSE */
     visualinfo_T b_visual;
-# ifdef FEAT_EVAL
+#ifdef FEAT_EVAL
     int		b_visual_mode_eval;  /* b_visual.vi_mode for visualmode() */
-# endif
 #endif
 
     pos_T	b_last_cursor;	/* cursor position when last unloading this
@@ -1440,6 +1471,7 @@
      * start and end of an operator, also used for '[ and ']
      */
     pos_T	b_op_start;
+    pos_T	b_op_start_orig;  /* used for Insstart_orig */
     pos_T	b_op_end;
 
 #ifdef FEAT_VIMINFO
@@ -1505,6 +1537,8 @@
 
     int		b_p_ai;		/* 'autoindent' */
     int		b_p_ai_nopaste;	/* b_p_ai saved for paste mode */
+    char_u	*b_p_bkc;	/* 'backupcopy' */
+    unsigned	b_bkc_flags;    /* flags for 'backupcopy' */
     int		b_p_ci;		/* 'copyindent' */
     int		b_p_bin;	/* 'binary' */
 #ifdef FEAT_MBYTE
@@ -1627,12 +1661,55 @@
     char_u	*b_p_dict;	/* 'dictionary' local value */
     char_u	*b_p_tsr;	/* 'thesaurus' local value */
 #endif
+    long	b_p_ul;		/* 'undolevels' local value */
 #ifdef FEAT_PERSISTENT_UNDO
     int		b_p_udf;	/* 'undofile' */
 #endif
+#ifdef FEAT_LISP
+    char_u	*b_p_lw;	/* 'lispwords' local value */
+#endif
 
     /* end of buffer options */
 
+#ifdef FEAT_CINDENT
+    /* values set from b_p_cino */
+    int		b_ind_level;
+    int		b_ind_open_imag;
+    int		b_ind_no_brace;
+    int		b_ind_first_open;
+    int		b_ind_open_extra;
+    int		b_ind_close_extra;
+    int		b_ind_open_left_imag;
+    int		b_ind_jump_label;
+    int		b_ind_case;
+    int		b_ind_case_code;
+    int		b_ind_case_break;
+    int		b_ind_param;
+    int		b_ind_func_type;
+    int		b_ind_comment;
+    int		b_ind_in_comment;
+    int		b_ind_in_comment2;
+    int		b_ind_cpp_baseclass;
+    int		b_ind_continuation;
+    int		b_ind_unclosed;
+    int		b_ind_unclosed2;
+    int		b_ind_unclosed_noignore;
+    int		b_ind_unclosed_wrapped;
+    int		b_ind_unclosed_whiteok;
+    int		b_ind_matching_paren;
+    int		b_ind_paren_prev;
+    int		b_ind_maxparen;
+    int		b_ind_maxcomment;
+    int		b_ind_scopedecl;
+    int		b_ind_scopedecl_code;
+    int		b_ind_java;
+    int		b_ind_js;
+    int		b_ind_keep_case_label;
+    int		b_ind_hash_comment;
+    int		b_ind_cpp_namespace;
+    int		b_ind_if_for_while;
+#endif
+
     linenr_T	b_no_eol_lnum;	/* non-zero lnum when last line of next binary
 				 * write should not have an end-of-line */
 
@@ -1721,7 +1798,12 @@
     int		b_was_netbeans_file;/* TRUE if b_netbeans_file was once set */
 #endif
 
-};
+#ifdef FEAT_CRYPT
+    cryptstate_T *b_cryptstate;	/* Encryption state while reading or writing
+				 * the file. NULL when not using encryption. */
+#endif
+
+}; /* file_buffer */
 
 
 #ifdef FEAT_DIFF
@@ -1876,6 +1958,32 @@
 #endif
 } match_T;
 
+/* number of positions supported by matchaddpos() */
+#define MAXPOSMATCH 8
+
+/*
+ * Same as lpos_T, but with additional field len.
+ */
+typedef struct
+{
+    linenr_T	lnum;	/* line number */
+    colnr_T	col;	/* column number */
+    int		len;	/* length: 0 - to the end of line */
+} llpos_T;
+
+/*
+ * posmatch_T provides an array for storing match items for matchaddpos()
+ * function.
+ */
+typedef struct posmatch posmatch_T;
+struct posmatch
+{
+    llpos_T	pos[MAXPOSMATCH];	/* array of positions */
+    int		cur;			/* internal position counter */
+    linenr_T	toplnum;		/* top buffer line */
+    linenr_T	botlnum;		/* bottom buffer line */
+};
+
 /*
  * matchitem_T provides a linked list for storing match items for ":match" and
  * the match functions.
@@ -1889,6 +1997,7 @@
     char_u	*pattern;   /* pattern to highlight */
     int		hlg_id;	    /* highlight group ID */
     regmmatch_T	match;	    /* regexp program for pattern */
+    posmatch_T	pos;	    /* position matches */
     match_T	hl;	    /* struct for doing the actual highlighting */
 };
 
@@ -1927,7 +2036,6 @@
 				       time through cursupdate() to the
 				       current virtual column */
 
-#ifdef FEAT_VISUAL
     /*
      * the next six are used to update the visual part
      */
@@ -1938,7 +2046,6 @@
     linenr_T	w_old_visual_lnum;  /* last known start of visual part */
     colnr_T	w_old_visual_col;   /* last known start of visual part */
     colnr_T	w_old_curswant;	    /* last known value of Curswant */
-#endif
 
     /*
      * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
@@ -2113,6 +2220,11 @@
 #ifdef FEAT_SYN_HL
     int		*w_p_cc_cols;	    /* array of columns to highlight or NULL */
 #endif
+#ifdef FEAT_LINEBREAK
+    int		w_p_brimin;	    /* minimum width for breakindent */
+    int		w_p_brishift;	    /* additional shift for breakindent */
+    int		w_p_brisbr;	    /* sbr in 'briopt' */
+#endif
 
     /* transform a pointer to a "onebuf" option into a "allbuf" option */
 #define GLOBAL_WO(p)	((char *)p + sizeof(winopt_T))
@@ -2240,10 +2352,8 @@
 				   (inclusive) */
     int		empty;		/* op_start and op_end the same (only used by
 				   do_change()) */
-#ifdef FEAT_VISUAL
     int		is_VIsual;	/* operator on Visual area */
     int		block_mode;	/* current operator is Visual block mode */
-#endif
     colnr_T	start_vcol;	/* start col for block mode operator */
     colnr_T	end_vcol;	/* end col for block mode operator */
 #ifdef FEAT_AUTOCMD
diff -Naur vim74.orig/src/syntax.c vim74/src/syntax.c
--- vim74.orig/src/syntax.c	2013-06-08 14:10:08.000000000 +0000
+++ vim74/src/syntax.c	2014-10-10 14:53:45.392044584 +0000
@@ -6837,10 +6837,8 @@
 	CENT("SignColumn term=standout ctermbg=Grey ctermfg=DarkBlue",
 	     "SignColumn term=standout ctermbg=Grey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue"),
 #endif
-#ifdef FEAT_VISUAL
 	CENT("Visual term=reverse",
 	     "Visual term=reverse guibg=LightGrey"),
-#endif
 #ifdef FEAT_DIFF
 	CENT("DiffAdd term=bold ctermbg=LightBlue",
 	     "DiffAdd term=bold ctermbg=LightBlue guibg=LightBlue"),
@@ -6927,10 +6925,8 @@
 	CENT("SignColumn term=standout ctermbg=DarkGrey ctermfg=Cyan",
 	     "SignColumn term=standout ctermbg=DarkGrey ctermfg=Cyan guibg=Grey guifg=Cyan"),
 #endif
-#ifdef FEAT_VISUAL
 	CENT("Visual term=reverse",
 	     "Visual term=reverse guibg=DarkGrey"),
-#endif
 #ifdef FEAT_DIFF
 	CENT("DiffAdd term=bold ctermbg=DarkBlue",
 	     "DiffAdd term=bold ctermbg=DarkBlue guibg=DarkBlue"),
@@ -7071,7 +7067,7 @@
 	retval = source_runtime(buf, FALSE);
 	vim_free(buf);
 #ifdef FEAT_AUTOCMD
-	apply_autocmds(EVENT_COLORSCHEME, NULL, NULL, FALSE, curbuf);
+	apply_autocmds(EVENT_COLORSCHEME, name, curbuf->b_fname, FALSE, curbuf);
 #endif
     }
     recursive = FALSE;
@@ -8047,8 +8043,14 @@
 {
     return (   HL_TABLE()[idx].sg_term_attr != 0
 	    || HL_TABLE()[idx].sg_cterm_attr != 0
+	    || HL_TABLE()[idx].sg_cterm_fg != 0
+	    || HL_TABLE()[idx].sg_cterm_bg != 0
 #ifdef FEAT_GUI
 	    || HL_TABLE()[idx].sg_gui_attr != 0
+	    || HL_TABLE()[idx].sg_gui_fg_name != NULL
+	    || HL_TABLE()[idx].sg_gui_bg_name != NULL
+	    || HL_TABLE()[idx].sg_gui_sp_name != NULL
+	    || HL_TABLE()[idx].sg_font_name != NUL
 #endif
 	    || (check_link && (HL_TABLE()[idx].sg_set & SG_LINK)));
 }
diff -Naur vim74.orig/src/tag.c vim74/src/tag.c
--- vim74.orig/src/tag.c	2013-06-15 20:26:26.000000000 +0000
+++ vim74/src/tag.c	2014-10-10 14:53:45.398711234 +0000
@@ -741,8 +741,10 @@
 			    break;
 			msg_advance(15);
 
-			/* skip backslash used for escaping command char */
-			if (*p == '\\' && *(p + 1) == *tagp.command)
+			/* skip backslash used for escaping a command char or
+			 * a backslash */
+			if (*p == '\\' && (*(p + 1) == *tagp.command
+				        || *(p + 1) == '\\'))
 			    ++p;
 
 			if (*p == TAB)
@@ -1326,6 +1328,7 @@
     int		match_no_ic = 0;/* matches with rm_ic == FALSE */
     int		match_re;	/* match with regexp */
     int		matchoff = 0;
+    int		save_emsg_off;
 
 #ifdef FEAT_EMACS_TAGS
     /*
@@ -1442,7 +1445,10 @@
     if (p_tl != 0 && orgpat.len > p_tl)		/* adjust for 'taglength' */
 	orgpat.len = p_tl;
 
+    save_emsg_off = emsg_off;
+    emsg_off = TRUE;  /* don't want error for invalid RE here */
     prepare_pats(&orgpat, has_re);
+    emsg_off = save_emsg_off;
     if (has_re && orgpat.regmatch.regprog == NULL)
 	goto findtag_end;
 
@@ -1797,13 +1803,16 @@
 	     */
 	    if (state == TS_START)
 	    {
-		/* The header ends when the line sorts below "!_TAG_".
-		 * There may be non-header items before the header though,
-		 * e.g. "!" itself. When case is folded lower case letters
-		 * sort before "_". */
+		/* The header ends when the line sorts below "!_TAG_".  When
+		 * case is folded lower case letters sort before "_". */
 		if (STRNCMP(lbuf, "!_TAG_", 6) <= 0
 				|| (lbuf[0] == '!' && ASCII_ISLOWER(lbuf[1])))
 		{
+		    if (STRNCMP(lbuf, "!_TAG_", 6) != 0)
+			/* Non-header item before the header, e.g. "!" itself.
+			 */
+			goto parse_line;
+
 		    /*
 		     * Read header line.
 		     */
@@ -1898,6 +1907,7 @@
 #endif
 	    }
 
+parse_line:
 	    /*
 	     * Figure out where the different strings are in this line.
 	     * For "normal" tags: Do a quick check if the tag matches.
@@ -3326,7 +3336,9 @@
 #ifdef FEAT_SEARCH_EXTRA
 	/* restore no_hlsearch when keeping the old search pattern */
 	if (search_options)
-	    no_hlsearch = save_no_hlsearch;
+	{
+	    SET_NO_HLSEARCH(save_no_hlsearch);
+	}
 #endif
 
 	/* Return OK if jumped to another file (at least we found the file!). */
diff -Naur vim74.orig/src/term.c vim74/src/term.c
--- vim74.orig/src/term.c	2013-07-04 20:29:28.000000000 +0000
+++ vim74/src/term.c	2014-10-10 14:53:45.408711209 +0000
@@ -3259,7 +3259,7 @@
 	    may_req_termresponse();
 	    /* Immediately check for a response.  If t_Co changes, we don't
 	     * want to redraw with wrong colors first. */
-	    if (crv_status != CRV_GET)
+	    if (crv_status == CRV_SENT)
 		check_for_codes_from_term();
 	}
 #endif
@@ -3356,7 +3356,7 @@
  * it must be called immediately after entering termcap mode.
  */
     void
-may_req_ambiguous_character_width()
+may_req_ambiguous_char_width()
 {
     if (u7_status == U7_GET
 	    && cur_tmode == TMODE_RAW
@@ -3379,7 +3379,8 @@
 	 out_str(buf);
 	 out_str(T_U7);
 	 u7_status = U7_SENT;
-	 term_windgoto(0, 0);
+	 out_flush();
+	 term_windgoto(1, 0);
 	 out_str((char_u *)"  ");
 	 term_windgoto(0, 0);
 	 /* check for the characters now, otherwise they might be eaten by
@@ -3455,12 +3456,9 @@
 	return;
     }
 
-#  ifdef FEAT_VISUAL
     if (VIsual_active)
 	checkfor = MOUSE_VISUAL;
-    else
-#  endif
-	if (State == HITRETURN || State == ASKMORE || State == SETWSIZE)
+    else if (State == HITRETURN || State == ASKMORE || State == SETWSIZE)
 	checkfor = MOUSE_RETURN;
     else if (State & INSERT)
 	checkfor = MOUSE_INSERT;
@@ -3684,7 +3682,11 @@
 	return;
     }
 
+#if defined(WIN3264) && !defined(FEAT_GUI)
+    s = vim_strnsave(string, (int)STRLEN(string) + 1);
+#else
     s = vim_strsave(string);
+#endif
     if (s == NULL)
 	return;
 
@@ -3694,6 +3696,15 @@
 	STRMOVE(s, s + 1);
 	s[0] = term_7to8bit(string);
     }
+
+#if defined(WIN3264) && !defined(FEAT_GUI)
+    if (s[0] == K_NUL)
+    {
+	STRMOVE(s + 1, s);
+	s[1] = 3;
+    }
+#endif
+
     len = (int)STRLEN(s);
 
     need_gather = TRUE;		/* need to fill termleader[] */
@@ -4159,24 +4170,31 @@
 
 #ifdef FEAT_TERMRESPONSE
 	if (key_name[0] == NUL
-	    /* URXVT mouse uses <ESC>[#;#;#M, but we are matching <ESC>[ */
+	    /* Mouse codes of DEC, pterm, and URXVT start with <ESC>[.  When
+	     * detecting the start of these mouse codes they might as well be
+	     * another key code or terminal response. */
+# ifdef FEAT_MOUSE_DEC
+	    || key_name[0] == KS_DEC_MOUSE
+# endif
+# ifdef FEAT_MOUSE_PTERM
+	    || key_name[0] == KS_PTERM_MOUSE
+# endif
+# ifdef FEAT_MOUSE_URXVT
 	    || key_name[0] == KS_URXVT_MOUSE
-# ifdef FEAT_MBYTE
-	    || u7_status == U7_SENT
 # endif
-            )
+	   )
 	{
-	    /* Check for some responses from terminal start with "<Esc>[" or
-	     * CSI.
+	    /* Check for some responses from the terminal starting with
+	     * "<Esc>[" or CSI:
 	     *
-	     * - xterm version string: <Esc>[>{x};{vers};{y}c
+	     * - Xterm version string: <Esc>[>{x};{vers};{y}c
 	     *   Also eat other possible responses to t_RV, rxvt returns
 	     *   "<Esc>[?1;2c". Also accept CSI instead of <Esc>[.
 	     *   mrxvt has been reported to have "+" in the version. Assume
 	     *   the escape sequence ends with a letter or one of "{|}~".
 	     *
-	     * - cursor position report: <Esc>[{row};{col}R
-	     *   The final byte is 'R'. now it is only used for checking for
+	     * - Cursor position report: <Esc>[{row};{col}R
+	     *   The final byte must be 'R'. It is used for checking the
 	     *   ambiguous-width character state.
 	     */
 	    p = tp[0] == CSI ? tp + 1 : tp + 2;
@@ -4185,55 +4203,73 @@
 			    || (tp[0] == CSI && len >= 2))
 			&& (VIM_ISDIGIT(*p) || *p == '>' || *p == '?'))
 	    {
+#ifdef FEAT_MBYTE
+		int col;
+		int row_char = NUL;
+#endif
 		j = 0;
 		extra = 0;
 		for (i = 2 + (tp[0] != CSI); i < len
 				&& !(tp[i] >= '{' && tp[i] <= '~')
 				&& !ASCII_ISALPHA(tp[i]); ++i)
 		    if (tp[i] == ';' && ++j == 1)
+		    {
 			extra = i + 1;
+#ifdef FEAT_MBYTE
+			row_char = tp[i - 1];
+#endif
+		    }
 		if (i == len)
 		{
 		    LOG_TR("Not enough characters for CRV");
 		    return -1;
 		}
-
 #ifdef FEAT_MBYTE
-		/* Eat it when it has 2 arguments and ends in 'R'. Ignore it
-		 * when u7_status is not "sent", <S-F3> sends something
-		 * similar. */
-		if (j == 1 && tp[i] == 'R' && u7_status == U7_SENT)
+		if (extra > 0)
+		    col = atoi((char *)tp + extra);
+		else
+		    col = 0;
+
+		/* Eat it when it has 2 arguments and ends in 'R'. Also when
+		 * u7_status is not "sent", it may be from a previous Vim that
+		 * just exited.  But not for <S-F3>, it sends something
+		 * similar, check for row and column to make sense. */
+		if (j == 1 && tp[i] == 'R')
 		{
-		    char *aw = NULL;
+		    if (row_char == '2' && col >= 2)
+		    {
+			char *aw = NULL;
 
-		    LOG_TR("Received U7 status");
-		    u7_status = U7_GOT;
+			LOG_TR("Received U7 status");
+			u7_status = U7_GOT;
 # ifdef FEAT_AUTOCMD
-		    did_cursorhold = TRUE;
+			did_cursorhold = TRUE;
 # endif
-		    if (extra > 0)
-			extra = atoi((char *)tp + extra);
-		    if (extra == 2)
-			aw = "single";
-		    else if (extra == 3)
-			aw = "double";
-		    if (aw != NULL && STRCMP(aw, p_ambw) != 0)
-		    {
-			/* Setting the option causes a screen redraw. Do that
-			 * right away if possible, keeping any messages. */
-			set_option_value((char_u *)"ambw", 0L, (char_u *)aw, 0);
-#ifdef DEBUG_TERMRESPONSE
+			if (col == 2)
+			    aw = "single";
+			else if (col == 3)
+			    aw = "double";
+			if (aw != NULL && STRCMP(aw, p_ambw) != 0)
 			{
-			    char buf[100];
-			    int  r = redraw_asap(CLEAR);
+			    /* Setting the option causes a screen redraw. Do
+			     * that right away if possible, keeping any
+			     * messages. */
+			    set_option_value((char_u *)"ambw", 0L,
+					     (char_u *)aw, 0);
+# ifdef DEBUG_TERMRESPONSE
+			    {
+				char buf[100];
+				int  r = redraw_asap(CLEAR);
 
-			    sprintf(buf, "set 'ambiwidth', redraw_asap(): %d",
-									   r);
-			    log_tr(buf);
+				sprintf(buf,
+					"set 'ambiwidth', redraw_asap(): %d",
+					r);
+				log_tr(buf);
+			    }
+# else
+			    redraw_asap(CLEAR);
+# endif
 			}
-#else
-			redraw_asap(CLEAR);
-#endif
 		    }
 		    key_name[0] = (int)KS_EXTRA;
 		    key_name[1] = (int)KE_IGNORE;
@@ -4498,19 +4534,19 @@
 			return -1;
 
 		    /* when mouse reporting is SGR, add 32 to mouse code */
-                    if (key_name[0] == KS_SGR_MOUSE)
-                        mouse_code += 32;
+		    if (key_name[0] == KS_SGR_MOUSE)
+			mouse_code += 32;
 
 		    mouse_col = getdigits(&p) - 1;
 		    if (*p++ != ';')
 			return -1;
 
 		    mouse_row = getdigits(&p) - 1;
-                    if (key_name[0] == KS_SGR_MOUSE && *p == 'm')
+		    if (key_name[0] == KS_SGR_MOUSE && *p == 'm')
 			mouse_code |= MOUSE_RELEASE;
-                    else if (*p != 'M')
+		    else if (*p != 'M')
 			return -1;
-                    p++;
+		    p++;
 
 		    slen += (int)(p - (tp + slen));
 
@@ -4527,7 +4563,7 @@
 			for (slen2 = slen; slen2 < len; slen2++)
 			{
 			    if (tp[slen2] == 'M'
-                                || (key_name[0] == KS_SGR_MOUSE
+				    || (key_name[0] == KS_SGR_MOUSE
 							 && tp[slen2] == 'm'))
 			    {
 				cmd_complete = 1;
diff -Naur vim74.orig/src/testdir/Make_amiga.mak vim74/src/testdir/Make_amiga.mak
--- vim74.orig/src/testdir/Make_amiga.mak	2013-07-09 11:40:02.000000000 +0000
+++ vim74/src/testdir/Make_amiga.mak	2014-10-10 14:53:45.415377859 +0000
@@ -33,7 +33,19 @@
 		test76.out test77.out test78.out test79.out test80.out \
 		test81.out test82.out test83.out test84.out test88.out \
 		test89.out test90.out test91.out test92.out test93.out \
-		test94.out test95.out test96.out test97.out test98.out
+		test94.out test95.out test96.out test97.out test98.out \
+		test99.out test100.out test101.out test102.out test103.out \
+		test104.out test105.out test106.out test107.out \
+		test_autoformat_join.out \
+		test_breakindent.out \
+		test_changelist.out \
+		test_eval.out \
+		test_insertcount.out \
+		test_listlbr.out \
+		test_listlbr_utf8.out \
+		test_options.out \
+		test_qf_title.out \
+		test_utf8.out
 
 .SUFFIXES: .in .out
 
@@ -148,3 +160,22 @@
 test96.out: test96.in
 test97.out: test97.in
 test98.out: test98.in
+test99.out: test99.in
+test100.out: test100.in
+test101.out: test101.in
+test102.out: test102.in
+test103.out: test103.in
+test104.out: test104.in
+test105.out: test105.in
+test106.out: test106.in
+test107.out: test107.in
+test_autoformat_join.out: test_autoformat_join.in
+test_breakindent.out: test_breakindent.in
+test_changelist.out: test_changelist.in
+test_eval.out: test_eval.in
+test_insertcount.out: test_insertcount.in
+test_listlbr.out: test_listlbr.in
+test_listlbr_utf8.out: test_listlbr_utf8.in
+test_options.out: test_options.in
+test_qf_title.out: test_qf_title.in
+test_utf8.out: test_utf8.in
diff -Naur vim74.orig/src/testdir/Make_dos.mak vim74/src/testdir/Make_dos.mak
--- vim74.orig/src/testdir/Make_dos.mak	2013-07-09 11:40:30.000000000 +0000
+++ vim74/src/testdir/Make_dos.mak	2014-10-10 14:53:45.415377859 +0000
@@ -32,7 +32,19 @@
 		test79.out test80.out test81.out test82.out test83.out \
 		test84.out test85.out test86.out test87.out test88.out \
 		test89.out test90.out test91.out test92.out test93.out \
-		test94.out test95.out test96.out test98.out
+		test94.out test95.out test96.out test98.out test99.out \
+		test100.out test101.out test102.out test103.out test104.out \
+		test105.out test106.out  test107.out\
+		test_autoformat_join.out \
+		test_breakindent.out \
+		test_changelist.out \
+		test_eval.out \
+		test_insertcount.out \
+		test_listlbr.out \
+		test_listlbr_utf8.out \
+		test_options.out \
+		test_qf_title.out \
+		test_utf8.out
 
 SCRIPTS32 =	test50.out test70.out
 
@@ -51,7 +63,7 @@
 fixff:
 	-$(VIMPROG) -u dos.vim --noplugin "+argdo set ff=dos|upd" +q *.in *.ok
 	-$(VIMPROG) -u dos.vim --noplugin "+argdo set ff=unix|upd" +q \
-		dotest.in test60.ok test71.ok test74.ok
+		dotest.in test60.ok test71.ok test74.ok test100.ok
 
 report:
 	@echo ""
diff -Naur vim74.orig/src/testdir/Make_ming.mak vim74/src/testdir/Make_ming.mak
--- vim74.orig/src/testdir/Make_ming.mak	2013-07-09 11:40:38.000000000 +0000
+++ vim74/src/testdir/Make_ming.mak	2014-10-10 14:53:45.418711183 +0000
@@ -52,7 +52,19 @@
 		test79.out test80.out test81.out test82.out test83.out \
 		test84.out test85.out test86.out test87.out test88.out \
 		test89.out test90.out test91.out test92.out test93.out \
-		test94.out test95.out test96.out test98.out
+		test94.out test95.out test96.out test98.out test99.out \
+		test100.out test101.out test102.out test103.out test104.out \
+		test105.out test106.out test107.out \
+		test_autoformat_join.out \
+		test_breakindent.out \
+		test_changelist.out \
+		test_eval.out \
+		test_insertcount.out \
+		test_listlbr.out \
+		test_listlbr_utf8.out \
+		test_options.out \
+		test_qf_title.out \
+		test_utf8.out
 
 SCRIPTS32 =	test50.out test70.out
 
diff -Naur vim74.orig/src/testdir/Make_os2.mak vim74/src/testdir/Make_os2.mak
--- vim74.orig/src/testdir/Make_os2.mak	2013-07-09 11:40:43.000000000 +0000
+++ vim74/src/testdir/Make_os2.mak	2014-10-10 14:53:45.418711183 +0000
@@ -34,7 +34,19 @@
 		test76.out test77.out test78.out test79.out test80.out \
 		test81.out test82.out test83.out test84.out test88.out \
 		test89.out test90.out test91.out test92.out test93.out \
-		test94.out test95.out test96.out test98.out
+		test94.out test95.out test96.out test98.out test99.out \
+		test100.out test101.out test102.out test103.out test104.out \
+		test105.out test106.out test107.out \
+		test_autoformat_join.out \
+		test_breakindent.out \
+		test_changelist.out \
+		test_eval.out \
+		test_insertcount.out \
+		test_listlbr.out \
+		test_listlbr_utf8.out \
+		test_options.out \
+		test_qf_title.out \
+		test_utf8.out
 
 .SUFFIXES: .in .out
 
diff -Naur vim74.orig/src/testdir/Make_vms.mms vim74/src/testdir/Make_vms.mms
--- vim74.orig/src/testdir/Make_vms.mms	2013-07-09 11:40:47.000000000 +0000
+++ vim74/src/testdir/Make_vms.mms	2014-10-10 14:53:45.422044508 +0000
@@ -4,7 +4,7 @@
 # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
 #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
 #
-# Last change:  2013 Jul 09
+# Last change:  2014 Aug 16
 #
 # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
 # Edit the lines in the Configuration section below to select.
@@ -41,16 +41,31 @@
 # They fail because VMS does not support file names.
 # WANT_SPELL = YES
 
-# Comment out if you want to run mzschema  tests.
+# Comment out if you want to run mzschema tests.
 # It fails because VMS does not support this feature yet.
 # WANT_MZSCH = YES
 
+# Comment out if you have ODS-5 file system                                                                                                                 
+# HAVE_ODS5 = YES
+
 # Comment out if you have gzip on your system
 # HAVE_GZIP = YES
 
 # Comment out if you have GNU compatible diff on your system
 # HAVE_GDIFF = YES
 
+# Comment out if you have GNU compatible cksum on your system                                                                                                  
+# HAVE_CKSUM = YES
+
+# Comment out if you have ICONV support                                                                                                  
+# HAVE_ICONV = YES
+
+# Comment out if you have LUA support
+# HAVE_LUA = YES
+
+# Comment out if you have PYTHON support
+# HAVE_PYTHON = YES
+
 #######################################################################
 # End of configuration section.
 #
@@ -63,35 +78,54 @@
 
 SCRIPT = test1.out  test2.out  test3.out  test4.out  test5.out  \
 	 test6.out  test7.out  test8.out  test9.out  test10a.out\
-	 test13.out test14.out test15.out test17.out \
+	 test13.out test14.out test15.out \
 	 test18.out test19.out test20.out test21.out test22.out \
 	 test23.out test24.out test26.out \
 	 test28.out test29.out test30.out test31.out test32.out \
 	 test33.out test34.out test35.out test36.out test37.out \
 	 test38.out test39.out test40.out test41.out test42.out \
 	 test43.out test44.out test45.out test46.out \
-	 test48.out test51.out test53.out test54.out test55.out \
-	 test56.out test57.out test60.out \
+	 test48.out test49.out test51.out test53.out test54.out \
+	 test55.out test56.out test57.out test60.out \
 	 test61.out test62.out test63.out test64.out test65.out \
 	 test66.out test67.out test68.out test69.out \
 	 test71.out test72.out test74.out test75.out test76.out \
-	 test77.out test78.out test79.out test80.out test81.out \
-	 test82.out test83.out test84.out test88.out test89.out \
+	 test77a.out test78.out test79.out test80.out test81.out \
+	 test82.out test84.out test88.out test89.out \
 	 test90.out test91.out test92.out test93.out test94.out \
-	 test95.out test96.out test97.out test98.out
+	 test95.out test96.out test98.out test99.out \
+	 test100.out test101.out test103.out test104.out \
+	 test105.out test106.out test107.out \
+	 test_autoformat_join.out \
+	 test_breakindent.out \
+	 test_changelist.out \
+	 test_eval.out \
+	 test_insertcount.out \
+	 test_listlbr.out \
+	 test_listlbr_utf8.out \
+	 test_options.out \
+	 test_qf_title.out \
+	 test_utf8.out
 
 # Known problems:
-# Test 30: a problem around mac format - unknown reason
+# test17: ?
+#
+# test30: bug, most probably - a problem around mac format
 #
-# Test 32: VMS is not case sensitive and all filenames are lowercase within Vim
+# test32: VMS is not case sensitive and all filenames are lowercase within Vim
 # (this should be changed in order to preserve the original filename) - should
 # be fixed. VMS allows just one dot in the filename
 #
-# Test 58 and 59: Failed/Hangs - VMS does not support spell files (file names
+# test58, test59: Failed/Hangs - VMS does not support spell files (file names
 # with too many dots).
 #
-# Test 72: unknown reason
-# Test 85: no Lua interface
+# test72: bug - Vim hangs at :rename (while rename works well otherwise)
+# test78: bug - Vim dies at :recover Xtest 
+# test83: ?
+# test85: no Lua interface
+# test89: bug - findfile() does not work on VMS (just in the current directory) 
+# test97, test102: Just ODS-5 supports space and special chars in the filename.
+# On ODS-2 tests fail. 
 
 .IFDEF WANT_GUI
 SCRIPT_GUI = test16.out
@@ -99,7 +133,7 @@
 .ENDIF
 
 .IFDEF WANT_UNIX
-SCRIPT_UNIX = test10.out test12.out test25.out test27.out test49.out test73.out
+SCRIPT_UNIX = test10.out test12.out test17.out test25.out test27.out test49.out test73.out
 .ENDIF
 
 .IFDEF WANT_WIN
@@ -114,6 +148,10 @@
 SCRIPT_MZSCH = test70.out 
 .ENDIF
 
+.IFDEF HAVE_ODS5                                                                                                                                   
+SCRIPT_ODS5 = test97.out test102.out                                                                                                   
+.ENDIF  
+
 .IFDEF HAVE_GZIP
 SCRIPT_GZIP = test11.out
 .ENDIF
@@ -122,10 +160,28 @@
 SCRIPT_GDIFF = test47.out
 .ENDIF
 
+.IFDEF HAVE_CKSUM
+SCRIPT_CKSUM = test77.out
+.ENDIF
+
+.IFDEF HAVE_ICONV
+SCRIPT_ICONV = test83.out
+.ENDIF
+
+.IFDEF HAVE_LUA
+SCRIPT_LUA = test85.out
+.ENDIF
+
+.IFDEF HAVE_PYTHON
+SCRIPT_PYTHON = test86.out test87.out
+.ENDIF
+
 .in.out :
 	-@ !clean up before doing the test
 	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then delete/noconfirm/nolog test.out.*
 	-@ if "''F$SEARCH("$*.out.*")'"   .NES. "" then delete/noconfirm/nolog $*.out.*
+	-@ ! define TMP if not set - some tests use it
+	-@ if "''F$TRNLNM("TMP")'" .EQS. "" then define/nolog TMP []
 	-@ write sys$output " "
 	-@ write sys$output "-----------------------------------------------"
 	-@ write sys$output "                "$*" "
@@ -138,9 +194,10 @@
 	-@ if "''F$SEARCH("$*.out.*")'"   .NES. "" then differences /par $*.out $*.ok;
 	-@ !clean up after the test
 	-@ if "''F$SEARCH("Xdotest.*")'"  .NES. "" then delete/noconfirm/nolog Xdotest.*.*
+	-@ if "''F$SEARCH("Xtest.*")'"    .NES. "" then delete/noconfirm/nolog Xtest.*.*
 
-all : clean nolog $(START_WITH) $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_WIN) $(SCRIPT_SPELL) $(SCRIPT_GZIP) \
-    $(SCRIPT_GDIFF) $(SCRIPT_MZSCH) nolog 
+all : clean nolog $(START_WITH) $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_WIN) $(SCRIPT_SPELL) $(SCRIPT_ODS5) $(SCRIPT_GZIP) \
+    $(SCRIPT_GDIFF) $(SCRIPT_MZSCH) $(SCRIPT_CKSUM) $(SCRIPT_ICONV) $(SCRIPT_LUA) $(SCRIPT_PYTHON) nolog 
 	-@ write sys$output " "
 	-@ write sys$output "-----------------------------------------------"
 	-@ write sys$output "                All done"
@@ -163,13 +220,18 @@
 	-@ write sys$output "                Test results:"
 	-@ write sys$output "-----------------------------------------------"
 	-@ write sys$output "MAKE_VMS.MMS options:"
-	-@ write sys$output "   WANT_GUI  = ""$(WANT_GUI)"" "
-	-@ write sys$output "   WANT_UNIX = ""$(WANT_UNIX)"" "
-	-@ write sys$output "   WANT_WIN  = ""$(WANT_WIN)"" "
-	-@ write sys$output "   WANT_SPELL= ""$(WANT_SPELL)"" "
-	-@ write sys$output "   WANT_MZSCH= ""$(WANT_MZSCH)"" "
-	-@ write sys$output "   HAVE_GZIP = ""$(HAVE_GZIP)"" "
-	-@ write sys$output "   HAVE_GDIFF= ""$(HAVE_GDIFF)"" "
+	-@ write sys$output "   WANT_GUI   = ""$(WANT_GUI)"" "
+	-@ write sys$output "   WANT_UNIX  = ""$(WANT_UNIX)"" "
+	-@ write sys$output "   WANT_WIN   = ""$(WANT_WIN)"" "
+	-@ write sys$output "   WANT_SPELL = ""$(WANT_SPELL)"" "
+	-@ write sys$output "   WANT_MZSCH = ""$(WANT_MZSCH)"" "
+	-@ write sys$output "   HAVE_ODS5  = ""$(HAVE_ODS5)"" "
+	-@ write sys$output "   HAVE_GZIP  = ""$(HAVE_GZIP)"" "
+	-@ write sys$output "   HAVE_GDIFF = ""$(HAVE_GDIFF)"" "
+	-@ write sys$output "   HAVE_CKSUM = ""$(HAVE_CKSUM)"" "	  
+	-@ write sys$output "   HAVE_ICONV = ""$(HAVE_ICONV)"" "
+	-@ write sys$output "   HAVE_LUA   = ""$(HAVE_LUA)"" "
+	-@ write sys$output "   HAVE_PYTHON= ""$(HAVE_PYTHON)"" "
 	-@ write sys$output "Default vimrc file is VMS.VIM:"
 	-@ write sys$output "-----------------------------------------------"
 	-@ type VMS.VIM
@@ -179,6 +241,9 @@
 	-@ if "''F$SEARCH("test.log")'"     .NES. "" then delete/noconfirm/nolog test.log.*
 	-@ if "''F$SEARCH("test.ok")'"      .NES. "" then delete/noconfirm/nolog test.ok.*
 	-@ if "''F$SEARCH("Xdotest.*")'"    .NES. "" then delete/noconfirm/nolog Xdotest.*.*
+	-@ if "''F$SEARCH("Xtest*.*")'"     .NES. "" then delete/noconfirm/nolog Xtest*.*.*
+	-@ if "''F$SEARCH("XX*.*")'"        .NES. "" then delete/noconfirm/nolog XX*.*.*
+	-@ if "''F$SEARCH("_un_*.*")'"      .NES. "" then delete/noconfirm/nolog _un_*.*.*
 	-@ if "''F$SEARCH("*.*_sw*")'"      .NES. "" then delete/noconfirm/nolog *.*_sw*.*
 	-@ if "''F$SEARCH("*.failed")'"     .NES. "" then delete/noconfirm/nolog *.failed.*
 	-@ if "''F$SEARCH("*.rej")'"        .NES. "" then delete/noconfirm/nolog *.rej.*
@@ -186,6 +251,6 @@
 	-@ if "''F$SEARCH("small.vim")'"    .NES. "" then delete/noconfirm/nolog small.vim.*
 	-@ if "''F$SEARCH("mbyte.vim")'"    .NES. "" then delete/noconfirm/nolog mbyte.vim.*
 	-@ if "''F$SEARCH("mzscheme.vim")'" .NES. "" then delete/noconfirm/nolog mzscheme.vim.*
-	-@ if "''F$SEARCH("lua.vim")'" .NES. "" then delete/noconfirm/nolog lua.vim.*
+	-@ if "''F$SEARCH("lua.vim")'"      .NES. "" then delete/noconfirm/nolog lua.vim.*
 	-@ if "''F$SEARCH("viminfo.*")'"    .NES. "" then delete/noconfirm/nolog viminfo.*.*
 
diff -Naur vim74.orig/src/testdir/Makefile vim74/src/testdir/Makefile
--- vim74.orig/src/testdir/Makefile	2013-08-10 12:20:20.000000000 +0000
+++ vim74/src/testdir/Makefile	2014-10-10 14:53:45.425377833 +0000
@@ -3,6 +3,7 @@
 #
 
 VIMPROG = ../vim
+SCRIPTSOURCE = ../../runtime
 
 # Uncomment this line to use valgrind for memory leaks and extra warnings.
 #   The output goes into a file "valgrind.testN"
@@ -29,7 +30,19 @@
 		test79.out test80.out test81.out test82.out test83.out \
 		test84.out test85.out test86.out test87.out test88.out \
 		test89.out test90.out test91.out test92.out test93.out \
-		test94.out test95.out test96.out test97.out test98.out
+		test94.out test95.out test96.out test97.out test98.out \
+		test99.out test100.out test101.out test102.out test103.out \
+		test104.out test105.out test106.out test107.out \
+		test_autoformat_join.out \
+		test_breakindent.out \
+		test_changelist.out \
+		test_eval.out \
+		test_insertcount.out \
+		test_listlbr.out \
+		test_listlbr_utf8.out \
+		test_options.out \
+		test_qf_title.out \
+		test_utf8.out
 
 SCRIPTS_GUI = test16.out
 
@@ -51,15 +64,19 @@
 
 RM_ON_RUN = test.out X* viminfo
 RM_ON_START = tiny.vim small.vim mbyte.vim mzscheme.vim lua.vim test.ok
-RUN_VIM = $(VALGRIND) $(VIMPROG) -u unix.vim -U NONE --noplugin -s dotest.in
+RUN_VIM = VIMRUNTIME=$(SCRIPTSOURCE); export VIMRUNTIME; $(VALGRIND) $(VIMPROG) -u unix.vim -U NONE --noplugin -s dotest.in
 
 clean:
 	-rm -rf *.out *.failed *.rej *.orig test.log $(RM_ON_RUN) $(RM_ON_START) valgrind.*
 
 test1.out: test1.in
-	-rm -rf $*.failed $(RM_ON_RUN) $(RM_ON_START)
+	-rm -rf $*.failed $(RM_ON_RUN) $(RM_ON_START) wrongtermsize
 	$(RUN_VIM) $*.in
-	@/bin/sh -c "if diff test.out $*.ok; \
+	@/bin/sh -c "if test -f wrongtermsize; \
+		then echo; \
+		echo test1 FAILED - terminal size must be 80x24 or larger; \
+		echo; exit 1; \
+		elif diff test.out $*.ok; \
 		then mv -f test.out $*.out; \
 		else echo; \
 		echo test1 FAILED - Something basic is wrong; \
diff -Naur vim74.orig/src/testdir/README.txt vim74/src/testdir/README.txt
--- vim74.orig/src/testdir/README.txt	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/README.txt	2014-10-10 14:53:45.425377833 +0000
@@ -0,0 +1,18 @@
+This directory contains tests for various Vim features.
+
+If it makes sense, try to add a new test to an already existing file.  You may
+want to separate it from other tests in that file using :" (that's an Ex
+command comment).
+
+The numbered tests are older, we have switched to named tests.
+
+To add a new test:
+1) Create test_<subject>.in and test_<subject>.ok files.
+2) Add them to all Makefiles (Make*) in alphabetical order (search for an
+   existing test_file.out to see where to add the new one).
+3) Use make test_<subject>.out to run a single test file in src/testdir/.
+4) Also add an entry in src/Makefile.
+
+Keep in mind that the files are used as if everything was typed.
+A line break is like pressing Enter.  If that happens on the last line you'll
+hear a beep.
diff -Naur vim74.orig/src/testdir/sautest/autoload/Test104.vim vim74/src/testdir/sautest/autoload/Test104.vim
--- vim74.orig/src/testdir/sautest/autoload/Test104.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/sautest/autoload/Test104.vim	2014-10-10 14:53:45.455377758 +0000
@@ -0,0 +1 @@
+let Test104#numvar = 123
diff -Naur vim74.orig/src/testdir/sautest/autoload/footest.vim vim74/src/testdir/sautest/autoload/footest.vim
--- vim74.orig/src/testdir/sautest/autoload/footest.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/sautest/autoload/footest.vim	2014-10-10 14:53:45.458711083 +0000
@@ -0,0 +1,5 @@
+" Autoload script used by test55 and test60
+let footest#x = 1
+func footest#F()
+  return 0
+endfunc
diff -Naur vim74.orig/src/testdir/test1.in vim74/src/testdir/test1.in
--- vim74.orig/src/testdir/test1.in	2012-04-05 14:37:37.000000000 +0000
+++ vim74/src/testdir/test1.in	2014-10-10 14:53:45.458711083 +0000
@@ -18,6 +18,10 @@
 Similar logic is applied to the +lua feature, using lua.vim.
 
 STARTTEST
+:" If columns or lines are too small, create wrongtermsize.
+:" (Some tests will fail. When columns and/or lines are small)
+:if &lines < 24 || &columns < 80 | sp another | w! wrongtermsize | qa! | endif
+:"
 :" Write a single line to test.out to check if testing works at all.
 :%d
 athis is a test:w! test.out
diff -Naur vim74.orig/src/testdir/test100.in vim74/src/testdir/test100.in
--- vim74.orig/src/testdir/test100.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test100.in	2014-10-10 14:53:45.465377733 +0000
@@ -0,0 +1,53 @@
+Tests for 'undolevel' and 'lispwords' settings being global-local
+
+STARTTEST
+:so small.vim
+:set nocompatible viminfo+=nviminfo ul=5
+:fu! FillBuffer()
+  :for i in range(1,13)
+    :put=i
+    :exe "setg ul=" . &g:ul
+  :endfor
+:endfu
+:fu! UndoLevel()
+  :redir @a | setglobal undolevels? | echon ' global' | setlocal undolevels? | echon ' local' |redir end
+  :$put a
+:endfu
+:new one
+:0put ='ONE: expecting global undolevels: 5, local undolevels: -123456 (default)'
+:call FillBuffer()
+:earlier 10
+:call UndoLevel()
+:set ff=unix
+:%w! test.out
+:new two
+:0put ='TWO: expecting global undolevels: 5, local undolevels: 2 (first) then 10 (afterwards)'
+:setlocal ul=2
+:call FillBuffer()
+:earlier 10
+:call UndoLevel()
+:setlocal ul=10
+:call UndoLevel()
+:set ff=unix
+:%w >> test.out
+:wincmd p
+:redir >>test.out | echo "global value shouldn't be changed and still be 5!" | echo 'ONE: expecting global undolevels: 5, local undolevels: -123456 (default)'|:setglobal undolevels? | echon ' global' | setlocal undolevels? | echon ' local' |echo "" |redir end
+:new three
+:setglobal ul=50
+:1put ='global value should be changed to 50'
+:2put ='THREE: expecting global undolevels: 50, local undolevels: -123456 (default)'
+:call UndoLevel()
+:set ff=unix
+:%w >> test.out
+:"sleep 10
+:"
+:" Testing 'lispwords'
+:"
+:setglobal lispwords=foo,bar,baz
+:setlocal lispwords-=foo | setlocal lispwords+=quux
+:redir >> test.out | echon "\nTesting 'lispwords' local value" | setglobal lispwords? | setlocal lispwords? | echo &lispwords . "\n" | redir end
+:setlocal lispwords<
+:redir >> test.out | echon "\nTesting 'lispwords' value reset" | setglobal lispwords? | setlocal lispwords? | echo &lispwords . "\n" | redir end
+:qa!
+ENDTEST
+
diff -Naur vim74.orig/src/testdir/test100.ok vim74/src/testdir/test100.ok
--- vim74.orig/src/testdir/test100.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test100.ok	2014-10-10 14:53:45.465377733 +0000
@@ -0,0 +1,51 @@
+ONE: expecting global undolevels: 5, local undolevels: -123456 (default)
+1
+2
+3
+4
+5
+6
+7
+
+
+  undolevels=5 global
+  undolevels=-123456 local
+TWO: expecting global undolevels: 5, local undolevels: 2 (first) then 10 (afterwards)
+1
+2
+3
+4
+5
+6
+7
+8
+9
+10
+
+
+  undolevels=5 global
+  undolevels=2 local
+
+  undolevels=5 global
+  undolevels=10 local
+
+global value shouldn't be changed and still be 5!
+ONE: expecting global undolevels: 5, local undolevels: -123456 (default)
+  undolevels=5 global
+  undolevels=-123456 local
+
+global value should be changed to 50
+THREE: expecting global undolevels: 50, local undolevels: -123456 (default)
+
+  undolevels=50 global
+  undolevels=-123456 local
+
+Testing 'lispwords' local value
+  lispwords=foo,bar,baz
+  lispwords=bar,baz,quux
+bar,baz,quux
+
+Testing 'lispwords' value reset
+  lispwords=foo,bar,baz
+  lispwords=foo,bar,baz
+foo,bar,baz
diff -Naur vim74.orig/src/testdir/test101.in vim74/src/testdir/test101.in
--- vim74.orig/src/testdir/test101.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test101.in	2014-10-10 14:53:45.468711058 +0000
@@ -0,0 +1,45 @@
+Test for v:hlsearch     vim: set ft=vim :
+
+STARTTEST
+:" Last abc: Q
+:so small.vim
+:new
+:call setline(1, repeat(['aaa'], 10))
+:set hlsearch nolazyredraw
+:let r=[]
+:command -nargs=0 -bar AddR :call add(r, [screenattr(1, 1), v:hlsearch])
+/aaa
+:AddR
+:nohlsearch
+:AddR
+:let v:hlsearch=1
+:AddR
+:let v:hlsearch=0
+:AddR
+:set hlsearch
+:AddR
+:let v:hlsearch=0
+:AddR
+n:AddR
+:let v:hlsearch=0
+:AddR
+/
+:AddR
+:let r1=r[0][0]
+:" I guess it is not guaranteed that screenattr outputs always the same character
+:call map(r, 'v:val[1].":".(v:val[0]==r1?"highlighted":"not highlighted")')
+:try
+:   let v:hlsearch=[]
+:catch
+:   call add(r, matchstr(v:exception,'^Vim(let):E\d\+:'))
+:endtry
+:bwipeout!
+:$put=r
+:call garbagecollect(1)
+:"
+:/^start:/,$wq! test.out
+:" vim: et ts=4 isk-=\:
+:call getchar()
+ENDTEST
+
+start:
diff -Naur vim74.orig/src/testdir/test101.ok vim74/src/testdir/test101.ok
--- vim74.orig/src/testdir/test101.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test101.ok	2014-10-10 14:53:45.468711058 +0000
@@ -0,0 +1,11 @@
+start:
+1:highlighted
+0:not highlighted
+1:highlighted
+0:not highlighted
+1:highlighted
+0:not highlighted
+1:highlighted
+0:not highlighted
+1:highlighted
+Vim(let):E706:
diff -Naur vim74.orig/src/testdir/test102.in vim74/src/testdir/test102.in
--- vim74.orig/src/testdir/test102.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test102.in	2014-10-10 14:53:45.468711058 +0000
@@ -0,0 +1,13 @@
+Test if fnameescape is correct for special chars like !
+
+STARTTEST
+:so small.vim
+:%d
+:let fname = 'Xspa ce'
+:try | exe "w! " . fnameescape(fname) | put='Space' | endtry 
+:let fname = 'Xemark!'
+:try | exe "w! " . fnameescape(fname) | put='ExclamationMark' | endtry
+:w! test.out
+:qa!
+ENDTEST
+
diff -Naur vim74.orig/src/testdir/test102.ok vim74/src/testdir/test102.ok
--- vim74.orig/src/testdir/test102.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test102.ok	2014-10-10 14:53:45.478711033 +0000
@@ -0,0 +1,3 @@
+
+Space
+ExclamationMark
diff -Naur vim74.orig/src/testdir/test103.in vim74/src/testdir/test103.in
--- vim74.orig/src/testdir/test103.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test103.in	2014-10-10 14:53:45.478711033 +0000
@@ -0,0 +1,37 @@
+Test for visual mode not being reset causing E315 error.
+STARTTEST
+:so small.vim
+:enew
+:let g:msg="Everything's fine."
+:function! TriggerTheProblem()
+:	" At this point there is no visual selection because :call reset it.
+:	" Let's restore the selection:
+:	normal gv
+:	'<,'>del _
+:	try
+:		exe "normal \<Esc>"
+:	catch /^Vim\%((\a\+)\)\=:E315/
+:		echom 'Snap! E315 error!'
+:		let g:msg='Snap! E315 error!'
+:	endtry
+:endfunction
+:enew
+:setl buftype=nofile
+:call append(line('$'), 'Delete this line.')
+:"
+:"
+:" NOTE: this has to be done by a call to a function because executing :del the
+:"       ex-way will require the colon operator which resets the visual mode thus
+:"       preventing the problem:
+:"
+GV:call TriggerTheProblem()
+:%del _
+:call append(line('$'), g:msg)
+:w! test.out
+:brewind
+ENDTEST
+
+STARTTEST
+:qa!
+ENDTEST
+
diff -Naur vim74.orig/src/testdir/test103.ok vim74/src/testdir/test103.ok
--- vim74.orig/src/testdir/test103.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test103.ok	2014-10-10 14:53:45.482044358 +0000
@@ -0,0 +1,2 @@
+
+Everything's fine.
diff -Naur vim74.orig/src/testdir/test104.in vim74/src/testdir/test104.in
--- vim74.orig/src/testdir/test104.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test104.in	2014-10-10 14:53:45.482044358 +0000
@@ -0,0 +1,30 @@
+Tests for :let.  vim: set ft=vim ts=8 :
+
+STARTTEST
+:so small.vim
+:set runtimepath+=./sautest
+:" Test to not autoload when assigning.  It causes internal error.
+:try
+:  let Test104#numvar = function('tr')
+:  $put ='OK: ' . string(Test104#numvar)
+:catch
+:  $put ='FAIL: ' . v:exception
+:endtry
+:let a = 1
+:let b = 2
+:for letargs in ['a b', '{0 == 1 ? "a" : "b"}', '{0 == 1 ? "a" : "b"} a', 'a {0 == 1 ? "a" : "b"}']
+:  try
+:    redir => messages
+:    execute 'let' letargs
+:    redir END
+:    $put ='OK:'
+:    $put =split(substitute(messages, '\n', '\0  ', 'g'), '\n')
+:  catch
+:    $put ='FAIL: ' . v:exception
+:    redir END
+:  endtry
+:endfor
+:/^Results/,$wq! test.out
+ENDTEST
+
+Results of test104:
diff -Naur vim74.orig/src/testdir/test104.ok vim74/src/testdir/test104.ok
--- vim74.orig/src/testdir/test104.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test104.ok	2014-10-10 14:53:45.482044358 +0000
@@ -0,0 +1,13 @@
+Results of test104:
+OK: function('tr')
+OK:
+  a                     #1
+  b                     #2
+OK:
+  b                     #2
+OK:
+  b                     #2
+  a                     #1
+OK:
+  a                     #1
+  b                     #2
diff -Naur vim74.orig/src/testdir/test105.in vim74/src/testdir/test105.in
--- vim74.orig/src/testdir/test105.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test105.in	2014-10-10 14:53:45.485377683 +0000
@@ -0,0 +1,45 @@
+Test filename modifiers     vim: set ft=vim :
+
+STARTTEST
+:source small.vim
+:%delete _
+:set shell=sh
+:set shellslash
+:let tab="\t"
+:command -nargs=1 Put :let expr=<q-args> | $put =expr.tab.strtrans(string(eval(expr)))
+:let $HOME=fnamemodify('.', ':p:h:h')
+:Put fnamemodify('.',              ':p'      )[-1:]
+:Put fnamemodify('.',              ':p:h'    )[-1:]
+:Put fnamemodify('test.out',       ':p'      )[-1:]
+:Put fnamemodify('test.out',       ':.'      )
+:Put fnamemodify('../testdir/a',   ':.'      )
+:Put fnamemodify('test.out',       ':~'      )
+:Put fnamemodify('../testdir/a',   ':~'      )
+:Put fnamemodify('../testdir/a',   ':t'      )
+:Put fnamemodify('.',              ':p:t'    )
+:Put fnamemodify('test.out',       ':p:t'    )
+:Put fnamemodify('test.out',       ':p:e'    )
+:Put fnamemodify('test.out',       ':p:t:e'  )
+:Put fnamemodify('abc.fb2.tar.gz', ':r'      )
+:Put fnamemodify('abc.fb2.tar.gz', ':r:r'    )
+:Put fnamemodify('abc.fb2.tar.gz', ':r:r:r'  )
+:Put substitute(fnamemodify('abc.fb2.tar.gz', ':p:r:r'), '.*\(testdir/.*\)', '\1', '')
+:Put fnamemodify('abc.fb2.tar.gz', ':e'      )
+:Put fnamemodify('abc.fb2.tar.gz', ':e:e'    )
+:Put fnamemodify('abc.fb2.tar.gz', ':e:e:e'  )
+:Put fnamemodify('abc.fb2.tar.gz', ':e:e:e:e')
+:Put fnamemodify('abc.fb2.tar.gz', ':e:e:r'  )
+:Put fnamemodify('abc def',        ':S'      )
+:Put fnamemodify('abc" "def',      ':S'      )
+:Put fnamemodify('abc"%"def',      ':S'      )
+:Put fnamemodify('abc'' ''def',    ':S'      )
+:Put fnamemodify('abc''%''def',    ':S'      )
+:Put fnamemodify("abc\ndef",       ':S'      )
+:set shell=tcsh
+:Put fnamemodify("abc\ndef",       ':S'      )
+:$put ='vim: ts=8'
+:1 delete _
+:w! test.out
+:qa!
+ENDTEST
+
diff -Naur vim74.orig/src/testdir/test105.ok vim74/src/testdir/test105.ok
--- vim74.orig/src/testdir/test105.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test105.ok	2014-10-10 14:53:45.488711008 +0000
@@ -0,0 +1,29 @@
+fnamemodify('.',              ':p'      )[-1:]	'/'
+fnamemodify('.',              ':p:h'    )[-1:]	'r'
+fnamemodify('test.out',       ':p'      )[-1:]	't'
+fnamemodify('test.out',       ':.'      )	'test.out'
+fnamemodify('../testdir/a',   ':.'      )	'a'
+fnamemodify('test.out',       ':~'      )	'~/testdir/test.out'
+fnamemodify('../testdir/a',   ':~'      )	'~/testdir/a'
+fnamemodify('../testdir/a',   ':t'      )	'a'
+fnamemodify('.',              ':p:t'    )	''
+fnamemodify('test.out',       ':p:t'    )	'test.out'
+fnamemodify('test.out',       ':p:e'    )	'out'
+fnamemodify('test.out',       ':p:t:e'  )	'out'
+fnamemodify('abc.fb2.tar.gz', ':r'      )	'abc.fb2.tar'
+fnamemodify('abc.fb2.tar.gz', ':r:r'    )	'abc.fb2'
+fnamemodify('abc.fb2.tar.gz', ':r:r:r'  )	'abc'
+substitute(fnamemodify('abc.fb2.tar.gz', ':p:r:r'), '.*\(testdir/.*\)', '\1', '')	'testdir/abc.fb2'
+fnamemodify('abc.fb2.tar.gz', ':e'      )	'gz'
+fnamemodify('abc.fb2.tar.gz', ':e:e'    )	'tar.gz'
+fnamemodify('abc.fb2.tar.gz', ':e:e:e'  )	'fb2.tar.gz'
+fnamemodify('abc.fb2.tar.gz', ':e:e:e:e')	'fb2.tar.gz'
+fnamemodify('abc.fb2.tar.gz', ':e:e:r'  )	'tar'
+fnamemodify('abc def',        ':S'      )	'''abc def'''
+fnamemodify('abc" "def',      ':S'      )	'''abc" "def'''
+fnamemodify('abc"%"def',      ':S'      )	'''abc"%"def'''
+fnamemodify('abc'' ''def',    ':S'      )	'''abc''\'''' ''\''''def'''
+fnamemodify('abc''%''def',    ':S'      )	'''abc''\''''%''\''''def'''
+fnamemodify("abc\ndef",       ':S'      )	'''abc^@def'''
+fnamemodify("abc\ndef",       ':S'      )	'''abc\^@def'''
+vim: ts=8
diff -Naur vim74.orig/src/testdir/test106.in vim74/src/testdir/test106.in
--- vim74.orig/src/testdir/test106.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test106.in	2014-10-10 14:53:45.488711008 +0000
@@ -0,0 +1,16 @@
+Tests for errorformat.  vim: set ft=vim ts=8 :
+
+STARTTEST
+:so small.vim
+:if !has('quickfix') | e! test.ok | wq! test.out | endif
+:set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#
+:cgetexpr ['WWWW', 'EEEE', 'CCCC']
+:$put =strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
+:cgetexpr ['WWWW', 'GGGG', 'EEEE', 'CCCC']
+:$put =strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
+:cgetexpr ['WWWW', 'GGGG', 'ZZZZ', 'EEEE', 'CCCC', 'YYYY']
+:$put =strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
+:/^Results/,$wq! test.out
+ENDTEST
+
+Results of test106:
diff -Naur vim74.orig/src/testdir/test106.ok vim74/src/testdir/test106.ok
--- vim74.orig/src/testdir/test106.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test106.ok	2014-10-10 14:53:45.488711008 +0000
@@ -0,0 +1,4 @@
+Results of test106:
+[['W', 1], ['E^@CCCC', 1]]
+[['W', 1], ['E^@CCCC', 1]]
+[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]
diff -Naur vim74.orig/src/testdir/test107.in vim74/src/testdir/test107.in
--- vim74.orig/src/testdir/test107.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test107.in	2014-10-10 14:53:45.492044333 +0000
@@ -0,0 +1,38 @@
+Tests for adjusting window and contents     vim: set ft=vim :
+
+STARTTEST
+:so small.vim
+:new
+:call setline(1, range(1,256))
+:let r=[]
+:func! GetScreenStr(row)
+:   let str = ""
+:   for c in range(1,3)
+:       let str .= nr2char(screenchar(a:row, c))
+:   endfor
+:   return str
+:endfunc
+:
+:exe ":norm! \<C-W>t\<C-W>=1Gzt\<C-W>w\<C-W>+"
+:let s3=GetScreenStr(1)
+:wincmd p
+:call add(r, [line("w0"), s3])
+:
+:exe ":norm! \<C-W>t\<C-W>=50Gzt\<C-W>w\<C-W>+"
+:let s3=GetScreenStr(1)
+:wincmd p
+:call add(r, [line("w0"), s3])
+:
+:exe ":norm! \<C-W>t\<C-W>=59Gzt\<C-W>w\<C-W>+"
+:let s3=GetScreenStr(1)
+::wincmd p
+:call add(r, [line("w0"), s3])
+:
+:bwipeout!
+:$put=r
+:call garbagecollect(1)
+:"
+:/^start:/,$wq! test.out
+ENDTEST
+
+start:
diff -Naur vim74.orig/src/testdir/test107.ok vim74/src/testdir/test107.ok
--- vim74.orig/src/testdir/test107.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test107.ok	2014-10-10 14:53:45.492044333 +0000
@@ -0,0 +1,4 @@
+start:
+[1, '1  ']
+[50, '50 ']
+[59, '59 ']
diff -Naur vim74.orig/src/testdir/test11.in vim74/src/testdir/test11.in
--- vim74.orig/src/testdir/test11.in	2010-08-08 11:16:36.000000000 +0000
+++ vim74/src/testdir/test11.in	2014-10-10 14:53:45.495377657 +0000
@@ -46,13 +46,13 @@
 :w>>test.out                    " Append it to the output file
 :set shelltemp                  " need temp files here
 :au FilterReadPre   *.out  call rename(expand("<afile>"), expand("<afile>") . ".t")
-:au FilterReadPre   *.out  exe '!sed s/e/E/ ' . shellescape(expand("<afile>")) . ".t >" . shellescape(expand("<afile>"))
-:au FilterReadPre   *.out  exe '!rm ' . shellescape(expand("<afile>")) . '.t'
+:au FilterReadPre   *.out  exe 'silent !sed s/e/E/ ' . shellescape(expand("<afile>")) . ".t >" . shellescape(expand("<afile>"))
+:au FilterReadPre   *.out  exe 'silent !rm ' . shellescape(expand("<afile>")) . '.t'
 :au FilterReadPost  *.out  '[,']s/x/X/g
 :e! test.out                    " Edit the output file
 :23,$!cat
 :23,$s/\r$//                 " remove CR for when sed adds them
-:au! FileReadPre    *.gz   exe '!gzip -d ' . shellescape(expand("<afile>"))
+:au! FileReadPre    *.gz   exe 'silent !gzip -d ' . shellescape(expand("<afile>"))
 :au  FileReadPre    *.gz   call rename(expand("<afile>:r"), expand("<afile>"))
 :au! FileReadPost   *.gz   '[,']s/l/L/
 :$r Xtestfile.gz             " Read compressed file
diff -Naur vim74.orig/src/testdir/test14.in vim74/src/testdir/test14.in
--- vim74.orig/src/testdir/test14.in	2013-04-03 18:59:14.000000000 +0000
+++ vim74/src/testdir/test14.in	2014-10-10 14:53:45.505377632 +0000
@@ -47,7 +47,19 @@
 /two
 :call search('.', 'c')
 :call append(line('$'), getline('.')[col('.') - 1:])
-:/^search()/,$w >>test.out
+:"
+/^substitute
+:s/foo/bar/
+:$put =@/
+/^substitute
+:keeppatterns s/asdf/xyz/
+:$put =@/
+/^substitute
+Y:$put =@0
+/bar /e
+:$put =@0
+-:keeppatterns /xyz
+0dn:/^search()/,$w >>test.out
 :qa!
 ENDTEST
 
@@ -81,6 +93,7 @@
 
 foobar
 
+substitute foo asdf
 
 one two
 search()
diff -Naur vim74.orig/src/testdir/test14.ok vim74/src/testdir/test14.ok
--- vim74.orig/src/testdir/test14.ok	2013-04-03 18:59:14.000000000 +0000
+++ vim74/src/testdir/test14.ok	2014-10-10 14:53:45.505377632 +0000
@@ -20,3 +20,7 @@
 1
 1
 two
+foo
+^substitute
+substitute bar xyz
+xyz
diff -Naur vim74.orig/src/testdir/test20.in vim74/src/testdir/test20.in
--- vim74.orig/src/testdir/test20.in	2010-05-15 11:04:10.000000000 +0000
+++ vim74/src/testdir/test20.in	2014-10-10 14:53:45.525377582 +0000
@@ -9,11 +9,17 @@
 @auY:quit!
 GP
 /start here$
-jjlld
-:/here$/,$-1w! test.out
+"by$jjlld
+/456$
+jj"bP
+:/56$/,$-1w! test.out
 :qa!
 ENDTEST
 
+123456
+234567
+345678
+
 test text test tex start here
 		some text
 		test text
diff -Naur vim74.orig/src/testdir/test20.ok vim74/src/testdir/test20.ok
--- vim74.orig/src/testdir/test20.ok	2010-05-15 11:04:10.000000000 +0000
+++ vim74/src/testdir/test20.ok	2014-10-10 14:53:45.528710907 +0000
@@ -1,3 +1,7 @@
+123start here56
+234start here67
+345start here78
+
 test text test tex rt here
 		somext
 		tesext
diff -Naur vim74.orig/src/testdir/test29.in vim74/src/testdir/test29.in
--- vim74.orig/src/testdir/test29.in	2012-06-13 11:48:26.000000000 +0000
+++ vim74/src/testdir/test29.in	2014-10-10 14:53:45.552044182 +0000
@@ -102,6 +102,34 @@
 }
 
 STARTTEST
+:" Test with backspace set to the non-compatible setting
+/^\d\+ this
+:set cp bs=2
+Avim1
+Avim2u
+:set cpo-=<
+:inoremap <c-u> <left><c-u>
+Avim3
+:iunmap <c-u>
+Avim4
+:" Test with backspace set to the compatible setting
+:set bs=
+A vim5A
+A vim6Azweiu
+:inoremap <c-u> <left><c-u>
+A vim7
+:set cp
+ENDTEST
+1 this shouldn't be deleted
+2 this shouldn't be deleted
+3 this shouldn't be deleted
+4 this should be deleted
+5 this shouldn't be deleted
+6 this shouldn't be deleted
+7 this shouldn't be deleted
+8 this shouldn't be deleted (not touched yet)
+
+STARTTEST
 /^{/+1
 :set comments=sO:*\ -,mO:*\ \ ,exO:*/
 :set comments+=s1:/*,mb:*,ex:*/,://
diff -Naur vim74.orig/src/testdir/test29.ok vim74/src/testdir/test29.ok
--- vim74.orig/src/testdir/test29.ok	2012-06-13 11:48:26.000000000 +0000
+++ vim74/src/testdir/test29.ok	2014-10-10 14:53:45.552044182 +0000
@@ -62,6 +62,15 @@
     action();
 }
 
+1 this shouldn't be deleted
+2 this shouldn't be deleted
+3 this shouldn't be deleted
+4 this should be deleted3
+
+6 this shouldn't be deleted vim5
+7 this shouldn't be deleted vim6
+8 this shouldn't be deleted (not touched yet) vim7
+
 
 {
 /* Make sure the previous comment leader is not removed.  */
diff -Naur vim74.orig/src/testdir/test3.in vim74/src/testdir/test3.in
--- vim74.orig/src/testdir/test3.in	2013-03-07 11:39:35.000000000 +0000
+++ vim74/src/testdir/test3.in	2014-10-10 14:53:45.555377507 +0000
@@ -464,6 +464,14 @@
 	asdfasdf
 }
 
+{
+for ( int i = 0;
+	i < 10; i++ )
+{
+}
+	i = 0;
+}
+
 class bob
 {
 	int foo() {return 1;}
@@ -1432,7 +1440,7 @@
 
 STARTTEST
 :set cino=(0,ts
-2kdd=][
+2kdd2j=][
 ENDTEST
 
 void func(int a
@@ -1446,7 +1454,7 @@
 
 STARTTEST
 :set cino=(0
-2kdd=][
+2kdd2j=][
 ENDTEST
 
 void
@@ -1461,7 +1469,7 @@
 
 STARTTEST
 :set cino&
-2kdd=7][
+2kdd2j=7][
 ENDTEST
 
 void func(void)
@@ -1538,7 +1546,7 @@
 STARTTEST
 :set cino&
 :set cino+=l1
-2kdd=][
+2kdd2j=][
 ENDTEST
 
 void func(void)
@@ -1567,7 +1575,7 @@
 
 STARTTEST
 :set cino&
-2kdd=][
+2kdd2j=][
 ENDTEST
 
 void func(void)
@@ -1592,7 +1600,7 @@
 
 STARTTEST
 :set cino&
-2kdd=][
+2kdd2j=][
 ENDTEST
 
 void func(void)
@@ -1919,10 +1927,10 @@
 
 JSSTART
 var foo = [
-1,  // indent 8 more
+1,
 2,
 3
-];  // indent 8 less
+];
 JSEND
 
 STARTTEST
@@ -1937,7 +1945,7 @@
 1,
 2,
 3
-];  // indent 16 less
+];
 }
 JSEND
 
@@ -1950,6 +1958,12 @@
 JSSTART
 (function($){
 
+if (cond &&
+cond) {
+stmt;
+}
+window.something.left =
+(width - 50 + offset) + "px";
 var class_name='myclass';
 
 function private_method() {
@@ -1965,15 +1979,15 @@
 
 $(this).data(class_name+'_public',$.extend({},{
 foo: 'bar',
-bar: 2,  // indent 8 more
-foobar: [  // indent 8 more
-1,  // indent 8 more
-2,  // indent 16 more
-3   // indent 16 more
+bar: 2,
+foobar: [
+1,
+2,
+3
 ],
-callback: function(){  // indent 8 more
-return true;  // indent 8 more
-}  // indent 8 more
+callback: function(){
+return true;
+}
 }, options||{}));
 }
 
@@ -2014,9 +2028,9 @@
 foo: 'bar',
 bar: 2,
 foobar: [
-1,  // indent 8 more
-2,  // indent 8 more
-3   // indent 8 more
+1,
+2,
+3
 ],
 callback: function(){
 return true;
@@ -2036,15 +2050,15 @@
 function init(options) {
 $(this).data(class_name+'_public',$.extend({},{
 foo: 'bar',
-bar: 2,  // indent 8 more
-foobar: [  // indent 8 more
-1,  // indent 8 more
-2,  // indent 16 more
-3  // indent 16 more
+bar: 2,
+foobar: [
+1,
+2,
+3
 ],
-callback: function(){  // indent 8 more
-return true;  // indent 8 more
-}  // indent 8 more
+callback: function(){
+return true;
+}
 }, options||{}));
 }
 })(jQuery);
diff -Naur vim74.orig/src/testdir/test3.ok vim74/src/testdir/test3.ok
--- vim74.orig/src/testdir/test3.ok	2013-03-07 11:40:03.000000000 +0000
+++ vim74/src/testdir/test3.ok	2014-10-10 14:53:45.555377507 +0000
@@ -452,6 +452,14 @@
 	asdfasdf
 }
 
+{
+	for ( int i = 0;
+			i < 10; i++ )
+	{
+	}
+	i = 0;
+}
+
 class bob
 {
 	int foo() {return 1;}
@@ -1707,10 +1715,10 @@
 
 JSSTART
 var foo = [
-1,  // indent 8 more
+	1,
 	2,
 	3
-	];  // indent 8 less
+];
 JSEND
 
 
@@ -1720,7 +1728,7 @@
 		1,
 		2,
 		3
-			];  // indent 16 less
+	];
 }
 JSEND
 
@@ -1728,6 +1736,12 @@
 JSSTART
 (function($){
 
+	if (cond &&
+			cond) {
+		stmt;
+	}
+	window.something.left =
+		(width - 50 + offset) + "px";
 	var class_name='myclass';
 
 	function private_method() {
@@ -1743,15 +1757,15 @@
 
 		$(this).data(class_name+'_public',$.extend({},{
 			foo: 'bar',
-		bar: 2,  // indent 8 more
-		foobar: [  // indent 8 more
-			1,  // indent 8 more
-		2,  // indent 16 more
-		3   // indent 16 more
+			bar: 2,
+			foobar: [
+				1,
+				2,
+				3
 			],
-		callback: function(){  // indent 8 more
-			return true;  // indent 8 more
-		}  // indent 8 more
+			callback: function(){
+				return true;
+			}
 		}, options||{}));
 	}
 
@@ -1787,9 +1801,9 @@
 		foo: 'bar',
 		bar: 2,
 		foobar: [
-		1,  // indent 8 more
-		2,  // indent 8 more
-		3   // indent 8 more
+			1,
+			2,
+			3
 		],
 		callback: function(){
 			return true;
@@ -1804,15 +1818,15 @@
 	function init(options) {
 		$(this).data(class_name+'_public',$.extend({},{
 			foo: 'bar',
-		bar: 2,  // indent 8 more
-		foobar: [  // indent 8 more
-			1,  // indent 8 more
-		2,  // indent 16 more
-		3  // indent 16 more
+			bar: 2,
+			foobar: [
+				1,
+				2,
+				3
 			],
-		callback: function(){  // indent 8 more
-			return true;  // indent 8 more
-		}  // indent 8 more
+			callback: function(){
+				return true;
+			}
 		}, options||{}));
 	}
 })(jQuery);
diff -Naur vim74.orig/src/testdir/test32.in vim74/src/testdir/test32.in
--- vim74.orig/src/testdir/test32.in	2010-05-15 11:04:10.000000000 +0000
+++ vim74/src/testdir/test32.in	2014-10-10 14:53:45.562044157 +0000
@@ -36,6 +36,9 @@
 :w Xtest11.one
 :w Xtest11.two
 OIXA
+:" use CTRL-X CTRL-F to complete Xtest11.one, remove it and then use
+:" CTRL-X CTRL-F again to verify this doesn't cause trouble.
+OXddk
 :se cpt=w
 OST
 :se cpt=u nohid
diff -Naur vim74.orig/src/testdir/test34.in vim74/src/testdir/test34.in
--- vim74.orig/src/testdir/test34.in	2012-07-16 14:51:29.000000000 +0000
+++ vim74/src/testdir/test34.in	2014-10-10 14:53:45.568710807 +0000
@@ -1,6 +1,7 @@
 Test for user functions.
 Also test an <expr> mapping calling a function.
 Also test that a builtin function cannot be replaced.
+Also test for regression when calling arbitrary expression.
 
 STARTTEST
 :so small.vim
@@ -62,7 +63,17 @@
 [(one again:call append(line('$'), max([1, 2, 3]))
 :call extend(g:, {'max': function('min')})
 :call append(line('$'), max([1, 2, 3]))
-:$-7,$w! test.out
+:try
+:    " Regression: the first line below used to throw ?E110: Missing ')'?
+:    " Second is here just to prove that this line is correct when not skipping
+:    " rhs of &&.
+:    $put =(0&&(function('tr'))(1, 2, 3))
+:    $put =(1&&(function('tr'))(1, 2, 3))
+:catch
+:    $put ='!!! Unexpected exception:'
+:    $put =v:exception
+:endtry
+:$-9,$w! test.out
 :delfunc Table
 :delfunc Compute
 :delfunc Expr1
diff -Naur vim74.orig/src/testdir/test34.ok vim74/src/testdir/test34.ok
--- vim74.orig/src/testdir/test34.ok	2012-07-16 14:43:15.000000000 +0000
+++ vim74/src/testdir/test34.ok	2014-10-10 14:53:45.572044132 +0000
@@ -6,3 +6,5 @@
 1. one again
 3
 3
+0
+1
diff -Naur vim74.orig/src/testdir/test37.ok vim74/src/testdir/test37.ok
--- vim74.orig/src/testdir/test37.ok	2010-05-15 11:04:10.000000000 +0000
+++ vim74/src/testdir/test37.ok	2014-10-10 14:53:45.578710781 +0000
@@ -27,7 +27,7 @@
 
 . line 16 ZYXWVUTSRQPONMLKJIHGREDCBA9876543210 16
 :set scrollbind
-zt:
-. line 15 ZYXWVUTSRQPONMLKJIHGREDCBA9876543210 15
 :set scrollbind
-. line 11 ZYXWVUTSRQPONMLKJIHGREDCBA9876543210 11
+. line 16 ZYXWVUTSRQPONMLKJIHGREDCBA9876543210 16
+j:
+. line 12 ZYXWVUTSRQPONMLKJIHGREDCBA9876543210 12
diff -Naur vim74.orig/src/testdir/test39.in vim74/src/testdir/test39.in
--- vim74.orig/src/testdir/test39.in	2013-03-07 17:30:38.000000000 +0000
+++ vim74/src/testdir/test39.in	2014-10-10 14:53:45.582044106 +0000
@@ -19,6 +19,31 @@
 :" Test block-change
 G$khhhhhkkcmno
 :$-4,$w! test.out
+:" Test block-insert using cursor keys for movement
+/^aaaa/
+:exe ":norm! l\<C-V>jjjlllI\<Right>\<Right>  \<Esc>"
+:/^aa/,/^$/w >> test.out
+/xaaa$/
+:exe ":norm! \<C-V>jjjI<>\<Left>p\<Esc>"
+:/xaaa$/,/^$/w >> test.out
+:" Test for Visual block was created with the last <C-v>$
+/^A23$/
+:exe ":norm! l\<C-V>j$Aab\<Esc>"
+:.,/^$/w >> test.out
+:" Test for Visual block was created with the middle <C-v>$ (1)
+/^B23$/
+:exe ":norm! l\<C-V>j$hAab\<Esc>"
+:.,/^$/w >> test.out
+:" Test for Visual block was created with the middle <C-v>$ (2)
+/^C23$/
+:exe ":norm! l\<C-V>j$hhAab\<Esc>"
+:.,/^$/w >> test.out
+:" Test for Visual block insert when virtualedit=all
+:set ve=all
+:/\t\tline
+:exe ":norm! 07l\<C-V>jjIx\<Esc>"
+:set ve=
+:.,/^$/w >> test.out
 :" gUe must uppercase a whole word, also when  changes to SS
 Gothe youtueuu endYpk0wgUe
 :" gUfx must uppercase until x, inclusive.
@@ -32,10 +57,43 @@
 doh dutVkUj
 :" Uppercase part of two lines
 ddppi333k0i222fyllvjfuUk
+:" visual replace using Enter or NL
+G3o1234567892k05l2jrG3o987652k02l2jr
+G3o1234567892k05l2jr
+G3o987652k02l2jr
+:"
+:" Test cursor position. When ve=block and Visual block mode and $gj
+:set ve=block
+:exe ":norm! 2k\<C-V>$gj\<Esc>"
+:let cpos=getpos("'>")
+:$put ='col:'.cpos[2].' off:'.cpos[3]
 :/^the/,$w >> test.out
 :qa!
 ENDTEST
 
+		line1
+		line2
+		line3
+
+aaaaaa
+bbbbbb
+cccccc
+dddddd
+
+xaaa
+bbbb
+cccc
+dddd
+
+A23
+4567
+
+B23
+4567
+
+C23
+4567
+
 abcdefghijklm
 abcdefghijklm
 abcdefghijklm
diff -Naur vim74.orig/src/testdir/test39.ok vim74/src/testdir/test39.ok
--- vim74.orig/src/testdir/test39.ok	2013-03-07 17:28:51.000000000 +0000
+++ vim74/src/testdir/test39.ok	2014-10-10 14:53:45.585377431 +0000
@@ -3,6 +3,29 @@
 axyzqqqqef mno        ghijklm
 axyzqqqqefgmnoklm
 abcdqqqqijklm
+aaa  aaa
+bbb  bbb
+ccc  ccc
+ddd  ddd
+
+<p>xaaa
+<p>bbbb
+<p>cccc
+<p>dddd
+
+A23ab
+4567ab
+
+B23 ab
+4567ab
+
+C23ab
+456ab7
+
+       x 	line1
+       x 	line2
+       x 	line3
+
 the YOUTUSSEUU end
 - yOUSSTUSSEXu -
 THE YOUTUSSEUU END
@@ -11,3 +34,22 @@
 DOH DUT
 222the yoUTUSSEUU END
 333THE YOUTUeuu end
+12345
+789
+12345
+789
+12345
+789
+9865
+9865
+9865
+12345
+789
+12345
+789
+12345
+789
+98 65
+98 65
+98 65
+col:4 off:0
diff -Naur vim74.orig/src/testdir/test44.in vim74/src/testdir/test44.in
--- vim74.orig/src/testdir/test44.in	2013-05-26 12:16:31.000000000 +0000
+++ vim74/src/testdir/test44.in	2014-10-10 14:53:45.598710731 +0000
@@ -1,9 +1,11 @@
 Tests for regexp with multi-byte encoding and various magic settings.
 Test matchstr() with a count and multi-byte chars.
+See test99 for exactly the same test with re=2.
 
 STARTTEST
 :so mbyte.vim
 :set nocompatible encoding=utf-8 termencoding=latin1 viminfo+=nviminfo
+:set re=1
 /^1
 /a*b\{2}c\+/e
 x/\Md\*e\{2}f\+/e
diff -Naur vim74.orig/src/testdir/test49.in vim74/src/testdir/test49.in
--- vim74.orig/src/testdir/test49.in	2012-11-15 21:29:55.000000000 +0000
+++ vim74/src/testdir/test49.in	2014-10-10 14:53:45.615377356 +0000
@@ -1,7 +1,7 @@
 This is a test of the script language.
 
 If after adding a new test, the test output doesn't appear properly in
-test49.failed, try to add one ore more "G"s at the line ending in "test.out"
+test49.failed, try to add one or more "G"s at the line ending in "test.out"
 
 STARTTEST
 :so small.vim
diff -Naur vim74.orig/src/testdir/test53.in vim74/src/testdir/test53.in
--- vim74.orig/src/testdir/test53.in	2013-06-30 12:31:56.000000000 +0000
+++ vim74/src/testdir/test53.in	2014-10-10 14:53:45.635377306 +0000
@@ -4,6 +4,8 @@
 
 Also test match() and matchstr()
 
+Also test the gn command and repeating it.
+
 STARTTEST
 :so small.vim
 /^start:/
@@ -28,6 +30,28 @@
 :put =matchstr(\"abcd\", \".\", 0, -1) " a
 :put =match(\"abcd\", \".\", 0, 5) " -1
 :put =match(\"abcd\", \".\", 0, -1) " 0
+:put =match('abc', '.', 0, 1) " 0
+:put =match('abc', '.', 0, 2) " 1
+:put =match('abc', '.', 0, 3) " 2
+:put =match('abc', '.', 0, 4) " -1
+:put =match('abc', '.', 1, 1) " 1
+:put =match('abc', '.', 2, 1) " 2
+:put =match('abc', '.', 3, 1) " -1
+:put =match('abc', '$', 0, 1) " 3
+:put =match('abc', '$', 0, 2) " -1
+:put =match('abc', '$', 1, 1) " 3
+:put =match('abc', '$', 2, 1) " 3
+:put =match('abc', '$', 3, 1) " 3
+:put =match('abc', '$', 4, 1) " -1
+:put =match('abc', '\zs', 0, 1) " 0
+:put =match('abc', '\zs', 0, 2) " 1
+:put =match('abc', '\zs', 0, 3) " 2
+:put =match('abc', '\zs', 0, 4) " 3
+:put =match('abc', '\zs', 0, 5) " -1
+:put =match('abc', '\zs', 1, 1) " 1
+:put =match('abc', '\zs', 2, 1) " 2
+:put =match('abc', '\zs', 3, 1) " 3
+:put =match('abc', '\zs', 4, 1) " -1
 /^foobar
 gncsearchmatch/one\_s*two\_s
 :1
@@ -46,6 +70,15 @@
 :set selection=exclusive
 $cgNmongoose/i
 cgnj
+:" Make sure there is no other match y uppercase.
+/x59
+gggnd
+:" test repeating dgn
+/^Johnny
+ggdgn.
+:" test repeating gUgn
+/^Depp
+gggUgn.
 :/^start:/,/^end:/wq! test.out
 ENDTEST
 
@@ -75,4 +108,16 @@
 uniquepattern uniquepattern
 my very excellent mother just served us nachos
 for (i=0; i<=10; i++)
+Y
+text
+Y
+--1
+Johnny
+--2
+Johnny
+--3
+Depp
+--4
+Depp
+--5
 end:
diff -Naur vim74.orig/src/testdir/test53.ok vim74/src/testdir/test53.ok
--- vim74.orig/src/testdir/test53.ok	2013-06-30 12:31:56.000000000 +0000
+++ vim74/src/testdir/test53.ok	2014-10-10 14:53:45.638710631 +0000
@@ -18,6 +18,28 @@
 a
 -1
 0
+0
+1
+2
+-1
+1
+2
+-1
+3
+-1
+3
+3
+3
+-1
+0
+1
+2
+3
+-1
+1
+2
+3
+-1
 SEARCH:
 searchmatch
 abcdx |  | abcdx
@@ -27,4 +49,16 @@
  uniquepattern
 my very excellent mongoose just served us nachos
 for (j=0; i<=10; i++)
+
+text
+Y
+--1
+
+--2
+
+--3
+DEPP
+--4
+DEPP
+--5
 end:
diff -Naur vim74.orig/src/testdir/test55.in vim74/src/testdir/test55.in
--- vim74.orig/src/testdir/test55.in	2013-03-07 13:33:12.000000000 +0000
+++ vim74/src/testdir/test55.in	2014-10-10 14:53:45.642043956 +0000
@@ -282,6 +282,28 @@
 :    $put =ps
 :  endfor
 :endfor
+:unlet l
+:let l = [1, 2, 3, 4]
+:lockvar! l
+:$put =string(l)
+:unlockvar l[1]
+:unlet l[0:1]
+:$put =string(l)
+:unlet l[1:2]
+:$put =string(l)
+:unlockvar l[1]
+:let l[0:1] = [0, 1]
+:$put =string(l)
+:let l[1:2] = [0, 1]
+:$put =string(l)
+:unlet l
+:" :lockvar/islocked() triggering script autoloading
+:set rtp+=./sautest
+:lockvar g:footest#x
+:unlockvar g:footest#x
+:$put ='locked g:footest#x:'.islocked('g:footest#x')
+:$put ='exists g:footest#x:'.exists('g:footest#x')
+:$put ='g:footest#x: '.g:footest#x
 :"
 :" a:000 function argument
 :" first the tests that should fail
@@ -316,13 +338,21 @@
 :  $put ='caught ' . v:exception
 :endtry
 :"
-:" reverse() and sort()
-:let l = ['-0', 'A11', 2, 'xaaa', 4, 'foo', 'foo6', [0, 1, 2], 'x8']
+:" reverse(), sort(), uniq()
+:let l = ['-0', 'A11', 2, 2, 'xaaa', 4, 'foo', 'foo6', 'foo', [0, 1, 2], 'x8', [0, 1, 2], 1.5]
+:$put =string(uniq(copy(l)))
 :$put =string(reverse(l))
 :$put =string(reverse(reverse(l)))
 :$put =string(sort(l))
 :$put =string(reverse(sort(l)))
 :$put =string(sort(reverse(sort(l))))
+:$put =string(uniq(sort(l)))
+:let l=[7, 9, 'one', 18, 12, 22, 'two', 10.0e-16, -1, 'three', 0xff, 0.22, 'four']
+:$put =string(sort(copy(l), 'n'))
+:let l=[7, 9, 18, 12, 22, 10.0e-16, -1, 0xff, 0, -0, 0.22, 'bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', {}, []]
+:$put =string(sort(copy(l), 1))
+:$put =string(sort(copy(l), 'i'))
+:$put =string(sort(copy(l)))
 :"
 :" splitting a string to a List
 :$put =string(split('  aa  bb '))
diff -Naur vim74.orig/src/testdir/test55.ok vim74/src/testdir/test55.ok
--- vim74.orig/src/testdir/test55.ok	2012-08-29 14:51:15.000000000 +0000
+++ vim74/src/testdir/test55.ok	2014-10-10 14:53:45.642043956 +0000
@@ -86,16 +86,30 @@
 FFpFFpp
 0000-000
 ppppppp
+[1, 2, 3, 4]
+[1, 2, 3, 4]
+[1, 2, 3, 4]
+[1, 2, 3, 4]
+[1, 2, 3, 4]
+locked g:footest#x:-1
+exists g:footest#x:0
+g:footest#x: 1
 caught a:000
 caught a:000[0]
 caught a:000[2]
 caught a:000[3]
 [1, 2, [3, 9, 5, 6], {'a': 12, '5': 8}]
-['x8', [0, 1, 2], 'foo6', 'foo', 4, 'xaaa', 2, 'A11', '-0']
-['x8', [0, 1, 2], 'foo6', 'foo', 4, 'xaaa', 2, 'A11', '-0']
-['-0', 'A11', 'foo', 'foo6', 'x8', 'xaaa', 2, 4, [0, 1, 2]]
-[[0, 1, 2], 4, 2, 'xaaa', 'x8', 'foo6', 'foo', 'A11', '-0']
-['-0', 'A11', 'foo', 'foo6', 'x8', 'xaaa', 2, 4, [0, 1, 2]]
+['-0', 'A11', 2, 'xaaa', 4, 'foo', 'foo6', 'foo', [0, 1, 2], 'x8', [0, 1, 2], 1.5]
+[1.5, [0, 1, 2], 'x8', [0, 1, 2], 'foo', 'foo6', 'foo', 4, 'xaaa', 2, 2, 'A11', '-0']
+[1.5, [0, 1, 2], 'x8', [0, 1, 2], 'foo', 'foo6', 'foo', 4, 'xaaa', 2, 2, 'A11', '-0']
+['-0', 'A11', 'foo', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 2, 4, [0, 1, 2], [0, 1, 2]]
+[[0, 1, 2], [0, 1, 2], 4, 2, 2, 1.5, 'xaaa', 'x8', 'foo6', 'foo', 'foo', 'A11', '-0']
+['-0', 'A11', 'foo', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 2, 4, [0, 1, 2], [0, 1, 2]]
+['-0', 'A11', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 4, [0, 1, 2]]
+[-1, 'one', 'two', 'three', 'four', 1.0e-15, 0.22, 7, 9, 12, 18, 22, 255]
+['bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}]
+['bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}]
+['BAR', 'Bar', 'FOO', 'FOOBAR', 'Foo', 'bar', 'foo', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}]
 ['aa', 'bb']
 ['aa', 'bb']
 ['', 'aa', 'bb', '']
diff -Naur vim74.orig/src/testdir/test60.in vim74/src/testdir/test60.in
--- vim74.orig/src/testdir/test60.in	2010-05-15 11:04:10.000000000 +0000
+++ vim74/src/testdir/test60.in	2014-10-10 14:53:45.658710580 +0000
@@ -1,4 +1,4 @@
-Tests for the exists() function.  vim: set ft=vim :
+Tests for the exists() and has() functions.  vim: set ft=vim ts=8 sw=2 :
 
 STARTTEST
 :so small.vim
@@ -11,8 +11,10 @@
 endfunction
 :function! TestExists()
     augroup myagroup
-	autocmd! BufEnter *.my echo 'myfile edited'
+	autocmd! BufEnter       *.my     echo "myfile edited"
+	autocmd! FuncUndefined  UndefFun exec "fu UndefFun()\nendfu"
     augroup END
+    set rtp+=./sautest
 
     let test_cases = []
 
@@ -95,10 +97,15 @@
     " Non-existing user defined function
     let test_cases += [['*MyxyzFunc', 0]]
 
+    " Function that may be created by FuncUndefined event
+    let test_cases += [['*UndefFun', 0]]
+    " Function that may be created by script autoloading
+    let test_cases += [['*footest#F', 0]]
+
     redir! > test.out
 
     for [test_case, result] in test_cases
-      	echo test_case . ": " . result
+        echo test_case . ": " . result
         call RunTest(test_case, result)
     endfor
 
@@ -207,6 +214,14 @@
 	echo "FAILED"
     endif
 
+    " Non-existing autoload variable that may be autoloaded
+    echo 'footest#x: 0'
+    if !exists('footest#x')
+	echo "OK"
+    else
+	echo "FAILED"
+    endif
+
     " Valid local list
     let local_list = ["blue", "orange"]
     echo 'local_list: 1'
@@ -566,9 +581,23 @@
 
     call TestFuncArg("arg1", "arg2")
 
+    echo ' g:footest#x =' g:footest#x
+    echo '   footest#F()' footest#F()
+    echo 'UndefFun()' UndefFun()
+
     redir END
 endfunction
 :call TestExists()
+:"
+:function TestHas()
+  redir >> test.out
+  for pl in ['6.9.999', '7.1.999', '7.4.123', '9.1.0', '9.9.1']
+    echo 'has patch ' . pl . ': ' . has('patch-' . pl)
+  endfor
+  redir END
+endfunc
+:call TestHas()
+:"
 :delfunc TestExists
 :delfunc RunTest
 :delfunc TestFuncArg
@@ -576,5 +605,6 @@
 :set ff=unix
 :w
 :qa!
+:while getchar(1) | call getchar() | endwhile
 ENDTEST
 
diff -Naur vim74.orig/src/testdir/test60.ok vim74/src/testdir/test60.ok
--- vim74.orig/src/testdir/test60.ok	2010-05-15 11:04:10.000000000 +0000
+++ vim74/src/testdir/test60.ok	2014-10-10 14:53:45.662043905 +0000
@@ -71,6 +71,10 @@
 OK
 *MyxyzFunc: 0
 OK
+*UndefFun: 0
+OK
+*footest#F: 0
+OK
 :edit: 2
 OK
 :edit/a: 0
@@ -95,6 +99,8 @@
 OK
 local_var: 0
 OK
+footest#x: 0
+OK
 local_list: 1
 OK
 local_list[1]: 1
@@ -195,3 +201,11 @@
 OK
 a:2: 0
 OK
+ g:footest#x = 1
+   footest#F() 0
+UndefFun() 0
+has patch 6.9.999: 1
+has patch 7.1.999: 1
+has patch 7.4.123: 1
+has patch 9.1.0: 0
+has patch 9.9.1: 0
diff -Naur vim74.orig/src/testdir/test62.in vim74/src/testdir/test62.in
--- vim74.orig/src/testdir/test62.in	2013-07-14 11:37:12.000000000 +0000
+++ vim74/src/testdir/test62.in	2014-10-10 14:53:45.665377230 +0000
@@ -2,6 +2,7 @@
 
 STARTTEST
 :so small.vim
+:lang C
 :" Simple test for opening and closing a tab page
 :tabnew
 :let nr = tabpagenr()
diff -Naur vim74.orig/src/testdir/test63.in vim74/src/testdir/test63.in
--- vim74.orig/src/testdir/test63.in	2010-05-15 11:04:10.000000000 +0000
+++ vim74/src/testdir/test63.in	2014-10-10 14:53:45.668710555 +0000
@@ -1,14 +1,15 @@
 Test for ":match", ":2match", ":3match", "clearmatches()", "getmatches()",
-"matchadd()", "matcharg()", "matchdelete()", and "setmatches()".
+"matchadd()", "matchaddpos", "matcharg()", "matchdelete()", and "setmatches()".
 
 STARTTEST
 :so small.vim
+:set encoding=utf8
 :" --- Check that "matcharg()" returns the correct group and pattern if a match
 :" --- is defined.
 :let @r = "*** Test 1: "
-:highlight MyGroup1 ctermbg=red
-:highlight MyGroup2 ctermbg=green
-:highlight MyGroup3 ctermbg=blue
+:highlight MyGroup1 ctermbg=red guibg=red
+:highlight MyGroup2 ctermbg=green guibg=green
+:highlight MyGroup3 ctermbg=blue guibg=blue
 :match MyGroup1 /TODO/
 :2match MyGroup2 /FIXME/
 :3match MyGroup3 /XXX/
@@ -147,9 +148,46 @@
 :unlet rf1
 :unlet rf2
 :unlet rf3
-:highlight clear MyGroup1
-:highlight clear MyGroup2
-:highlight clear MyGroup3
+:" --- Check that "matchaddpos()" positions matches correctly
+:let @r .= "*** Test 11:\n"
+:set nolazyredraw
+:call setline(1, 'abcdefghijklmnopq')
+:call matchaddpos("MyGroup1", [[1, 5], [1, 8, 3]], 10, 3)
+:1
+:redraw!
+:let v1 = screenattr(1, 1)
+:let v5 = screenattr(1, 5)
+:let v6 = screenattr(1, 6)
+:let v8 = screenattr(1, 8)
+:let v10 = screenattr(1, 10)
+:let v11 = screenattr(1, 11)
+:let @r .= string(getmatches())."\n"
+:if v1 != v5 && v6 == v1 && v8 == v5 && v10 == v5 && v11 == v1
+:  let @r .= "OK\n"
+:else
+:  let @r .= "FAILED: " . v5 . "/" . v6 . "/" . v8 . "/" . v10 . "/" . v11 . "\n"
+:endif
+:call clearmatches()
+:"
+:call setline(1, 'abcdabcdef')
+:call matchaddpos("MyGroup1", [[1, 4, 2], [1, 9, 2]])
+:1
+:redraw!
+:let v1 = screenattr(1, 1)
+:let v4 = screenattr(1, 4)
+:let v5 = screenattr(1, 5)
+:let v6 = screenattr(1, 6)
+:let v7 = screenattr(1, 7)
+:let v8 = screenattr(1, 8)
+:let v9 = screenattr(1, 9)
+:let v10 = screenattr(1, 10)
+:let @r .= string(getmatches())."\n"
+:if v1 != v4 && v5 == v4 && v6 == v1 && v7 == v1 && v8 == v4 && v9 == v4 && v10 == v1
+:  let @r .= "OK\n"
+:else
+:  let @r .= "FAILED: " . v4 . "/" . v5 . "/" . v6 . "/" . v7 . "/" . v8 . "/" . v9 . "/" . v10 . "\n"
+:endif
+:call clearmatches()
 G"rp
 :/^Results/,$wq! test.out
 ENDTEST
diff -Naur vim74.orig/src/testdir/test63.ok vim74/src/testdir/test63.ok
--- vim74.orig/src/testdir/test63.ok	2010-05-15 11:04:10.000000000 +0000
+++ vim74/src/testdir/test63.ok	2014-10-10 14:53:45.668710555 +0000
@@ -9,3 +9,8 @@
 *** Test 8: OK
 *** Test 9: OK
 *** Test 10: OK
+*** Test 11:
+[{'group': 'MyGroup1', 'id': 3, 'priority': 10, 'pos1': [1, 5, 1], 'pos2': [1, 8, 3]}]
+OK
+[{'group': 'MyGroup1', 'id': 11, 'priority': 10, 'pos1': [1, 4, 2], 'pos2': [1, 9, 2]}]
+OK
diff -Naur vim74.orig/src/testdir/test64.in vim74/src/testdir/test64.in
--- vim74.orig/src/testdir/test64.in	2013-08-01 15:45:33.000000000 +0000
+++ vim74/src/testdir/test64.in	2014-10-10 14:53:45.672043880 +0000
@@ -238,7 +238,11 @@
 :call add(tl, [2, '\vx(.{-,8})yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz','ayxa','xayzxayz'])
 :call add(tl, [2, '\vx(.*)yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz', 'ayxayzxayzxa',''])
 :call add(tl, [2, '\v(a{1,2}){-2,3}','aaaaaaa','aaaa','aa'])
-:call add(tl, [2, '\v(a{-1,3})+','aa','aa','a'])
+:call add(tl, [2, '\v(a{-1,3})+', 'aa', 'aa', 'a'])
+:call add(tl, [2, '^\s\{-}\zs\( x\|x$\)', ' x', ' x', ' x'])
+:call add(tl, [2, '^\s\{-}\zs\(x\| x$\)', ' x', ' x', ' x'])
+:call add(tl, [2, '^\s\{-}\ze\(x\| x$\)', ' x', '', ' x'])
+:call add(tl, [2, '^\(\s\{-}\)\(x\| x$\)', ' x', ' x', '', ' x'])
 :"
 :" Test Character classes
 :call add(tl, [2, '\d\+e\d\d','test 10e23 fd','10e23'])
@@ -289,15 +293,29 @@
 :call add(tl, [2, '.a\%$', " a\n "])
 :call add(tl, [2, '.a\%$', " a\n_a", "_a"])
 :"
-:"""" Test recognition of some character classes
-:call add(tl, [2, '[0-9]', '8', '8'])
-:call add(tl, [2, '[^0-9]', '8'])
-:call add(tl, [2, '[0-9a-fA-F]*', '0a7', '0a7'])
-:call add(tl, [2, '[^0-9A-Fa-f]\+', '0a7'])
-:call add(tl, [2, '[a-z_A-Z0-9]\+', 'aso_sfoij', 'aso_sfoij'])
-:call add(tl, [2, '[a-z]', 'a', 'a'])
-:call add(tl, [2, '[a-zA-Z]', 'a', 'a'])
-:call add(tl, [2, '[A-Z]', 'a'])
+:"""" Test recognition of character classes
+:call add(tl, [2, '[0-7]\+', 'x0123456789x', '01234567'])
+:call add(tl, [2, '[^0-7]\+', '0a;X+% 897', 'a;X+% 89'])
+:call add(tl, [2, '[0-9]\+', 'x0123456789x', '0123456789'])
+:call add(tl, [2, '[^0-9]\+', '0a;X+% 9', 'a;X+% '])
+:call add(tl, [2, '[0-9a-fA-F]\+', 'x0189abcdefg', '0189abcdef'])
+:call add(tl, [2, '[^0-9A-Fa-f]\+', '0189g;X+% ab', 'g;X+% '])
+:call add(tl, [2, '[a-z_A-Z0-9]\+', ';+aso_SfOij ', 'aso_SfOij'])
+:call add(tl, [2, '[^a-z_A-Z0-9]\+', 'aSo_;+% sfOij', ';+% '])
+:call add(tl, [2, '[a-z_A-Z]\+', '0abyz_ABYZ;', 'abyz_ABYZ'])
+:call add(tl, [2, '[^a-z_A-Z]\+', 'abAB_09;+% yzYZ', '09;+% '])
+:call add(tl, [2, '[a-z]\+', '0abcxyz1', 'abcxyz'])
+:call add(tl, [2, '[a-z]\+', 'AabxyzZ', 'abxyz'])
+:call add(tl, [2, '[^a-z]\+', 'a;X09+% x', ';X09+% '])
+:call add(tl, [2, '[^a-z]\+', 'abX0;%yz', 'X0;%'])
+:call add(tl, [2, '[a-zA-Z]\+', '0abABxzXZ9', 'abABxzXZ'])
+:call add(tl, [2, '[^a-zA-Z]\+', 'ab09_;+ XZ', '09_;+ '])
+:call add(tl, [2, '[A-Z]\+', 'aABXYZz', 'ABXYZ'])
+:call add(tl, [2, '[^A-Z]\+', 'ABx0;%YZ', 'x0;%'])
+:call add(tl, [2, '[a-z]\+\c', '0abxyzABXYZ;', 'abxyzABXYZ'])
+:call add(tl, [2, '[A-Z]\+\c', '0abABxzXZ9', 'abABxzXZ'])
+:call add(tl, [2, '\c[^a-z]\+', 'ab09_;+ XZ', '09_;+ '])
+:call add(tl, [2, '\c[^A-Z]\+', 'ab09_;+ XZ', '09_;+ '])
 :call add(tl, [2, '\C[^A-Z]\+', 'ABCOIJDEOIFNSD jsfoij sa', ' jsfoij sa'])
 :"
 :"""" Tests for \z features
@@ -314,6 +332,7 @@
 :call add(tl, [2, 'abc \zsmatch\ze abc', 'abc abc abc match abc abc', 'match'])
 :call add(tl, [2, '\v(a \zsif .*){2}', 'a if then a if last', 'if last', 'a if last'])
 :call add(tl, [2, '\>\zs.', 'aword. ', '.'])
+:call add(tl, [2, '\s\+\ze\[/\|\s\zs\s\+', 'is   [a t', '  '])
 :"
 :"""" Tests for \@= and \& features
 :call add(tl, [2, 'abc\@=', 'abc', 'ab'])
@@ -358,6 +377,7 @@
 :call add(tl, [2, '\%x20', 'yes no', ' '])
 :call add(tl, [2, '\%u0020', 'yes no', ' '])
 :call add(tl, [2, '\%U00000020', 'yes no', ' '])
+:call add(tl, [2, '\%d0', "yes\x0ano", "\x0a"])
 :"
 :""""" \%[abc]
 :call add(tl, [2, 'foo\%[bar]', 'fobar'])
@@ -390,6 +410,8 @@
 :call add(tl, [2, '^.*\.\(.*\)/.\+\(\1\)\@<!$', 'foo.bat/foo.bat'])
 :call add(tl, [2, '^.*\.\(.*\)/.\+\(\1\)\@<=$', 'foo.bat/foo.bat', 'foo.bat/foo.bat', 'bat', 'bat'])
 :call add(tl, [2, '\\\@<!\${\(\d\+\%(:.\{-}\)\?\\\@<!\)}', '2013-06-27${0}', '${0}', '0'])
+:call add(tl, [2, '^\(a*\)\1$', 'aaaaaaaa', 'aaaaaaaa', 'aaaa'])
+:call add(tl, [2, '^\(a\{-2,}\)\1\+$', 'aaaaaaaaa', 'aaaaaaaaa', 'aaa'])
 :"
 :"""" Look-behind with limit
 :call add(tl, [2, '<\@<=span.', 'xxspanxx<spanyyy', 'spany'])
@@ -407,9 +429,15 @@
 :call add(tl, [2, '\(foo\)\@<=\>', 'barfoo', '', 'foo'])
 :call add(tl, [2, '\(foo\)\@<=.*', 'foobar', 'bar', 'foo'])
 :"
+:" complicated look-behind match
+:call add(tl, [2, '\(r\@<=\|\w\@<!\)\/', 'x = /word/;', '/'])
+:call add(tl, [2, '^[a-z]\+\ze \&\(asdf\)\@<!', 'foo bar', 'foo'])
+:"
 :""""" \@>
 :call add(tl, [2, '\(a*\)\@>a', 'aaaa'])
 :call add(tl, [2, '\(a*\)\@>b', 'aaab', 'aaab', 'aaa'])
+:call add(tl, [2, '^\(.\{-}b\)\@>.', '  abcbd', '  abc', '  ab'])
+:call add(tl, [2, '\(.\{-}\)\(\)\@>$', 'abc', 'abc', 'abc', ''])
 :" TODO: BT engine does not restore submatch after failure
 :call add(tl, [1, '\(a*\)\@>a\|a\+', 'aaaa', 'aaaa'])
 :"
@@ -431,22 +459,22 @@
 :  let text = t[2]
 :  let matchidx = 3
 :  for engine in [0, 1, 2]
-:    if engine == 2 && re == 0 || engine == 1 && re ==1
+:    if engine == 2 && re == 0 || engine == 1 && re == 1
 :      continue
 :    endif
 :    let &regexpengine = engine
 :    try
 :      let l = matchlist(text, pat)
 :    catch
-:      $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", caused an exception: \"' . v:exception . '\"'
+:      $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", caused an exception: \"' . v:exception . '\"'
 :    endtry
 :" check the match itself
 :    if len(l) == 0 && len(t) > matchidx
-:      $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", did not match, expected: \"' . t[matchidx] . '\"'
+:      $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", did not match, expected: \"' . t[matchidx] . '\"'
 :    elseif len(l) > 0 && len(t) == matchidx
-:      $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", match: \"' . l[0] . '\", expected no match'
+:      $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", match: \"' . l[0] . '\", expected no match'
 :    elseif len(t) > matchidx && l[0] != t[matchidx]
-:      $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", match: \"' . l[0] . '\", expected: \"' . t[matchidx] . '\"'
+:      $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", match: \"' . l[0] . '\", expected: \"' . t[matchidx] . '\"'
 :    else
 :      $put ='OK ' . engine . ' - ' . pat
 :    endif
@@ -459,7 +487,7 @@
 :          let e = t[matchidx + i]
 :        endif
 :        if l[i] != e
-:          $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", submatch ' . i . ': \"' . l[i] . '\", expected: \"' . e . '\"'
+:          $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", submatch ' . i . ': \"' . l[i] . '\", expected: \"' . e . '\"'
 :        endif
 :      endfor
 :      unlet i
@@ -484,6 +512,8 @@
 :" Check a pattern with a line break and ^ and $
 :call add(tl, [2, 'a\n^b$\n^c', ['a', 'b', 'c'], ['XX']])
 :"
+:call add(tl, [2, '\(^.\+\n\)\1', [' dog', ' dog', 'asdf'], ['XXasdf']])
+:"
 :"""" Run the multi-line tests
 :"
 :$put ='multi-line tests'
@@ -578,6 +608,17 @@
 "ayb20gg/..\%$
 "bybGo"apo"bp:"
 :"
+:" Check for detecting error
+:set regexpengine=2
+:for pat in [' \ze*', ' \zs*']
+:  try
+:    let l = matchlist('x x', pat)
+:    $put ='E888 NOT detected for ' . pat
+:  catch
+:    $put ='E888 detected for ' . pat
+:  endtry
+:endfor
+:"
 :""""" Write the results """""""""""""
 :/\%#=1^Results/,$wq! test.out
 ENDTEST
diff -Naur vim74.orig/src/testdir/test64.ok vim74/src/testdir/test64.ok
--- vim74.orig/src/testdir/test64.ok	2013-08-01 16:28:56.000000000 +0000
+++ vim74/src/testdir/test64.ok	2014-10-10 14:53:45.675377205 +0000
@@ -533,6 +533,18 @@
 OK 0 - \v(a{-1,3})+
 OK 1 - \v(a{-1,3})+
 OK 2 - \v(a{-1,3})+
+OK 0 - ^\s\{-}\zs\( x\|x$\)
+OK 1 - ^\s\{-}\zs\( x\|x$\)
+OK 2 - ^\s\{-}\zs\( x\|x$\)
+OK 0 - ^\s\{-}\zs\(x\| x$\)
+OK 1 - ^\s\{-}\zs\(x\| x$\)
+OK 2 - ^\s\{-}\zs\(x\| x$\)
+OK 0 - ^\s\{-}\ze\(x\| x$\)
+OK 1 - ^\s\{-}\ze\(x\| x$\)
+OK 2 - ^\s\{-}\ze\(x\| x$\)
+OK 0 - ^\(\s\{-}\)\(x\| x$\)
+OK 1 - ^\(\s\{-}\)\(x\| x$\)
+OK 2 - ^\(\s\{-}\)\(x\| x$\)
 OK 0 - \d\+e\d\d
 OK 1 - \d\+e\d\d
 OK 2 - \d\+e\d\d
@@ -650,30 +662,72 @@
 OK 0 - .a\%$
 OK 1 - .a\%$
 OK 2 - .a\%$
-OK 0 - [0-9]
-OK 1 - [0-9]
-OK 2 - [0-9]
-OK 0 - [^0-9]
-OK 1 - [^0-9]
-OK 2 - [^0-9]
-OK 0 - [0-9a-fA-F]*
-OK 1 - [0-9a-fA-F]*
-OK 2 - [0-9a-fA-F]*
+OK 0 - [0-7]\+
+OK 1 - [0-7]\+
+OK 2 - [0-7]\+
+OK 0 - [^0-7]\+
+OK 1 - [^0-7]\+
+OK 2 - [^0-7]\+
+OK 0 - [0-9]\+
+OK 1 - [0-9]\+
+OK 2 - [0-9]\+
+OK 0 - [^0-9]\+
+OK 1 - [^0-9]\+
+OK 2 - [^0-9]\+
+OK 0 - [0-9a-fA-F]\+
+OK 1 - [0-9a-fA-F]\+
+OK 2 - [0-9a-fA-F]\+
 OK 0 - [^0-9A-Fa-f]\+
 OK 1 - [^0-9A-Fa-f]\+
 OK 2 - [^0-9A-Fa-f]\+
 OK 0 - [a-z_A-Z0-9]\+
 OK 1 - [a-z_A-Z0-9]\+
 OK 2 - [a-z_A-Z0-9]\+
-OK 0 - [a-z]
-OK 1 - [a-z]
-OK 2 - [a-z]
-OK 0 - [a-zA-Z]
-OK 1 - [a-zA-Z]
-OK 2 - [a-zA-Z]
-OK 0 - [A-Z]
-OK 1 - [A-Z]
-OK 2 - [A-Z]
+OK 0 - [^a-z_A-Z0-9]\+
+OK 1 - [^a-z_A-Z0-9]\+
+OK 2 - [^a-z_A-Z0-9]\+
+OK 0 - [a-z_A-Z]\+
+OK 1 - [a-z_A-Z]\+
+OK 2 - [a-z_A-Z]\+
+OK 0 - [^a-z_A-Z]\+
+OK 1 - [^a-z_A-Z]\+
+OK 2 - [^a-z_A-Z]\+
+OK 0 - [a-z]\+
+OK 1 - [a-z]\+
+OK 2 - [a-z]\+
+OK 0 - [a-z]\+
+OK 1 - [a-z]\+
+OK 2 - [a-z]\+
+OK 0 - [^a-z]\+
+OK 1 - [^a-z]\+
+OK 2 - [^a-z]\+
+OK 0 - [^a-z]\+
+OK 1 - [^a-z]\+
+OK 2 - [^a-z]\+
+OK 0 - [a-zA-Z]\+
+OK 1 - [a-zA-Z]\+
+OK 2 - [a-zA-Z]\+
+OK 0 - [^a-zA-Z]\+
+OK 1 - [^a-zA-Z]\+
+OK 2 - [^a-zA-Z]\+
+OK 0 - [A-Z]\+
+OK 1 - [A-Z]\+
+OK 2 - [A-Z]\+
+OK 0 - [^A-Z]\+
+OK 1 - [^A-Z]\+
+OK 2 - [^A-Z]\+
+OK 0 - [a-z]\+\c
+OK 1 - [a-z]\+\c
+OK 2 - [a-z]\+\c
+OK 0 - [A-Z]\+\c
+OK 1 - [A-Z]\+\c
+OK 2 - [A-Z]\+\c
+OK 0 - \c[^a-z]\+
+OK 1 - \c[^a-z]\+
+OK 2 - \c[^a-z]\+
+OK 0 - \c[^A-Z]\+
+OK 1 - \c[^A-Z]\+
+OK 2 - \c[^A-Z]\+
 OK 0 - \C[^A-Z]\+
 OK 1 - \C[^A-Z]\+
 OK 2 - \C[^A-Z]\+
@@ -710,6 +764,9 @@
 OK 0 - \>\zs.
 OK 1 - \>\zs.
 OK 2 - \>\zs.
+OK 0 - \s\+\ze\[/\|\s\zs\s\+
+OK 1 - \s\+\ze\[/\|\s\zs\s\+
+OK 2 - \s\+\ze\[/\|\s\zs\s\+
 OK 0 - abc\@=
 OK 1 - abc\@=
 OK 2 - abc\@=
@@ -818,6 +875,9 @@
 OK 0 - \%U00000020
 OK 1 - \%U00000020
 OK 2 - \%U00000020
+OK 0 - \%d0
+OK 1 - \%d0
+OK 2 - \%d0
 OK 0 - foo\%[bar]
 OK 1 - foo\%[bar]
 OK 2 - foo\%[bar]
@@ -896,6 +956,12 @@
 OK 0 - \\\@<!\${\(\d\+\%(:.\{-}\)\?\\\@<!\)}
 OK 1 - \\\@<!\${\(\d\+\%(:.\{-}\)\?\\\@<!\)}
 OK 2 - \\\@<!\${\(\d\+\%(:.\{-}\)\?\\\@<!\)}
+OK 0 - ^\(a*\)\1$
+OK 1 - ^\(a*\)\1$
+OK 2 - ^\(a*\)\1$
+OK 0 - ^\(a\{-2,}\)\1\+$
+OK 1 - ^\(a\{-2,}\)\1\+$
+OK 2 - ^\(a\{-2,}\)\1\+$
 OK 0 - <\@<=span.
 OK 1 - <\@<=span.
 OK 2 - <\@<=span.
@@ -932,12 +998,24 @@
 OK 0 - \(foo\)\@<=.*
 OK 1 - \(foo\)\@<=.*
 OK 2 - \(foo\)\@<=.*
+OK 0 - \(r\@<=\|\w\@<!\)\/
+OK 1 - \(r\@<=\|\w\@<!\)\/
+OK 2 - \(r\@<=\|\w\@<!\)\/
+OK 0 - ^[a-z]\+\ze \&\(asdf\)\@<!
+OK 1 - ^[a-z]\+\ze \&\(asdf\)\@<!
+OK 2 - ^[a-z]\+\ze \&\(asdf\)\@<!
 OK 0 - \(a*\)\@>a
 OK 1 - \(a*\)\@>a
 OK 2 - \(a*\)\@>a
 OK 0 - \(a*\)\@>b
 OK 1 - \(a*\)\@>b
 OK 2 - \(a*\)\@>b
+OK 0 - ^\(.\{-}b\)\@>.
+OK 1 - ^\(.\{-}b\)\@>.
+OK 2 - ^\(.\{-}b\)\@>.
+OK 0 - \(.\{-}\)\(\)\@>$
+OK 1 - \(.\{-}\)\(\)\@>$
+OK 2 - \(.\{-}\)\(\)\@>$
 OK 0 - \(a*\)\@>a\|a\+
 OK 2 - \(a*\)\@>a\|a\+
 OK 0 - \_[^8-9]\+
@@ -968,6 +1046,9 @@
 OK 0 - a\n^b$\n^c
 OK 1 - a\n^b$\n^c
 OK 2 - a\n^b$\n^c
+OK 0 - \(^.\+\n\)\1
+OK 1 - \(^.\+\n\)\1
+OK 2 - \(^.\+\n\)\1
 
 <T="5">Ta 5</Title>
 <T="7">Ac 7</Title>
@@ -1016,3 +1097,5 @@
 Test END
 EN
 E
+E888 detected for  \ze*
+E888 detected for  \zs*
diff -Naur vim74.orig/src/testdir/test68.in vim74/src/testdir/test68.in
--- vim74.orig/src/testdir/test68.in	2012-07-25 13:57:06.000000000 +0000
+++ vim74/src/testdir/test68.in	2014-10-10 14:53:45.685377180 +0000
@@ -62,6 +62,20 @@
 }
 
 STARTTEST
+/^{/+3
+:set tw=5 fo=t2a si
+i  A_
+ENDTEST
+
+{
+
+  x a
+  b
+ c
+
+}
+
+STARTTEST
 /^{/+1
 :set tw=5 fo=qn comments=:#
 gwap
diff -Naur vim74.orig/src/testdir/test68.ok vim74/src/testdir/test68.ok
--- vim74.orig/src/testdir/test68.ok	2012-07-25 14:03:05.000000000 +0000
+++ vim74/src/testdir/test68.ok	2014-10-10 14:53:45.685377180 +0000
@@ -43,6 +43,15 @@
 
 
 {
+
+  x a
+    b_
+    c
+
+}
+
+
+{
 # 1 a
 #   b
 }
diff -Naur vim74.orig/src/testdir/test69.in vim74/src/testdir/test69.in
--- vim74.orig/src/testdir/test69.in	2013-03-07 17:30:50.000000000 +0000
+++ vim74/src/testdir/test69.in	2014-10-10 14:53:45.688710505 +0000
@@ -1,6 +1,7 @@
 Test for multi-byte text formatting.
 Also test, that 'mps' with multibyte chars works.
 And test "ra" on multi-byte characters.
+Also test byteidx() and byteidxcomp()
 
 STARTTEST
 :so mbyte.vim
@@ -154,6 +155,38 @@
 b
 
 STARTTEST
+:set whichwrap+=h
+/^x
+dh
+:set whichwrap-=h
+ENDTEST
+
+
+x
+
+STARTTEST
+:let a = '..' " one char of two bytes
+:let b = '.e.' " normal e with composing char
+/^byteidx
+:put =string([byteidx(a, 0), byteidx(a, 1), byteidx(a, 2), byteidx(a, 3), byteidx(a, 4)])
+:put =string([byteidx(b, 0), byteidx(b, 1), byteidx(b, 2), byteidx(b, 3), byteidx(b, 4)])
+/^byteidxcomp
+:put =string([byteidxcomp(a, 0), byteidxcomp(a, 1), byteidxcomp(a, 2), byteidxcomp(a, 3), byteidxcomp(a, 4)])
+:let b = '.e.'
+:put =string([byteidxcomp(b, 0), byteidxcomp(b, 1), byteidxcomp(b, 2), byteidxcomp(b, 3), byteidxcomp(b, 4), byteidxcomp(b, 5)])
+ENDTEST
+
+byteidx
+byteidxcomp
+
+STARTTEST
+/^substitute
+:let y = substitute('', '\zs', 'a', 'g')    | put =y
+ENDTEST
+
+substitute
+
+STARTTEST
 :g/^STARTTEST/.,/^ENDTEST/d
 :1;/^Results/,$wq! test.out
 ENDTEST
diff -Naur vim74.orig/src/testdir/test69.ok vim74/src/testdir/test69.ok
--- vim74.orig/src/testdir/test69.ok	2013-03-07 17:31:32.000000000 +0000
+++ vim74/src/testdir/test69.ok	2014-10-10 14:53:45.688710505 +0000
@@ -149,3 +149,18 @@
 aaaa
 aaa
 
+
+x
+
+
+byteidx
+[0, 1, 3, 4, -1]
+[0, 1, 4, 5, -1]
+byteidxcomp
+[0, 1, 3, 4, -1]
+[0, 1, 2, 4, 5, -1]
+
+
+substitute
+aaaa
+
diff -Naur vim74.orig/src/testdir/test71.in vim74/src/testdir/test71.in
--- vim74.orig/src/testdir/test71.in	2013-07-01 18:47:58.000000000 +0000
+++ vim74/src/testdir/test71.in	2014-10-10 14:53:45.695377155 +0000
@@ -13,6 +13,8 @@
 :let cm0_bytes = getline('.', '.')
 :/^start of cm=blowfish bytes/+1
 :let cm1_bytes = getline('.', '.')
+:/^start of cm=blowfish2 bytes/+1
+:let cm2_bytes = getline('.', '.')
 :bwipe!
 :call append(0, text_lines)
 :$d
@@ -36,6 +38,18 @@
 :e Xtestfile
 barfoo
 :let cm1_read_back = getline('.', '$')
+:set key=
+:set cryptmethod=blowfish2
+:" If the blowfish test fails 'cryptmethod' will be 'zip' now.
+:%s/^/\=&cryptmethod == 'blowfish2' ? "OK " : "blowfish test failed "/
+:X
+bar2foo
+bar2foo
+:w! Xtestfile
+:bwipe!
+:e Xtestfile
+bar2foo
+:let cm2_read_back = getline('.', '$')
 :bwipe!
 :set bin noeol key=
 :call append(0, cm0_bytes)
@@ -57,7 +71,20 @@
 :set nobin
 :e Xtestfile
 barbar
+:let cm1_read_bin = getline('.', '$')
+:bwipe!
+:set bin noeol key=
+:call append(0, cm2_bytes)
+:$d
+:set fenc=latin1
+:w! Xtestfile
+:bwipe!
+:set nobin
+:e Xtestfile
+barburp
+:call append(0, cm1_read_bin)
 :call append(0, cm0_read_bin)
+:call append(0, cm2_read_back)
 :call append(0, cm1_read_back)
 :call append(0, cm0_read_back)
 :set key= fenc=latin1
diff -Naur vim74.orig/src/testdir/test71.ok vim74/src/testdir/test71.ok
--- vim74.orig/src/testdir/test71.ok	2010-05-21 13:21:48.000000000 +0000
+++ vim74/src/testdir/test71.ok	2014-10-10 14:53:45.695377155 +0000
@@ -4,7 +4,12 @@
 OK 01234567890123456789012345678901234567
 OK line 2  foo bar blah
 OK line 3 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+OK OK 01234567890123456789012345678901234567
+OK OK line 2  foo bar blah
+OK OK line 3 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 1234567890
 abbccddeff
 asdfasdfasdf
 0001112223333
+abcdefghijklmnopqrstuvwxyz
+!@#$%^&*()_+=-`~
diff -Naur vim74.orig/src/testdir/test71a.in vim74/src/testdir/test71a.in
--- vim74.orig/src/testdir/test71a.in	2013-07-01 18:45:58.000000000 +0000
+++ vim74/src/testdir/test71a.in	2014-10-10 14:53:45.695377155 +0000
@@ -12,3 +12,7 @@
 start of cm=blowfish bytes
 VimCrypt~02!k)#S=#MJAM!
 end of cm=blowfish bytes
+
+start of cm=blowfish2 bytes
+VimCrypt~03!N;^C).FS6[T92Q@Iv.`$%
+end of cm=blowfish2 bytes
diff -Naur vim74.orig/src/testdir/test72.in vim74/src/testdir/test72.in
--- vim74.orig/src/testdir/test72.in	2012-01-04 18:04:17.000000000 +0000
+++ vim74/src/testdir/test72.in	2014-10-10 14:53:45.698710480 +0000
@@ -8,6 +8,7 @@
 :" Test 'undofile': first a simple one-line change.
 :set nocompatible viminfo+=nviminfo visualbell
 :set ul=100 undofile nomore
+:set ff=unix
 :e! Xtestfile
 ggdGithis is one line:set ul=100
 :s/one/ONE/
@@ -81,6 +82,7 @@
 :"
 :" With encryption, cryptmethod=blowfish
 :e! Xtestfile
+rubbish
 :set undofile cm=blowfish
 ggdGijan
 feb
@@ -104,8 +106,38 @@
 u:.w >>test.out
 u:.w >>test.out
 :"
+:" With encryption, cryptmethod=blowfish2
+:e! Xtestfile
+rubbish
+:set undofile cm=blowfish2
+ggdGijan
+feb
+mar
+apr
+jun:set ul=100
+kk0ifoo :set ul=100
+dd:set ul=100
+ibar :set ul=100
+:X
+foo2bar
+foo2bar
+:w!
+:bwipe!
+:e Xtestfile
+foo2bar
+:set key=
+/bar
+:.w >>test.out
+u:.w >>test.out
+u:.w >>test.out
+u:.w >>test.out
+:"
 :" Rename the undo file so that it gets cleaned up.
-:call rename(".Xtestfile.un~", "Xtestundo")
+:if has("vms")
+: call rename("_un_Xtestfile", "Xtestundo")
+:else
+: call rename(".Xtestfile.un~", "Xtestundo")
+:endif
 :qa!
 ENDTEST
 
diff -Naur vim74.orig/src/testdir/test72.ok vim74/src/testdir/test72.ok
--- vim74.orig/src/testdir/test72.ok	2012-01-04 18:04:17.000000000 +0000
+++ vim74/src/testdir/test72.ok	2014-10-10 14:53:45.698710480 +0000
@@ -25,3 +25,7 @@
 apr
 foo mar
 mar
+bar apr
+apr
+foo mar
+mar
diff -Naur vim74.orig/src/testdir/test75.in vim74/src/testdir/test75.in
--- vim74.orig/src/testdir/test75.in	2013-06-29 11:48:42.000000000 +0000
+++ vim74/src/testdir/test75.in	2014-10-10 14:53:45.705377130 +0000
@@ -1,8 +1,11 @@
-" Tests for functions.
+Tests for maparg().
+Also test utf8 map with a 0x80 byte.
 
 STARTTEST
 :so small.vim
+:so mbyte.vim
 :set cpo-=<
+:set encoding=utf8
 :" Test maparg() with a string result
 :map foo<C-V> is<F4>foo
 :vnoremap <script> <buffer> <expr> <silent> bar isbar
@@ -17,6 +20,20 @@
 :map abc y<S-char-114>y
 :call append('$', maparg('abc'))
 :"
+Go:"
+:" Outside of the range, minimum
+:inoremap <Char-0x1040> a
+:execute "normal a\u1040\<Esc>"
+:" Inside of the range, minimum
+:inoremap <Char-0x103f> b
+:execute "normal a\u103f\<Esc>"
+:" Inside of the range, maximum
+:inoremap <Char-0xf03f> c
+:execute "normal a\uf03f\<Esc>"
+:" Outside of the range, maximum
+:inoremap <Char-0xf040> d
+:execute "normal a\uf040\<Esc>"
+:"
 :/^eof/+1,$w! test.out
 :qa!
 ENDTEST
diff -Naur vim74.orig/src/testdir/test75.ok vim74/src/testdir/test75.ok
--- vim74.orig/src/testdir/test75.ok	2013-06-29 11:50:08.000000000 +0000
+++ vim74/src/testdir/test75.ok	2014-10-10 14:53:45.708710455 +0000
@@ -4,3 +4,4 @@
 {'silent': 0, 'noremap': 0, 'lhs': 'foo', 'mode': ' ', 'nowait': 1, 'expr': 0, 'sid': 0, 'rhs': 'bar', 'buffer': 1}
 xrx
 yRy
+abcd
diff -Naur vim74.orig/src/testdir/test77a.com vim74/src/testdir/test77a.com
--- vim74.orig/src/testdir/test77a.com	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test77a.com	2014-10-10 14:53:45.715377105 +0000
@@ -0,0 +1,8 @@
+$! test77a - help file creating checksum on VMS
+$! Created by Zoltan Arpadffy
+$
+$ IF P1 .NES. ""
+$ THEN
+$    checksum 'P1'
+$    show symb CHECKSUM$CHECKSUM
+$ ENDIF
diff -Naur vim74.orig/src/testdir/test77a.in vim74/src/testdir/test77a.in
--- vim74.orig/src/testdir/test77a.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test77a.in	2014-10-10 14:53:45.715377105 +0000
@@ -0,0 +1,31 @@
+Inserts 2 million lines with consecutive integers starting from 1
+(essentially, the output of GNU's seq 1 2000000), writes them to Xtest
+and writes its cksum to test.out.
+
+We need 2 million lines to trigger a call to mf_hash_grow().  If it would mess
+up the lines the checksum would differ.
+
+cksum is part of POSIX and so should be available on most Unixes.
+If it isn't available then the test will be skipped.
+
+VMS does not have CKSUM but has a built in CHECKSUM - it should be used
+STARTTEST
+:so small.vim
+:if !has("vms")
+: e! test.ok
+: w! test.out
+: qa!
+:endif
+:set fileformat=unix undolevels=-1
+ggdG
+:let i = 1
+:while i <= 2000000 | call append(i, range(i, i + 99)) | let i += 100 | endwhile
+ggdd
+:w! Xtest.
+:r !@test77a.com Xtest.
+:s/\s/ /g
+:set fileformat&
+:.w! test.out
+:qa!
+ENDTEST
+
diff -Naur vim74.orig/src/testdir/test77a.ok vim74/src/testdir/test77a.ok
--- vim74.orig/src/testdir/test77a.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test77a.ok	2014-10-10 14:53:45.715377105 +0000
@@ -0,0 +1 @@
+  CHECKSUM$CHECKSUM = "844110470"
diff -Naur vim74.orig/src/testdir/test79.in vim74/src/testdir/test79.in
--- vim74.orig/src/testdir/test79.in	2013-04-13 09:16:38.000000000 +0000
+++ vim74/src/testdir/test79.in	2014-10-10 14:53:45.718710430 +0000
@@ -1,6 +1,7 @@
 Test for *sub-replace-special* and *sub-replace-expression* on :substitute.
 Test for submatch() on :substitue.
 Test for *:s%* on :substitute.
+Test for :s replacing \n with  line break.
 
 STARTTEST
 :so small.vim
@@ -181,10 +182,12 @@
 :set cpo&
 /^TEST/
 j:s/A\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)/\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/
+j:s/B\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)/\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/
 ENDTEST
 
 TEST_5:
 A123456789
+B123456789
 
 STARTTEST
 :set magic&
@@ -209,6 +212,9 @@
 /^TEST_7/
 j:s/A./\=submatch(0)/
 j:s/B./\=submatch(0)/
+j:s/C./\=strtrans(string(submatch(0, 1)))/
+j:s/D.\nD/\=strtrans(string(submatch(0, 1)))/
+j:s/E\_.\{-}E/\=strtrans(string(submatch(0, 1)))/
 /^Q$
 :s/Q[^\n]Q/\=submatch(0)."foobar"/
 :" Avoid :s error breaks dotest map on Windows.
@@ -217,10 +223,33 @@
 TEST_7:
 AA
 B B
+C C
+D 
+D
+E 
+ 
+ 
+ 
+ E
 Q
 Q
 
 STARTTEST
+:function! TitleString()
+  let check = 'foo' =~ 'bar'
+  return ""
+endfunction
+:set titlestring=%{TitleString()}
+:/^test_one/s/.*/\="foo\nbar"/
+:/^test_two/s/.*/\="foo\nbar"/c
+y
+ENDTEST
+
+test_one
+test_two
+
+STARTTEST
 :g/^STARTTEST/.,/^ENDTEST/d
 :1;/^Results/,$wq! test.out
+:call getchar()
 ENDTEST
diff -Naur vim74.orig/src/testdir/test79.ok vim74/src/testdir/test79.ok
--- vim74.orig/src/testdir/test79.ok	2013-03-19 16:30:51.000000000 +0000
+++ vim74/src/testdir/test79.ok	2014-10-10 14:53:45.722043755 +0000
@@ -105,6 +105,7 @@
 
 TEST_5:
 A123456789987654321
+[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]
 
 
 TEST_6:
@@ -119,6 +120,15 @@
 A
 B
 B
+['C^@']C
+['D^@', 'D']
+['E^@', '^@', '^@', '^@', '^@E']
 Q
 Q
 
+
+foo
+bar
+foo
+bar
+
diff -Naur vim74.orig/src/testdir/test80.in vim74/src/testdir/test80.in
--- vim74.orig/src/testdir/test80.in	2013-03-19 16:30:51.000000000 +0000
+++ vim74/src/testdir/test80.in	2014-10-10 14:53:45.725377080 +0000
@@ -117,6 +117,7 @@
 :set cpo&
 :$put =\"\n\nTEST_5:\"
 :$put =substitute('A123456789', 'A\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)', '\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)', '')
+:$put =substitute('A123456789', 'A\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)\(.\)', '\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])', '')
 /^TEST_6
 ENDTEST
 
@@ -142,6 +143,9 @@
 :$put =\"\n\nTEST_7:\"
 :$put =substitute('AA', 'A.', '\=submatch(0)', '')
 :$put =substitute(\"B\nB\", 'B.', '\=submatch(0)', '')
+:$put =substitute(\"B\nB\", 'B.', '\=string(submatch(0, 1))', '')
+:$put =substitute('-bb', '\zeb', 'a', 'g')
+:$put =substitute('-bb', '\ze', 'c', 'g')
 /^TEST_8
 ENDTEST
 
@@ -174,6 +178,23 @@
 TEST_10:
 
 STARTTEST
+:set magic&
+:set cpo&
+:$put =\"\n\nTEST_10:\"
+:let y = substitute('123', '\zs', 'a', 'g')             | $put =y
+:let y = substitute('123', '\zs.', 'a', 'g')            | $put =y
+:let y = substitute('123', '.\zs', 'a', 'g')            | $put =y
+:let y = substitute('123', '\ze', 'a', 'g')             | $put =y
+:let y = substitute('123', '\ze.', 'a', 'g')            | $put =y
+:let y = substitute('123', '.\ze', 'a', 'g')            | $put =y
+:let y = substitute('123', '1\|\ze', 'a', 'g')          | $put =y
+:let y = substitute('123', '1\zs\|[23]', 'a', 'g')      | $put =y
+/^TEST_11
+ENDTEST
+
+TEST_11:
+
+STARTTEST
 :/^Results/,$wq! test.out
 ENDTEST
 
diff -Naur vim74.orig/src/testdir/test80.ok vim74/src/testdir/test80.ok
--- vim74.orig/src/testdir/test80.ok	2013-03-19 16:31:45.000000000 +0000
+++ vim74/src/testdir/test80.ok	2014-10-10 14:53:45.728710405 +0000
@@ -90,6 +90,7 @@
 
 TEST_5:
 A123456789987654321
+[['A123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]
 
 
 TEST_6:
@@ -103,6 +104,10 @@
 AA
 B
 B
+['B
+']B
+-abab
+c-cbcbc
 
 
 TEST_8:
@@ -113,3 +118,14 @@
 
 TEST_9:
 XXx
+
+
+TEST_10:
+a1a2a3a
+aaa
+1a2a3a
+a1a2a3a
+a1a2a3
+aaa
+aa2a3a
+1aaa
diff -Naur vim74.orig/src/testdir/test86.in vim74/src/testdir/test86.in
--- vim74.orig/src/testdir/test86.in	2013-07-13 12:00:31.000000000 +0000
+++ vim74/src/testdir/test86.in	2014-10-10 14:53:45.745377029 +0000
@@ -39,6 +39,7 @@
 py << EOF
 d=vim.bindeval('d')
 d['1']='asd'
+d.update()  # Must not do anything, including throwing errors
 d.update(b=[1, 2, f])
 d.update((('-1', {'a': 1}),))
 d.update({'0': -1})
@@ -135,6 +136,18 @@
 :py l=vim.bindeval('l')
 :py del l[-6:2]
 :$put =string(l)
+:let l = [0, 1, 2, 3]
+:py l=vim.bindeval('l')
+:py del l[::2]
+:$put =string(l)
+:let l = [0, 1, 2, 3]
+:py l=vim.bindeval('l')
+:py del l[3:0:-2]
+:$put =string(l)
+:let l = [0, 1, 2, 3]
+:py l=vim.bindeval('l')
+:py del l[2:4:-2]
+:$put =string(l)
 :"
 :" Slice assignment to a list
 :let l = [0, 1, 2, 3]
@@ -169,6 +182,26 @@
 :py l=vim.bindeval('l')
 :py l[0:0]=['h']
 :$put =string(l)
+:let l = range(8)
+:py l=vim.bindeval('l')
+:py l[2:6:2] = [10, 20]
+:$put =string(l)
+:let l = range(8)
+:py l=vim.bindeval('l')
+:py l[6:2:-2] = [10, 20]
+:$put =string(l)
+:let l = range(8)
+:py l=vim.bindeval('l')
+:py l[6:2] = ()
+:$put =string(l)
+:let l = range(8)
+:py l=vim.bindeval('l')
+:py l[6:2:1] = ()
+:$put =string(l)
+:let l = range(8)
+:py l=vim.bindeval('l')
+:py l[2:2:1] = ()
+:$put =string(l)
 :"
 :" Locked variables
 :let l = [0, 1, 2, 3]
@@ -179,6 +212,32 @@
 :unlockvar! l
 :"
 :" Function calls
+py << EOF
+import sys
+def ee(expr, g=globals(), l=locals()):
+    try:
+        exec(expr, g, l)
+    except:
+        ei = sys.exc_info()
+        msg = sys.exc_info()[0].__name__ + ':' + repr(sys.exc_info()[1].args)
+        msg = msg.replace('TypeError:(\'argument 1 ', 'TypeError:(\'')
+        if expr.find('None') > -1:
+            msg = msg.replace('TypeError:(\'iteration over non-sequence\',)',
+                              'TypeError:("\'NoneType\' object is not iterable",)')
+        if expr.find('FailingNumber') > -1:
+            msg = msg.replace(', not \'FailingNumber\'', '').replace('"', '\'')
+            msg = msg.replace('TypeError:(\'iteration over non-sequence\',)',
+                              'TypeError:("\'FailingNumber\' object is not iterable",)')
+        if msg.find('(\'\'') > -1 or msg.find('(\'can\'t') > -1:
+            msg = msg.replace('(\'', '("').replace('\',)', '",)')
+        if expr == 'fd(self=[])':
+            # HACK: PyMapping_Check changed meaning
+            msg = msg.replace('AttributeError:(\'keys\',)',
+                              'TypeError:(\'unable to convert list to vim dictionary\',)')
+        vim.current.buffer.append(expr + ':' + msg)
+    else:
+        vim.current.buffer.append(expr + ':NOT FAILED')
+EOF
 :fun New(...)
 :   return ['NewStart']+a:000+['NewEnd']
 :endfun
@@ -193,18 +252,10 @@
 :$put =string(l)
 :py l.extend([l[0].name])
 :$put =string(l)
-:try
-:   py l[1](1, 2, 3)
-:catch
-:   $put =v:exception[:16]
-:endtry
+:py ee('l[1](1, 2, 3)')
 :py f=l[0]
 :delfunction New
-:try
-:   py f(1, 2, 3)
-:catch
-:   $put =v:exception[:16]
-:endtry
+:py ee('f(1, 2, 3)')
 :if has('float')
 :   let l=[0.0]
 :   py l=vim.bindeval('l')
@@ -216,7 +267,6 @@
 :let messages=[]
 :delfunction DictNew
 py <<EOF
-import sys
 d=vim.bindeval('{}')
 m=vim.bindeval('messages')
 def em(expr, g=globals(), l=locals()):
@@ -323,6 +373,7 @@
 :py l[0] = t.t > 8  # check if the background thread is working
 :py del time
 :py del threading
+:py del t
 :$put =string(l)
 :"
 :" settrace
@@ -372,6 +423,13 @@
 :$put =string(pyeval('l'))
 :py l = ll[-10:10]
 :$put =string(pyeval('l'))
+:py l = ll[4:2:-1]
+:$put =string(pyeval('l'))
+:py l = ll[::2]
+:$put =string(pyeval('l'))
+:py l = ll[4:2:1]
+:$put =string(pyeval('l'))
+:py del l
 :"
 :" Vars
 :let g:foo = 'bac'
@@ -449,6 +507,11 @@
 :py bopts1=vim.buffers[vim.bindeval("g:bufs")[2]].options
 :py bopts2=vim.buffers[vim.bindeval("g:bufs")[1]].options
 :py bopts3=vim.buffers[vim.bindeval("g:bufs")[0]].options
+:$put ='wopts iters equal: '.pyeval('list(wopts1) == list(wopts2)')
+:$put ='bopts iters equal: '.pyeval('list(bopts1) == list(bopts2)')
+:py gset=set(iter(gopts1))
+:py wset=set(iter(wopts1))
+:py bset=set(iter(bopts1))
 :set path=.,..,,
 :let lst=[]
 :let lst+=[['paste',          1,     0,     1,     2,      1,    1,      0    ]]
@@ -479,6 +542,8 @@
 :       py oval3=bool(oval3)
 :   endif
 :   put ='>>> '.oname
+:   $put ='  g/w/b:'.pyeval('oname in gset').'/'.pyeval('oname in wset').'/'.pyeval('oname in bset')
+:   $put ='  g/w/b (in):'.pyeval('oname in gopts1').'/'.pyeval('oname in wopts1').'/'.pyeval('oname in bopts1')
 :   for v in ['gopts1', 'wopts1', 'bopts1']
 :       try
 :           put ='  p/'.v.': '.Ev('repr('.v.'['''.oname.'''])')
@@ -610,7 +675,7 @@
 # Check GCing iterator that was not fully exhausted
 i = iter(vim.buffers)
 cb.append('i:' + str(next(i)))
-# and also check creating more then one iterator at a time
+# and also check creating more than one iterator at a time
 i2 = iter(vim.buffers)
 cb.append('i2:' + str(next(i2)))
 cb.append('i:' + str(next(i)))
@@ -882,29 +947,6 @@
 :fun D()
 :endfun
 py << EOF
-def ee(expr, g=globals(), l=locals()):
-    try:
-        exec(expr, g, l)
-    except:
-        ei = sys.exc_info()
-        msg = sys.exc_info()[0].__name__ + ':' + repr(sys.exc_info()[1].args)
-        msg = msg.replace('TypeError:(\'argument 1 ', 'TypeError:(\'')
-        if expr.find('None') > -1:
-            msg = msg.replace('TypeError:(\'iteration over non-sequence\',)',
-                              'TypeError:("\'NoneType\' object is not iterable",)')
-        if expr.find('FailingNumber') > -1:
-            msg = msg.replace(', not \'FailingNumber\'', '').replace('"', '\'')
-            msg = msg.replace('TypeError:(\'iteration over non-sequence\',)',
-                              'TypeError:("\'FailingNumber\' object is not iterable",)')
-        if msg.find('(\'\'') > -1 or msg.find('(\'can\'t') > -1:
-            msg = msg.replace('(\'', '("').replace('\',)', '",)')
-        if expr == 'fd(self=[])':
-            # HACK: PyMapping_Check changed meaning
-            msg = msg.replace('AttributeError:(\'keys\',)',
-                              'TypeError:(\'unable to convert list to vim dictionary\',)')
-        cb.append(expr + ':' + msg)
-    else:
-        cb.append(expr + ':NOT FAILED')
 d = vim.Dictionary()
 ned = vim.Dictionary(foo='bar', baz='abcD')
 dl = vim.Dictionary(a=1)
@@ -912,6 +954,7 @@
 l = vim.List()
 ll = vim.List('abcE')
 ll.locked = True
+nel = vim.List('abcO')
 f = vim.Function('string')
 fd = vim.Function('F')
 fdel = vim.Function('D')
@@ -999,6 +1042,20 @@
     def next(self):
         raise NotImplementedError('next')
 
+class FailingIterNextN(object):
+    def __init__(self, n):
+        self.n = n
+
+    def __iter__(self):
+        return self
+
+    def next(self):
+        if self.n:
+            self.n -= 1
+            return 1
+        else:
+            raise NotImplementedError('next N')
+
 class FailingMappingKey(object):
     def __getitem__(self, item):
         raise NotImplementedError('getitem:mappingkey')
@@ -1073,6 +1130,13 @@
 ee('import failing')
 vim.options['rtp'] = old_rtp
 del old_rtp
+cb.append("> Options")
+cb.append(">> OptionsItem")
+ee('vim.options["abcQ"]')
+ee('vim.options[""]')
+stringtochars_test('vim.options[%s]')
+cb.append(">> OptionsContains")
+stringtochars_test('%s in vim.options')
 cb.append("> Dictionary")
 cb.append(">> DictionaryConstructor")
 ee('vim.Dictionary("abcI")')
@@ -1088,6 +1152,9 @@
 stringtochars_test('d.get(%s)')
 ee('d.pop("a")')
 ee('dl.pop("a")')
+cb.append(">> DictionaryContains")
+ee('"" in d')
+ee('0 in d')
 cb.append(">> DictionaryIterNext")
 ee('for i in ned: ned["a"] = 1')
 del i
@@ -1100,6 +1167,7 @@
 cb.append(">>> iter")
 ee('d.update(FailingMapping())')
 ee('d.update([FailingIterNext()])')
+ee('d.update([FailingIterNextN(1)])')
 iter_test('d.update(%s)')
 convertfrompyobject_test('d.update(%s)')
 stringtochars_test('d.update(((%s, 0),))')
@@ -1122,6 +1190,14 @@
 cb.append(">> ListAssSlice")
 ee('ll[1:100] = "abcJ"')
 iter_test('l[:] = %s')
+ee('nel[1:10:2]  = "abcK"')
+cb.append(repr(tuple(nel)))
+ee('nel[1:10:2]  = "a"')
+cb.append(repr(tuple(nel)))
+ee('nel[1:1:-1]  = "a"')
+cb.append(repr(tuple(nel)))
+ee('nel[:] = FailingIterNextN(2)')
+cb.append(repr(tuple(nel)))
 convertfrompyobject_test('l[:] = [%s]')
 cb.append(">> ListConcatInPlace")
 iter_test('l.extend(%s)')
@@ -1203,6 +1279,7 @@
 del dl
 del l
 del ll
+del nel
 del f
 del fd
 del fdel
@@ -1216,6 +1293,7 @@
 del FailingTrue
 del FailingIter
 del FailingIterNext
+del FailingIterNextN
 del FailingMapping
 del FailingMappingKey
 del FailingList
@@ -1273,11 +1351,44 @@
 ee('vim.eval("Exe(\'throw \'\'ghi\'\'\')")')
 ee('vim.eval("Exe(\'echoerr \'\'jkl\'\'\')")')
 ee('vim.eval("Exe(\'xxx_non_existent_command_xxx\')")')
+ee('vim.eval("xxx_unknown_function_xxx()")')
 ee('vim.bindeval("Exe(\'xxx_non_existent_command_xxx\')")')
 del Exe
 EOF
 :delfunction Exe
 :"
+:" Regression: interrupting vim.command propagates to next vim.command
+py << EOF
+def test_keyboard_interrupt():
+    try:
+        vim.command('while 1 | endwhile')
+    except KeyboardInterrupt:
+        cb.append('Caught KeyboardInterrupt')
+    except Exception:
+        cb.append('!!!!!!!! Caught exception: ' + repr(sys.exc_info))
+    else:
+        cb.append('!!!!!!!! No exception')
+    try:
+        vim.command('$ put =\'Running :put\'')
+    except KeyboardInterrupt:
+        cb.append('!!!!!!!! Caught KeyboardInterrupt')
+    except Exception:
+        cb.append('!!!!!!!! Caught exception: ' + repr(sys.exc_info))
+    else:
+        cb.append('No exception')
+EOF
+:debuggreedy
+:call inputsave()
+:call feedkeys("s\ns\ns\ns\nq\n")
+:redir => output
+:debug silent! py test_keyboard_interrupt()
+:redir END
+:0 debuggreedy
+:call inputrestore()
+:silent $put =output
+:unlet output
+:py del test_keyboard_interrupt
+:"
 :" Cleanup
 py << EOF
 del cb
diff -Naur vim74.orig/src/testdir/test86.ok vim74/src/testdir/test86.ok
--- vim74.orig/src/testdir/test86.ok	2013-06-23 14:38:39.000000000 +0000
+++ vim74/src/testdir/test86.ok	2014-10-10 14:53:45.748710354 +0000
@@ -41,6 +41,9 @@
 [2, 3]
 [2, 3]
 [2, 3]
+[1, 3]
+[0, 2]
+[0, 1, 2, 3]
 ['a', 0, 1, 2, 3]
 [0, 'b', 2, 3]
 [0, 1, 'c']
@@ -49,12 +52,17 @@
 ['f', 2, 3]
 [0, 1, 'g', 2, 3]
 ['h']
+[0, 1, 10, 3, 20, 5, 6, 7]
+[0, 1, 2, 3, 20, 5, 10, 7]
+[0, 1, 2, 3, 4, 5, 6, 7]
+[0, 1, 2, 3, 4, 5, 6, 7]
+[0, 1, 2, 3, 4, 5, 6, 7]
 [0, 1, 2, 3]
 [function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd']
 [function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd', 'DictNewStart', 1, 2, 3, 'DictNewEnd', {'a': 'b'}]
 [function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd', 'DictNewStart', 1, 2, 3, 'DictNewEnd', {'a': 'b'}, 'New']
-Vim(python):E725:
-Vim(python):E117:
+l[1](1, 2, 3):error:('Vim:E725: Calling dict function without Dictionary: DictNew',)
+f(1, 2, 3):error:('Vim:E117: Unknown function: New',)
 [0.0, 0.0]
 KeyError
 TypeError
@@ -96,12 +104,19 @@
 [0, 1, 2, 3, 4, 5]
 [0, 1, 2, 3, 4, 5]
 [0, 1, 2, 3, 4, 5]
+[4, 3]
+[0, 2, 4]
+[]
 Abc
 bac
 def
 bar
 jkl
+wopts iters equal: 1
+bopts iters equal: 1
 >>> paste
+  g/w/b:1/0/0
+  g/w/b (in):1/0/0
   p/gopts1: False
   p/wopts1! KeyError
   inv: 2! KeyError
@@ -122,6 +137,8 @@
   W: 1:1 2:1 3:1 4:1
   B: 1:1 2:1 3:1 4:1
 >>> previewheight
+  g/w/b:1/0/0
+  g/w/b (in):1/0/0
   p/gopts1: 12
   inv: 'a'! TypeError
   p/wopts1! KeyError
@@ -143,6 +160,8 @@
   W: 1:5 2:5 3:5 4:5
   B: 1:5 2:5 3:5 4:5
 >>> operatorfunc
+  g/w/b:1/0/0
+  g/w/b (in):1/0/0
   p/gopts1: ''
   inv: 2! TypeError
   p/wopts1! KeyError
@@ -164,6 +183,8 @@
   W: 1:'A' 2:'A' 3:'A' 4:'A'
   B: 1:'A' 2:'A' 3:'A' 4:'A'
 >>> number
+  g/w/b:0/1/0
+  g/w/b (in):0/1/0
   p/gopts1! KeyError
   inv: 0! KeyError
   gopts1! KeyError
@@ -182,6 +203,8 @@
   W: 1:1 2:1 3:0 4:0
   B: 1:1 2:1 3:0 4:0
 >>> numberwidth
+  g/w/b:0/1/0
+  g/w/b (in):0/1/0
   p/gopts1! KeyError
   inv: -100! KeyError
   gopts1! KeyError
@@ -201,6 +224,8 @@
   W: 1:3 2:5 3:2 4:8
   B: 1:3 2:5 3:2 4:8
 >>> colorcolumn
+  g/w/b:0/1/0
+  g/w/b (in):0/1/0
   p/gopts1! KeyError
   inv: 'abc4'! KeyError
   gopts1! KeyError
@@ -220,6 +245,8 @@
   W: 1:'+2' 2:'+3' 3:'+1' 4:''
   B: 1:'+2' 2:'+3' 3:'+1' 4:''
 >>> statusline
+  g/w/b:1/1/0
+  g/w/b (in):1/1/0
   p/gopts1: ''
   inv: 0! TypeError
   p/wopts1: None
@@ -237,6 +264,8 @@
   W: 1:'2' 2:'1' 3:'1' 4:'1'
   B: 1:'2' 2:'1' 3:'1' 4:'1'
 >>> autoindent
+  g/w/b:0/0/1
+  g/w/b (in):0/0/1
   p/gopts1! KeyError
   inv: 2! KeyError
   gopts1! KeyError
@@ -255,6 +284,8 @@
   W: 1:0 2:1 3:0 4:1
   B: 1:0 2:1 3:0 4:1
 >>> shiftwidth
+  g/w/b:0/0/1
+  g/w/b (in):0/0/1
   p/gopts1! KeyError
   inv: 3! KeyError
   gopts1! KeyError
@@ -273,6 +304,8 @@
   W: 1:0 2:2 3:8 4:1
   B: 1:0 2:2 3:8 4:1
 >>> omnifunc
+  g/w/b:0/0/1
+  g/w/b (in):0/0/1
   p/gopts1! KeyError
   inv: 1! KeyError
   gopts1! KeyError
@@ -292,6 +325,8 @@
   W: 1:'A' 2:'B' 3:'' 4:'C'
   B: 1:'A' 2:'B' 3:'' 4:'C'
 >>> preserveindent
+  g/w/b:0/0/1
+  g/w/b (in):0/0/1
   p/gopts1! KeyError
   inv: 2! KeyError
   gopts1! KeyError
@@ -310,6 +345,8 @@
   W: 1:0 2:1 3:0 4:1
   B: 1:0 2:1 3:0 4:1
 >>> path
+  g/w/b:1/0/1
+  g/w/b (in):1/0/1
   p/gopts1: '.,..,,'
   inv: 0! TypeError
   p/wopts1! KeyError
@@ -498,6 +535,21 @@
 import xxx_no_such_module_xxx:ImportError:('No module named xxx_no_such_module_xxx',)
 import failing_import:ImportError:('No module named failing_import',)
 import failing:NotImplementedError:()
+> Options
+>> OptionsItem
+vim.options["abcQ"]:KeyError:('abcQ',)
+vim.options[""]:ValueError:('empty keys are not allowed',)
+>>> Testing StringToChars using vim.options[%s]
+vim.options[1]:TypeError:('expected str() or unicode() instance, but got int',)
+vim.options[u"\0"]:TypeError:('expected string without null bytes',)
+vim.options["\0"]:TypeError:('expected string without null bytes',)
+<<< Finished
+>> OptionsContains
+>>> Testing StringToChars using %s in vim.options
+1 in vim.options:TypeError:('expected str() or unicode() instance, but got int',)
+u"\0" in vim.options:TypeError:('expected string without null bytes',)
+"\0" in vim.options:TypeError:('expected string without null bytes',)
+<<< Finished
 > Dictionary
 >> DictionaryConstructor
 vim.Dictionary("abcI"):ValueError:('expected sequence element of size 2, but got sequence of size 1',)
@@ -516,6 +568,9 @@
 <<< Finished
 d.pop("a"):KeyError:('a',)
 dl.pop("a"):error:('dictionary is locked',)
+>> DictionaryContains
+"" in d:ValueError:('empty keys are not allowed',)
+0 in d:TypeError:('expected str() or unicode() instance, but got int',)
 >> DictionaryIterNext
 for i in ned: ned["a"] = 1:RuntimeError:('hashtab changed during iteration',)
 >> DictionaryAssItem
@@ -596,6 +651,7 @@
 >>> iter
 d.update(FailingMapping()):NotImplementedError:('keys',)
 d.update([FailingIterNext()]):NotImplementedError:('next',)
+d.update([FailingIterNextN(1)]):NotImplementedError:('next N',)
 >>> Testing *Iter* using d.update(%s)
 d.update(FailingIter()):NotImplementedError:('iter',)
 d.update(FailingIterNext()):NotImplementedError:('next',)
@@ -826,6 +882,14 @@
 l[:] = FailingIter():NotImplementedError:('iter',)
 l[:] = FailingIterNext():NotImplementedError:('next',)
 <<< Finished
+nel[1:10:2]  = "abcK":ValueError:('attempt to assign sequence of size greater than 2 to extended slice',)
+('a', 'b', 'c', 'O')
+nel[1:10:2]  = "a":ValueError:('attempt to assign sequence of size 1 to extended slice of size 2',)
+('a', 'b', 'c', 'O')
+nel[1:1:-1]  = "a":ValueError:('attempt to assign sequence of size greater than 0 to extended slice',)
+('a', 'b', 'c', 'O')
+nel[:] = FailingIterNextN(2):NotImplementedError:('next N',)
+('a', 'b', 'c', 'O')
 >>> Testing StringToChars using l[:] = [{%s : 1}]
 l[:] = [{1 : 1}]:TypeError:('expected str() or unicode() instance, but got int',)
 l[:] = [{u"\0" : 1}]:TypeError:('expected string without null bytes',)
@@ -1169,8 +1233,8 @@
 >>> Testing NumberToLong using vim.buffers[%s]
 vim.buffers[[]]:TypeError:('expected int(), long() or something supporting coercing to long(), but got list',)
 vim.buffers[None]:TypeError:('expected int(), long() or something supporting coercing to long(), but got NoneType',)
-vim.buffers[-1]:ValueError:('number must be greater then zero',)
-vim.buffers[0]:ValueError:('number must be greater then zero',)
+vim.buffers[-1]:ValueError:('number must be greater than zero',)
+vim.buffers[0]:ValueError:('number must be greater than zero',)
 <<< Finished
 > Current
 >> CurrentGetattr
@@ -1194,4 +1258,9 @@
 vim.eval("Exe('throw ''ghi''')"):error:('ghi',)
 vim.eval("Exe('echoerr ''jkl''')"):error:('Vim(echoerr):jkl',)
 vim.eval("Exe('xxx_non_existent_command_xxx')"):error:('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',)
+vim.eval("xxx_unknown_function_xxx()"):error:('Vim:E117: Unknown function: xxx_unknown_function_xxx',)
 vim.bindeval("Exe('xxx_non_existent_command_xxx')"):error:('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',)
+Caught KeyboardInterrupt
+Running :put
+No exception
+
diff -Naur vim74.orig/src/testdir/test87.in vim74/src/testdir/test87.in
--- vim74.orig/src/testdir/test87.in	2013-07-06 11:41:30.000000000 +0000
+++ vim74/src/testdir/test87.in	2014-10-10 14:53:45.752043679 +0000
@@ -33,6 +33,7 @@
 py3 << EOF
 d=vim.bindeval('d')
 d['1']='asd'
+d.update()  # Must not do anything, including throwing errors
 d.update(b=[1, 2, f])
 d.update((('-1', {'a': 1}),))
 d.update({'0': -1})
@@ -128,6 +129,18 @@
 :py3 l=vim.bindeval('l')
 :py3 del l[-6:2]
 :$put =string(l)
+:let l = [0, 1, 2, 3]
+:py3 l=vim.bindeval('l')
+:py3 del l[::2]
+:$put =string(l)
+:let l = [0, 1, 2, 3]
+:py3 l=vim.bindeval('l')
+:py3 del l[3:0:-2]
+:$put =string(l)
+:let l = [0, 1, 2, 3]
+:py3 l=vim.bindeval('l')
+:py3 del l[2:4:-2]
+:$put =string(l)
 :"
 :" Slice assignment to a list
 :let l = [0, 1, 2, 3]
@@ -162,6 +175,26 @@
 :py3 l=vim.bindeval('l')
 :py3 l[0:0]=['h']
 :$put =string(l)
+:let l = range(8)
+:py3 l=vim.bindeval('l')
+:py3 l[2:6:2] = [10, 20]
+:$put =string(l)
+:let l = range(8)
+:py3 l=vim.bindeval('l')
+:py3 l[6:2:-2] = [10, 20]
+:$put =string(l)
+:let l = range(8)
+:py3 l=vim.bindeval('l')
+:py3 l[6:2] = ()
+:$put =string(l)
+:let l = range(8)
+:py3 l=vim.bindeval('l')
+:py3 l[6:2:1] = ()
+:$put =string(l)
+:let l = range(8)
+:py3 l=vim.bindeval('l')
+:py3 l[2:2:1] = ()
+:$put =string(l)
 :"
 :" Locked variables
 :let l = [0, 1, 2, 3]
@@ -172,6 +205,36 @@
 :unlockvar! l
 :"
 :" Function calls
+py3 << EOF
+import sys
+import re
+
+py33_type_error_pattern = re.compile('^__call__\(\) takes (\d+) positional argument but (\d+) were given$')
+
+def ee(expr, g=globals(), l=locals()):
+    cb = vim.current.buffer
+    try:
+        try:
+            exec(expr, g, l)
+        except Exception as e:
+            if sys.version_info >= (3, 3) and e.__class__ is AttributeError and str(e).find('has no attribute')>=0 and not str(e).startswith("'vim."):
+                cb.append(expr + ':' + repr((e.__class__, AttributeError(str(e)[str(e).rfind(" '") + 2:-1]))))
+            elif sys.version_info >= (3, 3) and e.__class__ is ImportError and str(e).find('No module named \'') >= 0:
+                cb.append(expr + ':' + repr((e.__class__, ImportError(str(e).replace("'", '')))))
+            elif sys.version_info >= (3, 3) and e.__class__ is TypeError:
+                m = py33_type_error_pattern.search(str(e))
+                if m:
+                    msg = '__call__() takes exactly {0} positional argument ({1} given)'.format(m.group(1), m.group(2))
+                    cb.append(expr + ':' + repr((e.__class__, TypeError(msg))))
+                else:
+                    cb.append(expr + ':' + repr((e.__class__, e)))
+            else:
+                cb.append(expr + ':' + repr((e.__class__, e)))
+        else:
+            cb.append(expr + ':NOT FAILED')
+    except Exception as e:
+        cb.append(expr + '::' + repr((e.__class__, e)))
+EOF
 :fun New(...)
 :   return ['NewStart']+a:000+['NewEnd']
 :endfun
@@ -186,18 +249,10 @@
 :$put =string(l)
 :py3 l+=[l[0].name]
 :$put =string(l)
-:try
-:   py3 l[1](1, 2, 3)
-:catch
-:   $put =v:exception[:13]
-:endtry
+:py3 ee('l[1](1, 2, 3)')
 :py3 f=l[0]
 :delfunction New
-:try
-:   py3 f(1, 2, 3)
-:catch
-:   $put =v:exception[:13]
-:endtry
+:py3 ee('f(1, 2, 3)')
 :if has('float')
 :   let l=[0.0]
 :   py3 l=vim.bindeval('l')
@@ -315,6 +370,7 @@
 :py3 l[0] = t.t > 8  # check if the background thread is working
 :py3 del time
 :py3 del threading
+:py3 del t
 :$put =string(l)
 :"
 :" settrace
@@ -340,6 +396,38 @@
 :py3 del trace_main
 :$put =string(l)
 :"
+:" Slice
+:py3 ll = vim.bindeval('[0, 1, 2, 3, 4, 5]')
+:py3 l = ll[:4]
+:$put =string(py3eval('l'))
+:py3 l = ll[2:]
+:$put =string(py3eval('l'))
+:py3 l = ll[:-4]
+:$put =string(py3eval('l'))
+:py3 l = ll[-2:]
+:$put =string(py3eval('l'))
+:py3 l = ll[2:4]
+:$put =string(py3eval('l'))
+:py3 l = ll[4:2]
+:$put =string(py3eval('l'))
+:py3 l = ll[-4:-2]
+:$put =string(py3eval('l'))
+:py3 l = ll[-2:-4]
+:$put =string(py3eval('l'))
+:py3 l = ll[:]
+:$put =string(py3eval('l'))
+:py3 l = ll[0:6]
+:$put =string(py3eval('l'))
+:py3 l = ll[-10:10]
+:$put =string(py3eval('l'))
+:py3 l = ll[4:2:-1]
+:$put =string(py3eval('l'))
+:py3 l = ll[::2]
+:$put =string(py3eval('l'))
+:py3 l = ll[4:2:1]
+:$put =string(py3eval('l'))
+:py3 del l
+:"
 :" Vars
 :let g:foo = 'bac'
 :let w:abc3 = 'def'
@@ -416,6 +504,11 @@
 :py3 bopts1=vim.buffers[vim.bindeval("g:bufs")[2]].options
 :py3 bopts2=vim.buffers[vim.bindeval("g:bufs")[1]].options
 :py3 bopts3=vim.buffers[vim.bindeval("g:bufs")[0]].options
+:$put ='wopts iters equal: '.py3eval('list(wopts1) == list(wopts2)')
+:$put ='bopts iters equal: '.py3eval('list(bopts1) == list(bopts2)')
+:py3 gset=set(iter(gopts1))
+:py3 wset=set(iter(wopts1))
+:py3 bset=set(iter(bopts1))
 :set path=.,..,,
 :let lst=[]
 :let lst+=[['paste',          1,     0,     1,     2,      1,    1,      0    ]]
@@ -446,6 +539,8 @@
 :       py3 oval3=bool(oval3)
 :   endif
 :   put ='>>> '.oname
+:   $put ='  g/w/b:'.py3eval('oname in gset').'/'.py3eval('oname in wset').'/'.py3eval('oname in bset')
+:   $put ='  g/w/b (in):'.py3eval('oname in gopts1').'/'.py3eval('oname in wopts1').'/'.py3eval('oname in bopts1')
 :   for v in ['gopts1', 'wopts1', 'bopts1']
 :       try
 :           put ='  p/'.v.': '.Ev('repr('.v.'['''.oname.'''])')
@@ -569,7 +664,7 @@
 # Check GCing iterator that was not fully exhausted
 i = iter(vim.buffers)
 cb.append('i:' + str(next(i)))
-# and also check creating more then one iterator at a time
+# and also check creating more than one iterator at a time
 i2 = iter(vim.buffers)
 cb.append('i2:' + str(next(i2)))
 cb.append('i:' + str(next(i)))
@@ -829,33 +924,6 @@
 :fun D()
 :endfun
 py3 << EOF
-import re
-
-py33_type_error_pattern = re.compile('^__call__\(\) takes (\d+) positional argument but (\d+) were given$')
-
-def ee(expr, g=globals(), l=locals()):
-    try:
-        try:
-            exec(expr, g, l)
-        except Exception as e:
-            if sys.version_info >= (3, 3) and e.__class__ is AttributeError and str(e).find('has no attribute')>=0 and not str(e).startswith("'vim."):
-                cb.append(expr + ':' + repr((e.__class__, AttributeError(str(e)[str(e).rfind(" '") + 2:-1]))))
-            elif sys.version_info >= (3, 3) and e.__class__ is ImportError and str(e).find('No module named \'') >= 0:
-                cb.append(expr + ':' + repr((e.__class__, ImportError(str(e).replace("'", '')))))
-            elif sys.version_info >= (3, 3) and e.__class__ is TypeError:
-                m = py33_type_error_pattern.search(str(e))
-                if m:
-                    msg = '__call__() takes exactly {0} positional argument ({1} given)'.format(m.group(1), m.group(2))
-                    cb.append(expr + ':' + repr((e.__class__, TypeError(msg))))
-                else:
-                    cb.append(expr + ':' + repr((e.__class__, e)))
-            else:
-                cb.append(expr + ':' + repr((e.__class__, e)))
-        else:
-            cb.append(expr + ':NOT FAILED')
-    except Exception as e:
-        cb.append(expr + '::' + repr((e.__class__, e)))
-
 d = vim.Dictionary()
 ned = vim.Dictionary(foo='bar', baz='abcD')
 dl = vim.Dictionary(a=1)
@@ -863,6 +931,7 @@
 l = vim.List()
 ll = vim.List('abcE')
 ll.locked = True
+nel = vim.List('abcO')
 f = vim.Function('string')
 fd = vim.Function('F')
 fdel = vim.Function('D')
@@ -950,6 +1019,20 @@
     def __next__(self):
         raise NotImplementedError('next')
 
+class FailingIterNextN(object):
+    def __init__(self, n):
+        self.n = n
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        if self.n:
+            self.n -= 1
+            return 1
+        else:
+            raise NotImplementedError('next N')
+
 class FailingMappingKey(object):
     def __getitem__(self, item):
         raise NotImplementedError('getitem:mappingkey')
@@ -1024,6 +1107,13 @@
 ee('import failing')
 vim.options['rtp'] = old_rtp
 del old_rtp
+cb.append("> Options")
+cb.append(">> OptionsItem")
+ee('vim.options["abcQ"]')
+ee('vim.options[""]')
+stringtochars_test('vim.options[%s]')
+cb.append(">> OptionsContains")
+stringtochars_test('%s in vim.options')
 cb.append("> Dictionary")
 cb.append(">> DictionaryConstructor")
 ee('vim.Dictionary("abcI")')
@@ -1039,6 +1129,9 @@
 stringtochars_test('d.get(%s)')
 ee('d.pop("a")')
 ee('dl.pop("a")')
+cb.append(">> DictionaryContains")
+ee('"" in d')
+ee('0 in d')
 cb.append(">> DictionaryIterNext")
 ee('for i in ned: ned["a"] = 1')
 del i
@@ -1051,6 +1144,7 @@
 cb.append(">>> iter")
 ee('d.update(FailingMapping())')
 ee('d.update([FailingIterNext()])')
+ee('d.update([FailingIterNextN(1)])')
 iter_test('d.update(%s)')
 convertfrompyobject_test('d.update(%s)')
 stringtochars_test('d.update(((%s, 0),))')
@@ -1073,6 +1167,14 @@
 cb.append(">> ListAssSlice")
 ee('ll[1:100] = "abcJ"')
 iter_test('l[:] = %s')
+ee('nel[1:10:2]  = "abcK"')
+cb.append(repr(tuple(nel)))
+ee('nel[1:10:2]  = "a"')
+cb.append(repr(tuple(nel)))
+ee('nel[1:1:-1]  = "a"')
+cb.append(repr(tuple(nel)))
+ee('nel[:] = FailingIterNextN(2)')
+cb.append(repr(tuple(nel)))
 convertfrompyobject_test('l[:] = [%s]')
 cb.append(">> ListConcatInPlace")
 iter_test('l.extend(%s)')
@@ -1154,6 +1256,7 @@
 del dl
 del l
 del ll
+del nel
 del f
 del fd
 del fdel
@@ -1167,6 +1270,7 @@
 del FailingTrue
 del FailingIter
 del FailingIterNext
+del FailingIterNextN
 del FailingMapping
 del FailingMappingKey
 del FailingList
@@ -1224,11 +1328,44 @@
 ee('vim.eval("Exe(\'throw \'\'ghi\'\'\')")')
 ee('vim.eval("Exe(\'echoerr \'\'jkl\'\'\')")')
 ee('vim.eval("Exe(\'xxx_non_existent_command_xxx\')")')
+ee('vim.eval("xxx_unknown_function_xxx()")')
 ee('vim.bindeval("Exe(\'xxx_non_existent_command_xxx\')")')
 del Exe
 EOF
 :delfunction Exe
 :"
+:" Regression: interrupting vim.command propagates to next vim.command
+py3 << EOF
+def test_keyboard_interrupt():
+    try:
+        vim.command('while 1 | endwhile')
+    except KeyboardInterrupt:
+        cb.append('Caught KeyboardInterrupt')
+    except Exception as e:
+        cb.append('!!!!!!!! Caught exception: ' + repr(e))
+    else:
+        cb.append('!!!!!!!! No exception')
+    try:
+        vim.command('$ put =\'Running :put\'')
+    except KeyboardInterrupt:
+        cb.append('!!!!!!!! Caught KeyboardInterrupt')
+    except Exception as e:
+        cb.append('!!!!!!!! Caught exception: ' + repr(e))
+    else:
+        cb.append('No exception')
+EOF
+:debuggreedy
+:call inputsave()
+:call feedkeys("s\ns\ns\ns\nq\n")
+:redir => output
+:debug silent! py3 test_keyboard_interrupt()
+:redir END
+:0 debuggreedy
+:call inputrestore()
+:silent $put =output
+:unlet output
+:py3 del test_keyboard_interrupt
+:"
 :" Cleanup
 py3 << EOF
 del cb
diff -Naur vim74.orig/src/testdir/test87.ok vim74/src/testdir/test87.ok
--- vim74.orig/src/testdir/test87.ok	2013-06-23 14:38:39.000000000 +0000
+++ vim74/src/testdir/test87.ok	2014-10-10 14:53:45.755377004 +0000
@@ -41,6 +41,9 @@
 [2, 3]
 [2, 3]
 [2, 3]
+[1, 3]
+[0, 2]
+[0, 1, 2, 3]
 ['a', 0, 1, 2, 3]
 [0, 'b', 2, 3]
 [0, 1, 'c']
@@ -49,12 +52,17 @@
 ['f', 2, 3]
 [0, 1, 'g', 2, 3]
 ['h']
+[0, 1, 10, 3, 20, 5, 6, 7]
+[0, 1, 2, 3, 20, 5, 10, 7]
+[0, 1, 2, 3, 4, 5, 6, 7]
+[0, 1, 2, 3, 4, 5, 6, 7]
+[0, 1, 2, 3, 4, 5, 6, 7]
 [0, 1, 2, 3]
 [function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd']
 [function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd', 'DictNewStart', 1, 2, 3, 'DictNewEnd', {'a': 'b'}]
 [function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd', 'DictNewStart', 1, 2, 3, 'DictNewEnd', {'a': 'b'}, 'New']
-Vim(py3):E725:
-Vim(py3):E117:
+l[1](1, 2, 3):(<class 'vim.error'>, error('Vim:E725: Calling dict function without Dictionary: DictNew',))
+f(1, 2, 3):(<class 'vim.error'>, error('Vim:E117: Unknown function: New',))
 [0.0, 0.0]
 KeyError
 TypeError
@@ -85,12 +93,30 @@
 vim:	Vim(let):E859:
 [1]
 [1, 10, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 1]
+[0, 1, 2, 3]
+[2, 3, 4, 5]
+[0, 1]
+[4, 5]
+[2, 3]
+[]
+[2, 3]
+[]
+[0, 1, 2, 3, 4, 5]
+[0, 1, 2, 3, 4, 5]
+[0, 1, 2, 3, 4, 5]
+[4, 3]
+[0, 2, 4]
+[]
 Abc
 bac
 def
 bar
 jkl
+wopts iters equal: 1
+bopts iters equal: 1
 >>> paste
+  g/w/b:1/0/0
+  g/w/b (in):1/0/0
   p/gopts1: False
   p/wopts1! KeyError
   inv: 2! KeyError
@@ -111,6 +137,8 @@
   W: 1:1 2:1 3:1 4:1
   B: 1:1 2:1 3:1 4:1
 >>> previewheight
+  g/w/b:1/0/0
+  g/w/b (in):1/0/0
   p/gopts1: 12
   inv: 'a'! TypeError
   p/wopts1! KeyError
@@ -132,6 +160,8 @@
   W: 1:5 2:5 3:5 4:5
   B: 1:5 2:5 3:5 4:5
 >>> operatorfunc
+  g/w/b:1/0/0
+  g/w/b (in):1/0/0
   p/gopts1: b''
   inv: 2! TypeError
   p/wopts1! KeyError
@@ -153,6 +183,8 @@
   W: 1:'A' 2:'A' 3:'A' 4:'A'
   B: 1:'A' 2:'A' 3:'A' 4:'A'
 >>> number
+  g/w/b:0/1/0
+  g/w/b (in):0/1/0
   p/gopts1! KeyError
   inv: 0! KeyError
   gopts1! KeyError
@@ -171,6 +203,8 @@
   W: 1:1 2:1 3:0 4:0
   B: 1:1 2:1 3:0 4:0
 >>> numberwidth
+  g/w/b:0/1/0
+  g/w/b (in):0/1/0
   p/gopts1! KeyError
   inv: -100! KeyError
   gopts1! KeyError
@@ -190,6 +224,8 @@
   W: 1:3 2:5 3:2 4:8
   B: 1:3 2:5 3:2 4:8
 >>> colorcolumn
+  g/w/b:0/1/0
+  g/w/b (in):0/1/0
   p/gopts1! KeyError
   inv: 'abc4'! KeyError
   gopts1! KeyError
@@ -209,6 +245,8 @@
   W: 1:'+2' 2:'+3' 3:'+1' 4:''
   B: 1:'+2' 2:'+3' 3:'+1' 4:''
 >>> statusline
+  g/w/b:1/1/0
+  g/w/b (in):1/1/0
   p/gopts1: b''
   inv: 0! TypeError
   p/wopts1: None
@@ -226,6 +264,8 @@
   W: 1:'2' 2:'1' 3:'1' 4:'1'
   B: 1:'2' 2:'1' 3:'1' 4:'1'
 >>> autoindent
+  g/w/b:0/0/1
+  g/w/b (in):0/0/1
   p/gopts1! KeyError
   inv: 2! KeyError
   gopts1! KeyError
@@ -244,6 +284,8 @@
   W: 1:0 2:1 3:0 4:1
   B: 1:0 2:1 3:0 4:1
 >>> shiftwidth
+  g/w/b:0/0/1
+  g/w/b (in):0/0/1
   p/gopts1! KeyError
   inv: 3! KeyError
   gopts1! KeyError
@@ -262,6 +304,8 @@
   W: 1:0 2:2 3:8 4:1
   B: 1:0 2:2 3:8 4:1
 >>> omnifunc
+  g/w/b:0/0/1
+  g/w/b (in):0/0/1
   p/gopts1! KeyError
   inv: 1! KeyError
   gopts1! KeyError
@@ -281,6 +325,8 @@
   W: 1:'A' 2:'B' 3:'' 4:'C'
   B: 1:'A' 2:'B' 3:'' 4:'C'
 >>> preserveindent
+  g/w/b:0/0/1
+  g/w/b (in):0/0/1
   p/gopts1! KeyError
   inv: 2! KeyError
   gopts1! KeyError
@@ -299,6 +345,8 @@
   W: 1:0 2:1 3:0 4:1
   B: 1:0 2:1 3:0 4:1
 >>> path
+  g/w/b:1/0/1
+  g/w/b (in):1/0/1
   p/gopts1: b'.,..,,'
   inv: 0! TypeError
   p/wopts1! KeyError
@@ -487,6 +535,21 @@
 import xxx_no_such_module_xxx:(<class 'ImportError'>, ImportError('No module named xxx_no_such_module_xxx',))
 import failing_import:(<class 'ImportError'>, ImportError('No module named failing_import',))
 import failing:(<class 'NotImplementedError'>, NotImplementedError())
+> Options
+>> OptionsItem
+vim.options["abcQ"]:(<class 'KeyError'>, KeyError('abcQ',))
+vim.options[""]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
+>>> Testing StringToChars using vim.options[%s]
+vim.options[1]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
+vim.options[b"\0"]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
+vim.options["\0"]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
+<<< Finished
+>> OptionsContains
+>>> Testing StringToChars using %s in vim.options
+1 in vim.options:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
+b"\0" in vim.options:(<class 'TypeError'>, TypeError('expected bytes with no null',))
+"\0" in vim.options:(<class 'TypeError'>, TypeError('expected bytes with no null',))
+<<< Finished
 > Dictionary
 >> DictionaryConstructor
 vim.Dictionary("abcI"):(<class 'ValueError'>, ValueError('expected sequence element of size 2, but got sequence of size 1',))
@@ -505,6 +568,9 @@
 <<< Finished
 d.pop("a"):(<class 'KeyError'>, KeyError('a',))
 dl.pop("a"):(<class 'vim.error'>, error('dictionary is locked',))
+>> DictionaryContains
+"" in d:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
+0 in d:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
 >> DictionaryIterNext
 for i in ned: ned["a"] = 1:(<class 'RuntimeError'>, RuntimeError('hashtab changed during iteration',))
 >> DictionaryAssItem
@@ -585,6 +651,7 @@
 >>> iter
 d.update(FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError('keys',))
 d.update([FailingIterNext()]):(<class 'NotImplementedError'>, NotImplementedError('next',))
+d.update([FailingIterNextN(1)]):(<class 'NotImplementedError'>, NotImplementedError('next N',))
 >>> Testing *Iter* using d.update(%s)
 d.update(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError('iter',))
 d.update(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError('next',))
@@ -815,6 +882,14 @@
 l[:] = FailingIter():(<class 'NotImplementedError'>, NotImplementedError('iter',))
 l[:] = FailingIterNext():(<class 'NotImplementedError'>, NotImplementedError('next',))
 <<< Finished
+nel[1:10:2]  = "abcK":(<class 'ValueError'>, ValueError('attempt to assign sequence of size greater than 2 to extended slice',))
+(b'a', b'b', b'c', b'O')
+nel[1:10:2]  = "a":(<class 'ValueError'>, ValueError('attempt to assign sequence of size 1 to extended slice of size 2',))
+(b'a', b'b', b'c', b'O')
+nel[1:1:-1]  = "a":(<class 'ValueError'>, ValueError('attempt to assign sequence of size greater than 0 to extended slice',))
+(b'a', b'b', b'c', b'O')
+nel[:] = FailingIterNextN(2):(<class 'NotImplementedError'>, NotImplementedError('next N',))
+(b'a', b'b', b'c', b'O')
 >>> Testing StringToChars using l[:] = [{%s : 1}]
 l[:] = [{1 : 1}]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
 l[:] = [{b"\0" : 1}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
@@ -1158,8 +1233,8 @@
 >>> Testing NumberToLong using vim.buffers[%s]
 vim.buffers[[]]:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got list',))
 vim.buffers[None]:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got NoneType',))
-vim.buffers[-1]:(<class 'ValueError'>, ValueError('number must be greater then zero',))
-vim.buffers[0]:(<class 'ValueError'>, ValueError('number must be greater then zero',))
+vim.buffers[-1]:(<class 'ValueError'>, ValueError('number must be greater than zero',))
+vim.buffers[0]:(<class 'ValueError'>, ValueError('number must be greater than zero',))
 <<< Finished
 > Current
 >> CurrentGetattr
@@ -1183,4 +1258,9 @@
 vim.eval("Exe('throw ''ghi''')"):(<class 'vim.error'>, error('ghi',))
 vim.eval("Exe('echoerr ''jkl''')"):(<class 'vim.error'>, error('Vim(echoerr):jkl',))
 vim.eval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
+vim.eval("xxx_unknown_function_xxx()"):(<class 'vim.error'>, error('Vim:E117: Unknown function: xxx_unknown_function_xxx',))
 vim.bindeval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
+Caught KeyboardInterrupt
+Running :put
+No exception
+
diff -Naur vim74.orig/src/testdir/test91.in vim74/src/testdir/test91.in
--- vim74.orig/src/testdir/test91.in	2013-07-24 12:53:47.000000000 +0000
+++ vim74/src/testdir/test91.in	2014-10-10 14:53:45.768710304 +0000
@@ -55,6 +55,7 @@
 :tabnew
 :tabnew
 :let t:var_list = [1, 2, 3]
+:let t:other = 777
 :let def_list = [4, 5, 6, 7]
 :tabrewind
 :$put =string(gettabvar(3, 'var_list'))
diff -Naur vim74.orig/src/testdir/test91.ok vim74/src/testdir/test91.ok
--- vim74.orig/src/testdir/test91.ok	2013-07-24 12:52:47.000000000 +0000
+++ vim74/src/testdir/test91.ok	2014-10-10 14:53:45.768710304 +0000
@@ -26,8 +26,8 @@
 0
 [1, 2, 3]
 [1, 2, 3]
-''
-[4, 5, 6, 7]
+{'var_list': [1, 2, 3], 'other': 777}
+{'var_list': [1, 2, 3], 'other': 777}
 [4, 5, 6, 7]
 ''
 [4, 5, 6, 7]
diff -Naur vim74.orig/src/testdir/test92.in vim74/src/testdir/test92.in
--- vim74.orig/src/testdir/test92.in	2013-04-18 21:33:45.000000000 +0000
+++ vim74/src/testdir/test92.in	2014-10-10 14:53:45.768710304 +0000
@@ -33,7 +33,7 @@
 :mksession! test.out
 :new test.out
 :v/\(^ *normal! 0\|^ *exe 'normal!\)/d
-:w
+:w! test.out
 :qa!
 ENDTEST
 
diff -Naur vim74.orig/src/testdir/test93.in vim74/src/testdir/test93.in
--- vim74.orig/src/testdir/test93.in	2013-02-26 16:13:01.000000000 +0000
+++ vim74/src/testdir/test93.in	2014-10-10 14:53:45.772043629 +0000
@@ -33,7 +33,7 @@
 :mksession! test.out
 :new test.out
 :v/\(^ *normal! 0\|^ *exe 'normal!\)/d
-:w
+:w! test.out
 :qa!
 ENDTEST
 
diff -Naur vim74.orig/src/testdir/test95.in vim74/src/testdir/test95.in
--- vim74.orig/src/testdir/test95.in	2013-07-21 14:53:52.000000000 +0000
+++ vim74/src/testdir/test95.in	2014-10-10 14:53:45.778710279 +0000
@@ -50,6 +50,12 @@
 :call add(tl, [2, ".\u05b9", " y\u05bb\u05b9 x\u05b9 ", "y\u05bb\u05b9"])
 :call add(tl, [1, "\u05b9\u05bb", " y\u05b9 x\u05b9\u05bb ", "x\u05b9\u05bb"])
 :call add(tl, [2, ".\u05b9\u05bb", " y\u05bb x\u05b9\u05bb ", "x\u05b9\u05bb"])
+:call add(tl, [2, "a", "ca\u0300t"])
+:call add(tl, [2, "ca", "ca\u0300t"])
+:call add(tl, [2, "a\u0300", "ca\u0300t", "a\u0300"])
+:call add(tl, [2, 'a\%C', "ca\u0300t", "a\u0300"])
+:call add(tl, [2, 'ca\%C', "ca\u0300t", "ca\u0300"])
+:call add(tl, [2, 'ca\%Ct', "ca\u0300t", "ca\u0300t"])
 
 
 :"""" Test \Z
@@ -89,15 +95,15 @@
 :    try
 :      let l = matchlist(text, pat)
 :    catch
-:      $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", caused an exception: \"' . v:exception . '\"'
+:      $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", caused an exception: \"' . v:exception . '\"'
 :    endtry
 :" check the match itself
 :    if len(l) == 0 && len(t) > matchidx
-:      $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", did not match, expected: \"' . t[matchidx] . '\"'
+:      $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", did not match, expected: \"' . t[matchidx] . '\"'
 :    elseif len(l) > 0 && len(t) == matchidx
-:      $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", match: \"' . l[0] . '\", expected no match'
+:      $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", match: \"' . l[0] . '\", expected no match'
 :    elseif len(t) > matchidx && l[0] != t[matchidx]
-:      $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", match: \"' . l[0] . '\", expected: \"' . t[matchidx] . '\"'
+:      $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", match: \"' . l[0] . '\", expected: \"' . t[matchidx] . '\"'
 :    else
 :      $put ='OK ' . engine . ' - ' . pat
 :    endif
@@ -110,7 +116,7 @@
 :          let e = t[matchidx + i]
 :        endif
 :        if l[i] != e
-:          $put ='ERROR: pat: \"' . pat . '\", text: \"' . text . '\", submatch ' . i . ': \"' . l[i] . '\", expected: \"' . e . '\"'
+:          $put ='ERROR ' . engine . ': pat: \"' . pat . '\", text: \"' . text . '\", submatch ' . i . ': \"' . l[i] . '\", expected: \"' . e . '\"'
 :        endif
 :      endfor
 :      unlet i
diff -Naur vim74.orig/src/testdir/test95.ok vim74/src/testdir/test95.ok
--- vim74.orig/src/testdir/test95.ok	2013-07-21 15:01:22.000000000 +0000
+++ vim74/src/testdir/test95.ok	2014-10-10 14:53:45.782043604 +0000
@@ -67,6 +67,24 @@
 OK 0 - .
 OK 1 - .
 OK 2 - .
+OK 0 - a
+OK 1 - a
+OK 2 - a
+OK 0 - ca
+OK 1 - ca
+OK 2 - ca
+OK 0 - a
+OK 1 - a
+OK 2 - a
+OK 0 - a\%C
+OK 1 - a\%C
+OK 2 - a\%C
+OK 0 - ca\%C
+OK 1 - ca\%C
+OK 2 - ca\%C
+OK 0 - ca\%Ct
+OK 1 - ca\%Ct
+OK 2 - ca\%Ct
 OK 0 - \Z
 OK 1 - \Z
 OK 2 - \Z
diff -Naur vim74.orig/src/testdir/test97.in vim74/src/testdir/test97.in
--- vim74.orig/src/testdir/test97.in	2013-08-02 12:55:50.000000000 +0000
+++ vim74/src/testdir/test97.in	2014-10-10 14:53:45.785376929 +0000
@@ -3,14 +3,20 @@
 
 STARTTEST
 :so small.vim
+:" make sure glob() doesn't use the shell
 :set shell=doesnotexist
+:" consistent sorting of file names
+:set nofileignorecase
 :e test.out
-:put =glob('Xxx\{')
-:put =glob('Xxx\$')
+:$put =glob('Xxx\{')
+:$put =glob('Xxx\$')
 :w! Xxx{
 :w! Xxx\$
-:put =glob('Xxx\{')
-:put =glob('Xxx\$')
+:$put =glob('Xxx\{')
+:$put =glob('Xxx\$')
+:"
+:$put =string(globpath('sautest/autoload', '*.vim'))
+:$put =string(globpath('sautest/autoload', '*.vim', 0, 1))
 :w
 :qa!
 ENDTEST
diff -Naur vim74.orig/src/testdir/test97.ok vim74/src/testdir/test97.ok
--- vim74.orig/src/testdir/test97.ok	2013-07-03 14:14:50.000000000 +0000
+++ vim74/src/testdir/test97.ok	2014-10-10 14:53:45.785376929 +0000
@@ -3,3 +3,6 @@
 
 Xxx{
 Xxx$
+'sautest/autoload/Test104.vim
+sautest/autoload/footest.vim'
+['sautest/autoload/Test104.vim', 'sautest/autoload/footest.vim']
diff -Naur vim74.orig/src/testdir/test99.in vim74/src/testdir/test99.in
--- vim74.orig/src/testdir/test99.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test99.in	2014-10-10 14:53:45.788710254 +0000
@@ -0,0 +1,68 @@
+Tests for regexp with multi-byte encoding and various magic settings.
+Test matchstr() with a count and multi-byte chars.
+See test44 for exactly the same test with re=1.
+
+STARTTEST
+:so mbyte.vim
+:set nocompatible encoding=utf-8 termencoding=latin1 viminfo+=nviminfo
+:set re=2
+/^1
+/a*b\{2}c\+/e
+x/\Md\*e\{2}f\+/e
+x:set nomagic
+/g\*h\{2}i\+/e
+x/\mj*k\{2}l\+/e
+x/\vm*n{2}o+/e
+x/\V^aa$
+x:set magic
+/\v(a)(b)\2\1\1/e
+x/\V[ab]\(\[xy]\)\1
+x:" Now search for multi-byte without composing char
+/
+x:" Now search for multi-byte with composing char
+/
+x:" find word by change of word class
+/\<\>
+x:" Test \%u, [\u] and friends
+/\%u20ac
+x/[\u4f7f\u5929]\+
+x/\%U12345678
+x/[\U1234abcd\u1234\uabcd]
+x/\%d21879b
+x/ [[=A=]]* [[=B=]]* [[=C=]]* [[=D=]]* [[=E=]]* [[=F=]]* [[=G=]]* [[=H=]]* [[=I=]]* [[=J=]]* [[=K=]]* [[=L=]]* [[=M=]]* [[=N=]]* [[=O=]]* [[=P=]]* [[=Q=]]* [[=R=]]* [[=S=]]* [[=T=]]* [[=U=]]* [[=V=]]* [[=W=]]* [[=X=]]* [[=Y=]]* [[=Z=]]*/e
+x/ [[=a=]]* [[=b=]]* [[=c=]]* [[=d=]]* [[=e=]]* [[=f=]]* [[=g=]]* [[=h=]]* [[=i=]]* [[=j=]]* [[=k=]]* [[=l=]]* [[=m=]]* [[=n=]]* [[=o=]]* [[=p=]]* [[=q=]]* [[=r=]]* [[=s=]]* [[=t=]]* [[=u=]]* [[=v=]]* [[=w=]]* [[=x=]]* [[=y=]]* [[=z=]]*/e
+x:" Test backwards search from a multi-byte char
+/x
+x?.
+x:let @w=':%s#comb[i]nations#m#g'
+:@w
+:?^1?,$w! test.out
+:e! test.out
+G:put =matchstr(\"\", \".\", 0, 2) " 
+:put =matchstr(\"\", \"..\", 0, 2) " 
+:put =matchstr(\"\", \".\", 0, 0) " 
+:put =matchstr(\"\", \".\", 4, -1) " 
+:w!
+:qa!
+ENDTEST
+
+1 a aa abb abbccc
+2 d dd dee deefff
+3 g gg ghh ghhiii
+4 j jj jkk jkklll
+5 m mm mnn mnnooo
+6 x ^aa$ x
+7 (a)(b) abbaa
+8 axx [ab]xx
+9 x x
+a x x
+b 
+c x x
+d x
+e y
+f z
+g abb
+h A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
+i a b c d e f g h i j k l m n o p q r s t u v w x y z
+j 0123x
+k combinations
diff -Naur vim74.orig/src/testdir/test99.ok vim74/src/testdir/test99.ok
--- vim74.orig/src/testdir/test99.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test99.ok	2014-10-10 14:53:45.792043579 +0000
@@ -0,0 +1,24 @@
+1 a aa abb abbcc
+2 d dd dee deeff
+3 g gg ghh ghhii
+4 j jj jkk jkkll
+5 m mm mnn mnnoo
+6 x aa$ x
+7 (a)(b) abba
+8 axx ab]xx
+9 x x
+a x x
+b 
+c x x
+d x
+e y
+f z
+g abb
+h A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
+i a b c d e f g h i j k l m n o p q r s t u v w x y z
+j 012
+k m
+
+
+
+
diff -Naur vim74.orig/src/testdir/test_autoformat_join.in vim74/src/testdir/test_autoformat_join.in
--- vim74.orig/src/testdir/test_autoformat_join.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_autoformat_join.in	2014-10-10 14:53:45.792043579 +0000
@@ -0,0 +1,23 @@
+Tests for setting the '[,'] marks when joining lines.
+
+STARTTEST
+:so small.vim
+:/^\t\t/
+0gqj
+:let a=string(getpos("'[")).'/'.string(getpos("']"))
+:/^This line/;'}-join
+:let b=string(getpos("'[")).'/'.string(getpos("']"))
+:$put ='First test: Start/End '.string(a)
+:$put ='Second test: Start/End '.string(b)
+:/^\t\t/,$wq! test.out
+ENDTEST
+
+
+		O sodales, ludite, vos qui
+attamen consulite per voster honur. Tua pulchra facies me fay planszer milies
+
+This line.
+Should be joined with the next line
+and with this line
+
+Results:
diff -Naur vim74.orig/src/testdir/test_autoformat_join.ok vim74/src/testdir/test_autoformat_join.ok
--- vim74.orig/src/testdir/test_autoformat_join.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_autoformat_join.ok	2014-10-10 14:53:45.795376904 +0000
@@ -0,0 +1,8 @@
+		O sodales, ludite, vos qui attamen consulite per voster honur.
+Tua pulchra facies me fay planszer milies
+
+This line.  Should be joined with the next line and with this line
+
+Results:
+First test: Start/End '[0, 16, 1, 0]/[0, 17, 1, 0]'
+Second test: Start/End '[0, 19, 11, 0]/[0, 19, 67, 0]'
diff -Naur vim74.orig/src/testdir/test_breakindent.in vim74/src/testdir/test_breakindent.in
--- vim74.orig/src/testdir/test_breakindent.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_breakindent.in	2014-10-10 14:53:45.795376904 +0000
@@ -0,0 +1,97 @@
+Test for breakindent
+
+STARTTEST
+:so small.vim
+:if !exists("+breakindent") | e! test.ok | w! test.out | qa! | endif
+:10new|:vsp|:vert resize 20
+:put =\"\tabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP\"
+:set ts=4 sw=4 sts=4 breakindent
+:fu! ScreenChar(width)
+:	let c=''
+:	for i in range(1,a:width)
+:		let c.=nr2char(screenchar(line('.'), i))
+:	endfor
+:       let c.="\n"
+:	for i in range(1,a:width)
+:		let c.=nr2char(screenchar(line('.')+1, i))
+:	endfor
+:       let c.="\n"
+:	for i in range(1,a:width)
+:		let c.=nr2char(screenchar(line('.')+2, i))
+:	endfor
+:	return c
+:endfu
+:fu DoRecordScreen()
+:	wincmd l
+:	$put =printf(\"\n%s\", g:test)
+:	$put =g:line1
+:	wincmd p
+:endfu
+:set briopt=min:0
+:let g:test="Test 1: Simple breakindent"
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test="Test 2: Simple breakindent + sbr=>>"
+:set sbr=>>
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test ="Test 3: Simple breakindent + briopt:sbr"
+:set briopt=sbr,min:0 sbr=++
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test ="Test 4: Simple breakindent + min width: 18"
+:set sbr= briopt=min:18
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test =" Test 5: Simple breakindent + shift by 2"
+:set briopt=shift:2,min:0
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test=" Test 6: Simple breakindent + shift by -1"
+:set briopt=shift:-1,min:0
+:let line1=ScreenChar(8)
+:call DoRecordScreen()
+:let g:test=" Test 7: breakindent + shift by +1 + nu + sbr=? briopt:sbr"
+:set briopt=shift:1,sbr,min:0 nu sbr=? nuw=4
+:let line1=ScreenChar(10)
+:call DoRecordScreen()
+:let g:test=" Test 8: breakindent + shift:1 + nu + sbr=# list briopt:sbr"
+:set briopt=shift:1,sbr,min:0 nu sbr=# list
+:let line1=ScreenChar(10)
+:call DoRecordScreen()
+:let g:test=" Test 9: breakindent + shift by +1 + 'nu' + sbr=# list"
+:set briopt-=sbr
+:let line1=ScreenChar(10)
+:call DoRecordScreen()
+:let g:test=" Test 10: breakindent + shift by +1 + 'nu' + sbr=~ cpo+=n"
+:set cpo+=n sbr=~ nu nuw=4 nolist briopt=sbr,min:0
+:let line1=ScreenChar(10)
+:call DoRecordScreen()
+:wincmd p
+:let g:test="\n Test 11: strdisplaywidth when breakindent is on"
+:set cpo-=n sbr=>> nu nuw=4 nolist briopt= ts=4
+:let text=getline(2) "skip leading tab when calculating text width
+:let width = strlen(text[1:])+indent(2)*4+strlen(&sbr)*3 " text wraps 3 times
+:$put =g:test
+:$put =printf(\"strdisplaywidth: %d == calculated: %d\", strdisplaywidth(text), width)
+:"
+:" Test, that the string "    a\tb\tc\td\te" is correctly
+:" displayed in a 20 column wide window (see bug report
+:" https://groups.google.com/d/msg/vim_dev/ZOdg2mc9c9Y/TT8EhFjEy0IJ
+:only
+:vert 20new
+:set all& nocp breakindent briopt=min:10
+:call setline(1, ["    a\tb\tc\td\te", "    z   y       x       w       v"])
+:/^\s*a
+fbgjyl:let line1 = @0
+:?^\s*z
+fygjyl:let line2 = @0
+:quit!
+:$put ='Test 12: breakindent with wrapping Tab'
+:$put =line1
+:$put =line2
+:"
+:%w! test.out
+:qa!
+ENDTEST
+dummy text
diff -Naur vim74.orig/src/testdir/test_breakindent.ok vim74/src/testdir/test_breakindent.ok
--- vim74.orig/src/testdir/test_breakindent.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_breakindent.ok	2014-10-10 14:53:45.795376904 +0000
@@ -0,0 +1,58 @@
+
+	abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP
+
+Test 1: Simple breakindent
+    abcd
+    qrst
+    GHIJ
+
+Test 2: Simple breakindent + sbr=>>
+    abcd
+    >>qr
+    >>EF
+
+Test 3: Simple breakindent + briopt:sbr
+    abcd
+++  qrst
+++  GHIJ
+
+Test 4: Simple breakindent + min width: 18
+    abcd
+  qrstuv
+  IJKLMN
+
+ Test 5: Simple breakindent + shift by 2
+    abcd
+      qr
+      EF
+
+ Test 6: Simple breakindent + shift by -1
+    abcd
+   qrstu
+   HIJKL
+
+ Test 7: breakindent + shift by +1 + nu + sbr=? briopt:sbr
+  2     ab
+?        m
+?        x
+
+ Test 8: breakindent + shift:1 + nu + sbr=# list briopt:sbr
+  2 ^Iabcd
+#      opq
+#      BCD
+
+ Test 9: breakindent + shift by +1 + 'nu' + sbr=# list
+  2 ^Iabcd
+       #op
+       #AB
+
+ Test 10: breakindent + shift by +1 + 'nu' + sbr=~ cpo+=n
+  2     ab
+~       mn
+~       yz
+
+ Test 11: strdisplaywidth when breakindent is on
+strdisplaywidth: 46 == calculated: 64
+Test 12: breakindent with wrapping Tab
+d
+w
diff -Naur vim74.orig/src/testdir/test_changelist.in vim74/src/testdir/test_changelist.in
--- vim74.orig/src/testdir/test_changelist.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_changelist.in	2014-10-10 14:53:45.798710229 +0000
@@ -0,0 +1,22 @@
+Test changelist position after splitting window
+Set 'undolevels' to make changelist for sourced file
+
+STARTTEST
+:so small.vim
+Gkylp:set ul=100
+Gylp:set ul=100
+gg
+:vsplit
+:try
+:  normal g;
+:  normal ggVGcpass
+:catch
+:  normal ggVGcfail
+:finally
+:  %w! test.out
+:endtry
+:qa!
+ENDTEST
+
+1
+2
diff -Naur vim74.orig/src/testdir/test_changelist.ok vim74/src/testdir/test_changelist.ok
--- vim74.orig/src/testdir/test_changelist.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_changelist.ok	2014-10-10 14:53:45.798710229 +0000
@@ -0,0 +1 @@
+pass
diff -Naur vim74.orig/src/testdir/test_eval.in vim74/src/testdir/test_eval.in
--- vim74.orig/src/testdir/test_eval.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_eval.in	2014-10-10 14:53:45.798710229 +0000
@@ -0,0 +1,207 @@
+Test for various eval features.   vim: set ft=vim :
+
+Note: system clipboard support is not tested. I do not think anybody will thank 
+me for messing with clipboard.
+
+STARTTEST
+:so small.vim
+:set encoding=latin1
+:set noswapfile
+:lang C
+:fun AppendRegContents(reg)
+    call append('$', printf('%s: type %s; value: %s (%s), expr: %s (%s)', a:reg, getregtype(a:reg), getreg(a:reg), string(getreg(a:reg, 0, 1)), getreg(a:reg, 1), string(getreg(a:reg, 1, 1))))
+endfun
+:command -nargs=? AR :call AppendRegContents(<q-args>)
+:fun SetReg(...)
+    call call('setreg', a:000)
+    call append('$', printf('{{{2 setreg(%s)', string(a:000)[1:-2]))
+    call AppendRegContents(a:1)
+    if a:1 isnot# '='
+        execute "silent normal! Go==\n==\e\"".a:1."P"
+    endif
+endfun
+:fun ErrExe(str)
+    call append('$', 'Executing '.a:str)
+    try
+        execute a:str
+    catch
+        $put =v:exception
+    endtry
+endfun
+:fun Test()
+$put ='{{{1 let tests'
+let @" = 'abc'
+AR "
+let @" = "abc\n"
+AR "
+let @" = "abc\<C-m>"
+AR "
+let @= = '"abc"'
+AR =
+
+$put ='{{{1 Basic setreg tests'
+call SetReg('a', 'abcA', 'c')
+call SetReg('b', 'abcB', 'v')
+call SetReg('c', 'abcC', 'l')
+call SetReg('d', 'abcD', 'V')
+call SetReg('e', 'abcE', 'b')
+call SetReg('f', 'abcF', "\<C-v>")
+call SetReg('g', 'abcG', 'b10')
+call SetReg('h', 'abcH', "\<C-v>10")
+call SetReg('I', 'abcI')
+
+$put ='{{{1 Appending single lines with setreg()'
+call SetReg('A', 'abcAc', 'c')
+call SetReg('A', 'abcAl', 'l')
+call SetReg('A', 'abcAc2','c')
+call SetReg('b', 'abcBc', 'ca')
+call SetReg('b', 'abcBb', 'ba')
+call SetReg('b', 'abcBc2','ca')
+call SetReg('b', 'abcBb2','b50a')
+
+call SetReg('C', 'abcCl', 'l')
+call SetReg('C', 'abcCc', 'c')
+call SetReg('D', 'abcDb', 'b')
+
+call SetReg('E', 'abcEb', 'b')
+call SetReg('E', 'abcEl', 'l')
+call SetReg('F', 'abcFc', 'c')
+
+$put ='{{{1 Appending NL with setreg()'
+call setreg('a', 'abcA2', 'c')
+call setreg('b', 'abcB2', 'v')
+call setreg('c', 'abcC2', 'l')
+call setreg('d', 'abcD2', 'V')
+call setreg('e', 'abcE2', 'b')
+call setreg('f', 'abcF2', "\<C-v>")
+call setreg('g', 'abcG2', 'b10')
+call setreg('h', 'abcH2', "\<C-v>10")
+call setreg('I', 'abcI2')
+
+call SetReg('A', "\n")
+call SetReg('B', "\n", 'c')
+call SetReg('C', "\n")
+call SetReg('D', "\n", 'l')
+call SetReg('E', "\n")
+call SetReg('F', "\n", 'b')
+
+$put ='{{{1 Setting lists with setreg()'
+call SetReg('a', ['abcA3'], 'c')
+call SetReg('b', ['abcB3'], 'l')
+call SetReg('c', ['abcC3'], 'b')
+call SetReg('d', ['abcD3'])
+call SetReg('e', [1, 2, 'abc', 3])
+call SetReg('f', [1, 2, 3])
+
+$put ='{{{1 Appending lists with setreg()'
+call SetReg('A', ['abcA3c'], 'c')
+call SetReg('b', ['abcB3l'], 'la')
+call SetReg('C', ['abcC3b'], 'lb')
+call SetReg('D', ['abcD32'])
+
+call SetReg('A', ['abcA32'])
+call SetReg('B', ['abcB3c'], 'c')
+call SetReg('C', ['abcC3l'], 'l')
+call SetReg('D', ['abcD3b'], 'b')
+
+$put ='{{{1 Appending lists with NL with setreg()'
+call SetReg('A', ["\n", 'abcA3l2'], 'l')
+call SetReg('B', ["\n", 'abcB3c2'], 'c')
+call SetReg('C', ["\n", 'abcC3b2'], 'b')
+call SetReg('D', ["\n", 'abcD3b50'],'b50')
+
+$put ='{{{1 Setting lists with NLs with setreg()'
+call SetReg('a', ['abcA4-0', "\n", "abcA4-2\n", "\nabcA4-3", "abcA4-4\nabcA4-4-2"])
+call SetReg('b', ['abcB4c-0', "\n", "abcB4c-2\n", "\nabcB4c-3", "abcB4c-4\nabcB4c-4-2"], 'c')
+call SetReg('c', ['abcC4l-0', "\n", "abcC4l-2\n", "\nabcC4l-3", "abcC4l-4\nabcC4l-4-2"], 'l')
+call SetReg('d', ['abcD4b-0', "\n", "abcD4b-2\n", "\nabcD4b-3", "abcD4b-4\nabcD4b-4-2"], 'b')
+call SetReg('e', ['abcE4b10-0', "\n", "abcE4b10-2\n", "\nabcE4b10-3", "abcE4b10-4\nabcE4b10-4-2"], 'b10')
+
+$put ='{{{1 Search and expressions'
+call SetReg('/', ['abc/'])
+call SetReg('/', ["abc/\n"])
+call SetReg('=', ['"abc/"'])
+call SetReg('=', ["\"abc/\n\""])
+
+$put ='{{{1 Errors'
+call ErrExe('call setreg()')
+call ErrExe('call setreg(1)')
+call ErrExe('call setreg(1, 2, 3, 4)')
+call ErrExe('call setreg([], 2)')
+call ErrExe('call setreg(1, {})')
+call ErrExe('call setreg(1, 2, [])')
+call ErrExe('call setreg("/", ["1", "2"])')
+call ErrExe('call setreg("=", ["1", "2"])')
+call ErrExe('call setreg(1, ["", "", [], ""])')
+endfun
+:"
+:call Test()
+:"
+:delfunction SetReg
+:delfunction AppendRegContents
+:delfunction ErrExe
+:delfunction Test
+:delcommand AR
+:call garbagecollect(1)
+:"
+:" function name not starting with capital
+:try
+:func! g:test()
+:echo "test"
+:endfunc
+:catch
+:$put =v:exception
+:endtry
+:"
+:" function name includes a colon
+:try
+:func! b:test()
+:echo "test"
+:endfunc
+:catch
+:$put =v:exception
+:endtry
+:"
+:" function name folowed by #
+:try
+:func! test2() "#
+:echo "test2"
+:endfunc
+:catch
+:$put =v:exception
+:endtry
+:"
+:" function name starting with/without "g:", buffer-local funcref.
+:function! g:Foo(n)
+:  $put ='called Foo(' . a:n . ')'
+:endfunction
+:let b:my_func = function('Foo')
+:call b:my_func(1)
+:echo g:Foo(2)
+:echo Foo(3)
+:"
+:" script-local function used in Funcref must exist.
+:so test_eval_func.vim
+:"
+:" Using $ instead of '$' must give an error
+:try
+: call append($, 'foobar')
+:catch
+:$put =v:exception
+:endtry
+:"
+:$put ='{{{1 getcurpos/setpos'
+/^012345678
+6l:let sp = getcurpos()
+0:call setpos('.', sp)
+jyl:$put
+:"
+:/^start:/+1,$wq! test.out
+:" vim: et ts=4 isk-=\: fmr=???,???
+:call getchar()
+ENDTEST
+
+012345678
+012345678
+
+start:
diff -Naur vim74.orig/src/testdir/test_eval.ok vim74/src/testdir/test_eval.ok
--- vim74.orig/src/testdir/test_eval.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_eval.ok	2014-10-10 14:53:45.802043554 +0000
@@ -0,0 +1,350 @@
+{{{1 let tests
+": type v; value: abc (['abc']), expr: abc (['abc'])
+": type V; value: abc  (['abc']), expr: abc  (['abc'])
+": type V; value: abc  (['abc']), expr: abc  (['abc'])
+=: type v; value: abc (['abc']), expr: "abc" (['"abc"'])
+{{{1 Basic setreg tests
+{{{2 setreg('a', 'abcA', 'c')
+a: type v; value: abcA (['abcA']), expr: abcA (['abcA'])
+==
+=abcA=
+{{{2 setreg('b', 'abcB', 'v')
+b: type v; value: abcB (['abcB']), expr: abcB (['abcB'])
+==
+=abcB=
+{{{2 setreg('c', 'abcC', 'l')
+c: type V; value: abcC  (['abcC']), expr: abcC  (['abcC'])
+==
+abcC
+==
+{{{2 setreg('d', 'abcD', 'V')
+d: type V; value: abcD  (['abcD']), expr: abcD  (['abcD'])
+==
+abcD
+==
+{{{2 setreg('e', 'abcE', 'b')
+e: type 4; value: abcE (['abcE']), expr: abcE (['abcE'])
+==
+=abcE=
+{{{2 setreg('f', 'abcF', '')
+f: type 4; value: abcF (['abcF']), expr: abcF (['abcF'])
+==
+=abcF=
+{{{2 setreg('g', 'abcG', 'b10')
+g: type 10; value: abcG (['abcG']), expr: abcG (['abcG'])
+==
+=abcG      =
+{{{2 setreg('h', 'abcH', '10')
+h: type 10; value: abcH (['abcH']), expr: abcH (['abcH'])
+==
+=abcH      =
+{{{2 setreg('I', 'abcI')
+I: type v; value: abcI (['abcI']), expr: abcI (['abcI'])
+==
+=abcI=
+{{{1 Appending single lines with setreg()
+{{{2 setreg('A', 'abcAc', 'c')
+A: type v; value: abcAabcAc (['abcAabcAc']), expr: abcAabcAc (['abcAabcAc'])
+==
+=abcAabcAc=
+{{{2 setreg('A', 'abcAl', 'l')
+A: type V; value: abcAabcAcabcAl  (['abcAabcAcabcAl']), expr: abcAabcAcabcAl  (['abcAabcAcabcAl'])
+==
+abcAabcAcabcAl
+==
+{{{2 setreg('A', 'abcAc2', 'c')
+A: type v; value: abcAabcAcabcAl abcAc2 (['abcAabcAcabcAl', 'abcAc2']), expr: abcAabcAcabcAl abcAc2 (['abcAabcAcabcAl', 'abcAc2'])
+==
+=abcAabcAcabcAl
+abcAc2=
+{{{2 setreg('b', 'abcBc', 'ca')
+b: type v; value: abcBabcBc (['abcBabcBc']), expr: abcBabcBc (['abcBabcBc'])
+==
+=abcBabcBc=
+{{{2 setreg('b', 'abcBb', 'ba')
+b: type 5; value: abcBabcBcabcBb (['abcBabcBcabcBb']), expr: abcBabcBcabcBb (['abcBabcBcabcBb'])
+==
+=abcBabcBcabcBb=
+{{{2 setreg('b', 'abcBc2', 'ca')
+b: type v; value: abcBabcBcabcBb abcBc2 (['abcBabcBcabcBb', 'abcBc2']), expr: abcBabcBcabcBb abcBc2 (['abcBabcBcabcBb', 'abcBc2'])
+==
+=abcBabcBcabcBb
+abcBc2=
+{{{2 setreg('b', 'abcBb2', 'b50a')
+b: type 50; value: abcBabcBcabcBb abcBc2abcBb2 (['abcBabcBcabcBb', 'abcBc2abcBb2']), expr: abcBabcBcabcBb abcBc2abcBb2 (['abcBabcBcabcBb', 'abcBc2abcBb2'])
+==
+=abcBabcBcabcBb                                    =
+ abcBc2abcBb2
+{{{2 setreg('C', 'abcCl', 'l')
+C: type V; value: abcC abcCl  (['abcC', 'abcCl']), expr: abcC abcCl  (['abcC', 'abcCl'])
+==
+abcC
+abcCl
+==
+{{{2 setreg('C', 'abcCc', 'c')
+C: type v; value: abcC abcCl abcCc (['abcC', 'abcCl', 'abcCc']), expr: abcC abcCl abcCc (['abcC', 'abcCl', 'abcCc'])
+==
+=abcC
+abcCl
+abcCc=
+{{{2 setreg('D', 'abcDb', 'b')
+D: type 5; value: abcD abcDb (['abcD', 'abcDb']), expr: abcD abcDb (['abcD', 'abcDb'])
+==
+=abcD =
+ abcDb
+{{{2 setreg('E', 'abcEb', 'b')
+E: type 5; value: abcE abcEb (['abcE', 'abcEb']), expr: abcE abcEb (['abcE', 'abcEb'])
+==
+=abcE =
+ abcEb
+{{{2 setreg('E', 'abcEl', 'l')
+E: type V; value: abcE abcEb abcEl  (['abcE', 'abcEb', 'abcEl']), expr: abcE abcEb abcEl  (['abcE', 'abcEb', 'abcEl'])
+==
+abcE
+abcEb
+abcEl
+==
+{{{2 setreg('F', 'abcFc', 'c')
+F: type v; value: abcF abcFc (['abcF', 'abcFc']), expr: abcF abcFc (['abcF', 'abcFc'])
+==
+=abcF
+abcFc=
+{{{1 Appending NL with setreg()
+{{{2 setreg('A', ' ')
+A: type V; value: abcA2  (['abcA2']), expr: abcA2  (['abcA2'])
+==
+abcA2
+==
+{{{2 setreg('B', ' ', 'c')
+B: type v; value: abcB2  (['abcB2', '']), expr: abcB2  (['abcB2', ''])
+==
+=abcB2
+=
+{{{2 setreg('C', ' ')
+C: type V; value: abcC2   (['abcC2', '']), expr: abcC2   (['abcC2', ''])
+==
+abcC2
+
+==
+{{{2 setreg('D', ' ', 'l')
+D: type V; value: abcD2   (['abcD2', '']), expr: abcD2   (['abcD2', ''])
+==
+abcD2
+
+==
+{{{2 setreg('E', ' ')
+E: type V; value: abcE2   (['abcE2', '']), expr: abcE2   (['abcE2', ''])
+==
+abcE2
+
+==
+{{{2 setreg('F', ' ', 'b')
+F: type 0; value: abcF2  (['abcF2', '']), expr: abcF2  (['abcF2', ''])
+==
+=abcF2=
+ 
+{{{1 Setting lists with setreg()
+{{{2 setreg('a', ['abcA3'], 'c')
+a: type v; value: abcA3 (['abcA3']), expr: abcA3 (['abcA3'])
+==
+=abcA3=
+{{{2 setreg('b', ['abcB3'], 'l')
+b: type V; value: abcB3  (['abcB3']), expr: abcB3  (['abcB3'])
+==
+abcB3
+==
+{{{2 setreg('c', ['abcC3'], 'b')
+c: type 5; value: abcC3 (['abcC3']), expr: abcC3 (['abcC3'])
+==
+=abcC3=
+{{{2 setreg('d', ['abcD3'])
+d: type V; value: abcD3  (['abcD3']), expr: abcD3  (['abcD3'])
+==
+abcD3
+==
+{{{2 setreg('e', [1, 2, 'abc', 3])
+e: type V; value: 1 2 abc 3  (['1', '2', 'abc', '3']), expr: 1 2 abc 3  (['1', '2', 'abc', '3'])
+==
+1
+2
+abc
+3
+==
+{{{2 setreg('f', [1, 2, 3])
+f: type V; value: 1 2 3  (['1', '2', '3']), expr: 1 2 3  (['1', '2', '3'])
+==
+1
+2
+3
+==
+{{{1 Appending lists with setreg()
+{{{2 setreg('A', ['abcA3c'], 'c')
+A: type v; value: abcA3 abcA3c (['abcA3', 'abcA3c']), expr: abcA3 abcA3c (['abcA3', 'abcA3c'])
+==
+=abcA3
+abcA3c=
+{{{2 setreg('b', ['abcB3l'], 'la')
+b: type V; value: abcB3 abcB3l  (['abcB3', 'abcB3l']), expr: abcB3 abcB3l  (['abcB3', 'abcB3l'])
+==
+abcB3
+abcB3l
+==
+{{{2 setreg('C', ['abcC3b'], 'lb')
+C: type 6; value: abcC3 abcC3b (['abcC3', 'abcC3b']), expr: abcC3 abcC3b (['abcC3', 'abcC3b'])
+==
+=abcC3 =
+ abcC3b
+{{{2 setreg('D', ['abcD32'])
+D: type V; value: abcD3 abcD32  (['abcD3', 'abcD32']), expr: abcD3 abcD32  (['abcD3', 'abcD32'])
+==
+abcD3
+abcD32
+==
+{{{2 setreg('A', ['abcA32'])
+A: type V; value: abcA3 abcA3c abcA32  (['abcA3', 'abcA3c', 'abcA32']), expr: abcA3 abcA3c abcA32  (['abcA3', 'abcA3c', 'abcA32'])
+==
+abcA3
+abcA3c
+abcA32
+==
+{{{2 setreg('B', ['abcB3c'], 'c')
+B: type v; value: abcB3 abcB3l abcB3c (['abcB3', 'abcB3l', 'abcB3c']), expr: abcB3 abcB3l abcB3c (['abcB3', 'abcB3l', 'abcB3c'])
+==
+=abcB3
+abcB3l
+abcB3c=
+{{{2 setreg('C', ['abcC3l'], 'l')
+C: type V; value: abcC3 abcC3b abcC3l  (['abcC3', 'abcC3b', 'abcC3l']), expr: abcC3 abcC3b abcC3l  (['abcC3', 'abcC3b', 'abcC3l'])
+==
+abcC3
+abcC3b
+abcC3l
+==
+{{{2 setreg('D', ['abcD3b'], 'b')
+D: type 6; value: abcD3 abcD32 abcD3b (['abcD3', 'abcD32', 'abcD3b']), expr: abcD3 abcD32 abcD3b (['abcD3', 'abcD32', 'abcD3b'])
+==
+=abcD3 =
+ abcD32
+ abcD3b
+{{{1 Appending lists with NL with setreg()
+{{{2 setreg('A', [' ', 'abcA3l2'], 'l')
+A: type V; value: abcA3 abcA3c abcA32   abcA3l2  (['abcA3', 'abcA3c', 'abcA32', ' ', 'abcA3l2']), expr: abcA3 abcA3c abcA32   abcA3l2  (['abcA3', 'abcA3c', 'abcA32', ' ', 'abcA3l2'])
+==
+abcA3
+abcA3c
+abcA32
+ 
+abcA3l2
+==
+{{{2 setreg('B', [' ', 'abcB3c2'], 'c')
+B: type v; value: abcB3 abcB3l abcB3c   abcB3c2 (['abcB3', 'abcB3l', 'abcB3c', ' ', 'abcB3c2']), expr: abcB3 abcB3l abcB3c   abcB3c2 (['abcB3', 'abcB3l', 'abcB3c', ' ', 'abcB3c2'])
+==
+=abcB3
+abcB3l
+abcB3c
+ 
+abcB3c2=
+{{{2 setreg('C', [' ', 'abcC3b2'], 'b')
+C: type 7; value: abcC3 abcC3b abcC3l   abcC3b2 (['abcC3', 'abcC3b', 'abcC3l', ' ', 'abcC3b2']), expr: abcC3 abcC3b abcC3l   abcC3b2 (['abcC3', 'abcC3b', 'abcC3l', ' ', 'abcC3b2'])
+==
+=abcC3  =
+ abcC3b
+ abcC3l
+  
+ abcC3b2
+{{{2 setreg('D', [' ', 'abcD3b50'], 'b50')
+D: type 50; value: abcD3 abcD32 abcD3b   abcD3b50 (['abcD3', 'abcD32', 'abcD3b', ' ', 'abcD3b50']), expr: abcD3 abcD32 abcD3b   abcD3b50 (['abcD3', 'abcD32', 'abcD3b', ' ', 'abcD3b50'])
+==
+=abcD3                                             =
+ abcD32
+ abcD3b
+  
+ abcD3b50
+{{{1 Setting lists with NLs with setreg()
+{{{2 setreg('a', ['abcA4-0', ' ', 'abcA4-2 ', ' abcA4-3', 'abcA4-4 abcA4-4-2'])
+a: type V; value: abcA4-0   abcA4-2   abcA4-3 abcA4-4 abcA4-4-2  (['abcA4-0', ' ', 'abcA4-2 ', ' abcA4-3', 'abcA4-4 abcA4-4-2']), expr: abcA4-0   abcA4-2   abcA4-3 abcA4-4 abcA4-4-2  (['abcA4-0', ' ', 'abcA4-2 ', ' abcA4-3', 'abcA4-4 abcA4-4-2'])
+==
+abcA4-0
+ 
+abcA4-2 
+ abcA4-3
+abcA4-4 abcA4-4-2
+==
+{{{2 setreg('b', ['abcB4c-0', ' ', 'abcB4c-2 ', ' abcB4c-3', 'abcB4c-4 abcB4c-4-2'], 'c')
+b: type v; value: abcB4c-0   abcB4c-2   abcB4c-3 abcB4c-4 abcB4c-4-2 (['abcB4c-0', ' ', 'abcB4c-2 ', ' abcB4c-3', 'abcB4c-4 abcB4c-4-2']), expr: abcB4c-0   abcB4c-2   abcB4c-3 abcB4c-4 abcB4c-4-2 (['abcB4c-0', ' ', 'abcB4c-2 ', ' abcB4c-3', 'abcB4c-4 abcB4c-4-2'])
+==
+=abcB4c-0
+ 
+abcB4c-2 
+ abcB4c-3
+abcB4c-4 abcB4c-4-2=
+{{{2 setreg('c', ['abcC4l-0', ' ', 'abcC4l-2 ', ' abcC4l-3', 'abcC4l-4 abcC4l-4-2'], 'l')
+c: type V; value: abcC4l-0   abcC4l-2   abcC4l-3 abcC4l-4 abcC4l-4-2  (['abcC4l-0', ' ', 'abcC4l-2 ', ' abcC4l-3', 'abcC4l-4 abcC4l-4-2']), expr: abcC4l-0   abcC4l-2   abcC4l-3 abcC4l-4 abcC4l-4-2  (['abcC4l-0', ' ', 'abcC4l-2 ', ' abcC4l-3', 'abcC4l-4 abcC4l-4-2'])
+==
+abcC4l-0
+ 
+abcC4l-2 
+ abcC4l-3
+abcC4l-4 abcC4l-4-2
+==
+{{{2 setreg('d', ['abcD4b-0', ' ', 'abcD4b-2 ', ' abcD4b-3', 'abcD4b-4 abcD4b-4-2'], 'b')
+d: type 19; value: abcD4b-0   abcD4b-2   abcD4b-3 abcD4b-4 abcD4b-4-2 (['abcD4b-0', ' ', 'abcD4b-2 ', ' abcD4b-3', 'abcD4b-4 abcD4b-4-2']), expr: abcD4b-0   abcD4b-2   abcD4b-3 abcD4b-4 abcD4b-4-2 (['abcD4b-0', ' ', 'abcD4b-2 ', ' abcD4b-3', 'abcD4b-4 abcD4b-4-2'])
+==
+=abcD4b-0           =
+  
+ abcD4b-2 
+  abcD4b-3
+ abcD4b-4 abcD4b-4-2
+{{{2 setreg('e', ['abcE4b10-0', ' ', 'abcE4b10-2 ', ' abcE4b10-3', 'abcE4b10-4 abcE4b10-4-2'], 'b10')
+e: type 10; value: abcE4b10-0   abcE4b10-2   abcE4b10-3 abcE4b10-4 abcE4b10-4-2 (['abcE4b10-0', ' ', 'abcE4b10-2 ', ' abcE4b10-3', 'abcE4b10-4 abcE4b10-4-2']), expr: abcE4b10-0   abcE4b10-2   abcE4b10-3 abcE4b10-4 abcE4b10-4-2 (['abcE4b10-0', ' ', 'abcE4b10-2 ', ' abcE4b10-3', 'abcE4b10-4 abcE4b10-4-2'])
+==
+=abcE4b10-0=
+  
+ abcE4b10-2 
+  abcE4b10-3
+ abcE4b10-4 abcE4b10-4-2
+{{{1 Search and expressions
+{{{2 setreg('/', ['abc/'])
+/: type v; value: abc/ (['abc/']), expr: abc/ (['abc/'])
+==
+=abc/=
+{{{2 setreg('/', ['abc/ '])
+/: type v; value: abc/  (['abc/ ']), expr: abc/  (['abc/ '])
+==
+=abc/ =
+{{{2 setreg('=', ['"abc/"'])
+=: type v; value: abc/ (['abc/']), expr: "abc/" (['"abc/"'])
+{{{2 setreg('=', ['"abc/ "'])
+=: type v; value: abc/  (['abc/ ']), expr: "abc/ " (['"abc/ "'])
+{{{1 Errors
+Executing call setreg()
+Vim(call):E119: Not enough arguments for function: setreg
+Executing call setreg(1)
+Vim(call):E119: Not enough arguments for function: setreg
+Executing call setreg(1, 2, 3, 4)
+Vim(call):E118: Too many arguments for function: setreg
+Executing call setreg([], 2)
+Vim(call):E730: using List as a String
+Executing call setreg(1, {})
+Vim(call):E731: using Dictionary as a String
+Executing call setreg(1, 2, [])
+Vim(call):E730: using List as a String
+Executing call setreg("/", ["1", "2"])
+Vim(call):E883: search pattern and expression register may not contain two or more lines
+Executing call setreg("=", ["1", "2"])
+Vim(call):E883: search pattern and expression register may not contain two or more lines
+Executing call setreg(1, ["", "", [], ""])
+Vim(call):E730: using List as a String
+Vim(function):E128: Function name must start with a capital or "s:": g:test()
+Vim(function):E128: Function name must start with a capital or "s:": b:test()
+Vim(function):E128: Function name must start with a capital or "s:": test2() "#
+called Foo(1)
+called Foo(2)
+called Foo(3)
+s:Testje exists: 0
+func s:Testje exists: 1
+Bar exists: 1
+func Bar exists: 1
+Vim(call):E116: Invalid arguments for function append
+{{{1 getcurpos/setpos
+6
diff -Naur vim74.orig/src/testdir/test_eval_func.vim vim74/src/testdir/test_eval_func.vim
--- vim74.orig/src/testdir/test_eval_func.vim	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_eval_func.vim	2014-10-10 14:53:45.802043554 +0000
@@ -0,0 +1,10 @@
+" Vim script used in test_eval.in.  Needed for script-local function.
+
+func! s:Testje()
+  return "foo"
+endfunc
+let Bar = function('s:Testje')
+$put ='s:Testje exists: ' . exists('s:Testje')
+$put ='func s:Testje exists: ' . exists('*s:Testje')
+$put ='Bar exists: ' . exists('Bar')
+$put ='func Bar exists: ' . exists('*Bar')
diff -Naur vim74.orig/src/testdir/test_insertcount.in vim74/src/testdir/test_insertcount.in
--- vim74.orig/src/testdir/test_insertcount.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_insertcount.in	2014-10-10 14:53:45.805376879 +0000
@@ -0,0 +1,14 @@
+Tests for repeating insert and replace.
+
+STARTTEST
+:so small.vim
+:/Second
+4gro
+:/^First/,$wq! test.out
+:" get here when failed and in Insert mode
+:.wq! test.out
+ENDTEST
+
+First line
+Second line
+Last line
diff -Naur vim74.orig/src/testdir/test_insertcount.ok vim74/src/testdir/test_insertcount.ok
--- vim74.orig/src/testdir/test_insertcount.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_insertcount.ok	2014-10-10 14:53:45.805376879 +0000
@@ -0,0 +1,3 @@
+First line
+ooooecond line
+Last line
diff -Naur vim74.orig/src/testdir/test_listlbr.in vim74/src/testdir/test_listlbr.in
--- vim74.orig/src/testdir/test_listlbr.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_listlbr.in	2014-10-10 14:53:45.805376879 +0000
@@ -0,0 +1,70 @@
+Test for linebreak and list option (non-utf8)
+
+STARTTEST
+:so small.vim
+:if !exists("+linebreak") || !has("conceal") | e! test.ok | w! test.out | qa! | endif
+:10new|:vsp|:vert resize 20
+:put =\"\tabcdef hijklmn\tpqrstuvwxyz_1060ABCDEFGHIJKLMNOP \"
+:norm! zt
+:set ts=4 sw=4 sts=4 linebreak sbr=+ wrap
+:fu! ScreenChar(width)
+:	let c=''
+:	for j in range(1,4)
+:	    for i in range(1,a:width)
+:	    	let c.=nr2char(screenchar(j, i))
+:	    endfor
+:           let c.="\n"
+:	endfor
+:	return c
+:endfu
+:fu! DoRecordScreen()
+:	wincmd l
+:	$put =printf(\"\n%s\", g:test)
+:	$put =g:line
+:	wincmd p
+:endfu
+:let g:test="Test 1: set linebreak"
+:redraw!
+:let line=ScreenChar(winwidth(0))
+:call DoRecordScreen()
+:let g:test="Test 2: set linebreak + set list"
+:set linebreak list listchars=
+:redraw!
+:let line=ScreenChar(winwidth(0))
+:call DoRecordScreen()
+:let g:test ="Test 3: set linebreak nolist"
+:set nolist linebreak
+:redraw!
+:let line=ScreenChar(winwidth(0))
+:call DoRecordScreen()
+:let g:test ="Test 4: set linebreak with tab and 1 line as long as screen: should break!"
+:set nolist linebreak ts=8
+:let line="1\t".repeat('a', winwidth(0)-2)
+:$put =line
+:$
+:norm! zt
+:redraw!
+:let line=ScreenChar(winwidth(0))
+:call DoRecordScreen()
+:let line="_S_\t bla"
+:$put =line
+:$
+:norm! zt
+:let g:test ="Test 5: set linebreak with conceal and set list and tab displayed by different char (line may not be truncated)"
+:set cpo&vim list linebreak conceallevel=2 concealcursor=nv listchars=tab:ab
+:syn match ConcealVar contained /_/ conceal
+:syn match All /.*/ contains=ConcealVar
+:let line=ScreenChar(winwidth(0))
+:call DoRecordScreen()
+:set cpo&vim linebreak
+:let g:test ="Test 6: set linebreak with visual block mode"
+:let line="REMOVE: this not"
+:$put =line
+:let line="REMOVE: aaaaaaaaaaaaa"
+:$put =line
+:1/^REMOVE:
+0jf x:$put
+:%w! test.out
+:qa!
+ENDTEST
+dummy text
diff -Naur vim74.orig/src/testdir/test_listlbr.ok vim74/src/testdir/test_listlbr.ok
--- vim74.orig/src/testdir/test_listlbr.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_listlbr.ok	2014-10-10 14:53:45.805376879 +0000
@@ -0,0 +1,38 @@
+
+	abcdef hijklmn	pqrstuvwxyz_1060ABCDEFGHIJKLMNOP 
+
+Test 1: set linebreak
+    abcdef          
++hijklmn            
++pqrstuvwxyz_1060ABC
++DEFGHIJKLMNOP      
+
+Test 2: set linebreak + set list
+^Iabcdef hijklmn^I  
++pqrstuvwxyz_1060ABC
++DEFGHIJKLMNOP      
+                    
+
+Test 3: set linebreak nolist
+    abcdef          
++hijklmn            
++pqrstuvwxyz_1060ABC
++DEFGHIJKLMNOP      
+1	aaaaaaaaaaaaaaaaaa
+
+Test 4: set linebreak with tab and 1 line as long as screen: should break!
+1                   
++aaaaaaaaaaaaaaaaaa 
+~                   
+~                   
+_S_	 bla
+
+Test 5: set linebreak with conceal and set list and tab displayed by different char (line may not be truncated)
+Sabbbbbb bla        
+~                   
+~                   
+~                   
+this not
+aaaaaaaaaaaaa
+REMOVE: 
+REMOVE: 
diff -Naur vim74.orig/src/testdir/test_listlbr_utf8.in vim74/src/testdir/test_listlbr_utf8.in
--- vim74.orig/src/testdir/test_listlbr_utf8.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_listlbr_utf8.in	2014-10-10 14:53:45.808710203 +0000
@@ -0,0 +1,52 @@
+Test for linebreak and list option in utf-8 mode
+
+STARTTEST
+:so small.vim
+:if !exists("+linebreak") | e! test.ok | w! test.out | qa! | endif
+:so mbyte.vim
+:if &enc !=? 'utf-8'|:e! test.ok|:w! test.out|qa!|endif
+:10new|:vsp|:vert resize 20
+:put =\"\tabcdef hijklmn\tpqrstuvwxyz\u00a01060ABCDEFGHIJKLMNOP \"
+:norm! zt
+:set ts=4 sw=4 sts=4 linebreak sbr=+ wrap
+:fu! ScreenChar(width)
+:	let c=''
+:	for j in range(1,4)
+:	    for i in range(1,a:width)
+:	    	let c.=nr2char(screenchar(j, i))
+:	    endfor
+:           let c.="\n"
+:	endfor
+:	return c
+:endfu
+:fu! DoRecordScreen()
+:	wincmd l
+:	$put =printf(\"\n%s\", g:test)
+:	$put =g:line
+:	wincmd p
+:endfu
+:let g:test ="Test 1: set linebreak + set list + fancy listchars"
+:exe "set linebreak list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6"
+:redraw!
+:let line=ScreenChar(winwidth(0))
+:call DoRecordScreen()
+:"
+:let g:test ="Test 2: set nolinebreak list"
+:set list nolinebreak
+:redraw!
+:let line=ScreenChar(winwidth(0))
+:call DoRecordScreen()
+:"
+:let g:test ="Test 3: set linebreak nolist"
+:$put =\"\t*mask = nil;\"
+:$
+:norm! zt
+:set nolist linebreak
+:redraw!
+:let line=ScreenChar(winwidth(0))
+:call DoRecordScreen()
+:"
+:%w! test.out
+:qa!
+ENDTEST
+dummy text
diff -Naur vim74.orig/src/testdir/test_listlbr_utf8.ok vim74/src/testdir/test_listlbr_utf8.ok
--- vim74.orig/src/testdir/test_listlbr_utf8.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_listlbr_utf8.ok	2014-10-10 14:53:45.808710203 +0000
@@ -0,0 +1,21 @@
+
+	abcdef hijklmn	pqrstuvwxyz1060ABCDEFGHIJKLMNOP 
+
+Test 1: set linebreak + set list + fancy listchars
+abcdef          
++hijklmn        
++pqrstuvwxyz1060ABC
++DEFGHIJKLMNOP    
+
+Test 2: set nolinebreak list
+abcdef hijklmn
++pqrstuvwxyz1060ABC
++DEFGHIJKLMNOP    
+                   
+	*mask = nil;
+
+Test 3: set linebreak nolist
+    *mask = nil;    
+~                   
+~                   
+~                   
diff -Naur vim74.orig/src/testdir/test_options.in vim74/src/testdir/test_options.in
--- vim74.orig/src/testdir/test_options.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_options.in	2014-10-10 14:53:45.812043528 +0000
@@ -0,0 +1,17 @@
+Test for ":options".
+
+STARTTEST
+:so small.vim
+:let caught = 'ok'
+:try
+  :options
+:catch 
+  :let caught = v:throwpoint . "\n" . v:exception
+:endtry
+:buf 1
+:$put =caught
+:/^result/,$w! test.out
+:qa!
+ENDTEST
+
+result
diff -Naur vim74.orig/src/testdir/test_options.ok vim74/src/testdir/test_options.ok
--- vim74.orig/src/testdir/test_options.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_options.ok	2014-10-10 14:53:45.812043528 +0000
@@ -0,0 +1,2 @@
+result
+ok
diff -Naur vim74.orig/src/testdir/test_qf_title.in vim74/src/testdir/test_qf_title.in
--- vim74.orig/src/testdir/test_qf_title.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_qf_title.in	2014-10-10 14:53:45.812043528 +0000
@@ -0,0 +1,18 @@
+Tests for quickfix window's title     vim: set ft=vim :
+
+STARTTEST
+:so small.vim
+:if !has('quickfix') | e! test.ok | wq! test.out | endif
+:set efm=%E%f:%l:%c:%m
+:cgetexpr ['file:1:1:message']
+:let qflist=getqflist()
+:call setqflist(qflist, 'r')
+:copen
+:let g:quickfix_title=w:quickfix_title
+:wincmd p
+:$put =g:quickfix_title
+:/^Results/,$w test.out
+:qa!
+ENDTEST
+
+Results of test_qf_title:
diff -Naur vim74.orig/src/testdir/test_qf_title.ok vim74/src/testdir/test_qf_title.ok
--- vim74.orig/src/testdir/test_qf_title.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_qf_title.ok	2014-10-10 14:53:45.815376853 +0000
@@ -0,0 +1,2 @@
+Results of test_qf_title:
+:setqflist()
diff -Naur vim74.orig/src/testdir/test_utf8.in vim74/src/testdir/test_utf8.in
--- vim74.orig/src/testdir/test_utf8.in	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_utf8.in	2014-10-10 14:53:45.815376853 +0000
@@ -0,0 +1,18 @@
+Tests for Unicode manipulations                vim: set ft=vim :
+ 
+STARTTEST
+:so small.vim
+:set encoding=utf-8
+:" Visual block Insert adjusts for multi-byte char
+:new
+:call setline(1, ["aaa", "", "bbb"])
+:exe ":norm! gg0l\<C-V>jjIx\<Esc>"
+:let r = getline(1, '$')
+:
+:bwipeout!
+:$put=r
+:call garbagecollect(1)
+:/^start:/,$wq! test.out
+ENDTEST
+ 
+start:
diff -Naur vim74.orig/src/testdir/test_utf8.ok vim74/src/testdir/test_utf8.ok
--- vim74.orig/src/testdir/test_utf8.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim74/src/testdir/test_utf8.ok	2014-10-10 14:53:45.815376853 +0000
@@ -0,0 +1,4 @@
+start:
+axaa
+x
+bxbb
diff -Naur vim74.orig/src/ui.c vim74/src/ui.c
--- vim74.orig/src/ui.c	2013-07-13 18:57:08.000000000 +0000
+++ vim74/src/ui.c	2014-10-10 14:53:45.832043478 +0000
@@ -558,6 +558,51 @@
 }
 
 /*
+ * Save and restore clip_unnamed before doing possibly many changes. This
+ * prevents accessing the clipboard very often which might slow down Vim
+ * considerably.
+ */
+
+/*
+ * Save clip_unnamed and reset it.
+ */
+    void
+start_global_changes()
+{
+    clip_unnamed_saved = clip_unnamed;
+
+    if (clip_did_set_selection > 0)
+    {
+	clip_unnamed = FALSE;
+	clip_did_set_selection = FALSE;
+    }
+}
+
+/*
+ * Restore clip_unnamed and set the selection when needed.
+ */
+    void
+end_global_changes()
+{
+    if (clip_did_set_selection == FALSE)  /* not when -1 */
+    {
+	clip_did_set_selection = TRUE;
+	clip_unnamed = clip_unnamed_saved;
+	if (clip_unnamed & CLIP_UNNAMED)
+	{
+	    clip_own_selection(&clip_star);
+	    clip_gen_set_selection(&clip_star);
+	}
+	if (clip_unnamed & CLIP_UNNAMED_PLUS)
+	{
+	    clip_own_selection(&clip_plus);
+	    clip_gen_set_selection(&clip_plus);
+	}
+    }
+    clip_unnamed_saved = FALSE;
+}
+
+/*
  * Called when Visual mode is ended: update the selection.
  */
     void
@@ -1428,6 +1473,15 @@
 clip_gen_set_selection(cbd)
     VimClipboard	*cbd;
 {
+    if (!clip_did_set_selection)
+    {
+	/* Updating postponed, so that accessing the system clipboard won't
+	 * hang Vim when accessing it many times (e.g. on a :g comand). */
+	if (cbd == &clip_plus && (clip_unnamed_saved & CLIP_UNNAMED_PLUS))
+	    return;
+	else if (cbd == &clip_star && (clip_unnamed_saved & CLIP_UNNAMED))
+	    return;
+    }
 #ifdef FEAT_XCLIPBOARD
 # ifdef FEAT_GUI
     if (gui.in_use)
@@ -2324,7 +2378,7 @@
     if (       *target != XA_STRING
 #ifdef FEAT_MBYTE
 	    && *target != vimenc_atom
-	    && *target != utf8_atom
+	    && (*target != utf8_atom || !enc_utf8)
 #endif
 	    && *target != vim_atom
 	    && *target != text_atom
@@ -2610,13 +2664,11 @@
 	if (on_sep_line)
 	    return IN_SEP_LINE;
 #endif
-#ifdef FEAT_VISUAL
 	if (flags & MOUSE_MAY_STOP_VIS)
 	{
 	    end_visual_mode();
 	    redraw_curbuf_later(INVERTED);	/* delete the inversion */
 	}
-#endif
 #if defined(FEAT_CMDWIN) && defined(FEAT_CLIPBOARD)
 	/* Continue a modeless selection in another window. */
 	if (cmdwin_type != 0 && row < W_WINROW(curwin))
@@ -2686,32 +2738,30 @@
 	}
 #endif
 
-#ifdef FEAT_VISUAL
 	/* Before jumping to another buffer, or moving the cursor for a left
 	 * click, stop Visual mode. */
 	if (VIsual_active
 		&& (wp->w_buffer != curwin->w_buffer
 		    || (!on_status_line
-# ifdef FEAT_VERTSPLIT
+#ifdef FEAT_VERTSPLIT
 			&& !on_sep_line
-# endif
-# ifdef FEAT_FOLDING
+#endif
+#ifdef FEAT_FOLDING
 			&& (
-#  ifdef FEAT_RIGHTLEFT
+# ifdef FEAT_RIGHTLEFT
 			    wp->w_p_rl ? col < W_WIDTH(wp) - wp->w_p_fdc :
-#  endif
+# endif
 			    col >= wp->w_p_fdc
-#  ifdef FEAT_CMDWIN
+# ifdef FEAT_CMDWIN
 				  + (cmdwin_type == 0 && wp == curwin ? 0 : 1)
-#  endif
-			    )
 # endif
+			    )
+#endif
 			&& (flags & MOUSE_MAY_STOP_VIS))))
 	{
 	    end_visual_mode();
 	    redraw_curbuf_later(INVERTED);	/* delete the inversion */
 	}
-#endif
 #ifdef FEAT_CMDWIN
 	if (cmdwin_type != 0 && wp != curwin)
 	{
@@ -2801,14 +2851,12 @@
 #endif
     else /* keep_window_focus must be TRUE */
     {
-#ifdef FEAT_VISUAL
 	/* before moving the cursor for a left click, stop Visual mode */
 	if (flags & MOUSE_MAY_STOP_VIS)
 	{
 	    end_visual_mode();
 	    redraw_curbuf_later(INVERTED);	/* delete the inversion */
 	}
-#endif
 
 #if defined(FEAT_CMDWIN) && defined(FEAT_CLIPBOARD)
 	/* Continue a modeless selection in another window. */
@@ -2933,7 +2981,6 @@
     if (mouse_comp_pos(curwin, &row, &col, &curwin->w_cursor.lnum))
 	mouse_past_bottom = TRUE;
 
-#ifdef FEAT_VISUAL
     /* Start Visual mode before coladvance(), for when 'sel' != "old" */
     if ((flags & MOUSE_MAY_VIS) && !VIsual_active)
     {
@@ -2947,7 +2994,6 @@
 	if (p_smd && msg_silent == 0)
 	    redraw_cmdline = TRUE;	/* show visual mode later */
     }
-#endif
 
     curwin->w_curswant = col;
     curwin->w_set_curswant = FALSE;	/* May still have been TRUE */
@@ -3170,15 +3216,15 @@
     /* try to advance to the specified column */
     int		count = 0;
     char_u	*ptr;
-    char_u	*start;
+    char_u	*line;
 
-    start = ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);
+    line = ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);
     while (count < vcol && *ptr != NUL)
     {
-	count += win_lbr_chartabsize(wp, ptr, count, NULL);
+	count += win_lbr_chartabsize(wp, line, ptr, count, NULL);
 	mb_ptr_adv(ptr);
     }
-    return (int)(ptr - start);
+    return (int)(ptr - line);
 }
 #endif
 
diff -Naur vim74.orig/src/undo.c vim74/src/undo.c
--- vim74.orig/src/undo.c	2013-06-10 18:13:37.000000000 +0000
+++ vim74/src/undo.c	2014-10-10 14:53:45.838710128 +0000
@@ -81,8 +81,26 @@
 #define UH_MAGIC 0x18dade	/* value for uh_magic when in use */
 #define UE_MAGIC 0xabc123	/* value for ue_magic when in use */
 
+/* Size of buffer used for encryption. */
+#define CRYPT_BUF_SIZE 8192
+
 #include "vim.h"
 
+/* Structure passed around between functions.
+ * Avoids passing cryptstate_T when encryption not available. */
+typedef struct {
+    buf_T	*bi_buf;
+    FILE	*bi_fp;
+#ifdef FEAT_CRYPT
+    cryptstate_T *bi_state;
+    char_u	*bi_buffer; /* CRYPT_BUF_SIZE, NULL when not buffering */
+    size_t	bi_used;    /* bytes written to/read from bi_buffer */
+    size_t	bi_avail;   /* bytes available in bi_buffer */
+#endif
+} bufinfo_T;
+
+
+static long get_undolevel __ARGS((void));
 static void u_unch_branch __ARGS((u_header_T *uhp));
 static u_entry_T *u_get_headentry __ARGS((void));
 static void u_getbot __ARGS((void));
@@ -97,18 +115,26 @@
 #ifdef FEAT_PERSISTENT_UNDO
 static void corruption_error __ARGS((char *mesg, char_u *file_name));
 static void u_free_uhp __ARGS((u_header_T *uhp));
-static size_t fwrite_crypt __ARGS((buf_T *buf UNUSED, char_u *ptr, size_t len, FILE *fp));
-static char_u *read_string_decrypt __ARGS((buf_T *buf UNUSED, FILE *fd, int len));
-static int serialize_header __ARGS((FILE *fp, buf_T *buf, char_u *hash));
-static int serialize_uhp __ARGS((FILE *fp, buf_T *buf, u_header_T *uhp));
-static u_header_T *unserialize_uhp __ARGS((FILE *fp, char_u *file_name));
-static int serialize_uep __ARGS((FILE *fp, buf_T *buf, u_entry_T *uep));
-static u_entry_T *unserialize_uep __ARGS((FILE *fp, int *error, char_u *file_name));
-static void serialize_pos __ARGS((pos_T pos, FILE *fp));
-static void unserialize_pos __ARGS((pos_T *pos, FILE *fp));
-static void serialize_visualinfo __ARGS((visualinfo_T *info, FILE *fp));
-static void unserialize_visualinfo __ARGS((visualinfo_T *info, FILE *fp));
-static void put_header_ptr __ARGS((FILE	*fp, u_header_T *uhp));
+static int undo_write __ARGS((bufinfo_T *bi, char_u *ptr, size_t len));
+static int undo_flush __ARGS((bufinfo_T *bi));
+static int fwrite_crypt __ARGS((bufinfo_T *bi, char_u *ptr, size_t len));
+static int undo_write_bytes __ARGS((bufinfo_T *bi, long_u nr, int len));
+static void put_header_ptr __ARGS((bufinfo_T *bi, u_header_T *uhp));
+static int undo_read_4c __ARGS((bufinfo_T *bi));
+static int undo_read_2c __ARGS((bufinfo_T *bi));
+static int undo_read_byte __ARGS((bufinfo_T *bi));
+static time_t undo_read_time __ARGS((bufinfo_T *bi));
+static int undo_read __ARGS((bufinfo_T *bi, char_u *buffer, size_t size));
+static char_u *read_string_decrypt __ARGS((bufinfo_T *bi, int len));
+static int serialize_header __ARGS((bufinfo_T *bi, char_u *hash));
+static int serialize_uhp __ARGS((bufinfo_T *bi, u_header_T *uhp));
+static u_header_T *unserialize_uhp __ARGS((bufinfo_T *bi, char_u *file_name));
+static int serialize_uep __ARGS((bufinfo_T *bi, u_entry_T *uep));
+static u_entry_T *unserialize_uep __ARGS((bufinfo_T *bi, int *error, char_u *file_name));
+static void serialize_pos __ARGS((bufinfo_T *bi, pos_T pos));
+static void unserialize_pos __ARGS((bufinfo_T *bi, pos_T *pos));
+static void serialize_visualinfo __ARGS((bufinfo_T *bi, visualinfo_T *info));
+static void unserialize_visualinfo __ARGS((bufinfo_T *bi, visualinfo_T *info));
 #endif
 
 #define U_ALLOC_LINE(size) lalloc((long_u)(size), FALSE)
@@ -336,6 +362,17 @@
 }
 
 /*
+ * Get the undolevle value for the current buffer.
+ */
+    static long
+get_undolevel()
+{
+    if (curbuf->b_p_ul == NO_LOCAL_UNDOLEVEL)
+	return p_ul;
+    return curbuf->b_p_ul;
+}
+
+/*
  * Common code for various ways to save text before a change.
  * "top" is the line above the first changed line.
  * "bot" is the line below the last changed line.
@@ -397,7 +434,7 @@
 	{
 	    /* This happens when the FileChangedRO autocommand changes the
 	     * file in a way it becomes shorter. */
-	    EMSG(_("E834: Line count changed unexpectedly"));
+	    EMSG(_("E881: Line count changed unexpectedly"));
 	    return FAIL;
 	}
 #endif
@@ -419,7 +456,7 @@
 	curbuf->b_new_change = TRUE;
 #endif
 
-	if (p_ul >= 0)
+	if (get_undolevel() >= 0)
 	{
 	    /*
 	     * Make a new header entry.  Do this first so that we don't mess
@@ -449,7 +486,8 @@
 	/*
 	 * free headers to keep the size right
 	 */
-	while (curbuf->b_u_numhead > p_ul && curbuf->b_u_oldhead != NULL)
+	while (curbuf->b_u_numhead > get_undolevel()
+					       && curbuf->b_u_oldhead != NULL)
 	{
 	    u_header_T	    *uhfree = curbuf->b_u_oldhead;
 
@@ -519,9 +557,7 @@
 
 	/* save named marks and Visual marks for undo */
 	mch_memmove(uhp->uh_namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);
-#ifdef FEAT_VISUAL
 	uhp->uh_visual = curbuf->b_visual;
-#endif
 
 	curbuf->b_u_newhead = uhp;
 	if (curbuf->b_u_oldhead == NULL)
@@ -530,7 +566,7 @@
     }
     else
     {
-	if (p_ul < 0)		/* no undo at all */
+	if (get_undolevel() < 0)	/* no undo at all */
 	    return OK;
 
 	/*
@@ -777,9 +813,20 @@
 	    if (undo_file_name == NULL)
 		break;
 	    p = gettail(undo_file_name);
+#ifdef VMS
+	    /* VMS can not handle more than one dot in the filenames
+	     * use "dir/name" -> "dir/_un_name" - add _un_
+	     * at the beginning to keep the extension */
+	    mch_memmove(p + 4,  p, STRLEN(p) + 1);
+	    mch_memmove(p, "_un_", 4);
+
+#else
+	    /* Use same directory as the ffname,
+	     * "dir/name" -> "dir/.name.un~" */
 	    mch_memmove(p + 1, p, STRLEN(p) + 1);
 	    *p = '.';
 	    STRCAT(p, ".un~");
+#endif
 	}
 	else
 	{
@@ -837,68 +884,294 @@
 }
 
 /*
- * Like fwrite() but crypt the bytes when 'key' is set.
- * Returns 1 if successful.
+ * Write a sequence of bytes to the undo file.
+ * Buffers and encrypts as needed.
+ * Returns OK or FAIL.
  */
-    static size_t
-fwrite_crypt(buf, ptr, len, fp)
-    buf_T	*buf UNUSED;
+    static int
+undo_write(bi, ptr, len)
+    bufinfo_T	*bi;
+    char_u	*ptr;
+    size_t	len;
+{
+#ifdef FEAT_CRYPT
+    if (bi->bi_buffer != NULL)
+    {
+	size_t	len_todo = len;
+	char_u  *p = ptr;
+
+	while (bi->bi_used + len_todo >= CRYPT_BUF_SIZE)
+	{
+	    size_t	n = CRYPT_BUF_SIZE - bi->bi_used;
+
+	    mch_memmove(bi->bi_buffer + bi->bi_used, p, n);
+	    len_todo -= n;
+	    p += n;
+	    bi->bi_used = CRYPT_BUF_SIZE;
+	    if (undo_flush(bi) == FAIL)
+		return FAIL;
+	}
+	if (len_todo > 0)
+	{
+	    mch_memmove(bi->bi_buffer + bi->bi_used, p, len_todo);
+	    bi->bi_used += len_todo;
+	}
+	return OK;
+    }
+#endif
+    if (fwrite(ptr, len, (size_t)1, bi->bi_fp) != 1)
+	return FAIL;
+    return OK;
+}
+
+#ifdef FEAT_CRYPT
+    static int
+undo_flush(bi)
+    bufinfo_T	*bi;
+{
+    if (bi->bi_buffer != NULL && bi->bi_used > 0)
+    {
+	crypt_encode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_used);
+	if (fwrite(bi->bi_buffer, bi->bi_used, (size_t)1, bi->bi_fp) != 1)
+	    return FAIL;
+	bi->bi_used = 0;
+    }
+    return OK;
+}
+#endif
+
+/*
+ * Write "ptr[len]" and crypt the bytes when needed.
+ * Returns OK or FAIL.
+ */
+    static int
+fwrite_crypt(bi, ptr, len)
+    bufinfo_T	*bi;
     char_u	*ptr;
     size_t	len;
-    FILE	*fp;
 {
 #ifdef FEAT_CRYPT
     char_u  *copy;
     char_u  small_buf[100];
     size_t  i;
 
-    if (*buf->b_p_key == NUL)
-	return fwrite(ptr, len, (size_t)1, fp);
-    if (len < 100)
-	copy = small_buf;  /* no malloc()/free() for short strings */
-    else
+    if (bi->bi_state != NULL && bi->bi_buffer == NULL)
     {
-	copy = lalloc(len, FALSE);
-	if (copy == NULL)
-	    return 0;
-    }
-    crypt_encode(ptr, len, copy);
-    i = fwrite(copy, len, (size_t)1, fp);
-    if (copy != small_buf)
-	vim_free(copy);
-    return i;
-#else
-    return fwrite(ptr, len, (size_t)1, fp);
+	/* crypting every piece of text separately */
+	if (len < 100)
+	    copy = small_buf;  /* no malloc()/free() for short strings */
+	else
+	{
+	    copy = lalloc(len, FALSE);
+	    if (copy == NULL)
+		return 0;
+	}
+	crypt_encode(bi->bi_state, ptr, len, copy);
+	i = fwrite(copy, len, (size_t)1, bi->bi_fp);
+	if (copy != small_buf)
+	    vim_free(copy);
+	return i == 1 ? OK : FAIL;
+    }
 #endif
+    return undo_write(bi, ptr, len);
 }
 
 /*
- * Read a string of length "len" from "fd".
- * When 'key' is set decrypt the bytes.
+ * Write a number, MSB first, in "len" bytes.
+ * Must match with undo_read_?c() functions.
+ * Returns OK or FAIL.
  */
-    static char_u *
-read_string_decrypt(buf, fd, len)
-    buf_T   *buf UNUSED;
-    FILE    *fd;
+    static int
+undo_write_bytes(bi, nr, len)
+    bufinfo_T *bi;
+    long_u  nr;
     int	    len;
 {
-    char_u  *ptr;
+    char_u  buf[8];
+    int	    i;
+    int	    bufi = 0;
+
+    for (i = len - 1; i >= 0; --i)
+	buf[bufi++] = (char_u)(nr >> (i * 8));
+    return undo_write(bi, buf, (size_t)len);
+}
+
+/*
+ * Write the pointer to an undo header.  Instead of writing the pointer itself
+ * we use the sequence number of the header.  This is converted back to
+ * pointers when reading. */
+    static void
+put_header_ptr(bi, uhp)
+    bufinfo_T	*bi;
+    u_header_T	*uhp;
+{
+    undo_write_bytes(bi, (long_u)(uhp != NULL ? uhp->uh_seq : 0), 4);
+}
+
+    static int
+undo_read_4c(bi)
+    bufinfo_T	*bi;
+{
+#ifdef FEAT_CRYPT
+    if (bi->bi_buffer != NULL)
+    {
+	char_u  buf[4];
+	int	n;
+
+	undo_read(bi, buf, (size_t)4);
+	n = ((unsigned)buf[0] << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3];
+	return n;
+    }
+#endif
+    return get4c(bi->bi_fp);
+}
+
+    static int
+undo_read_2c(bi)
+    bufinfo_T	*bi;
+{
+#ifdef FEAT_CRYPT
+    if (bi->bi_buffer != NULL)
+    {
+	char_u  buf[2];
+	int	n;
+
+	undo_read(bi, buf, (size_t)2);
+	n = (buf[0] << 8) + buf[1];
+	return n;
+    }
+#endif
+    return get2c(bi->bi_fp);
+}
+
+    static int
+undo_read_byte(bi)
+    bufinfo_T	*bi;
+{
+#ifdef FEAT_CRYPT
+    if (bi->bi_buffer != NULL)
+    {
+	char_u  buf[1];
+
+	undo_read(bi, buf, (size_t)1);
+	return buf[0];
+    }
+#endif
+    return getc(bi->bi_fp);
+}
+
+    static time_t
+undo_read_time(bi)
+    bufinfo_T	*bi;
+{
+#ifdef FEAT_CRYPT
+    if (bi->bi_buffer != NULL)
+    {
+	char_u  buf[8];
+	time_t	n = 0;
+	int	i;
+
+	undo_read(bi, buf, (size_t)8);
+	for (i = 0; i < 8; ++i)
+	    n = (n << 8) + buf[i];
+	return n;
+    }
+#endif
+    return get8ctime(bi->bi_fp);
+}
+
+/*
+ * Read "buffer[size]" from the undo file.
+ * Return OK or FAIL.
+ */
+    static int
+undo_read(bi, buffer, size)
+    bufinfo_T   *bi;
+    char_u	*buffer;
+    size_t	size;
+{
+#ifdef FEAT_CRYPT
+    if (bi->bi_buffer != NULL)
+    {
+	int	size_todo = (int)size;
+	char_u	*p = buffer;
+
+	while (size_todo > 0)
+	{
+	    size_t n;
+
+	    if (bi->bi_used >= bi->bi_avail)
+	    {
+		n = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);
+		if (n <= 0)
+		{
+		    /* Error may be checked for only later.  Fill with zeros,
+		     * so that the reader won't use garbage. */
+		    vim_memset(p, 0, size_todo);
+		    return FAIL;
+		}
+		bi->bi_avail = n;
+		bi->bi_used = 0;
+		crypt_decode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_avail);
+	    }
+	    n = size_todo;
+	    if (n > bi->bi_avail - bi->bi_used)
+		n = bi->bi_avail - bi->bi_used;
+	    mch_memmove(p, bi->bi_buffer + bi->bi_used, n);
+	    bi->bi_used += n;
+	    size_todo -= (int)n;
+	    p += n;
+	}
+	return OK;
+    }
+#endif
+    if (fread(buffer, (size_t)size, 1, bi->bi_fp) != 1)
+	return FAIL;
+    return OK;
+}
+
+/*
+ * Read a string of length "len" from "bi->bi_fd".
+ * "len" can be zero to allocate an empty line.
+ * Decrypt the bytes if needed.
+ * Append a NUL.
+ * Returns a pointer to allocated memory or NULL for failure.
+ */
+    static char_u *
+read_string_decrypt(bi, len)
+    bufinfo_T	*bi;
+    int		len;
+{
+    char_u  *ptr = alloc((unsigned)len + 1);
 
-    ptr = read_string(fd, len);
+    if (ptr != NULL)
+    {
+	if (len > 0 && undo_read(bi, ptr, len) == FAIL)
+	{
+	    vim_free(ptr);
+	    return NULL;
+	}
+	ptr[len] = NUL;
 #ifdef FEAT_CRYPT
-    if (ptr != NULL && *buf->b_p_key != NUL)
-	crypt_decode(ptr, len);
+	if (bi->bi_state != NULL && bi->bi_buffer == NULL)
+	    crypt_decode_inplace(bi->bi_state, ptr, len);
 #endif
+    }
     return ptr;
 }
 
+/*
+ * Writes the (not encrypted) header and initializes encryption if needed.
+ */
     static int
-serialize_header(fp, buf, hash)
-    FILE	*fp;
-    buf_T	*buf;
+serialize_header(bi, hash)
+    bufinfo_T	*bi;
     char_u	*hash;
 {
-    int len;
+    int		len;
+    buf_T	*buf = bi->bi_buf;
+    FILE	*fp = bi->bi_fp;
+    char_u	time_buf[8];
 
     /* Start writing, first the magic marker and undo info version. */
     if (fwrite(UF_START_MAGIC, (size_t)UF_START_MAGIC_LEN, (size_t)1, fp) != 1)
@@ -912,117 +1185,124 @@
 	char_u *header;
 	int    header_len;
 
-	put_bytes(fp, (long_u)UF_VERSION_CRYPT, 2);
-	header = prepare_crypt_write(buf, &header_len);
-	if (header == NULL)
+	undo_write_bytes(bi, (long_u)UF_VERSION_CRYPT, 2);
+	bi->bi_state = crypt_create_for_writing(crypt_get_method_nr(buf),
+					  buf->b_p_key, &header, &header_len);
+	if (bi->bi_state == NULL)
 	    return FAIL;
 	len = (int)fwrite(header, (size_t)header_len, (size_t)1, fp);
 	vim_free(header);
 	if (len != 1)
 	{
-	    crypt_pop_state();
+	    crypt_free_state(bi->bi_state);
+	    bi->bi_state = NULL;
 	    return FAIL;
 	}
+
+	if (crypt_whole_undofile(crypt_get_method_nr(buf)))
+	{
+	    bi->bi_buffer = alloc(CRYPT_BUF_SIZE);
+	    if (bi->bi_buffer == NULL)
+	    {
+		crypt_free_state(bi->bi_state);
+		bi->bi_state = NULL;
+		return FAIL;
+	    }
+	    bi->bi_used = 0;
+	}
     }
     else
 #endif
-	put_bytes(fp, (long_u)UF_VERSION, 2);
+	undo_write_bytes(bi, (long_u)UF_VERSION, 2);
 
 
     /* Write a hash of the buffer text, so that we can verify it is still the
      * same when reading the buffer text. */
-    if (fwrite(hash, (size_t)UNDO_HASH_SIZE, (size_t)1, fp) != 1)
+    if (undo_write(bi, hash, (size_t)UNDO_HASH_SIZE) == FAIL)
 	return FAIL;
 
     /* buffer-specific data */
-    put_bytes(fp, (long_u)buf->b_ml.ml_line_count, 4);
+    undo_write_bytes(bi, (long_u)buf->b_ml.ml_line_count, 4);
     len = buf->b_u_line_ptr != NULL ? (int)STRLEN(buf->b_u_line_ptr) : 0;
-    put_bytes(fp, (long_u)len, 4);
-    if (len > 0 && fwrite_crypt(buf, buf->b_u_line_ptr, (size_t)len, fp) != 1)
+    undo_write_bytes(bi, (long_u)len, 4);
+    if (len > 0 && fwrite_crypt(bi, buf->b_u_line_ptr, (size_t)len) == FAIL)
 	return FAIL;
-    put_bytes(fp, (long_u)buf->b_u_line_lnum, 4);
-    put_bytes(fp, (long_u)buf->b_u_line_colnr, 4);
+    undo_write_bytes(bi, (long_u)buf->b_u_line_lnum, 4);
+    undo_write_bytes(bi, (long_u)buf->b_u_line_colnr, 4);
 
     /* Undo structures header data */
-    put_header_ptr(fp, buf->b_u_oldhead);
-    put_header_ptr(fp, buf->b_u_newhead);
-    put_header_ptr(fp, buf->b_u_curhead);
-
-    put_bytes(fp, (long_u)buf->b_u_numhead, 4);
-    put_bytes(fp, (long_u)buf->b_u_seq_last, 4);
-    put_bytes(fp, (long_u)buf->b_u_seq_cur, 4);
-    put_time(fp, buf->b_u_time_cur);
+    put_header_ptr(bi, buf->b_u_oldhead);
+    put_header_ptr(bi, buf->b_u_newhead);
+    put_header_ptr(bi, buf->b_u_curhead);
+
+    undo_write_bytes(bi, (long_u)buf->b_u_numhead, 4);
+    undo_write_bytes(bi, (long_u)buf->b_u_seq_last, 4);
+    undo_write_bytes(bi, (long_u)buf->b_u_seq_cur, 4);
+    time_to_bytes(buf->b_u_time_cur, time_buf);
+    undo_write(bi, time_buf, 8);
 
     /* Optional fields. */
-    putc(4, fp);
-    putc(UF_LAST_SAVE_NR, fp);
-    put_bytes(fp, (long_u)buf->b_u_save_nr_last, 4);
+    undo_write_bytes(bi, 4, 1);
+    undo_write_bytes(bi, UF_LAST_SAVE_NR, 1);
+    undo_write_bytes(bi, (long_u)buf->b_u_save_nr_last, 4);
 
-    putc(0, fp);  /* end marker */
+    undo_write_bytes(bi, 0, 1);  /* end marker */
 
     return OK;
 }
 
     static int
-serialize_uhp(fp, buf, uhp)
-    FILE	*fp;
-    buf_T	*buf;
+serialize_uhp(bi, uhp)
+    bufinfo_T	*bi;
     u_header_T	*uhp;
 {
     int		i;
     u_entry_T	*uep;
+    char_u	time_buf[8];
 
-    if (put_bytes(fp, (long_u)UF_HEADER_MAGIC, 2) == FAIL)
+    if (undo_write_bytes(bi, (long_u)UF_HEADER_MAGIC, 2) == FAIL)
 	return FAIL;
 
-    put_header_ptr(fp, uhp->uh_next.ptr);
-    put_header_ptr(fp, uhp->uh_prev.ptr);
-    put_header_ptr(fp, uhp->uh_alt_next.ptr);
-    put_header_ptr(fp, uhp->uh_alt_prev.ptr);
-    put_bytes(fp, uhp->uh_seq, 4);
-    serialize_pos(uhp->uh_cursor, fp);
+    put_header_ptr(bi, uhp->uh_next.ptr);
+    put_header_ptr(bi, uhp->uh_prev.ptr);
+    put_header_ptr(bi, uhp->uh_alt_next.ptr);
+    put_header_ptr(bi, uhp->uh_alt_prev.ptr);
+    undo_write_bytes(bi, uhp->uh_seq, 4);
+    serialize_pos(bi, uhp->uh_cursor);
 #ifdef FEAT_VIRTUALEDIT
-    put_bytes(fp, (long_u)uhp->uh_cursor_vcol, 4);
+    undo_write_bytes(bi, (long_u)uhp->uh_cursor_vcol, 4);
 #else
-    put_bytes(fp, (long_u)0, 4);
+    undo_write_bytes(bi, (long_u)0, 4);
 #endif
-    put_bytes(fp, (long_u)uhp->uh_flags, 2);
+    undo_write_bytes(bi, (long_u)uhp->uh_flags, 2);
     /* Assume NMARKS will stay the same. */
     for (i = 0; i < NMARKS; ++i)
-	serialize_pos(uhp->uh_namedm[i], fp);
-#ifdef FEAT_VISUAL
-    serialize_visualinfo(&uhp->uh_visual, fp);
-#else
-    {
-	visualinfo_T info;
-
-	memset(&info, 0, sizeof(visualinfo_T));
-	serialize_visualinfo(&info, fp);
-    }
-#endif
-    put_time(fp, uhp->uh_time);
+	serialize_pos(bi, uhp->uh_namedm[i]);
+    serialize_visualinfo(bi, &uhp->uh_visual);
+    time_to_bytes(uhp->uh_time, time_buf);
+    undo_write(bi, time_buf, 8);
 
     /* Optional fields. */
-    putc(4, fp);
-    putc(UHP_SAVE_NR, fp);
-    put_bytes(fp, (long_u)uhp->uh_save_nr, 4);
+    undo_write_bytes(bi, 4, 1);
+    undo_write_bytes(bi, UHP_SAVE_NR, 1);
+    undo_write_bytes(bi, (long_u)uhp->uh_save_nr, 4);
 
-    putc(0, fp);  /* end marker */
+    undo_write_bytes(bi, 0, 1);  /* end marker */
 
     /* Write all the entries. */
     for (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)
     {
-	put_bytes(fp, (long_u)UF_ENTRY_MAGIC, 2);
-	if (serialize_uep(fp, buf, uep) == FAIL)
+	undo_write_bytes(bi, (long_u)UF_ENTRY_MAGIC, 2);
+	if (serialize_uep(bi, uep) == FAIL)
 	    return FAIL;
     }
-    put_bytes(fp, (long_u)UF_ENTRY_END_MAGIC, 2);
+    undo_write_bytes(bi, (long_u)UF_ENTRY_END_MAGIC, 2);
     return OK;
 }
 
     static u_header_T *
-unserialize_uhp(fp, file_name)
-    FILE	*fp;
+unserialize_uhp(bi, file_name)
+    bufinfo_T	*bi;
     char_u	*file_name;
 {
     u_header_T	*uhp;
@@ -1038,63 +1318,56 @@
 #ifdef U_DEBUG
     uhp->uh_magic = UH_MAGIC;
 #endif
-    uhp->uh_next.seq = get4c(fp);
-    uhp->uh_prev.seq = get4c(fp);
-    uhp->uh_alt_next.seq = get4c(fp);
-    uhp->uh_alt_prev.seq = get4c(fp);
-    uhp->uh_seq = get4c(fp);
+    uhp->uh_next.seq = undo_read_4c(bi);
+    uhp->uh_prev.seq = undo_read_4c(bi);
+    uhp->uh_alt_next.seq = undo_read_4c(bi);
+    uhp->uh_alt_prev.seq = undo_read_4c(bi);
+    uhp->uh_seq = undo_read_4c(bi);
     if (uhp->uh_seq <= 0)
     {
 	corruption_error("uh_seq", file_name);
 	vim_free(uhp);
 	return NULL;
     }
-    unserialize_pos(&uhp->uh_cursor, fp);
+    unserialize_pos(bi, &uhp->uh_cursor);
 #ifdef FEAT_VIRTUALEDIT
-    uhp->uh_cursor_vcol = get4c(fp);
+    uhp->uh_cursor_vcol = undo_read_4c(bi);
 #else
-    (void)get4c(fp);
+    (void)undo_read_4c(bi);
 #endif
-    uhp->uh_flags = get2c(fp);
+    uhp->uh_flags = undo_read_2c(bi);
     for (i = 0; i < NMARKS; ++i)
-	unserialize_pos(&uhp->uh_namedm[i], fp);
-#ifdef FEAT_VISUAL
-    unserialize_visualinfo(&uhp->uh_visual, fp);
-#else
-    {
-	visualinfo_T info;
-	unserialize_visualinfo(&info, fp);
-    }
-#endif
-    uhp->uh_time = get8ctime(fp);
+	unserialize_pos(bi, &uhp->uh_namedm[i]);
+    unserialize_visualinfo(bi, &uhp->uh_visual);
+    uhp->uh_time = undo_read_time(bi);
 
     /* Optional fields. */
     for (;;)
     {
-	int len = getc(fp);
+	int len = undo_read_byte(bi);
 	int what;
 
 	if (len == 0)
 	    break;
-	what = getc(fp);
+	what = undo_read_byte(bi);
 	switch (what)
 	{
 	    case UHP_SAVE_NR:
-		uhp->uh_save_nr = get4c(fp);
+		uhp->uh_save_nr = undo_read_4c(bi);
 		break;
 	    default:
 		/* field not supported, skip */
 		while (--len >= 0)
-		    (void)getc(fp);
+		    (void)undo_read_byte(bi);
 	}
     }
 
     /* Unserialize the uep list. */
     last_uep = NULL;
-    while ((c = get2c(fp)) == UF_ENTRY_MAGIC)
+    while ((c = undo_read_2c(bi)) == UF_ENTRY_MAGIC)
     {
 	error = FALSE;
-	uep = unserialize_uep(fp, &error, file_name);
+	uep = unserialize_uep(bi, &error, file_name);
 	if (last_uep == NULL)
 	    uhp->uh_entry = uep;
 	else
@@ -1117,35 +1390,34 @@
 }
 
 /*
- * Serialize "uep" to "fp".
+ * Serialize "uep".
  */
     static int
-serialize_uep(fp, buf, uep)
-    FILE	*fp;
-    buf_T	*buf;
+serialize_uep(bi, uep)
+    bufinfo_T	*bi;
     u_entry_T	*uep;
 {
     int		i;
     size_t	len;
 
-    put_bytes(fp, (long_u)uep->ue_top, 4);
-    put_bytes(fp, (long_u)uep->ue_bot, 4);
-    put_bytes(fp, (long_u)uep->ue_lcount, 4);
-    put_bytes(fp, (long_u)uep->ue_size, 4);
+    undo_write_bytes(bi, (long_u)uep->ue_top, 4);
+    undo_write_bytes(bi, (long_u)uep->ue_bot, 4);
+    undo_write_bytes(bi, (long_u)uep->ue_lcount, 4);
+    undo_write_bytes(bi, (long_u)uep->ue_size, 4);
     for (i = 0; i < uep->ue_size; ++i)
     {
 	len = STRLEN(uep->ue_array[i]);
-	if (put_bytes(fp, (long_u)len, 4) == FAIL)
+	if (undo_write_bytes(bi, (long_u)len, 4) == FAIL)
 	    return FAIL;
-	if (len > 0 && fwrite_crypt(buf, uep->ue_array[i], len, fp) != 1)
+	if (len > 0 && fwrite_crypt(bi, uep->ue_array[i], len) == FAIL)
 	    return FAIL;
     }
     return OK;
 }
 
     static u_entry_T *
-unserialize_uep(fp, error, file_name)
-    FILE	*fp;
+unserialize_uep(bi, error, file_name)
+    bufinfo_T	*bi;
     int		*error;
     char_u	*file_name;
 {
@@ -1162,10 +1434,10 @@
 #ifdef U_DEBUG
     uep->ue_magic = UE_MAGIC;
 #endif
-    uep->ue_top = get4c(fp);
-    uep->ue_bot = get4c(fp);
-    uep->ue_lcount = get4c(fp);
-    uep->ue_size = get4c(fp);
+    uep->ue_top = undo_read_4c(bi);
+    uep->ue_bot = undo_read_4c(bi);
+    uep->ue_lcount = undo_read_4c(bi);
+    uep->ue_size = undo_read_4c(bi);
     if (uep->ue_size > 0)
     {
 	array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);
@@ -1182,9 +1454,9 @@
 
     for (i = 0; i < uep->ue_size; ++i)
     {
-	line_len = get4c(fp);
+	line_len = undo_read_4c(bi);
 	if (line_len >= 0)
-	    line = read_string_decrypt(curbuf, fp, line_len);
+	    line = read_string_decrypt(bi, line_len);
 	else
 	{
 	    line = NULL;
@@ -1201,83 +1473,71 @@
 }
 
 /*
- * Serialize "pos" to "fp".
+ * Serialize "pos".
  */
     static void
-serialize_pos(pos, fp)
+serialize_pos(bi, pos)
+    bufinfo_T *bi;
     pos_T pos;
-    FILE  *fp;
 {
-    put_bytes(fp, (long_u)pos.lnum, 4);
-    put_bytes(fp, (long_u)pos.col, 4);
+    undo_write_bytes(bi, (long_u)pos.lnum, 4);
+    undo_write_bytes(bi, (long_u)pos.col, 4);
 #ifdef FEAT_VIRTUALEDIT
-    put_bytes(fp, (long_u)pos.coladd, 4);
+    undo_write_bytes(bi, (long_u)pos.coladd, 4);
 #else
-    put_bytes(fp, (long_u)0, 4);
+    undo_write_bytes(bi, (long_u)0, 4);
 #endif
 }
 
 /*
- * Unserialize the pos_T at the current position in fp.
+ * Unserialize the pos_T at the current position.
  */
     static void
-unserialize_pos(pos, fp)
+unserialize_pos(bi, pos)
+    bufinfo_T *bi;
     pos_T *pos;
-    FILE  *fp;
 {
-    pos->lnum = get4c(fp);
+    pos->lnum = undo_read_4c(bi);
     if (pos->lnum < 0)
 	pos->lnum = 0;
-    pos->col = get4c(fp);
+    pos->col = undo_read_4c(bi);
     if (pos->col < 0)
 	pos->col = 0;
 #ifdef FEAT_VIRTUALEDIT
-    pos->coladd = get4c(fp);
+    pos->coladd = undo_read_4c(bi);
     if (pos->coladd < 0)
 	pos->coladd = 0;
 #else
-    (void)get4c(fp);
+    (void)undo_read_4c(bi);
 #endif
 }
 
 /*
- * Serialize "info" to "fp".
+ * Serialize "info".
  */
     static void
-serialize_visualinfo(info, fp)
+serialize_visualinfo(bi, info)
+    bufinfo_T	    *bi;
     visualinfo_T    *info;
-    FILE	    *fp;
 {
-    serialize_pos(info->vi_start, fp);
-    serialize_pos(info->vi_end, fp);
-    put_bytes(fp, (long_u)info->vi_mode, 4);
-    put_bytes(fp, (long_u)info->vi_curswant, 4);
+    serialize_pos(bi, info->vi_start);
+    serialize_pos(bi, info->vi_end);
+    undo_write_bytes(bi, (long_u)info->vi_mode, 4);
+    undo_write_bytes(bi, (long_u)info->vi_curswant, 4);
 }
 
 /*
- * Unserialize the visualinfo_T at the current position in fp.
+ * Unserialize the visualinfo_T at the current position.
  */
     static void
-unserialize_visualinfo(info, fp)
+unserialize_visualinfo(bi, info)
+    bufinfo_T	    *bi;
     visualinfo_T    *info;
-    FILE	    *fp;
 {
-    unserialize_pos(&info->vi_start, fp);
-    unserialize_pos(&info->vi_end, fp);
-    info->vi_mode = get4c(fp);
-    info->vi_curswant = get4c(fp);
-}
-
-/*
- * Write the pointer to an undo header.  Instead of writing the pointer itself
- * we use the sequence number of the header.  This is converted back to
- * pointers when reading. */
-    static void
-put_header_ptr(fp, uhp)
-    FILE	*fp;
-    u_header_T	*uhp;
-{
-    put_bytes(fp, (long_u)(uhp != NULL ? uhp->uh_seq : 0), 4);
+    unserialize_pos(bi, &info->vi_start);
+    unserialize_pos(bi, &info->vi_end);
+    info->vi_mode = undo_read_4c(bi);
+    info->vi_curswant = undo_read_4c(bi);
 }
 
 /*
@@ -1311,9 +1571,9 @@
     struct stat	st_old;
     struct stat	st_new;
 #endif
-#ifdef FEAT_CRYPT
-    int		do_crypt = FALSE;
-#endif
+    bufinfo_T	bi;
+
+    vim_memset(&bi, 0, sizeof(bi));
 
     if (name == NULL)
     {
@@ -1449,7 +1709,7 @@
 # endif
        )
 	mch_setperm(file_name, (perm & 0707) | ((perm & 07) << 3));
-# ifdef HAVE_SELINUX
+# if defined(HAVE_SELINUX) || defined(HAVE_SMACK)
     if (buf->b_ffname != NULL)
 	mch_copy_sec(buf->b_ffname, file_name);
 # endif
@@ -1468,14 +1728,12 @@
     u_sync(TRUE);
 
     /*
-     * Write the header.
+     * Write the header.  Initializes encryption, if enabled.
      */
-    if (serialize_header(fp, buf, hash) == FAIL)
+    bi.bi_buf = buf;
+    bi.bi_fp = fp;
+    if (serialize_header(&bi, hash) == FAIL)
 	goto write_error;
-#ifdef FEAT_CRYPT
-    if (*buf->b_p_key != NUL)
-	do_crypt = TRUE;
-#endif
 
     /*
      * Iteratively serialize UHPs and their UEPs from the top down.
@@ -1491,7 +1749,7 @@
 #ifdef U_DEBUG
 	    ++headers_written;
 #endif
-	    if (serialize_uhp(fp, buf, uhp) == FAIL)
+	    if (serialize_uhp(&bi, uhp) == FAIL)
 		goto write_error;
 	}
 
@@ -1510,7 +1768,7 @@
 	    uhp = uhp->uh_next.ptr;
     }
 
-    if (put_bytes(fp, (long_u)UF_HEADER_END_MAGIC, 2) == OK)
+    if (undo_write_bytes(&bi, (long_u)UF_HEADER_END_MAGIC, 2) == OK)
 	write_ok = TRUE;
 #ifdef U_DEBUG
     if (headers_written != buf->b_u_numhead)
@@ -1520,6 +1778,11 @@
     }
 #endif
 
+#ifdef FEAT_CRYPT
+    if (bi.bi_state != NULL && undo_flush(&bi) == FAIL)
+	write_ok = FALSE;
+#endif
+
 write_error:
     fclose(fp);
     if (!write_ok)
@@ -1545,8 +1808,9 @@
 
 theend:
 #ifdef FEAT_CRYPT
-    if (do_crypt)
-	crypt_pop_state();
+    if (bi.bi_state != NULL)
+	crypt_free_state(bi.bi_state);
+    vim_free(bi.bi_buffer);
 #endif
     if (file_name != name)
 	vim_free(file_name);
@@ -1592,10 +1856,9 @@
     struct stat	st_orig;
     struct stat	st_undo;
 #endif
-#ifdef FEAT_CRYPT
-    int		do_decrypt = FALSE;
-#endif
+    bufinfo_T	bi;
 
+    vim_memset(&bi, 0, sizeof(bi));
     if (name == NULL)
     {
 	file_name = u_get_undo_file_name(curbuf->b_ffname, TRUE);
@@ -1604,10 +1867,11 @@
 
 #ifdef UNIX
 	/* For safety we only read an undo file if the owner is equal to the
-	 * owner of the text file. */
+	 * owner of the text file or equal to the current user. */
 	if (mch_stat((char *)orig_name, &st_orig) >= 0
 		&& mch_stat((char *)file_name, &st_undo) >= 0
-		&& st_orig.st_uid != st_undo.st_uid)
+		&& st_orig.st_uid != st_undo.st_uid
+		&& st_undo.st_uid != getuid())
 	{
 	    if (p_verbose > 0)
 	    {
@@ -1637,6 +1901,8 @@
 	    EMSG2(_("E822: Cannot open undo file for reading: %s"), file_name);
 	goto error;
     }
+    bi.bi_buf = curbuf;
+    bi.bi_fp = fp;
 
     /*
      * Read the undo file header.
@@ -1657,12 +1923,24 @@
 								   file_name);
 	    goto error;
 	}
-	if (prepare_crypt_read(fp) == FAIL)
+	bi.bi_state = crypt_create_from_file(fp, curbuf->b_p_key);
+	if (bi.bi_state == NULL)
 	{
 	    EMSG2(_("E826: Undo file decryption failed: %s"), file_name);
 	    goto error;
 	}
-	do_decrypt = TRUE;
+	if (crypt_whole_undofile(bi.bi_state->method_nr))
+	{
+	    bi.bi_buffer = alloc(CRYPT_BUF_SIZE);
+	    if (bi.bi_buffer == NULL)
+	    {
+		crypt_free_state(bi.bi_state);
+		bi.bi_state = NULL;
+		goto error;
+	    }
+	    bi.bi_avail = 0;
+	    bi.bi_used = 0;
+	}
 #else
 	EMSG2(_("E827: Undo file is encrypted: %s"), file_name);
 	goto error;
@@ -1674,12 +1952,12 @@
 	goto error;
     }
 
-    if (fread(read_hash, UNDO_HASH_SIZE, 1, fp) != 1)
+    if (undo_read(&bi, read_hash, (size_t)UNDO_HASH_SIZE) == FAIL)
     {
 	corruption_error("hash", file_name);
 	goto error;
     }
-    line_count = (linenr_T)get4c(fp);
+    line_count = (linenr_T)undo_read_4c(&bi);
     if (memcmp(hash, read_hash, UNDO_HASH_SIZE) != 0
 				  || line_count != curbuf->b_ml.ml_line_count)
     {
@@ -1696,13 +1974,13 @@
     }
 
     /* Read undo data for "U" command. */
-    str_len = get4c(fp);
+    str_len = undo_read_4c(&bi);
     if (str_len < 0)
 	goto error;
     if (str_len > 0)
-	line_ptr = read_string_decrypt(curbuf, fp, str_len);
-    line_lnum = (linenr_T)get4c(fp);
-    line_colnr = (colnr_T)get4c(fp);
+	line_ptr = read_string_decrypt(&bi, str_len);
+    line_lnum = (linenr_T)undo_read_4c(&bi);
+    line_colnr = (colnr_T)undo_read_4c(&bi);
     if (line_lnum < 0 || line_colnr < 0)
     {
 	corruption_error("line lnum/col", file_name);
@@ -1710,32 +1988,32 @@
     }
 
     /* Begin general undo data */
-    old_header_seq = get4c(fp);
-    new_header_seq = get4c(fp);
-    cur_header_seq = get4c(fp);
-    num_head = get4c(fp);
-    seq_last = get4c(fp);
-    seq_cur = get4c(fp);
-    seq_time = get8ctime(fp);
+    old_header_seq = undo_read_4c(&bi);
+    new_header_seq = undo_read_4c(&bi);
+    cur_header_seq = undo_read_4c(&bi);
+    num_head = undo_read_4c(&bi);
+    seq_last = undo_read_4c(&bi);
+    seq_cur = undo_read_4c(&bi);
+    seq_time = undo_read_time(&bi);
 
     /* Optional header fields. */
     for (;;)
     {
-	int len = getc(fp);
+	int len = undo_read_byte(&bi);
 	int what;
 
 	if (len == 0 || len == EOF)
 	    break;
-	what = getc(fp);
+	what = undo_read_byte(&bi);
 	switch (what)
 	{
 	    case UF_LAST_SAVE_NR:
-		last_save_nr = get4c(fp);
+		last_save_nr = undo_read_4c(&bi);
 		break;
 	    default:
 		/* field not supported, skip */
 		while (--len >= 0)
-		    (void)getc(fp);
+		    (void)undo_read_byte(&bi);
 	}
     }
 
@@ -1751,7 +2029,7 @@
 	    goto error;
     }
 
-    while ((c = get2c(fp)) == UF_HEADER_MAGIC)
+    while ((c = undo_read_2c(&bi)) == UF_HEADER_MAGIC)
     {
 	if (num_read_uhps >= num_head)
 	{
@@ -1759,7 +2037,7 @@
 	    goto error;
 	}
 
-	uhp = unserialize_uhp(fp, file_name);
+	uhp = unserialize_uhp(&bi, file_name);
 	if (uhp == NULL)
 	    goto error;
 	uhp_table[num_read_uhps++] = uhp;
@@ -1891,8 +2169,9 @@
 
 theend:
 #ifdef FEAT_CRYPT
-    if (do_decrypt)
-	crypt_pop_state();
+    if (bi.bi_state != NULL)
+	crypt_free_state(bi.bi_state);
+    vim_free(bi.bi_buffer);
 #endif
     if (fp != NULL)
 	fclose(fp);
@@ -1971,7 +2250,7 @@
 	{
 	    if (curbuf->b_u_curhead == NULL)		/* first undo */
 		curbuf->b_u_curhead = curbuf->b_u_newhead;
-	    else if (p_ul > 0)				/* multi level undo */
+	    else if (get_undolevel() > 0)		/* multi level undo */
 		/* get next undo */
 		curbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;
 	    /* nothing to undo */
@@ -1992,7 +2271,7 @@
 	}
 	else
 	{
-	    if (curbuf->b_u_curhead == NULL || p_ul <= 0)
+	    if (curbuf->b_u_curhead == NULL || get_undolevel() <= 0)
 	    {
 		beep_flush();	/* nothing to redo */
 		if (count == startcount - 1)
@@ -2381,9 +2660,7 @@
     int		old_flags;
     int		new_flags;
     pos_T	namedm[NMARKS];
-#ifdef FEAT_VISUAL
     visualinfo_T visualinfo;
-#endif
     int		empty_buffer;		    /* buffer became empty */
     u_header_T	*curhead = curbuf->b_u_curhead;
 
@@ -2405,9 +2682,7 @@
      * save marks before undo/redo
      */
     mch_memmove(namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);
-#ifdef FEAT_VISUAL
     visualinfo = curbuf->b_visual;
-#endif
     curbuf->b_op_start.lnum = curbuf->b_ml.ml_line_count;
     curbuf->b_op_start.col = 0;
     curbuf->b_op_end.lnum = 0;
@@ -2577,13 +2852,11 @@
 	    curbuf->b_namedm[i] = curhead->uh_namedm[i];
 	    curhead->uh_namedm[i] = namedm[i];
 	}
-#ifdef FEAT_VISUAL
     if (curhead->uh_visual.vi_start.lnum != 0)
     {
 	curbuf->b_visual = curhead->uh_visual;
 	curhead->uh_visual = visualinfo;
     }
-#endif
 
     /*
      * If the cursor is only off by one line, put it at the same position as
@@ -2750,7 +3023,7 @@
     if (im_is_preediting())
 	return;		    /* XIM is busy, don't break an undo sequence */
 #endif
-    if (p_ul < 0)
+    if (get_undolevel() < 0)
 	curbuf->b_u_synced = TRUE;  /* no entries, nothing to do */
     else
     {
@@ -2910,7 +3183,7 @@
     }
     if (!curbuf->b_u_synced)
 	return;		    /* already unsynced */
-    if (p_ul < 0)
+    if (get_undolevel() < 0)
 	return;		    /* no entries, nothing to do */
     else
     {
@@ -3107,7 +3380,8 @@
      * all the pointers. */
     if (uhp == buf->b_u_oldhead)
     {
-	u_freeheader(buf, uhp, uhpp);
+	while (buf->b_u_oldhead != NULL)
+	    u_freeheader(buf, buf->b_u_oldhead, uhpp);
 	return;
     }
 
diff -Naur vim74.orig/src/version.c vim74/src/version.c
--- vim74.orig/src/version.c	2013-08-10 11:29:20.000000000 +0000
+++ vim74/src/version.c	2014-10-10 14:53:45.845376778 +0000
@@ -60,6 +60,11 @@
 
 static char *(features[]) =
 {
+#ifdef HAVE_ACL
+	"+acl",
+#else
+	"-acl",
+#endif
 #ifdef AMIGA		/* only for Amiga systems */
 # ifdef FEAT_ARP
 	"+ARP",
@@ -184,6 +189,13 @@
 #else
 	"-digraphs",
 #endif
+#ifdef FEAT_GUI_W32
+# ifdef FEAT_DIRECTX
+	"+directx",
+# else
+	"-directx",
+# endif
+#endif
 #ifdef FEAT_DND
 	"+dnd",
 #else
@@ -637,15 +649,11 @@
 #else
 	"-virtualedit",
 #endif
-#ifdef FEAT_VISUAL
 	"+visual",
-# ifdef FEAT_VISUALEXTRA
+#ifdef FEAT_VISUALEXTRA
 	"+visualextra",
-# else
-	"-visualextra",
-# endif
 #else
-	"-visual",
+	"-visualextra",
 #endif
 #ifdef FEAT_VIMINFO
 	"+viminfo",
@@ -721,6 +729,12 @@
 # else
 	"-xpm_w32",
 # endif
+#else
+# ifdef HAVE_XPM
+	"+xpm",
+# else
+	"-xpm",
+# endif
 #endif
 	NULL
 };
@@ -728,6 +742,952 @@
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    473,
+/**/
+    472,
+/**/
+    471,
+/**/
+    470,
+/**/
+    469,
+/**/
+    468,
+/**/
+    467,
+/**/
+    466,
+/**/
+    465,
+/**/
+    464,
+/**/
+    463,
+/**/
+    462,
+/**/
+    461,
+/**/
+    460,
+/**/
+    459,
+/**/
+    458,
+/**/
+    457,
+/**/
+    456,
+/**/
+    455,
+/**/
+    454,
+/**/
+    453,
+/**/
+    452,
+/**/
+    451,
+/**/
+    450,
+/**/
+    449,
+/**/
+    448,
+/**/
+    447,
+/**/
+    446,
+/**/
+    445,
+/**/
+    444,
+/**/
+    443,
+/**/
+    442,
+/**/
+    441,
+/**/
+    440,
+/**/
+    439,
+/**/
+    438,
+/**/
+    437,
+/**/
+    436,
+/**/
+    435,
+/**/
+    434,
+/**/
+    433,
+/**/
+    432,
+/**/
+    431,
+/**/
+    430,
+/**/
+    429,
+/**/
+    428,
+/**/
+    427,
+/**/
+    426,
+/**/
+    425,
+/**/
+    424,
+/**/
+    423,
+/**/
+    422,
+/**/
+    421,
+/**/
+    420,
+/**/
+    419,
+/**/
+    418,
+/**/
+    417,
+/**/
+    416,
+/**/
+    415,
+/**/
+    414,
+/**/
+    413,
+/**/
+    412,
+/**/
+    411,
+/**/
+    410,
+/**/
+    409,
+/**/
+    408,
+/**/
+    407,
+/**/
+    406,
+/**/
+    405,
+/**/
+    404,
+/**/
+    403,
+/**/
+    402,
+/**/
+    401,
+/**/
+    400,
+/**/
+    399,
+/**/
+    398,
+/**/
+    397,
+/**/
+    396,
+/**/
+    395,
+/**/
+    394,
+/**/
+    393,
+/**/
+    392,
+/**/
+    391,
+/**/
+    390,
+/**/
+    389,
+/**/
+    388,
+/**/
+    387,
+/**/
+    386,
+/**/
+    385,
+/**/
+    384,
+/**/
+    383,
+/**/
+    382,
+/**/
+    381,
+/**/
+    380,
+/**/
+    379,
+/**/
+    378,
+/**/
+    377,
+/**/
+    376,
+/**/
+    375,
+/**/
+    374,
+/**/
+    373,
+/**/
+    372,
+/**/
+    371,
+/**/
+    370,
+/**/
+    369,
+/**/
+    368,
+/**/
+    367,
+/**/
+    366,
+/**/
+    365,
+/**/
+    364,
+/**/
+    363,
+/**/
+    362,
+/**/
+    361,
+/**/
+    360,
+/**/
+    359,
+/**/
+    358,
+/**/
+    357,
+/**/
+    356,
+/**/
+    355,
+/**/
+    354,
+/**/
+    353,
+/**/
+    352,
+/**/
+    351,
+/**/
+    350,
+/**/
+    349,
+/**/
+    348,
+/**/
+    347,
+/**/
+    346,
+/**/
+    345,
+/**/
+    344,
+/**/
+    343,
+/**/
+    342,
+/**/
+    341,
+/**/
+    340,
+/**/
+    339,
+/**/
+    338,
+/**/
+    337,
+/**/
+    336,
+/**/
+    335,
+/**/
+    334,
+/**/
+    333,
+/**/
+    332,
+/**/
+    331,
+/**/
+    330,
+/**/
+    329,
+/**/
+    328,
+/**/
+    327,
+/**/
+    326,
+/**/
+    325,
+/**/
+    324,
+/**/
+    323,
+/**/
+    322,
+/**/
+    321,
+/**/
+    320,
+/**/
+    319,
+/**/
+    318,
+/**/
+    317,
+/**/
+    316,
+/**/
+    315,
+/**/
+    314,
+/**/
+    313,
+/**/
+    312,
+/**/
+    311,
+/**/
+    310,
+/**/
+    309,
+/**/
+    308,
+/**/
+    307,
+/**/
+    306,
+/**/
+    305,
+/**/
+    304,
+/**/
+    303,
+/**/
+    302,
+/**/
+    301,
+/**/
+    300,
+/**/
+    299,
+/**/
+    298,
+/**/
+    297,
+/**/
+    296,
+/**/
+    295,
+/**/
+    294,
+/**/
+    293,
+/**/
+    292,
+/**/
+    291,
+/**/
+    290,
+/**/
+    289,
+/**/
+    288,
+/**/
+    287,
+/**/
+    286,
+/**/
+    285,
+/**/
+    284,
+/**/
+    283,
+/**/
+    282,
+/**/
+    281,
+/**/
+    280,
+/**/
+    279,
+/**/
+    278,
+/**/
+    277,
+/**/
+    276,
+/**/
+    275,
+/**/
+    274,
+/**/
+    273,
+/**/
+    272,
+/**/
+    271,
+/**/
+    270,
+/**/
+    269,
+/**/
+    268,
+/**/
+    267,
+/**/
+    266,
+/**/
+    265,
+/**/
+    264,
+/**/
+    263,
+/**/
+    262,
+/**/
+    261,
+/**/
+    260,
+/**/
+    259,
+/**/
+    258,
+/**/
+    257,
+/**/
+    256,
+/**/
+    255,
+/**/
+    254,
+/**/
+    253,
+/**/
+    252,
+/**/
+    251,
+/**/
+    250,
+/**/
+    249,
+/**/
+    248,
+/**/
+    247,
+/**/
+    246,
+/**/
+    245,
+/**/
+    244,
+/**/
+    243,
+/**/
+    242,
+/**/
+    241,
+/**/
+    240,
+/**/
+    239,
+/**/
+    238,
+/**/
+    237,
+/**/
+    236,
+/**/
+    235,
+/**/
+    234,
+/**/
+    233,
+/**/
+    232,
+/**/
+    231,
+/**/
+    230,
+/**/
+    229,
+/**/
+    228,
+/**/
+    227,
+/**/
+    226,
+/**/
+    225,
+/**/
+    224,
+/**/
+    223,
+/**/
+    222,
+/**/
+    221,
+/**/
+    220,
+/**/
+    219,
+/**/
+    218,
+/**/
+    217,
+/**/
+    216,
+/**/
+    215,
+/**/
+    214,
+/**/
+    213,
+/**/
+    212,
+/**/
+    211,
+/**/
+    210,
+/**/
+    209,
+/**/
+    208,
+/**/
+    207,
+/**/
+    206,
+/**/
+    205,
+/**/
+    204,
+/**/
+    203,
+/**/
+    202,
+/**/
+    201,
+/**/
+    200,
+/**/
+    199,
+/**/
+    198,
+/**/
+    197,
+/**/
+    196,
+/**/
+    195,
+/**/
+    194,
+/**/
+    193,
+/**/
+    192,
+/**/
+    191,
+/**/
+    190,
+/**/
+    189,
+/**/
+    188,
+/**/
+    187,
+/**/
+    186,
+/**/
+    185,
+/**/
+    184,
+/**/
+    183,
+/**/
+    182,
+/**/
+    181,
+/**/
+    180,
+/**/
+    179,
+/**/
+    178,
+/**/
+    177,
+/**/
+    176,
+/**/
+    175,
+/**/
+    174,
+/**/
+    173,
+/**/
+    172,
+/**/
+    171,
+/**/
+    170,
+/**/
+    169,
+/**/
+    168,
+/**/
+    167,
+/**/
+    166,
+/**/
+    165,
+/**/
+    164,
+/**/
+    163,
+/**/
+    162,
+/**/
+    161,
+/**/
+    160,
+/**/
+    159,
+/**/
+    158,
+/**/
+    157,
+/**/
+    156,
+/**/
+    155,
+/**/
+    154,
+/**/
+    153,
+/**/
+    152,
+/**/
+    151,
+/**/
+    150,
+/**/
+    149,
+/**/
+    148,
+/**/
+    147,
+/**/
+    146,
+/**/
+    145,
+/**/
+    144,
+/**/
+    143,
+/**/
+    142,
+/**/
+    141,
+/**/
+    140,
+/**/
+    139,
+/**/
+    138,
+/**/
+    137,
+/**/
+    136,
+/**/
+    135,
+/**/
+    134,
+/**/
+    133,
+/**/
+    132,
+/**/
+    131,
+/**/
+    130,
+/**/
+    129,
+/**/
+    128,
+/**/
+    127,
+/**/
+    126,
+/**/
+    125,
+/**/
+    124,
+/**/
+    123,
+/**/
+    122,
+/**/
+    121,
+/**/
+    120,
+/**/
+    119,
+/**/
+    118,
+/**/
+    117,
+/**/
+    116,
+/**/
+    115,
+/**/
+    114,
+/**/
+    113,
+/**/
+    112,
+/**/
+    111,
+/**/
+    110,
+/**/
+    109,
+/**/
+    108,
+/**/
+    107,
+/**/
+    106,
+/**/
+    105,
+/**/
+    104,
+/**/
+    103,
+/**/
+    102,
+/**/
+    101,
+/**/
+    100,
+/**/
+    99,
+/**/
+    98,
+/**/
+    97,
+/**/
+    96,
+/**/
+    95,
+/**/
+    94,
+/**/
+    93,
+/**/
+    92,
+/**/
+    91,
+/**/
+    90,
+/**/
+    89,
+/**/
+    88,
+/**/
+    87,
+/**/
+    86,
+/**/
+    85,
+/**/
+    84,
+/**/
+    83,
+/**/
+    82,
+/**/
+    81,
+/**/
+    80,
+/**/
+    79,
+/**/
+    78,
+/**/
+    77,
+/**/
+    76,
+/**/
+    75,
+/**/
+    74,
+/**/
+    73,
+/**/
+    72,
+/**/
+    71,
+/**/
+    70,
+/**/
+    69,
+/**/
+    68,
+/**/
+    67,
+/**/
+    66,
+/**/
+    65,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    57,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    49,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    45,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    41,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    36,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    32,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    27,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    7,
+/**/
+    6,
+/**/
+    5,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
     0
 };
 
diff -Naur vim74.orig/src/vim.h vim74/src/vim.h
--- vim74.orig/src/vim.h	2013-08-02 14:02:27.000000000 +0000
+++ vim74/src/vim.h	2014-10-10 14:53:45.855376753 +0000
@@ -43,7 +43,7 @@
  * it becomes zero.  This is likely a problem of not being able to run the
  * test program.  Other items from configure may also be wrong then!
  */
-# if (SIZEOF_INT == 0)
+# if (VIM_SIZEOF_INT == 0)
     Error: configure did not run properly.  Check auto/config.log.
 # endif
 
@@ -77,6 +77,10 @@
 # endif
 # include <floss.h>
 # define ROOT_UID 65535
+# define OLDXAW
+# if (_TANDEM_ARCH_ == 2 && __H_Series_RVU >= 621)
+#  define SA_ONSTACK_COMPATIBILITY
+# endif
 #else
 # define ROOT_UID 0
 #endif
@@ -130,6 +134,13 @@
 # endif
 #endif
 
+/* Check support for rendering options */
+#ifdef FEAT_GUI
+# if defined(FEAT_DIRECTX)
+#  define FEAT_RENDER_OPTIONS
+# endif
+#endif
+
 /* Visual Studio 2005 has 'deprecated' many of the standard CRT functions */
 #if _MSC_VER >= 1400
 # define _CRT_SECURE_NO_DEPRECATE
@@ -148,22 +159,22 @@
 #endif
 
 /*
- * SIZEOF_INT is used in feature.h, and the system-specific included files
- * need items from feature.h.  Therefore define SIZEOF_INT here.
+ * VIM_SIZEOF_INT is used in feature.h, and the system-specific included files
+ * need items from feature.h.  Therefore define VIM_SIZEOF_INT here.
  */
 #ifdef WIN3264
-# define SIZEOF_INT 4
+# define VIM_SIZEOF_INT 4
 #endif
 #ifdef MSDOS
 # ifdef DJGPP
 #  ifndef FEAT_GUI_GTK		/* avoid problems when generating prototypes */
-#   define SIZEOF_INT 4		/* 32 bit ints */
+#   define VIM_SIZEOF_INT 4	/* 32 bit ints */
 #  endif
 #  define DOS32
 #  define FEAT_CLIPBOARD
 # else
 #  ifndef FEAT_GUI_GTK		/* avoid problems when generating prototypes */
-#   define SIZEOF_INT 2		/* 16 bit ints */
+#   define VIM_SIZEOF_INT 2	/* 16 bit ints */
 #  endif
 #  define SMALL_MALLOC		/* 16 bit storage allocation */
 #  define DOS16
@@ -174,18 +185,18 @@
   /* Be conservative about sizeof(int). It could be 4 too. */
 # ifndef FEAT_GUI_GTK	/* avoid problems when generating prototypes */
 #  ifdef __GNUC__
-#   define SIZEOF_INT	4
+#   define VIM_SIZEOF_INT	4
 #  else
-#   define SIZEOF_INT	2
+#   define VIM_SIZEOF_INT	2
 #  endif
 # endif
 #endif
 #ifdef MACOS
 # if defined(__POWERPC__) || defined(MACOS_X) || defined(__fourbyteints__) \
   || defined(__MRC__) || defined(__SC__) || defined(__APPLE_CC__)/* MPW Compilers */
-#  define SIZEOF_INT 4
+#  define VIM_SIZEOF_INT 4
 # else
-#  define SIZEOF_INT 2
+#  define VIM_SIZEOF_INT 2
 # endif
 #endif
 
@@ -417,12 +428,12 @@
 #define PRINTF_DECIMAL_LONG_U SCANF_DECIMAL_LONG_U
 
 /*
- * Only systems which use configure will have SIZEOF_OFF_T and SIZEOF_LONG
+ * Only systems which use configure will have SIZEOF_OFF_T and VIM_SIZEOF_LONG
  * defined, which is ok since those are the same systems which can have
  * varying sizes for off_t.  The other systems will continue to use "%ld" to
  * print off_t since off_t is simply a typedef to long for them.
  */
-#if defined(SIZEOF_OFF_T) && (SIZEOF_OFF_T > SIZEOF_LONG)
+#if defined(SIZEOF_OFF_T) && (SIZEOF_OFF_T > VIM_SIZEOF_LONG)
 # define LONG_LONG_OFF_T
 #endif
 
@@ -448,7 +459,7 @@
 # ifdef UNICODE16
 typedef unsigned short u8char_T;    /* short should be 16 bits */
 # else
-#  if SIZEOF_INT >= 4
+#  if VIM_SIZEOF_INT >= 4
 typedef unsigned int u8char_T;	    /* int is 32 bits */
 #  else
 typedef unsigned long u8char_T;	    /* long should be 32 bits or more */
@@ -824,6 +835,7 @@
 #define EW_ICASE	0x100	/* ignore case */
 #define EW_NOERROR	0x200	/* no error for bad regexp */
 #define EW_NOTWILD	0x400	/* add match with literal name if exists */
+#define EW_KEEPDOLLAR	0x800	/* do not escape $, $var is expanded */
 /* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND
  * is used when executing commands and EW_SILENT for interactive expanding. */
 
@@ -1176,6 +1188,15 @@
 #define RESIZE_BOTH	15	/* resize in both directions */
 
 /*
+ * flags for check_changed()
+ */
+#define CCGD_AW		1	/* do autowrite if buffer was changed */
+#define CCGD_MULTWIN	2	/* check also when several wins for the buf */
+#define CCGD_FORCEIT	4	/* ! used */
+#define CCGD_ALLBUF	8	/* may write all buffers */
+#define CCGD_EXCMD	16	/* may suggest using ! */
+
+/*
  * "flags" values for option-setting functions.
  * When OPT_GLOBAL and OPT_LOCAL are both missing, set both local and global
  * values, get local value.
@@ -1306,6 +1327,7 @@
     EVENT_SHELLFILTERPOST,	/* after ":1,2!cmd", ":w !cmd", ":r !cmd". */
     EVENT_TEXTCHANGED,		/* text was modified */
     EVENT_TEXTCHANGEDI,		/* text was modified in Insert mode*/
+    EVENT_CMDUNDEFINED,		/* command undefined */
     NUM_EVENTS			/* MUST be the last one */
 };
 
@@ -1599,7 +1621,7 @@
  * With this we restrict the maximum line length to 1073741823. I guess this is
  * not a real problem. BTW:  Longer lines are split.
  */
-#if SIZEOF_INT >= 4
+#if VIM_SIZEOF_INT >= 4
 # ifdef __MVS__
 #  define MAXCOL (0x3fffffffL)		/* maximum column number, 30 bits */
 # else
@@ -1864,9 +1886,11 @@
 #define VV_MOUSE_COL	51
 #define VV_OP		52
 #define VV_SEARCHFORWARD 53
-#define VV_OLDFILES	54
-#define VV_WINDOWID	55
-#define VV_LEN		56	/* number of v: vars */
+#define VV_HLSEARCH	54
+#define VV_OLDFILES	55
+#define VV_WINDOWID	56
+#define VV_PROGPATH	57
+#define VV_LEN		58	/* number of v: vars */
 
 #ifdef FEAT_CLIPBOARD
 
@@ -2239,11 +2263,23 @@
 #define SOPT_BUF	0x20	/* Option has buffer-local value */
 #define SOPT_UNSET	0x40	/* Option does not have local value set */
 
+/* Option types for various functions in option.c */
 #define SREQ_GLOBAL	0	/* Request global option */
 #define SREQ_WIN	1	/* Request window-local option */
 #define SREQ_BUF	2	/* Request buffer-local option */
 
+/* Flags for get_reg_contents */
+#define GREG_NO_EXPR	1	/* Do not allow expression register */
+#define GREG_EXPR_SRC	2	/* Return expression itself for "=" register */
+#define GREG_LIST	4	/* Return list */
+
 /* Character used as separated in autoload function/variable names. */
 #define AUTOLOAD_CHAR '#'
 
+#ifdef FEAT_EVAL
+# define SET_NO_HLSEARCH(flag) no_hlsearch = (flag); set_vim_var_nr(VV_HLSEARCH, !no_hlsearch)
+#else
+# define SET_NO_HLSEARCH(flag) no_hlsearch = (flag)
+#endif
+
 #endif /* VIM__H */
diff -Naur vim74.orig/src/winclip.c vim74/src/winclip.c
--- vim74.orig/src/winclip.c	2013-07-01 19:05:53.000000000 +0000
+++ vim74/src/winclip.c	2014-10-10 14:53:45.885376678 +0000
@@ -797,4 +797,29 @@
 	vim_free(widestr);
     }
 }
+
+/*
+ * Convert from 'encoding' to the active codepage.
+ * Input is "str[str_size]".
+ * The result is in allocated memory: "out[outlen]".  With terminating NUL.
+ */
+    void
+enc_to_acp(str, str_size, out, outlen)
+    char_u	*str;
+    int		str_size;
+    char_u	**out;
+    int		*outlen;
+
+{
+    LPWSTR	widestr;
+    int		len = str_size;
+
+    widestr = (WCHAR *)enc_to_utf16(str, &len);
+    if (widestr != NULL)
+    {
+	WideCharToMultiByte_alloc(GetACP(), 0, widestr, len,
+						(LPSTR *)out, outlen, 0, 0);
+	vim_free(widestr);
+    }
+}
 #endif
diff -Naur vim74.orig/src/window.c vim74/src/window.c
--- vim74.orig/src/window.c	2013-07-24 15:38:29.000000000 +0000
+++ vim74/src/window.c	2014-10-10 14:53:45.892043327 +0000
@@ -130,9 +130,7 @@
     case Ctrl_S:
     case 's':
 		CHECK_CMDWIN
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 #ifdef FEAT_QUICKFIX
 		/* When splitting the quickfix window open a new buffer in it,
 		 * don't replicate the quickfix buffer. */
@@ -150,9 +148,7 @@
     case Ctrl_V:
     case 'v':
 		CHECK_CMDWIN
-# ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-# endif
 # ifdef FEAT_QUICKFIX
 		/* When splitting the quickfix window open a new buffer in it,
 		 * don't replicate the quickfix buffer. */
@@ -170,9 +166,7 @@
     case Ctrl_HAT:
     case '^':
 		CHECK_CMDWIN
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 		STRCPY(cbuf, "split #");
 		if (Prenum)
 		    vim_snprintf((char *)cbuf + 7, sizeof(cbuf) - 7,
@@ -184,9 +178,7 @@
     case Ctrl_N:
     case 'n':
 		CHECK_CMDWIN
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 #ifdef FEAT_QUICKFIX
 newwindow:
 #endif
@@ -206,18 +198,14 @@
 /* quit current window */
     case Ctrl_Q:
     case 'q':
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 		do_cmdline_cmd((char_u *)"quit");
 		break;
 
 /* close current window */
     case Ctrl_C:
     case 'c':
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 		do_cmdline_cmd((char_u *)"close");
 		break;
 
@@ -226,9 +214,7 @@
     case Ctrl_Z:
     case 'z':
 		CHECK_CMDWIN
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 		do_cmdline_cmd((char_u *)"pclose");
 		break;
 
@@ -248,9 +234,7 @@
     case Ctrl_O:
     case 'o':
 		CHECK_CMDWIN
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 		do_cmdline_cmd((char_u *)"only");
 		break;
 
@@ -399,18 +383,14 @@
     case Ctrl_R:
     case 'r':
 		CHECK_CMDWIN
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 		win_rotate(FALSE, (int)Prenum1);    /* downwards */
 		break;
 
 /* rotate windows upwards */
     case 'R':
 		CHECK_CMDWIN
-#ifdef FEAT_VISUAL
 		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 		win_rotate(TRUE, (int)Prenum1);	    /* upwards */
 		break;
 
@@ -499,16 +479,18 @@
     case ']':
     case Ctrl_RSB:
 		CHECK_CMDWIN
-#ifdef FEAT_VISUAL
-		reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
+		/* keep Visual mode, can select words to use as a tag */
 		if (Prenum)
 		    postponed_split = Prenum;
 		else
 		    postponed_split = -1;
+#ifdef FEAT_QUICKFIX
+		if (nchar != '}')
+		    g_do_tagpreview = 0;
+#endif
 
-		/* Execute the command right here, required when
-		 * "wincmd ]" was used in a function. */
+		/* Execute the command right here, required when "wincmd ]"
+		 * was used in a function. */
 		do_nv_ident(Ctrl_RSB, NUL);
 		break;
 
@@ -612,9 +594,7 @@
 #endif
 		    case ']':
 		    case Ctrl_RSB:
-#ifdef FEAT_VISUAL
-			reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
+			/* keep Visual mode, can select words to use as a tag */
 			if (Prenum)
 			    postponed_split = Prenum;
 			else
@@ -708,8 +688,10 @@
     int		available;
     int		oldwin_height = 0;
     int		layout;
-    frame_T	*frp, *curfrp;
+    frame_T	*frp, *curfrp, *frp2, *prevfrp;
     int		before;
+    int		minheight;
+    int		wmh1;
 
     if (flags & WSP_TOP)
 	oldwin = firstwin;
@@ -738,22 +720,49 @@
 #ifdef FEAT_VERTSPLIT
     if (flags & WSP_VERT)
     {
+	int	wmw1;
+	int	minwidth;
+
 	layout = FR_ROW;
 
 	/*
 	 * Check if we are able to split the current window and compute its
 	 * width.
 	 */
-	needed = p_wmw + 1;
+	/* Current window requires at least 1 space. */
+	wmw1 = (p_wmw == 0 ? 1 : p_wmw);
+	needed = wmw1 + 1;
 	if (flags & WSP_ROOM)
-	    needed += p_wiw - p_wmw;
-	if (p_ea || (flags & (WSP_BOT | WSP_TOP)))
+	    needed += p_wiw - wmw1;
+	if (flags & (WSP_BOT | WSP_TOP))
 	{
+	    minwidth = frame_minwidth(topframe, NOWIN);
 	    available = topframe->fr_width;
-	    needed += frame_minwidth(topframe, NULL);
+	    needed += minwidth;
+	}
+	else if (p_ea)
+	{
+	    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);
+	    prevfrp = oldwin->w_frame;
+	    for (frp = oldwin->w_frame->fr_parent; frp != NULL;
+							frp = frp->fr_parent)
+	    {
+		if (frp->fr_layout == FR_ROW)
+		    for (frp2 = frp->fr_child; frp2 != NULL;
+							frp2 = frp2->fr_next)
+			if (frp2 != prevfrp)
+			    minwidth += frame_minwidth(frp2, NOWIN);
+		prevfrp = frp;
+	    }
+	    available = topframe->fr_width;
+	    needed += minwidth;
 	}
 	else
-	    available = oldwin->w_width;
+	{
+	    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);
+	    available = oldwin->w_frame->fr_width;
+	    needed += minwidth;
+	}
 	if (available < needed && new_wp == NULL)
 	{
 	    EMSG(_(e_noroom));
@@ -761,10 +770,10 @@
 	}
 	if (new_size == 0)
 	    new_size = oldwin->w_width / 2;
-	if (new_size > oldwin->w_width - p_wmw - 1)
-	    new_size = oldwin->w_width - p_wmw - 1;
-	if (new_size < p_wmw)
-	    new_size = p_wmw;
+	if (new_size > available - minwidth - 1)
+	    new_size = available - minwidth - 1;
+	if (new_size < wmw1)
+	    new_size = wmw1;
 
 	/* if it doesn't fit in the current window, need win_equal() */
 	if (oldwin->w_width - new_size - 1 < p_wmw)
@@ -805,18 +814,39 @@
 	 * Check if we are able to split the current window and compute its
 	 * height.
 	 */
-	needed = p_wmh + STATUS_HEIGHT + need_status;
+	/* Current window requires at least 1 space. */
+	wmh1 = (p_wmh == 0 ? 1 : p_wmh);
+	needed = wmh1 + STATUS_HEIGHT;
 	if (flags & WSP_ROOM)
-	    needed += p_wh - p_wmh;
-	if (p_ea || (flags & (WSP_BOT | WSP_TOP)))
+	    needed += p_wh - wmh1;
+	if (flags & (WSP_BOT | WSP_TOP))
 	{
+	    minheight = frame_minheight(topframe, NOWIN) + need_status;
 	    available = topframe->fr_height;
-	    needed += frame_minheight(topframe, NULL);
+	    needed += minheight;
+	}
+	else if (p_ea)
+	{
+	    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;
+	    prevfrp = oldwin->w_frame;
+	    for (frp = oldwin->w_frame->fr_parent; frp != NULL;
+							frp = frp->fr_parent)
+	    {
+		if (frp->fr_layout == FR_COL)
+		    for (frp2 = frp->fr_child; frp2 != NULL;
+							frp2 = frp2->fr_next)
+			if (frp2 != prevfrp)
+			    minheight += frame_minheight(frp2, NOWIN);
+		prevfrp = frp;
+	    }
+	    available = topframe->fr_height;
+	    needed += minheight;
 	}
 	else
 	{
-	    available = oldwin->w_height;
-	    needed += p_wmh;
+	    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;
+	    available = oldwin->w_frame->fr_height;
+	    needed += minheight;
 	}
 	if (available < needed && new_wp == NULL)
 	{
@@ -831,11 +861,10 @@
 	}
 	if (new_size == 0)
 	    new_size = oldwin_height / 2;
-
-	if (new_size > oldwin_height - p_wmh - STATUS_HEIGHT)
-	    new_size = oldwin_height - p_wmh - STATUS_HEIGHT;
-	if (new_size < p_wmh)
-	    new_size = p_wmh;
+	if (new_size > available - minheight - STATUS_HEIGHT)
+	    new_size = available - minheight - STATUS_HEIGHT;
+	if (new_size < wmh1)
+	    new_size = wmh1;
 
 	/* if it doesn't fit in the current window, need win_equal() */
 	if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)
@@ -1153,6 +1182,11 @@
 	    p_wh = size;
     }
 
+#ifdef FEAT_JUMPLIST
+    /* Keep same changelist position in new window. */
+    wp->w_changelistidx = oldwin->w_changelistidx;
+#endif
+
     /*
      * make the new window the current window
      */
@@ -1216,8 +1250,8 @@
     else
 	copy_loclist(oldp, newp);
 #endif
-    if (oldp->w_localdir != NULL)
-	newp->w_localdir = vim_strsave(oldp->w_localdir);
+    newp->w_localdir = (oldp->w_localdir == NULL)
+				    ? NULL : vim_strsave(oldp->w_localdir);
 
     /* copy tagstack and folds */
     for (i = 0; i < oldp->w_tagstacklen; i++)
@@ -1241,7 +1275,7 @@
 }
 
 /*
- * Initialize window "newp" from window"old".
+ * Initialize window "newp" from window "old".
  * Only the essential things are copied.
  */
     static void
@@ -2172,8 +2206,9 @@
  * If "free_buf" is TRUE related buffer may be unloaded.
  *
  * Called by :quit, :close, :xit, :wq and findtag().
+ * Returns FAIL when the window was not closed.
  */
-    void
+    int
 win_close(win, free_buf)
     win_T	*win;
     int		free_buf;
@@ -2190,21 +2225,21 @@
     if (last_window())
     {
 	EMSG(_("E444: Cannot close last window"));
-	return;
+	return FAIL;
     }
 
 #ifdef FEAT_AUTOCMD
     if (win->w_closing || (win->w_buffer != NULL && win->w_buffer->b_closing))
-	return; /* window is already being closed */
+	return FAIL; /* window is already being closed */
     if (win == aucmd_win)
     {
 	EMSG(_("E813: Cannot close autocmd window"));
-	return;
+	return FAIL;
     }
     if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())
     {
 	EMSG(_("E814: Cannot close window, only autocmd window would remain"));
-	return;
+	return FAIL;
     }
 #endif
 
@@ -2212,7 +2247,7 @@
      * and then close the window and the tab page to avoid that curwin and
      * curtab are invalid while we are freeing memory. */
     if (close_last_window_tabpage(win, free_buf, prev_curtab))
-      return;
+      return FAIL;
 
     /* When closing the help window, try restoring a snapshot after closing
      * the window.  Otherwise clear the snapshot, it's now invalid. */
@@ -2240,22 +2275,22 @@
 	    win->w_closing = TRUE;
 	    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
 	    if (!win_valid(win))
-		return;
+		return FAIL;
 	    win->w_closing = FALSE;
 	    if (last_window())
-		return;
+		return FAIL;
 	}
 	win->w_closing = TRUE;
 	apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);
 	if (!win_valid(win))
-	    return;
+	    return FAIL;
 	win->w_closing = FALSE;
 	if (last_window())
-	    return;
+	    return FAIL;
 # ifdef FEAT_EVAL
 	/* autocmds may abort script processing */
 	if (aborting())
-	    return;
+	    return FAIL;
 # endif
     }
 #endif
@@ -2303,7 +2338,7 @@
      * other window or moved to another tab page. */
     else if (!win_valid(win) || last_window() || curtab != prev_curtab
 	    || close_last_window_tabpage(win, free_buf, prev_curtab))
-	return;
+	return FAIL;
 
     /* Free the memory used for the window and get the window that received
      * the screen space. */
@@ -2383,6 +2418,7 @@
 #endif
 
     redraw_all_later(NOT_VALID);
+    return OK;
 }
 
 /*
@@ -2499,6 +2535,10 @@
 
     while (firstwin != NULL)
 	(void)win_free_mem(firstwin, &dummy, NULL);
+
+    /* No window should be used after this. Set curwin to NULL to crash
+     * instead of using freed memory. */
+    curwin = NULL;
 }
 #endif
 
@@ -3724,9 +3764,7 @@
 {
     tabpage_T	*tp = curtab;
 
-#ifdef FEAT_VISUAL
     reset_VIsual_and_resel();	/* stop Visual mode */
-#endif
 #ifdef FEAT_AUTOCMD
     if (trigger_leave_autocmds)
     {
@@ -4027,12 +4065,10 @@
 	return;
 #endif
 
-#ifdef FEAT_VISUAL
     if (wp->w_buffer != curbuf)
 	reset_VIsual_and_resel();
     else if (VIsual_active)
 	wp->w_cursor = curwin->w_cursor;
-#endif
 
 #ifdef FEAT_GUI
     need_mouse_correct = TRUE;
@@ -4276,6 +4312,11 @@
     /* sync undo before leaving the current buffer */
     if (undo_sync && curbuf != wp->w_buffer)
 	u_sync(FALSE);
+
+    /* Might need to scroll the old window before switching, e.g., when the
+     * cursor was moved. */
+    update_topline();
+
     /* may have to copy the buffer options when 'cpo' contains 'S' */
     if (wp->w_buffer != curbuf)
 	buf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);
@@ -4623,7 +4664,15 @@
     if (wp != aucmd_win)
 #endif
 	win_remove(wp, tp);
-    vim_free(wp);
+#ifdef FEAT_AUTOCMD
+    if (autocmd_busy)
+    {
+	wp->w_next = au_pending_free_win;
+	au_pending_free_win = wp;
+    }
+    else
+#endif
+	vim_free(wp);
 
 #ifdef FEAT_AUTOCMD
     unblock_autocmds();
@@ -4747,8 +4796,12 @@
 win_free_lsize(wp)
     win_T	*wp;
 {
-    vim_free(wp->w_lines);
-    wp->w_lines = NULL;
+    /* TODO: why would wp be NULL here? */
+    if (wp != NULL)
+    {
+	vim_free(wp->w_lines);
+	wp->w_lines = NULL;
+    }
 }
 
 /*
@@ -4845,15 +4898,20 @@
     garray_T	*gap;
 {
     win_T	*wp;
-    int		i;
+    int		i, j;
 
     if (win_count() * 2 == gap->ga_len)
     {
-	i = 0;
-	for (wp = firstwin; wp != NULL; wp = wp->w_next)
+	/* The order matters, because frames contain other frames, but it's
+	 * difficult to get right. The easy way out is to do it twice. */
+	for (j = 0; j < 2; ++j)
 	{
-	    frame_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);
-	    win_setheight_win(((int *)gap->ga_data)[i++], wp);
+	    i = 0;
+	    for (wp = firstwin; wp != NULL; wp = wp->w_next)
+	    {
+		frame_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);
+		win_setheight_win(((int *)gap->ga_data)[i++], wp);
+	    }
 	}
 	/* recompute the window positions */
 	(void)win_comp_pos();
@@ -5649,7 +5707,7 @@
     win_T	*wp;
 {
     wp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT
-				    + FRACTION_MULT / 2) / (long)wp->w_height;
+				    + wp->w_height / 2) / (long)wp->w_height;
 }
 
 /*
@@ -5664,6 +5722,7 @@
 {
     linenr_T	lnum;
     int		sline, line_size;
+    int		prev_height = wp->w_height;
 
     /* Don't want a negative height.  Happens when splitting a tiny window.
      * Will equalize heights soon to fix it. */
@@ -5672,8 +5731,18 @@
     if (wp->w_height == height)
 	return;	    /* nothing to do */
 
-    if (wp->w_wrow != wp->w_prev_fraction_row && wp->w_height > 0)
-	set_fraction(wp);
+    if (wp->w_height > 0)
+    {
+	if (wp == curwin)
+	    /* w_wrow needs to be valid. When setting 'laststatus' this may
+	     * call win_new_height() recursively. */
+	    validate_cursor();
+	if (wp->w_height != prev_height)
+	    return;  /* Recursive call already changed the size, bail out here
+			to avoid the following to mess things up. */
+	if (wp->w_wrow != wp->w_prev_fraction_row)
+	    set_fraction(wp);
+    }
 
     wp->w_height = height;
     wp->w_skipcol = 0;
@@ -5693,7 +5762,8 @@
 	lnum = wp->w_cursor.lnum;
 	if (lnum < 1)		/* can happen when starting up */
 	    lnum = 1;
-	wp->w_wrow = ((long)wp->w_fraction * (long)height - 1L) / FRACTION_MULT;
+	wp->w_wrow = ((long)wp->w_fraction * (long)height - 1L
+					 + FRACTION_MULT / 2) / FRACTION_MULT;
 	line_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;
 	sline = wp->w_wrow - line_size;
 
@@ -5729,8 +5799,9 @@
 		    --wp->w_wrow;
 		}
 	    }
+	    set_topline(wp, lnum);
 	}
-	else
+	else if (sline > 0)
 	{
 	    while (sline > 0 && lnum > 1)
 	    {
@@ -5773,8 +5844,9 @@
 		lnum = 1;
 		wp->w_wrow -= sline;
 	    }
+
+	    set_topline(wp, lnum);
 	}
-	set_topline(wp, lnum);
     }
 
     if (wp == curwin)
@@ -5783,7 +5855,8 @@
 	    update_topline();
 	curs_columns(FALSE);	/* validate w_wrow */
     }
-    wp->w_prev_fraction_row = wp->w_wrow;
+    if (prev_height > 0)
+	wp->w_prev_fraction_row = wp->w_wrow;
 
     win_comp_scroll(wp);
     redraw_win_later(wp, SOME_VALID);
@@ -6035,7 +6108,6 @@
     long	count;
     linenr_T	*file_lnum;
 {
-# ifdef FEAT_VISUAL
     if (VIsual_active)
     {
 	int	len;
@@ -6046,7 +6118,6 @@
 	return find_file_name_in_path(ptr, len,
 		     FNAME_MESS|FNAME_EXP|FNAME_REL, count, curbuf->b_ffname);
     }
-# endif
     return file_name_at_cursor(FNAME_MESS|FNAME_HYP|FNAME_EXP|FNAME_REL, count,
 			       file_lnum);
 
@@ -6595,8 +6666,8 @@
 	|| defined(PROTO)
 /*
  * Set "win" to be the curwin and "tp" to be the current tab page.
- * restore_win() MUST be called to undo.
- * No autocommands will be executed.
+ * restore_win() MUST be called to undo, also when FAIL is returned.
+ * No autocommands will be executed until restore_win() is called.
  * When "no_display" is TRUE the display won't be affected, no redraw is
  * triggered, another tabpage access is limited.
  * Returns FAIL if switching to "win" failed.
@@ -6629,12 +6700,7 @@
 	    goto_tabpage_tp(tp, FALSE, FALSE);
     }
     if (!win_valid(win))
-    {
-# ifdef FEAT_AUTOCMD
-	unblock_autocmds();
-# endif
 	return FAIL;
-    }
     curwin = win;
     curbuf = curwin->w_buffer;
 # endif
@@ -6747,20 +6813,22 @@
  * Return ID of added match, -1 on failure.
  */
     int
-match_add(wp, grp, pat, prio, id)
+match_add(wp, grp, pat, prio, id, pos_list)
     win_T	*wp;
     char_u	*grp;
     char_u	*pat;
     int		prio;
     int		id;
+    list_T	*pos_list;
 {
-    matchitem_T *cur;
-    matchitem_T *prev;
-    matchitem_T *m;
+    matchitem_T	*cur;
+    matchitem_T	*prev;
+    matchitem_T	*m;
     int		hlg_id;
-    regprog_T	*regprog;
+    regprog_T	*regprog = NULL;
+    int		rtype = SOME_VALID;
 
-    if (*grp == NUL || *pat == NUL)
+    if (*grp == NUL || (pat != NULL && *pat == NUL))
 	return -1;
     if (id < -1 || id == 0)
     {
@@ -6785,7 +6853,7 @@
 	EMSG2(_(e_nogroup), grp);
 	return -1;
     }
-    if ((regprog = vim_regcomp(pat, RE_MAGIC)) == NULL)
+    if (pat != NULL && (regprog = vim_regcomp(pat, RE_MAGIC)) == NULL)
     {
 	EMSG2(_(e_invarg2), pat);
 	return -1;
@@ -6803,15 +6871,112 @@
     }
 
     /* Build new match. */
-    m = (matchitem_T *)alloc(sizeof(matchitem_T));
+    m = (matchitem_T *)alloc_clear(sizeof(matchitem_T));
     m->id = id;
     m->priority = prio;
-    m->pattern = vim_strsave(pat);
+    m->pattern = pat == NULL ? NULL : vim_strsave(pat);
     m->hlg_id = hlg_id;
     m->match.regprog = regprog;
     m->match.rmm_ic = FALSE;
     m->match.rmm_maxcol = 0;
 
+    /* Set up position matches */
+    if (pos_list != NULL)
+    {
+	linenr_T	toplnum = 0;
+	linenr_T	botlnum = 0;
+	listitem_T	*li;
+	int		i;
+
+	for (i = 0, li = pos_list->lv_first; li != NULL && i < MAXPOSMATCH;
+							i++, li = li->li_next)
+	{
+	    linenr_T	lnum = 0;
+	    colnr_T	col = 0;
+	    int		len = 1;
+	    list_T	*subl;
+	    listitem_T	*subli;
+	    int		error = FALSE;
+
+	    if (li->li_tv.v_type == VAR_LIST)
+	    {
+		subl = li->li_tv.vval.v_list;
+		if (subl == NULL)
+		    goto fail;
+		subli = subl->lv_first;
+		if (subli == NULL)
+		    goto fail;
+		lnum = get_tv_number_chk(&subli->li_tv, &error);
+		if (error == TRUE)
+		    goto fail;
+		if (lnum == 0)
+		{
+		    --i;
+		    continue;
+		}
+		m->pos.pos[i].lnum = lnum;
+		subli = subli->li_next;
+		if (subli != NULL)
+		{
+		    col = get_tv_number_chk(&subli->li_tv, &error);
+		    if (error == TRUE)
+			goto fail;
+		    subli = subli->li_next;
+		    if (subli != NULL)
+		    {
+			len = get_tv_number_chk(&subli->li_tv, &error);
+			if (error == TRUE)
+			    goto fail;
+		    }
+		}
+		m->pos.pos[i].col = col;
+		m->pos.pos[i].len = len;
+	    }
+	    else if (li->li_tv.v_type == VAR_NUMBER)
+	    {
+		if (li->li_tv.vval.v_number == 0)
+		{
+		    --i;
+		    continue;
+		}
+		m->pos.pos[i].lnum = li->li_tv.vval.v_number;
+		m->pos.pos[i].col = 0;
+		m->pos.pos[i].len = 0;
+	    }
+	    else
+	    {
+		EMSG(_("List or number required"));
+		goto fail;
+	    }
+	    if (toplnum == 0 || lnum < toplnum)
+		toplnum = lnum;
+	    if (botlnum == 0 || lnum >= botlnum)
+		botlnum = lnum + 1;
+	}
+
+	/* Calculate top and bottom lines for redrawing area */
+	if (toplnum != 0)
+	{
+	    if (wp->w_buffer->b_mod_set)
+	    {
+		if (wp->w_buffer->b_mod_top > toplnum)
+		    wp->w_buffer->b_mod_top = toplnum;
+		if (wp->w_buffer->b_mod_bot < botlnum)
+		    wp->w_buffer->b_mod_bot = botlnum;
+	    }
+	    else
+	    {
+		wp->w_buffer->b_mod_set = TRUE;
+		wp->w_buffer->b_mod_top = toplnum;
+		wp->w_buffer->b_mod_bot = botlnum;
+		wp->w_buffer->b_mod_xlines = 0;
+	    }
+	    m->pos.toplnum = toplnum;
+	    m->pos.botlnum = botlnum;
+	    rtype = VALID;
+	}
+    }
+
     /* Insert new match.  The match list is in ascending order with regard to
      * the match priorities. */
     cur = wp->w_match_head;
@@ -6827,8 +6992,12 @@
 	prev->next = m;
     m->next = cur;
 
-    redraw_later(SOME_VALID);
+    redraw_later(rtype);
     return id;
+
+fail:
+    vim_free(m);
+    return -1;
 }
 
 /*
@@ -6841,8 +7010,9 @@
     int		id;
     int		perr;
 {
-    matchitem_T *cur = wp->w_match_head;
-    matchitem_T *prev = cur;
+    matchitem_T	*cur = wp->w_match_head;
+    matchitem_T	*prev = cur;
+    int		rtype = SOME_VALID;
 
     if (id < 1)
     {
@@ -6868,8 +7038,26 @@
 	prev->next = cur->next;
     vim_regfree(cur->match.regprog);
     vim_free(cur->pattern);
+    if (cur->pos.toplnum != 0)
+    {
+	if (wp->w_buffer->b_mod_set)
+	{
+	    if (wp->w_buffer->b_mod_top > cur->pos.toplnum)
+		wp->w_buffer->b_mod_top = cur->pos.toplnum;
+	    if (wp->w_buffer->b_mod_bot < cur->pos.botlnum)
+		wp->w_buffer->b_mod_bot = cur->pos.botlnum;
+	}
+	else
+	{
+	    wp->w_buffer->b_mod_set = TRUE;
+	    wp->w_buffer->b_mod_top = cur->pos.toplnum;
+	    wp->w_buffer->b_mod_bot = cur->pos.botlnum;
+	    wp->w_buffer->b_mod_xlines = 0;
+	}
+	rtype = VALID;
+    }
     vim_free(cur);
-    redraw_later(SOME_VALID);
+    redraw_later(rtype);
     return 0;
 }
 
diff -Naur vim74.orig/src/xxd/Make_cyg.mak vim74/src/xxd/Make_cyg.mak
--- vim74.orig/src/xxd/Make_cyg.mak	2010-05-15 11:04:06.000000000 +0000
+++ vim74/src/xxd/Make_cyg.mak	2014-10-10 14:53:45.942043202 +0000
@@ -8,7 +8,7 @@
 DEFINES =
 LIBS    = -lc
 else
-DEFINES = -mno-cygwin
+DEFINES =
 LIBS    =
 endif
 
