Submitted By: Jim Gifford (jim at linuxfromscratch dot org)
Date: 2006-08-27
Initial Package Version: 7.0
Origin: Upstream
Upstream Status: Applied
Description: Contains Patch 001-004, 006-026, 028-031, 033-044, 036-056,
        058-064, and 066 from Upstream
        005, 027, 032, 045, 057, and 066 is for the extras, Mac, or
        Windows 32 only

diff -Naur vim70.orig/configure vim70/configure
--- vim70.orig/configure	2004-07-05 02:02:24.000000000 -0700
+++ vim70/configure	2006-08-09 08:37:06.000000000 -0700
@@ -3,4 +3,4 @@
 # This is just a stub for the Unix configure script, to provide support for
 # doing "./configure" in the top Vim directory.
 
-cd src && ./configure "$@"
+cd src && exec ./configure "$@"
diff -Naur vim70.orig/runtime/autoload/ccomplete.vim vim70/runtime/autoload/ccomplete.vim
--- vim70.orig/runtime/autoload/ccomplete.vim	2006-05-03 07:35:56.000000000 -0700
+++ vim70/runtime/autoload/ccomplete.vim	2006-07-14 08:51:21.000000000 -0700
@@ -1,7 +1,7 @@
 " Vim completion script
 " Language:	C
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2006 May 03
+" Last Change:	2006 May 08
 
 
 " This function is used for the 'omnifunc' option.
@@ -458,7 +458,7 @@
 " member.
 function! s:StructMembers(typename, items, all)
   " Todo: What about local structures?
-  let fnames = join(map(tagfiles(), 'escape(v:val, " \\")'))
+  let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
   if fnames == ''
     return []
   endif
diff -Naur vim70.orig/runtime/autoload/gzip.vim vim70/runtime/autoload/gzip.vim
--- vim70.orig/runtime/autoload/gzip.vim	2006-03-31 07:12:15.000000000 -0800
+++ vim70/runtime/autoload/gzip.vim	2006-08-09 08:37:36.000000000 -0700
@@ -1,6 +1,6 @@
 " Vim autoload file for editing compressed files.
 " Maintainer: Bram Moolenaar <Bram@vim.org>
-" Last Change: 2006 Mar 31
+" Last Change: 2006 Jul 19
 
 " These functions are used by the gzip plugin.
 
@@ -127,9 +127,9 @@
     let nmt = s:tempname(nm)
     if rename(nm, nmt) == 0
       if exists("b:gzip_comp_arg")
-	call system(a:cmd . " " . b:gzip_comp_arg . " " . nmt)
+	call system(a:cmd . " " . b:gzip_comp_arg . " '" . nmt . "'")
       else
-	call system(a:cmd . " " . nmt)
+	call system(a:cmd . " '" . nmt . "'")
       endif
       call rename(nmt . "." . expand("<afile>:e"), nm)
     endif
diff -Naur vim70.orig/runtime/autoload/paste.vim vim70/runtime/autoload/paste.vim
--- vim70.orig/runtime/autoload/paste.vim	2006-04-21 11:31:01.000000000 -0700
+++ vim70/runtime/autoload/paste.vim	2006-07-14 08:51:21.000000000 -0700
@@ -1,6 +1,6 @@
 " Vim support file to help with paste mappings and menus
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2006 Apr 21
+" Last Change:	2006 Jun 23
 
 " Define the string to use for items that are present both in Edit, Popup and
 " Toolbar menu.  Also used in mswin.vim and macmap.vim.
@@ -12,7 +12,7 @@
 if has("virtualedit")
   let paste#paste_cmd = {'n': ":call paste#Paste()<CR>"}
   let paste#paste_cmd['v'] = '"-c<Esc>' . paste#paste_cmd['n']
-  let paste#paste_cmd['i'] = '<Esc>' . paste#paste_cmd['n'] . 'gi'
+  let paste#paste_cmd['i'] = 'x<BS><Esc>' . paste#paste_cmd['n'] . 'gi'
 
   func! paste#Paste()
     let ove = &ve
diff -Naur vim70.orig/runtime/autoload/spellfile.vim vim70/runtime/autoload/spellfile.vim
--- vim70.orig/runtime/autoload/spellfile.vim	2006-02-01 04:12:24.000000000 -0800
+++ vim70/runtime/autoload/spellfile.vim	2006-07-14 08:51:21.000000000 -0700
@@ -1,9 +1,9 @@
 " Vim script to download a missing spell file
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2006 Feb 01
+" Last Change:	2006 May 10
 
 if !exists('g:spellfile_URL')
-  let g:spellfile_URL = 'ftp://ftp.vim.org/pub/vim/unstable/runtime/spell'
+  let g:spellfile_URL = 'ftp://ftp.vim.org/pub/vim/runtime/spell'
 endif
 let s:spellfile_URL = ''    " Start with nothing so that s:donedict is reset.
 
@@ -61,13 +61,13 @@
     new
     setlocal bin
     echo 'Downloading ' . fname . '...'
-    exe 'Nread ' g:spellfile_URL . '/' . fname
+    call spellfile#Nread(fname)
     if getline(2) !~ 'VIMspell'
       " Didn't work, perhaps there is an ASCII one.
       g/^/d
       let fname = a:lang . '.ascii.spl'
       echo 'Could not find it, trying ' . fname . '...'
-      exe 'Nread ' g:spellfile_URL . '/' . fname
+      call spellfile#Nread(fname)
       if getline(2) !~ 'VIMspell'
 	echo 'Sorry, downloading failed'
 	bwipe!
@@ -95,7 +95,7 @@
 	g/^/d
 	let fname = substitute(fname, '\.spl$', '.sug', '')
 	echo 'Downloading ' . fname . '...'
-	exe 'Nread ' g:spellfile_URL . '/' . fname
+	call spellfile#Nread(fname)
 	if getline(2) !~ 'VIMsug'
 	  echo 'Sorry, downloading failed'
 	else
@@ -109,3 +109,10 @@
     bwipe
   endif
 endfunc
+
+" Read "fname" from the ftp server.
+function! spellfile#Nread(fname)
+  let machine = substitute(g:spellfile_URL, 'ftp://\([^/]*\).*', '\1', '')
+  let dir = substitute(g:spellfile_URL, 'ftp://[^/]*/\(.*\)', '\1', '')
+  exe 'Nread "' . machine . ' anonymous vim7user ' . dir . '/' . a:fname . '"'
+endfunc
diff -Naur vim70.orig/runtime/plugin/matchparen.vim vim70/runtime/plugin/matchparen.vim
--- vim70.orig/runtime/plugin/matchparen.vim	2006-04-27 06:31:26.000000000 -0700
+++ vim70/runtime/plugin/matchparen.vim	2006-08-09 08:36:40.000000000 -0700
@@ -1,6 +1,6 @@
 " Vim plugin for showing matching parens
 " Maintainer:  Bram Moolenaar <Bram@vim.org>
-" Last Change: 2006 Apr 27
+" Last Change: 2006 Jun 26
 
 " Exit quickly when:
 " - this plugin was already loaded (or disabled)
@@ -90,19 +90,19 @@
   " Find the match.  When it was just before the cursor move it there for a
   " moment.
   if before > 0
-    let save_cursor = getpos('.')
+    let save_cursor = winsaveview()
     call cursor(c_lnum, c_col - before)
   endif
 
   " When not in a string or comment ignore matches inside them.
   let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
-	\ '=~?  "string\\|comment"'
+	\ '=~?  "string\\|character\\|singlequote\\|comment"'
   execute 'if' s_skip '| let s_skip = 0 | endif'
 
   let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
 
   if before > 0
-    call setpos('.', save_cursor)
+    call winrestview(save_cursor)
   endif
 
   " If a match is found setup match highlighting.
diff -Naur vim70.orig/runtime/scripts.vim vim70/runtime/scripts.vim
--- vim70.orig/runtime/scripts.vim	2006-03-28 11:30:49.000000000 -0800
+++ vim70/runtime/scripts.vim	2006-08-09 08:38:04.000000000 -0700
@@ -1,7 +1,7 @@
 " Vim support file to detect file types in scripts
 "
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last change:	2006 Mar 28
+" Last change:	2006 Jul 08
 
 " This file is called by an autocommand for every file that has just been
 " loaded into a buffer.  It checks if the type of file can be recognized by
@@ -54,6 +54,12 @@
     let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
   endif
 
+  " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
+  " third line.  Suggested by Steven Atkinson.
+  if getline(3) =~ '^exec wish'
+    let s:name = 'wish'
+  endif
+
   " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
   if s:name =~ '^\(bash\d*\|\|ksh\d*\|sh\)\>'
     call SetFileTypeSH(s:line1)	" defined in filetype.vim
diff -Naur vim70.orig/src/buffer.c vim70/src/buffer.c
--- vim70.orig/src/buffer.c	2006-04-26 14:37:23.000000000 -0700
+++ vim70/src/buffer.c	2006-08-19 16:39:01.000000000 -0700
@@ -5420,11 +5420,7 @@
     buf_T	*newbuf;
     int		differ = TRUE;
     linenr_T	lnum;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
-#else
-    buf_T	*old_curbuf = curbuf;
-#endif
     exarg_T	ea;
 
     /* Allocate a buffer without putting it in the buffer list. */
@@ -5439,13 +5435,8 @@
 	return TRUE;
     }
 
-#ifdef FEAT_AUTOCMD
     /* set curwin/curbuf to buf and save a few things */
     aucmd_prepbuf(&aco, newbuf);
-#else
-    curbuf = newbuf;
-    curwin->w_buffer = newbuf;
-#endif
 
     if (ml_open(curbuf) == OK
 	    && readfile(buf->b_ffname, buf->b_fname,
@@ -5466,13 +5457,8 @@
     }
     vim_free(ea.cmd);
 
-#ifdef FEAT_AUTOCMD
     /* restore curwin/curbuf and a few other things */
     aucmd_restbuf(&aco);
-#else
-    curbuf = old_curbuf;
-    curwin->w_buffer = old_curbuf;
-#endif
 
     if (curbuf != newbuf)	/* safety check */
 	wipe_buffer(newbuf, FALSE);
diff -Naur vim70.orig/src/configure vim70/src/configure
--- vim70.orig/src/configure	2006-05-07 07:17:49.000000000 -0700
+++ vim70/src/configure	2006-08-09 08:37:06.000000000 -0700
@@ -2,5 +2,9 @@
 # run the automatically generated configure script
 CONFIG_STATUS=auto/config.status \
 	auto/configure "$@" --srcdir="${srcdir:-.}" --cache-file=auto/config.cache
+result=$?
+
 # Stupid autoconf 2.5x causes this file to be left behind.
 if test -f configure.lineno; then rm -f configure.lineno; fi
+
+exit $result
diff -Naur vim70.orig/src/edit.c vim70/src/edit.c
--- vim70.orig/src/edit.c	2006-05-07 04:48:51.000000000 -0700
+++ vim70/src/edit.c	2006-08-27 12:47:33.000000000 -0700
@@ -719,9 +719,14 @@
 #ifdef FEAT_INS_EXPAND
 	/*
 	 * Special handling of keys while the popup menu is visible or wanted
-	 * and the cursor is still in the completed word.
+	 * and the cursor is still in the completed word.  Only when there is
+	 * a match, skip this when no matches were found.
 	 */
-	if (compl_started && pum_wanted() && curwin->w_cursor.col >= compl_col)
+	if (compl_started
+		&& pum_wanted()
+		&& curwin->w_cursor.col >= compl_col
+		&& (compl_shown_match == NULL
+		    || compl_shown_match != compl_shown_match->cp_next))
 	{
 	    /* BS: Delete one character from "compl_leader". */
 	    if ((c == K_BS || c == Ctrl_H)
@@ -751,7 +756,7 @@
 		    continue;
 		}
 
-		/* Pressing CTRL-Y selects the current match.  Shen
+		/* Pressing CTRL-Y selects the current match.  When
 		 * compl_enter_selects is set the Enter key does the same. */
 		if (c == Ctrl_Y || (compl_enter_selects
 				   && (c == CAR || c == K_KENTER || c == NL)))
@@ -877,6 +882,7 @@
 		/* Close the cmdline window. */
 		cmdwin_result = K_IGNORE;
 		got_int = FALSE; /* don't stop executing autocommands et al. */
+		nomove = TRUE;
 		goto doESCkey;
 	    }
 #endif
@@ -2409,6 +2415,7 @@
     compl_matches = ins_compl_make_cyclic();
     compl_started = TRUE;
     compl_used_match = TRUE;
+    compl_cont_status = 0;
 
     compl_curr_match = compl_first_match;
     ins_complete(Ctrl_N);
@@ -2753,6 +2760,7 @@
 	}
 	else
 # endif
+	    if (count > 0)	/* avoid warning for using "files" uninit */
 	{
 	    ins_compl_files(count, files, thesaurus, flags,
 							&regmatch, buf, &dir);
@@ -3015,9 +3023,6 @@
     if ((int)(p - line) - (int)compl_col <= 0)
 	return K_BS;
 
-    /* For redo we need to repeat this backspace. */
-    AppendCharToRedobuff(K_BS);
-
     /* Deleted more than what was used to find matches or didn't finish
      * finding all matches: need to look for matches all over again. */
     if (curwin->w_cursor.col <= compl_col + compl_length
@@ -3046,7 +3051,6 @@
     ins_compl_delete();
     ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
     compl_used_match = FALSE;
-    compl_enter_selects = FALSE;
 
     if (compl_started)
 	ins_compl_set_original_text(compl_leader);
@@ -3076,6 +3080,7 @@
 	compl_restarting = FALSE;
     }
 
+#if 0   /* disabled, made CTRL-L, BS and typing char jump to original text. */
     if (!compl_used_match)
     {
 	/* Go to the original text, since none of the matches is inserted. */
@@ -3087,6 +3092,8 @@
 	compl_curr_match = compl_shown_match;
 	compl_shows_dir = compl_direction;
     }
+#endif
+    compl_enter_selects = !compl_used_match;
 
     /* Show the popup menu with a different set of matches. */
     ins_compl_show_pum();
@@ -3115,10 +3122,6 @@
 #endif
 	ins_char(c);
 
-    /* For redo we need to count this character so that the number of
-     * backspaces is correct. */
-    AppendCharToRedobuff(c);
-
     /* If we didn't complete finding matches we must search again. */
     if (compl_was_interrupted)
 	ins_compl_restart();
@@ -3175,10 +3178,32 @@
     char_u	*p;
     int		len = curwin->w_cursor.col - compl_col;
     int		c;
+    compl_T	*cp;
 
     p = compl_shown_match->cp_str;
     if ((int)STRLEN(p) <= len)   /* the match is too short */
-	return;
+    {
+	/* When still at the original match use the first entry that matches
+	 * the leader. */
+	if (compl_shown_match->cp_flags & ORIGINAL_TEXT)
+	{
+	    p = NULL;
+	    for (cp = compl_shown_match->cp_next; cp != NULL
+				 && cp != compl_first_match; cp = cp->cp_next)
+	    {
+		if (ins_compl_equal(cp, compl_leader,
+						   (int)STRLEN(compl_leader)))
+		{
+		    p = cp->cp_str;
+		    break;
+		}
+	    }
+	    if (p == NULL || (int)STRLEN(p) <= len)
+		return;
+	}
+	else
+	    return;
+    }
     p += len;
 #ifdef FEAT_MBYTE
     c = mb_ptr2char(p);
@@ -3198,7 +3223,6 @@
     int	    c;
 {
     char_u	*ptr;
-    int		temp;
     int		want_cindent;
     int		retval = FALSE;
 
@@ -3354,6 +3378,7 @@
 	    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)
 	    {
 		char_u	*p;
+		int	temp = 0;
 
 		/*
 		 * If any of the original typed text has been changed, eg when
@@ -3369,16 +3394,21 @@
 		    ptr = compl_leader;
 		else
 		    ptr = compl_orig_text;
-		p = compl_orig_text;
-		for (temp = 0; p[temp] != NUL && p[temp] == ptr[temp]; ++temp)
-		    ;
+		if (compl_orig_text != NULL)
+		{
+		    p = compl_orig_text;
+		    for (temp = 0; p[temp] != NUL && p[temp] == ptr[temp];
+								       ++temp)
+			;
 #ifdef FEAT_MBYTE
-		if (temp > 0)
-		    temp -= (*mb_head_off)(compl_orig_text, p + temp);
+		    if (temp > 0)
+			temp -= (*mb_head_off)(compl_orig_text, p + temp);
 #endif
-		for (p += temp; *p != NUL; mb_ptr_adv(p))
-		    AppendCharToRedobuff(K_BS);
-		AppendToRedobuffLit(ptr + temp, -1);
+		    for (p += temp; *p != NUL; mb_ptr_adv(p))
+			AppendCharToRedobuff(K_BS);
+		}
+		if (ptr != NULL)
+		    AppendToRedobuffLit(ptr + temp, -1);
 	    }
 
 #ifdef FEAT_CINDENT
@@ -4100,6 +4130,21 @@
 		&& compl_shown_match->cp_next != NULL
 		&& compl_shown_match->cp_next != compl_first_match)
 	    compl_shown_match = compl_shown_match->cp_next;
+
+	/* If we didn't find it searching forward, and compl_shows_dir is
+	 * backward, find the last match. */
+	if (compl_shows_dir == BACKWARD
+		&& !ins_compl_equal(compl_shown_match,
+				      compl_leader, (int)STRLEN(compl_leader))
+		&& (compl_shown_match->cp_next == NULL
+		    || compl_shown_match->cp_next == compl_first_match))
+	{
+	    while (!ins_compl_equal(compl_shown_match,
+				      compl_leader, (int)STRLEN(compl_leader))
+		    && compl_shown_match->cp_prev != NULL
+		    && compl_shown_match->cp_prev != compl_first_match)
+		compl_shown_match = compl_shown_match->cp_prev;
+	}
     }
 
     if (allow_get_expansion && insert_match
@@ -4124,8 +4169,6 @@
     {
 	if (compl_shows_dir == FORWARD && compl_shown_match->cp_next != NULL)
 	{
-	    if (compl_pending != 0)
-		--compl_pending;
 	    compl_shown_match = compl_shown_match->cp_next;
 	    found_end = (compl_first_match != NULL
 			   && (compl_shown_match->cp_next == compl_first_match
@@ -4134,14 +4177,24 @@
 	else if (compl_shows_dir == BACKWARD
 					&& compl_shown_match->cp_prev != NULL)
 	{
-	    if (compl_pending != 0)
-		++compl_pending;
 	    found_end = (compl_shown_match == compl_first_match);
 	    compl_shown_match = compl_shown_match->cp_prev;
 	    found_end |= (compl_shown_match == compl_first_match);
 	}
 	else
 	{
+	    if (!allow_get_expansion)
+	    {
+		if (advance)
+		{
+		    if (compl_shows_dir == BACKWARD)
+			compl_pending -= todo + 1;
+		    else
+			compl_pending += todo + 1;
+		}
+		return -1;
+	    }
+
 	    if (advance)
 	    {
 		if (compl_shows_dir == BACKWARD)
@@ -4149,14 +4202,27 @@
 		else
 		    ++compl_pending;
 	    }
-	    if (!allow_get_expansion)
-		return -1;
 
 	    /* Find matches. */
 	    num_matches = ins_compl_get_exp(&compl_startpos);
-	    if (compl_pending != 0 && compl_direction == compl_shows_dir
+
+	    /* handle any pending completions */
+	    while (compl_pending != 0 && compl_direction == compl_shows_dir
 								   && advance)
-		compl_shown_match = compl_curr_match;
+	    {
+		if (compl_pending > 0 && compl_shown_match->cp_next != NULL)
+		{
+		    compl_shown_match = compl_shown_match->cp_next;
+		    --compl_pending;
+		}
+		if (compl_pending < 0 && compl_shown_match->cp_prev != NULL)
+		{
+		    compl_shown_match = compl_shown_match->cp_prev;
+		    ++compl_pending;
+		}
+		else
+		    break;
+	    }
 	    found_end = FALSE;
 	}
 	if ((compl_shown_match->cp_flags & ORIGINAL_TEXT) == 0
@@ -4265,9 +4331,9 @@
 	return;
     count = 0;
 
-    ++no_mapping;
+    /* Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()
+     * can't do its work correctly. */
     c = vpeekc_any();
-    --no_mapping;
     if (c != NUL)
     {
 	if (vim_is_ctrl_x_key(c) && c != Ctrl_X && c != Ctrl_R)
@@ -4277,12 +4343,27 @@
 	    (void)ins_compl_next(FALSE, ins_compl_key2count(c),
 						    c != K_UP && c != K_DOWN);
 	}
-	else if (c != Ctrl_R)
-	    compl_interrupted = TRUE;
+	else
+	{
+	    /* Need to get the character to have KeyTyped set.  We'll put it
+	     * back with vungetc() below. */
+	    c = safe_vgetc();
+
+	    /* Don't interrupt completion when the character wasn't typed,
+	     * e.g., when doing @q to replay keys. */
+	    if (c != Ctrl_R && KeyTyped)
+		compl_interrupted = TRUE;
+
+	    vungetc(c);
+	}
     }
     if (compl_pending != 0 && !got_int)
-	(void)ins_compl_next(FALSE, compl_pending > 0
-				      ? compl_pending : -compl_pending, TRUE);
+    {
+	int todo = compl_pending > 0 ? compl_pending : -compl_pending;
+
+	compl_pending = 0;
+	(void)ins_compl_next(FALSE, todo, TRUE);
+    }
 }
 
 /*
@@ -4611,10 +4692,12 @@
 				     (int)STRLEN(compl_pattern), curs_col);
 	    if (compl_xp.xp_context == EXPAND_UNSUCCESSFUL
 		    || compl_xp.xp_context == EXPAND_NOTHING)
-		return FAIL;
-	    startcol = (int)(compl_xp.xp_pattern - compl_pattern);
-	    compl_col = startcol;
-	    compl_length = curs_col - startcol;
+		/* No completion possible, use an empty pattern to get a
+		 * "pattern not found" message. */
+		compl_col = curs_col;
+	    else
+		compl_col = (int)(compl_xp.xp_pattern - compl_pattern);
+	    compl_length = curs_col - compl_col;
 	}
 	else if (ctrl_x_mode == CTRL_X_FUNCTION || ctrl_x_mode == CTRL_X_OMNI)
 	{
@@ -4668,11 +4751,17 @@
 	    else
 		compl_col = spell_word_start(startcol);
 	    if (compl_col >= (colnr_T)startcol)
-		return FAIL;
-	    spell_expand_check_cap(compl_col);
+	    {
+		compl_length = 0;
+		compl_col = curs_col;
+	    }
+	    else
+	    {
+		spell_expand_check_cap(compl_col);
+		compl_length = (int)curs_col - compl_col;
+	    }
 	    /* Need to obtain "line" again, it may have become invalid. */
 	    line = ml_get(curwin->w_cursor.lnum);
-	    compl_length = (int)curs_col - compl_col;
 	    compl_pattern = vim_strnsave(line + compl_col, compl_length);
 	    if (compl_pattern == NULL)
 #endif
diff -Naur vim70.orig/src/eval.c vim70/src/eval.c
--- vim70.orig/src/eval.c	2006-05-05 10:15:26.000000000 -0700
+++ vim70/src/eval.c	2006-08-19 16:40:29.000000000 -0700
@@ -8252,6 +8252,12 @@
 	EMSG(_("E785: complete() can only be used in Insert mode"));
 	return;
     }
+
+    /* Check for undo allowed here, because if something was already inserted
+     * the line was already saved for undo and this check isn't done. */
+    if (!undo_allowed())
+	return;
+
     if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)
     {
 	EMSG(_(e_invarg));
@@ -9792,6 +9798,9 @@
     varnumber_T		n;
     int			error = FALSE;
 
+    /* Position the cursor.  Needed after a message that ends in a space. */
+    windgoto(msg_row, msg_col);
+
     ++no_mapping;
     ++allow_keys;
     if (argvars[0].v_type == VAR_UNKNOWN)
@@ -11312,14 +11321,19 @@
 
 static int inputsecret_flag = 0;
 
+static void get_user_input __ARGS((typval_T *argvars, typval_T *rettv, int inputdialog));
+
 /*
- * "input()" function
- *     Also handles inputsecret() when inputsecret is set.
+ * This function is used by f_input() and f_inputdialog() functions. The third
+ * argument to f_input() specifies the type of completion to use at the
+ * prompt. The third argument to f_inputdialog() specifies the value to return
+ * when the user cancels the prompt.
  */
     static void
-f_input(argvars, rettv)
+get_user_input(argvars, rettv, inputdialog)
     typval_T	*argvars;
     typval_T	*rettv;
+    int		inputdialog;
 {
     char_u	*prompt = get_tv_string_chk(&argvars[0]);
     char_u	*p = NULL;
@@ -11369,10 +11383,10 @@
 	    if (defstr != NULL)
 		stuffReadbuffSpec(defstr);
 
-	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)
 	    {
 		char_u	*xp_name;
-		int		xp_namelen;
+		int	xp_namelen;
 		long	argt;
 
 		rettv->vval.v_string = NULL;
@@ -11404,6 +11418,18 @@
 }
 
 /*
+ * "input()" function
+ *     Also handles inputsecret() when inputsecret is set.
+ */
+    static void
+f_input(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    get_user_input(argvars, rettv, FALSE);
+}
+
+/*
  * "inputdialog()" function
  */
     static void
@@ -11443,7 +11469,7 @@
     }
     else
 #endif
-	f_input(argvars, rettv);
+	get_user_input(argvars, rettv, TRUE);
 }
 
 /*
@@ -11471,6 +11497,7 @@
     }
 
     msg_start();
+    msg_row = Rows - 1;	/* for when 'cmdheight' > 1 */
     lines_left = Rows;	/* avoid more prompt */
     msg_scroll = TRUE;
     msg_clr_eos();
@@ -13250,7 +13277,7 @@
 	if (argvars[2].v_type != VAR_UNKNOWN)
 	    EMSG2(_(e_toomanyarg), "remove()");
 	else if ((d = argvars[0].vval.v_dict) != NULL
-		&& !tv_check_lock(d->dv_lock, (char_u *)"remove()"))
+		&& !tv_check_lock(d->dv_lock, (char_u *)"remove() argument"))
 	{
 	    key = get_tv_string_chk(&argvars[1]);
 	    if (key != NULL)
@@ -13270,7 +13297,7 @@
     else if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listdictarg), "remove()");
     else if ((l = argvars[0].vval.v_list) != NULL
-	    && !tv_check_lock(l->lv_lock, (char_u *)"remove()"))
+	    && !tv_check_lock(l->lv_lock, (char_u *)"remove() argument"))
     {
 	int	    error = FALSE;
 
@@ -14157,11 +14184,7 @@
     typval_T	*rettv;
 {
     buf_T	*buf;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
-#else
-    buf_T	*save_curbuf;
-#endif
     char_u	*varname, *bufvarname;
     typval_T	*varp;
     char_u	nbuf[NUMBUFLEN];
@@ -14178,12 +14201,7 @@
     if (buf != NULL && varname != NULL && varp != NULL)
     {
 	/* set curbuf to be our buf, temporarily */
-#ifdef FEAT_AUTOCMD
 	aucmd_prepbuf(&aco, buf);
-#else
-	save_curbuf = curbuf;
-	curbuf = buf;
-#endif
 
 	if (*varname == '&')
 	{
@@ -14210,11 +14228,7 @@
 	}
 
 	/* reset notion of buffer */
-#ifdef FEAT_AUTOCMD
 	aucmd_restbuf(&aco);
-#else
-	curbuf = save_curbuf;
-#endif
     }
 }
 
@@ -16438,9 +16452,12 @@
     long	i = 0;
     long	n;
 
-    /* List must be: [fnum, lnum, col, coladd] */
-    if (arg->v_type != VAR_LIST || l == NULL
-				      || l->lv_len != (fnump == NULL ? 3 : 4))
+    /* List must be: [fnum, lnum, col, coladd], where "fnum" is only there
+     * when "fnump" isn't NULL and "coladd" is optional. */
+    if (arg->v_type != VAR_LIST
+	    || l == NULL
+	    || l->lv_len < (fnump == NULL ? 2 : 3)
+	    || l->lv_len > (fnump == NULL ? 3 : 4))
 	return FAIL;
 
     if (fnump != NULL)
@@ -16466,8 +16483,9 @@
 #ifdef FEAT_VIRTUALEDIT
     n = list_find_nr(l, i, NULL);
     if (n < 0)
-	return FAIL;
-    posp->coladd = n;
+	posp->coladd = 0;
+    else
+	posp->coladd = n;
 #endif
 
     return OK;
@@ -17759,6 +17777,13 @@
     }
     else		    /* add a new variable */
     {
+	/* Can't add "v:" variable. */
+	if (ht == &vimvarht)
+	{
+	    EMSG2(_(e_illvar), name);
+	    return;
+	}
+
 	/* Make sure the variable name is valid. */
 	for (p = varname; *p != NUL; ++p)
 	    if (!eval_isnamec1(*p) && (p == varname || !VIM_ISDIGIT(*p))
@@ -18786,6 +18811,7 @@
 		if (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)
 		{
 		    vim_free(fudi.fd_di);
+		    vim_free(fp);
 		    goto erret;
 		}
 	    }
@@ -18963,7 +18989,8 @@
     else if (lead > 0)
     {
 	lead = 3;
-	if (eval_fname_sid(lv.ll_exp_name != NULL ? lv.ll_exp_name : *pp))
+	if ((lv.ll_exp_name != NULL && eval_fname_sid(lv.ll_exp_name))
+						       || eval_fname_sid(*pp))
 	{
 	    /* It's "s:" or "<SID>" */
 	    if (current_SID <= 0)
@@ -19685,6 +19712,7 @@
     v->di_tv.vval.v_list = &fc.l_varlist;
     vim_memset(&fc.l_varlist, 0, sizeof(list_T));
     fc.l_varlist.lv_refcount = 99999;
+    fc.l_varlist.lv_lock = VAR_FIXED;
 
     /*
      * Set a:firstline to "firstline" and a:lastline to "lastline".
diff -Naur vim70.orig/src/ex_cmds.h vim70/src/ex_cmds.h
--- vim70.orig/src/ex_cmds.h	2006-04-07 02:44:46.000000000 -0700
+++ vim70/src/ex_cmds.h	2006-07-14 08:51:21.000000000 -0700
@@ -262,7 +262,7 @@
 EX(CMD_comclear,	"comclear",	ex_comclear,
 			TRLBAR|CMDWIN),
 EX(CMD_compiler,	"compiler",	ex_compiler,
-			BANG|TRLBAR|WORD1),
+			BANG|TRLBAR|WORD1|CMDWIN),
 EX(CMD_continue,	"continue",	ex_continue,
 			TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_confirm,		"confirm",	ex_wrongmodifier,
diff -Naur vim70.orig/src/ex_docmd.c vim70/src/ex_docmd.c
--- vim70.orig/src/ex_docmd.c	2006-05-05 09:33:19.000000000 -0700
+++ vim70/src/ex_docmd.c	2006-08-19 16:34:11.000000000 -0700
@@ -833,7 +833,7 @@
      * If requested, store and reset the global values controlling the
      * exception handling (used when debugging).
      */
-    else if (flags & DOCMD_EXCRESET)
+    if (flags & DOCMD_EXCRESET)
 	save_dbg_stuff(&debug_saved);
 
     initial_trylevel = trylevel;
@@ -1710,6 +1710,10 @@
     save_cmdmod = cmdmod;
     vim_memset(&cmdmod, 0, sizeof(cmdmod));
 
+    /* "#!anything" is handled like a comment. */
+    if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!')
+	goto doend;
+
     /*
      * Repeat until no more command modifiers are found.
      */
diff -Naur vim70.orig/src/ex_getln.c vim70/src/ex_getln.c
--- vim70.orig/src/ex_getln.c	2006-04-30 08:32:01.000000000 -0700
+++ vim70/src/ex_getln.c	2006-08-19 16:33:52.000000000 -0700
@@ -5982,6 +5982,8 @@
     typestr[0] = cmdwin_type;
     typestr[1] = NUL;
     apply_autocmds(EVENT_CMDWINENTER, typestr, typestr, FALSE, curbuf);
+    if (restart_edit != 0)	/* autocmd with ":startinsert" */
+	stuffcharReadbuff(K_NOP);
 # endif
 
     i = RedrawingDisabled;
diff -Naur vim70.orig/src/fileio.c vim70/src/fileio.c
--- vim70.orig/src/fileio.c	2006-04-30 08:28:57.000000000 -0700
+++ vim70/src/fileio.c	2006-08-19 16:39:01.000000000 -0700
@@ -6450,17 +6450,10 @@
     int		old_ro = buf->b_p_ro;
     buf_T	*savebuf;
     int		saved = OK;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
 
     /* set curwin/curbuf for "buf" and save some things */
     aucmd_prepbuf(&aco, buf);
-#else
-    buf_T	*save_curbuf = curbuf;
-
-    curbuf = buf;
-    curwin->w_buffer = buf;
-#endif
 
     /* We only want to read the text from the file, not reset the syntax
      * highlighting, clear marks, diff status, etc.  Force the fileformat
@@ -6573,14 +6566,9 @@
 	    curbuf->b_p_ro |= old_ro;
     }
 
-#ifdef FEAT_AUTOCMD
     /* restore curwin/curbuf and a few other things */
     aucmd_restbuf(&aco);
     /* Careful: autocommands may have made "buf" invalid! */
-#else
-    curwin->w_buffer = save_curbuf;
-    curbuf = save_curbuf;
-#endif
 }
 
 /*ARGSUSED*/
@@ -8088,6 +8076,7 @@
  * Search a window for the current buffer.  Save the cursor position and
  * screen offset.
  * Set "curbuf" and "curwin" to match "buf".
+ * When FEAT_AUTOCMD is not defined another version is used, see below.
  */
     void
 aucmd_prepbuf(aco, buf)
@@ -8151,6 +8140,7 @@
 /*
  * Cleanup after executing autocommands for a (hidden) buffer.
  * Restore the window as it was (if possible).
+ * When FEAT_AUTOCMD is not defined another version is used, see below.
  */
     void
 aucmd_restbuf(aco)
@@ -9063,8 +9053,38 @@
     return retval;
 }
 
+#else	/* FEAT_AUTOCMD */
+
+/*
+ * Prepare for executing commands for (hidden) buffer "buf".
+ * This is the non-autocommand version, it simply saves "curbuf" and sets
+ * "curbuf" and "curwin" to match "buf".
+ */
+    void
+aucmd_prepbuf(aco, buf)
+    aco_save_T	*aco;		/* structure to save values in */
+    buf_T	*buf;		/* new curbuf */
+{
+    aco->save_buf = buf;
+    curbuf = buf;
+    curwin->w_buffer = buf;
+}
+
+/*
+ * Restore after executing commands for a (hidden) buffer.
+ * This is the non-autocommand version.
+ */
+    void
+aucmd_restbuf(aco)
+    aco_save_T	*aco;		/* structure holding saved values */
+{
+    curbuf = aco->save_buf;
+    curwin->w_buffer = curbuf;
+}
+
 #endif	/* FEAT_AUTOCMD */
 
+
 #if defined(FEAT_AUTOCMD) || defined(FEAT_WILDIGN) || defined(PROTO)
 /*
  * Try matching a filename with a "pattern" ("prog" is NULL), or use the
diff -Naur vim70.orig/src/gui_at_fs.c vim70/src/gui_at_fs.c
--- vim70.orig/src/gui_at_fs.c	2005-07-09 04:30:17.000000000 -0700
+++ vim70/src/gui_at_fs.c	2006-07-14 08:51:21.000000000 -0700
@@ -1861,27 +1861,27 @@
     XtPointer	pnew;
 {
     SFDir	*dir;
-    int		nw;
+    int		nw = (int)(long)pnew;
 
     dir = &(SFdirs[SFdirPtr + (int)(long)n]);
 
 #ifdef FEAT_GUI_NEXTAW
-    if ((int)(long)pnew < 0)
+    if (nw < 0)
     {
-	if ((int)(long)pnew > -SFvScrollHeight)
-	    (int)(long)pnew = -1;
+	if (nw > -SFvScrollHeight)
+	    nw = -1;
 	else
-	    (int)(long)pnew = -SFlistSize;
+	    nw = -SFlistSize;
     }
-    else if ((int)(long)pnew > 0)
+    else if (nw > 0)
     {
-	if ((int)(long)pnew < SFvScrollHeight)
-	    (int)(long)pnew = 1;
+	if (nw < SFvScrollHeight)
+	    nw = 1;
 	else
-	    (int)(long)pnew = SFlistSize;
+	    nw = SFlistSize;
     }
 #endif
-    nw = dir->vOrigin + (int)(long)pnew;
+    nw += dir->vOrigin;
 
     if (nw > dir->nEntries - SFlistSize)
 	nw = dir->nEntries - SFlistSize;
@@ -1941,27 +1941,27 @@
     XtPointer	pnew;
 {
     SFDir	*dir;
-    int		nw;
+    int		nw = (int)(long)pnew;
 
     dir = &(SFdirs[SFdirPtr + (int)(long)n]);
 
 #ifdef FEAT_GUI_NEXTAW
-    if ((int)(long)pnew < 0)
+    if (nw < 0)
     {
-	if ((int)(long)pnew > -SFhScrollWidth)
-	    (int)(long)pnew = -1;
+	if (nw > -SFhScrollWidth)
+	    nw = -1;
 	else
-	    (int)(long)pnew = -SFcharsPerEntry;
+	    nw = -SFcharsPerEntry;
     }
-    else if ((int)(long)pnew > 0)
+    else if (nw > 0)
     {
-	if ((int)(long)pnew < SFhScrollWidth)
-	    (int)(long)pnew = 1;
+	if (nw < SFhScrollWidth)
+	    nw = 1;
 	else
-	    (int)(long)pnew = SFcharsPerEntry;
+	    nw = SFcharsPerEntry;
     }
 #endif
-    nw = dir->hOrigin + (int)(long)pnew;
+    nw += dir->hOrigin;
 
     if (nw > dir->nChars - SFcharsPerEntry)
 	nw = dir->nChars - SFcharsPerEntry;
@@ -2038,26 +2038,26 @@
     XtPointer	client_data;
     XtPointer	pnew;
 {
-    int		nw;
+    int		nw = (int)(long)pnew;
     float	f;
 
 #ifdef FEAT_GUI_NEXTAW
-    if ((int)(long)pnew < 0)
+    if (nw < 0)
     {
-	if ((int)(long)pnew > -SFpathScrollWidth)
-	    (int)(long)pnew = -1;
+	if (nw > -SFpathScrollWidth)
+	    nw = -1;
 	else
-	    (int)(long)pnew = -3;
+	    nw = -3;
     }
-    else if ((int)(long)pnew > 0)
+    else if (nw > 0)
     {
-	if ((int)(long)pnew < SFpathScrollWidth)
-	    (int)(long)pnew = 1;
+	if (nw < SFpathScrollWidth)
+	    nw = 1;
 	else
-	    (int)(long)pnew = 3;
+	    nw = 3;
     }
 #endif
-    nw = SFdirPtr + (int)(long)pnew;
+    nw += SFdirPtr;
 
     if (nw > SFdirEnd - 3)
 	nw = SFdirEnd - 3;
diff -Naur vim70.orig/src/gui.c vim70/src/gui.c
--- vim70.orig/src/gui.c	2006-05-03 04:00:59.000000000 -0700
+++ vim70/src/gui.c	2006-07-14 08:51:21.000000000 -0700
@@ -4515,7 +4515,7 @@
     int		y;
 {
     win_T	*wp;
-    char_u	st[6];
+    char_u	st[8];
 
     /* Ignore this while still starting up. */
     if (!gui.in_use || gui.starting)
@@ -4603,11 +4603,11 @@
     /* Don't move the mouse when it's left or right of the Vim window */
     if (x < 0 || x > Columns * gui.char_width)
 	return;
+    if (y >= 0
 # ifdef FEAT_WINDOWS
-    if (Y_2_ROW(y) >= tabline_height())
-# else
-    if (y >= 0)
+	    && Y_2_ROW(y) >= tabline_height()
 # endif
+       )
 	wp = xy2win(x, y);
     if (wp != curwin && wp != NULL)	/* If in other than current window */
     {
diff -Naur vim70.orig/src/gui_xmebw.c vim70/src/gui_xmebw.c
--- vim70.orig/src/gui_xmebw.c	2006-04-30 08:32:32.000000000 -0700
+++ vim70/src/gui_xmebw.c	2006-07-14 08:51:21.000000000 -0700
@@ -47,13 +47,13 @@
 #include "gui_xmebwp.h"
 
 /* Provide some missing wrappers, which are missed from the LessTif
- * implementation.
+ * implementation.  Also missing in Motif 1.2 and earlier.
  *
  * We neither use XmeGetPixmapData or _XmGetPixmapData, since with LessTif the
  * pixmap will not appear in it's caches properly. We cache the interresting
  * values in XmEnhancedButtonPart instead ourself.
  */
-#ifdef LESSTIF_VERSION
+#if defined(LESSTIF_VERSION) || (XmVersion <= 1002)
 # ifndef Lab_IsMenupane
 #  define Lab_IsMenupane(w) (Lab_MenuType(w) == (int)XmMENU_POPUP || \
 		    Lab_MenuType(w) == (int)XmMENU_PULLDOWN)
@@ -480,7 +480,7 @@
 	    || (eb->core.height <= 2 * eb->primitive.highlight_thickness))
 	return;
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
     {
 	XmDisplay	dpy;
 
@@ -641,7 +641,7 @@
     GC		tmp_gc = NULL;
     Boolean	replaceGC = False;
     Boolean	deadjusted = False;
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
     XmDisplay	dpy = (XmDisplay)XmGetXmDisplay(XtDisplay(eb));
     Boolean	etched_in = dpy->display.enable_etched_in_menu;
 #else
@@ -726,7 +726,7 @@
 	if ((((ShellWidget) XtParent(XtParent(eb)))->shell.popped_up)
 		&& _XmGetInDragMode((Widget) eb))
 	{
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	    XmDisplay dpy = (XmDisplay) XmGetXmDisplay(XtDisplay(wid));
 	    Boolean etched_in = dpy->display.enable_etched_in_menu;
 #else
@@ -810,7 +810,7 @@
 
     if (Lab_IsMenupane(eb))
     {
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	XmDisplay dpy = (XmDisplay) XmGetXmDisplay(XtDisplay(wid));
 	Boolean etched_in = dpy->display.enable_etched_in_menu;
 #else
@@ -1150,7 +1150,7 @@
 Redisplay(Widget w, XEvent *event, Region region)
 {
     XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget) w;
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
     XmDisplay		    dpy;
     XtEnum		    default_button_emphasis;
 #endif
@@ -1162,7 +1162,7 @@
     if (!XtIsRealized((Widget)eb))
 	return;
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
     dpy = (XmDisplay)XmGetXmDisplay(XtDisplay(eb));
     default_button_emphasis = dpy->display.default_button_emphasis;
 #endif
@@ -1241,7 +1241,7 @@
     {
 	int adjust = 0;
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	/*
 	 *  NOTE: PushButton has two types of shadows: primitive-shadow and
 	 *  default-button-shadow.  If pushbutton is in a menu only primitive
@@ -1289,7 +1289,7 @@
 			  adjust, adjust, rectwidth, rectheight, borderwidth);
 	    }
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	    switch (default_button_emphasis)
 	    {
 		case XmINTERNAL_HIGHLIGHT:
@@ -1365,7 +1365,7 @@
 		    default_button_shadow_thickness =
 			       eb->pushbutton.default_button_shadow_thickness;
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 		/*
 		 * Compute location of bounding box to contain the
 		 * defaultButtonShadow.
diff -Naur vim70.orig/src/if_perl.xs vim70/src/if_perl.xs
--- vim70.orig/src/if_perl.xs	2006-03-06 10:57:16.000000000 -0800
+++ vim70/src/if_perl.xs	2006-08-19 16:39:02.000000000 -0700
@@ -155,8 +155,8 @@
 static int (*perl_run)(PerlInterpreter*);
 static int (*perl_parse)(PerlInterpreter*, XSINIT_t, int, char**, char**);
 static void* (*Perl_get_context)(void);
-static void (*Perl_croak)(pTHX_ const char*, ...) __attribute__((noreturn));
-static void (*Perl_croak_nocontext)(const char*, ...) __attribute__((noreturn));
+static void (*Perl_croak)(pTHX_ const char*, ...);
+static void (*Perl_croak_nocontext)(const char*, ...);
 static I32 (*Perl_dowantarray)(pTHX);
 static void (*Perl_free_tmps)(pTHX);
 static HV* (*Perl_gv_stashpv)(pTHX_ const char*, I32);
@@ -1056,7 +1056,6 @@
     int i;
     long lnum;
     char *line;
-    buf_T *savebuf;
     PPCODE:
     if (buf_valid(vimbuf))
     {
@@ -1069,14 +1068,20 @@
 	    line = SvPV(ST(i),PL_na);
 	    if (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count && line != NULL)
 	    {
-		savebuf = curbuf;
-		curbuf = vimbuf;
+		aco_save_T	aco;
+
+		/* set curwin/curbuf for "vimbuf" and save some things */
+		aucmd_prepbuf(&aco, vimbuf);
+
 		if (u_savesub(lnum) == OK)
 		{
 		    ml_replace(lnum, (char_u *)line, TRUE);
 		    changed_bytes(lnum, 0);
 		}
-		curbuf = savebuf;
+
+		/* restore curwin/curbuf and a few other things */
+		aucmd_restbuf(&aco);
+		/* Careful: autocommands may have made "vimbuf" invalid! */
 	    }
 	}
     }
@@ -1087,7 +1092,6 @@
 
     PREINIT:
     long i, lnum = 0, count = 0;
-    buf_T *savebuf;
     PPCODE:
     if (buf_valid(vimbuf))
     {
@@ -1114,16 +1118,23 @@
 	    {
 		if (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count)
 		{
-		    savebuf = curbuf;
-		    curbuf = vimbuf;
+		    aco_save_T	aco;
+
+		    /* set curwin/curbuf for "vimbuf" and save some things */
+		    aucmd_prepbuf(&aco, vimbuf);
+
 		    if (u_savedel(lnum, 1) == OK)
 		    {
 			ml_delete(lnum, 0);
 			deleted_lines_mark(lnum, 1L);
-			if (savebuf == curbuf)
+			if (aco.save_buf == curbuf)
 			    check_cursor();
 		    }
-		    curbuf = savebuf;
+
+		    /* restore curwin/curbuf and a few other things */
+		    aucmd_restbuf(&aco);
+		    /* Careful: autocommands may have made "vimbuf" invalid! */
+
 		    update_curbuf(VALID);
 		}
 	    }
@@ -1138,7 +1149,6 @@
     int		i;
     long	lnum;
     char	*line;
-    buf_T	*savebuf;
     PPCODE:
     if (buf_valid(vimbuf))
     {
@@ -1151,14 +1161,21 @@
 	    line = SvPV(ST(i),PL_na);
 	    if (lnum >= 0 && lnum <= vimbuf->b_ml.ml_line_count && line != NULL)
 	    {
-		savebuf = curbuf;
-		curbuf = vimbuf;
+		aco_save_T	aco;
+
+		/* set curwin/curbuf for "vimbuf" and save some things */
+		aucmd_prepbuf(&aco, vimbuf);
+
 		if (u_inssub(lnum + 1) == OK)
 		{
 		    ml_append(lnum, (char_u *)line, (colnr_T)0, FALSE);
 		    appended_lines_mark(lnum, 1L);
 		}
-		curbuf = savebuf;
+
+		/* restore curwin/curbuf and a few other things */
+		aucmd_restbuf(&aco);
+		/* Careful: autocommands may have made "vimbuf" invalid! */
+
 		update_curbuf(VALID);
 	    }
 	}
diff -Naur vim70.orig/src/if_ruby.c vim70/src/if_ruby.c
--- vim70.orig/src/if_ruby.c	2006-04-30 08:37:52.000000000 -0700
+++ vim70/src/if_ruby.c	2006-08-19 16:39:01.000000000 -0700
@@ -643,11 +643,14 @@
 
 static VALUE set_buffer_line(buf_T *buf, linenr_T n, VALUE str)
 {
-    buf_T *savebuf = curbuf;
-    char *line = STR2CSTR(str);
+    char	*line = STR2CSTR(str);
+    aco_save_T	aco;
+
+    if (n > 0 && n <= buf->b_ml.ml_line_count && line != NULL)
+    {
+	/* set curwin/curbuf for "buf" and save some things */
+	aucmd_prepbuf(&aco, buf);
 
-    if (n > 0 && n <= buf->b_ml.ml_line_count && line != NULL) {
-	curbuf = buf;
 	if (u_savesub(n) == OK) {
 	    ml_replace(n, (char_u *)line, TRUE);
 	    changed();
@@ -655,10 +658,15 @@
 	    syn_changed(n); /* recompute syntax hl. for this line */
 #endif
 	}
-	curbuf = savebuf;
+
+	/* restore curwin/curbuf and a few other things */
+	aucmd_restbuf(&aco);
+	/* Careful: autocommands may have made "buf" invalid! */
+
 	update_curbuf(NOT_VALID);
     }
-    else {
+    else
+    {
 	rb_raise(rb_eIndexError, "index %d out of buffer", n);
 	return Qnil; /* For stop warning */
     }
@@ -676,12 +684,15 @@
 
 static VALUE buffer_delete(VALUE self, VALUE num)
 {
-    buf_T *buf = get_buf(self);
-    buf_T *savebuf = curbuf;
-    long n = NUM2LONG(num);
+    buf_T	*buf = get_buf(self);
+    long	n = NUM2LONG(num);
+    aco_save_T	aco;
+
+    if (n > 0 && n <= buf->b_ml.ml_line_count)
+    {
+	/* set curwin/curbuf for "buf" and save some things */
+	aucmd_prepbuf(&aco, buf);
 
-    if (n > 0 && n <= buf->b_ml.ml_line_count) {
-	curbuf = buf;
 	if (u_savedel(n, 1) == OK) {
 	    ml_delete(n, 0);
 
@@ -691,10 +702,15 @@
 
 	    changed();
 	}
-	curbuf = savebuf;
+
+	/* restore curwin/curbuf and a few other things */
+	aucmd_restbuf(&aco);
+	/* Careful: autocommands may have made "buf" invalid! */
+
 	update_curbuf(NOT_VALID);
     }
-    else {
+    else
+    {
 	rb_raise(rb_eIndexError, "index %d out of buffer", n);
     }
     return Qnil;
@@ -702,13 +718,16 @@
 
 static VALUE buffer_append(VALUE self, VALUE num, VALUE str)
 {
-    buf_T *buf = get_buf(self);
-    buf_T *savebuf = curbuf;
-    char *line = STR2CSTR(str);
-    long n = NUM2LONG(num);
+    buf_T	*buf = get_buf(self);
+    char	*line = STR2CSTR(str);
+    long	n = NUM2LONG(num);
+    aco_save_T	aco;
+
+    if (n >= 0 && n <= buf->b_ml.ml_line_count && line != NULL)
+    {
+	/* set curwin/curbuf for "buf" and save some things */
+	aucmd_prepbuf(&aco, buf);
 
-    if (n >= 0 && n <= buf->b_ml.ml_line_count && line != NULL) {
-	curbuf = buf;
 	if (u_inssub(n + 1) == OK) {
 	    ml_append(n, (char_u *) line, (colnr_T) 0, FALSE);
 
@@ -718,7 +737,11 @@
 
 	    changed();
 	}
-	curbuf = savebuf;
+
+	/* restore curwin/curbuf and a few other things */
+	aucmd_restbuf(&aco);
+	/* Careful: autocommands may have made "buf" invalid! */
+
 	update_curbuf(NOT_VALID);
     }
     else {
diff -Naur vim70.orig/src/main.c vim70/src/main.c
--- vim70.orig/src/main.c	2006-05-03 10:36:44.000000000 -0700
+++ vim70/src/main.c	2006-08-19 16:32:24.000000000 -0700
@@ -564,7 +564,11 @@
      */
     if (p_lpl)
     {
+# ifdef VMS	/* Somehow VMS doesn't handle the "**". */
+	source_runtime((char_u *)"plugin/*.vim", TRUE);
+# else
 	source_runtime((char_u *)"plugin/**/*.vim", TRUE);
+# endif
 	TIME_MSG("loading plugins");
     }
 #endif
@@ -3208,10 +3212,15 @@
      * Register for remote command execution with :serversend and --remote
      * unless there was a -X or a --servername '' on the command line.
      * Only register nongui-vim's with an explicit --servername argument.
+     * When running as root --servername is also required.
      */
     if (X_DISPLAY != NULL && parmp->servername != NULL && (
 #  ifdef FEAT_GUI
-		gui.in_use ||
+		(gui.in_use
+#   ifdef UNIX
+		 && getuid() != 0
+#   endif
+		) ||
 #  endif
 		parmp->serverName_arg != NULL))
     {
diff -Naur vim70.orig/src/Makefile vim70/src/Makefile
--- vim70.orig/src/Makefile	2006-05-07 06:25:27.000000000 -0700
+++ vim70/src/Makefile	2006-07-14 08:51:21.000000000 -0700
@@ -2177,6 +2177,7 @@
 	cd $(SHADOWDIR)/xxd; ln -s ../../xxd/*.[ch] ../../xxd/Make* .
 	if test -d $(RSRC_DIR); then \
 		cd $(SHADOWDIR); \
+		ln -s ../infplist.xml .; \
 		ln -s ../$(RSRC_DIR) ../os_mac.rsr.hqx ../dehqx.py .; \
 	fi
 	mkdir $(SHADOWDIR)/testdir
diff -Naur vim70.orig/src/mbyte.c vim70/src/mbyte.c
--- vim70.orig/src/mbyte.c	2006-04-30 04:51:01.000000000 -0700
+++ vim70/src/mbyte.c	2006-08-19 16:34:45.000000000 -0700
@@ -311,7 +311,11 @@
 
 #define IDX_MACROMAN	57
     {"macroman",	ENC_8BIT + ENC_MACROMAN, 0},	/* Mac OS */
-#define IDX_COUNT	58
+#define IDX_DECMCS	58
+    {"dec-mcs",		ENC_8BIT,		0},	/* DEC MCS */
+#define IDX_HPROMAN8	59
+    {"hp-roman8",	ENC_8BIT,		0},	/* HP Roman8 */
+#define IDX_COUNT	60
 };
 
 /*
@@ -359,6 +363,8 @@
     {"932",		IDX_CP932},
     {"949",		IDX_CP949},
     {"936",		IDX_CP936},
+    {"gbk",		IDX_CP936},
+    {"gb18030",		IDX_CP936},	/* only 99% the same */
     {"950",		IDX_CP950},
     {"eucjp",		IDX_EUC_JP},
     {"unix-jis",	IDX_EUC_JP},
@@ -386,6 +392,7 @@
     {"950",		IDX_BIG5},
 #endif
     {"mac",		IDX_MACROMAN},
+    {"mac-roman",	IDX_MACROMAN},
     {NULL,		0}
 };
 
diff -Naur vim70.orig/src/menu.c vim70/src/menu.c
--- vim70.orig/src/menu.c	2006-05-03 10:30:48.000000000 -0700
+++ vim70/src/menu.c	2006-08-19 16:40:11.000000000 -0700
@@ -511,6 +511,14 @@
 	 * name (without mnemonic and accelerator text). */
 	next_name = menu_name_skip(name);
 	dname = menu_text(name, NULL, NULL);
+	if (dname == NULL)
+	    goto erret;
+	if (*dname == NUL)
+	{
+	    /* Only a mnemonic or accelerator is not valid. */
+	    EMSG(_("E792: Empty menu name"));
+	    goto erret;
+	}
 
 	/* See if it's already there */
 	lower_pri = menup;
@@ -704,6 +712,7 @@
 	parent = menu;
 	name = next_name;
 	vim_free(dname);
+	dname = NULL;
 	if (pri_tab[pri_idx + 1] != -1)
 	    ++pri_idx;
     }
@@ -793,6 +802,22 @@
 erret:
     vim_free(path_name);
     vim_free(dname);
+
+    /* Delete any empty submenu we added before discovering the error.  Repeat
+     * for higher levels. */
+    while (parent != NULL && parent->children == NULL)
+    {
+	if (parent->parent == NULL)
+	    menup = &root_menu;
+	else
+	    menup = &parent->parent->children;
+	for ( ; *menup != NULL && *menup != parent; menup = &((*menup)->next))
+	    ;
+	if (*menup == NULL) /* safety check */
+	    break;
+	parent = parent->parent;
+	free_menu(menup);
+    }
     return FAIL;
 }
 
@@ -1753,6 +1778,27 @@
 }
 
 /*
+ * Check that a pointer appears in the menu tree.  Used to protect from using
+ * a menu that was deleted after it was selected but before the event was
+ * handled.
+ * Return OK or FAIL.  Used recursively.
+ */
+    int
+check_menu_pointer(root, menu_to_check)
+    vimmenu_T *root;
+    vimmenu_T *menu_to_check;
+{
+    vimmenu_T	*p;
+
+    for (p = root; p != NULL; p = p->next)
+	if (p == menu_to_check
+		|| (p->children != NULL
+		    && check_menu_pointer(p->children, menu_to_check) == OK))
+	    return OK;
+    return FAIL;
+}
+
+/*
  * After we have started the GUI, then we can create any menus that have been
  * defined.  This is done once here.  add_menu_path() may have already been
  * called to define these menus, and may be called again.  This function calls
diff -Naur vim70.orig/src/message.c vim70/src/message.c
--- vim70.orig/src/message.c	2006-05-06 13:07:37.000000000 -0700
+++ vim70/src/message.c	2006-07-14 08:51:21.000000000 -0700
@@ -4175,15 +4175,16 @@
 			str_arg_l = 0;
 		    else
 		    {
-			/* memchr on HP does not like n > 2^31  !!! */
-			char *q = memchr(str_arg, '\0',
+			/* Don't put the #if inside memchr(), it can be a
+			 * macro. */
 #if SIZEOF_INT <= 2
-				precision
+			char *q = memchr(str_arg, '\0', precision);
 #else
-				precision <= (size_t)0x7fffffffL ? precision
-						       : (size_t)0x7fffffffL
+			/* memchr on HP does not like n > 2^31  !!! */
+			char *q = memchr(str_arg, '\0',
+				  precision <= (size_t)0x7fffffffL ? precision
+						       : (size_t)0x7fffffffL);
 #endif
-						       );
 			str_arg_l = (q == NULL) ? precision : q - str_arg;
 		    }
 		    break;
diff -Naur vim70.orig/src/misc1.c vim70/src/misc1.c
--- vim70.orig/src/misc1.c	2006-04-30 08:30:02.000000000 -0700
+++ vim70/src/misc1.c	2006-08-19 16:32:45.000000000 -0700
@@ -4492,7 +4492,7 @@
 		int l = mb_ptr2len(s);
 
 		while (--l > 0)
-		    *d++ = *s++;
+		    *d++ = *++s;
 	    }
 # endif
 	}
diff -Naur vim70.orig/src/netbeans.c vim70/src/netbeans.c
--- vim70.orig/src/netbeans.c	2006-04-22 11:00:05.000000000 -0700
+++ vim70/src/netbeans.c	2006-08-09 08:38:32.000000000 -0700
@@ -1986,6 +1986,8 @@
 	    if (buf->bufp != NULL)
 		do_buffer(DOBUF_WIPE, DOBUF_FIRST, FORWARD,
 						     buf->bufp->b_fnum, TRUE);
+	    buf->bufp = NULL;
+	    buf->initDone = FALSE;
 	    doupdate = 1;
 /* =====================================================================*/
 	}
diff -Naur vim70.orig/src/normal.c vim70/src/normal.c
--- vim70.orig/src/normal.c	2006-04-29 06:11:18.000000000 -0700
+++ vim70/src/normal.c	2006-08-19 16:40:11.000000000 -0700
@@ -2504,7 +2504,8 @@
 	     * NOTE: Ignore right button down and drag mouse events.
 	     * Windows only shows the popup menu on the button up event.
 	     */
-#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON)
+#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
+			  || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
 	    if (!is_click)
 		return FALSE;
 #endif
diff -Naur vim70.orig/src/ops.c vim70/src/ops.c
--- vim70.orig/src/ops.c	2006-04-30 08:13:44.000000000 -0700
+++ vim70/src/ops.c	2006-08-09 08:33:53.000000000 -0700
@@ -2413,6 +2413,7 @@
 	else
 	{
 	    curwin->w_cursor = oap->end;
+	    check_cursor_col();
 
 	    /* Works just like an 'i'nsert on the next character. */
 	    if (!lineempty(curwin->w_cursor.lnum)
@@ -3492,8 +3493,15 @@
 # endif
 	if (flags & PUT_CURSEND)
 	{
+	    colnr_T len;
+
 	    curwin->w_cursor = curbuf->b_op_end;
 	    curwin->w_cursor.col++;
+
+	    /* in Insert mode we might be after the NUL, correct for that */
+	    len = (colnr_T)STRLEN(ml_get_curline());
+	    if (curwin->w_cursor.col > len)
+		curwin->w_cursor.col = len;
 	}
 	else
 	    curwin->w_cursor.lnum = lnum;
diff -Naur vim70.orig/src/option.c vim70/src/option.c
--- vim70.orig/src/option.c	2006-05-03 10:32:28.000000000 -0700
+++ vim70/src/option.c	2006-08-09 08:34:17.000000000 -0700
@@ -2294,7 +2294,7 @@
 			    {(char_u *)0L, (char_u *)0L}
 #endif
 			    },
-    {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE,
+    {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE|P_COMMA,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_sps, PV_NONE,
 			    {(char_u *)"best", (char_u *)0L}
@@ -5227,13 +5227,13 @@
 	    case PV_STL:	return &curwin->w_p_stl_flags;
 #endif
 #ifdef FEAT_EVAL
+# ifdef FEAT_FOLDING
 	    case PV_FDE:	return &curwin->w_p_fde_flags;
 	    case PV_FDT:	return &curwin->w_p_fdt_flags;
+# endif
 # ifdef FEAT_BEVAL
 	    case PV_BEXPR:	return &curbuf->b_p_bexpr_flags;
 # endif
-#endif
-#if defined(FEAT_EVAL)
 # if defined(FEAT_CINDENT)
 	    case PV_INDE:	return &curbuf->b_p_inde_flags;
 # endif
@@ -6325,7 +6325,8 @@
 	    else
 		errmsg = check_stl_option(p_ruf);
 	}
-	else
+	/* check 'statusline' only if it doesn't start with "%!" */
+	else if (varp != &p_stl || s[0] != '%' || s[1] != '!')
 	    errmsg = check_stl_option(s);
 	if (varp == &p_ruf && errmsg == NULL)
 	    comp_col();
diff -Naur vim70.orig/src/os_unix.c vim70/src/os_unix.c
--- vim70.orig/src/os_unix.c	2006-05-01 01:13:15.000000000 -0700
+++ vim70/src/os_unix.c	2006-07-14 08:51:21.000000000 -0700
@@ -4971,7 +4971,8 @@
 		    if (((*file)[*num_file] = alloc(len + 2)) != NULL)
 		    {
 			STRCPY((*file)[*num_file], p);
-			if (!after_pathsep((*file)[*num_file] + len))
+			if (!after_pathsep((*file)[*num_file],
+						    (*file)[*num_file] + len))
 			{
 			    (*file)[*num_file][len] = psepc;
 			    (*file)[*num_file][len + 1] = NUL;
@@ -5757,8 +5758,13 @@
     int		retval_int = 0;
     int		success = FALSE;
 
-    /* Get a handle to the DLL module. */
+    /*
+     * Get a handle to the DLL module.
+     */
 # if defined(USE_DLOPEN)
+    /* First clear any error, it's not cleared by the dlopen() call. */
+    (void)dlerror();
+
     hinstLib = dlopen((char *)libname, RTLD_LAZY
 #  ifdef RTLD_LOCAL
 	    | RTLD_LOCAL
diff -Naur vim70.orig/src/popupmnu.c vim70/src/popupmnu.c
--- vim70.orig/src/popupmnu.c	2006-04-20 13:18:37.000000000 -0700
+++ vim70/src/popupmnu.c	2006-08-27 12:48:28.000000000 -0700
@@ -552,6 +552,9 @@
 {
     pum_array = NULL;
     redraw_all_later(SOME_VALID);
+#ifdef FEAT_WINDOWS
+    redraw_tabline = TRUE;
+#endif
     status_redraw_all();
 }
 
diff -Naur vim70.orig/src/proto/menu.pro vim70/src/proto/menu.pro
--- vim70.orig/src/proto/menu.pro	2006-05-07 06:08:51.000000000 -0700
+++ vim70/src/proto/menu.pro	2006-08-19 16:40:11.000000000 -0700
@@ -10,6 +10,7 @@
 extern int menu_is_child_of_popup __ARGS((vimmenu_T *menu));
 extern int menu_is_toolbar __ARGS((char_u *name));
 extern int menu_is_separator __ARGS((char_u *name));
+extern int check_menu_pointer __ARGS((vimmenu_T *root, vimmenu_T *menu_to_check));
 extern void gui_create_initial_menus __ARGS((vimmenu_T *menu));
 extern void gui_update_menus __ARGS((int modes));
 extern int gui_is_menu_shortcut __ARGS((int key));
diff -Naur vim70.orig/src/proto/undo.pro vim70/src/proto/undo.pro
--- vim70.orig/src/proto/undo.pro	2006-05-07 06:09:11.000000000 -0700
+++ vim70/src/proto/undo.pro	2006-07-14 10:51:11.000000000 -0700
@@ -4,6 +4,7 @@
 extern int u_savesub __ARGS((linenr_T lnum));
 extern int u_inssub __ARGS((linenr_T lnum));
 extern int u_savedel __ARGS((linenr_T lnum, long nlines));
+extern int undo_allowed __ARGS((void));
 extern void u_undo __ARGS((int count));
 extern void u_redo __ARGS((int count));
 extern void undo_time __ARGS((long step, int sec, int absolute));
diff -Naur vim70.orig/src/quickfix.c vim70/src/quickfix.c
--- vim70.orig/src/quickfix.c	2006-05-03 00:47:42.000000000 -0700
+++ vim70/src/quickfix.c	2006-08-19 16:39:02.000000000 -0700
@@ -602,13 +602,19 @@
 		else
 		    type = 0;
 		/*
-		 * Extract error message data from matched line
+		 * Extract error message data from matched line.
+		 * We check for an actual submatch, because "\[" and "\]" in
+		 * the 'errorformat' may cause the wrong submatch to be used.
 		 */
 		if ((i = (int)fmt_ptr->addr[0]) > 0)		/* %f */
 		{
-		    int c = *regmatch.endp[i];
+		    int c;
+
+		    if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
+			continue;
 
 		    /* Expand ~/file and $HOME/file to full path. */
+		    c = *regmatch.endp[i];
 		    *regmatch.endp[i] = NUL;
 		    expand_env(regmatch.startp[i], namebuf, CMDBUFFSIZE);
 		    *regmatch.endp[i] = c;
@@ -618,35 +624,63 @@
 			continue;
 		}
 		if ((i = (int)fmt_ptr->addr[1]) > 0)		/* %n */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    enr = (int)atol((char *)regmatch.startp[i]);
+		}
 		if ((i = (int)fmt_ptr->addr[2]) > 0)		/* %l */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    lnum = atol((char *)regmatch.startp[i]);
+		}
 		if ((i = (int)fmt_ptr->addr[3]) > 0)		/* %c */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    col = (int)atol((char *)regmatch.startp[i]);
+		}
 		if ((i = (int)fmt_ptr->addr[4]) > 0)		/* %t */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    type = *regmatch.startp[i];
+		}
 		if (fmt_ptr->flags == '+' && !multiscan)	/* %+ */
 		    STRCPY(errmsg, IObuff);
 		else if ((i = (int)fmt_ptr->addr[5]) > 0)	/* %m */
 		{
+		    if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
+			continue;
 		    len = (int)(regmatch.endp[i] - regmatch.startp[i]);
 		    vim_strncpy(errmsg, regmatch.startp[i], len);
 		}
 		if ((i = (int)fmt_ptr->addr[6]) > 0)		/* %r */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    tail = regmatch.startp[i];
+		}
 		if ((i = (int)fmt_ptr->addr[7]) > 0)		/* %p */
 		{
+		    if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
+			continue;
 		    col = (int)(regmatch.endp[i] - regmatch.startp[i] + 1);
 		    if (*((char_u *)regmatch.startp[i]) != TAB)
 			use_viscol = TRUE;
 		}
 		if ((i = (int)fmt_ptr->addr[8]) > 0)		/* %v */
 		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    col = (int)atol((char *)regmatch.startp[i]);
 		    use_viscol = TRUE;
 		}
 		if ((i = (int)fmt_ptr->addr[9]) > 0)		/* %s */
 		{
+		    if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
+			continue;
 		    len = (int)(regmatch.endp[i] - regmatch.startp[i]);
 		    if (len > CMDBUFFSIZE - 5)
 			len = CMDBUFFSIZE - 5;
@@ -2429,32 +2463,19 @@
     qf_info_T	*qi;
 {
     buf_T	*buf;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
-#else
-    buf_T	*save_curbuf;
-#endif
 
     /* Check if a buffer for the quickfix list exists.  Update it. */
     buf = qf_find_buf(qi);
     if (buf != NULL)
     {
-#ifdef FEAT_AUTOCMD
 	/* set curwin/curbuf to buf and save a few things */
 	aucmd_prepbuf(&aco, buf);
-#else
-	save_curbuf = curbuf;
-	curbuf = buf;
-#endif
 
 	qf_fill_buffer(qi);
 
-#ifdef FEAT_AUTOCMD
 	/* restore curwin/curbuf and a few other things */
 	aucmd_restbuf(&aco);
-#else
-	curbuf = save_curbuf;
-#endif
 
 	(void)qf_win_pos_update(qi, 0);
     }
@@ -2943,10 +2964,8 @@
 #if defined(FEAT_AUTOCMD) && defined(FEAT_SYN_HL)
     char_u	*save_ei = NULL;
 #endif
-#ifndef FEAT_AUTOCMD
-    buf_T	*save_curbuf;
-#else
     aco_save_T	aco;
+#ifdef FEAT_AUTOCMD
     char_u	*au_name =  NULL;
     int		flags = 0;
     colnr_T	col;
@@ -3167,24 +3186,13 @@
 		     * need to be done now, in that buffer.  And the modelines
 		     * need to be done (again).  But not the window-local
 		     * options! */
-#if defined(FEAT_AUTOCMD)
 		    aucmd_prepbuf(&aco, buf);
-#else
-		    save_curbuf = curbuf;
-		    curbuf = buf;
-		    curwin->w_buffer = curbuf;
-#endif
 #if defined(FEAT_AUTOCMD) && defined(FEAT_SYN_HL)
 		    apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,
 						     buf->b_fname, TRUE, buf);
 #endif
 		    do_modelines(OPT_NOWIN);
-#if defined(FEAT_AUTOCMD)
 		    aucmd_restbuf(&aco);
-#else
-		    curbuf = save_curbuf;
-		    curwin->w_buffer = curbuf;
-#endif
 		}
 	    }
 	}
@@ -3285,11 +3293,7 @@
 {
     buf_T	*newbuf;
     int		failed = TRUE;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
-#else
-    buf_T	*old_curbuf = curbuf;
-#endif
 
     /* Allocate a buffer without putting it in the buffer list. */
     newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);
@@ -3299,13 +3303,8 @@
     /* Init the options. */
     buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);
 
-#ifdef FEAT_AUTOCMD
     /* set curwin/curbuf to buf and save a few things */
     aucmd_prepbuf(&aco, newbuf);
-#else
-    curbuf = newbuf;
-    curwin->w_buffer = newbuf;
-#endif
 
     /* Need to set the filename for autocommands. */
     (void)setfname(curbuf, fname, NULL, FALSE);
@@ -3336,13 +3335,8 @@
 	}
     }
 
-#ifdef FEAT_AUTOCMD
     /* restore curwin/curbuf and a few other things */
     aucmd_restbuf(&aco);
-#else
-    curbuf = old_curbuf;
-    curwin->w_buffer = old_curbuf;
-#endif
 
     if (!buf_valid(newbuf))
 	return NULL;
diff -Naur vim70.orig/src/screen.c vim70/src/screen.c
--- vim70.orig/src/screen.c	2006-05-05 03:13:55.000000000 -0700
+++ vim70/src/screen.c	2006-07-14 10:50:30.000000000 -0700
@@ -2612,7 +2612,8 @@
 #ifdef FEAT_LINEBREAK
     int		need_showbreak = FALSE;
 #endif
-#if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS))
+#if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
+	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
 # define LINE_ATTR
     int		line_attr = 0;		/* atrribute for the whole line */
 #endif
@@ -2626,7 +2627,7 @@
     int		prev_c = 0;		/* previous Arabic character */
     int		prev_c1 = 0;		/* first composing char for prev_c */
 #endif
-#if defined(FEAT_DIFF) || defined(LINE_ATTR)
+#if defined(LINE_ATTR)
     int		did_line_attr = 0;
 #endif
 
@@ -4116,17 +4117,12 @@
 		    --ptr;	    /* put it back at the NUL */
 		}
 #endif
-#if defined(FEAT_DIFF) || defined(LINE_ATTR)
+#if defined(LINE_ATTR)
 		else if ((
 # ifdef FEAT_DIFF
-			    diff_hlf != (hlf_T)0
-#  ifdef LINE_ATTR
-			    ||
-#  endif
+			    diff_hlf != (hlf_T)0 ||
 # endif
-# ifdef LINE_ATTR
 			    line_attr != 0
-# endif
 			) && (
 # ifdef FEAT_RIGHTLEFT
 			    wp->w_p_rl ? (col >= 0) :
@@ -4237,7 +4233,7 @@
 	 * At end of the text line or just after the last character.
 	 */
 	if (c == NUL
-#if defined(FEAT_DIFF) || defined(LINE_ATTR)
+#if defined(LINE_ATTR)
 		|| did_line_attr == 1
 #endif
 		)
@@ -4258,7 +4254,7 @@
 				|| prevcol == (long)match_hl[0].startcol
 				|| prevcol == (long)match_hl[1].startcol
 				|| prevcol == (long)match_hl[2].startcol)
-# if defined(FEAT_DIFF) || defined(LINE_ATTR)
+# if defined(LINE_ATTR)
 			    && did_line_attr <= 1
 # endif
 			   )
@@ -7133,6 +7129,12 @@
 	return;
     entered = TRUE;
 
+    /*
+     * Note that the window sizes are updated before reallocating the arrays,
+     * thus we must not redraw here!
+     */
+    ++RedrawingDisabled;
+
     win_new_shellsize();    /* fit the windows in the new sized shell */
 
     comp_col();		/* recompute columns for shown command and ruler */
@@ -7367,6 +7369,7 @@
 #endif
 
     entered = FALSE;
+    --RedrawingDisabled;
 
 #ifdef FEAT_AUTOCMD
     if (starting == 0)
diff -Naur vim70.orig/src/spell.c vim70/src/spell.c
--- vim70.orig/src/spell.c	2006-05-05 00:49:58.000000000 -0700
+++ vim70/src/spell.c	2006-08-09 08:31:46.000000000 -0700
@@ -2108,7 +2108,8 @@
 	 * possible. */
 	STRCPY(buf, line);
 	if (lnum < wp->w_buffer->b_ml.ml_line_count)
-	    spell_cat_line(buf + STRLEN(buf), ml_get(lnum + 1), MAXWLEN);
+	    spell_cat_line(buf + STRLEN(buf),
+			  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);
 
 	p = buf + skip;
 	endp = buf + len;
@@ -10070,6 +10071,7 @@
 
 	/* List the suggestions. */
 	msg_start();
+	msg_row = Rows - 1;	/* for when 'cmdheight' > 1 */
 	lines_left = Rows;	/* avoid more prompt */
 	vim_snprintf((char *)IObuff, IOSIZE, _("Change \"%.*s\" to:"),
 						sug.su_badlen, sug.su_badptr);
diff -Naur vim70.orig/src/structs.h vim70/src/structs.h
--- vim70.orig/src/structs.h	2006-04-09 10:57:46.000000000 -0700
+++ vim70/src/structs.h	2006-08-19 16:39:02.000000000 -0700
@@ -2213,18 +2213,20 @@
 
 /*
  * Struct to save values in before executing autocommands for a buffer that is
- * not the current buffer.
+ * not the current buffer.  Without FEAT_AUTOCMD only "curbuf" is remembered.
  */
 typedef struct
 {
     buf_T	*save_buf;	/* saved curbuf */
+#ifdef FEAT_AUTOCMD
     buf_T	*new_curbuf;	/* buffer to be used */
     win_T	*save_curwin;	/* saved curwin, NULL if it didn't change */
     win_T	*new_curwin;	/* new curwin if save_curwin != NULL */
     pos_T	save_cursor;	/* saved cursor pos of save_curwin */
     linenr_T	save_topline;	/* saved topline of save_curwin */
-#ifdef FEAT_DIFF
+# ifdef FEAT_DIFF
     int		save_topfill;	/* saved topfill of save_curwin */
+# endif
 #endif
 } aco_save_T;
 
diff -Naur vim70.orig/src/term.c vim70/src/term.c
--- vim70.orig/src/term.c	2006-05-03 10:34:57.000000000 -0700
+++ vim70/src/term.c	2006-08-19 16:40:11.000000000 -0700
@@ -4783,6 +4783,14 @@
 		return -1;
 	    current_menu = (vimmenu_T *)val;
 	    slen += num_bytes;
+
+	    /* The menu may have been deleted right after it was used, check
+	     * for that. */
+	    if (check_menu_pointer(root_menu, current_menu) == FAIL)
+	    {
+		key_name[0] = KS_EXTRA;
+		key_name[1] = (int)KE_IGNORE;
+	    }
 	}
 # endif
 # ifdef FEAT_GUI_TABLINE
diff -Naur vim70.orig/src/undo.c vim70/src/undo.c
--- vim70.orig/src/undo.c	2006-04-21 02:30:59.000000000 -0700
+++ vim70/src/undo.c	2006-07-14 10:51:11.000000000 -0700
@@ -84,7 +84,6 @@
 static void u_unch_branch __ARGS((u_header_T *uhp));
 static u_entry_T *u_get_headentry __ARGS((void));
 static void u_getbot __ARGS((void));
-static int undo_allowed __ARGS((void));
 static int u_savecommon __ARGS((linenr_T, linenr_T, linenr_T));
 static void u_doit __ARGS((int count));
 static void u_undoredo __ARGS((int undo));
@@ -196,7 +195,7 @@
  * Return TRUE when undo is allowed.  Otherwise give an error message and
  * return FALSE.
  */
-    static int
+    int
 undo_allowed()
 {
     /* Don't allow changes when 'modifiable' is off.  */
diff -Naur vim70.orig/src/version.c vim70/src/version.c
--- vim70.orig/src/version.c	2006-05-03 00:50:42.000000000 -0700
+++ vim70/src/version.c	2006-08-27 12:48:28.000000000 -0700
@@ -667,6 +667,126 @@
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    66,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    49,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    41,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    36,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    7,
+/**/
+    6,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
     0
 };
 
diff -Naur vim70.orig/src/vim.h vim70/src/vim.h
--- vim70.orig/src/vim.h	2006-04-30 08:32:38.000000000 -0700
+++ vim70/src/vim.h	2006-07-14 08:51:21.000000000 -0700
@@ -585,7 +585,6 @@
 #define INSERT		0x10	/* Insert mode */
 #define LANGMAP		0x20	/* Language mapping, can be combined with
 				   INSERT and CMDLINE */
-#define MAP_ALL_MODES	0x3f	/* all mode bits used for mapping */
 
 #define REPLACE_FLAG	0x40	/* Replace mode flag */
 #define REPLACE		(REPLACE_FLAG + INSERT)
@@ -605,6 +604,9 @@
 #define CONFIRM		0x800	/* ":confirm" prompt */
 #define SELECTMODE	0x1000	/* Select mode, only for mappings */
 
+#define MAP_ALL_MODES	(0x3f | SELECTMODE)	/* all mode bits used for
+						 * mapping */
+
 /* directions */
 #define FORWARD			1
 #define BACKWARD		(-1)
@@ -1983,7 +1985,7 @@
 /* values for vim_handle_signal() that are not a signal */
 #define SIGNAL_BLOCK	-1
 #define SIGNAL_UNBLOCK  -2
-#if !defined(UNIX) && !defined(VMS)
+#if !defined(UNIX) && !defined(VMS) && !defined(OS2)
 # define vim_handle_signal(x) 0
 #endif
 
	
