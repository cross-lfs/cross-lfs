Submitted By: Jim Gifford (jim at linuxfromscratch dot org)
Date: 2006-09-11
Initial Package Version: 7.0
Origin: Upstream
Upstream Status: Applied
Description: Contains Patch 001-004, 006-026, 028-031, 033-044, 036-056,
        058-064, 066-073, and 075-099  from Upstream
        005, 027, 032, 045, 057, 066, and 074 are for the extras, Mac, or
        Windows 32 only

diff -Naur vim70.orig/configure vim70/configure
--- vim70.orig/configure	2004-07-05 02:02:24.000000000 -0700
+++ vim70/configure	2006-08-09 08:37:06.000000000 -0700
@@ -3,4 +3,4 @@
 # This is just a stub for the Unix configure script, to provide support for
 # doing "./configure" in the top Vim directory.
 
-cd src && ./configure "$@"
+cd src && exec ./configure "$@"
diff -Naur vim70.orig/runtime/autoload/ccomplete.vim vim70/runtime/autoload/ccomplete.vim
--- vim70.orig/runtime/autoload/ccomplete.vim	2006-05-03 07:35:56.000000000 -0700
+++ vim70/runtime/autoload/ccomplete.vim	2006-07-14 08:51:21.000000000 -0700
@@ -1,7 +1,7 @@
 " Vim completion script
 " Language:	C
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2006 May 03
+" Last Change:	2006 May 08
 
 
 " This function is used for the 'omnifunc' option.
@@ -458,7 +458,7 @@
 " member.
 function! s:StructMembers(typename, items, all)
   " Todo: What about local structures?
-  let fnames = join(map(tagfiles(), 'escape(v:val, " \\")'))
+  let fnames = join(map(tagfiles(), 'escape(v:val, " \\#%")'))
   if fnames == ''
     return []
   endif
diff -Naur vim70.orig/runtime/autoload/gzip.vim vim70/runtime/autoload/gzip.vim
--- vim70.orig/runtime/autoload/gzip.vim	2006-03-31 07:12:15.000000000 -0800
+++ vim70/runtime/autoload/gzip.vim	2006-08-09 08:37:36.000000000 -0700
@@ -1,6 +1,6 @@
 " Vim autoload file for editing compressed files.
 " Maintainer: Bram Moolenaar <Bram@vim.org>
-" Last Change: 2006 Mar 31
+" Last Change: 2006 Jul 19
 
 " These functions are used by the gzip plugin.
 
@@ -127,9 +127,9 @@
     let nmt = s:tempname(nm)
     if rename(nm, nmt) == 0
       if exists("b:gzip_comp_arg")
-	call system(a:cmd . " " . b:gzip_comp_arg . " " . nmt)
+	call system(a:cmd . " " . b:gzip_comp_arg . " '" . nmt . "'")
       else
-	call system(a:cmd . " " . nmt)
+	call system(a:cmd . " '" . nmt . "'")
       endif
       call rename(nmt . "." . expand("<afile>:e"), nm)
     endif
diff -Naur vim70.orig/runtime/autoload/paste.vim vim70/runtime/autoload/paste.vim
--- vim70.orig/runtime/autoload/paste.vim	2006-04-21 11:31:01.000000000 -0700
+++ vim70/runtime/autoload/paste.vim	2006-07-14 08:51:21.000000000 -0700
@@ -1,6 +1,6 @@
 " Vim support file to help with paste mappings and menus
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2006 Apr 21
+" Last Change:	2006 Jun 23
 
 " Define the string to use for items that are present both in Edit, Popup and
 " Toolbar menu.  Also used in mswin.vim and macmap.vim.
@@ -12,7 +12,7 @@
 if has("virtualedit")
   let paste#paste_cmd = {'n': ":call paste#Paste()<CR>"}
   let paste#paste_cmd['v'] = '"-c<Esc>' . paste#paste_cmd['n']
-  let paste#paste_cmd['i'] = '<Esc>' . paste#paste_cmd['n'] . 'gi'
+  let paste#paste_cmd['i'] = 'x<BS><Esc>' . paste#paste_cmd['n'] . 'gi'
 
   func! paste#Paste()
     let ove = &ve
diff -Naur vim70.orig/runtime/autoload/spellfile.vim vim70/runtime/autoload/spellfile.vim
--- vim70.orig/runtime/autoload/spellfile.vim	2006-02-01 04:12:24.000000000 -0800
+++ vim70/runtime/autoload/spellfile.vim	2006-09-11 08:32:21.000000000 -0700
@@ -1,9 +1,9 @@
 " Vim script to download a missing spell file
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last Change:	2006 Feb 01
+" Last Change:	2006 Aug 29
 
 if !exists('g:spellfile_URL')
-  let g:spellfile_URL = 'ftp://ftp.vim.org/pub/vim/unstable/runtime/spell'
+  let g:spellfile_URL = 'ftp://ftp.vim.org/pub/vim/runtime/spell'
 endif
 let s:spellfile_URL = ''    " Start with nothing so that s:donedict is reset.
 
@@ -61,13 +61,13 @@
     new
     setlocal bin
     echo 'Downloading ' . fname . '...'
-    exe 'Nread ' g:spellfile_URL . '/' . fname
+    call spellfile#Nread(fname)
     if getline(2) !~ 'VIMspell'
       " Didn't work, perhaps there is an ASCII one.
       g/^/d
       let fname = a:lang . '.ascii.spl'
       echo 'Could not find it, trying ' . fname . '...'
-      exe 'Nread ' g:spellfile_URL . '/' . fname
+      call spellfile#Nread(fname)
       if getline(2) !~ 'VIMspell'
 	echo 'Sorry, downloading failed'
 	bwipe!
@@ -95,7 +95,7 @@
 	g/^/d
 	let fname = substitute(fname, '\.spl$', '.sug', '')
 	echo 'Downloading ' . fname . '...'
-	exe 'Nread ' g:spellfile_URL . '/' . fname
+	call spellfile#Nread(fname)
 	if getline(2) !~ 'VIMsug'
 	  echo 'Sorry, downloading failed'
 	else
@@ -109,3 +109,15 @@
     bwipe
   endif
 endfunc
+
+" Read "fname" from the server.
+function! spellfile#Nread(fname)
+  if g:spellfile_URL =~ '^ftp://'
+    " for an ftp server use a default login and password to avoid a prompt
+    let machine = substitute(g:spellfile_URL, 'ftp://\([^/]*\).*', '\1', '')
+    let dir = substitute(g:spellfile_URL, 'ftp://[^/]*/\(.*\)', '\1', '')
+    exe 'Nread "' . machine . ' anonymous vim7user ' . dir . '/' . a:fname . '"'
+  else
+    exe 'Nread ' g:spellfile_URL . '/' . a:fname
+  endif
+endfunc
diff -Naur vim70.orig/runtime/plugin/matchparen.vim vim70/runtime/plugin/matchparen.vim
--- vim70.orig/runtime/plugin/matchparen.vim	2006-04-27 06:31:26.000000000 -0700
+++ vim70/runtime/plugin/matchparen.vim	2006-09-11 09:04:35.000000000 -0700
@@ -1,6 +1,6 @@
 " Vim plugin for showing matching parens
 " Maintainer:  Bram Moolenaar <Bram@vim.org>
-" Last Change: 2006 Apr 27
+" Last Change: 2006 Sep 09
 
 " Exit quickly when:
 " - this plugin was already loaded (or disabled)
@@ -44,7 +44,7 @@
   let before = 0
 
   let c = getline(c_lnum)[c_col - 1]
-  let plist = split(&matchpairs, ':\|,')
+  let plist = split(&matchpairs, '.\zs[:,]')
   let i = index(plist, c)
   if i < 0
     " not found, in Insert mode try character before the cursor
@@ -90,19 +90,19 @@
   " Find the match.  When it was just before the cursor move it there for a
   " moment.
   if before > 0
-    let save_cursor = getpos('.')
+    let save_cursor = winsaveview()
     call cursor(c_lnum, c_col - before)
   endif
 
   " When not in a string or comment ignore matches inside them.
   let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
-	\ '=~?  "string\\|comment"'
+	\ '=~?  "string\\|character\\|singlequote\\|comment"'
   execute 'if' s_skip '| let s_skip = 0 | endif'
 
   let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
 
   if before > 0
-    call setpos('.', save_cursor)
+    call winrestview(save_cursor)
   endif
 
   " If a match is found setup match highlighting.
diff -Naur vim70.orig/runtime/scripts.vim vim70/runtime/scripts.vim
--- vim70.orig/runtime/scripts.vim	2006-03-28 11:30:49.000000000 -0800
+++ vim70/runtime/scripts.vim	2006-08-09 08:38:04.000000000 -0700
@@ -1,7 +1,7 @@
 " Vim support file to detect file types in scripts
 "
 " Maintainer:	Bram Moolenaar <Bram@vim.org>
-" Last change:	2006 Mar 28
+" Last change:	2006 Jul 08
 
 " This file is called by an autocommand for every file that has just been
 " loaded into a buffer.  It checks if the type of file can be recognized by
@@ -54,6 +54,12 @@
     let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
   endif
 
+  " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
+  " third line.  Suggested by Steven Atkinson.
+  if getline(3) =~ '^exec wish'
+    let s:name = 'wish'
+  endif
+
   " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
   if s:name =~ '^\(bash\d*\|\|ksh\d*\|sh\)\>'
     call SetFileTypeSH(s:line1)	" defined in filetype.vim
diff -Naur vim70.orig/runtime/tutor/Makefile vim70/runtime/tutor/Makefile
--- vim70.orig/runtime/tutor/Makefile	2004-06-07 07:32:39.000000000 -0700
+++ vim70/runtime/tutor/Makefile	2006-09-11 09:26:16.000000000 -0700
@@ -2,8 +2,13 @@
 #
 # The Japanese tutor exists in three encodings.  Use the UTF-8 version as the
 # original and create the others with conversion.
+#
+# Similarly for Russian and Korean
 
-all: tutor.ja.sjis tutor.ja.euc tutor.ko.euc
+all: tutor.ja.sjis tutor.ja.euc \
+	tutor.ko.euc \
+	tutor.ru tutor.ru.cp1251 \
+	tutor.gr tutor.gr.cp737
 
 tutor.ja.sjis: tutor.ja.utf-8
 	nkf -WXs tutor.ja.utf-8 > tutor.ja.sjis
@@ -13,3 +18,15 @@
 
 tutor.ko.euc: tutor.ko.utf-8
 	iconv -f UTF-8 -t EUC-KR tutor.ko.utf-8 > tutor.ko.euc
+
+tutor.ru: tutor.ru.utf-8
+	iconv -f UTF-8 -t KOI8-R tutor.ru.utf-8 > tutor.ru
+
+tutor.ru.cp1251: tutor.ru.utf-8
+	iconv -f UTF-8 -t cp1251 tutor.ru.utf-8 > tutor.ru.cp1251
+
+tutor.gr: tutor.gr.utf-8
+	iconv -f UTF-8 -t ISO-8859-7 tutor.gr.utf-8 > tutor.gr
+
+tutor.gr.cp737: tutor.gr.utf-8
+	iconv -f UTF-8 -t cp737 tutor.gr.utf-8 > tutor.gr.cp737
diff -Naur vim70.orig/runtime/tutor/tutor.gr.utf-8 vim70/runtime/tutor/tutor.gr.utf-8
--- vim70.orig/runtime/tutor/tutor.gr.utf-8	1969-12-31 16:00:00.000000000 -0800
+++ vim70/runtime/tutor/tutor.gr.utf-8	2006-09-11 09:26:16.000000000 -0700
@@ -0,0 +1,815 @@
+===============================================================================
+=    . αλ . . ή ρ θ α . ε    . . ο   V I M   T u t o r    -    .κδο.η 1.5     =
+===============================================================================
+
+     . Vim είναι ένα. .ανί...ρο. ..ν.άκ.η. .ο. έ.ει .ολλέ. εν.ολέ., .άρα
+     .ολλέ. για να εξηγή.ο.με .ε μία .εριήγη.η .... α..ή. ...ή η .εριήγη.η
+     ..εδιά..ηκε για να .εριγρά.ει ικανο.οιη.ικά .ι. εν.ολέ. .ο. θα .α.
+     κάνο.ν να .ρη.ιμο.οιεί.ε εύκολα .ον Vim .αν έναν γενική. .ρή.η. ..ν.άκ.η.
+
+     . κα.ά .ρο.έγγι.η .ρ.νο. .ο. α.αι.εί.αι για να ολοκληρ..ε.ε .ην .εριήγη.η
+     είναι 25-30 λε..ά, εξαρ..ν.α. α.. .ο ...ο .ρ.νο θα ξοδέ.ε.ε για
+     .ειραμα.ι.μού..
+
+     .ι εν.ολέ. ..α μαθήμα.α θα .ρο.ο.οιή.ο.ν .ο κείμενο. .ημιο.ργή..ε ένα
+     αν.ίγρα.ο α..ού .ο. αρ.είο. για να εξα.κηθεί.ε (αν ξεκινή.α.ε .ο
+     "Vimtutor" α... είναι ήδη ένα αν.ίγρα.ο).
+
+     .ίναι .ημαν.ικ. να θ.μά..ε ..ι α..ή η .εριήγη.η είναι οργαν.μένη έ..ι
+     ...ε να διδά.κει μέ.. .η. .ρή.η.. .... .ημαίνει ..ι .ρειάζε.αι να
+     εκ.ελεί.ε .ι. εν.ολέ. για να .ι. μάθε.ε ....ά. .ν διαβάζε.ε μ.νο .ο
+     κείμενο, θα .ι. ξε.ά.ε.ε!
+
+     Τ.ρα, βεβαι.θεί.ε ..ι .ο .λήκ.ρο Shift-Lock ..Ν είναι .α.ημένο και
+     .α.ή..ε .ο .λήκ.ρο j αρκε.έ. .ορέ. για να με.ακινή.ε.ε .ον δρομέα έ..ι
+     ...ε .ο .άθημα 1.1 να γεμί.ει .λήρ.. .ην οθ.νη.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      .άθημα 1.1:  ..Τ...Ν.ΝΤ.Σ Τ.Ν .Ρ....
+
+  ** .ια να κινή.ε.ε .ον δρομέα, .α.ή..ε .α .λήκ.ρα h,j,k,l .... δεί.νε.αι. **
+	     ^
+	     k	      Hint: Το .λήκ.ρο h είναι αρι..ερά και κινεί ..' αρι..ερά.
+       < h	 l >	    Το .λήκ.ρο l είναι δεξιά και κινεί ..α δεξιά.
+	     j		    Το .λήκ.ρο j μοιάζει με βελάκι .ρο. .α κά...
+	     v
+
+  1. .ε.ακινεί..ε .ον δρομέα .ριγύρ. ..ην οθ.νη μέ.ρι να νοι.θε.ε άνε.α.
+
+  2. .ρα.ή..ε .α.ημένο .ο κά.. .λήκ.ρο (j) μέ.ρι να ε.αναλη.θεί.
+---> Τ.ρα ξέρε.ε ... να με.ακινηθεί.ε ..ο ε..μενο μάθημα.
+
+  3. Χρη.ιμο.οι.ν.α. .ο κά.. .λήκ.ρο, με.ακινηθεί.ε ..ο .άθημα 1.2.
+
+Σημεί..η: .ν αμ.ιβάλλε.ε για κά.ι .ο. .α.ή.α.ε, .α.ή..ε <ESC> για να βρεθεί.ε
+	  ..ην .ανονική .α.ά..α.η. .ε.ά .α.ή..ε ξανά .ην εν.ολή .ο. θέλα.ε.
+
+Σημεί..η: Τα .λήκ.ρα .ο. δρομέα θα .ρέ.ει ε.ί.η. να δο.λεύο.ν. .λλά με .α hjkl
+	  θα μ.ορεί.ε να κινηθεί.ε .ολύ γρηγορ..ερα, μ.λι. .α ..νηθί.ε.ε.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		.άθημα 1.2:  . ..Ν.ΝΤ.Σ ... ....Ν.ΝΤ.Σ ΣΤ.Ν VIM
+
+  !! Σ....ΩΣ.:  ριν εκ.ελέ.ε.ε κά.οιο α.. .α βήμα.α, διαβά..ε .λο .ο μάθημα!!
+
+  1.  α.ή..ε .ο .λήκ.ρο <ESC> (για να εί..ε .ίγο.ρα ..ην .ανονική .α.ά..α.η).
+
+  2.  ληκ.ρολογή..ε:		:q! <ENTER>.
+
+---> .... εξέρ.ε.αι α.. .ον ..ν.άκ.η ΧΩΡ.Σ να ...ει ..οιε. αλλαγέ. έ.ε.ε κάνει.
+     .ν θέλε.ε να ...ε.ε .ι. αλλαγέ. και να εξέρθε.ε .ληκ.ρολογή..ε:
+	      :wq <ENTER>
+
+  3. ..αν δεί.ε .ην .ρο.ρο.ή .ο. .λοιού, .ληκ.ρολογή..ε .ην εν.ολή με .ην ο.οία
+     μ.ήκα.ε .ε α..ήν .ην .εριήγη.η. ..ορεί να είναι:	vimtutor <ENTER>
+     .ανονικά θα .ρη.ιμο.οιού.α.ε:			vim tutor <ENTER>
+
+---> 'vim' .ημαίνει ει.αγ.γή ..ον ..ν.άκ.η vim, 'tutor' είναι .ο αρ.είο .ο.
+     θέλο.με να διορθ..ο.με.
+
+  4. .ν έ.ε.ε α.ομνημονεύ.ει α..ά .α βήμα.α και έ.ε.ε α..ο.ε.οίθη.η, εκ.ελέ..ε
+     .α βήμα.α 1 έ.. 3 για να βγεί.ε και να μ.εί.ε ξανά ..ον ..ν.άκ.η. .ε.ά
+     με.ακινή..ε .ον δρομέα κά.. ..ο .άθημα 1.3.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   .άθημα 1.3:  ...Ρ.ΩΣ. .....Ν.Υ - ....Ρ.Φ.
+
+   ** ..ο εί..ε ..ην .ανονική .α.ά..α.η .α.ή..ε  x  για να διαγρά.ε.ε .ον
+      .αρακ.ήρα κά.. α.. .ον δρομέα. **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ην .αρακά.. γραμμή .ημει.μένη με --->.
+
+  2. .ια να διορθ..ε.ε .α λάθη, κινεί..ε .ον δρομέα μέ.ρι να είναι .άν. α..
+     .ον .αρακ.ήρα .ο. θα διαγρα.εί.
+
+  3.  α.ή..ε .ο .λήκ.ρο x για να διαγρά.ε.ε .ον ανε.ιθύμη.ο .αρακ.ήρα.
+
+  4. ..αναλάβε.ε .α βήμα.α 2 μέ.ρι 4 μέ.ρι η .ρ..α.η να είναι ....ή.
+
+---> The ccow jumpedd ovverr thhe mooon.
+
+  5. Τ.ρα .ο. η γραμμή είναι ....ή, .ηγαίν.ε ..ο .άθημα 1.4.
+
+Σ....ΩΣ.: .αθ.. δια.ρέ.ε.ε α..ήν .ην .εριήγη.η, .ρο..αθή..ε να μην
+	  α.ομνημονεύε.ε, μαθαίνε.ε με .η .ρή.η.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   .άθημα 1.4: ...Ρ.ΩΣ. .....Ν.Υ -  .Ρ......
+
+ ** ..ο εί..ε .ε .ανονική .α.ά..α.η .α.ή..ε  i  για να .αρεμβάλλε.ε κείμενο. **
+
+  1. .ε.ακινεί..ε .ον δρομέα μέ.ρι .ην .ρ..η γραμμή .αρακά.. .ημει.μένη με --->.
+
+  2. .ια να κάνε.ε .ην .ρ..η γραμμή ίδια με .ην δεύ.ερη, με.ακινεί..ε .ον
+     δρομέα .άν. ..ον .ρ..ο .αρακ.ήρα ..Τ. α.. ..ο. θα .αρεμβληθεί .ο κείμενο.
+
+  3.  α.ή..ε .ο  i  και .ληκ.ρολογή..ε .ι. α.αραί.η.ε. .ρο.θήκε..
+
+  4. .αθ.. διορθ.νε.ε κάθε λάθο. .α.ή..ε <ESC> για να ε.ι..ρέ.ε.ε ..ην
+     .ανονική .α.ά..α.η. ..αναλάβε.ε .α βήμα.α 2 μέ.ρι 4 για να διορθ..ε.ε
+     .ην .ρ..α.η.
+
+---> There is text misng this .
+---> There is some text missing from this line.
+
+  5. ..αν εί..ε άνε.οι με .ην .αρεμβολή κειμένο. με.ακινηθεί.ε ..ην
+     .αρακά.. .ερίλη.η.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			       ...... 1  .Ρ...Ψ.
+
+
+  1. . δρομέα. κινεί.αι .ρη.ιμο.οι.ν.α. εί.ε .α .λήκ.ρα δρομέα ή .α hjkl.
+	 h (αρι..έρα)	j (κά..)	k (.άν.)	l (δεξιά)
+
+  2. .ια να μ.εί.ε ..ον Vim (α.. .ην .ρο.ρο.ή %) γρά..ε:  vim .ΡΧ... <ENTER>
+
+  3. .ια να βγεί.ε γρά..ε:  <ESC>   :q!   <ENTER>   για α..ρρι.η ..ν αλλαγ.ν.
+		 . γρά..ε:  <ESC>   :wq   <ENTER>   για α.οθήκε..η ..ν αλλαγ.ν.
+
+  4. .ια να διαγρά.ε.ε έναν .αρακ.ήρα κά.. α.. .ον δρομέα .ε
+     .ανονική .α.ά..α.η .α.ή..ε:  x
+
+  5. .ια να ει.άγε.ε κείμενο ..ον δρομέα ..ο εί..ε .ε .ανονική .α.ά..α.η γρά..ε:
+	 i     .ληκ.ρολογή..ε .ο κείμενο	<ESC>
+
+Σ....ΩΣ.:  α..ν.α. <ESC> θα .ο.οθε.ηθεί.ε ..ην .ανονική .α.ά..α.η ή θα
+	  ακ.ρ..ε.ε μία ανε.ιθύμη.η και μερικ.. ολοκληρ.μένη εν.ολή.
+
+Τ.ρα ..νε.ί..ε με .ο .άθημα 2.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 .άθημα 2.1: .ΝΤ...Σ ....Ρ.Φ.Σ
+
+	 ** .ρά..ε  dw  για να διαγρά.ε.ε μέ.ρι .ο .έλο. μία. λέξη.. **
+
+  1.  α.ή..ε  <ESC>  για να βεβαι.θεί.ε ..ι εί..ε ..ην .ανονική .α.ά..α.η.
+
+  2. .ε.ακινεί..ε .ον δρομέα ..ην .αρακά.. γραμμή .ημει.μένη με --->.
+
+  3.  ηγαίνε.ε .ον δρομέα ..ην αρ.ή .η. λέξη. .ο. .ρέ.ει να διαγρα.εί.
+
+  4. .ρά..ε  dw  για να κάνε.ε .ην λέξη να εξα.ανι..εί.
+
+Σ....ΩΣ.: Τα γράμμα.α dw θα εμ.ανι..ούν ..ην .ελε..αία γραμμή .η. οθ.νη. ..ο
+	  .α .ληκ.ρολογεί.ε. .ν γρά.α.ε κά.ι λάθο., .α.ή..ε  <ESC>  και
+	  ξεκινή..ε α.. .ην αρ.ή.
+
+---> There are a some words fun that don't belong paper in this sentence.
+
+  5. ..αναλάβε.ε .α βήμα.α 3 και 4 μέ.ρι η .ρ..α.η να είναι ....ή και
+     .ηγαίνε.ε ..ο .άθημα 2.2.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   .άθημα 2.2:  .Ρ.ΣΣ.Τ.Ρ.Σ .ΝΤ...Σ ....Ρ.Φ.Σ
+
+    **  ληκ.ρολογή..ε  d$  για να διαγρά.ε.ε μέ.ρι .ο .έλο. .η. γραμμή.. **
+
+  1.  α.ή..ε  <ESC>  για να βεβαι.θεί.ε ..ι εί..ε ..ην .ανονική .α.ά..α.η.
+
+  2. .ε.ακινεί..ε .ον δρομέα ..ην .αρακά.. γραμμή .ημει.μένη με --->.
+
+  3. .ε.ακινεί..ε .ον δρομέα ..ο .έλο. .η. ....ή. γραμμή. (..Τ. .ην .ρ..η . ).
+
+  4.  α.ή..ε   d$   για να διαγρά.ε.ε μέ.ρι .ο .έλο. .η. γραμμή..
+
+---> Somebody typed the end of this line twice. end of this line twice.
+
+  5.  ηγαίνε.ε ..ο .άθημα 2.3 για να κα.αλάβε.ε .ι ..μβαίνει.
+
+
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   .άθημα 2.3:  .Ρ. .ΝΤ..ΩΝ ... .ΝΤ......ΝΩΝ
+
+
+. μορ.ή .η. εν.ολή. διαγρα.ή.  d  είναι .. εξή.:
+
+	 [αριθμ..]   d   αν.ικείμενο	.	d   [αριθμ..]   αν.ικείμενο
+  ..ο.:
+    αριθμ.. - ...ε. .ορέ. θα εκ.ελε..εί η εν.ολή (.ροαιρε.ικ., εξ' ορι.μού=1).
+    d - η εν.ολή .η. διαγρα.ή..
+    αν.ικείμενο - .άν. .ε .ι θα λει.ο.ργή.ει η εν.ολή (.αρακά.. λί..α).
+
+  .ία μικρή λί..α α.. αν.ικείμενα:
+    w - α.. .ον δρομέα μέ.ρι .ο .έλο. .η. λέξη., .εριλαμβάνον.α. .ο διά..ημα.
+    e - α.. .ον δρομέα μέ.ρι .ο .έλο. .η. λέξη., ΧΩΡ.Σ .ο διά..ημα.
+    $ - α.. .ον δρομέα μέ.ρι .ο .έλο. .η. γραμμή..
+
+Σ....ΩΣ.:  .ια .ο.. .ύ.ο.. .η. .ερι.έ.εια., .α..ν.α. α.λ.. .ο αν.ικείμενο ..ο
+	   εί..ε ..ην .ανονική .α.ά..α.η ..ρί. κά.οια εν.ολή θα με.ακινή.ε.ε
+	   .ον δρομέα .... καθορίζε.αι ..ην λί..α αν.ικειμέν.ν.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	       .άθημα 2.4: ... ....Ρ.Σ. ΣΤ.Ν '.ΝΤ...-.ΝΤ......Ν.'
+
+	   **  ληκ.ρολογή..ε  dd  για να διαγρά.ε.ε .λη .η γραμμή. **
+
+  .ξαι.ία. .η. ...ν..η.α. .η. διαγρα.ή. ολ.κληρη. γραμμή., οι ..εδια..έ.
+  .ο. Vim α.ο.ά.ι.αν ..ι θα ή.αν ε.κολ..ερο να γρά.ε.ε α.λ.. δύο d ..η
+  .ειρά για να διαγρά.ε.ε μία γραμμή.
+
+  1. .ε.ακινεί..ε .ον δρομέα ..η δεύ.ερη γραμμή .η. .αρακά.. .ρά.η..
+  2. .ρά..ε  dd  για να διαγρά.ε.ε .η γραμμή.
+  3. Τ.ρα με.ακινηθεί.ε ..ην .έ.αρ.η γραμμή.
+  4. .ρά..ε  2dd  (θ.μηθεί.ε  αριθμ..-εν.ολή-αν.ικείμενο) για να
+     διαγρά.ε.ε δύο γραμμέ..
+
+      1)  Roses are red,
+      2)  Mud is fun,
+      3)  Violets are blue,
+      4)  I have a car,
+      5)  Clocks tell time,
+      6)  Sugar is sweet
+      7)  And so are you.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 .άθημα 2.5: . .ΝΤ... .Ν..Ρ.Σ.Σ
+
+	    **  α.ή..ε  u  για να αναιρέ.ε.ε .ι. .ελε..αίε. εν.ολέ.,
+	       U για να διορθ..ε.ε .λη .η γραμμή. **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ην .αρακά.. γραμμή .ημει.μένη με ---> και
+     .ο.οθε.ή..ε .ον .άν. ..ο .ρ..ο λάθο..
+  2.  α.ή..ε  x  για να διαγρά.ε.ε .ον .ρ..ο ανε.ιθύμη.ο .αρακ.ήρα.
+  3. Τ.ρα .α.ή..ε  u  για να αναιρέ.ε.ε .ην .ελε..αία εκ.ελε.μένη εν.ολή.
+  4. ...ή .η .ορά διορθ...ε .λα .α λάθη ..η γραμμή .ρη.ιμο.οι.ν.α. .ην εν.ολή x.
+  5. Τ.ρα .α.ή..ε ένα κε.αλαίο  U  για να ε.ι..ρέ.ε.ε .η γραμμή ..ην αρ.ική
+     .η. κα.ά..α.η.
+  6. Τ.ρα .α.ή..ε  u  μερικέ. .ορέ. για να αναιρέ.ε.ε .ην  U  και
+     .ροηγούμενε. εν.ολέ..
+  7. Τ.ρα .α.ή..ε CTRL-R (κρα..ν.α. .α.ημένο .ο .λήκ.ρο CTRL καθ.. .α.ά.ε .ο R)
+     μερικέ. .ορέ. για να ε.ανα.έρε.ε .ι. εν.ολέ. (αναίρε.η ..ν αναιρέ.ε.ν).
+
+---> Fiix the errors oon thhis line and reeplace them witth undo.
+
+  8. ...έ. είναι .ολύ .ρή.ιμε. εν.ολέ..  Τ.ρα .ηγαίνε.ε ..ην
+      ερίλη.η .ο. .αθήμα.ο. 2.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			       ...... 2  .Ρ...Ψ.
+
+
+  1. .ια να διαγρά.ε.ε α.. .ον δρομέα μέ.ρι .ο .έλο. λέξη. γρά..ε:      dw
+
+  2. .ια να διαγρά.ε.ε α.. .ον δρομέα μέ.ρι .ο .έλο. γραμμή. γρά..ε:    d$
+
+  3. .ια να διαγρά.ε.ε ολ.κληρη .η γραμμή γρά..ε:    dd
+
+  4. . μορ.ή για μία εν.ολή ..ην .ανονική .α.ά..α.η είναι:
+
+      [αριθμ..]   εν.ολή   αν.ικείμενο    .    εν.ολή   [αριθμ..]   αν.ικείμενο
+     ..ο.:
+       αριθμ.. - ...ε. .ορέ. να ε.αναλη.θεί η εν.ολή
+       εν.ολή - .ι να γίνει, .... η  d  για διαγρα.ή
+       αν.ικείμενο - .άν. .ε .ι να ενεργή.ει η εν.ολή, ....  w  (λέξη),
+		     $ (.έλο. .η. γραμμή.), κ.λ.
+
+  5. .ια να αναιρέ.ε.ε .ροηγούμενε. ενέργειε., .α.ή..ε:        u   (.εζ. u)
+     .ια να αναιρέ.ε.ε .λε. .ι. αλλαγέ. ..η γραμμή, .α.ή..ε:  U  (κε.αλαίο U)
+     .ια να αναιρέ.ε.ε .ι. αναιρέ.ει., .α.ή..ε:               CTRL-R
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			.άθημα 3.1: . .ΝΤ... Τ. ...Τ.Σ.Σ
+
+
+  **  α.ή..ε  p  για να .ο.οθε.ή.ε.ε .ην .ελε..αία διαγρα.ή με.ά .ον δρομέα.  **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ην .ρ..η γραμμή .η. .αρακά.. ομάδα..
+
+  2.  α.ή..ε  dd  για να διαγρά.ε.ε .η γραμμή και να .ην α.οθηκεύ.ε.ε .ε
+     .ρο..ρινή μνήμη .ο. Vim.
+
+  3. .ε.ακινεί..ε .ον δρομέα ..η γραμμή  .ΝΩ α.. εκεί .ο. θα .ρέ.ει να .άει
+     η διαγραμμένη γραμμή.
+
+  4. ..ο εί..ε .ε .ανονική .α.ά..α.η, .α.ή..ε  p  για να βάλε.ε .η γραμμή.
+
+  5. ..αναλάβε.ε .α βήμα.α 2 έ.. 4 για να βάλε.ε .λε. .ι. γραμμέ. ..η
+     ....ή .ειρά.
+
+     d) Can you learn too?
+     b) Violets are blue,
+     c) Intelligence is learned,
+     a) Roses are red,
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      .άθημα 3.2: . .ΝΤ... .ΝΤ...Τ.ΣΤ.Σ.Σ
+
+
+    **  α.ή..ε  r  και .αρακ.ήρα για να αλλάξε.ε α...ν .ο. είναι
+       κά.. α.. .ον δρομέα. **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ην .ρ..η γραμμή .αρακά.. .ημει.μένη με --->.
+
+  2. .ε.ακινεί..ε .ον δρομέα έ..ι ...ε να είναι .άν. ..ο .ρ..ο λάθο..
+
+  3.  α.ή..ε  r  και με.ά .ον .αρακ.ήρα ο ο.οίο. διορθ.νει .ο λάθο..
+
+  4. ..αναλάβε.ε .α βήμα.α 2 και 3 μέ.ρι να είναι ....ή η .ρ..η γραμμή.
+
+--->  Whan this lime was tuoed in, someone presswd some wrojg keys!
+--->  When this line was typed in, someone pressed some wrong keys!
+
+  5. Τ.ρα .ηγαίνε.ε ..ο .άθημα 3.2.
+
+Σ....ΩΣ.: Να θ.μά..ε ..ι .ρέ.ει να μαθαίνε.ε με .η .ρή.η, και ..ι με
+	  .ην α.ομνημ.νε..η.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			  .άθημα 3.3: . .ΝΤ... ......Σ
+
+	   ** .ια να αλλάξε.ε .μήμα ή .λη .η λέξη, .α.ή..ε  cw  . **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ην .ρ..η γραμμή .αρακά.. .ημει.μένη με --->.
+
+  2. Το.οθε.ή..ε .ον δρομέα .άν. ..ο u .η. λέξη. lubw.
+
+  3.  α.ή..ε  cw  και .η ....ή λέξη (..ην .ερί....η α..ή, γρά..ε  'ine'.)
+
+  4.  α.ή..ε <ESC> και .ηγαίνε.ε ..ο ε..μενο λάθο. (..ον .ρ..ο
+     .αρακ.ήρα .ρο. αλλαγή).
+
+  5. ..αναλάβε.ε .α βήμα.α 3 και 4 μέ.ρι. ..ο. η .ρ..η .ρ..α.η να είναι
+     ίδια με .η δεύ.ερη.
+
+---> This lubw has a few wptfd that mrrf changing usf the change command.
+---> This line has a few words that need changing using the change command.
+
+ αρα.ηρεί..ε ..ι η  cw  ..ι μ.νο αν.ικαθι..άει .η λέξη, αλλά .α. ει.άγει
+ε.ί.η. .ε .αρεμβολή.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     .άθημα 3.4:  .Ρ.ΣΣ.Τ.Ρ.Σ ......Σ .. c
+
+
+  ** . εν.ολή αλλαγή. .ρη.ιμο.οιεί.αι με .α ίδια αν.ικείμενα .η. διαγρα.ή.. **
+
+
+  1. . εν.ολή αλλαγή. δο.λεύει με .ον ίδιο .ρ..ο .... η διαγρα.ή. . μορ.ή είναι:
+
+       [αριθμ..]   c   αν.ικείμενο     .     c   [αριθμ..]   αν.ικείμενο
+
+  2. Τα αν.ικείμενα είναι .άλι .α ίδια, .... w (λέξη), $ (.έλο. γραμμή.), κ.λ.
+
+  3. .ε.ακινηθεί.ε ..ην .ρ..η γραμμή .αρακά.. .ημει.μένη με --->.
+
+  4. .ε.ακινεί..ε .ον δρομέα ..ο .ρ..ο λάθο..
+
+  5. .ρά..ε  c$  για να κάνε.ε .ο ...λοι.ο .η. γραμμή. ίδιο με .η δεύ.ερη
+     και .α.ή..ε <ESC>.
+
+---> The end of this line needs some help to make it like the second.
+---> The end of this line needs to be corrected using the  c$  command.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			       ...... 3  .Ρ...Ψ.
+
+
+  1. .ια να .ο.οθε.ή.ε.ε κείμενο .ο. μ.λι. έ.ει διαγρα.εί, .α.ή..ε  p .
+     .... .ο.οθε.εί .ο διαγραμμένο κείμενο ..Τ. .ον δρομέα (αν διαγρά..ηκε
+     γραμμή θα .άει με.ά ..η γραμμή κά.. α.. .ον δρομέα.
+
+  2. .ια να αν.ικα.α..ή.ε.ε .ον .αρακ.ήρα κά.. α.. .ον δρομέα, .α.ή..ε  r
+     και με.ά .ον .αρακ.ήρα .ο. θα αν.ικα.α..ή.ει .ον αρ.ικ..
+
+  3. . εν.ολή αλλαγή. .α. ε.ι.ρέ.ει να αλλάξε.ε .ο καθορι.μένο αν.ικείμενο
+     α.. .ον δρομέα μέ.ρι .ο .έλο. .ο. αν.ικείμενο.  ... γρά..ε  cw  για να
+     αλλάξε.ε α.. .ον δρομέα μέ.ρι .ο .έλο. .η. λέξη., c$ για να αλλάξε.ε
+     μέ.ρι .ο .έλο. γραμμή..
+
+  4. . μορ.ή για .ην αλλαγή είναι:
+
+	 [αριθμ..]   c   αν.ικείμενο     .     c   [αριθμ..]   αν.ικείμενο
+
+Τ.ρα ..νε.ί..ε με .ο ε..μενο μάθημα.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     .άθημα 4.1: ..Σ. ... ..Τ.ΣΤ.Σ. .ΡΧ...Υ
+
+
+ **  α.ή..ε CTRL-g για να εμ.ανι..εί η θέ.η .α. ..ο αρ.είο και η κα.ά..α.ή .ο..
+     α.ή..ε SHIFT-G για να .ά.ε .ε μία γραμμή ..ο αρ.είο. **
+
+  Σημεί..η: .ιαβά..ε ολ.κληρο .ο μάθημα .ριν εκ.ελέ.ε.ε κά.οιο α.. .α βήμα.α!!
+
+  1. .ρα.ή..ε .α.ημένο .ο .λήκ.ρο Ctrl και .α.ή..ε  g . .ία γραμμή κα.ά..α.η.
+     θα εμ.ανι..εί ..ο κά.. μέρο. .η. .ελίδα. με .ο .νομα αρ.είο. και .η
+     γραμμή .ο. εί..ε. ..μηθεί.ε .ον αριθμ. γραμμή. για .ο .ήμα 3.
+
+  2.  α.ή..ε shift-G για να με.ακινηθεί.ε ..ο .έλο. .ο. αρ.είο..
+
+  3.  α.ή..ε .ον αριθμ. .η. γραμμή. .ο. ή.α..αν και με.ά shift-G. .... θα
+     .α. ε.ι..ρέ.ει ..η γραμμή .ο. ή.α..αν .ριν .α.ή.ε.ε για .ρ..η .ορά Ctrl-g.
+     (..αν .ληκ.ρολογεί.ε .ο.. αριθμού., ..Ν θα εμ.ανίζον.αι ..ην οθ.νη).
+
+  4. .ν νοι.θε.ε .ίγο.ρο. για α..., εκ.ελέ..ε .α βήμα.α 1 έ.. 3.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			.άθημα 4.2: . .ΝΤ... .Ν...Τ.Σ.Σ
+
+
+	  **  α.ή..ε   /   ακολο.θούμενο α.. .η .ρά.η .ο. .ά.νε.ε. **
+
+  1. Σε .ανονική .α.ά..α.η .α.ή..ε .ον .αρακ.ήρα  / .  αρα.ηρή..ε ..ι α.... και
+     ο δρομέα. εμ.ανίζον.αι ..ο κά.. μέρο. .η. οθ.νη. .... με .ην εν.ολή  : .
+
+  2. Τ.ρα γρά..ε 'errroor' <ENTER>. ...ή είναι η λέξη .ο. θέλε.ε να .άξε.ε.
+
+  3. .ια να .άξε.ε ξανά για .ην ίδια .ρά.η, .α.ή..ε α.λ..  n .
+     .ια να .άξε.ε .ην ίδια .ρά.η ..ην αν.ίθε.η κα.εύθ.ν.η, .α.ή..ε  Shift-N .
+
+  4. .ν θέλε.ε να .άξε.ε για μία .ρά.η .ρο. .α .ί.., .ρη.ιμο.οιή..ε .ην εν.ολή  ?  αν.ί .η.  / .
+
+---> ..αν η αναζή.η.η ..ά.ει ..ο .έλο. .ο. αρ.είο. θα ..νε.ί.ει α.. .ην αρ.ή.
+
+  "errroor" is not the way to spell error;  errroor is an error.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   .άθημα 4.3: .ΥΡ.Σ. Τ..Ρ..ΣΤΩΝ  .Ρ.Ν..Σ.ΩΝ
+
+
+	  **  α.ή..ε   %   για να βρεί.ε .ην αν.ί..οι.η ), ], ή } . **
+
+  1. Το.οθε.ή..ε .ον δρομέα .ε κά.οια (, [, ή { ..ην .αρακά.. γραμμή
+     .ημει.μένη με --->.
+
+  2. Τ.ρα .α.ή..ε .ον .αρακ.ήρα  % .
+
+  3. . δρομέα. θα .ρέ.ει να είναι ..ην αν.ί..οι.η .αρένθε.η ή αγκύλη.
+
+  4.  α.ή..ε  %  για να με.ακινή.ε.ε .ον δρομέα .ί.. ..ην .ρ..η αγκύλη
+    (.ο. ζε.γαριού).
+
+---> This ( is a test line with ('s, ['s ] and {'s } in it. ))
+
+Σ....ΩΣ.: .... είναι .ολύ .ρή.ιμο ..ην α.ο..αλμά...η εν.. .ρογράμμα.ο.
+	  με μη .αιρια..έ. .αρενθέ.ει.!
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    .άθημα 4.4: .Ν.Σ ΤΡ. .Σ ... ...... ...ΩΝ
+
+
+       ** .ρά..ε  :s/old/new/g  για να αλλάξε.ε .ο 'new' με .ο 'old'. **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ην .αρακά.. γραμμή .ημει.μένη με --->.
+
+  2. .ρά..ε  :s/thee/the <ENTER> . Σημει...ε ..ι α..ή η εν.ολή αλλάζει μ.νο
+     .ην .ρ..η εμ.άνι.η ..η γραμμή.
+
+  3. Τ.ρα γρά..ε   :s/thee/the/g    εννο.ν.α. γενική αν.ικα.ά..α.η ..η
+     γραμμή. .... αλλάζει .λε. .ι. εμ.ανί.ει. ε.ί .η. γραμμή..
+
+---> thee best time to see thee flowers is in thee spring.
+
+  4. .ια να αλλάξε.ε κάθε εμ.άνι.η μία. ..μβολο.ειρά. με.αξύ δύο γραμμ.ν,
+     γρά..ε   :#,#s/old/new/g   ..ο. #,# οι αριθμοί ..ν δύο γραμμ.ν.
+     .ρά..ε   :%s/old/new/g     για να αλλάξε.ε κάθε εμ.άνι.η .ε .λο .ο αρ.είο.
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			       ...... 4  .Ρ...Ψ.
+
+
+  1. Το  Ctrl-g  εμ.ανίζει .η θέ.η .α. ..ο αρ.είο και .ην κα.ά..α.ή .ο..
+     Το  Shift-G  .ηγαίνει ..ο .έλο. .ο. αρ.είο.. .να. αριθμ.. γραμμή.
+     ακολο.θούμενο. α..  Shift-G  .ηγαίνει .ε εκείνη .η γραμμή.
+
+  2. .ρά.ον.α.  /  ακολο.θούμενο α.. μία .ρά.η .ά.νει .ρο. .α . Ρ.ΣΤ. για
+     .η .ρά.η. .ρά.ον.α.  ?  ακολο.θούμενο α.. μία .ρά.η .ά.νει .ρο. .α  .ΣΩ
+     για .η .ρά.η. .ε.ά α.. μία αναζή.η.η .α.ή..ε  n  για να βρεί.ε .ην
+     ε..μενη εμ.άνι.η .ρο. .ην ίδια κα.εύθ.ν.η ή  Shift-N  για να .άξε.ε
+     .ρο. .ην αν.ίθε.η κα.εύθ.ν.η.
+
+  3.  α..ν.α.  %  ..ο ο δρομέα. είναι .άν. .ε μία (,),[,],{, ή }  εν.ο.ίζει
+     .ο αν.ί..οι.ο .αίρι .ο. ζε.γαριού.
+
+  4. .ια αν.ικα.ά..α.η με new .ο. .ρ..ο. old ..η γραμμή γρά..ε  :s/old/new
+     .ια αν.ικα.ά..α.η με new .λ.ν ..ν 'old' ..η γραμμή γρά..ε  :s/old/new/g
+     .ια αν.ικα.ά..α.η .ρά.ε.ν με.αξύ δύο # γραμμ.ν γρά..ε      :#,#s/old/new/g
+     .ια αν.ικα.ά..α.η .λ.ν ..ν εμ.ανί.ε.ν ..ο αρ.είο γρά..ε    :%s/old/new/g
+     .ια ερ..η.η ε.ιβεβαί..η. κάθε .ορά .ρο.θέ..ε ένα 'c'       "%s/old/new/gc
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  .άθημα 5.1:  ΩΣ ..Τ..Ω ... ..ΩΤ.Ρ... .ΝΤ...
+
+
+** .ρά..ε  :!  ακολο.θούμενο α.. μία εξ..ερική εν.ολή για να .ην εκ.ελέ.ε.ε. **
+
+  1.  α.ή..ε .ην οικεία εν.ολή  :  για να θέ.ε.ε .ον δρομέα ..ο κά.. μέρο.
+     .η. οθ.νη.. .... .α. ε.ι.ρέ.ει να δ..ε.ε μία εν.ολή.
+
+  2. Τ.ρα .α.ή..ε  .ο  !  (θα.μα..ικ.). .... .α. ε.ι.ρέ.ει να εκ.ελέ.ε.ε
+     ο.οιαδή.ο.ε εξ..ερική εν.ολή .ο. .λοιού.
+
+  3. Σαν .αράδειγμα γρά..ε  ls  με.ά α.. .ο ! και .α.ή..ε <ENTER>. .... θα
+     .α. εμ.ανί.ει μία λί..α .ο. κα.αλ.γο. .α., ακριβ.. .αν να ή.α..αν ..ην
+     .ρο.ρο.ή .ο. .λοιού. . .ρη.ιμο.οιή..ε  :!dir  αν .ο ls δεν δο.λεύει.
+
+---> Σημεί..η: .ίναι δ.να..ν να εκ.ελέ.ε.ε ο.οιαδή.ο.ε εξ..ερική εν.ολή
+     με α...ν .ον .ρ..ο.
+
+---> Σημεί..η: .λε. οι εν.ολέ.  :  .ρέ.ει να .ερμα.ίζον.αι .α..ν.α. .ο <ENTER>.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		 .άθημα 5.2:  .Ρ.ΣΣ.Τ.Ρ.  .Ρ. ...Ρ.Φ.Σ .ΡΧ..ΩΝ
+
+
+   ** .ια να ...ε.ε .ι. αλλάγε. .ο. κάνα.ε ..ο αρ.είο, γρά..ε  :w .ΡΧ....  **
+
+  1. .ρά..ε  :!dir  ή  :!ls  για να .άρε.ε μία λί..α .ο. κα.αλ.γο. .α..
+     .δη ξέρε.ε ..ι .ρέ.ει να .α.ή.ε.ε <ENTER> με.ά α.. α....
+
+  2. .ιαλέξ.ε ένα .νομα αρ.είο. .ο. δεν ..άρ.ει ακ.μα, .... .ο TEST.
+
+  3. Τ.ρα γρά..ε:  :w TEST  (..ο. TEST είναι .ο .νομα αρ.είο. .ο. διαλέξα.ε).
+
+  4. .... ..ζει .λο .ο αρ.είο (vim Tutor) με .ο .νομα TEST. .ια να .ο
+     ε.αληθεύ.ε.ε, γρά..ε ξανά  :!dir για να δεί.ε .ον κα.άλογ. .α..
+
+---> Σημει...ε ..ι αν βγαίνα.ε α.. .ον Vim και μ.αίνα.ε ξανά με .ο .νομα
+     αρ.είο. TEST, .ο αρ.είο θα ή.αν ακριβέ. αν.ίγρα.ο .ο. tutor ..αν .ο ...α.ε.
+
+  5. Τ.ρα διαγρά..ε .ο αρ.είο γρά.ον.α. (MS-DOS):      :!del TEST
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     .άθημα 5.3: . ....Τ... .ΝΤ... ...Ρ.Φ.Σ
+
+
+	  ** .ια να ...ε.ε .μήμα .ο. αρ.είο., γρά..ε  :#,# w .ΡΧ... **
+
+  1. .λλη μια .ορά, γρά..ε  :!dir  ή  :!ls  για να .άρε.ε μία λί..α α.. .ον
+     κα.άλογ. .α. και διαλέξ.ε ένα κα.άλληλο .νομα αρ.είο. .... .ο TEST.
+
+  2. .ε.ακινεί..ε .ον δρομέα ..ο .άν. μέρο. α..ή. .η. .ελίδα. και .α.ή..ε
+     Ctrl-g  για να βρεί.ε .ον αριθμ. α..ή. .η. γραμμή..
+     Ν. .Υ..ΣΤ. .ΥΤ.Ν Τ.Ν .Ρ....!
+
+  3. Τ.ρα .ηγαίνε.ε ..ο κά.. μέρο. .η. .ελίδα. και .α.ή..ε  Ctrl-g  ξανά.
+     Ν. .Υ..ΣΤ. ... .ΥΤ.Ν Τ.Ν .Ρ....!
+
+  4. .ια να ...ε.ε ..Ν. ένα .μήμα .ε αρ.είο, γρά..ε   :#,# w TEST
+     ..ο. #,# οι δύο αριθμοί .ο. α.ομνημονεύ.α.ε (.άν.,κά..) και TEST .ο
+     .νομα .ο. αρ.είο. .α..
+
+  5. .ανά, δεί.ε ..ι .ο αρ.είο είναι εκεί με .ην  :!dir αλλά ..Ν .ο διαγρά.ε.ε.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  .άθημα 5.4: .Ν..ΤΩΝΤ.Σ ... .ΝΩΝ.ΝΤ.Σ .ΡΧ...
+
+
+     ** .ια να ει.άγε.ε .α .εριε..μενα εν.. αρ.είο., γρά..ε   :r .ΡΧ... **
+
+  1. .ρά..ε  :!dir  για να βεβαι.θεί.ε ..ι .ο TEST ..άρ.ει α.. .ριν.
+
+  2. Το.οθε.ή..ε .ον δρομέα ..ο .άν. μέρο. .η. .ελίδα..
+
+Σ....ΩΣ.:  ....ο. εκ.ελέ.ε.ε .ο .ήμα 3 θα δεί.ε .ο .άθημα 5.3.
+	   .ε.ά κινηθεί.ε ..ΤΩ ξανά .ρο. .ο μάθημα α....
+
+  3. Τ.ρα ανακ.ή..ε .ο αρ.είο .α. TEST .ρη.ιμο.οι.ν.α. .ην εν.ολή  :r TEST
+     ..ο. TEST είναι .ο .νομα .ο. αρ.είο..
+
+Σ....ΩΣ.:  Το αρ.είο .ο. ανακ.ά.ε .ο.οθε.εί.αι ξεκιν.ν.α. εκεί .ο. βρί.κε.αι
+	   ο δρομέα..
+
+  4. .ια να ε.αληθεύ.ε.ε ..ι .ο αρ.είο ανακ.ήθηκε, .ί.. .ον δρομέα και
+     .αρα.ηρή..ε ..ι ..άρ.ο.ν ..ρα δύο αν.ίγρα.α .ο. .αθήμα.ο. 5.3, .ο
+     αρ.ικ. και η έκδο.η .ο. αρ.είο..
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			       ...... 5  .Ρ...Ψ.
+
+
+  1.  :!εν.ολή  εκ.ελεί μία εξ..ερική εν.ολή.
+
+      .ερικά .ρή.ιμα .αραδείγμα.α είναι (MS-DOS):
+      :!dir            - εμ.άνι.η λί..α. εν.. κα.αλ.γο..
+      :!del .ΡΧ...     - διαγρά.ει .ο .ΡΧ....
+
+  2.  :w .ΡΧ...   γρά.ει .ο .ρέ..ν αρ.είο .ο. Vim ..ο δί.κο με .νομα .ΡΧ....
+
+  3.  :#,#w .ΡΧ...   ..ζει .ι. γραμμέ. α.. # μέ.ρι # ..ο .ΡΧ....
+
+  4.  :r .ΡΧ...  ανακ.εί .ο αρ.είο δί.κο. .ΡΧ... και .ο .αρεμβάλλει μέ.α
+      ..ο .ρέ.ον αρ.είο με.ά α.. .η θέ.η .ο. δρομέα.
+
+
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			.άθημα 6.1: . .ΝΤ... .Ν.....Τ.Σ
+
+
+      **  α.ή..ε  o  για να ανοίξε.ε μία γραμμή κά.. α.. .ον δρομέα και να
+	 βρεθεί.ε .ε .α.ά..α.η .ειμένο.. **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ην .αρακά.. γραμμή .ημει.μένη με --->.
+
+  2.  α.ή..ε  o (.εζ.) για να ανοίξε.ε μία γραμμή ..ΤΩ α.. .ον δρομέα και να
+     βρεθεί.ε .ε .α.ά..α.η .ειμένο..
+
+  3. Τ.ρα αν.ιγρά..ε .η .ημει.μένη με ---> γραμμή  και .α.ή..ε <ESC> για να
+     βγεί.ε α.. .ην .α.ά..α.η .ειμένο..
+
+---> After typing  o  the cursor is placed on the open line in Insert mode.
+
+  4. .ια να ανοίξε.ε μία γραμμή  .ΝΩ α.. .ον δρομέα, .α.ή..ε α.λά ένα κε.αλαίο
+     O, αν.ί για ένα .εζ.  o.  .οκιμά..ε .ο ..ην .αρακά.. γραμμή.
+.νοίγε.ε γραμμή .άν. α.. α..ήν .α..ν.α. Shift-O ..ο ο δρομέα. είναι ..η γραμμή
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 .άθημα 6.2: . .ΝΤ...  Ρ.Σ....Σ
+
+	  **  α.ή..ε   a   για να ει.άγε.ε κείμενο ..Τ. .ον δρομέα. **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ο .έλο. .η. .ρ..η. γραμμή. .αρακά..
+     .ημει.μένη με ---> .α..ν.α.  $  ..ην .ανονική .α.ά..α.η.
+
+  2.  α.ή..ε ένα  a  (.εζ.) για να .ρο.θέ.ε.ε κείμενο ..Τ. α.. .ον .αρακ.ήρα
+     .ο. είναι κά.. α.. .ον δρομέα.  (Το κε.αλαίο  A  .ρο.θέ.ει ..ο .έλο.
+     .η. γραμμή.).
+
+Σημεί..η: .... α.ο.εύγει .ο .ά.ημα .ο.  i , .ον .ελε..αίο .αρακ.ήρα, .ο
+	  κείμενο .η. ει.αγ.γή., <ESC>, δρομέα-δεξιά, και .έλο., x, μ.νο και
+	  μ.νο για να .ρο.θέ.ε.ε ..ο .έλο. .η. γραμμή.!
+
+  3. Σ.μ.ληρ...ε ..ρα .ην .ρ..η γραμμή. Σημει...ε ε.ί.η. ..ι η .ρο.θήκη είναι
+     ακριβ.. ίδια ..ην .α.ά..α.η .ειμένο. με .ην .α.ά..α.η .ι.αγ.γή., εκ...
+     α.. .η θέ.η .ο. ει.άγε.αι .ο κείμενο.
+
+---> This line will allow you to practice
+---> This line will allow you to practice appending text to the end of a line.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   .άθημα 6.3: .... ....Σ. Τ.Σ .ΝΤ...Τ.ΣΤ.Σ.Σ
+
+
+ **  α.ή..ε κε.αλαίο  R  για να αλλάξε.ε .ερι....ερο.. α.. έναν .αρακ.ήρε.. **
+
+  1. .ε.ακινεί..ε .ον δρομέα ..ην .ρ..η γραμμή .αρακά.. .ημει.μένη με --->.
+
+  2. Το.οθε.ή..ε .ον δρομέα ..ην αρ.ή .η. .ρ..η. λέξη. .ο. είναι δια.ορε.ική
+     α.. .η δεύ.ερη γραμμή .ημει.μένη με ---> (η λέξη 'last').
+
+  3.  α.ή..ε ..ρα  R   και αλλάξ.ε .ο ...λοι.ο .ο. κειμένο. ..ην .ρ..η γραμμή
+     γρά.ον.α. .άν. α.. .ο .αλι. κείμενο ...ε να κάνε.ε .ην .ρ..η γραμμή ίδια
+     με .η δεύ.ερη.
+
+---> To make the first line the same as the last on this page use the keys.
+---> To make the first line the same as the second, type R and the new text.
+
+  4. Σημει...ε ..ι ..αν .α.ά.ε <ESC> για να βγεί.ε, .αραμένει ο.οιοδή.ο.ε
+     αναλλοί..ο κείμενο.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			  .άθημα 6.4: ΡΥ...Σ. . .....Σ
+
+
+   ** Ρ.θμί..ε μία ε.ιλογή έ..ι ...ε η αναζή.η.η ή η αν.ικα.ά..α.η να αγνοεί
+      .η δια.ορά .εζ.ν-κε.αλαί.ν **
+
+  1. Ψάξ.ε για 'ignore' ει.άγον.α.:
+     /ignore
+     Σ.νε.ί..ε αρκε.έ. .ορέ. .α..ν.α. .ο .λήκ.ρο n.
+
+  2. .έ..ε .ην ε.ιλογή 'ic' (Ignore case) γρά.ον.α.:
+     :set ic
+
+  3. Ψάξ.ε ..ρα ξανά για 'ignore' .α..ν.α.: n
+     Σ.νε.ί..ε .ην αναζή.η.η μερικέ. ακ.μα .ορέ. .α..ν.α. .ο .λήκ.ρο n
+
+  4. .έ..ε .ι. ε.ιλογέ. 'hlsearch' και 'incsearch':
+     :set hls is
+
+  5. .ι.άγε.ε ..ρα ξανά .ην εν.ολή αναζή.η.η., και δεί.ε .ι ..μβαίνει
+     /ignore
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			       ...... 6  .Ρ...Ψ.
+
+
+  1.  α..ν.α.  o  ανοίγει μία γραμμή ..ΤΩ α.. .ον δρομέα και .ο.οθε.εί .ον
+     δρομέα ..ην ανοι..ή γραμμή .ε .α.ά..α.η .ειμένο..
+
+  2.  α.ή..ε  a  για να ει.άγε.ε κείμενο ..Τ. .ον .αρακ.ήρα ..ον ο.οίο είναι
+     ο δρομέα..  α..ν.α. κε.αλαίο  A  α...μα.α .ρο.θέ.ει κείμενο ..ο .έλο.
+     .η. γραμμή..
+
+  3.  α..ν.α. κε.αλαίο  R  ει.έρ.ε.αι ..ην .α.ά..αη .ν.ικα.ά..α.η. μέ.ρι να
+     .α.ηθεί .ο <ESC> και να εξέλθει.
+
+  4. .ρά.ον.α. ":set xxx" ρ.θμίζει .ην ε.ιλογή "xxx".
+
+
+
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       ...... 7: ON-LINE .ΝΤ...Σ .......Σ
+
+
+		** Χρη.ιμο.οιή..ε .ο on-line .ύ..ημα βοήθεια. **
+
+  . Vim έ.ει ένα .εριεκ.ικ. on-line .ύ..ημα βοήθεια.. .ια να ξεκινή.ει,
+  δοκιμά..ε κά.οιο α.. .α .ρία:
+	- .α.ή..ε .ο .λήκ.ρο <HELP> (αν έ.ε.ε κά.οιο)
+	- .α.ή..ε .ο .λήκ.ρο <F1> (αν έ.ε.ε κά.οιο)
+	- γρά..ε   :help <ENTER>
+
+  .ρά..ε  :q <ENTER>   για να κλεί.ε.ε .ο .αράθ.ρο .η. βοήθεια..
+
+  ..ορεί.ε να βρεί.ε βοήθεια .άν. .ε κάθε αν.ικείμενο, δίνον.α. μία .αράμε.ρο
+  ..ην εν.ολή ":help".  .οκιμά..ε α..ά (μην ξε.νά.ε να .α.ά.ε <ENTER>):
+
+	:help w
+	:help c_<T
+	:help insert-index
+	:help user-manual
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  ...... 8: .....ΥΡ..ΣΤ. .Ν. SCRIPT ....Ν.Σ.Σ
+
+		   ** .νεργο.οιή..ε .αρακ.ηρι..ικά .ο. Vim **
+
+  . Vim έ.ει .ολλά .ερι....ερα .αρακ.ηρι..ικά α.' .,.ι ο Vi, αλλά .α
+  .ερι....ερα είναι αρ.ικά α.ενεργο.οιημένα. .ια να αρ.ί.ε.ε να .ρη.ιμο.οιεί.ε
+  .ερι....ερα .αρακ.ηρι..ικά .ρέ.ει να ..ιάξε.ε ένα αρ.είο "vimrc".
+
+  1. .ρ.ί..ε διορθ.νον.α. .ο αρ.είο "vimrc", α... εξαρ.ά.αι α.. .ο .ύ..ημά .α.:
+	:edit ~/.vimrc               για Unix
+	:edit $VIM/_vimrc            για MS-Windows
+
+  2. Τ.ρα ει.άγε.ε .ο κείμενο .αραδείγμα.ο. για αρ.είο "vimrc":
+	:read $VIMRUNTIME/vimrc_example.vim
+
+  3. .ρά..ε .ο αρ.είο με .ην:
+	:write
+
+  Την ε..μενη .ορά .ο. θα ξεκινή.ε.ε .ον Vim θα .ρη.ιμο.οιή.ει ...ι.μ.
+  .ύν.αξη..  ..ορεί.ε να .ρο.θέ.ε.ε .λε. .ι. .ρο.ιμ.μενε. ε.ιλογέ. .' α...
+  .ο αρ.είο "vimrc".
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+  .δ. ολοκληρ.νε.αι .ο Vim Tutor. Σκο... .ο. ή.αν να δ..ει μία .ύν.ομη
+  .ερίλη.η .ο. ..ν.άκ.η Vim, .ο.λά.ι..ον ...η ...ε να .α. ε.ι.ρέ.ει να
+  .ρη.ιμο.οιή.ε.ε .ον ..ν.άκ.η αρκε.ά εύκολα. ..έ.ει .ολύ α.. μία
+  ολοκληρ.μένη .αρο..ία.η καθ.. ο Vim έ.ει .άρα .ολλέ. εν.ολέ.. .ιαβά..ε
+  κα...ιν .ο εγ.ειρίδιο .ρή.η.:
+	":help user-manual".
+
+  .ια .εραι.έρ. διάβα.μα και μελέ.η, ....ήνε.αι α... .ο βιβλίο:
+	Vim - Vi Improved - by Steve Oualline
+	Publisher: New Riders
+	Το .ρ..ο βιβλίο .λήρ.. α.ιερ.μένο ..ον Vim.
+	.διαί.ερα .ρή.ιμο για αρ.άριο...
+	Υ.άρ.ο.ν .ολλά .αραδείγμα.α και εικ.νε..
+	.εί.ε .ην http://iccf-holland.org/click5.html
+
+  .... .ο βιβλίο είναι .αλι..ερο και .ερι....ερο για .ον Vi .αρά για .ον Vim,
+  αλλά ε.ί.η. ..νι...μενο:
+	Learning the Vi Editor - by Linda Lamb
+	Publisher: O'Reilly & Associates Inc.
+	.ίναι ένα καλ. βιβλίο για να μάθε.ε ..εδ.ν .α .άν.α .ο. θέλε.ε
+	να κάνε.ε με .ον Vi.
+	. έκ.η έκδο.η .εριέ.ει ακ.μα .ληρο.ορίε. για .ον Vim.
+
+  ...ή η .εριήγη.η γρά..ηκε α.. .ο.. Michael C. Pierce και Robert K. Ware,
+  Colorado School of Mines .ρη.ιμο.οι.ν.α. ιδέε. α.. .ον Charles Smith,
+  Colorado State University.  E-mail: bware@mines.colorado.edu.
+
+   ρο.αρμογή για .ον Vim α.. .ον Bram Moolenaar.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim70.orig/runtime/tutor/tutor.ru.utf-8 vim70/runtime/tutor/tutor.ru.utf-8
--- vim70.orig/runtime/tutor/tutor.ru.utf-8	1969-12-31 16:00:00.000000000 -0800
+++ vim70/runtime/tutor/tutor.ru.utf-8	2006-09-11 08:57:09.000000000 -0700
@@ -0,0 +1,834 @@
+===============================================================================
+=    . о б . о   п о ж а л о в а . .   в   . . е б н и к   VIM  -  .е.сия 1.5 =
+===============================================================================
+     Vim --- э.о о.ен. мо.н.й .едак.о., име..ий множес.во команд, сли.ком
+     много для .ого, ..об. и. все можно б.ло описа.. в .аком ..ебнике, как
+     э.о.. Э.о. ..ебник п.изван об.ясни.. дос.а.о.ное .исло команд для .ого,
+     ..об. .. могли с легкос... испол.зова.. Vim в ка.ес.ве .едак.о.а об.его
+     назна.ения.
+
+     .ам по..еб.е.ся п.иблизи.ел.но 25-30 мин.. на освоение данного ..ебника в
+     зависимос.и о. .ого, скол.ко в.емени .. по..а.и.е на экспе.имен...
+
+     .оманд. в ..ока. б.д.. моди.и.и.ова.. .екс.. Создай.е копи. э.ого .айла,
+     ..об. поп.ак.икова..ся на ней (если .. зап.с.или "vimtutor", .о э.о .же
+     копия).
+
+     .ажно помни.., ..о э.о. ..ебник п.едназна.ен для об..ения в п.о.ессе
+     испол.зования. Э.о озна.ае., ..о .. должн. зап.ска.. команд. для .ого,
+     ..об. как след.е. и. из..и... .сли .. п.ос.о п.о.и.ае.е .екс., .о
+     заб.де.е команд.!
+
+     Тепе.. .беди.ес. в .ом, ..о клави.а CapsLock не вкл..ена и нажми.е
+     клави..   j   нескол.ко .аз, .ак, ..об. У.ок 1.1 полнос... помес.ился на
+     эк.ане.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			У.ок 1.1:  .. ...Щ.Н.. .У С. А
+
+** .ля пе.еме.ения к..со.а нажми.е клави.и h,j,k,l .ак, как показано ниже. **
+	     ^
+	     k		Сове..:	.лави.а h на.оди.ся слева и пе.еме.ае. влево.
+       < h	 l >		.лави.а l на.оди.ся сп.ава и пе.еме.ае. вп.аво.
+	     j			.лави.а j по.ожа на с..елк. `вниз'.
+	     v
+  1. .одвигай.е к..со. по эк.ан., пока не по..вс.в.е.е себя .ве.енно.
+
+  2. Надави.е клави.. `вниз' (j) пока она не на.не. пов.о.я..ся.
+---> Тепе.. .. знае.е, как пе.ей.и к след...ем. ..ок..
+
+  3. .спол.з.я клави.. `вниз' пе.ейди.е к У.ок. 1.2.
+
+.аме.ание: .сли в. пока не .ве.ен. в .ом, ..о наби.ае.е, нажми.е <ESC> для
+	   пе.е.ода в об..н.й .ежим (Normal mode). .осле э.ого пе.енабе.и.е
+	   ..еб.ем.. команд..
+
+.аме.ание: .б..н.е клави.и .п.авления к..со.ом (с..елки) .акже должн.
+	   .або.а... .днако, клави.и hjkl позволя. .ам пе.еме.а..ся
+	   зна.и.ел.но б.с..ее, как .ол.ко .. на..и.ес. ими пол.зова..ся.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  У.ок 1.2: .А.УС. . .А.. Ш.Н..  А..ТЫ С VIM
+
+!! .Н..АН..! ..ежде, .ем в.полня.. л.бой из описанн.. ниже .агов, п.о..и.е
+			       ..ок .еликом !!
+
+  1. Нажми.е клави.. <ESC> (для .ого, ..об. .дос.ове.и..ся, ..о .. в об..ном
+     .ежиме (Normal mode)).
+
+  2. Набе.и.е:			:q! <ENTER>.
+
+---> Э.о позволи. .ам в.й.и из .едак.о.а ... С.Х АН.Н.Я л.б.. сделанн..
+     изменений. .сли .. .о.и.е со..ани.. изменения и в.й.и:
+				:wq  <ENTER>
+
+  3. .огда .. .види.е п.игла.ение командной оболо.ки, набе.и.е команд.,
+     ко.о.ая п.ивела .ас в э.о. ..ебник. Э.о може. б...
+				vimtutor ru <ENTER>
+     .б..но можно испол.зова..:	vim tutor.ru <ENTER>
+
+---> 'vim' позволяе. зап.с.и.. .едак.о. vim, 'tutor.ru' --- э.о .айл, ко.о..й
+     .. б.де.е .едак.и.ова...
+
+  4. .сли .. .ве.ен. в .ом, ..о запомнили э.и .аги, в.полни.е .аги о. 1 до 3
+     ..об. в.й.и снова зап.с.и.. .едак.о.. .а.ем пе.емес.и.е к..со. вниз к
+     У.ок. 1.3.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  У.ок 1.3:  ..А.Т. ..АН.. Т..СТА - У.А..Н..
+
+
+** На.одяс. в об..ном .ежиме нажми.е x, ..об. .дали.. символ под к..со.ом. **
+
+  1. .е.емес.и.е к..со. к с..оке вниз., поме.енной --->.
+
+  2. .ля исп.авления о.ибок, пе.емес.и.е к..со., пока он не окаже.ся над
+     .даляем.м символом.
+
+  3. Нажми.е клави.. x для .даления ..еб.емого символа.
+
+  4. .ов.о.и.е .аги 2--4 пока с..ока не б.де. исп.авлена.
+
+---> .. ...опо.а коп... ппп.л. ппо пппол. ле..и...
+
+  5. Тепе.., когда с..ока о.ко..ек.и.ована, пе.е.оди.е к ..ок. 1.4.
+
+.А..ЧАН..: . .оде освоения э.ого ..ебника не п..ай.ес. запомина.., ..и.е
+	   в п.о.ессе испол.зования.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  У.ок 1.4:  ..А.Т. ..АН.. Т..СТА - .СТА..А
+
+
+ ** На.одяс. в об..ном .ежиме (Normal mode), нажми.е i для вс.авки .екс.а. **
+
+  1. .е.емес.и.е к..со. к пе.вой с..оке вниз., поме.енной --->.
+
+  2. .ля .ого, ..об. сдела.. пе.в.. с..ок. иден.и.ной в.о.ой, помес.и.е
+     к..со. на символ .. .. ко.о..м след.е. вс.ави.. .екс..
+
+  3. Нажми.е i и набе.и.е ..еб.ем.е добавления.
+
+  4. .осле исп.авления все. о.ибок нажми.е <ESC> для возв.а.а в об..н.й .ежим.
+     .ов.о.и.е .аги 2--4, пока ..аза не б.де. исп.авлена полнос....
+
+---> Час.. .екс.а в с..оке беследно .
+---> Час.. .екс.а в э.ой с..оке бесследно п.опала.
+
+  5. .огда освои.е вс.авк. .екс.а, пе.е.оди.е дал..е к  ез.ме.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+				 ..Ю.. У ..А 1
+
+  1. ...со. пе.еме.ае.ся либо клави.ами со с..елками, либо клави.ами hjkl.
+	 h (влево)	j (вниз)       k (вве..)	    l (вп.аво)
+
+  2. .ля зап.ска Vim (из п.игла.ения % командной оболо.ки) набе.и.е:
+     vim ..Я_ФА..А <ENTER>
+
+  3. .ля заве..ения .або.. с Vim набе.и.е:
+     <ESC>   :q!	 <ENTER>  ..об. о.каза..ся о. со..анения изменений.
+     .ли набе.и.е:
+     <ESC>   :wq	 <ENTER>  ..об. со..ани.. изменения.
+
+  4. .ля .даления символа под к..со.ом в об..ном .ежиме, набе.и.е: x
+
+  5. Ч.об. вс.ави.. .екс. пе.ед к..со.ом в об..ном .ежиме, набе.и.е:
+	 i     вводи.е .екс.	<ESC>
+
+.А..ЧАН..: Нажа.ие <ESC> пе.емес.и. .ас в об..н.й .ежим (Normal mode) либо
+	   п.е.ве. нежела.ел.н.. и .ас.и.но заве..енн.. команд..
+
+Тепе.. пе.е.одим к У.ок. 2.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			  У.ок 2.1: ...АН.Ы У.А..Н.Я
+
+
+	** Набе.и.е dw для .даления ..ас.ка .екс.а до кон.а слова. **
+
+  1. Нажми.е <ESC>, ..об. пе.ей.и в об..н.й .ежим.
+
+  2. .е.емес.и.е к..со. вниз, к с..оке, поме.енной --->.
+
+  3. .е.емес.и.е к..со. в на.ало слова, ко.о.ое след.е. .дали...
+
+  4. Набе.и.е  dw , ..об. .дали.. э.о слово.
+
+.А..ЧАН..: .о в.емя набо.а б.кв. dw появя.ся в последней с..оке эк.ана. .сли
+	   .. ..о-.о набе.е.е неп.авил.но, нажми.е <ESC> и на.ни.е сна.ала.
+
+---> Нескол.ко слов .а.инад в э.ом п.едложении ав.ок.ан изли.ни.
+
+  5. .ов.о.и.е .аги 3 и 4, пока не исп.ави.е все о.ибки и пе.е.оди.е к
+     У.ок. 2.2.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  У.ок 2.2: .....Н.Т..ЬНЫ. ...АН.Ы У.А..Н.Я
+
+
+	    ** Набе.и.е d$ для .даления .екс.а до кон.а с..оки. **
+
+  1. Нажми.е <ESC>, ..об. пе.ей.и в об..н.й .ежим.
+
+  2. .е.емес.и.е к..со. вниз, к с..оке, поме.енной --->.
+
+  3. .е.емес.и.е к..со. к кон.. п.авил.ной с..оки (..С.. пе.вой . ).
+
+  4. Ч.об. .дали.. ос.а.ок с..оки, набе.и.е  d$ .
+
+---> ..о-.о наб.ал окон.ание э.ой с..оки дважд.. окон.ание э.ой с..оки дважд..
+
+
+  5.Ч.об. л...е .азоб.а..ся в э.ом, пе.е.оди.е к У.ок. 2.3.
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 У.ок 2.3: ...АН.Ы . ..Ъ..ТЫ
+
+
+  Фо.ма. команд. `.даление' d .аков:
+
+	 [.исло]   d	об.ек.	    ...	     d	 [.исло]   об.ек.
+  .дес.:
+    .исло  - скол.ко .аз исполни.. команд. (необяза.ел.но, по .мол.ани.=1).
+    d      - команда .даления.
+    об.ек. - с .ем команда должна б... в.полнена (пе.е.ислено ниже).
+
+  ..а.кий список об.ек.ов:
+    w - о. к..со.а до кон.а слова, вкл..ая заве..а..ий п.обел.
+    e - о. к..со.а до кон.а слова, Н. вкл..ая заве..а..ий п.обел.
+    $ - о. к..со.а до кон.а с..оки.
+    ^ - о. к..со.а до на.ала с..оки.
+
+.А..ЧАН..: ..ос.ое нажа.ие на символ об.ек.а в об..ном .ежиме (Normal mode)
+	   без дополни.ел.н.. команд пе.едвине. к..со. .ак, как .казано в
+	   списке об.ек.ов.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	       У.ок 2.4: .С..ЮЧ.Н.. .. . А...А `...АН.А-..Ъ..Т'
+
+
+		 ** Набе.и.е dd для .даления всей с..оки. **
+
+  .следс.вие .ас.ого п.именения опе.а.ии .даления всей с..оки, .аз.або..ики
+  Vim .е.или, ..о для э.ого п.о.е всего п.ос.о наб.а.. d дважд..
+
+  1. .е.емес.и.е к..со. вниз, ко в.о.ой с..оке ..аз..
+  2. Набе.и.е dd для .даления с..оки.
+  3. Тепе.. пе.емес.и.ес. к .е.ве..ой с..оке.
+  4. Набе.и.е 2dd (вспомни.е п.авило `.исло-команда-об.ек.'), ..об. .дали..
+     две с..оки.
+
+      1)  .е.ом я .ож. на с.адион,
+      2)  ., как внезапно кон.ился диван!
+      3)  Я боле. за ``.ени.'', ``.ени.'' --- .емпион!
+      4)  .е.ал.но я гляж. на на.е поколение!
+      5)  .го г.яд..ее ил. п.с.о ил. .емно...
+      6)  Я сиж. на скамейке в ложе `.'
+      7)  . иг.а. на бол..ой жес.яной ...бе.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			  У.ок 2.5: ...АН.А `.Т.АТ'
+
+
+  ** Нажми.е u	для о.мен. .ез.л..а.а .або.. п.ед.д..ей команд., U для о.мен.
+			исп.авлений во всей с..оке. **
+
+  1. .е.емес.и.е к..со. вниз, к с..оке, поме.енной ---> и .с.анови.е его на
+     пе.в.. о.ибк..
+  2. Нажми.е x для .даления пе.вого неп.авил.ного символа.
+  3. Тепе.. нажми.е u для о.мен. (о.ка.а) последней в.полненной команд..
+  4. .сп.ав..е все о.ибки в с..оке, испол.з.я команд. x .
+  5. Тепе.. нажми.е заглавн.. U для .ого, ..об. ве.н... вс. с..ок. в ис.одное
+     сос.ояние.
+  6. Нажми.е u нескол.ко .аз для о.мен. команд. U и п.ед.д..и. команд.
+  7. Нажми.е .епе.. CTRL-R (.де.живай.е клави.. CTRL нажа.ой в момен. нажа.ия
+  R)     нескол.ко .аз для возв.а.а команд (о.ка. о.ка.а).
+
+---> .сп..ав..е оо.ибки в э.ойй с..оке и ве.ни..е и. сс помо.... `о.ка.а'.
+
+  8. Э.о б.ли о.ен. полезн.е команд.. .алее пе.е.оди.е к  ез.ме У.ока 2.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+				 ..Ю.. У ..А 2
+
+
+  1. .ля .даления .екс.а о. к..со.а до кон.а слова набе.и.е:    dw
+
+  2. .ля .даления .екс.а о. к..со.а до кон.а с..оки набе.и.е:    d$
+
+  3. .ля .даления всей с..оки набе.и.е:    dd
+
+  4. Фо.ма. команд. в об..ном .ежиме имее. вид:
+
+       [.исло]   команда   об.ек.     ...     команда	[.исло]   об.ек.
+     где:
+       .исло   - скол.ко .аз пов.о.и.. в.полнение команд.
+       команда - ..о в.полни.., нап.име. d для .даления
+       об.ек.  - на ..о должна воздейс.вова.. команда, нап.име. w (слово),
+		$ (до кон.а с..оки), и ..д.
+
+  5. .ля о.мен. (о.ка.а) п.ед.ес.в...и. дейс.вий набе.и.е:  u (с..о.ная u)
+     .ля о.мен. (о.ка.а) все. изменений в с..оке набе.и.е:  U (п.описная U)
+     .ля о.мен. о.ка.а набе.и.е:  CTRL-R
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			  У.ок 3.1: ...АН.А .СТА...
+
+
+   ** Набе.и.е p для вс.авки последнего .даленного .екс.а после к..со.а. **
+
+  1. .е.емес.и.е к..со. вниз к последней с..оке из набо.а.
+
+  2. Набе.и.е dd для .даления с..оки и ее со..анения в б..е.е Vim'а.
+
+  3. .е.емес.и.е к..со. к с..оке НА. .ем мес.ом, к.да след.е. вс.ави..
+     .даленн.. с..ок..
+
+  4. На.одяс. в об..ном .ежиме набе.и.е p для замен. с..оки.
+
+  5. .ов.о.и.е .аги 2--4, пока не .асс.ави.е все с..оки в н.жном по.ядке.
+
+     г) . л...е в.д.ма.. не мог.
+     б) .огда не в ...к. занемог,
+     в) .н .важа.. себя зас.авил
+     а) .ой дядя сам.. .ес.н.. п.авил
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       У.ок 3.2: ...АН.А .А..НЫ
+
+
+	  ** Набе.и.е r и символ, заменя..ий символ под к..со.ом. **
+
+  1. .е.емес.и.е к..со. вниз, к с..оке, поме.енной --->.
+
+  2. Ус.анови.е к..со. .ак, ..об. он на.одился над пе.вой о.ибкой.
+
+  3. Набе.и.е r	и за.ем символ, исп.авля..ий о.ибк..
+
+  4. .ов.о.и.е .аги 2 и 3, пока пе.вая с..ока не б.де. исп.авлена.
+
+--->  . момег. наб..а э.ой ...оки кое0к.о с ...дом попвдал по клваи.ам!
+--->  . момен. набо.а э.ой с..оки кое-к.о с ...дом попадал по клави.ам!
+
+  5. Тепе.. пе.е.оди.е к У.ок. 3.2.
+
+.А..ЧАН..: .омни.е, ..о в. должн. ..и..ся в п.о.ессе .або.., а не п.ос.о
+	   запоминая.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 У.ок 3.3: ...АН.А ....Н.Н.Я
+
+
+		** .ля изменения .ас.и слова набе.и.е cw . **
+
+  1. .е.емес.и.е к..со. вниз, к с..оке, поме.енной --->.
+
+  2.  асположи.е к..со. над б.квой `o' в слове `сола'.
+
+  3. Набе.и.е cw и исп.ав..е слово (в данном сл..ае, набе.и.е `лов'.)
+
+  4. Нажми.е <ESC> и пе.е.оди.е к след...ей о.ибке (к пе.вом. символ., ко.о..й
+     надо измени...)
+
+  5. .ов.о.и.е .аги 3--4 пока пе.вое п.едложение не с.ане. иден.и.н.м в.о.ом..
+
+---> Нескол.ко сола в э.г. с..оке .пг..б. .едалзк..иесв..
+---> Нескол.ко слов в э.ой с..оке ..еб... .едак.и.ования.
+
+.б.а.и.е внимание, ..о cw не .ол.ко заменяе. слово, но и пе.еводи. вас в .ежим
+вс.авки.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		  У.ок 3.4: . .....А.. ....НЯТЬ С ...АН... c
+
+
+** .оманда замен. испол.з.е.ся с .еми же об.ек.ами, ..о и команда .даления. **
+
+  1. .оманда изменения п.именяе.ся .аким же об.азом, как и команда .даления.
+     .е .о.ма. .аков:
+
+       [.исло]   c   об.ек.	   ...	    c	[.исло]   об.ек.
+
+  2. .б.ек.. .акже совпада..: w (слово), $ (коне. с..оки) и ..п.
+
+  3. .е.емес.и.е к..со. вниз, к с..оке, поме.енной --->.
+
+  4. .е.ейди.е к пе.вой о.ибке.
+
+  5. Набе.и.е c$ и о..едак.и..й.е пе.в.. с..ок. .ак, ..об. она совпадала со
+     в.о.ой, после .его нажми.е <ESC>.
+
+---> .оне. э.ой с..оки н.ждае.ся в помо.и, ..об. с.а.. по.ожим на в.о.ой.
+---> .оне. э.ой с..оки н.ждае.ся в помо.и команд. c$ .
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+				 ..Ю.. У ..А 3
+
+
+  1. .ля вс.авки .екс.а, ко.о..й .ол.ко ..о б.л .дален, набе.и.е p . Э.а
+     команда вс.ави. .даленн.й .екс. ..С.. к..со.а (если б.ла .далена с..ока,
+     .о она б.де. поме.ена в с..оке под к..со.ом).
+
+  2. .ля замен. символа под к..со.ом набе.и.е r и за.ем заменя..ий символ.
+
+  3. .оманда изменения позволяе. .ам измени.. .казанн.й об.ек. о. к..со.а до
+     кон.а э.ого об.ек.а. Нап.име., набе.и.е cw для замен. о. к..со.а до
+     кон.а слова, c$ для изменения до кон.а с..оки.
+
+  4. Фо.ма. команд. изменения .аков:
+
+	 [.исло]   c	об.ек.	      ...	c   [.исло]   об.ек.
+
+Тепе.. о.п.авляй.ес. к след...ем. ..ок..
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	      У.ок 4.1: .НФ. .АЦ.Я . ФА... .  АС......Н.. . Н..
+
+
+ ** Набе.и.е CTRL-g ..об. .виде.. .а.е мес.о.асположение в .айле и ин.о.ма.и.
+				    о нем.
+	Набе.и.е SHIFT-G для пе.еме.ения к заданной с..оке в .айле. **
+
+  .аме.ание: ..о.и.ай.е вес. ..ок п.ежде .ем в.полня.. л.б.е команд.!!
+
+  1. Уде.живая клави.. Ctrl нажми.е g . .низ. эк.ана появи.ся с..ока с.а..са с
+     именем .айла и номе.ом с..оки, в ко.о.ой .. на.оди.ес.. .апомни.е номе.
+     с..оки, он по..еб.е.ся на Шаге 3.
+
+  2. Нажми.е shift-G для пе.еме.ения к кон.. .айла.
+
+  3. Набе.и.е номе. с..оки, в ко.о.ой в. на.одилис. и за.ем shift-G. Э.о
+     ве.не. .ас к с..оке, в ко.о.ой .. б.ли, когда в пе.в.й .аз нажали Ctrl-g.
+     (.огда .. б.де.е наби.а.. .и..., они Н. о.об.азя.ся на эк.ане.)
+
+  4. .сли .. запомнили все в..есказанное, в.полни.е .аги 1--3.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			   У.ок 4.2: ...АН.А ...С.А
+
+	      ** Набе.и.е  /  и за.ем введи.е иском.. ..аз.. **
+
+  1. . об..ном .ежиме (Normal mode) набе.и.е символ  / . .б.а.и.е внимание,
+     ..о он вмес.е с к..со.ом появи.ся вниз. эк.ана, как э.о п.оис.оди. с
+     командой :	.
+
+  2. Тепе.. набе.и.е 'о...ибка' <ENTER>. Э.о .о слово, ко.о.ое .. б.де.е
+     иска...
+
+  3. .ля .ого, ..об. пов.о.и.. поиск, п.ос.о нажми.е n .
+     .ля поиска э.ой ..аз. в об.а.ном нап.авлении, нажми.е Shift-N .
+
+  4. .сли .. желае.е с.аз. иска.. в об.а.ном нап.авлении, испол.з.й.е
+     команд. ? вмес.о / .
+
+---> .огда .. п.и поиске дос.игне.е кон.а .айла, поиск б.де. п.одолжен с
+     на.ала.
+
+  "о...ибка" э.о не способ п.оизнесения слова `о.ибка';  о...ибка э.о о.ибка.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			У.ок 4.3: ...С. .А НЫХ С.....
+
+
+		** Набе.и.е % для поиска па.н.. ),] или } . **
+
+  1. .омес.и.е к..со. над л.бой из (, [ или { в с..оке вниз., поме.енной --->.
+
+  2. Тепе.. набе.и.е символ % .
+
+  3. ...со. должен пе.еско.и.. на па.н.. скобк..
+
+  4. Набе.и.е % для возв.а.а к..со.а назад к пе.вой скобке.
+
+---> Э.о ( с..ока, соде.жа.ая .акие (, .акие [ ] и .акие { } скобки. ))
+
+.аме.ание: Э.о о.ен. .добно п.и о.ладке п.ог.амм с п.оп..енн.ми скобками!
+
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		      У.ок 4.4: С..С.. .С. А...Н.Я .Ш....
+
+
+	 ** Набе.и.е :s/б.ло/с.ало/g для замен. 'б.ло' на 'с.ало'. **
+
+  1. .е.емес.и.е к..со. вниз, к с..оке, поме.енной --->.
+
+  2. Набе.и.е :s/.вод./.вож. <ENTER> . .б.а.и.е внимание на .о, ..о э.а команда
+     замени. .ол.ко пе.вое найденное в.ождение в с..оке.
+
+  3. Тепе.. набе.и.е :s/.вод./.вож./g , озна.а..ее подс.ановк. глобал.но во
+     всей с..оке. Э.о замени. все найденн.е в с..оке в.ождения.
+
+---> Я .вод. к о.ве.женн.м селен.ям, я .вод. сквоз. векове.н.й с.он, я .вод. к
+     заб...м поколен.ям.
+
+  4. .ля замен. все. в.ождений последова.ел.нос.и символов межд. дв.мя
+     с..оками,
+     набе.и.е :#,#s/б.ло/с.ало/g  где #,# --- номе.а э.и. с..ок.
+     Набе.и.е :%s/б.ло/с.ало/g    для замен. все. в.ождений во всем .айле.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+				 ..Ю.. У ..А 4
+  1. Ctrl-g показ.вае. ва.е положение в .айле и ин.о.ма.и. о нем.
+     Shift-G пе.еме.ае. .ас в коне. .айла. Номе., за ко.о..м след.е. Shift-G
+     позволяе. пе.ей.и к с..оке с э.им номе.ом.
+
+  2. Нажа.ие / и за.ем ввод с..оки позволяе. п.оизвес.и поиск э.ой с..оки
+     ... .. по .екс...
+     Нажа.ие ? и за.ем ввод с..оки позволяе. п.оизвес.и поиск э.ой с..оки
+     НА.А. по .екс...
+     .осле поиска набе.и.е n для пе.е.ода к след...ем. в.ождени. искомой
+     с..оки в .ом же нап.авлении или Shift-N для пе.е.ода в п.о.ивоположном
+     нап.авлении.
+
+  3. Нажа.ие % , когда к..со. на.оди.ся на (,),[,],{, или } позволяе. най.и
+     па.н.. скобк..
+
+  4. .ля подс.ановки `с.ало' вмес.о пе.вого `б.ло' в с..оке, набе.и.е
+     :s/old/new
+     .ля подс.ановки `с.ало' вмес.о все. `б.ло' в с..оке, набе.и.е
+     :s/old/new/g
+     .ля замен. в ин.е.вале межд. дв.мя с..оками, набе.и.е
+     :#,#s/old/new/g
+     .ля замен. все. в.ождений `б.ло' на `с.ало' в .айле, набе.и.е
+     :%s/old/new/g
+     Ч.об. .едак.о. кажд.й .аз зап.а.ивал под.ве.ждение, добав..е 'c'
+     :%s/old/new/gc
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		   У.ок 5.1: .А. .Ы...Н.ТЬ .Н.ШНЮЮ ...АН.У
+
+
+    ** Набе.и.е :! и за.ем вне.н.. команд., ко.о... след.е. в.полни... **
+
+  1. Набе.и.е .же знаком.. .ам команд. : для .с.ановки к..со.а в командн..
+     с..ок. .едак.о.а. Э.о позволи. .ам ввес.и команд..
+
+  2. Тепе.. набе.и.е символ ! (воскли.а.ел.н.й знак). Тепе.. можно исполни..
+     вне.н.. команд., испол.з.я командн.. оболо.к..
+
+  3. .ля п.име.а набе.и.е ls после ! и нажми.е <ENTER>. Э.а команда в.веде.
+     список .айлов в .ек..ем ка.алоге, .о.но .акже, как если б. .. ввели э..
+     команд. в п.игла.ении оболо.ки. .ли поп.об.й.е :!dir , если п.ед.д..ая
+     команда не с.або.ала.
+
+---> .аме.ание: Таким способом можно в.полни.. л.б.. вне.н.. команд..
+
+---> .аме.ание: .се команд., на.ина..иеся с : , должн. заве..а..ся нажа.ием
+     <ENTER>.
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 У.ок 5.2: .А. .А..САТЬ ФА..
+
+
+** .ля со..анения изменений, п.оизведенн.. в .айле, набе.и.е :w ..Я_ФА..А. **
+
+  1. Набе.и.е :!dir или :!ls для пол..ения списка .айлов в .ек..ем ка.алоге.
+     .ак .ам .же извес.но, .. должн. нажа.. <ENTER> после ввода э.и. команд.
+
+  2. ..ид.май.е название для .айла, ко.о.ое е.е не с..ес.в.е., нап.име. TEST.
+
+  3. Тепе.. набе.и.е :w TEST (где TEST --- э.о имя .айла, п.ид.манное .ами.)
+
+  4. Э.а команда со..ани. вес. .айл (У.ебник по Vim) под именем TEST. Ч.об.
+     .дос.ове.и..ся в э.ом, снова набе.и.е :!dir и п.осмо..и.е ка.алог.
+
+---> .аме...е, ..о если .. в.йде.е из Vim и за.ем зап.с.и.е его снова с
+     .айлом TEST, э.о. .айл б.де. .о.ной копией ..ебника в .о. момен., когда
+     .. его со..анили.
+
+  5. Тепе.. .дали.е э.о. .айл, наб.ав :!del TEST
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       У.ок 5.3: .Ы.. .ЧН.. С.Х АН.Н..
+
+
+	 ** .ля со..анения .ас.и .айла, набе.и.е :#,# w ..Я_ФА..А **
+
+  1. ..е .аз набе.и.е :!dir или :!ls для пол..ения списка .айлов в .ек..ем
+     ка.алоге и в.бе.и.е под.одя.ее имя, нап.име. TEST.
+
+  2. .е.емес.и.е к..со. к на.ал. э.ой с..ани.. и нажми.е Ctrl-g для на.ождения
+     номе.а с..окиto. .А...Н.Т. ЭТ.Т Н... !
+
+  3. Тепе.. пе.емес.и.ес. в коне. с..ани.. и внов. набе.и.е Ctrl-g. .А...Н.Т.
+     . ЭТ.Т Н...  Т...!
+
+  4. .ля со..анения Т..Ь.. ЧАСТ. .айла набе.и.е :#,# w TEST , где #,# --- э.о
+     номе.а, ко.о..е .. запомнили (на.ало, коне.), а TEST --- имя ва.его .айла.
+
+  5. .ак и п.ежде, .беди.ес. в нали.ии э.ого .айла командой :!dir , но Н.
+     У.А.Я.Т. его.
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		    У.ок 5.4: ЧТ.Н.. . ..Ъ...Н.Н.. ФА....
+
+	  ** .ля вс.авки соде.жимого .айла, набе.и.е  :r FILENAME **
+
+  1. Набе.и.е :!dir для .ого, ..об. .беди..ся в .ом, ..о .айл TEST все е.е
+     с..ес.в.е..
+
+  2. Ус.анови.е к..со. в ве..ней .ас.и э.ой с..ани...
+
+.аме.ание: .осле в.полнения .ага 3 .. .види.е У.ок 5.3.	.осле э.ого
+	   пе.еме.ай.ес. .Н.., снова к э.ом. ..ок..
+
+  3. Тепе.. п.о.и.ай.е .а. .айл TEST, испол.з.я команд. :r TEST , где
+     TEST --- э.о имя .айла.
+
+.аме.ание: ..о.и.анн.й .ами .айл б.де. вс.авлен в .ом мес.е, где на.оди.ся
+	   к..со..
+
+  4. Ч.об. .беди..ся в .ом, ..о .айл п.о.и.ан, пе.емес.и.ес. немного назад по
+     .екс.. и заме...е, ..о .епе.. с..ес.в... две копии У.ока 5.3, ис.одная
+     и пол..енная из .айла.
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+				 ..Ю.. У ..А 5
+
+
+  1.  :!команда  исполняе. вне.н.. команд..
+
+      Неко.о..е полезн.е п.име..:
+	  :!dir --- в.води. список .айлов в ка.алоге.
+	  :!del FILENAME --- .даляе. .айл FILENAME.
+
+  2.  :w FILENAME запис.вае. .ек..ий .едак.и..ем.й .айл на диск
+      под именем FILENAME.
+
+  3.  :#,#w FILENAME со..аняе. с..оки о. # до # в .айл FILENAME.
+
+  4.  :r FILENAME с.и..вае. с диска .айл FILENAME и поме.ае. его в .ек..ий
+      .айл следом за пози.ией к..со.а.
+
+
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			  У.ок 6.1: ...АН.А С...АН.Я
+
+
+ ** Набе.и.е o ..об. созда.. п.с... с..ок. под к..со.ом и пе.ей.и в .ежим
+			   вс.авки (Insert mode) **
+
+  1. .е.емес.и.е к..со. вниз, к с..оке, поме.енной --->.
+
+  2. Набе.и.е o (в нижнем .егис..е) для .ого, ..об. созда.. п.с... с..ок.
+     Н... к..со.а и пе.ей.и в .ежим вс.авки (Insert mode).
+
+  3. Тепе.. скопи..й.е поме.енн.. ---> с..ок. и нажми.е <ESC> для в..ода из
+     .ежима вс.авки.
+
+---> .осле нажа.ия o к..со. пе.ейде. на нов.. п.с... с..ок. в .ежиме вс.авки.
+
+  4. .ля создания с..оки .ЫШ. к..со.а, п.ос.о набе.и.е заглавн.. O, вмес.о
+     с..о.ной o. .оп.об.й.е п.одела.. э.о с нижеслед...ей с..окой.
+Создай.е нов.. с..ок. над э.ой, нажав Shift-O, помес.ив к..со. на э.. с..ок..
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			 У.ок 6.2: ...АН.А ...А...Н.Я
+
+	    ** Набе.и.е a , ..об. вс.ави.. .екс. ..С.. к..со.а. **
+
+  1. .е.емес.и.е к..со. вниз, в коне. пе.вой с..оки, поме.енной ---> ,
+     наб.ав $ в об..ном .ежиме (Normal mode).
+
+  2. Набе.и.е a (в нижнем .егис..е) для добавления .екс.а ..С.. символа,
+     на.одя.егося под к..со.ом. (.аглавная A позволяе. добави.. в коне.
+     с..оки.)
+
+.аме.ание: Э.о позволяе. избежа.. нажа.ия i , последнего символа, .екс.а для
+	   вс.авки, <ESC>, к..со.-вп.аво, и, наконе., x , п.ос.о для .ого,
+	   ..об. добави.. .ес. в коне. с..оки!
+
+  3. Тепе.. заве..и.е пе.в.. с..ок.. .аме...е .акже, ..о добавление э.о в
+     .о.нос.и .о же самое, ..о и .ежим вс.авки, за искл..ением пози.ии, в
+     ко.о... б.де. вс.авлен .екс..
+
+---> Э.а с..о.ка позволи. .ам поп.ак.икова..ся
+---> Э.а с..о.ка позволи. .ам поп.ак.икова..ся в добавлении .екс.а в коне.
+     с..оки.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		       У.ок 6.3: .Щ. ...Н С..С.. .А..НЫ
+
+
+       ** Набе.и.е заглавн.. R для замен. более, .ем одного символа. **
+
+  1. .е.емес.и.е к..со. вниз, к с..оке, поме.енной --->.
+
+  2.  асположи.е к..со. в на.але пе.вого слова, о.ли.а..егося о.
+     соо.ве.с.в...его в след...ей с..оке, поме.енной ---> (слово 'последней').
+
+  3. Тепе.. набе.и.е R и замени.е ос.а.ок .екс.а в пе.вой с..оке, наб.ав
+     пове.. с.а.ого .екс.а .ак, ..об. обе с..оки с.али одинаков.ми.
+
+---> .е.в.. с..ок. можно с.авня.. с последней, испол.з.я клави.и.
+---> .е.в.. с..ок. можно с.авня.. с в.о.ой, испол.з.я R и наб.ав нов.й .екс..
+
+  4. .б.а.и.е внимание, ..о п.и нажа.ии <ESC> для заве..ения, л.бой
+     не измененн.й .екс. со..ани.ся.
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+			У.ок 6.4: УСТАН...А .А А..Т ..
+
+
+** Ус.ановим па.аме... .ак, ..об. игно.и.ова.. .егис.. п.и поиске или замене **
+
+
+  1. .ои.и.е слово 'игно.и.ова..', наб.ав:
+     /игно.и.ова..
+     .ов.о.и.е поиск нескол.ко .аз, нажимая клави.. n
+
+  2. .кл..и.е па.аме.. 'ic' (.гно.и.ова.. .егис..), наб.ав:
+     :set ic
+
+  3. Тепе.. снова сделай.е поиск слова 'игно.и.ова..', нажав: n
+     .ов.о.и.е поиск нескол.ко .аз, нажимая клави.. n
+
+  4. .кл..и.е па.аме... 'hlsearch' и 'incsearch':
+     :set hls is
+
+  5. Тепе.. опя.. введи.е команд. поиска и посмо..и.е, ..о пол..и.ся:
+     /игно.и.ова..
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+				 ..Ю.. У ..А 6
+
+
+  1. Нажа.ие o создае. с..ок. Н... к..со.а и пе.еме.ае. к..со. в нее в .ежиме
+     вс.авки.
+     Нажа.ие заглавной O создае. с..ок. .ЫШ. с..оки, в ко.о.ой на.оди.ся
+     к..со..
+
+  2. Набе.и.е a для вс.авки .екс.а ..С.. символа, на ко.о.ом на.оди.ся к..со..
+     Нажа.ие заглавной A ав.ома.и.ески пе.еме.ае. .ас для добавления .екс.а
+     в коне. с..оки.
+
+  3. Нажа.ие заглавной R пе.еводи. .ас в .ежим замен. до .е. по., пока не
+     б.де. нажа.а клави.а <ESC> для заве..ения.
+
+  4. Наб.ав ":set xxx" в. сможе.е вкл..и.. па.аме.. "xxx"
+
+
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		 У.ок 7: ...АН.Ы ...УЧ.Н.Я .СТ ..НН.. С. А...
+
+	       ** .спол.з.й.е вс..оенн.. сп.аво.н.. сис.ем. **
+
+  Vim обладае. мо.ной вс..оенной сп.аво.ной сис.емой. .ля на.ала поп.об.й.е
+  один из ..е. ва.иан.ов:
+	- нажми.е клави.. <HELP> (если .аковая имее.ся на клавиа...е)
+	- нажми.е клави.. <F1> (если .аковая имее.ся на клавиа...е)
+	- набе.и.е   :help <ENTER>
+
+  Набе.и.е   :q <ENTER>   ..об. зак.... окно сп.авки.
+
+  .. може.е най.и сп.авк. для л.бого поня.ия или команд., п.ос.о задав
+  соо.ве.с.в...ий а.г.мен. команде ":help". .оп.об.й.е след...ее (не заб.д..е
+  нажа.. <ENTER>):
+
+  :help w
+  :help c_<T
+  :help insert-index
+
+
+
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+		     У.ок 8: С...АН.. СТА Т..... С. ..ТА
+
+			** .кл..им возможнос.и Vim **
+
+  Vim имее. намного бол..е возможнос.ей, .ем Vi, однако бол..инс.вао из ни.
+  в.кл..ен. по .мол.ани.. .ля .ого, ..об. на.а.. испол.зова.. нов.е
+  возможнос.и .ам след.е. созда.. .айл "vimrc".
+
+  1. ...едак.и..й.е .айл "vimrc", его .асположение зависи. о. испол.з.емой
+     сис.ем.:
+
+       :edit ~/.vimrc			для Unix
+       :edit $VIM/_vimrc		для MS-Windows
+
+  2. Тепе.. п.о.и.ай.е п.име. .айла "vimrc":
+
+       :read $VIMRUNTIME/vimrc_example.vim
+
+  3. .апи.и.е .айл:
+
+       :write
+
+  Тепе.. п.и след...ем зап.ске Vim б.де. вкл..ена подсве.ка син.аксиса. .се
+  нас..ойки, п.едпо.и.аем.е .ами, мог.. б... добавлен. в .айл "vimrc".
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  На э.ом заве..ае.ся У.ебник Vim. .н б.л п.едназна.ен для .ого, ..об. да..
+  об.ее п.едс.авление о .едак.о.е Vim, дос.а.о.ное для .ого, ..об. с легкос...
+  испол.зова.. его. У.ебник далек о. полно.., поскол.к. Vim имее. о.ен. много
+  команд. ..о.и.ай.е .епе.. ..ководс.во пол.зова.еля: ":help user-manual".
+
+  .ля дал.ней.его ..ения .екоменд.е.ся книга:
+	Vim - Vi Improved - Ав.о.: Steve Oualline
+	.зда.ел.: New Riders
+  Э.а книга полнос... посвя.ена Vim. .собенно полезна нови.кам. Соде.жи.
+  множес.во п.име.ов и илл.с..а.ий.
+  .згляни.е на See http://iccf-holland.org/click5.html
+
+  След...ая книга более по..енного воз.ас.а и посвя.ена бол..е Vi, .ем Vim,
+  однако .акже .екоменд.е.ся:
+	Learning the Vi Editor - Ав.о.: Linda Lamb
+	.зда.ел.: O'Reilly & Associates Inc.
+  Э.о .о.о.ая книга для .ого, ..об. .зна.. все, ..о .ол.ко можно п.одел.ва.. с
+  Vi. Шес.ое издание .акже вкл..ае. ин.о.ма.и. о Vim.
+
+  Э.о. ..ебник б.л написан Michael C. Pierce и Robert K. Ware, Colorado School
+  of Mines с испол.зованием идей, п.едложенн.. Charles Smith, Colorado State
+  University. E-mail: bware@mines.colorado.edu.
+
+  .о.або.ано для Vim Bram Moolenaar.
+
+  .е.евод: Анд.ей .иселев <a_kissel@eudoramail.com>, 2002.
+  Translator: Andrey Kiselev <a_kissel@eudoramail.com>, 2002.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff -Naur vim70.orig/runtime/tutor/tutor.vim vim70/runtime/tutor/tutor.vim
--- vim70.orig/runtime/tutor/tutor.vim	2006-03-18 12:20:36.000000000 -0800
+++ vim70/runtime/tutor/tutor.vim	2006-09-11 09:26:16.000000000 -0700
@@ -1,6 +1,6 @@
 " Vim tutor support file
 " Author: Eduardo F. Amatria <eferna1@platea.pntic.mec.es>
-" Last Change:	2006 Mar 18
+" Last Change:	2006 Sep 09
 
 " This small source file is used for detecting if a translation of the
 " tutor file exist, i.e., a tutor.xx file, where xx is the language.
@@ -93,9 +93,16 @@
   endif
 endif
 
-" The Greek tutor is available in two encodings, guess which one to use
-if s:ext =~? '\.gr' && &enc =~ 737
-  let s:ext = ".gr.cp737"
+" The Greek tutor is available in three encodings, guess what to use.
+" We used ".gr" (Greece) instead of ".el" (Greek); accept both.
+if s:ext =~? '\.gr\|\.el'
+  if &enc == "iso-8859-7"
+    let s:ext = ".gr"
+  elseif &enc == "utf-8"
+    let s:ext = ".gr.utf-8"
+  elseif &enc =~ 737
+    let s:ext = ".gr.cp737"
+  endif
 endif
 
 " The Slovak tutor is available in two encodings, guess which one to use
@@ -103,11 +110,15 @@
   let s:ext = ".sk.cp1250"
 endif
 
-" The Russian tutor is available in two encodings, guess which one to use.
-" This segment is from the above lines and modified by
-" Alexey I. Froloff <raorn@altlinux.org> for Russian vim tutorial
-if s:ext =~? '\.ru' && &enc =~ 1251
-  let s:ext = ".ru.cp1251"
+" The Russian tutor is available in three encodings, guess which one to use.
+if s:ext =~? '\.ru'
+  if &enc == 'utf-8'
+    let s:ext = '.ru.utf-8'
+  elseif &enc =~ '1251'
+    let s:ext = '.ru.cp1251'
+  elseif &enc =~ 'koi8'
+    let s:ext = '.ru'
+  endif
 endif
 
 " Somehow ".ge" (Germany) is sometimes used for ".de" (Deutsch).
diff -Naur vim70.orig/src/auto/configure vim70/src/auto/configure
--- vim70.orig/src/auto/configure	2006-05-04 03:46:19.000000000 -0700
+++ vim70/src/auto/configure	2006-09-11 09:02:36.000000000 -0700
@@ -4014,7 +4014,7 @@
       LDFLAGS=$ldflags_save
       if test $perl_ok = yes; then
 	if test "X$perlcppflags" != "X"; then
-	  PERL_CFLAGS="$perlcppflags"
+	  	  PERL_CFLAGS=`echo "$perlcppflags" | sed 's/-pipe //'`
 	fi
 	if test "X$perlldflags" != "X"; then
 	  LDFLAGS="$perlldflags $LDFLAGS"
diff -Naur vim70.orig/src/buffer.c vim70/src/buffer.c
--- vim70.orig/src/buffer.c	2006-04-26 14:37:23.000000000 -0700
+++ vim70/src/buffer.c	2006-09-11 09:04:57.000000000 -0700
@@ -434,12 +434,8 @@
     if (usingNetbeans)
 	netbeans_file_closed(buf);
 #endif
-#ifdef FEAT_AUTOCHDIR
-    /* Change directories when the acd option is set on. */
-    if (p_acd && curbuf->b_ffname != NULL
-				     && vim_chdirfile(curbuf->b_ffname) == OK)
-	shorten_fnames(TRUE);
-#endif
+    /* Change directories when the 'acd' option is set. */
+    DO_AUTOCHDIR
 
     /*
      * Remove the buffer from the list.
@@ -1390,7 +1386,8 @@
     }
     else
     {
-	need_fileinfo = TRUE;		/* display file info after redraw */
+	if (!msg_silent)
+	    need_fileinfo = TRUE;	/* display file info after redraw */
 	(void)buf_check_timestamp(curbuf, FALSE); /* check if file changed */
 #ifdef FEAT_AUTOCMD
 	curwin->w_topline = 1;
@@ -1422,12 +1419,8 @@
 	netbeans_file_activated(curbuf);
 #endif
 
-#ifdef FEAT_AUTOCHDIR
-    /* Change directories when the acd option is set on. */
-    if (p_acd && curbuf->b_ffname != NULL
-				     && vim_chdirfile(curbuf->b_ffname) == OK)
-	shorten_fnames(TRUE);
-#endif
+    /* Change directories when the 'acd' option is set. */
+    DO_AUTOCHDIR
 
 #ifdef FEAT_KEYMAP
     if (curbuf->b_kmap_state & KEYMAP_INIT)
@@ -1436,6 +1429,18 @@
     redraw_later(NOT_VALID);
 }
 
+#if defined(FEAT_AUTOCHDIR) || defined(PROTO)
+/*
+ * Change to the directory of the current buffer.
+ */
+    void
+do_autochdir()
+{
+    if (curbuf->b_ffname != NULL && vim_chdirfile(curbuf->b_ffname) == OK)
+	shorten_fnames(TRUE);
+}
+#endif
+
 /*
  * functions for dealing with the buffer list
  */
@@ -3324,7 +3329,7 @@
     {
 	usefmt = eval_to_string_safe(fmt + 2, NULL, use_sandbox);
 	if (usefmt == NULL)
-	    usefmt = (char_u *)"";
+	    usefmt = fmt;
     }
 #endif
 
@@ -5420,11 +5425,7 @@
     buf_T	*newbuf;
     int		differ = TRUE;
     linenr_T	lnum;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
-#else
-    buf_T	*old_curbuf = curbuf;
-#endif
     exarg_T	ea;
 
     /* Allocate a buffer without putting it in the buffer list. */
@@ -5439,13 +5440,8 @@
 	return TRUE;
     }
 
-#ifdef FEAT_AUTOCMD
     /* set curwin/curbuf to buf and save a few things */
     aucmd_prepbuf(&aco, newbuf);
-#else
-    curbuf = newbuf;
-    curwin->w_buffer = newbuf;
-#endif
 
     if (ml_open(curbuf) == OK
 	    && readfile(buf->b_ffname, buf->b_fname,
@@ -5466,13 +5462,8 @@
     }
     vim_free(ea.cmd);
 
-#ifdef FEAT_AUTOCMD
     /* restore curwin/curbuf and a few other things */
     aucmd_restbuf(&aco);
-#else
-    curbuf = old_curbuf;
-    curwin->w_buffer = old_curbuf;
-#endif
 
     if (curbuf != newbuf)	/* safety check */
 	wipe_buffer(newbuf, FALSE);
diff -Naur vim70.orig/src/configure vim70/src/configure
--- vim70.orig/src/configure	2006-05-07 07:17:49.000000000 -0700
+++ vim70/src/configure	2006-08-09 08:37:06.000000000 -0700
@@ -2,5 +2,9 @@
 # run the automatically generated configure script
 CONFIG_STATUS=auto/config.status \
 	auto/configure "$@" --srcdir="${srcdir:-.}" --cache-file=auto/config.cache
+result=$?
+
 # Stupid autoconf 2.5x causes this file to be left behind.
 if test -f configure.lineno; then rm -f configure.lineno; fi
+
+exit $result
diff -Naur vim70.orig/src/configure.in vim70/src/configure.in
--- vim70.orig/src/configure.in	2006-05-04 03:46:11.000000000 -0700
+++ vim70/src/configure.in	2006-09-11 09:02:36.000000000 -0700
@@ -508,7 +508,8 @@
       LDFLAGS=$ldflags_save
       if test $perl_ok = yes; then
 	if test "X$perlcppflags" != "X"; then
-	  PERL_CFLAGS="$perlcppflags"
+	  dnl remove -pipe, it confuses cproto
+	  PERL_CFLAGS=`echo "$perlcppflags" | sed 's/-pipe //'`
 	fi
 	if test "X$perlldflags" != "X"; then
 	  LDFLAGS="$perlldflags $LDFLAGS"
diff -Naur vim70.orig/src/edit.c vim70/src/edit.c
--- vim70.orig/src/edit.c	2006-05-07 04:48:51.000000000 -0700
+++ vim70/src/edit.c	2006-09-11 08:30:17.000000000 -0700
@@ -129,7 +129,7 @@
 
 static void ins_ctrl_x __ARGS((void));
 static int  has_compl_option __ARGS((int dict_opt));
-static int ins_compl_add __ARGS((char_u *str, int len, int icase, char_u *fname, char_u **cptext, int cdir, int flags, int dup));
+static int ins_compl_add __ARGS((char_u *str, int len, int icase, char_u *fname, char_u **cptext, int cdir, int flags, int adup));
 static int  ins_compl_equal __ARGS((compl_T *match, char_u *str, int len));
 static void ins_compl_longest_match __ARGS((compl_T *match));
 static void ins_compl_add_matches __ARGS((int num_matches, char_u **matches, int icase));
@@ -719,9 +719,14 @@
 #ifdef FEAT_INS_EXPAND
 	/*
 	 * Special handling of keys while the popup menu is visible or wanted
-	 * and the cursor is still in the completed word.
+	 * and the cursor is still in the completed word.  Only when there is
+	 * a match, skip this when no matches were found.
 	 */
-	if (compl_started && pum_wanted() && curwin->w_cursor.col >= compl_col)
+	if (compl_started
+		&& pum_wanted()
+		&& curwin->w_cursor.col >= compl_col
+		&& (compl_shown_match == NULL
+		    || compl_shown_match != compl_shown_match->cp_next))
 	{
 	    /* BS: Delete one character from "compl_leader". */
 	    if ((c == K_BS || c == Ctrl_H)
@@ -751,7 +756,7 @@
 		    continue;
 		}
 
-		/* Pressing CTRL-Y selects the current match.  Shen
+		/* Pressing CTRL-Y selects the current match.  When
 		 * compl_enter_selects is set the Enter key does the same. */
 		if (c == Ctrl_Y || (compl_enter_selects
 				   && (c == CAR || c == K_KENTER || c == NL)))
@@ -877,6 +882,7 @@
 		/* Close the cmdline window. */
 		cmdwin_result = K_IGNORE;
 		got_int = FALSE; /* don't stop executing autocommands et al. */
+		nomove = TRUE;
 		goto doESCkey;
 	    }
 #endif
@@ -2112,7 +2118,7 @@
  * maybe because alloc() returns NULL, then FAIL is returned.
  */
     static int
-ins_compl_add(str, len, icase, fname, cptext, cdir, flags, dup)
+ins_compl_add(str, len, icase, fname, cptext, cdir, flags, adup)
     char_u	*str;
     int		len;
     int		icase;
@@ -2120,7 +2126,7 @@
     char_u	**cptext;   /* extra text for popup menu or NULL */
     int		cdir;
     int		flags;
-    int		dup;	    /* accept duplicate match */
+    int		adup;	    /* accept duplicate match */
 {
     compl_T	*match;
     int		dir = (cdir == 0 ? compl_direction : cdir);
@@ -2134,7 +2140,7 @@
     /*
      * If the same match is already present, don't add it.
      */
-    if (compl_first_match != NULL && !dup)
+    if (compl_first_match != NULL && !adup)
     {
 	match = compl_first_match;
 	do
@@ -2399,7 +2405,7 @@
     /* compl_pattern doesn't need to be set */
     compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);
     if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
-			-1, FALSE, NULL, NULL, 0, ORIGINAL_TEXT, FALSE) != OK)
+			-1, p_ic, NULL, NULL, 0, ORIGINAL_TEXT, FALSE) != OK)
 	return;
 
     /* Handle like dictionary completion. */
@@ -2409,6 +2415,7 @@
     compl_matches = ins_compl_make_cyclic();
     compl_started = TRUE;
     compl_used_match = TRUE;
+    compl_cont_status = 0;
 
     compl_curr_match = compl_first_match;
     ins_complete(Ctrl_N);
@@ -2753,6 +2760,7 @@
 	}
 	else
 # endif
+	    if (count > 0)	/* avoid warning for using "files" uninit */
 	{
 	    ins_compl_files(count, files, thesaurus, flags,
 							&regmatch, buf, &dir);
@@ -2813,7 +2821,7 @@
 			ptr = find_word_end(ptr);
 		    add_r = ins_compl_add_infercase(regmatch->startp[0],
 					  (int)(ptr - regmatch->startp[0]),
-						     FALSE, files[i], *dir, 0);
+						     p_ic, files[i], *dir, 0);
 		    if (thesaurus)
 		    {
 			char_u *wstart;
@@ -2849,7 +2857,7 @@
 				ptr = find_word_end(ptr);
 			    add_r = ins_compl_add_infercase(wstart,
 				    (int)(ptr - wstart),
-				    FALSE, files[i], *dir, 0);
+				    p_ic, files[i], *dir, 0);
 			}
 		    }
 		    if (add_r == OK)
@@ -3015,9 +3023,6 @@
     if ((int)(p - line) - (int)compl_col <= 0)
 	return K_BS;
 
-    /* For redo we need to repeat this backspace. */
-    AppendCharToRedobuff(K_BS);
-
     /* Deleted more than what was used to find matches or didn't finish
      * finding all matches: need to look for matches all over again. */
     if (curwin->w_cursor.col <= compl_col + compl_length
@@ -3046,7 +3051,6 @@
     ins_compl_delete();
     ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
     compl_used_match = FALSE;
-    compl_enter_selects = FALSE;
 
     if (compl_started)
 	ins_compl_set_original_text(compl_leader);
@@ -3076,6 +3080,7 @@
 	compl_restarting = FALSE;
     }
 
+#if 0   /* disabled, made CTRL-L, BS and typing char jump to original text. */
     if (!compl_used_match)
     {
 	/* Go to the original text, since none of the matches is inserted. */
@@ -3087,9 +3092,15 @@
 	compl_curr_match = compl_shown_match;
 	compl_shows_dir = compl_direction;
     }
+#endif
+    compl_enter_selects = !compl_used_match;
 
     /* Show the popup menu with a different set of matches. */
     ins_compl_show_pum();
+
+    /* Don't let Enter select the original text when there is no popup menu. */
+    if (compl_match_array == NULL)
+	compl_enter_selects = FALSE;
 }
 
 /*
@@ -3115,10 +3126,6 @@
 #endif
 	ins_char(c);
 
-    /* For redo we need to count this character so that the number of
-     * backspaces is correct. */
-    AppendCharToRedobuff(c);
-
     /* If we didn't complete finding matches we must search again. */
     if (compl_was_interrupted)
 	ins_compl_restart();
@@ -3175,10 +3182,32 @@
     char_u	*p;
     int		len = curwin->w_cursor.col - compl_col;
     int		c;
+    compl_T	*cp;
 
     p = compl_shown_match->cp_str;
     if ((int)STRLEN(p) <= len)   /* the match is too short */
-	return;
+    {
+	/* When still at the original match use the first entry that matches
+	 * the leader. */
+	if (compl_shown_match->cp_flags & ORIGINAL_TEXT)
+	{
+	    p = NULL;
+	    for (cp = compl_shown_match->cp_next; cp != NULL
+				 && cp != compl_first_match; cp = cp->cp_next)
+	    {
+		if (ins_compl_equal(cp, compl_leader,
+						   (int)STRLEN(compl_leader)))
+		{
+		    p = cp->cp_str;
+		    break;
+		}
+	    }
+	    if (p == NULL || (int)STRLEN(p) <= len)
+		return;
+	}
+	else
+	    return;
+    }
     p += len;
 #ifdef FEAT_MBYTE
     c = mb_ptr2char(p);
@@ -3198,7 +3227,6 @@
     int	    c;
 {
     char_u	*ptr;
-    int		temp;
     int		want_cindent;
     int		retval = FALSE;
 
@@ -3354,6 +3382,7 @@
 	    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)
 	    {
 		char_u	*p;
+		int	temp = 0;
 
 		/*
 		 * If any of the original typed text has been changed, eg when
@@ -3369,16 +3398,21 @@
 		    ptr = compl_leader;
 		else
 		    ptr = compl_orig_text;
-		p = compl_orig_text;
-		for (temp = 0; p[temp] != NUL && p[temp] == ptr[temp]; ++temp)
-		    ;
+		if (compl_orig_text != NULL)
+		{
+		    p = compl_orig_text;
+		    for (temp = 0; p[temp] != NUL && p[temp] == ptr[temp];
+								       ++temp)
+			;
 #ifdef FEAT_MBYTE
-		if (temp > 0)
-		    temp -= (*mb_head_off)(compl_orig_text, p + temp);
+		    if (temp > 0)
+			temp -= (*mb_head_off)(compl_orig_text, p + temp);
 #endif
-		for (p += temp; *p != NUL; mb_ptr_adv(p))
-		    AppendCharToRedobuff(K_BS);
-		AppendToRedobuffLit(ptr + temp, -1);
+		    for (p += temp; *p != NUL; mb_ptr_adv(p))
+			AppendCharToRedobuff(K_BS);
+		}
+		if (ptr != NULL)
+		    AppendToRedobuffLit(ptr + temp, -1);
 	    }
 
 #ifdef FEAT_CINDENT
@@ -3578,7 +3612,7 @@
 {
     char_u	*word;
     int		icase = FALSE;
-    int		dup = FALSE;
+    int		adup = FALSE;
     char_u	*(cptext[CPT_COUNT]);
 
     if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)
@@ -3595,7 +3629,7 @@
 	if (get_dict_string(tv->vval.v_dict, (char_u *)"icase", FALSE) != NULL)
 	    icase = get_dict_number(tv->vval.v_dict, (char_u *)"icase");
 	if (get_dict_string(tv->vval.v_dict, (char_u *)"dup", FALSE) != NULL)
-	    dup = get_dict_number(tv->vval.v_dict, (char_u *)"dup");
+	    adup = get_dict_number(tv->vval.v_dict, (char_u *)"dup");
     }
     else
     {
@@ -3604,7 +3638,7 @@
     }
     if (word == NULL || *word == NUL)
 	return FAIL;
-    return ins_compl_add(word, -1, icase, NULL, cptext, dir, 0, dup);
+    return ins_compl_add(word, -1, icase, NULL, cptext, dir, 0, adup);
 }
 #endif
 
@@ -3796,7 +3830,7 @@
 		    TAG_INS_COMP | (ctrl_x_mode ? TAG_VERBOSE : 0),
 		    TAG_MANY, curbuf->b_ffname) == OK && num_matches > 0)
 	    {
-		ins_compl_add_matches(num_matches, matches, FALSE);
+		ins_compl_add_matches(num_matches, matches, p_ic);
 	    }
 	    p_ic = save_p_ic;
 	    break;
@@ -3837,7 +3871,7 @@
 	    num_matches = expand_spelling(first_match_pos.lnum,
 				 first_match_pos.col, compl_pattern, &matches);
 	    if (num_matches > 0)
-		ins_compl_add_matches(num_matches, matches, FALSE);
+		ins_compl_add_matches(num_matches, matches, p_ic);
 #endif
 	    break;
 
@@ -3971,7 +4005,7 @@
 			    continue;
 		    }
 		}
-		if (ins_compl_add_infercase(ptr, len, FALSE,
+		if (ins_compl_add_infercase(ptr, len, p_ic,
 				 ins_buf == curbuf ? NULL : ins_buf->b_sfname,
 					   0, flags) != NOTDONE)
 		{
@@ -4100,6 +4134,21 @@
 		&& compl_shown_match->cp_next != NULL
 		&& compl_shown_match->cp_next != compl_first_match)
 	    compl_shown_match = compl_shown_match->cp_next;
+
+	/* If we didn't find it searching forward, and compl_shows_dir is
+	 * backward, find the last match. */
+	if (compl_shows_dir == BACKWARD
+		&& !ins_compl_equal(compl_shown_match,
+				      compl_leader, (int)STRLEN(compl_leader))
+		&& (compl_shown_match->cp_next == NULL
+		    || compl_shown_match->cp_next == compl_first_match))
+	{
+	    while (!ins_compl_equal(compl_shown_match,
+				      compl_leader, (int)STRLEN(compl_leader))
+		    && compl_shown_match->cp_prev != NULL
+		    && compl_shown_match->cp_prev != compl_first_match)
+		compl_shown_match = compl_shown_match->cp_prev;
+	}
     }
 
     if (allow_get_expansion && insert_match
@@ -4124,8 +4173,6 @@
     {
 	if (compl_shows_dir == FORWARD && compl_shown_match->cp_next != NULL)
 	{
-	    if (compl_pending != 0)
-		--compl_pending;
 	    compl_shown_match = compl_shown_match->cp_next;
 	    found_end = (compl_first_match != NULL
 			   && (compl_shown_match->cp_next == compl_first_match
@@ -4134,14 +4181,24 @@
 	else if (compl_shows_dir == BACKWARD
 					&& compl_shown_match->cp_prev != NULL)
 	{
-	    if (compl_pending != 0)
-		++compl_pending;
 	    found_end = (compl_shown_match == compl_first_match);
 	    compl_shown_match = compl_shown_match->cp_prev;
 	    found_end |= (compl_shown_match == compl_first_match);
 	}
 	else
 	{
+	    if (!allow_get_expansion)
+	    {
+		if (advance)
+		{
+		    if (compl_shows_dir == BACKWARD)
+			compl_pending -= todo + 1;
+		    else
+			compl_pending += todo + 1;
+		}
+		return -1;
+	    }
+
 	    if (advance)
 	    {
 		if (compl_shows_dir == BACKWARD)
@@ -4149,14 +4206,27 @@
 		else
 		    ++compl_pending;
 	    }
-	    if (!allow_get_expansion)
-		return -1;
 
 	    /* Find matches. */
 	    num_matches = ins_compl_get_exp(&compl_startpos);
-	    if (compl_pending != 0 && compl_direction == compl_shows_dir
+
+	    /* handle any pending completions */
+	    while (compl_pending != 0 && compl_direction == compl_shows_dir
 								   && advance)
-		compl_shown_match = compl_curr_match;
+	    {
+		if (compl_pending > 0 && compl_shown_match->cp_next != NULL)
+		{
+		    compl_shown_match = compl_shown_match->cp_next;
+		    --compl_pending;
+		}
+		if (compl_pending < 0 && compl_shown_match->cp_prev != NULL)
+		{
+		    compl_shown_match = compl_shown_match->cp_prev;
+		    ++compl_pending;
+		}
+		else
+		    break;
+	    }
 	    found_end = FALSE;
 	}
 	if ((compl_shown_match->cp_flags & ORIGINAL_TEXT) == 0
@@ -4265,9 +4335,9 @@
 	return;
     count = 0;
 
-    ++no_mapping;
+    /* Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()
+     * can't do its work correctly. */
     c = vpeekc_any();
-    --no_mapping;
     if (c != NUL)
     {
 	if (vim_is_ctrl_x_key(c) && c != Ctrl_X && c != Ctrl_R)
@@ -4277,12 +4347,27 @@
 	    (void)ins_compl_next(FALSE, ins_compl_key2count(c),
 						    c != K_UP && c != K_DOWN);
 	}
-	else if (c != Ctrl_R)
-	    compl_interrupted = TRUE;
+	else
+	{
+	    /* Need to get the character to have KeyTyped set.  We'll put it
+	     * back with vungetc() below. */
+	    c = safe_vgetc();
+
+	    /* Don't interrupt completion when the character wasn't typed,
+	     * e.g., when doing @q to replay keys. */
+	    if (c != Ctrl_R && KeyTyped)
+		compl_interrupted = TRUE;
+
+	    vungetc(c);
+	}
     }
     if (compl_pending != 0 && !got_int)
-	(void)ins_compl_next(FALSE, compl_pending > 0
-				      ? compl_pending : -compl_pending, TRUE);
+    {
+	int todo = compl_pending > 0 ? compl_pending : -compl_pending;
+
+	compl_pending = 0;
+	(void)ins_compl_next(FALSE, todo, TRUE);
+    }
 }
 
 /*
@@ -4611,10 +4696,12 @@
 				     (int)STRLEN(compl_pattern), curs_col);
 	    if (compl_xp.xp_context == EXPAND_UNSUCCESSFUL
 		    || compl_xp.xp_context == EXPAND_NOTHING)
-		return FAIL;
-	    startcol = (int)(compl_xp.xp_pattern - compl_pattern);
-	    compl_col = startcol;
-	    compl_length = curs_col - startcol;
+		/* No completion possible, use an empty pattern to get a
+		 * "pattern not found" message. */
+		compl_col = curs_col;
+	    else
+		compl_col = (int)(compl_xp.xp_pattern - compl_pattern);
+	    compl_length = curs_col - compl_col;
 	}
 	else if (ctrl_x_mode == CTRL_X_FUNCTION || ctrl_x_mode == CTRL_X_OMNI)
 	{
@@ -4668,11 +4755,17 @@
 	    else
 		compl_col = spell_word_start(startcol);
 	    if (compl_col >= (colnr_T)startcol)
-		return FAIL;
-	    spell_expand_check_cap(compl_col);
+	    {
+		compl_length = 0;
+		compl_col = curs_col;
+	    }
+	    else
+	    {
+		spell_expand_check_cap(compl_col);
+		compl_length = (int)curs_col - compl_col;
+	    }
 	    /* Need to obtain "line" again, it may have become invalid. */
 	    line = ml_get(curwin->w_cursor.lnum);
-	    compl_length = (int)curs_col - compl_col;
 	    compl_pattern = vim_strnsave(line + compl_col, compl_length);
 	    if (compl_pattern == NULL)
 #endif
@@ -4720,7 +4813,7 @@
 	vim_free(compl_orig_text);
 	compl_orig_text = vim_strnsave(line + compl_col, compl_length);
 	if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
-			-1, FALSE, NULL, NULL, 0, ORIGINAL_TEXT, FALSE) != OK)
+			-1, p_ic, NULL, NULL, 0, ORIGINAL_TEXT, FALSE) != OK)
 	{
 	    vim_free(compl_pattern);
 	    compl_pattern = NULL;
@@ -8508,7 +8601,12 @@
     tpos = curwin->w_cursor;
     if (oneleft() == OK)
     {
-	start_arrow(&tpos);
+#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
+	/* Only call start_arrow() when not busy with preediting, it will
+	 * break undo.  K_LEFT is inserted in im_correct_cursor(). */
+	if (!im_is_preediting())
+#endif
+	    start_arrow(&tpos);
 #ifdef FEAT_RIGHTLEFT
 	/* If exit reversed string, position is fixed */
 	if (revins_scol != -1 && (int)curwin->w_cursor.col >= revins_scol)
diff -Naur vim70.orig/src/eval.c vim70/src/eval.c
--- vim70.orig/src/eval.c	2006-05-05 10:15:26.000000000 -0700
+++ vim70/src/eval.c	2006-09-11 09:04:12.000000000 -0700
@@ -454,7 +454,7 @@
 static char_u *deref_func_name __ARGS((char_u *name, int *lenp));
 static int get_func_tv __ARGS((char_u *name, int len, typval_T *rettv, char_u **arg, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
 static int call_func __ARGS((char_u *name, int len, typval_T *rettv, int argcount, typval_T *argvars, linenr_T firstline, linenr_T lastline, int *doesrange, int evaluate, dict_T *selfdict));
-static void emsg_funcname __ARGS((char *msg, char_u *name));
+static void emsg_funcname __ARGS((char *ermsg, char_u *name));
 
 static void f_add __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_append __ARGS((typval_T *argvars, typval_T *rettv));
@@ -701,6 +701,7 @@
 static void list_one_var_a __ARGS((char_u *prefix, char_u *name, int type, char_u *string));
 static void set_var __ARGS((char_u *name, typval_T *varp, int copy));
 static int var_check_ro __ARGS((int flags, char_u *name));
+static int var_check_fixed __ARGS((int flags, char_u *name));
 static int tv_check_lock __ARGS((int lock, char_u *name));
 static void copy_tv __ARGS((typval_T *from, typval_T *to));
 static int item_copy __ARGS((typval_T *from, typval_T *to, int deep, int copyID));
@@ -2260,7 +2261,7 @@
 	    EMSG(_(e_letunexp));
 	else
 	{
-	    char_u	*tofree = NULL;
+	    char_u	*ptofree = NULL;
 	    char_u	*s;
 
 	    p = get_tv_string_chk(tv);
@@ -2269,7 +2270,7 @@
 		s = get_reg_contents(*arg == '@' ? '"' : *arg, TRUE, TRUE);
 		if (s != NULL)
 		{
-		    p = tofree = concat_str(s, p);
+		    p = ptofree = concat_str(s, p);
 		    vim_free(s);
 		}
 	    }
@@ -2278,7 +2279,7 @@
 		write_reg_contents(*arg == '@' ? '"' : *arg, p, -1, FALSE);
 		arg_end = arg + 1;
 	    }
-	    vim_free(tofree);
+	    vim_free(ptofree);
 	}
     }
 
@@ -3364,6 +3365,8 @@
 	hi = hash_find(ht, varname);
 	if (!HASHITEM_EMPTY(hi))
 	{
+	    if (var_check_fixed(HI2DI(hi)->di_flags, name))
+		return FAIL;
 	    if (var_check_ro(HI2DI(hi)->di_flags, name))
 		return FAIL;
 	    delete_var(ht, hi);
@@ -6059,6 +6062,10 @@
     tabpage_T	*tp;
 #endif
 
+    /* Only do this once. */
+    want_garbage_collect = FALSE;
+    may_garbage_collect = FALSE;
+
     /*
      * 1. Go through all accessible variables and mark all lists and dicts
      *    with copyID.
@@ -7595,8 +7602,8 @@
  * Give an error message with a function name.  Handle <SNR> things.
  */
     static void
-emsg_funcname(msg, name)
-    char	*msg;
+emsg_funcname(ermsg, name)
+    char	*ermsg;
     char_u	*name;
 {
     char_u	*p;
@@ -7605,7 +7612,7 @@
 	p = concat_str((char_u *)"<SNR>", name + 3);
     else
 	p = name;
-    EMSG2(_(msg), p);
+    EMSG2(_(ermsg), p);
     if (p != name)
 	vim_free(p);
 }
@@ -8252,6 +8259,12 @@
 	EMSG(_("E785: complete() can only be used in Insert mode"));
 	return;
     }
+
+    /* Check for undo allowed here, because if something was already inserted
+     * the line was already saved for undo and this check isn't done. */
+    if (!undo_allowed())
+	return;
+
     if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)
     {
 	EMSG(_(e_invarg));
@@ -9173,25 +9186,25 @@
     typval_T	save_key;
     int		rem;
     int		todo;
-    char_u	*msg = map ? (char_u *)"map()" : (char_u *)"filter()";
+    char_u	*ermsg = map ? (char_u *)"map()" : (char_u *)"filter()";
     int		save_did_emsg;
 
     rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_LIST)
     {
 	if ((l = argvars[0].vval.v_list) == NULL
-		|| (map && tv_check_lock(l->lv_lock, msg)))
+		|| (map && tv_check_lock(l->lv_lock, ermsg)))
 	    return;
     }
     else if (argvars[0].v_type == VAR_DICT)
     {
 	if ((d = argvars[0].vval.v_dict) == NULL
-		|| (map && tv_check_lock(d->dv_lock, msg)))
+		|| (map && tv_check_lock(d->dv_lock, ermsg)))
 	    return;
     }
     else
     {
-	EMSG2(_(e_listdictarg), msg);
+	EMSG2(_(e_listdictarg), ermsg);
 	return;
     }
 
@@ -9223,7 +9236,7 @@
 		{
 		    --todo;
 		    di = HI2DI(hi);
-		    if (tv_check_lock(di->di_tv.v_lock, msg))
+		    if (tv_check_lock(di->di_tv.v_lock, ermsg))
 			break;
 		    vimvars[VV_KEY].vv_str = vim_strsave(di->di_key);
 		    if (filter_map_one(&di->di_tv, expr, map, &rem) == FAIL
@@ -9242,7 +9255,7 @@
 	{
 	    for (li = l->lv_first; li != NULL; li = nli)
 	    {
-		if (tv_check_lock(li->li_tv.v_lock, msg))
+		if (tv_check_lock(li->li_tv.v_lock, ermsg))
 		    break;
 		nli = li->li_next;
 		if (filter_map_one(&li->li_tv, expr, map, &rem) == FAIL
@@ -9598,7 +9611,9 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    garbage_collect();
+    /* This is postponed until we are back at the toplevel, because we may be
+     * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
+    want_garbage_collect = TRUE;
 }
 
 /*
@@ -9792,6 +9807,9 @@
     varnumber_T		n;
     int			error = FALSE;
 
+    /* Position the cursor.  Needed after a message that ends in a space. */
+    windgoto(msg_row, msg_col);
+
     ++no_mapping;
     ++allow_keys;
     if (argvars[0].v_type == VAR_UNKNOWN)
@@ -11312,14 +11330,19 @@
 
 static int inputsecret_flag = 0;
 
+static void get_user_input __ARGS((typval_T *argvars, typval_T *rettv, int inputdialog));
+
 /*
- * "input()" function
- *     Also handles inputsecret() when inputsecret is set.
+ * This function is used by f_input() and f_inputdialog() functions. The third
+ * argument to f_input() specifies the type of completion to use at the
+ * prompt. The third argument to f_inputdialog() specifies the value to return
+ * when the user cancels the prompt.
  */
     static void
-f_input(argvars, rettv)
+get_user_input(argvars, rettv, inputdialog)
     typval_T	*argvars;
     typval_T	*rettv;
+    int		inputdialog;
 {
     char_u	*prompt = get_tv_string_chk(&argvars[0]);
     char_u	*p = NULL;
@@ -11369,10 +11392,10 @@
 	    if (defstr != NULL)
 		stuffReadbuffSpec(defstr);
 
-	    if (argvars[2].v_type != VAR_UNKNOWN)
+	    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)
 	    {
 		char_u	*xp_name;
-		int		xp_namelen;
+		int	xp_namelen;
 		long	argt;
 
 		rettv->vval.v_string = NULL;
@@ -11404,6 +11427,18 @@
 }
 
 /*
+ * "input()" function
+ *     Also handles inputsecret() when inputsecret is set.
+ */
+    static void
+f_input(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    get_user_input(argvars, rettv, FALSE);
+}
+
+/*
  * "inputdialog()" function
  */
     static void
@@ -11443,7 +11478,7 @@
     }
     else
 #endif
-	f_input(argvars, rettv);
+	get_user_input(argvars, rettv, TRUE);
 }
 
 /*
@@ -11471,6 +11506,7 @@
     }
 
     msg_start();
+    msg_row = Rows - 1;	/* for when 'cmdheight' > 1 */
     lines_left = Rows;	/* avoid more prompt */
     msg_scroll = TRUE;
     msg_clr_eos();
@@ -13250,7 +13286,7 @@
 	if (argvars[2].v_type != VAR_UNKNOWN)
 	    EMSG2(_(e_toomanyarg), "remove()");
 	else if ((d = argvars[0].vval.v_dict) != NULL
-		&& !tv_check_lock(d->dv_lock, (char_u *)"remove()"))
+		&& !tv_check_lock(d->dv_lock, (char_u *)"remove() argument"))
 	{
 	    key = get_tv_string_chk(&argvars[1]);
 	    if (key != NULL)
@@ -13270,7 +13306,7 @@
     else if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listdictarg), "remove()");
     else if ((l = argvars[0].vval.v_list) != NULL
-	    && !tv_check_lock(l->lv_lock, (char_u *)"remove()"))
+	    && !tv_check_lock(l->lv_lock, (char_u *)"remove() argument"))
     {
 	int	    error = FALSE;
 
@@ -14157,11 +14193,7 @@
     typval_T	*rettv;
 {
     buf_T	*buf;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
-#else
-    buf_T	*save_curbuf;
-#endif
     char_u	*varname, *bufvarname;
     typval_T	*varp;
     char_u	nbuf[NUMBUFLEN];
@@ -14178,12 +14210,7 @@
     if (buf != NULL && varname != NULL && varp != NULL)
     {
 	/* set curbuf to be our buf, temporarily */
-#ifdef FEAT_AUTOCMD
 	aucmd_prepbuf(&aco, buf);
-#else
-	save_curbuf = curbuf;
-	curbuf = buf;
-#endif
 
 	if (*varname == '&')
 	{
@@ -14210,11 +14237,7 @@
 	}
 
 	/* reset notion of buffer */
-#ifdef FEAT_AUTOCMD
 	aucmd_restbuf(&aco);
-#else
-	curbuf = save_curbuf;
-#endif
     }
 }
 
@@ -16173,7 +16196,7 @@
 	curwin->w_curswant = get_dict_number(dict, (char_u *)"curswant");
 	curwin->w_set_curswant = FALSE;
 
-	curwin->w_topline = get_dict_number(dict, (char_u *)"topline");
+	set_topline(curwin, get_dict_number(dict, (char_u *)"topline"));
 #ifdef FEAT_DIFF
 	curwin->w_topfill = get_dict_number(dict, (char_u *)"topfill");
 #endif
@@ -16218,6 +16241,7 @@
 #ifdef FEAT_VIRTUALEDIT
     dict_add_nr_str(dict, "coladd", (long)curwin->w_cursor.coladd, NULL);
 #endif
+    update_curswant();
     dict_add_nr_str(dict, "curswant", (long)curwin->w_curswant, NULL);
 
     dict_add_nr_str(dict, "topline", (long)curwin->w_topline, NULL);
@@ -16438,9 +16462,12 @@
     long	i = 0;
     long	n;
 
-    /* List must be: [fnum, lnum, col, coladd] */
-    if (arg->v_type != VAR_LIST || l == NULL
-				      || l->lv_len != (fnump == NULL ? 3 : 4))
+    /* List must be: [fnum, lnum, col, coladd], where "fnum" is only there
+     * when "fnump" isn't NULL and "coladd" is optional. */
+    if (arg->v_type != VAR_LIST
+	    || l == NULL
+	    || l->lv_len < (fnump == NULL ? 2 : 3)
+	    || l->lv_len > (fnump == NULL ? 3 : 4))
 	return FAIL;
 
     if (fnump != NULL)
@@ -16466,8 +16493,9 @@
 #ifdef FEAT_VIRTUALEDIT
     n = list_find_nr(l, i, NULL);
     if (n < 0)
-	return FAIL;
-    posp->coladd = n;
+	posp->coladd = 0;
+    else
+	posp->coladd = n;
 #endif
 
     return OK;
@@ -17759,6 +17787,13 @@
     }
     else		    /* add a new variable */
     {
+	/* Can't add "v:" variable. */
+	if (ht == &vimvarht)
+	{
+	    EMSG2(_(e_illvar), name);
+	    return;
+	}
+
 	/* Make sure the variable name is valid. */
 	for (p = varname; *p != NUL; ++p)
 	    if (!eval_isnamec1(*p) && (p == varname || !VIM_ISDIGIT(*p))
@@ -17792,7 +17827,7 @@
 }
 
 /*
- * Return TRUE if di_flags "flags" indicate read-only variable "name".
+ * Return TRUE if di_flags "flags" indicates variable "name" is read-only.
  * Also give an error message.
  */
     static int
@@ -17814,6 +17849,23 @@
 }
 
 /*
+ * Return TRUE if di_flags "flags" indicates variable "name" is fixed.
+ * Also give an error message.
+ */
+    static int
+var_check_fixed(flags, name)
+    int		flags;
+    char_u	*name;
+{
+    if (flags & DI_FLAGS_FIX)
+    {
+	EMSG2(_("E795: Cannot delete variable %s"), name);
+	return TRUE;
+    }
+    return FALSE;
+}
+
+/*
  * Return TRUE if typeval "tv" is set to be locked (immutable).
  * Also give an error message, using "name".
  */
@@ -18786,6 +18838,7 @@
 		if (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)
 		{
 		    vim_free(fudi.fd_di);
+		    vim_free(fp);
 		    goto erret;
 		}
 	    }
@@ -18963,7 +19016,8 @@
     else if (lead > 0)
     {
 	lead = 3;
-	if (eval_fname_sid(lv.ll_exp_name != NULL ? lv.ll_exp_name : *pp))
+	if ((lv.ll_exp_name != NULL && eval_fname_sid(lv.ll_exp_name))
+						       || eval_fname_sid(*pp))
 	{
 	    /* It's "s:" or "<SID>" */
 	    if (current_SID <= 0)
@@ -19685,6 +19739,7 @@
     v->di_tv.vval.v_list = &fc.l_varlist;
     vim_memset(&fc.l_varlist, 0, sizeof(list_T));
     fc.l_varlist.lv_refcount = 99999;
+    fc.l_varlist.lv_lock = VAR_FIXED;
 
     /*
      * Set a:firstline to "firstline" and a:lastline to "lastline".
@@ -19761,7 +19816,7 @@
 	    if (p_verbose >= 14)
 	    {
 		char_u	buf[MSG_BUF_LEN];
-		char_u	numbuf[NUMBUFLEN];
+		char_u	numbuf2[NUMBUFLEN];
 		char_u	*tofree;
 
 		msg_puts((char_u *)"(");
@@ -19773,8 +19828,8 @@
 			msg_outnum((long)argvars[i].vval.v_number);
 		    else
 		    {
-			trunc_string(tv2string(&argvars[i], &tofree, numbuf, 0),
-							    buf, MSG_BUF_CLEN);
+			trunc_string(tv2string(&argvars[i], &tofree,
+					      numbuf2, 0), buf, MSG_BUF_CLEN);
 			msg_puts(buf);
 			vim_free(tofree);
 		    }
@@ -19852,13 +19907,13 @@
 	else
 	{
 	    char_u	buf[MSG_BUF_LEN];
-	    char_u	numbuf[NUMBUFLEN];
+	    char_u	numbuf2[NUMBUFLEN];
 	    char_u	*tofree;
 
 	    /* The value may be very long.  Skip the middle part, so that we
 	     * have some idea how it starts and ends. smsg() would always
 	     * truncate it at the end. */
-	    trunc_string(tv2string(fc.rettv, &tofree, numbuf, 0),
+	    trunc_string(tv2string(fc.rettv, &tofree, numbuf2, 0),
 							   buf, MSG_BUF_CLEN);
 	    smsg((char_u *)_("%s returning %s"), sourcing_name, buf);
 	    vim_free(tofree);
diff -Naur vim70.orig/src/ex_cmds2.c vim70/src/ex_cmds2.c
--- vim70.orig/src/ex_cmds2.c	2006-04-17 03:19:07.000000000 -0700
+++ vim70/src/ex_cmds2.c	2006-09-11 08:23:15.000000000 -0700
@@ -3648,13 +3648,13 @@
  * Return FALSE when not sourcing a file.
  */
     int
-source_finished(getline, cookie)
-    char_u	*(*getline) __ARGS((int, void *, int));
+source_finished(fgetline, cookie)
+    char_u	*(*fgetline) __ARGS((int, void *, int));
     void	*cookie;
 {
-    return (getline_equal(getline, cookie, getsourceline)
+    return (getline_equal(fgetline, cookie, getsourceline)
 	    && ((struct source_cookie *)getline_cookie(
-						 getline, cookie))->finished);
+						fgetline, cookie))->finished);
 }
 #endif
 
diff -Naur vim70.orig/src/ex_cmds.c vim70/src/ex_cmds.c
--- vim70.orig/src/ex_cmds.c	2006-04-22 11:56:56.000000000 -0700
+++ vim70/src/ex_cmds.c	2006-09-11 09:03:01.000000000 -0700
@@ -95,7 +95,10 @@
 		_("<%s>%s%s  %d,  Hex %02x,  Octal %03o"),
 					   transchar(c), buf1, buf2, c, c, c);
 #ifdef FEAT_MBYTE
-	c = cc[ci++];
+	if (enc_utf8)
+	    c = cc[ci++];
+	else
+	    c = 0;
 #endif
     }
 
@@ -108,7 +111,7 @@
 	if (len > 0)
 	    IObuff[len++] = ' ';
 	IObuff[len++] = '<';
-	if (utf_iscomposing(c)
+	if (enc_utf8 && utf_iscomposing(c)
 # ifdef USE_GUI
 		&& !gui.in_use
 # endif
@@ -120,7 +123,10 @@
 				    : _("> %d, Hex %08x, Octal %o"), c, c, c);
 	if (ci == MAX_MCO)
 	    break;
-	c = cc[ci++];
+	if (enc_utf8)
+	    c = cc[ci++];
+	else
+	    c = 0;
     }
 #endif
 
@@ -185,6 +191,7 @@
 	    new_indent = indent;
 	else
 	{
+	    has_tab = FALSE;	/* avoid uninit warnings */
 	    len = linelen(eap->cmdidx == CMD_right ? &has_tab
 						   : NULL) - get_indent();
 
@@ -1772,10 +1779,9 @@
 				? (st_old.st_mode & 0020)
 				: (st_old.st_mode & 0002))))
 	{
-	    int	tt;
+	    int	tt = msg_didany;
 
 	    /* avoid a wait_return for this message, it's annoying */
-	    tt = msg_didany;
 	    EMSG2(_("E137: Viminfo file is not writable: %s"), fname);
 	    msg_didany = tt;
 	    fclose(fp_in);
@@ -2458,6 +2464,8 @@
 #ifdef FEAT_AUTOCMD
 	apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);
 #endif
+	/* Change directories when the 'acd' option is set. */
+	DO_AUTOCHDIR
     }
     /* print full file name if :cd used */
     fileinfo(FALSE, FALSE, eap->forceit);
@@ -2675,8 +2683,13 @@
 				 eap, eap->append, eap->forceit, TRUE, FALSE);
 
 	/* After ":saveas fname" reset 'readonly'. */
-	if (eap->cmdidx == CMD_saveas && retval == OK)
-	    curbuf->b_p_ro = FALSE;
+	if (eap->cmdidx == CMD_saveas)
+	{
+	    if (retval == OK)
+		curbuf->b_p_ro = FALSE;
+	    /* Change directories when the 'acd' option is set. */
+	    DO_AUTOCHDIR
+	}
     }
 
 theend:
@@ -3547,11 +3560,9 @@
 	foldUpdateAll(curwin);
 #endif
 
-#ifdef FEAT_AUTOCHDIR
-	if (p_acd && curbuf->b_ffname != NULL
-				     && vim_chdirfile(curbuf->b_ffname) == OK)
-	    shorten_fnames(TRUE);
-#endif
+	/* Change directories when the 'acd' option is set. */
+	DO_AUTOCHDIR
+
 	/*
 	 * Careful: open_buffer() and apply_autocmds() may change the current
 	 * buffer and window.
@@ -3718,12 +3729,8 @@
     if (p_im)
 	need_start_insertmode = TRUE;
 
-#ifdef FEAT_AUTOCHDIR
-    /* Change directories when the acd option is set on. */
-    if (p_acd && curbuf->b_ffname != NULL
-				     && vim_chdirfile(curbuf->b_ffname) == OK)
-	shorten_fnames(TRUE);
-#endif
+    /* Change directories when the 'acd' option is set. */
+    DO_AUTOCHDIR
 
 #if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG)
     if (gui.in_use && curbuf->b_ffname != NULL)
diff -Naur vim70.orig/src/ex_cmds.h vim70/src/ex_cmds.h
--- vim70.orig/src/ex_cmds.h	2006-04-07 02:44:46.000000000 -0700
+++ vim70/src/ex_cmds.h	2006-07-14 08:51:21.000000000 -0700
@@ -262,7 +262,7 @@
 EX(CMD_comclear,	"comclear",	ex_comclear,
 			TRLBAR|CMDWIN),
 EX(CMD_compiler,	"compiler",	ex_compiler,
-			BANG|TRLBAR|WORD1),
+			BANG|TRLBAR|WORD1|CMDWIN),
 EX(CMD_continue,	"continue",	ex_continue,
 			TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_confirm,		"confirm",	ex_wrongmodifier,
diff -Naur vim70.orig/src/ex_docmd.c vim70/src/ex_docmd.c
--- vim70.orig/src/ex_docmd.c	2006-05-05 09:33:19.000000000 -0700
+++ vim70/src/ex_docmd.c	2006-09-11 09:27:48.000000000 -0700
@@ -58,9 +58,9 @@
 #endif
 
 #ifdef FEAT_EVAL
-static char_u	*do_one_cmd __ARGS((char_u **, int, struct condstack *, char_u *(*getline)(int, void *, int), void *cookie));
+static char_u	*do_one_cmd __ARGS((char_u **, int, struct condstack *, char_u *(*fgetline)(int, void *, int), void *cookie));
 #else
-static char_u	*do_one_cmd __ARGS((char_u **, int, char_u *(*getline)(int, void *, int), void *cookie));
+static char_u	*do_one_cmd __ARGS((char_u **, int, char_u *(*fgetline)(int, void *, int), void *cookie));
 static int	if_level = 0;		/* depth in :if */
 #endif
 static char_u	*find_command __ARGS((exarg_T *eap, int *full));
@@ -831,10 +831,13 @@
 
     /*
      * If requested, store and reset the global values controlling the
-     * exception handling (used when debugging).
+     * exception handling (used when debugging).  Otherwise clear it to avoid
+     * a bogus compiler warning when the optimizer uses inline functions...
      */
-    else if (flags & DOCMD_EXCRESET)
+    if (flags & DOCMD_EXCRESET)
 	save_dbg_stuff(&debug_saved);
+    else
+	memset(&debug_saved, 0, 1);
 
     initial_trylevel = trylevel;
 
@@ -1574,24 +1577,24 @@
 #endif
 
 /*
- * If "getline" is get_loop_line(), return TRUE if the getline it uses equals
- * "func".  * Otherwise return TRUE when "getline" equals "func".
+ * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
+ * "func".  * Otherwise return TRUE when "fgetline" equals "func".
  */
 /*ARGSUSED*/
     int
-getline_equal(getline, cookie, func)
-    char_u	*(*getline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for getline() */
+getline_equal(fgetline, cookie, func)
+    char_u	*(*fgetline) __ARGS((int, void *, int));
+    void	*cookie;		/* argument for fgetline() */
     char_u	*(*func) __ARGS((int, void *, int));
 {
 #ifdef FEAT_EVAL
     char_u		*(*gp) __ARGS((int, void *, int));
     struct loop_cookie *cp;
 
-    /* When "getline" is "get_loop_line()" use the "cookie" to find the
+    /* When "fgetline" is "get_loop_line()" use the "cookie" to find the
      * function that's orignally used to obtain the lines.  This may be nested
      * several levels. */
-    gp = getline;
+    gp = fgetline;
     cp = (struct loop_cookie *)cookie;
     while (gp == get_loop_line)
     {
@@ -1600,29 +1603,29 @@
     }
     return gp == func;
 #else
-    return getline == func;
+    return fgetline == func;
 #endif
 }
 
 #if defined(FEAT_EVAL) || defined(FEAT_MBYTE) || defined(PROTO)
 /*
- * If "getline" is get_loop_line(), return the cookie used by the original
+ * If "fgetline" is get_loop_line(), return the cookie used by the original
  * getline function.  Otherwise return "cookie".
  */
 /*ARGSUSED*/
     void *
-getline_cookie(getline, cookie)
-    char_u	*(*getline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for getline() */
+getline_cookie(fgetline, cookie)
+    char_u	*(*fgetline) __ARGS((int, void *, int));
+    void	*cookie;		/* argument for fgetline() */
 {
 # ifdef FEAT_EVAL
     char_u		*(*gp) __ARGS((int, void *, int));
     struct loop_cookie *cp;
 
-    /* When "getline" is "get_loop_line()" use the "cookie" to find the
+    /* When "fgetline" is "get_loop_line()" use the "cookie" to find the
      * cookie that's orignally used to obtain the lines.  This may be nested
      * several levels. */
-    gp = getline;
+    gp = fgetline;
     cp = (struct loop_cookie *)cookie;
     while (gp == get_loop_line)
     {
@@ -1648,7 +1651,7 @@
  * 5. parse arguments
  * 6. switch on command name
  *
- * Note: "getline" can be NULL.
+ * Note: "fgetline" can be NULL.
  *
  * This function may be called recursively!
  */
@@ -1663,14 +1666,14 @@
 #ifdef FEAT_EVAL
 			    cstack,
 #endif
-				    getline, cookie)
+				    fgetline, cookie)
     char_u		**cmdlinep;
     int			sourcing;
 #ifdef FEAT_EVAL
     struct condstack	*cstack;
 #endif
-    char_u		*(*getline) __ARGS((int, void *, int));
-    void		*cookie;		/* argument for getline() */
+    char_u		*(*fgetline) __ARGS((int, void *, int));
+    void		*cookie;		/* argument for fgetline() */
 {
     char_u		*p;
     linenr_T		lnum;
@@ -1698,7 +1701,7 @@
     if (quitmore
 #ifdef FEAT_EVAL
 	    /* avoid that a function call in 'statusline' does this */
-	    && !getline_equal(getline, cookie, get_func_line)
+	    && !getline_equal(fgetline, cookie, get_func_line)
 #endif
 	    )
 	--quitmore;
@@ -1710,6 +1713,10 @@
     save_cmdmod = cmdmod;
     vim_memset(&cmdmod, 0, sizeof(cmdmod));
 
+    /* "#!anything" is handled like a comment. */
+    if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!')
+	goto doend;
+
     /*
      * Repeat until no more command modifiers are found.
      */
@@ -1724,8 +1731,8 @@
 
 	/* in ex mode, an empty line works like :+ */
 	if (*ea.cmd == NUL && exmode_active
-			&& (getline_equal(getline, cookie, getexmodeline)
-			    || getline_equal(getline, cookie, getexline))
+			&& (getline_equal(fgetline, cookie, getexmodeline)
+			    || getline_equal(fgetline, cookie, getexline))
 			&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
 	{
 	    ea.cmd = (char_u *)"+";
@@ -1914,9 +1921,9 @@
     /* Count this line for profiling if ea.skip is FALSE. */
     if (do_profiling == PROF_YES && !ea.skip)
     {
-	if (getline_equal(getline, cookie, get_func_line))
-	    func_line_exec(getline_cookie(getline, cookie));
-	else if (getline_equal(getline, cookie, getsourceline))
+	if (getline_equal(fgetline, cookie, get_func_line))
+	    func_line_exec(getline_cookie(fgetline, cookie));
+	else if (getline_equal(fgetline, cookie, getsourceline))
 	    script_line_exec();
     }
 #endif
@@ -2585,7 +2592,7 @@
  * The "ea" structure holds the arguments that can be used.
  */
     ea.cmdlinep = cmdlinep;
-    ea.getline = getline;
+    ea.getline = fgetline;
     ea.cookie = cookie;
 #ifdef FEAT_EVAL
     ea.cstack = cstack;
@@ -2623,9 +2630,9 @@
 	do_throw(cstack);
     else if (check_cstack)
     {
-	if (source_finished(getline, cookie))
+	if (source_finished(fgetline, cookie))
 	    do_finish(&ea, TRUE);
-	else if (getline_equal(getline, cookie, get_func_line)
+	else if (getline_equal(fgetline, cookie, get_func_line)
 						   && current_func_returned())
 	    do_return(&ea, TRUE, FALSE, NULL);
     }
@@ -6289,7 +6296,6 @@
     exarg_T	*eap;
 {
     tabpage_T	*tp;
-    int		h = tabline_height();
 
 # ifdef FEAT_CMDWIN
     if (cmdwin_type != 0)
@@ -6321,9 +6327,6 @@
 	       )
 		tabpage_close(eap->forceit);
 	}
-
-    if (h != tabline_height())
-	shell_new_rows();
 }
 
 /*
@@ -6335,7 +6338,6 @@
 {
     tabpage_T	*tp;
     int		done;
-    int		h = tabline_height();
 
 # ifdef FEAT_CMDWIN
     if (cmdwin_type != 0)
@@ -6364,9 +6366,6 @@
 		    break;
 	    }
 	}
-
-    if (h != tabline_height())
-	shell_new_rows();
 }
 
 /*
@@ -6390,6 +6389,8 @@
 /*
  * Close tab page "tp", which is not the current tab page.
  * Note that autocommands may make "tp" invalid.
+ * Also takes care of the tab pages line disappearing when closing the
+ * last-but-one tab page.
  */
     void
 tabpage_close_other(tp, forceit)
@@ -6398,6 +6399,7 @@
 {
     int		done = 0;
     win_T	*wp;
+    int		h = tabline_height();
 
     /* Limit to 1000 windows, autocommands may add a window while we close
      * one.  OK, so I'm paranoid... */
@@ -6411,7 +6413,10 @@
 	if (!valid_tabpage(tp) || tp->tp_firstwin == wp)
 	    break;
     }
+
     redraw_tabline = TRUE;
+    if (h != tabline_height())
+	shell_new_rows();
 }
 
 /*
@@ -8417,6 +8422,15 @@
 	else
 	    EMSG2(_(e_invarg2), eap->arg);
     }
+
+    /* Make sure redirection is not off.  Can happen for cmdline completion
+     * that indirectly invokes a command to catch its output. */
+    if (redir_fd != NULL
+#ifdef FEAT_EVAL
+			  || redir_reg || redir_vname
+#endif
+							)
+	redir_off = FALSE;
 }
 
 /*
diff -Naur vim70.orig/src/ex_getln.c vim70/src/ex_getln.c
--- vim70.orig/src/ex_getln.c	2006-04-30 08:32:01.000000000 -0700
+++ vim70/src/ex_getln.c	2006-09-11 09:27:49.000000000 -0700
@@ -324,6 +324,9 @@
      */
     for (;;)
     {
+	redir_off = TRUE;	/* Don't redirect the typed command.
+				   Repeated, because a ":redir" inside
+				   completion may switch it on. */
 #ifdef USE_ON_FLY_SCROLL
 	dont_scroll = FALSE;	/* allow scrolling here */
 #endif
@@ -4521,7 +4524,9 @@
     flags |= EW_FILE | EW_EXEC;
 
     /* For an absolute name we don't use $PATH. */
-    if ((pat[0] == '.' && (vim_ispathsep(pat[1])
+    if (mch_isFullName(pat))
+	path = (char_u *)" ";
+    else if ((pat[0] == '.' && (vim_ispathsep(pat[1])
 			    || (pat[1] == '.' && vim_ispathsep(pat[2])))))
 	path = (char_u *)".";
     else
@@ -4534,6 +4539,9 @@
     ga_init2(&ga, (int)sizeof(char *), 10);
     for (s = path; *s != NUL; s = e)
     {
+	if (*s == ' ')
+	    ++s;	/* Skip space used for absolute path name. */
+
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
 	e = vim_strchr(s, ';');
 #else
@@ -5982,6 +5990,8 @@
     typestr[0] = cmdwin_type;
     typestr[1] = NUL;
     apply_autocmds(EVENT_CMDWINENTER, typestr, typestr, FALSE, curbuf);
+    if (restart_edit != 0)	/* autocmd with ":startinsert" */
+	stuffcharReadbuff(K_NOP);
 # endif
 
     i = RedrawingDisabled;
diff -Naur vim70.orig/src/fileio.c vim70/src/fileio.c
--- vim70.orig/src/fileio.c	2006-04-30 08:28:57.000000000 -0700
+++ vim70/src/fileio.c	2006-09-11 09:04:57.000000000 -0700
@@ -316,6 +316,9 @@
      * display the line. */
     ex_no_reprint = TRUE;
 
+    /* don't display the file info for another buffer now */
+    need_fileinfo = FALSE;
+
     /*
      * For Unix: Use the short file name whenever possible.
      * Avoids problems with networks and when directory names are changed.
@@ -6450,17 +6453,10 @@
     int		old_ro = buf->b_p_ro;
     buf_T	*savebuf;
     int		saved = OK;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
 
     /* set curwin/curbuf for "buf" and save some things */
     aucmd_prepbuf(&aco, buf);
-#else
-    buf_T	*save_curbuf = curbuf;
-
-    curbuf = buf;
-    curwin->w_buffer = buf;
-#endif
 
     /* We only want to read the text from the file, not reset the syntax
      * highlighting, clear marks, diff status, etc.  Force the fileformat
@@ -6573,14 +6569,9 @@
 	    curbuf->b_p_ro |= old_ro;
     }
 
-#ifdef FEAT_AUTOCMD
     /* restore curwin/curbuf and a few other things */
     aucmd_restbuf(&aco);
     /* Careful: autocommands may have made "buf" invalid! */
-#else
-    curwin->w_buffer = save_curbuf;
-    curbuf = save_curbuf;
-#endif
 }
 
 /*ARGSUSED*/
@@ -6992,6 +6983,7 @@
     {"FocusLost",	EVENT_FOCUSLOST},
     {"FuncUndefined",	EVENT_FUNCUNDEFINED},
     {"GUIEnter",	EVENT_GUIENTER},
+    {"GUIFailed",	EVENT_GUIFAILED},
     {"InsertChange",	EVENT_INSERTCHANGE},
     {"InsertEnter",	EVENT_INSERTENTER},
     {"InsertLeave",	EVENT_INSERTLEAVE},
@@ -8088,6 +8080,7 @@
  * Search a window for the current buffer.  Save the cursor position and
  * screen offset.
  * Set "curbuf" and "curwin" to match "buf".
+ * When FEAT_AUTOCMD is not defined another version is used, see below.
  */
     void
 aucmd_prepbuf(aco, buf)
@@ -8151,6 +8144,7 @@
 /*
  * Cleanup after executing autocommands for a (hidden) buffer.
  * Restore the window as it was (if possible).
+ * When FEAT_AUTOCMD is not defined another version is used, see below.
  */
     void
 aucmd_restbuf(aco)
@@ -9063,8 +9057,38 @@
     return retval;
 }
 
+#else	/* FEAT_AUTOCMD */
+
+/*
+ * Prepare for executing commands for (hidden) buffer "buf".
+ * This is the non-autocommand version, it simply saves "curbuf" and sets
+ * "curbuf" and "curwin" to match "buf".
+ */
+    void
+aucmd_prepbuf(aco, buf)
+    aco_save_T	*aco;		/* structure to save values in */
+    buf_T	*buf;		/* new curbuf */
+{
+    aco->save_buf = buf;
+    curbuf = buf;
+    curwin->w_buffer = buf;
+}
+
+/*
+ * Restore after executing commands for a (hidden) buffer.
+ * This is the non-autocommand version.
+ */
+    void
+aucmd_restbuf(aco)
+    aco_save_T	*aco;		/* structure holding saved values */
+{
+    curbuf = aco->save_buf;
+    curwin->w_buffer = curbuf;
+}
+
 #endif	/* FEAT_AUTOCMD */
 
+
 #if defined(FEAT_AUTOCMD) || defined(FEAT_WILDIGN) || defined(PROTO)
 /*
  * Try matching a filename with a "pattern" ("prog" is NULL), or use the
diff -Naur vim70.orig/src/getchar.c vim70/src/getchar.c
--- vim70.orig/src/getchar.c	2006-05-03 10:29:21.000000000 -0700
+++ vim70/src/getchar.c	2006-09-11 09:00:04.000000000 -0700
@@ -1451,7 +1451,8 @@
 {
     updatescript(0);
 #ifdef FEAT_EVAL
-    garbage_collect();
+    if (may_garbage_collect)
+	garbage_collect();
 #endif
 }
 
@@ -1502,6 +1503,13 @@
     int		i;
 #endif
 
+#ifdef FEAT_EVAL
+    /* Do garbage collection when garbagecollect() was called previously and
+     * we are now at the toplevel. */
+    if (may_garbage_collect && want_garbage_collect)
+	garbage_collect();
+#endif
+
     /*
      * If a character was put back with vungetc, it was already processed.
      * Return it directly.
@@ -1511,13 +1519,13 @@
 	c = old_char;
 	old_char = -1;
 	mod_mask = old_mod_mask;
-	return c;
     }
-
-    mod_mask = 0x0;
-    last_recorded_len = 0;
-    for (;;)			/* this is done twice if there are modifiers */
+    else
     {
+      mod_mask = 0x0;
+      last_recorded_len = 0;
+      for (;;)			/* this is done twice if there are modifiers */
+      {
 	if (mod_mask)		/* no mapping after modifier has been read */
 	{
 	    ++no_mapping;
@@ -1695,8 +1703,20 @@
 	}
 #endif
 
-	return c;
+	break;
+      }
     }
+
+#ifdef FEAT_EVAL
+    /*
+     * In the main loop "may_garbage_collect" can be set to do garbage
+     * collection in the first next vgetc().  It's disabled after that to
+     * avoid internally used Lists and Dicts to be freed.
+     */
+    may_garbage_collect = FALSE;
+#endif
+
+    return c;
 }
 
 /*
diff -Naur vim70.orig/src/globals.h vim70/src/globals.h
--- vim70.orig/src/globals.h	2006-04-30 06:16:23.000000000 -0700
+++ vim70/src/globals.h	2006-09-11 09:00:04.000000000 -0700
@@ -300,9 +300,16 @@
 #endif
 
 #ifdef FEAT_EVAL
-EXTERN scid_T	current_SID INIT(= 0);	    /* ID of script being sourced or
-					       was sourced to define the
-					       current function. */
+/* Garbage collection can only take place when we are sure there are no Lists
+ * or Dictionaries being used internally.  This is flagged with
+ * "may_garbage_collect" when we are at the toplevel.
+ * "want_garbage_collect" is set by the garbagecollect() function, which means
+ * we do garbage collection before waiting for a char at the toplevel. */
+EXTERN int	may_garbage_collect INIT(= FALSE);
+EXTERN int	want_garbage_collect INIT(= FALSE);
+
+/* ID of script being sourced or was sourced to define the current function. */
+EXTERN scid_T	current_SID INIT(= 0);
 #endif
 
 #if defined(FEAT_EVAL) || defined(FEAT_SYN_HL)
@@ -1441,7 +1448,7 @@
 EXTERN char_u e_readonly[]	INIT(= N_("E45: 'readonly' option is set (add ! to override)"));
 #ifdef FEAT_EVAL
 EXTERN char_u e_readonlyvar[]	INIT(= N_("E46: Cannot change read-only variable \"%s\""));
-EXTERN char_u e_readonlysbx[]	INIT(= N_("E46: Cannot set variable in the sandbox: \"%s\""));
+EXTERN char_u e_readonlysbx[]	INIT(= N_("E794: Cannot set variable in the sandbox: \"%s\""));
 #endif
 #ifdef FEAT_QUICKFIX
 EXTERN char_u e_readerrf[]	INIT(= N_("E47: Error while reading errorfile"));
diff -Naur vim70.orig/src/gui_at_fs.c vim70/src/gui_at_fs.c
--- vim70.orig/src/gui_at_fs.c	2005-07-09 04:30:17.000000000 -0700
+++ vim70/src/gui_at_fs.c	2006-07-14 08:51:21.000000000 -0700
@@ -1861,27 +1861,27 @@
     XtPointer	pnew;
 {
     SFDir	*dir;
-    int		nw;
+    int		nw = (int)(long)pnew;
 
     dir = &(SFdirs[SFdirPtr + (int)(long)n]);
 
 #ifdef FEAT_GUI_NEXTAW
-    if ((int)(long)pnew < 0)
+    if (nw < 0)
     {
-	if ((int)(long)pnew > -SFvScrollHeight)
-	    (int)(long)pnew = -1;
+	if (nw > -SFvScrollHeight)
+	    nw = -1;
 	else
-	    (int)(long)pnew = -SFlistSize;
+	    nw = -SFlistSize;
     }
-    else if ((int)(long)pnew > 0)
+    else if (nw > 0)
     {
-	if ((int)(long)pnew < SFvScrollHeight)
-	    (int)(long)pnew = 1;
+	if (nw < SFvScrollHeight)
+	    nw = 1;
 	else
-	    (int)(long)pnew = SFlistSize;
+	    nw = SFlistSize;
     }
 #endif
-    nw = dir->vOrigin + (int)(long)pnew;
+    nw += dir->vOrigin;
 
     if (nw > dir->nEntries - SFlistSize)
 	nw = dir->nEntries - SFlistSize;
@@ -1941,27 +1941,27 @@
     XtPointer	pnew;
 {
     SFDir	*dir;
-    int		nw;
+    int		nw = (int)(long)pnew;
 
     dir = &(SFdirs[SFdirPtr + (int)(long)n]);
 
 #ifdef FEAT_GUI_NEXTAW
-    if ((int)(long)pnew < 0)
+    if (nw < 0)
     {
-	if ((int)(long)pnew > -SFhScrollWidth)
-	    (int)(long)pnew = -1;
+	if (nw > -SFhScrollWidth)
+	    nw = -1;
 	else
-	    (int)(long)pnew = -SFcharsPerEntry;
+	    nw = -SFcharsPerEntry;
     }
-    else if ((int)(long)pnew > 0)
+    else if (nw > 0)
     {
-	if ((int)(long)pnew < SFhScrollWidth)
-	    (int)(long)pnew = 1;
+	if (nw < SFhScrollWidth)
+	    nw = 1;
 	else
-	    (int)(long)pnew = SFcharsPerEntry;
+	    nw = SFcharsPerEntry;
     }
 #endif
-    nw = dir->hOrigin + (int)(long)pnew;
+    nw += dir->hOrigin;
 
     if (nw > dir->nChars - SFcharsPerEntry)
 	nw = dir->nChars - SFcharsPerEntry;
@@ -2038,26 +2038,26 @@
     XtPointer	client_data;
     XtPointer	pnew;
 {
-    int		nw;
+    int		nw = (int)(long)pnew;
     float	f;
 
 #ifdef FEAT_GUI_NEXTAW
-    if ((int)(long)pnew < 0)
+    if (nw < 0)
     {
-	if ((int)(long)pnew > -SFpathScrollWidth)
-	    (int)(long)pnew = -1;
+	if (nw > -SFpathScrollWidth)
+	    nw = -1;
 	else
-	    (int)(long)pnew = -3;
+	    nw = -3;
     }
-    else if ((int)(long)pnew > 0)
+    else if (nw > 0)
     {
-	if ((int)(long)pnew < SFpathScrollWidth)
-	    (int)(long)pnew = 1;
+	if (nw < SFpathScrollWidth)
+	    nw = 1;
 	else
-	    (int)(long)pnew = 3;
+	    nw = 3;
     }
 #endif
-    nw = SFdirPtr + (int)(long)pnew;
+    nw += SFdirPtr;
 
     if (nw > SFdirEnd - 3)
 	nw = SFdirEnd - 3;
diff -Naur vim70.orig/src/gui_beval.c vim70/src/gui_beval.c
--- vim70.orig/src/gui_beval.c	2006-05-04 12:29:51.000000000 -0700
+++ vim70/src/gui_beval.c	2006-09-11 08:23:15.000000000 -0700
@@ -926,7 +926,7 @@
 #  define IS_NONPRINTABLE(c) (((c) < 0x20 && (c) != TAB && (c) != NL) \
 			      || (c) == DEL)
     static void
-set_printable_label_text(GtkLabel *label, char_u *msg)
+set_printable_label_text(GtkLabel *label, char_u *text)
 {
     char_u	    *convbuf = NULL;
     char_u	    *buf;
@@ -940,14 +940,14 @@
     /* Convert to UTF-8 if it isn't already */
     if (output_conv.vc_type != CONV_NONE)
     {
-	convbuf = string_convert(&output_conv, msg, NULL);
+	convbuf = string_convert(&output_conv, text, NULL);
 	if (convbuf != NULL)
-	    msg = convbuf;
+	    text = convbuf;
     }
 
     /* First let's see how much we need to allocate */
     len = 0;
-    for (p = msg; *p != NUL; p += charlen)
+    for (p = text; *p != NUL; p += charlen)
     {
 	if ((*p & 0x80) == 0)	/* be quick for ASCII */
 	{
@@ -992,7 +992,7 @@
 				     (unsigned long)pixel, &color);
 
 	pdest = buf;
-	p = msg;
+	p = text;
 	while (*p != NUL)
 	{
 	    /* Be quick for ASCII */
diff -Naur vim70.orig/src/gui.c vim70/src/gui.c
--- vim70.orig/src/gui.c	2006-05-03 04:00:59.000000000 -0700
+++ vim70/src/gui.c	2006-09-11 09:28:13.000000000 -0700
@@ -187,9 +187,10 @@
 #endif
 
 #ifdef FEAT_AUTOCMD
-    /* If the GUI started successfully, trigger the GUIEnter event */
-    if (gui.in_use)
-	apply_autocmds(EVENT_GUIENTER, NULL, NULL, FALSE, curbuf);
+    /* If the GUI started successfully, trigger the GUIEnter event, otherwise
+     * the GUIFailed event. */
+    apply_autocmds(gui.in_use ? EVENT_GUIENTER : EVENT_GUIFAILED,
+						   NULL, NULL, FALSE, curbuf);
 #endif
 
     --recursive;
@@ -3733,6 +3734,12 @@
     if (dont_scroll || input_available())
 	return;
 #endif
+#ifdef FEAT_INS_EXPAND
+    /* Disallow scrolling the current window when the completion popup menu is
+     * visible. */
+    if ((sb->wp == NULL || sb->wp == curwin) && pum_visible())
+	return;
+#endif
 
 #ifdef FEAT_RIGHTLEFT
     if (sb->wp == NULL && curwin->w_p_rl)
@@ -4207,6 +4214,12 @@
 	updateWindow(wp);   /* update window, status line, and cmdline */
     }
 
+#ifdef FEAT_INS_EXPAND
+    /* May need to redraw the popup menu. */
+    if (pum_visible())
+	pum_redraw();
+#endif
+
     return (wp == curwin && !equalpos(curwin->w_cursor, old_cursor));
 }
 
@@ -4515,7 +4528,7 @@
     int		y;
 {
     win_T	*wp;
-    char_u	st[6];
+    char_u	st[8];
 
     /* Ignore this while still starting up. */
     if (!gui.in_use || gui.starting)
@@ -4603,11 +4616,11 @@
     /* Don't move the mouse when it's left or right of the Vim window */
     if (x < 0 || x > Columns * gui.char_width)
 	return;
+    if (y >= 0
 # ifdef FEAT_WINDOWS
-    if (Y_2_ROW(y) >= tabline_height())
-# else
-    if (y >= 0)
+	    && Y_2_ROW(y) >= tabline_height()
 # endif
+       )
 	wp = xy2win(x, y);
     if (wp != curwin && wp != NULL)	/* If in other than current window */
     {
diff -Naur vim70.orig/src/gui_gtk.c vim70/src/gui_gtk.c
--- vim70.orig/src/gui_gtk.c	2006-05-05 04:52:52.000000000 -0700
+++ vim70/src/gui_gtk.c	2006-09-11 08:23:15.000000000 -0700
@@ -957,15 +957,15 @@
 get_menu_position(vimmenu_T *menu)
 {
     vimmenu_T	*node;
-    int		index = 0;
+    int		idx = 0;
 
     for (node = menu->parent->children; node != menu; node = node->next)
     {
 	g_return_val_if_fail(node != NULL, -1);
-	++index;
+	++idx;
     }
 
-    return index;
+    return idx;
 }
 #endif /* FEAT_TOOLBAR && HAVE_GTK2 */
 
@@ -2127,7 +2127,7 @@
     char    **ync;  /* "yes no cancel" */
     char    **buttons;
     int	    n_buttons = 0;
-    int	    index;
+    int	    idx;
 
     button_string = vim_strsave(button_string); /* must be writable */
     if (button_string == NULL)
@@ -2161,12 +2161,12 @@
      * Well, apparently somebody changed his mind: with GTK 2.2.4 it works the
      * other way around...
      */
-    for (index = 1; index <= n_buttons; ++index)
+    for (idx = 1; idx <= n_buttons; ++idx)
     {
 	char	*label;
 	char_u	*label8;
 
-	label = buttons[index - 1];
+	label = buttons[idx - 1];
 	/*
 	 * Perform some guesswork to find appropriate stock items for the
 	 * buttons.  We have to compare with a sample of the translated
@@ -2188,7 +2188,7 @@
 	    else if (button_equal(label, "Cancel")) label = GTK_STOCK_CANCEL;
 	}
 	label8 = CONVERT_TO_UTF8((char_u *)label);
-	gtk_dialog_add_button(dialog, (const gchar *)label8, index);
+	gtk_dialog_add_button(dialog, (const gchar *)label8, idx);
 	CONVERT_TO_UTF8_FREE(label8);
     }
 
diff -Naur vim70.orig/src/gui_gtk_x11.c vim70/src/gui_gtk_x11.c
--- vim70.orig/src/gui_gtk_x11.c	2006-05-04 23:58:59.000000000 -0700
+++ vim70/src/gui_gtk_x11.c	2006-09-11 08:23:16.000000000 -0700
@@ -3233,12 +3233,12 @@
 on_select_tab(
 	GtkNotebook	*notebook,
 	GtkNotebookPage *page,
-	gint		index,
+	gint		idx,
 	gpointer	data)
 {
     if (!ignore_tabline_evt)
     {
-	if (send_tabline_event(index + 1) && gtk_main_level() > 0)
+	if (send_tabline_event(idx + 1) && gtk_main_level() > 0)
 	    gtk_main_quit();
     }
 }
@@ -5303,13 +5303,13 @@
 # ifdef HAVE_GTK2
     if (font != NOFONT)
     {
-	char	*name = pango_font_description_to_string(font);
+	char	*pangoname = pango_font_description_to_string(font);
 
-	if (name != NULL)
+	if (pangoname != NULL)
 	{
-	    char_u	*s = vim_strsave((char_u *)name);
+	    char_u	*s = vim_strsave((char_u *)pangoname);
 
-	    g_free(name);
+	    g_free(pangoname);
 	    return s;
 	}
     }
@@ -6241,24 +6241,20 @@
 {
     GdkGCValues values;
     GdkGC *invert_gc;
-    GdkColor foreground;
-    GdkColor background;
 
     if (gui.drawarea->window == NULL)
 	return;
 
-    foreground.pixel = gui.norm_pixel ^ gui.back_pixel;
-    background.pixel = gui.norm_pixel ^ gui.back_pixel;
-
-    values.foreground = foreground;
-    values.background = background;
+    values.foreground.pixel = gui.norm_pixel ^ gui.back_pixel;
+    values.background.pixel = gui.norm_pixel ^ gui.back_pixel;
     values.function = GDK_XOR;
     invert_gc = gdk_gc_new_with_values(gui.drawarea->window,
 				       &values,
 				       GDK_GC_FOREGROUND |
 				       GDK_GC_BACKGROUND |
 				       GDK_GC_FUNCTION);
-    gdk_gc_set_exposures(invert_gc, gui.visibility != GDK_VISIBILITY_UNOBSCURED);
+    gdk_gc_set_exposures(invert_gc, gui.visibility !=
+						   GDK_VISIBILITY_UNOBSCURED);
     gdk_draw_rectangle(gui.drawarea->window, invert_gc,
 		       TRUE,
 		       FILL_X(c), FILL_Y(r),
diff -Naur vim70.orig/src/gui_xmebw.c vim70/src/gui_xmebw.c
--- vim70.orig/src/gui_xmebw.c	2006-04-30 08:32:32.000000000 -0700
+++ vim70/src/gui_xmebw.c	2006-07-14 08:51:21.000000000 -0700
@@ -47,13 +47,13 @@
 #include "gui_xmebwp.h"
 
 /* Provide some missing wrappers, which are missed from the LessTif
- * implementation.
+ * implementation.  Also missing in Motif 1.2 and earlier.
  *
  * We neither use XmeGetPixmapData or _XmGetPixmapData, since with LessTif the
  * pixmap will not appear in it's caches properly. We cache the interresting
  * values in XmEnhancedButtonPart instead ourself.
  */
-#ifdef LESSTIF_VERSION
+#if defined(LESSTIF_VERSION) || (XmVersion <= 1002)
 # ifndef Lab_IsMenupane
 #  define Lab_IsMenupane(w) (Lab_MenuType(w) == (int)XmMENU_POPUP || \
 		    Lab_MenuType(w) == (int)XmMENU_PULLDOWN)
@@ -480,7 +480,7 @@
 	    || (eb->core.height <= 2 * eb->primitive.highlight_thickness))
 	return;
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
     {
 	XmDisplay	dpy;
 
@@ -641,7 +641,7 @@
     GC		tmp_gc = NULL;
     Boolean	replaceGC = False;
     Boolean	deadjusted = False;
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
     XmDisplay	dpy = (XmDisplay)XmGetXmDisplay(XtDisplay(eb));
     Boolean	etched_in = dpy->display.enable_etched_in_menu;
 #else
@@ -726,7 +726,7 @@
 	if ((((ShellWidget) XtParent(XtParent(eb)))->shell.popped_up)
 		&& _XmGetInDragMode((Widget) eb))
 	{
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	    XmDisplay dpy = (XmDisplay) XmGetXmDisplay(XtDisplay(wid));
 	    Boolean etched_in = dpy->display.enable_etched_in_menu;
 #else
@@ -810,7 +810,7 @@
 
     if (Lab_IsMenupane(eb))
     {
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	XmDisplay dpy = (XmDisplay) XmGetXmDisplay(XtDisplay(wid));
 	Boolean etched_in = dpy->display.enable_etched_in_menu;
 #else
@@ -1150,7 +1150,7 @@
 Redisplay(Widget w, XEvent *event, Region region)
 {
     XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget) w;
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
     XmDisplay		    dpy;
     XtEnum		    default_button_emphasis;
 #endif
@@ -1162,7 +1162,7 @@
     if (!XtIsRealized((Widget)eb))
 	return;
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
     dpy = (XmDisplay)XmGetXmDisplay(XtDisplay(eb));
     default_button_emphasis = dpy->display.default_button_emphasis;
 #endif
@@ -1241,7 +1241,7 @@
     {
 	int adjust = 0;
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	/*
 	 *  NOTE: PushButton has two types of shadows: primitive-shadow and
 	 *  default-button-shadow.  If pushbutton is in a menu only primitive
@@ -1289,7 +1289,7 @@
 			  adjust, adjust, rectwidth, rectheight, borderwidth);
 	    }
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	    switch (default_button_emphasis)
 	    {
 		case XmINTERNAL_HIGHLIGHT:
@@ -1365,7 +1365,7 @@
 		    default_button_shadow_thickness =
 			       eb->pushbutton.default_button_shadow_thickness;
 
-#ifndef LESSTIF_VERSION
+#if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 		/*
 		 * Compute location of bounding box to contain the
 		 * defaultButtonShadow.
diff -Naur vim70.orig/src/hardcopy.c vim70/src/hardcopy.c
--- vim70.orig/src/hardcopy.c	2006-05-04 03:09:58.000000000 -0700
+++ vim70/src/hardcopy.c	2006-09-11 08:23:16.000000000 -0700
@@ -1794,29 +1794,27 @@
     static int
 prt_resfile_next_line()
 {
-    int     index;
+    int     idx;
 
     /* Move to start of next line and then find end of line */
-    index = prt_resfile.line_end + 1;
-    while (index < prt_resfile.len)
+    idx = prt_resfile.line_end + 1;
+    while (idx < prt_resfile.len)
     {
-	if (prt_resfile.buffer[index] != PSLF && prt_resfile.buffer[index]
-									!= PSCR)
+	if (prt_resfile.buffer[idx] != PSLF && prt_resfile.buffer[idx] != PSCR)
 	    break;
-	index++;
+	idx++;
     }
-    prt_resfile.line_start = index;
+    prt_resfile.line_start = idx;
 
-    while (index < prt_resfile.len)
+    while (idx < prt_resfile.len)
     {
-	if (prt_resfile.buffer[index] == PSLF || prt_resfile.buffer[index]
-									== PSCR)
+	if (prt_resfile.buffer[idx] == PSLF || prt_resfile.buffer[idx] == PSCR)
 	    break;
-	index++;
+	idx++;
     }
-    prt_resfile.line_end = index;
+    prt_resfile.line_end = idx;
 
-    return (index < prt_resfile.len);
+    return (idx < prt_resfile.len);
 }
 
     static int
@@ -1837,14 +1835,14 @@
 prt_resfile_skip_nonws(offset)
     int     offset;
 {
-    int     index;
+    int     idx;
 
-    index = prt_resfile.line_start + offset;
-    while (index < prt_resfile.line_end)
+    idx = prt_resfile.line_start + offset;
+    while (idx < prt_resfile.line_end)
     {
-	if (isspace(prt_resfile.buffer[index]))
-	    return index - prt_resfile.line_start;
-	index++;
+	if (isspace(prt_resfile.buffer[idx]))
+	    return idx - prt_resfile.line_start;
+	idx++;
     }
     return -1;
 }
@@ -1853,14 +1851,14 @@
 prt_resfile_skip_ws(offset)
     int     offset;
 {
-    int     index;
+    int     idx;
 
-    index = prt_resfile.line_start + offset;
-    while (index < prt_resfile.line_end)
+    idx = prt_resfile.line_start + offset;
+    while (idx < prt_resfile.line_end)
     {
-	if (!isspace(prt_resfile.buffer[index]))
-	    return index - prt_resfile.line_start;
-	index++;
+	if (!isspace(prt_resfile.buffer[idx]))
+	    return idx - prt_resfile.line_start;
+	idx++;
     }
     return -1;
 }
@@ -2478,7 +2476,7 @@
     char_u	*p_encoding;
     struct prt_ps_encoding_S *p_mbenc;
     struct prt_ps_encoding_S *p_mbenc_first;
-    struct prt_ps_charset_S  *p_mbchar;
+    struct prt_ps_charset_S  *p_mbchar = NULL;
 #endif
 
 #if 0
@@ -2516,7 +2514,6 @@
     if (!(props & ENC_8BIT) && ((*p_pmcs != NUL) || !(props & ENC_UNICODE)))
     {
 	p_mbenc_first = NULL;
-	p_mbchar = NULL;
 	for (cmap = 0; cmap < NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
 	    if (prt_match_encoding((char *)p_encoding, &prt_ps_mbfonts[cmap],
 								    &p_mbenc))
diff -Naur vim70.orig/src/if_cscope.c vim70/src/if_cscope.c
--- vim70.orig/src/if_cscope.c	2006-04-18 01:54:15.000000000 -0700
+++ vim70/src/if_cscope.c	2006-09-11 08:23:16.000000000 -0700
@@ -989,8 +989,7 @@
 {
     int i;
     char *cmd;
-    char **matches, **contexts;
-    int nummatches[CSCOPE_MAX_CONNECTIONS], totmatches, matched;
+    int nummatches[CSCOPE_MAX_CONNECTIONS], totmatches;
 #ifdef FEAT_QUICKFIX
     char cmdletter;
     char *qfpos;
@@ -1141,6 +1140,9 @@
     else
 #endif /* FEAT_QUICKFIX */
     {
+	char **matches = NULL, **contexts = NULL;
+	int matched = 0;
+
 	/* read output */
 	cs_fill_results((char *)pat, totmatches, nummatches, &matches,
 							 &contexts, &matched);
diff -Naur vim70.orig/src/if_perl.xs vim70/src/if_perl.xs
--- vim70.orig/src/if_perl.xs	2006-03-06 10:57:16.000000000 -0800
+++ vim70/src/if_perl.xs	2006-08-19 16:39:02.000000000 -0700
@@ -155,8 +155,8 @@
 static int (*perl_run)(PerlInterpreter*);
 static int (*perl_parse)(PerlInterpreter*, XSINIT_t, int, char**, char**);
 static void* (*Perl_get_context)(void);
-static void (*Perl_croak)(pTHX_ const char*, ...) __attribute__((noreturn));
-static void (*Perl_croak_nocontext)(const char*, ...) __attribute__((noreturn));
+static void (*Perl_croak)(pTHX_ const char*, ...);
+static void (*Perl_croak_nocontext)(const char*, ...);
 static I32 (*Perl_dowantarray)(pTHX);
 static void (*Perl_free_tmps)(pTHX);
 static HV* (*Perl_gv_stashpv)(pTHX_ const char*, I32);
@@ -1056,7 +1056,6 @@
     int i;
     long lnum;
     char *line;
-    buf_T *savebuf;
     PPCODE:
     if (buf_valid(vimbuf))
     {
@@ -1069,14 +1068,20 @@
 	    line = SvPV(ST(i),PL_na);
 	    if (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count && line != NULL)
 	    {
-		savebuf = curbuf;
-		curbuf = vimbuf;
+		aco_save_T	aco;
+
+		/* set curwin/curbuf for "vimbuf" and save some things */
+		aucmd_prepbuf(&aco, vimbuf);
+
 		if (u_savesub(lnum) == OK)
 		{
 		    ml_replace(lnum, (char_u *)line, TRUE);
 		    changed_bytes(lnum, 0);
 		}
-		curbuf = savebuf;
+
+		/* restore curwin/curbuf and a few other things */
+		aucmd_restbuf(&aco);
+		/* Careful: autocommands may have made "vimbuf" invalid! */
 	    }
 	}
     }
@@ -1087,7 +1092,6 @@
 
     PREINIT:
     long i, lnum = 0, count = 0;
-    buf_T *savebuf;
     PPCODE:
     if (buf_valid(vimbuf))
     {
@@ -1114,16 +1118,23 @@
 	    {
 		if (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count)
 		{
-		    savebuf = curbuf;
-		    curbuf = vimbuf;
+		    aco_save_T	aco;
+
+		    /* set curwin/curbuf for "vimbuf" and save some things */
+		    aucmd_prepbuf(&aco, vimbuf);
+
 		    if (u_savedel(lnum, 1) == OK)
 		    {
 			ml_delete(lnum, 0);
 			deleted_lines_mark(lnum, 1L);
-			if (savebuf == curbuf)
+			if (aco.save_buf == curbuf)
 			    check_cursor();
 		    }
-		    curbuf = savebuf;
+
+		    /* restore curwin/curbuf and a few other things */
+		    aucmd_restbuf(&aco);
+		    /* Careful: autocommands may have made "vimbuf" invalid! */
+
 		    update_curbuf(VALID);
 		}
 	    }
@@ -1138,7 +1149,6 @@
     int		i;
     long	lnum;
     char	*line;
-    buf_T	*savebuf;
     PPCODE:
     if (buf_valid(vimbuf))
     {
@@ -1151,14 +1161,21 @@
 	    line = SvPV(ST(i),PL_na);
 	    if (lnum >= 0 && lnum <= vimbuf->b_ml.ml_line_count && line != NULL)
 	    {
-		savebuf = curbuf;
-		curbuf = vimbuf;
+		aco_save_T	aco;
+
+		/* set curwin/curbuf for "vimbuf" and save some things */
+		aucmd_prepbuf(&aco, vimbuf);
+
 		if (u_inssub(lnum + 1) == OK)
 		{
 		    ml_append(lnum, (char_u *)line, (colnr_T)0, FALSE);
 		    appended_lines_mark(lnum, 1L);
 		}
-		curbuf = savebuf;
+
+		/* restore curwin/curbuf and a few other things */
+		aucmd_restbuf(&aco);
+		/* Careful: autocommands may have made "vimbuf" invalid! */
+
 		update_curbuf(VALID);
 	    }
 	}
diff -Naur vim70.orig/src/if_ruby.c vim70/src/if_ruby.c
--- vim70.orig/src/if_ruby.c	2006-04-30 08:37:52.000000000 -0700
+++ vim70/src/if_ruby.c	2006-08-19 16:39:01.000000000 -0700
@@ -643,11 +643,14 @@
 
 static VALUE set_buffer_line(buf_T *buf, linenr_T n, VALUE str)
 {
-    buf_T *savebuf = curbuf;
-    char *line = STR2CSTR(str);
+    char	*line = STR2CSTR(str);
+    aco_save_T	aco;
+
+    if (n > 0 && n <= buf->b_ml.ml_line_count && line != NULL)
+    {
+	/* set curwin/curbuf for "buf" and save some things */
+	aucmd_prepbuf(&aco, buf);
 
-    if (n > 0 && n <= buf->b_ml.ml_line_count && line != NULL) {
-	curbuf = buf;
 	if (u_savesub(n) == OK) {
 	    ml_replace(n, (char_u *)line, TRUE);
 	    changed();
@@ -655,10 +658,15 @@
 	    syn_changed(n); /* recompute syntax hl. for this line */
 #endif
 	}
-	curbuf = savebuf;
+
+	/* restore curwin/curbuf and a few other things */
+	aucmd_restbuf(&aco);
+	/* Careful: autocommands may have made "buf" invalid! */
+
 	update_curbuf(NOT_VALID);
     }
-    else {
+    else
+    {
 	rb_raise(rb_eIndexError, "index %d out of buffer", n);
 	return Qnil; /* For stop warning */
     }
@@ -676,12 +684,15 @@
 
 static VALUE buffer_delete(VALUE self, VALUE num)
 {
-    buf_T *buf = get_buf(self);
-    buf_T *savebuf = curbuf;
-    long n = NUM2LONG(num);
+    buf_T	*buf = get_buf(self);
+    long	n = NUM2LONG(num);
+    aco_save_T	aco;
+
+    if (n > 0 && n <= buf->b_ml.ml_line_count)
+    {
+	/* set curwin/curbuf for "buf" and save some things */
+	aucmd_prepbuf(&aco, buf);
 
-    if (n > 0 && n <= buf->b_ml.ml_line_count) {
-	curbuf = buf;
 	if (u_savedel(n, 1) == OK) {
 	    ml_delete(n, 0);
 
@@ -691,10 +702,15 @@
 
 	    changed();
 	}
-	curbuf = savebuf;
+
+	/* restore curwin/curbuf and a few other things */
+	aucmd_restbuf(&aco);
+	/* Careful: autocommands may have made "buf" invalid! */
+
 	update_curbuf(NOT_VALID);
     }
-    else {
+    else
+    {
 	rb_raise(rb_eIndexError, "index %d out of buffer", n);
     }
     return Qnil;
@@ -702,13 +718,16 @@
 
 static VALUE buffer_append(VALUE self, VALUE num, VALUE str)
 {
-    buf_T *buf = get_buf(self);
-    buf_T *savebuf = curbuf;
-    char *line = STR2CSTR(str);
-    long n = NUM2LONG(num);
+    buf_T	*buf = get_buf(self);
+    char	*line = STR2CSTR(str);
+    long	n = NUM2LONG(num);
+    aco_save_T	aco;
+
+    if (n >= 0 && n <= buf->b_ml.ml_line_count && line != NULL)
+    {
+	/* set curwin/curbuf for "buf" and save some things */
+	aucmd_prepbuf(&aco, buf);
 
-    if (n >= 0 && n <= buf->b_ml.ml_line_count && line != NULL) {
-	curbuf = buf;
 	if (u_inssub(n + 1) == OK) {
 	    ml_append(n, (char_u *) line, (colnr_T) 0, FALSE);
 
@@ -718,7 +737,11 @@
 
 	    changed();
 	}
-	curbuf = savebuf;
+
+	/* restore curwin/curbuf and a few other things */
+	aucmd_restbuf(&aco);
+	/* Careful: autocommands may have made "buf" invalid! */
+
 	update_curbuf(NOT_VALID);
     }
     else {
diff -Naur vim70.orig/src/macros.h vim70/src/macros.h
--- vim70.orig/src/macros.h	2006-03-01 04:01:10.000000000 -0800
+++ vim70/src/macros.h	2006-09-11 09:01:59.000000000 -0700
@@ -276,3 +276,9 @@
 # define MB_CHARLEN(p)		STRLEN(p)
 # define PTR2CHAR(p)		((int)*(p))
 #endif
+
+#ifdef FEAT_AUTOCHDIR
+# define DO_AUTOCHDIR if (p_acd) do_autochdir();
+#else
+# define DO_AUTOCHDIR
+#endif
diff -Naur vim70.orig/src/main.c vim70/src/main.c
--- vim70.orig/src/main.c	2006-05-03 10:36:44.000000000 -0700
+++ vim70/src/main.c	2006-09-11 09:00:04.000000000 -0700
@@ -564,7 +564,11 @@
      */
     if (p_lpl)
     {
+# ifdef VMS	/* Somehow VMS doesn't handle the "**". */
+	source_runtime((char_u *)"plugin/*.vim", TRUE);
+# else
 	source_runtime((char_u *)"plugin/**/*.vim", TRUE);
+# endif
 	TIME_MSG("loading plugins");
     }
 #endif
@@ -1126,6 +1130,16 @@
 	 */
 	update_curswant();
 
+#ifdef FEAT_EVAL
+	/*
+	 * May perform garbage collection when waiting for a character, but
+	 * only at the very toplevel.  Otherwise we may be using a List or
+	 * Dict internally somewhere.
+	 * "may_garbage_collect" is reset in vgetc() which is invoked through
+	 * do_exmode() and normal_cmd().
+	 */
+	may_garbage_collect = (!cmdwin && !noexmode);
+#endif
 	/*
 	 * If we're invoked as ex, do a round of ex commands.
 	 * Otherwise, get and execute a normal mode command.
@@ -2281,7 +2295,7 @@
     mparm_T	*parmp;
 {
 #ifdef FEAT_WINDOWS
-    int		rewind;
+    int		dorewind;
     int		done = 0;
 
     /*
@@ -2338,10 +2352,10 @@
 	++autocmd_no_leave;
 #endif
 #ifdef FEAT_WINDOWS
-	rewind = TRUE;
+	dorewind = TRUE;
 	while (done++ < 1000)
 	{
-	    if (rewind)
+	    if (dorewind)
 	    {
 		if (parmp->window_layout == WIN_TABS)
 		    goto_tabpage(1);
@@ -2360,7 +2374,7 @@
 		    break;
 		curwin = curwin->w_next;
 	    }
-	    rewind = FALSE;
+	    dorewind = FALSE;
 #endif
 	    curbuf = curwin->w_buffer;
 	    if (curbuf->b_ml.ml_mfp == NULL)
@@ -2381,7 +2395,7 @@
 		check_swap_exists_action();
 #endif
 #ifdef FEAT_AUTOCMD
-		rewind = TRUE;		/* start again */
+		dorewind = TRUE;		/* start again */
 #endif
 	    }
 #ifdef FEAT_WINDOWS
@@ -3208,10 +3222,15 @@
      * Register for remote command execution with :serversend and --remote
      * unless there was a -X or a --servername '' on the command line.
      * Only register nongui-vim's with an explicit --servername argument.
+     * When running as root --servername is also required.
      */
     if (X_DISPLAY != NULL && parmp->servername != NULL && (
 #  ifdef FEAT_GUI
-		gui.in_use ||
+		(gui.in_use
+#   ifdef UNIX
+		 && getuid() != 0
+#   endif
+		) ||
 #  endif
 		parmp->serverName_arg != NULL))
     {
diff -Naur vim70.orig/src/Makefile vim70/src/Makefile
--- vim70.orig/src/Makefile	2006-05-07 06:25:27.000000000 -0700
+++ vim70/src/Makefile	2006-09-11 08:57:41.000000000 -0700
@@ -2177,6 +2177,7 @@
 	cd $(SHADOWDIR)/xxd; ln -s ../../xxd/*.[ch] ../../xxd/Make* .
 	if test -d $(RSRC_DIR); then \
 		cd $(SHADOWDIR); \
+		ln -s ../infplist.xml .; \
 		ln -s ../$(RSRC_DIR) ../os_mac.rsr.hqx ../dehqx.py .; \
 	fi
 	mkdir $(SHADOWDIR)/testdir
@@ -2260,7 +2261,7 @@
 auto/osdef.h: auto/config.h osdef.sh osdef1.h.in osdef2.h.in
 	CC="$(CC) $(OSDEF_CFLAGS)" srcdir=$(srcdir) sh $(srcdir)/osdef.sh
 
-QUOTESED = sed -e 's/"/\\"/g' -e 's/\\"/"/' -e 's/\\";$$/";/'
+QUOTESED = sed -e 's/[\\"]/\\&/g' -e 's/\\"/"/' -e 's/\\";$$/";/'
 auto/pathdef.c: Makefile auto/config.mk
 	-@echo creating $@
 	-@echo '/* pathdef.c */' > $@
diff -Naur vim70.orig/src/mbyte.c vim70/src/mbyte.c
--- vim70.orig/src/mbyte.c	2006-04-30 04:51:01.000000000 -0700
+++ vim70/src/mbyte.c	2006-09-11 08:23:16.000000000 -0700
@@ -311,7 +311,11 @@
 
 #define IDX_MACROMAN	57
     {"macroman",	ENC_8BIT + ENC_MACROMAN, 0},	/* Mac OS */
-#define IDX_COUNT	58
+#define IDX_DECMCS	58
+    {"dec-mcs",		ENC_8BIT,		0},	/* DEC MCS */
+#define IDX_HPROMAN8	59
+    {"hp-roman8",	ENC_8BIT,		0},	/* HP Roman8 */
+#define IDX_COUNT	60
 };
 
 /*
@@ -359,6 +363,8 @@
     {"932",		IDX_CP932},
     {"949",		IDX_CP949},
     {"936",		IDX_CP936},
+    {"gbk",		IDX_CP936},
+    {"gb18030",		IDX_CP936},	/* only 99% the same */
     {"950",		IDX_CP950},
     {"eucjp",		IDX_EUC_JP},
     {"unix-jis",	IDX_EUC_JP},
@@ -386,6 +392,7 @@
     {"950",		IDX_BIG5},
 #endif
     {"mac",		IDX_MACROMAN},
+    {"mac-roman",	IDX_MACROMAN},
     {NULL,		0}
 };
 
@@ -3507,6 +3514,11 @@
 	add_to_input_buf(delkey, (int)sizeof(delkey));
 }
 
+/*
+ * Move the cursor left by "num_move_back" characters.
+ * Note that ins_left() checks im_is_preediting() to avoid breaking undo for
+ * these K_LEFT keys.
+ */
     static void
 im_correct_cursor(int num_move_back)
 {
@@ -3734,8 +3746,7 @@
     }
     else if (cursor_index == 0 && preedit_string[0] == '\0')
     {
-	if (preedit_start_col == MAXCOL)
-	    xim_has_preediting = FALSE;
+	xim_has_preediting = FALSE;
 
 	/* If at the start position (after typing backspace)
 	 * preedit_start_col must be reset. */
@@ -3850,13 +3861,13 @@
 
     if (preedit_string != NULL && attr_list != NULL)
     {
-	int index;
+	int idx;
 
 	/* Get the byte index as used by PangoAttrIterator */
-	for (index = 0; col > 0 && preedit_string[index] != '\0'; --col)
-	    index += utfc_ptr2len((char_u *)preedit_string + index);
+	for (idx = 0; col > 0 && preedit_string[idx] != '\0'; --col)
+	    idx += utfc_ptr2len((char_u *)preedit_string + idx);
 
-	if (preedit_string[index] != '\0')
+	if (preedit_string[idx] != '\0')
 	{
 	    PangoAttrIterator	*iter;
 	    int			start, end;
@@ -3869,7 +3880,7 @@
 	    {
 		pango_attr_iterator_range(iter, &start, &end);
 
-		if (index >= start && index < end)
+		if (idx >= start && idx < end)
 		    char_attr |= translate_pango_attributes(iter);
 	    }
 	    while (pango_attr_iterator_next(iter));
diff -Naur vim70.orig/src/memline.c vim70/src/memline.c
--- vim70.orig/src/memline.c	2006-04-20 14:00:21.000000000 -0700
+++ vim70/src/memline.c	2006-09-11 08:23:16.000000000 -0700
@@ -215,7 +215,7 @@
 #define ML_FLUSH	0x02	    /* flush locked block */
 #define ML_SIMPLE(x)	(x & 0x10)  /* DEL, INS or FIND */
 
-static void ml_upd_block0 __ARGS((buf_T *buf, int setfname));
+static void ml_upd_block0 __ARGS((buf_T *buf, int set_fname));
 static void set_b0_fname __ARGS((ZERO_BL *, buf_T *buf));
 static void set_b0_dir_flag __ARGS((ZERO_BL *b0p, buf_T *buf));
 #ifdef FEAT_MBYTE
@@ -679,9 +679,9 @@
  * Update the timestamp or the B0_SAME_DIR flag of the .swp file.
  */
     static void
-ml_upd_block0(buf, setfname)
+ml_upd_block0(buf, set_fname)
     buf_T	*buf;
-    int		setfname;
+    int		set_fname;
 {
     memfile_T	*mfp;
     bhdr_T	*hp;
@@ -695,7 +695,7 @@
 	EMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
     else
     {
-	if (setfname)
+	if (set_fname)
 	    set_b0_fname(b0p, buf);
 	else
 	    set_b0_dir_flag(b0p, buf);
diff -Naur vim70.orig/src/menu.c vim70/src/menu.c
--- vim70.orig/src/menu.c	2006-05-03 10:30:48.000000000 -0700
+++ vim70/src/menu.c	2006-08-19 16:40:11.000000000 -0700
@@ -511,6 +511,14 @@
 	 * name (without mnemonic and accelerator text). */
 	next_name = menu_name_skip(name);
 	dname = menu_text(name, NULL, NULL);
+	if (dname == NULL)
+	    goto erret;
+	if (*dname == NUL)
+	{
+	    /* Only a mnemonic or accelerator is not valid. */
+	    EMSG(_("E792: Empty menu name"));
+	    goto erret;
+	}
 
 	/* See if it's already there */
 	lower_pri = menup;
@@ -704,6 +712,7 @@
 	parent = menu;
 	name = next_name;
 	vim_free(dname);
+	dname = NULL;
 	if (pri_tab[pri_idx + 1] != -1)
 	    ++pri_idx;
     }
@@ -793,6 +802,22 @@
 erret:
     vim_free(path_name);
     vim_free(dname);
+
+    /* Delete any empty submenu we added before discovering the error.  Repeat
+     * for higher levels. */
+    while (parent != NULL && parent->children == NULL)
+    {
+	if (parent->parent == NULL)
+	    menup = &root_menu;
+	else
+	    menup = &parent->parent->children;
+	for ( ; *menup != NULL && *menup != parent; menup = &((*menup)->next))
+	    ;
+	if (*menup == NULL) /* safety check */
+	    break;
+	parent = parent->parent;
+	free_menu(menup);
+    }
     return FAIL;
 }
 
@@ -1753,6 +1778,27 @@
 }
 
 /*
+ * Check that a pointer appears in the menu tree.  Used to protect from using
+ * a menu that was deleted after it was selected but before the event was
+ * handled.
+ * Return OK or FAIL.  Used recursively.
+ */
+    int
+check_menu_pointer(root, menu_to_check)
+    vimmenu_T *root;
+    vimmenu_T *menu_to_check;
+{
+    vimmenu_T	*p;
+
+    for (p = root; p != NULL; p = p->next)
+	if (p == menu_to_check
+		|| (p->children != NULL
+		    && check_menu_pointer(p->children, menu_to_check) == OK))
+	    return OK;
+    return FAIL;
+}
+
+/*
  * After we have started the GUI, then we can create any menus that have been
  * defined.  This is done once here.  add_menu_path() may have already been
  * called to define these menus, and may be called again.  This function calls
diff -Naur vim70.orig/src/message.c vim70/src/message.c
--- vim70.orig/src/message.c	2006-05-06 13:07:37.000000000 -0700
+++ vim70/src/message.c	2006-09-11 08:59:06.000000000 -0700
@@ -1925,7 +1925,8 @@
 	     * If screen is completely filled and 'more' is set then wait
 	     * for a character.
 	     */
-	    if (p_more && --lines_left == 0 && State != HITRETURN
+	    --lines_left;
+	    if (p_more && lines_left == 0 && State != HITRETURN
 					    && !msg_no_more && !exmode_active)
 	    {
 #ifdef FEAT_CON_DIALOG
@@ -4175,15 +4176,16 @@
 			str_arg_l = 0;
 		    else
 		    {
-			/* memchr on HP does not like n > 2^31  !!! */
-			char *q = memchr(str_arg, '\0',
+			/* Don't put the #if inside memchr(), it can be a
+			 * macro. */
 #if SIZEOF_INT <= 2
-				precision
+			char *q = memchr(str_arg, '\0', precision);
 #else
-				precision <= (size_t)0x7fffffffL ? precision
-						       : (size_t)0x7fffffffL
+			/* memchr on HP does not like n > 2^31  !!! */
+			char *q = memchr(str_arg, '\0',
+				  precision <= (size_t)0x7fffffffL ? precision
+						       : (size_t)0x7fffffffL);
 #endif
-						       );
 			str_arg_l = (q == NULL) ? precision : q - str_arg;
 		    }
 		    break;
diff -Naur vim70.orig/src/misc1.c vim70/src/misc1.c
--- vim70.orig/src/misc1.c	2006-04-30 08:30:02.000000000 -0700
+++ vim70/src/misc1.c	2006-09-11 09:03:25.000000000 -0700
@@ -3016,6 +3016,7 @@
     int		len = 0;
     int		n;
     int		save_mapped_ctrl_c = mapped_ctrl_c;
+    int		waited = 0;
 
     mapped_ctrl_c = FALSE;	/* mappings are not used here */
     for (;;)
@@ -3034,11 +3035,16 @@
 	    /* Replace zero and CSI by a special key code. */
 	    n = fix_input_buffer(buf + len, n, FALSE);
 	    len += n;
+	    waited = 0;
 	}
+	else if (len > 0)
+	    ++waited;	    /* keep track of the waiting time */
 
-	/* incomplete termcode: get more characters */
-	if ((n = check_termcode(1, buf, len)) < 0)
+	/* Incomplete termcode and not timed out yet: get more characters */
+	if ((n = check_termcode(1, buf, len)) < 0
+	       && (!p_ttimeout || waited * 100L < (p_ttm < 0 ? p_tm : p_ttm)))
 	    continue;
+
 	/* found a termcode: adjust length */
 	if (n > 0)
 	    len = n;
@@ -3196,14 +3202,12 @@
     else
 	MSG_PUTS(_("Choice number (<Enter> cancels): "));
 
-    /* Set the state such that text can be selected/copied/pasted. */
+    /* Set the state such that text can be selected/copied/pasted and we still
+     * get mouse events. */
     save_cmdline_row = cmdline_row;
-    cmdline_row = Rows - 1;
+    cmdline_row = 0;
     save_State = State;
-    if (mouse_used == NULL)
-	State = CMDLINE;
-    else
-	State = NORMAL;
+    State = CMDLINE;
 
     i = get_number(TRUE, mouse_used);
     if (KeyTyped)
@@ -4492,7 +4496,7 @@
 		int l = mb_ptr2len(s);
 
 		while (--l > 0)
-		    *d++ = *s++;
+		    *d++ = *++s;
 	    }
 # endif
 	}
diff -Naur vim70.orig/src/netbeans.c vim70/src/netbeans.c
--- vim70.orig/src/netbeans.c	2006-04-22 11:00:05.000000000 -0700
+++ vim70/src/netbeans.c	2006-09-11 08:23:16.000000000 -0700
@@ -103,7 +103,7 @@
 static int  inputHandler = -1;		/* simply ret.value of WSAAsyncSelect() */
 extern HWND s_hwnd;			/* Gvim's Window handle */
 #endif
-static int cmdno;			/* current command number for reply */
+static int r_cmdno;			/* current command number for reply */
 static int haveConnection = FALSE;	/* socket is connected and
 					   initialization is done */
 #ifdef FEAT_GUI_MOTIF
@@ -832,11 +832,11 @@
 	return;
     }
 
-    cmdno = strtol(q, &q, 10);
+    r_cmdno = strtol(q, &q, 10);
 
     q = (char *)skipwhite((char_u *)q);
 
-    if (nb_do_cmd(bufno, (char_u *)verb, isfunc, cmdno, (char_u *)q) == FAIL)
+    if (nb_do_cmd(bufno, (char_u *)verb, isfunc, r_cmdno, (char_u *)q) == FAIL)
     {
 #ifdef NBDEBUG
 	/*
@@ -1008,11 +1008,11 @@
 	if (netbeansForcedQuit)
 	{
 	    /* mark as unmodified so NetBeans won't put up dialog on "killed" */
-	    sprintf(buf, "%d:unmodified=%d\n", i, cmdno);
+	    sprintf(buf, "%d:unmodified=%d\n", i, r_cmdno);
 	    nbdebug(("EVT: %s", buf));
 	    nb_send(buf, "netbeans_end");
 	}
-	sprintf(buf, "%d:killed=%d\n", i, cmdno);
+	sprintf(buf, "%d:killed=%d\n", i, r_cmdno);
 	nbdebug(("EVT: %s", buf));
 /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
 	if (sd >= 0)
@@ -1986,6 +1986,8 @@
 	    if (buf->bufp != NULL)
 		do_buffer(DOBUF_WIPE, DOBUF_FIRST, FORWARD,
 						     buf->bufp->b_fnum, TRUE);
+	    buf->bufp = NULL;
+	    buf->initDone = FALSE;
 	    doupdate = 1;
 /* =====================================================================*/
 	}
@@ -2561,7 +2563,7 @@
 	    if (p != NULL)
 	    {
 		vim_snprintf(buf, sizeof(buf),
-				       "0:balloonText=%d \"%s\"\n", cmdno, p);
+				       "0:balloonText=%d \"%s\"\n", r_cmdno, p);
 		vim_free(p);
 	    }
 	    nbdebug(("EVT: %s", buf));
@@ -2615,7 +2617,7 @@
 
     if (haveConnection)
     {
-	sprintf(buf, "0:disconnect=%d\n", cmdno);
+	sprintf(buf, "0:disconnect=%d\n", r_cmdno);
 	nbdebug(("EVT: %s", buf));
 	nb_send(buf, "netbeans_disconnect");
     }
@@ -2634,7 +2636,7 @@
 	return;
 
     sprintf(buf, "0:geometry=%d %d %d %d %d\n",
-		    cmdno, (int)Columns, (int)Rows, new_x, new_y);
+		    r_cmdno, (int)Columns, (int)Rows, new_x, new_y);
     /*nbdebug(("EVT: %s", buf)); happens too many times during a move */
     nb_send(buf, "netbeans_frame_moved");
 }
@@ -2743,7 +2745,7 @@
     if (bufno <= 0)
 	return;
 
-    sprintf(buffer, "%d:killed=%d\n", bufno, cmdno);
+    sprintf(buffer, "%d:killed=%d\n", bufno, r_cmdno);
 
     nbdebug(("EVT: %s", buffer));
 
@@ -2817,7 +2819,8 @@
     if (p != NULL)
     {
 	buf = alloc(128 + 2*newlen);
-	sprintf((char *)buf, "%d:insert=%d %ld \"%s\"\n", bufno, cmdno, off, p);
+	sprintf((char *)buf, "%d:insert=%d %ld \"%s\"\n",
+						      bufno, r_cmdno, off, p);
 	nbdebug(("EVT: %s", buf));
 	nb_send((char *)buf, "netbeans_inserted");
 	vim_free(p);
@@ -2859,7 +2862,7 @@
 
     off = pos2off(bufp, &pos);
 
-    sprintf((char *)buf, "%d:remove=%d %ld %ld\n", bufno, cmdno, off, len);
+    sprintf((char *)buf, "%d:remove=%d %ld %ld\n", bufno, r_cmdno, off, len);
     nbdebug(("EVT: %s", buf));
     nb_send((char *)buf, "netbeans_removed");
 }
@@ -2884,7 +2887,7 @@
 
     nbbuf->modified = 0;
 
-    sprintf((char *)buf, "%d:unmodified=%d\n", bufno, cmdno);
+    sprintf((char *)buf, "%d:unmodified=%d\n", bufno, r_cmdno);
     nbdebug(("EVT: %s", buf));
     nb_send((char *)buf, "netbeans_unmodified");
 #endif
@@ -2908,11 +2911,11 @@
 	long off = pos2off(curbuf, &curwin->w_cursor);
 
 	/* sync the cursor position */
-	sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, cmdno, off, off);
+	sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, r_cmdno, off, off);
 	nbdebug(("EVT: %s", buf));
 	nb_send(buf, "netbeans_button_release[newDotAndMark]");
 
-	sprintf(buf, "%d:buttonRelease=%d %d %ld %d\n", bufno, cmdno,
+	sprintf(buf, "%d:buttonRelease=%d %d %ld %d\n", bufno, r_cmdno,
 				    button, (long)curwin->w_cursor.lnum, col);
 	nbdebug(("EVT: %s", buf));
 	nb_send(buf, "netbeans_button_release");
@@ -2973,7 +2976,7 @@
 
     /* sync the cursor position */
     off = pos2off(curbuf, &curwin->w_cursor);
-    sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, cmdno, off, off);
+    sprintf(buf, "%d:newDotAndMark=%d %ld %ld\n", bufno, r_cmdno, off, off);
     nbdebug(("EVT: %s", buf));
     nb_send(buf, "netbeans_keycommand");
 
@@ -2984,13 +2987,13 @@
 
     /* now send keyCommand event */
     vim_snprintf(buf, sizeof(buf), "%d:keyCommand=%d \"%s\"\n",
-						       bufno, cmdno, keyName);
+						     bufno, r_cmdno, keyName);
     nbdebug(("EVT: %s", buf));
     nb_send(buf, "netbeans_keycommand");
 
     /* New: do both at once and include the lnum/col. */
     vim_snprintf(buf, sizeof(buf), "%d:keyAtPos=%d \"%s\" %ld %ld/%ld\n",
-	    bufno, cmdno, keyName,
+	    bufno, r_cmdno, keyName,
 		off, (long)curwin->w_cursor.lnum, (long)curwin->w_cursor.col);
     nbdebug(("EVT: %s", buf));
     nb_send(buf, "netbeans_keycommand");
@@ -3013,7 +3016,7 @@
 
     nbbuf->modified = 0;
 
-    sprintf((char *)buf, "%d:save=%d\n", bufno, cmdno);
+    sprintf((char *)buf, "%d:save=%d\n", bufno, r_cmdno);
     nbdebug(("EVT: %s", buf));
     nb_send((char *)buf, "netbeans_save_buffer");
 }
@@ -3037,7 +3040,7 @@
     if (nbbuf->insertDone)
 	nbbuf->modified = 1;
 
-    sprintf((char *)buf, "%d:remove=%d 0 -1\n", bufno, cmdno);
+    sprintf((char *)buf, "%d:remove=%d 0 -1\n", bufno, r_cmdno);
     nbdebug(("EVT(suppressed): %s", buf));
 /*     nb_send(buf, "netbeans_deleted_all_lines"); */
 }
diff -Naur vim70.orig/src/normal.c vim70/src/normal.c
--- vim70.orig/src/normal.c	2006-04-29 06:11:18.000000000 -0700
+++ vim70/src/normal.c	2006-09-11 08:23:16.000000000 -0700
@@ -2504,7 +2504,8 @@
 	     * NOTE: Ignore right button down and drag mouse events.
 	     * Windows only shows the popup menu on the button up event.
 	     */
-#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON)
+#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) \
+			  || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
 	    if (!is_click)
 		return FALSE;
 #endif
@@ -4126,7 +4127,7 @@
     int		save_p_ws;
     int		save_p_scs;
     int		retval = OK;
-    int		incl;
+    int		incll;
 
     if ((pat = alloc(len + 7)) == NULL)
 	return FAIL;
@@ -4146,7 +4147,7 @@
      * With "gd" Search back for the start of the current function, then go
      * back until a blank line.  If this fails go to line 1.
      */
-    if (!locally || !findpar(&incl, BACKWARD, 1L, '{', FALSE))
+    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))
     {
 	setpcmark();			/* Set in findpar() otherwise */
 	curwin->w_cursor.lnum = 1;
diff -Naur vim70.orig/src/ops.c vim70/src/ops.c
--- vim70.orig/src/ops.c	2006-04-30 08:13:44.000000000 -0700
+++ vim70/src/ops.c	2006-08-09 08:33:53.000000000 -0700
@@ -2413,6 +2413,7 @@
 	else
 	{
 	    curwin->w_cursor = oap->end;
+	    check_cursor_col();
 
 	    /* Works just like an 'i'nsert on the next character. */
 	    if (!lineempty(curwin->w_cursor.lnum)
@@ -3492,8 +3493,15 @@
 # endif
 	if (flags & PUT_CURSEND)
 	{
+	    colnr_T len;
+
 	    curwin->w_cursor = curbuf->b_op_end;
 	    curwin->w_cursor.col++;
+
+	    /* in Insert mode we might be after the NUL, correct for that */
+	    len = (colnr_T)STRLEN(ml_get_curline());
+	    if (curwin->w_cursor.col > len)
+		curwin->w_cursor.col = len;
 	}
 	else
 	    curwin->w_cursor.lnum = lnum;
diff -Naur vim70.orig/src/option.c vim70/src/option.c
--- vim70.orig/src/option.c	2006-05-03 10:32:28.000000000 -0700
+++ vim70/src/option.c	2006-09-11 09:01:59.000000000 -0700
@@ -2294,7 +2294,7 @@
 			    {(char_u *)0L, (char_u *)0L}
 #endif
 			    },
-    {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE,
+    {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE|P_COMMA,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_sps, PV_NONE,
 			    {(char_u *)"best", (char_u *)0L}
@@ -5227,13 +5227,13 @@
 	    case PV_STL:	return &curwin->w_p_stl_flags;
 #endif
 #ifdef FEAT_EVAL
+# ifdef FEAT_FOLDING
 	    case PV_FDE:	return &curwin->w_p_fde_flags;
 	    case PV_FDT:	return &curwin->w_p_fdt_flags;
+# endif
 # ifdef FEAT_BEVAL
 	    case PV_BEXPR:	return &curbuf->b_p_bexpr_flags;
 # endif
-#endif
-#if defined(FEAT_EVAL)
 # if defined(FEAT_CINDENT)
 	    case PV_INDE:	return &curbuf->b_p_inde_flags;
 # endif
@@ -5268,45 +5268,46 @@
     char_u	*s;
     char_u	**varp;
     int		both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
+    int		idx = opt_idx;
 
-    if (opt_idx == -1)		/* use name */
+    if (idx == -1)		/* use name */
     {
-	opt_idx = findoption(name);
-	if (opt_idx < 0)	/* not found (should not happen) */
+	idx = findoption(name);
+	if (idx < 0)	/* not found (should not happen) */
 	{
 	    EMSG2(_(e_intern2), "set_string_option_direct()");
 	    return;
 	}
     }
 
-    if (options[opt_idx].var == NULL)	/* can't set hidden option */
+    if (options[idx].var == NULL)	/* can't set hidden option */
 	return;
 
     s = vim_strsave(val);
     if (s != NULL)
     {
-	varp = (char_u **)get_varp_scope(&(options[opt_idx]),
+	varp = (char_u **)get_varp_scope(&(options[idx]),
 					       both ? OPT_LOCAL : opt_flags);
-	if ((opt_flags & OPT_FREE) && (options[opt_idx].flags & P_ALLOCED))
+	if ((opt_flags & OPT_FREE) && (options[idx].flags & P_ALLOCED))
 	    free_string_option(*varp);
 	*varp = s;
 
 	/* For buffer/window local option may also set the global value. */
 	if (both)
-	    set_string_option_global(opt_idx, varp);
+	    set_string_option_global(idx, varp);
 
-	options[opt_idx].flags |= P_ALLOCED;
+	options[idx].flags |= P_ALLOCED;
 
 	/* When setting both values of a global option with a local value,
 	 * make the local value empty, so that the global value is used. */
-	if (((int)options[opt_idx].indir & PV_BOTH) && both)
+	if (((int)options[idx].indir & PV_BOTH) && both)
 	{
 	    free_string_option(*varp);
 	    *varp = empty_option;
 	}
 # ifdef FEAT_EVAL
 	if (set_sid != SID_NONE)
-	    set_option_scriptID_idx(opt_idx, opt_flags,
+	    set_option_scriptID_idx(idx, opt_flags,
 					set_sid == 0 ? current_SID : set_sid);
 # endif
     }
@@ -6325,7 +6326,8 @@
 	    else
 		errmsg = check_stl_option(p_ruf);
 	}
-	else
+	/* check 'statusline' only if it doesn't start with "%!" */
+	else if (varp != &p_stl || s[0] != '%' || s[1] != '!')
 	    errmsg = check_stl_option(s);
 	if (varp == &p_ruf && errmsg == NULL)
 	    comp_col();
@@ -7324,9 +7326,8 @@
 #ifdef FEAT_AUTOCHDIR
     else if ((int *)varp == &p_acd)
     {
-	if (p_acd && curbuf->b_ffname != NULL
-				     && vim_chdirfile(curbuf->b_ffname) == OK)
-	    shorten_fnames(TRUE);
+	/* Change directories when the 'acd' option is set now. */
+	DO_AUTOCHDIR
     }
 #endif
 
diff -Naur vim70.orig/src/os_unix.c vim70/src/os_unix.c
--- vim70.orig/src/os_unix.c	2006-05-01 01:13:15.000000000 -0700
+++ vim70/src/os_unix.c	2006-09-11 08:23:16.000000000 -0700
@@ -3934,7 +3934,7 @@
 		    {
 			linenr_T    lnum = curbuf->b_op_start.lnum;
 			int	    written = 0;
-			char_u	    *p = ml_get(lnum);
+			char_u	    *lp = ml_get(lnum);
 			char_u	    *s;
 			size_t	    l;
 
@@ -3942,17 +3942,17 @@
 			close(fromshell_fd);
 			for (;;)
 			{
-			    l = STRLEN(p + written);
+			    l = STRLEN(lp + written);
 			    if (l == 0)
 				len = 0;
-			    else if (p[written] == NL)
+			    else if (lp[written] == NL)
 				/* NL -> NUL translation */
 				len = write(toshell_fd, "", (size_t)1);
 			    else
 			    {
-				s = vim_strchr(p + written, NL);
-				len = write(toshell_fd, (char *)p + written,
-					   s == NULL ? l : s - (p + written));
+				s = vim_strchr(lp + written, NL);
+				len = write(toshell_fd, (char *)lp + written,
+					   s == NULL ? l : s - (lp + written));
 			    }
 			    if (len == l)
 			    {
@@ -3973,7 +3973,7 @@
 				    toshell_fd = -1;
 				    break;
 				}
-				p = ml_get(lnum);
+				lp = ml_get(lnum);
 				written = 0;
 			    }
 			    else if (len > 0)
@@ -4971,7 +4971,8 @@
 		    if (((*file)[*num_file] = alloc(len + 2)) != NULL)
 		    {
 			STRCPY((*file)[*num_file], p);
-			if (!after_pathsep((*file)[*num_file] + len))
+			if (!after_pathsep((*file)[*num_file],
+						    (*file)[*num_file] + len))
 			{
 			    (*file)[*num_file][len] = psepc;
 			    (*file)[*num_file][len + 1] = NUL;
@@ -5757,8 +5758,13 @@
     int		retval_int = 0;
     int		success = FALSE;
 
-    /* Get a handle to the DLL module. */
+    /*
+     * Get a handle to the DLL module.
+     */
 # if defined(USE_DLOPEN)
+    /* First clear any error, it's not cleared by the dlopen() call. */
+    (void)dlerror();
+
     hinstLib = dlopen((char *)libname, RTLD_LAZY
 #  ifdef RTLD_LOCAL
 	    | RTLD_LOCAL
diff -Naur vim70.orig/src/popupmnu.c vim70/src/popupmnu.c
--- vim70.orig/src/popupmnu.c	2006-04-20 13:18:37.000000000 -0700
+++ vim70/src/popupmnu.c	2006-08-27 12:48:28.000000000 -0700
@@ -552,6 +552,9 @@
 {
     pum_array = NULL;
     redraw_all_later(SOME_VALID);
+#ifdef FEAT_WINDOWS
+    redraw_tabline = TRUE;
+#endif
     status_redraw_all();
 }
 
diff -Naur vim70.orig/src/proto/buffer.pro vim70/src/proto/buffer.pro
--- vim70.orig/src/proto/buffer.pro	2006-05-07 06:08:29.000000000 -0700
+++ vim70/src/proto/buffer.pro	2006-09-11 09:01:59.000000000 -0700
@@ -10,6 +10,7 @@
 extern int do_buffer __ARGS((int action, int start, int dir, int count, int forceit));
 extern void set_curbuf __ARGS((buf_T *buf, int action));
 extern void enter_buffer __ARGS((buf_T *buf));
+extern void do_autochdir __ARGS((void));
 extern buf_T *buflist_new __ARGS((char_u *ffname, char_u *sfname, linenr_T lnum, int flags));
 extern void free_buf_options __ARGS((buf_T *buf, int free_p_ff));
 extern int buflist_getfile __ARGS((int n, linenr_T lnum, int options, int forceit));
diff -Naur vim70.orig/src/proto/menu.pro vim70/src/proto/menu.pro
--- vim70.orig/src/proto/menu.pro	2006-05-07 06:08:51.000000000 -0700
+++ vim70/src/proto/menu.pro	2006-08-19 16:40:11.000000000 -0700
@@ -10,6 +10,7 @@
 extern int menu_is_child_of_popup __ARGS((vimmenu_T *menu));
 extern int menu_is_toolbar __ARGS((char_u *name));
 extern int menu_is_separator __ARGS((char_u *name));
+extern int check_menu_pointer __ARGS((vimmenu_T *root, vimmenu_T *menu_to_check));
 extern void gui_create_initial_menus __ARGS((vimmenu_T *menu));
 extern void gui_update_menus __ARGS((int modes));
 extern int gui_is_menu_shortcut __ARGS((int key));
diff -Naur vim70.orig/src/proto/undo.pro vim70/src/proto/undo.pro
--- vim70.orig/src/proto/undo.pro	2006-05-07 06:09:11.000000000 -0700
+++ vim70/src/proto/undo.pro	2006-07-14 10:51:11.000000000 -0700
@@ -4,6 +4,7 @@
 extern int u_savesub __ARGS((linenr_T lnum));
 extern int u_inssub __ARGS((linenr_T lnum));
 extern int u_savedel __ARGS((linenr_T lnum, long nlines));
+extern int undo_allowed __ARGS((void));
 extern void u_undo __ARGS((int count));
 extern void u_redo __ARGS((int count));
 extern void undo_time __ARGS((long step, int sec, int absolute));
diff -Naur vim70.orig/src/quickfix.c vim70/src/quickfix.c
--- vim70.orig/src/quickfix.c	2006-05-03 00:47:42.000000000 -0700
+++ vim70/src/quickfix.c	2006-09-11 09:00:46.000000000 -0700
@@ -500,8 +500,6 @@
 	{
 	    if (tv != NULL)
 	    {
-		int len;
-
 		if (tv->v_type == VAR_STRING)
 		{
 		    /* Get the next line from the supplied string */
@@ -602,13 +600,19 @@
 		else
 		    type = 0;
 		/*
-		 * Extract error message data from matched line
+		 * Extract error message data from matched line.
+		 * We check for an actual submatch, because "\[" and "\]" in
+		 * the 'errorformat' may cause the wrong submatch to be used.
 		 */
 		if ((i = (int)fmt_ptr->addr[0]) > 0)		/* %f */
 		{
-		    int c = *regmatch.endp[i];
+		    int c;
+
+		    if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
+			continue;
 
 		    /* Expand ~/file and $HOME/file to full path. */
+		    c = *regmatch.endp[i];
 		    *regmatch.endp[i] = NUL;
 		    expand_env(regmatch.startp[i], namebuf, CMDBUFFSIZE);
 		    *regmatch.endp[i] = c;
@@ -618,35 +622,63 @@
 			continue;
 		}
 		if ((i = (int)fmt_ptr->addr[1]) > 0)		/* %n */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    enr = (int)atol((char *)regmatch.startp[i]);
+		}
 		if ((i = (int)fmt_ptr->addr[2]) > 0)		/* %l */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    lnum = atol((char *)regmatch.startp[i]);
+		}
 		if ((i = (int)fmt_ptr->addr[3]) > 0)		/* %c */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    col = (int)atol((char *)regmatch.startp[i]);
+		}
 		if ((i = (int)fmt_ptr->addr[4]) > 0)		/* %t */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    type = *regmatch.startp[i];
+		}
 		if (fmt_ptr->flags == '+' && !multiscan)	/* %+ */
 		    STRCPY(errmsg, IObuff);
 		else if ((i = (int)fmt_ptr->addr[5]) > 0)	/* %m */
 		{
+		    if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
+			continue;
 		    len = (int)(regmatch.endp[i] - regmatch.startp[i]);
 		    vim_strncpy(errmsg, regmatch.startp[i], len);
 		}
 		if ((i = (int)fmt_ptr->addr[6]) > 0)		/* %r */
+		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    tail = regmatch.startp[i];
+		}
 		if ((i = (int)fmt_ptr->addr[7]) > 0)		/* %p */
 		{
+		    if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
+			continue;
 		    col = (int)(regmatch.endp[i] - regmatch.startp[i] + 1);
 		    if (*((char_u *)regmatch.startp[i]) != TAB)
 			use_viscol = TRUE;
 		}
 		if ((i = (int)fmt_ptr->addr[8]) > 0)		/* %v */
 		{
+		    if (regmatch.startp[i] == NULL)
+			continue;
 		    col = (int)atol((char *)regmatch.startp[i]);
 		    use_viscol = TRUE;
 		}
 		if ((i = (int)fmt_ptr->addr[9]) > 0)		/* %s */
 		{
+		    if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
+			continue;
 		    len = (int)(regmatch.endp[i] - regmatch.startp[i]);
 		    if (len > CMDBUFFSIZE - 5)
 			len = CMDBUFFSIZE - 5;
@@ -2429,32 +2461,19 @@
     qf_info_T	*qi;
 {
     buf_T	*buf;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
-#else
-    buf_T	*save_curbuf;
-#endif
 
     /* Check if a buffer for the quickfix list exists.  Update it. */
     buf = qf_find_buf(qi);
     if (buf != NULL)
     {
-#ifdef FEAT_AUTOCMD
 	/* set curwin/curbuf to buf and save a few things */
 	aucmd_prepbuf(&aco, buf);
-#else
-	save_curbuf = curbuf;
-	curbuf = buf;
-#endif
 
 	qf_fill_buffer(qi);
 
-#ifdef FEAT_AUTOCMD
 	/* restore curwin/curbuf and a few other things */
 	aucmd_restbuf(&aco);
-#else
-	curbuf = save_curbuf;
-#endif
 
 	(void)qf_win_pos_update(qi, 0);
     }
@@ -2943,10 +2962,8 @@
 #if defined(FEAT_AUTOCMD) && defined(FEAT_SYN_HL)
     char_u	*save_ei = NULL;
 #endif
-#ifndef FEAT_AUTOCMD
-    buf_T	*save_curbuf;
-#else
     aco_save_T	aco;
+#ifdef FEAT_AUTOCMD
     char_u	*au_name =  NULL;
     int		flags = 0;
     colnr_T	col;
@@ -3167,24 +3184,13 @@
 		     * need to be done now, in that buffer.  And the modelines
 		     * need to be done (again).  But not the window-local
 		     * options! */
-#if defined(FEAT_AUTOCMD)
 		    aucmd_prepbuf(&aco, buf);
-#else
-		    save_curbuf = curbuf;
-		    curbuf = buf;
-		    curwin->w_buffer = curbuf;
-#endif
 #if defined(FEAT_AUTOCMD) && defined(FEAT_SYN_HL)
 		    apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,
 						     buf->b_fname, TRUE, buf);
 #endif
 		    do_modelines(OPT_NOWIN);
-#if defined(FEAT_AUTOCMD)
 		    aucmd_restbuf(&aco);
-#else
-		    curbuf = save_curbuf;
-		    curwin->w_buffer = curbuf;
-#endif
 		}
 	    }
 	}
@@ -3285,11 +3291,7 @@
 {
     buf_T	*newbuf;
     int		failed = TRUE;
-#ifdef FEAT_AUTOCMD
     aco_save_T	aco;
-#else
-    buf_T	*old_curbuf = curbuf;
-#endif
 
     /* Allocate a buffer without putting it in the buffer list. */
     newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);
@@ -3299,13 +3301,8 @@
     /* Init the options. */
     buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);
 
-#ifdef FEAT_AUTOCMD
     /* set curwin/curbuf to buf and save a few things */
     aucmd_prepbuf(&aco, newbuf);
-#else
-    curbuf = newbuf;
-    curwin->w_buffer = newbuf;
-#endif
 
     /* Need to set the filename for autocommands. */
     (void)setfname(curbuf, fname, NULL, FALSE);
@@ -3336,13 +3333,8 @@
 	}
     }
 
-#ifdef FEAT_AUTOCMD
     /* restore curwin/curbuf and a few other things */
     aucmd_restbuf(&aco);
-#else
-    curbuf = old_curbuf;
-    curwin->w_buffer = old_curbuf;
-#endif
 
     if (!buf_valid(newbuf))
 	return NULL;
@@ -3434,8 +3426,10 @@
 	  || dict_add_nr_str(dict, "col",   (long)qfp->qf_col, NULL) == FAIL
 	  || dict_add_nr_str(dict, "vcol",  (long)qfp->qf_viscol, NULL) == FAIL
 	  || dict_add_nr_str(dict, "nr",    (long)qfp->qf_nr, NULL) == FAIL
-	  || dict_add_nr_str(dict, "pattern",  0L, qfp->qf_pattern) == FAIL
-	  || dict_add_nr_str(dict, "text",  0L, qfp->qf_text) == FAIL
+	  || dict_add_nr_str(dict, "pattern",  0L,
+	     qfp->qf_pattern == NULL ? (char_u *)"" : qfp->qf_pattern) == FAIL
+	  || dict_add_nr_str(dict, "text",  0L,
+		   qfp->qf_text == NULL ? (char_u *)"" : qfp->qf_text) == FAIL
 	  || dict_add_nr_str(dict, "type",  0L, buf) == FAIL
 	  || dict_add_nr_str(dict, "valid", (long)qfp->qf_valid, NULL) == FAIL)
 	    return FAIL;
diff -Naur vim70.orig/src/regexp.c vim70/src/regexp.c
--- vim70.orig/src/regexp.c	2006-04-30 08:31:50.000000000 -0700
+++ vim70/src/regexp.c	2006-09-11 08:23:16.000000000 -0700
@@ -3912,7 +3912,7 @@
 		{
 		    colnr_T	    start, end;
 		    colnr_T	    start2, end2;
-		    colnr_T	    col;
+		    colnr_T	    cols;
 
 		    getvvcol(wp, &top, &start, NULL, &end);
 		    getvvcol(wp, &bot, &start2, NULL, &end2);
@@ -3922,9 +3922,9 @@
 			end = end2;
 		    if (top.col == MAXCOL || bot.col == MAXCOL)
 			end = MAXCOL;
-		    col = win_linetabsize(wp,
+		    cols = win_linetabsize(wp,
 				      regline, (colnr_T)(reginput - regline));
-		    if (col < start || col > end - (*p_sel == 'e'))
+		    if (cols < start || cols > end - (*p_sel == 'e'))
 			status = RA_NOMATCH;
 		}
 	    }
@@ -4253,7 +4253,7 @@
 	    {
 		int	i, len;
 		char_u	*opnd;
-		int	opndc, inpc;
+		int	opndc = 0, inpc;
 
 		opnd = OPERAND(scan);
 		/* Safety check (just in case 'encoding' was changed since
diff -Naur vim70.orig/src/screen.c vim70/src/screen.c
--- vim70.orig/src/screen.c	2006-05-05 03:13:55.000000000 -0700
+++ vim70/src/screen.c	2006-09-11 08:23:16.000000000 -0700
@@ -2612,7 +2612,8 @@
 #ifdef FEAT_LINEBREAK
     int		need_showbreak = FALSE;
 #endif
-#if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS))
+#if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
+	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
 # define LINE_ATTR
     int		line_attr = 0;		/* atrribute for the whole line */
 #endif
@@ -2626,7 +2627,7 @@
     int		prev_c = 0;		/* previous Arabic character */
     int		prev_c1 = 0;		/* first composing char for prev_c */
 #endif
-#if defined(FEAT_DIFF) || defined(LINE_ATTR)
+#if defined(LINE_ATTR)
     int		did_line_attr = 0;
 #endif
 
@@ -4116,17 +4117,12 @@
 		    --ptr;	    /* put it back at the NUL */
 		}
 #endif
-#if defined(FEAT_DIFF) || defined(LINE_ATTR)
+#if defined(LINE_ATTR)
 		else if ((
 # ifdef FEAT_DIFF
-			    diff_hlf != (hlf_T)0
-#  ifdef LINE_ATTR
-			    ||
-#  endif
+			    diff_hlf != (hlf_T)0 ||
 # endif
-# ifdef LINE_ATTR
 			    line_attr != 0
-# endif
 			) && (
 # ifdef FEAT_RIGHTLEFT
 			    wp->w_p_rl ? (col >= 0) :
@@ -4237,7 +4233,7 @@
 	 * At end of the text line or just after the last character.
 	 */
 	if (c == NUL
-#if defined(FEAT_DIFF) || defined(LINE_ATTR)
+#if defined(LINE_ATTR)
 		|| did_line_attr == 1
 #endif
 		)
@@ -4258,7 +4254,7 @@
 				|| prevcol == (long)match_hl[0].startcol
 				|| prevcol == (long)match_hl[1].startcol
 				|| prevcol == (long)match_hl[2].startcol)
-# if defined(FEAT_DIFF) || defined(LINE_ATTR)
+# if defined(LINE_ATTR)
 			    && did_line_attr <= 1
 # endif
 			   )
@@ -7103,7 +7099,7 @@
     tabpage_T	    *tp;
 #endif
     static int	    entered = FALSE;		/* avoid recursiveness */
-    static int	    did_outofmem_msg = FALSE;	/* did outofmem message */
+    static int	    done_outofmem_msg = FALSE;	/* did outofmem message */
 
     /*
      * Allocation of the screen buffers is done only when the size changes and
@@ -7133,6 +7129,12 @@
 	return;
     entered = TRUE;
 
+    /*
+     * Note that the window sizes are updated before reallocating the arrays,
+     * thus we must not redraw here!
+     */
+    ++RedrawingDisabled;
+
     win_new_shellsize();    /* fit the windows in the new sized shell */
 
     comp_col();		/* recompute columns for shown command and ruler */
@@ -7205,14 +7207,14 @@
 #endif
 	    || outofmem)
     {
-	if (ScreenLines != NULL || !did_outofmem_msg)
+	if (ScreenLines != NULL || !done_outofmem_msg)
 	{
 	    /* guess the size */
 	    do_outofmem_msg((long_u)((Rows + 1) * Columns));
 
 	    /* Remember we did this to avoid getting outofmem messages over
 	     * and over again. */
-	    did_outofmem_msg = TRUE;
+	    done_outofmem_msg = TRUE;
 	}
 	vim_free(new_ScreenLines);
 	new_ScreenLines = NULL;
@@ -7240,7 +7242,7 @@
     }
     else
     {
-	did_outofmem_msg = FALSE;
+	done_outofmem_msg = FALSE;
 
 	for (new_row = 0; new_row < Rows; ++new_row)
 	{
@@ -7367,6 +7369,7 @@
 #endif
 
     entered = FALSE;
+    --RedrawingDisabled;
 
 #ifdef FEAT_AUTOCMD
     if (starting == 0)
diff -Naur vim70.orig/src/search.c vim70/src/search.c
--- vim70.orig/src/search.c	2006-05-05 05:12:13.000000000 -0700
+++ vim70/src/search.c	2006-09-11 08:23:39.000000000 -0700
@@ -1259,7 +1259,7 @@
 	/*
 	 * Add character and/or line offset
 	 */
-	if (!(options & SEARCH_NOOF) || *pat == ';')
+	if (!(options & SEARCH_NOOF) || (pat != NULL && *pat == ';'))
 	{
 	    if (spats[0].off.line)	/* Add the offset to the line number. */
 	    {
@@ -4826,15 +4826,20 @@
 
 		if ((compl_cont_status & CONT_ADDING) && i == compl_length)
 		{
-		    /* get the next line */
 		    /* IOSIZE > compl_length, so the STRNCPY works */
 		    STRNCPY(IObuff, aux, i);
-		    if (!(     depth < 0
-			    && lnum < end_lnum
-			    && (line = ml_get(++lnum)) != NULL)
-			&& !(	depth >= 0
-			    && !vim_fgets(line = file_line,
-						     LSIZE, files[depth].fp)))
+
+		    /* Get the next line: when "depth" < 0  from the current
+		     * buffer, otherwise from the included file.  Jump to
+		     * exit_matched when past the last line. */
+		    if (depth < 0)
+		    {
+			if (lnum >= end_lnum)
+			    goto exit_matched;
+			line = ml_get(++lnum);
+		    }
+		    else if (vim_fgets(line = file_line,
+						      LSIZE, files[depth].fp))
 			goto exit_matched;
 
 		    /* we read a line, set "already" to check this "line" later
@@ -4871,7 +4876,7 @@
 			goto exit_matched;
 		}
 
-		add_r = ins_compl_add_infercase(aux, i, FALSE,
+		add_r = ins_compl_add_infercase(aux, i, p_ic,
 			curr_fname == curbuf->b_fname ? NULL : curr_fname,
 			dir, reuse);
 		if (add_r == OK)
diff -Naur vim70.orig/src/spell.c vim70/src/spell.c
--- vim70.orig/src/spell.c	2006-05-05 00:49:58.000000000 -0700
+++ vim70/src/spell.c	2006-09-11 08:23:16.000000000 -0700
@@ -2043,8 +2043,8 @@
     int		len;
 # ifdef FEAT_SYN_HL
     int		has_syntax = syntax_present(wp->w_buffer);
-    int		col;
 # endif
+    int		col;
     int		can_spell;
     char_u	*buf = NULL;
     int		buflen = 0;
@@ -2093,9 +2093,8 @@
 	    capcol = (int)(skipwhite(line) - line);
 	else if (curline && wp == curwin)
 	{
-	    int	    col = (int)(skipwhite(line) - line);
-
 	    /* For spellbadword(): check if first word needs a capital. */
+	    col = (int)(skipwhite(line) - line);
 	    if (check_need_cap(lnum, col))
 		capcol = col;
 
@@ -2108,7 +2107,8 @@
 	 * possible. */
 	STRCPY(buf, line);
 	if (lnum < wp->w_buffer->b_ml.ml_line_count)
-	    spell_cat_line(buf + STRLEN(buf), ml_get(lnum + 1), MAXWLEN);
+	    spell_cat_line(buf + STRLEN(buf),
+			  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);
 
 	p = buf + skip;
 	endp = buf + len;
@@ -5060,7 +5060,7 @@
     int		do_rep;
     int		do_repsal;
     int		do_sal;
-    int		do_map;
+    int		do_mapline;
     int		found_map = FALSE;
     hashitem_T	*hi;
     int		l;
@@ -5098,7 +5098,7 @@
     do_sal = spin->si_sal.ga_len == 0;
 
     /* Only do MAP lines when not done in another .aff file already. */
-    do_map = spin->si_map.ga_len == 0;
+    do_mapline = spin->si_map.ga_len == 0;
 
     /*
      * Allocate and init the afffile_T structure.
@@ -5780,7 +5780,7 @@
 			smsg((char_u *)_("Expected MAP count in %s line %d"),
 								 fname, lnum);
 		}
-		else if (do_map)
+		else if (do_mapline)
 		{
 		    int		c;
 
@@ -7507,7 +7507,7 @@
 {
     char_u	*p = p_msm;
     long	start = 0;
-    long	inc = 0;
+    long	incr = 0;
     long	added = 0;
 
     if (!VIM_ISDIGIT(*p))
@@ -7519,7 +7519,7 @@
     ++p;
     if (!VIM_ISDIGIT(*p))
 	return FAIL;
-    inc = (getdigits(&p) * 102) / (SBLOCKSIZE / 10);
+    incr = (getdigits(&p) * 102) / (SBLOCKSIZE / 10);
     if (*p != ',')
 	return FAIL;
     ++p;
@@ -7529,11 +7529,11 @@
     if (*p != NUL)
 	return FAIL;
 
-    if (start == 0 || inc == 0 || added == 0 || inc > start)
+    if (start == 0 || incr == 0 || added == 0 || incr > start)
 	return FAIL;
 
     compress_start = start;
-    compress_inc = inc;
+    compress_inc = incr;
     compress_added = added;
     return OK;
 }
@@ -8291,14 +8291,14 @@
  * Returns the number of nodes used.
  */
     static int
-put_node(fd, node, index, regionmask, prefixtree)
+put_node(fd, node, idx, regionmask, prefixtree)
     FILE	*fd;		/* NULL when only counting */
     wordnode_T	*node;
-    int		index;
+    int		idx;
     int		regionmask;
     int		prefixtree;	/* TRUE for PREFIXTREE */
 {
-    int		newindex = index;
+    int		newindex = idx;
     int		siblingcount = 0;
     wordnode_T	*np;
     int		flags;
@@ -8308,7 +8308,7 @@
 	return 0;
 
     /* Store the index where this node is written. */
-    node->wn_u1.index = index;
+    node->wn_u1.index = idx;
 
     /* Count the number of siblings. */
     for (np = node; np != NULL; np = np->wn_sibling)
@@ -9243,11 +9243,11 @@
  * Add "word[len]" to 'spellfile' as a good or bad word.
  */
     void
-spell_add_word(word, len, bad, index, undo)
+spell_add_word(word, len, bad, idx, undo)
     char_u	*word;
     int		len;
     int		bad;
-    int		index;	    /* "zG" and "zW": zero, otherwise index in
+    int		idx;	    /* "zG" and "zW": zero, otherwise index in
 			       'spellfile' */
     int		undo;	    /* TRUE for "zug", "zuG", "zuw" and "zuW" */
 {
@@ -9261,7 +9261,7 @@
     int		i;
     char_u	*spf;
 
-    if (index == 0)	    /* use internal wordlist */
+    if (idx == 0)	    /* use internal wordlist */
     {
 	if (int_wordlist == NULL)
 	{
@@ -9289,11 +9289,11 @@
 	for (spf = curbuf->b_p_spf, i = 1; *spf != NUL; ++i)
 	{
 	    copy_option_part(&spf, fnamebuf, MAXPATHL, ",");
-	    if (i == index)
+	    if (i == idx)
 		break;
 	    if (*spf == NUL)
 	    {
-		EMSGN(_("E765: 'spellfile' does not have %ld entries"), index);
+		EMSGN(_("E765: 'spellfile' does not have %ld entries"), idx);
 		return;
 	    }
 	}
@@ -10070,6 +10070,7 @@
 
 	/* List the suggestions. */
 	msg_start();
+	msg_row = Rows - 1;	/* for when 'cmdheight' > 1 */
 	lines_left = Rows;	/* avoid more prompt */
 	vim_snprintf((char *)IObuff, IOSIZE, _("Change \"%.*s\" to:"),
 						sug.su_badlen, sug.su_badptr);
@@ -13579,53 +13580,58 @@
 	 * the first "the" to itself. */
 	return;
 
-    /* Check if the word is already there.  Also check the length that is
-     * being replaced "thes," -> "these" is a different suggestion from
-     * "thes" -> "these". */
-    stp = &SUG(*gap, 0);
-    for (i = gap->ga_len; --i >= 0; ++stp)
-	if (stp->st_wordlen == goodlen
-		&& stp->st_orglen == badlen
-		&& STRNCMP(stp->st_word, goodword, goodlen) == 0)
-	{
-	    /*
-	     * Found it.  Remember the word with the lowest score.
-	     */
-	    if (stp->st_slang == NULL)
-		stp->st_slang = slang;
+    if (gap->ga_len == 0)
+	i = -1;
+    else
+    {
+	/* Check if the word is already there.  Also check the length that is
+	 * being replaced "thes," -> "these" is a different suggestion from
+	 * "thes" -> "these". */
+	stp = &SUG(*gap, 0);
+	for (i = gap->ga_len; --i >= 0; ++stp)
+	    if (stp->st_wordlen == goodlen
+		    && stp->st_orglen == badlen
+		    && STRNCMP(stp->st_word, goodword, goodlen) == 0)
+	    {
+		/*
+		 * Found it.  Remember the word with the lowest score.
+		 */
+		if (stp->st_slang == NULL)
+		    stp->st_slang = slang;
 
-	    new_sug.st_score = score;
-	    new_sug.st_altscore = altscore;
-	    new_sug.st_had_bonus = had_bonus;
+		new_sug.st_score = score;
+		new_sug.st_altscore = altscore;
+		new_sug.st_had_bonus = had_bonus;
+
+		if (stp->st_had_bonus != had_bonus)
+		{
+		    /* Only one of the two had the soundalike score computed.
+		     * Need to do that for the other one now, otherwise the
+		     * scores can't be compared.  This happens because
+		     * suggest_try_change() doesn't compute the soundalike
+		     * word to keep it fast, while some special methods set
+		     * the soundalike score to zero. */
+		    if (had_bonus)
+			rescore_one(su, stp);
+		    else
+		    {
+			new_sug.st_word = stp->st_word;
+			new_sug.st_wordlen = stp->st_wordlen;
+			new_sug.st_slang = stp->st_slang;
+			new_sug.st_orglen = badlen;
+			rescore_one(su, &new_sug);
+		    }
+		}
 
-	    if (stp->st_had_bonus != had_bonus)
-	    {
-		/* Only one of the two had the soundalike score computed.
-		 * Need to do that for the other one now, otherwise the
-		 * scores can't be compared.  This happens because
-		 * suggest_try_change() doesn't compute the soundalike
-		 * word to keep it fast, while some special methods set
-		 * the soundalike score to zero. */
-		if (had_bonus)
-		    rescore_one(su, stp);
-		else
+		if (stp->st_score > new_sug.st_score)
 		{
-		    new_sug.st_word = stp->st_word;
-		    new_sug.st_wordlen = stp->st_wordlen;
-		    new_sug.st_slang = stp->st_slang;
-		    new_sug.st_orglen = badlen;
-		    rescore_one(su, &new_sug);
+		    stp->st_score = new_sug.st_score;
+		    stp->st_altscore = new_sug.st_altscore;
+		    stp->st_had_bonus = new_sug.st_had_bonus;
 		}
+		break;
 	    }
-
-	    if (stp->st_score > new_sug.st_score)
-	    {
-		stp->st_score = new_sug.st_score;
-		stp->st_altscore = new_sug.st_altscore;
-		stp->st_had_bonus = new_sug.st_had_bonus;
-	    }
-	    break;
-	}
+    }
 
     if (i < 0 && ga_grow(gap, 1) == OK)
     {
@@ -15656,7 +15662,7 @@
 		    ? MB_STRNICMP(p, pat, STRLEN(pat)) == 0
 		    : STRNCMP(p, pat, STRLEN(pat)) == 0)
 		&& ins_compl_add_infercase(p, (int)STRLEN(p),
-					  FALSE, NULL, *dir, 0) == OK)
+					  p_ic, NULL, *dir, 0) == OK)
 	/* if dir was BACKWARD then honor it just once */
 	*dir = FORWARD;
 }
diff -Naur vim70.orig/src/structs.h vim70/src/structs.h
--- vim70.orig/src/structs.h	2006-04-09 10:57:46.000000000 -0700
+++ vim70/src/structs.h	2006-08-19 16:39:02.000000000 -0700
@@ -2213,18 +2213,20 @@
 
 /*
  * Struct to save values in before executing autocommands for a buffer that is
- * not the current buffer.
+ * not the current buffer.  Without FEAT_AUTOCMD only "curbuf" is remembered.
  */
 typedef struct
 {
     buf_T	*save_buf;	/* saved curbuf */
+#ifdef FEAT_AUTOCMD
     buf_T	*new_curbuf;	/* buffer to be used */
     win_T	*save_curwin;	/* saved curwin, NULL if it didn't change */
     win_T	*new_curwin;	/* new curwin if save_curwin != NULL */
     pos_T	save_cursor;	/* saved cursor pos of save_curwin */
     linenr_T	save_topline;	/* saved topline of save_curwin */
-#ifdef FEAT_DIFF
+# ifdef FEAT_DIFF
     int		save_topfill;	/* saved topfill of save_curwin */
+# endif
 #endif
 } aco_save_T;
 
diff -Naur vim70.orig/src/tag.c vim70/src/tag.c
--- vim70.orig/src/tag.c	2006-04-27 06:11:21.000000000 -0700
+++ vim70/src/tag.c	2006-09-11 09:26:46.000000000 -0700
@@ -3787,6 +3787,7 @@
 {
     int		num_matches, i, ret;
     char_u	**matches, *p;
+    char_u	*full_fname;
     dict_T	*dict;
     tagptrs_T	tp;
     long	is_static;
@@ -3809,9 +3810,10 @@
 	    if (list_append_dict(list, dict) == FAIL)
 		ret = FAIL;
 
+	    full_fname = tag_full_fname(&tp);
 	    if (add_tag_field(dict, "name", tp.tagname, tp.tagname_end) == FAIL
-		    || add_tag_field(dict, "filename", tp.fname,
-							 tp.fname_end) == FAIL
+		    || add_tag_field(dict, "filename", full_fname,
+							 NULL) == FAIL
 		    || add_tag_field(dict, "cmd", tp.command,
 						       tp.command_end) == FAIL
 		    || add_tag_field(dict, "kind", tp.tagkind,
@@ -3819,6 +3821,8 @@
 		    || dict_add_nr_str(dict, "static", is_static, NULL) == FAIL)
 		ret = FAIL;
 
+	    vim_free(full_fname);
+
 	    if (tp.command_end != NULL)
 	    {
 		for (p = tp.command_end + 3;
diff -Naur vim70.orig/src/term.c vim70/src/term.c
--- vim70.orig/src/term.c	2006-05-03 10:34:57.000000000 -0700
+++ vim70/src/term.c	2006-08-19 16:40:11.000000000 -0700
@@ -4783,6 +4783,14 @@
 		return -1;
 	    current_menu = (vimmenu_T *)val;
 	    slen += num_bytes;
+
+	    /* The menu may have been deleted right after it was used, check
+	     * for that. */
+	    if (check_menu_pointer(root_menu, current_menu) == FAIL)
+	    {
+		key_name[0] = KS_EXTRA;
+		key_name[1] = (int)KE_IGNORE;
+	    }
 	}
 # endif
 # ifdef FEAT_GUI_TABLINE
diff -Naur vim70.orig/src/testdir/test56.in vim70/src/testdir/test56.in
--- vim70.orig/src/testdir/test56.in	2005-05-18 08:37:37.000000000 -0700
+++ vim70/src/testdir/test56.in	2006-09-11 09:00:23.000000000 -0700
@@ -3,7 +3,7 @@
 STARTTEST
 :so small.vim
 :"
-:set nocp
+:set nocp viminfo+=nviminfo
 :/^start:/+1,/^end:/-1w! Xtest.vim
 :source Xtest.vim
 _x
diff -Naur vim70.orig/src/ui.c vim70/src/ui.c
--- vim70.orig/src/ui.c	2006-03-27 11:15:09.000000000 -0800
+++ vim70/src/ui.c	2006-09-11 08:23:16.000000000 -0700
@@ -1137,7 +1137,6 @@
     int		len;
 #ifdef FEAT_MBYTE
     char_u	*p;
-    int		i;
 #endif
     int		row1 = clip_star.start.lnum;
     int		col1 = clip_star.start.col;
@@ -1218,6 +1217,8 @@
 #ifdef FEAT_MBYTE
 	    if (enc_dbcs != 0)
 	    {
+		int	i;
+
 		p = ScreenLines + LineOffset[row];
 		for (i = start_col; i < end_col; ++i)
 		    if (enc_dbcs == DBCS_JPNU && p[i] == 0x8e)
diff -Naur vim70.orig/src/undo.c vim70/src/undo.c
--- vim70.orig/src/undo.c	2006-04-21 02:30:59.000000000 -0700
+++ vim70/src/undo.c	2006-09-11 08:23:16.000000000 -0700
@@ -84,7 +84,6 @@
 static void u_unch_branch __ARGS((u_header_T *uhp));
 static u_entry_T *u_get_headentry __ARGS((void));
 static void u_getbot __ARGS((void));
-static int undo_allowed __ARGS((void));
 static int u_savecommon __ARGS((linenr_T, linenr_T, linenr_T));
 static void u_doit __ARGS((int count));
 static void u_undoredo __ARGS((int undo));
@@ -196,7 +195,7 @@
  * Return TRUE when undo is allowed.  Otherwise give an error message and
  * return FALSE.
  */
-    static int
+    int
 undo_allowed()
 {
     /* Don't allow changes when 'modifiable' is off.  */
@@ -1188,7 +1187,7 @@
     int		did_undo;	/* just did an undo */
     int		absolute;	/* used ":undo N" */
 {
-    char	*msg;
+    char	*msgstr;
     u_header_T	*uhp;
     char_u	msgbuf[80];
 
@@ -1206,20 +1205,20 @@
 
     u_oldcount -= u_newcount;
     if (u_oldcount == -1)
-	msg = N_("more line");
+	msgstr = N_("more line");
     else if (u_oldcount < 0)
-	msg = N_("more lines");
+	msgstr = N_("more lines");
     else if (u_oldcount == 1)
-	msg = N_("line less");
+	msgstr = N_("line less");
     else if (u_oldcount > 1)
-	msg = N_("fewer lines");
+	msgstr = N_("fewer lines");
     else
     {
 	u_oldcount = u_newcount;
 	if (u_newcount == 1)
-	    msg = N_("change");
+	    msgstr = N_("change");
 	else
-	    msg = N_("changes");
+	    msgstr = N_("changes");
     }
 
     if (curbuf->b_u_curhead != NULL)
@@ -1245,7 +1244,7 @@
 
     smsg((char_u *)_("%ld %s; %s #%ld  %s"),
 	    u_oldcount < 0 ? -u_oldcount : u_oldcount,
-	    _(msg),
+	    _(msgstr),
 	    did_undo ? _("before") : _("after"),
 	    uhp == NULL ? 0L : uhp->uh_seq,
 	    msgbuf);
diff -Naur vim70.orig/src/version.c vim70/src/version.c
--- vim70.orig/src/version.c	2006-05-03 00:50:42.000000000 -0700
+++ vim70/src/version.c	2006-09-11 09:28:13.000000000 -0700
@@ -667,6 +667,190 @@
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    99,
+/**/
+    98,
+/**/
+    97,
+/**/
+    96,
+/**/
+    95,
+/**/
+    94,
+/**/
+    93,
+/**/
+    92,
+/**/
+    91,
+/**/
+    90,
+/**/
+    89,
+/**/
+    88,
+/**/
+    87,
+/**/
+    86,
+/**/
+    85,
+/**/
+    84,
+/**/
+    83,
+/**/
+    82,
+/**/
+    81,
+/**/
+    80,
+/**/
+    79,
+/**/
+    78,
+/**/
+    77,
+/**/
+    76,
+/**/
+    75,
+/**/
+    73,
+/**/
+    72,
+/**/
+    71,
+/**/
+    70,
+/**/
+    69,
+/**/
+    68,
+/**/
+    67,
+/**/
+    66,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    49,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    41,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    36,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    7,
+/**/
+    6,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
     0
 };
 
diff -Naur vim70.orig/src/vim.h vim70/src/vim.h
--- vim70.orig/src/vim.h	2006-04-30 08:32:38.000000000 -0700
+++ vim70/src/vim.h	2006-09-11 08:24:09.000000000 -0700
@@ -585,7 +585,6 @@
 #define INSERT		0x10	/* Insert mode */
 #define LANGMAP		0x20	/* Language mapping, can be combined with
 				   INSERT and CMDLINE */
-#define MAP_ALL_MODES	0x3f	/* all mode bits used for mapping */
 
 #define REPLACE_FLAG	0x40	/* Replace mode flag */
 #define REPLACE		(REPLACE_FLAG + INSERT)
@@ -605,6 +604,9 @@
 #define CONFIRM		0x800	/* ":confirm" prompt */
 #define SELECTMODE	0x1000	/* Select mode, only for mappings */
 
+#define MAP_ALL_MODES	(0x3f | SELECTMODE)	/* all mode bits used for
+						 * mapping */
+
 /* directions */
 #define FORWARD			1
 #define BACKWARD		(-1)
@@ -1118,6 +1120,7 @@
     EVENT_FOCUSGAINED,		/* got the focus */
     EVENT_FOCUSLOST,		/* lost the focus to another app */
     EVENT_GUIENTER,		/* after starting the GUI */
+    EVENT_GUIFAILED,		/* after starting the GUI failed */
     EVENT_INSERTCHANGE,		/* when changing Insert/Replace mode */
     EVENT_INSERTENTER,		/* when entering Insert mode */
     EVENT_INSERTLEAVE,		/* when leaving Insert mode */
@@ -1983,7 +1986,7 @@
 /* values for vim_handle_signal() that are not a signal */
 #define SIGNAL_BLOCK	-1
 #define SIGNAL_UNBLOCK  -2
-#if !defined(UNIX) && !defined(VMS)
+#if !defined(UNIX) && !defined(VMS) && !defined(OS2)
 # define vim_handle_signal(x) 0
 #endif
 
diff -Naur vim70.orig/src/window.c vim70/src/window.c
--- vim70.orig/src/window.c	2006-05-06 03:54:51.000000000 -0700
+++ vim70/src/window.c	2006-09-11 09:01:59.000000000 -0700
@@ -340,10 +340,10 @@
 		{
 		    tabpage_T	*oldtab = curtab;
 		    tabpage_T	*newtab;
-		    win_T	*wp = curwin;
 
 		    /* First create a new tab with the window, then go back to
 		     * the old tab and close the window there. */
+		    wp = curwin;
 		    if (win_new_tabpage((int)Prenum) == OK
 						     && valid_tabpage(oldtab))
 		    {
@@ -3954,13 +3954,8 @@
     setmouse();			/* in case jumped to/from help buffer */
 #endif
 
-#ifdef FEAT_AUTOCHDIR
-    /* Change directories when the 'acd' option is set on and after
-     * switching windows. */
-    if (p_acd && curbuf->b_ffname != NULL
-				     && vim_chdirfile(curbuf->b_ffname) == OK)
-	shorten_fnames(TRUE);
-#endif
+    /* Change directories when the 'acd' option is set. */
+    DO_AUTOCHDIR
 }
 
 #endif /* FEAT_WINDOWS */

